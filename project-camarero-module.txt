# √çNDICE DE ARCHIVOS (M√ìDULO CAMARERO + SHARED)

1. README.md
2. backend/package.json
3. backend/src/modules/camarero/admin-menu-category.controller.ts
4. backend/src/modules/camarero/admin-menu-category.service.ts
5. backend/src/modules/camarero/admin-menu-item.controller.ts
6. backend/src/modules/camarero/admin-menu-item.service.ts
7. backend/src/modules/camarero/admin-modifier.controller.ts
8. backend/src/modules/camarero/admin-modifier.service.ts
9. backend/src/modules/camarero/camarero.dto.ts
10. backend/src/modules/camarero/kds.controller.ts
11. backend/src/modules/camarero/kds.service.ts
12. backend/src/modules/camarero/public/OrderValidationService.ts
13. backend/src/modules/camarero/public/menu.controller.ts
14. backend/src/modules/camarero/public/menu.service.ts
15. backend/src/modules/camarero/public/order-creation.service.ts
16. backend/src/modules/camarero/public/order-item-processor.service.ts
17. backend/src/modules/camarero/public/order-modification.service.ts
18. backend/src/modules/camarero/public/order-payment.service.ts
19. backend/src/modules/camarero/public/order.controller.ts
20. backend/src/modules/camarero/public/order.dto.ts
21. backend/src/modules/camarero/public/order.service.ts
22. backend/src/modules/camarero/public/order.types.ts
23. backend/src/modules/camarero/waiter.controller.ts
24. backend/src/modules/camarero/waiter.service.ts
25. backend/src/shared/auth/__tests__/auth.service.test.ts
26. backend/src/shared/auth/auth.controller.ts
27. backend/src/shared/auth/auth.dto.ts
28. backend/src/shared/auth/auth.service.ts
29. backend/src/shared/auth/password-reset.controller.ts
30. backend/src/shared/auth/password-reset.service.ts
31. backend/src/shared/auth/registration.controller.ts
32. backend/src/shared/auth/registration.service.ts
33. backend/src/shared/businesses/businesses.controller.ts
34. backend/src/shared/businesses/businesses.service.ts
35. backend/src/shared/middleware/auth.middleware.ts
36. backend/src/shared/middleware/module.middleware.ts
37. backend/src/shared/middleware/multer.config.ts
38. backend/src/shared/middleware/role.middleware.ts
39. backend/src/shared/services/loyalty-points.service.ts
40. backend/src/shared/services/table.service.ts
41. backend/src/shared/uploads/uploads.controller.ts
42. backend/src/shared/uploads/uploads.service.ts
43. backend/src/shared/utils/cloudinary.config.ts
44. backend/src/shared/utils/validation.ts
45. backend/tsconfig.json
46. frontend/index.html
47. frontend/package.json
48. frontend/src/modules/camarero/components/admin/menu/MenuCategoryFormModal.tsx
49. frontend/src/modules/camarero/components/admin/menu/MenuCategoryManager.tsx
50. frontend/src/modules/camarero/components/admin/menu/MenuItemFormModal.tsx
51. frontend/src/modules/camarero/components/admin/menu/MenuItemManager.tsx
52. frontend/src/modules/camarero/components/admin/menu/ModifierGroupsManagementModal.tsx
53. frontend/src/modules/camarero/components/admin/menu/ModifierOptionsManagementModal.tsx
54. frontend/src/modules/camarero/components/public/menu/CategoryAccordion.tsx
55. frontend/src/modules/camarero/components/public/menu/MenuItemCard.tsx
56. frontend/src/modules/camarero/components/public/menu/ModifierGroupInteractiveRenderer.tsx
57. frontend/src/modules/camarero/components/public/menu/ShoppingCartModal.tsx
58. frontend/src/modules/camarero/hooks/useActiveOrderState.ts
59. frontend/src/modules/camarero/hooks/useAdminMenuCategories.ts
60. frontend/src/modules/camarero/hooks/useAdminMenuItems.ts
61. frontend/src/modules/camarero/hooks/useAdminModifierGroups.ts
62. frontend/src/modules/camarero/hooks/useAdminModifierOptions.ts
63. frontend/src/modules/camarero/hooks/useMenuItemConfigurator.ts
64. frontend/src/modules/camarero/hooks/usePublicMenuData.ts
65. frontend/src/modules/camarero/hooks/usePublicOrderCart.ts
66. frontend/src/modules/camarero/hooks/useWaiterPickupItems.ts
67. frontend/src/modules/camarero/pages/OrderStatusPage.tsx
68. frontend/src/modules/camarero/pages/PublicMenuViewPage.tsx
69. frontend/src/modules/camarero/pages/admin/camarero/KitchenDisplayPage.tsx
70. frontend/src/modules/camarero/pages/admin/camarero/MenuManagementPage.tsx
71. frontend/src/modules/camarero/pages/admin/camarero/WaiterOrderManagementPage.tsx
72. frontend/src/modules/camarero/pages/admin/camarero/WaiterPickupPage.tsx
73. frontend/src/modules/camarero/services/kdsService.ts
74. frontend/src/modules/camarero/services/publicOrderApiService.ts
75. frontend/src/modules/camarero/services/waiterService.ts
76. frontend/src/modules/camarero/types/camarero.types.ts
77. frontend/src/modules/camarero/types/menu.types.ts
78. frontend/src/modules/camarero/types/publicOrder.types.ts
79. frontend/src/shared/components/PrivateRoute.tsx
80. frontend/src/shared/components/layout/AdminNavbar.tsx
81. frontend/src/shared/components/layout/AppHeader.tsx
82. frontend/src/shared/components/layout/MainLayout.tsx
83. frontend/src/shared/components/layout/PublicLayout.tsx
84. frontend/src/shared/components/utils/ImageUploadCropper.tsx
85. frontend/src/shared/components/utils/canvasPreview.ts
86. frontend/src/shared/hooks/useLayoutUserData.ts
87. frontend/src/shared/services/axiosInstance.ts
88. frontend/src/shared/services/businessService.ts
89. frontend/src/shared/types/superadmin.types.ts
90. frontend/src/shared/types/user.types.ts
91. frontend/tsconfig.json
92. frontend/vite.config.ts


# CONTENIDO DE ARCHIVOS


// ====== [1] README.md ======
# LoyalPyME üá™üá∏ (v1.21.0)

**LoyalPyME** es una plataforma web integral y modular, desarrollada con un stack **Frontend React (TypeScript, Mantine UI, Vite)** y **Backend Node.js (TypeScript, Express, Prisma, PostgreSQL)**, dise√±ada espec√≠ficamente para Peque√±as y Medianas Empresas (PyMEs). La plataforma se estructura en m√≥dulos activables individualmente por cada negocio cliente, permitiendo una soluci√≥n a medida y adaptada a sus necesidades operativas y de marketing.

- ‚≠ê **LoyalPyME Core (LCo) - M√≥dulo de Fidelizaci√≥n [Estable y Funcional]:**
  Un sistema robusto y completo para la gesti√≥n de programas de lealtad digitales.

  - **Gesti√≥n de Clientes:** Administraci√≥n detallada de clientes, incluyendo su historial de puntos, nivel de fidelizaci√≥n, y actividad.
  - **Sistema de Puntos:** Configuraci√≥n de ratio de puntos por gasto, generaci√≥n de QR para acumulaci√≥n en punto de venta f√≠sico.
  - **Niveles de Fidelizaci√≥n (Tiers):** Creaci√≥n de m√∫ltiples niveles con umbrales personalizables (basados en gasto, visitas, o puntos acumulados) y asignaci√≥n de beneficios exclusivos por nivel (ej. multiplicadores de puntos, acceso a recompensas especiales).
  - **Cat√°logo de Recompensas:** Gesti√≥n de un cat√°logo de recompensas canjeables por puntos, con soporte completo para internacionalizaci√≥n (nombres y descripciones en ES/EN) e im√°genes individuales por recompensa.
  - **Panel de Cliente Interactivo:** Un dashboard personalizado para que los clientes finales consulten su saldo de puntos, nivel actual y progreso hacia el siguiente, visualicen las recompensas disponibles y regalos asignados, canjeen beneficios, y revisen su historial completo de transacciones de fidelizaci√≥n.

- üöÄ **LoyalPyME Camarero (LC) - M√≥dulo de Hosteler√≠a [Ciclo Completo de Pedido y Servicio Validado]:**
  Un m√≥dulo avanzado enfocado en la digitalizaci√≥n y optimizaci√≥n integral del servicio en el sector hostelero (restaurantes, bares, cafeter√≠as), mejorando la eficiencia operativa y la experiencia del cliente.
  - **Funcionalidad Actual Clave:**
    1.  **Gesti√≥n de Carta Digital por el Administrador:** Interfaz administrativa completa y detallada (`/admin/dashboard/camarero/menu-editor`) para crear, editar y organizar:
        - **Categor√≠as del Men√∫:** Con nombre (ES/EN), descripci√≥n (ES/EN), imagen (con recorte), posici√≥n y estado de activaci√≥n.
        - **√çtems del Men√∫:** Dentro de cada categor√≠a, con nombre (ES/EN), descripci√≥n (ES/EN), precio, imagen (con recorte), listado de al√©rgenos, etiquetas (ej. "Vegano", "Popular"), disponibilidad, posici√≥n, tiempo de preparaci√≥n estimado, calor√≠as, SKU y destino KDS.
        - **Grupos de Modificadores:** Asociados a cada √≠tem, con nombre (ES/EN), tipo de interfaz de usuario (`RADIO` para selecci√≥n √∫nica, `CHECKBOX` para m√∫ltiple), y reglas de selecci√≥n (m√≠nimo/m√°ximo, obligatorio).
        - **Opciones de Modificador:** Dentro de cada grupo, con nombre (ES/EN) y ajuste de precio.
    2.  **Visualizaci√≥n de Carta P√∫blica por el Cliente Final:** Acceso mediante URL directa (`/m/:businessSlug/:tableIdentifier?`). Los clientes pueden:
        - Navegar por categor√≠as y ver detalles de cada √≠tem.
        - Personalizar √≠tems seleccionando opciones de los modificadores, con el precio actualiz√°ndose din√°micamente.
    3.  **Flujo de Pedido Completo por el Cliente Final:**
        - **Carrito de Compra Local:** Los √≠tems configurados se a√±aden a un carrito que persiste en el `localStorage`.
        - **Modal de Carrito (`ShoppingCartModal.tsx`):** Permite revisar el pedido, modificar cantidades, eliminar √≠tems y a√±adir notas generales.
        - **Env√≠o y Adici√≥n a Pedido:** Al confirmar, el sistema env√≠a un `CreateOrderPayloadDto` al backend, gestionando inteligentemente si se debe crear un pedido nuevo o a√±adir los √≠tems a uno ya existente.
        - **Procesamiento Backend:** Validaci√≥n exhaustiva de disponibilidad, reglas y precios, con creaci√≥n transaccional en la base de datos.
        - **Feedback al Cliente:** Notificaci√≥n de √©xito y redirecci√≥n a la p√°gina de estado del pedido.
    4.  **Visualizaci√≥n del Estado del Pedido por el Cliente (`OrderStatusPage.tsx`):**
        - Muestra el estado general del pedido y de cada √≠tem (`En preparaci√≥n`, `Listo`, `Servido`).
        - Se actualiza autom√°ticamente mediante polling.
        - Permite al cliente **solicitar la cuenta** para iniciar el proceso de pago.
    5.  **Kitchen Display System (KDS) - Backend y Frontend (Funcional):**
        - **API KDS Backend:** Endpoints validados para obtener y actualizar el estado de los √≠tems de preparaci√≥n.
        - **Interfaz KDS Frontend:** Permite al personal de cocina/barra visualizar los √≠tems por destino y cambiar su estado (`PENDING_KDS` -> `PREPARING` -> `READY`).
    6.  **Interfaz de Camarero y Ciclo de Pago Completo (Funcional):**
        - **Recogida y Entrega:** La interfaz de camarero (`WaiterPickupPage.tsx`) muestra los √≠tems listos para recoger, permitiendo marcarlos como servidos.
        - **Gesti√≥n de Pago:** La interfaz de gesti√≥n (`WaiterOrderManagementPage.tsx`) muestra los pedidos pendientes de pago, permitiendo al camarero marcarlos como `PAID`.
        - **Automatizaci√≥n:** Al marcar como pagado, el sistema libera la mesa y asigna puntos de fidelidad LCo al cliente de forma autom√°tica.

La plataforma LoyalPyME est√° dise√±ada con un enfoque en la **mantenibilidad**, **escalabilidad** y **adaptabilidad**, buscando ser el socio tecnol√≥gico que impulse la eficiencia operativa y el crecimiento sostenible de las PyMEs.

## Visi√≥n y Prop√≥sito ‚ú®

LoyalPyME aspira a ser el **aliado tecnol√≥gico integral de las Peque√±as y Medianas Empresas (PyMEs)**, proporcionando herramientas digitales sofisticadas pero intuitivas y f√°ciles de usar, integradas en una √∫nica plataforma modular que se adapta a las necesidades espec√≠ficas de cada negocio.

Con **LoyalPyME Core (LCo)**, buscamos empoderar a las empresas para que puedan cultivar relaciones m√°s profundas, significativas y duraderas con sus clientes. El objetivo es fomentar la lealtad y la recurrencia a trav√©s de programas de recompensas personalizados, comunicaci√≥n efectiva y una experiencia de cliente gratificante que los haga sentir valorados.

Con el m√≥dulo **LoyalPyME Camarero (LC)**, nuestra visi√≥n es transformar y modernizar la operativa en el sector de la hosteler√≠a. Queremos que los negocios puedan:

- **Modernizar su servicio:** Ofreciendo una experiencia de pedido digital √°gil y sin fricciones directamente desde la mesa del cliente.
- **Reducir errores manuales:** Minimizando las imprecisiones en la toma de comandas y la comunicaci√≥n con cocina/barra.
- **Agilizar la comunicaci√≥n interna:** Optimizando el flujo de informaci√≥n entre el personal de sala, la cocina y la barra a trav√©s del KDS y la interfaz de camarero.
- **Mejorar significativamente la experiencia del cliente final:** Permiti√©ndole explorar la carta a su ritmo, personalizar sus pedidos con total control y transparencia, y seguir el estado de su comanda en tiempo real.
- **Obtener datos operativos valiosos:** Recopilando informaci√≥n sobre ventas, popularidad de √≠tems, y tiempos de preparaci√≥n para la toma de decisiones estrat√©gicas y la optimizaci√≥n continua del negocio.

La plataforma es inherentemente vers√°til: **LoyalPyME Core** es aplicable a una amplia gama de sectores empresariales (retail, servicios profesionales, bienestar, etc.) que busquen implementar programas de fidelizaci√≥n. Por su parte, **LoyalPyME Camarero** ofrece una soluci√≥n especializada, potente y adaptada a las particularidades del sector de la restauraci√≥n, desde peque√±as cafeter√≠as hasta restaurantes con mayor volumen de operaciones. La sinergia entre ambos m√≥dulos permite una experiencia de cliente altamente integrada y datos de negocio enriquecidos.

_(Para un an√°lisis exhaustivo del estado actual del proyecto, incluyendo la versi√≥n actual, los hitos completados en detalle, las decisiones de dise√±o clave y las lecciones aprendidas, consulta nuestro [**PROJECT_STATUS.md**](./PROJECT_STATUS.md). La hoja de ruta completa, el backlog de funcionalidades futuras para ambos m√≥dulos, y la visi√≥n a largo plazo se encuentran detallados en [**DEVELOPMENT_PLAN.md**](./DEVELOPMENT_PLAN.md))._

## Caracter√≠sticas Principales Implementadas ‚úÖ

**Plataforma Base y Gesti√≥n Multi-M√≥dulo:**

- **Panel Super Admin:** Interfaz dedicada (`/superadmin`) para el rol `SUPER_ADMIN`, permitiendo la administraci√≥n global de los negocios clientes registrados. Funcionalidades: listar negocios, ver su estado general (`isActive`), y **activar/desactivar individualmente los m√≥dulos LoyalPyME Core (`isLoyaltyCoreActive`) y LoyalPyME Camarero (`isCamareroActive`)** para cada negocio.
- **Gesti√≥n de M√≥dulos por Negocio:** La funcionalidad de cada m√≥dulo (LCo, LC) se habilita o deshabilita a nivel de la entidad `Business` en la base de datos. El perfil de usuario (`/api/profile`) que se obtiene tras el login incluye estos flags de activaci√≥n para el negocio asociado, permitiendo al frontend adaptar la UI din√°micamente.
- **Control de Acceso Basado en M√≥dulos y Roles (RBAC + MBAC):**
  - **RBAC (Role-Based Access Control):** El acceso a las funcionalidades (APIs backend y componentes UI frontend) est√° condicionado por el rol del usuario (`SUPER_ADMIN`, `BUSINESS_ADMIN`, `CUSTOMER_FINAL`, `KITCHEN_STAFF`, `BAR_STAFF`, y futuro `WAITER`).
  - **MBAC (Module-Based Access Control):** Un middleware backend (`checkModuleActive`) y l√≥gica en frontend verifican que el m√≥dulo requerido est√© activo para el negocio del usuario antes de permitir el acceso a funcionalidades espec√≠ficas de dicho m√≥dulo.

**LoyalPyME Core (LCo) - M√≥dulo de Fidelizaci√≥n [Estable y Funcional]:**

- **Autenticaci√≥n Completa y Segura:**
  - Registro de Negocios con su primer `BUSINESS_ADMIN`.
  - Registro de `CUSTOMER_FINAL` asociados a un negocio espec√≠fico.
  - Login robusto con email/contrase√±a, utilizando JWT para la gesti√≥n de sesiones.
  - Funcionalidad completa de Reseteo de Contrase√±a.
- **Gesti√≥n Avanzada de Clientes (Panel Admin LCo):**
  - Listado paginado con b√∫squeda por nombre/email, filtros y ordenaci√≥n.
  - Funcionalidades CRUD para clientes, incluyendo: notas internas, ajuste manual de puntos, cambio manual de nivel, asignaci√≥n de regalos, activaci√≥n/desactivaci√≥n y marcado como favoritos.
  - Acciones Masivas sobre clientes seleccionados: activar/desactivar, eliminar y ajustar puntos.
- **Sistema de Niveles/Tiers Din√°mico y Configurable (Panel Admin LCo):**
  - CRUD completo para niveles de fidelizaci√≥n y sus beneficios asociados.
  - Configuraci√≥n global del sistema de tiers: base de c√°lculo, periodo y pol√≠ticas de descenso.
- **Gesti√≥n Integral de Recompensas (Panel Admin LCo):**
  - CRUD completo para recompensas canjeables por puntos, con soporte i18n y subida de im√°genes.
- **Flujo de Acumulaci√≥n de Puntos y QR (LCo):**
  - Generaci√≥n de QR √∫nicos y temporales por parte del administrador.
  - Validaci√≥n de QR por parte del cliente mediante escaneo con la c√°mara o introducci√≥n manual.
- **L√≥gica de Tiers y Actualizaci√≥n Autom√°tica (LCo - Backend):** Tarea programada (Cron Job) para recalcular y actualizar el nivel de los clientes.
- **Panel de Cliente Completo (LCo - Frontend - `CustomerDashboardPage.tsx`):**
  - Interfaz organizada en pesta√±as:
    - **Resumen (`SummaryTab.tsx`):** Informaci√≥n clave, barra de progreso al siguiente nivel, y secci√≥n para validar QR.
    - **Recompensas (`RewardsTab.tsx`):** Listado de recompensas canjeables y regalos pendientes.
    - **Actividad (`ActivityTab.tsx`):** Historial paginado de todas las transacciones de puntos.

**M√≥dulo LoyalPyME Camarero (LC) [Ciclo de Pedido Completo Validado]:**

- **Modelo de Datos Robusto para Hosteler√≠a (Backend - Prisma):**
  - Definici√≥n detallada de entidades como `MenuCategory`, `MenuItem`, `ModifierGroup`, `Order`, `OrderItem`, `Table`, `StaffPin`.
- **API de Gesti√≥n de Carta por el Administrador (Backend):**
  - Endpoints CRUD completos y protegidos para gestionar toda la carta digital.
- **Interfaz de Usuario para Gesti√≥n de Carta (Admin Frontend):**
  - Componentes dedicados para un CRUD intuitivo de la estructura de la carta, incluyendo subida y recorte de im√°genes.
- **Visualizaci√≥n de Carta P√∫blica y Flujo de Pedido por Cliente Final:**
  - **Frontend:** P√°gina responsive para visualizaci√≥n y personalizaci√≥n de √≠tems con precios din√°micos.
  - **Carrito de Compra Local:** Con persistencia en `localStorage` y funcionalidades de edici√≥n.
  - **Env√≠o y Adici√≥n de √çtems:** El sistema gestiona inteligentemente si crear un nuevo pedido o a√±adir √≠tems a uno ya existente.
- **Visualizaci√≥n del Estado del Pedido por el Cliente:**
  - P√°gina con polling autom√°tico que muestra el estado del `Order` y de cada `OrderItem`.
  - Incluye la funcionalidad para "Pedir la Cuenta".
- **Kitchen Display System (KDS) - Backend y Frontend:**
  - **API KDS:** Endpoints validados para obtener y actualizar el estado de los √≠tems de preparaci√≥n.
  - **Interfaz KDS:** Permite al personal de cocina/barra visualizar los √≠tems y cambiar su estado de preparaci√≥n.
- **Ciclo de Servicio y Pago Completo (Camarero):**
  - **Recogida:** Interfaz para que el personal de sala vea los √≠tems listos y los marque como servidos.
  - **Pago:** Interfaz para ver los pedidos pendientes de pago y marcarlos como `PAID`.
  - **Automatizaci√≥n:** El marcado como pagado libera la mesa y asigna puntos LCo.

## Estado Actual y Pr√≥ximos Pasos üó∫Ô∏è

La plataforma ha alcanzado la **versi√≥n v1.21.0**.

- **LoyalPyME Core (LCo):** Estable, completamente funcional y probado.
- **Arquitectura Multi-M√≥dulo y Panel Super Admin:** Implementada y operativa.
- **M√≥dulo Camarero (LC):** El ciclo de vida completo de un pedido est√° **completo y validado.**

El **enfoque principal de desarrollo inmediato** es a√±adir funcionalidades avanzadas de gesti√≥n al M√≥dulo Camarero (LC):

1.  ‚≠ê **LC - Dividir la Cuenta (Split Bill):**
    - **Objetivo:** Permitir al personal de sala dividir una cuenta entre m√∫ltiples clientes.

Posteriormente, se abordar√°n funcionalidades como la gesti√≥n de personal con PINs, mejoras en la interfaz del camarero (TPV), y un sistema de reservas.

- Consulta **[PROJECT_STATUS.md](./PROJECT_STATUS.md)** para un an√°lisis detallado.
- Revisa **[DEVELOPMENT_PLAN.md](./DEVELOPMENT_PLAN.md)** para la hoja de ruta completa.

## Tecnolog√≠as Utilizadas üõ†Ô∏è

**Frontend:**
React (v19+, Hooks, Context API), TypeScript, Vite (v5+, bundler y servidor de desarrollo HMR), Mantine UI (v7+, biblioteca de componentes y hooks), Axios (cliente HTTP), React Router DOM (v6+, para enrutamiento SPA), `html5-qrcode` (para escaneo de c√≥digos QR por el cliente en LCo), `react-image-crop` (para recorte de im√°genes en interfaces de administraci√≥n), `i18next` y `react-i18next` (para internacionalizaci√≥n ES/EN con archivos JSON), `zod` (para validaci√≥n de formularios, implementaci√≥n progresiva).

**Backend:**
Node.js (runtime), Express.js (framework web), TypeScript (lenguaje principal), Prisma ORM (v6+, para acceso a base de datos PostgreSQL, gesti√≥n de migraciones y generaci√≥n de cliente tipado), PostgreSQL (sistema de gesti√≥n de base deatos relacional), JSON Web Tokens (JWT) (para autenticaci√≥n stateless), `bcryptjs` (para hashing seguro de contrase√±as), Cloudinary SDK (para almacenamiento y gesti√≥n de im√°genes en la nube), Multer (middleware para manejo de subidas de archivos `multipart/form-data`), Vitest (para testing unitario y de integraci√≥n), Supertest (para testing de API HTTP), Swagger/OpenAPI (`swagger-jsdoc`, `swagger-ui-express`) (para documentaci√≥n interactiva de la API RESTful), `node-cron` (para la ejecuci√≥n de tareas programadas, ej. actualizaci√≥n de tiers en LCo).

## Inicio R√°pido (Desarrollo Local) üöÄ

1.  **Clonar el Repositorio:**
    ```bash
    git clone <URL_DEL_REPOSITORIO_GIT> LoyalPyME
    cd LoyalPyME
    ```
2.  **Configuraci√≥n del Backend (`backend/`):**
    - Instalar dependencias: `yarn install` (o `npm install`).
    - Configurar Variables de Entorno: Copiar `backend/.env.example` a `backend/.env` y rellenar todas las variables.
    - Base de Datos (PostgreSQL debe estar corriendo):
      1.  Crear la base de datos (ej. `loyalpymedb`).
      2.  Desde `backend/`, ejecutar `npx prisma migrate reset`.
      3.  Ejecutar `npx prisma db seed` para poblar con datos de demostraci√≥n.
      4.  Ejecutar `npx ts-node ./scripts/create-superadmin.ts` para crear el Super Administrador.
    - Ejecutar el Backend (desde `backend/`, en dos terminales separadas):
      1.  `yarn dev:build` (o `npx tsc --watch`): Compilaci√≥n continua de TypeScript.
      2.  `yarn dev:run` (o `npx nodemon dist/index.js`): Iniciar servidor Node.js con Nodemon.
3.  **Configuraci√≥n del Frontend (`frontend/`):**
    - Instalar dependencias: `yarn install` (o `npm install`).
    - Ejecutar el Frontend (desde `frontend/`): `yarn dev`.
4.  **Acceso a las Aplicaciones (URLs por defecto):**
    - **Carta P√∫blica:** `https://localhost:5173/m/restaurante-demo-loyalpyme`
    - **Login / Dashboards:** `https://localhost:5173`
    - **Documentaci√≥n API (Swagger):** `http://localhost:3000/api-docs`

**¬°Importante!** Para instrucciones **exhaustivas y detalladas**, consulta la gu√≠a **[SETUP_GUIDE.md](./SETUP_GUIDE.md)**. Para soluciones a problemas comunes, revisa la **[TROUBLESHOOTING_GUIDE.md](./TROUBLESHOOTING_GUIDE.md)**.

---

## Contribuciones ü§ù

Este proyecto es software propietario desarrollado por Olivier Hottelet. No se aceptan contribuciones externas directas en este momento. Si se detectan errores o se tienen sugerencias de mejora, pueden ser comunicadas al propietario. Si el repositorio fuera p√∫blico y permitiera la creaci√≥n de "Issues" en la plataforma de hosting de c√≥digo (ej. GitHub, GitLab), esa ser√≠a la v√≠a formal para reportar bugs o proponer nuevas funcionalidades.

## Licencia üìú

Este proyecto es software propietario.
**Copyright (c) 2024-2025 Olivier Hottelet. Todos los derechos reservados.**

El uso, copia, reproducci√≥n, distribuci√≥n, modificaci√≥n, descompilaci√≥n, ingenier√≠a inversa o cualquier otra forma de explotaci√≥n de este software o su c√≥digo fuente, en su totalidad o en parte, est√° estrictamente prohibido sin el permiso previo, expl√≠cito y por escrito del propietario de los derechos de autor. Este software se considera informaci√≥n confidencial y un secreto comercial.

Para m√°s detalles sobre los t√©rminos de la licencia, consulta el archivo [LICENSE.md](./LICENSE.MD) en el directorio ra√≠z del proyecto.

## Contacto üìß

Para consultas sobre el proyecto, licencias, adquisici√≥n, o cualquier otro asunto relacionado:

- **Olivier Hottelet**
- [olivierhottelet1980@gmail.com](mailto:olivierhottelet1980@gmail.com)



// ====== [2] backend/package.json ======
{
  "name": "backend",
  "version": "1.15.0",
  "main": "dist/index.js",
  "license": "SEE LICENSE IN ../LICENSE.md",
  "scripts": {
    "build": "npx tsc",
    "start": "node dist/index.js",
    "dev:build": "npx tsc --watch",
    "dev:run": "npx nodemon dist/index.js",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "db:seed": "ts-node --compiler-options \"{\\\"module\\\":\\\"commonjs\\\"}\" prisma/seed.ts"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@nestjs/common": "^11.1.2",
    "@nestjs/core": "^11.1.2",
    "@prisma/client": "^6.6.0",
    "@types/multer": "^1.4.12",
    "@types/node-cron": "^3.0.11",
    "@types/streamifier": "^0.1.2",
    "bcryptjs": "^2.4.3",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "cloudinary": "^2.6.0",
    "cors": "^2.8.5",
    "date-fns": "^3.6.0",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.2",
    "node-cron": "^3.0.3",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.2",
    "streamifier": "^0.1.1",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1",
    "uuid": "^10.0.0"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/date-fns": "^2.6.0",
    "@types/dotenv": "^8.2.0",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^20.14.10",
    "@types/supertest": "^6.0.2",
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.8",
    "@types/uuid": "^10.0.0",
    "@vitest/coverage-v8": "^2.0.4",
    "nodemon": "^3.1.4",
    "prisma": "^6.6.0",
    "supertest": "^7.0.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.5.3",
    "vitest": "^2.0.4"
  },
  "resolutions": {
    "@types/express": "^4.17.21",
    "@types/express-serve-static-core": "^4.17.42"
  }
}



// ====== [3] backend/src/modules/camarero/admin-menu-category.controller.ts ======
// backend/src/modules/camarero/admin-menu-category.controller.ts (CORREGIDO)
import { Request, Response, NextFunction } from 'express';
// --- RUTA CORREGIDA ---
import * as menuCategoryAdminService from './admin-menu-category.service';
// --- FIN RUTA CORREGIDA ---

// --- Handlers del Controlador (Sin cambios en la l√≥gica interna) ---
export const createMenuCategoryHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }

    const { name_es, name_en, description_es, description_en, imageUrl, position, isActive } = req.body;

    if (!name_es || typeof name_es !== 'string' || name_es.trim() === '') {
        return res.status(400).json({ message: "El campo 'name_es' (nombre en espa√±ol) es obligatorio." });
    }
    if (name_en !== undefined && name_en !== null && typeof name_en !== 'string') {
        return res.status(400).json({ message: "El campo 'name_en' debe ser un texto o nulo." });
    }
    if (position !== undefined && typeof position !== 'number') {
        return res.status(400).json({ message: "El campo 'position' debe ser un n√∫mero si se proporciona." });
    }
    if (isActive !== undefined && typeof isActive !== 'boolean') {
        return res.status(400).json({ message: "El campo 'isActive' debe ser un booleano si se proporciona." });
    }

    try {
        const categoryData: menuCategoryAdminService.CreateMenuCategoryData = {
            name_es: name_es.trim(),
            name_en: name_en?.trim() || null,
            description_es: description_es?.trim() || null,
            description_en: description_en?.trim() || null,
            imageUrl: imageUrl || null,
            position: typeof position === 'number' ? position : 0,
            isActive: typeof isActive === 'boolean' ? isActive : true,
        };
        const newCategory = await menuCategoryAdminService.createMenuCategory(businessId, categoryData);
        res.status(201).json(newCategory);
    } catch (error: any) {
        if (error.message && error.message.includes('Ya existe una categor√≠a con el nombre')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};

export const getMenuCategoriesHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }
    try {
        const categories = await menuCategoryAdminService.getMenuCategoriesByBusiness(businessId);
        res.status(200).json(categories);
    } catch (error) {
        next(error);
    }
};

export const getMenuCategoryByIdHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }
    try {
        const category = await menuCategoryAdminService.getMenuCategoryById(categoryId, businessId);
        if (!category) {
            return res.status(404).json({ message: "Categor√≠a de men√∫ no encontrada o no pertenece a este negocio." });
        }
        res.status(200).json(category);
    } catch (error) {
        next(error);
    }
};

export const updateMenuCategoryHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }

    const { name_es, name_en, description_es, description_en, imageUrl, position, isActive } = req.body;
    if (Object.keys(req.body).length === 0) {
        return res.status(400).json({ message: "Se requiere al menos un campo para actualizar." });
    }
    if (name_es !== undefined && (typeof name_es !== 'string' || name_es.trim() === '')) {
        return res.status(400).json({ message: "Si se proporciona 'name_es', no puede estar vac√≠o." });
    }
    if (name_en !== undefined && name_en !== null && typeof name_en !== 'string') {
        return res.status(400).json({ message: "Si se proporciona 'name_en', debe ser un texto o nulo." });
    }
    if (position !== undefined && typeof position !== 'number') {
        return res.status(400).json({ message: "Si se proporciona 'position', debe ser un n√∫mero." });
    }
    if (isActive !== undefined && typeof isActive !== 'boolean') {
        return res.status(400).json({ message: "Si se proporciona 'isActive', debe ser un booleano." });
    }
    
    try {
        const updateData: menuCategoryAdminService.UpdateMenuCategoryData = {};
        if (name_es !== undefined) updateData.name_es = name_es.trim();
        if (name_en !== undefined) updateData.name_en = name_en === null ? null : name_en?.trim() || null;
        if (description_es !== undefined) updateData.description_es = description_es === null ? null : description_es?.trim() || null;
        if (description_en !== undefined) updateData.description_en = description_en === null ? null : description_en?.trim() || null;
        if (imageUrl !== undefined) updateData.imageUrl = imageUrl === null ? null : imageUrl || null;
        if (position !== undefined) updateData.position = position;
        if (isActive !== undefined) updateData.isActive = isActive;

        const updatedCategory = await menuCategoryAdminService.updateMenuCategory(categoryId, businessId, updateData);
        res.status(200).json(updatedCategory);
    } catch (error: any) {
        if (error.message && error.message.includes('no encontrada')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('Error de unicidad')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};

export const deleteMenuCategoryHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }
    try {
        const deletedCategory = await menuCategoryAdminService.deleteMenuCategory(categoryId, businessId);
        res.status(200).json({ message: "Categor√≠a de men√∫ eliminada con √©xito.", id: deletedCategory.id });
    } catch (error: any) {
         if (error.message && error.message.includes('no encontrada')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('contiene √≠tems que est√°n actualmente en uso')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};


// ====== [4] backend/src/modules/camarero/admin-menu-category.service.ts ======
// backend/src/camarero/admin-menu-category.service.ts
import { PrismaClient, MenuCategory, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

// Tipo para los datos de creaci√≥n (excluye businessId ya que se pasa como argumento)
export type CreateMenuCategoryData = Omit<Prisma.MenuCategoryCreateInput, 'business' | 'items'>;

// Tipo para los datos de actualizaci√≥n (parcial y excluye relaciones)
export type UpdateMenuCategoryData = Partial<Omit<Prisma.MenuCategoryUpdateInput, 'business' | 'items'>>;


/**
 * Crea una nueva categor√≠a de men√∫ para un negocio espec√≠fico.
 */
export const createMenuCategory = async (
    businessId: string,
    data: CreateMenuCategoryData
): Promise<MenuCategory> => {
    console.log(`[MC_SVC] Creating menu category for business ${businessId}:`, data.name_es);
    try {
        const newCategory = await prisma.menuCategory.create({
            data: {
                ...data,
                business: {
                    connect: { id: businessId }
                }
            }
        });
        return newCategory;
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            // P2002 es error de constraint √∫nico (ej: nombre de categor√≠a ya existe para ese negocio)
            console.warn(`[MC_SVC] Unique constraint violation for business ${businessId}, name: ${data.name_es}`, error.meta);
            throw new Error(`Ya existe una categor√≠a con el nombre '${data.name_es}' en este negocio.`);
        }
        console.error(`[MC_SVC] Error creating menu category for business ${businessId}:`, error);
        throw new Error("Error de base de datos al crear la categor√≠a de men√∫.");
    }
};

/**
 * Obtiene todas las categor√≠as de men√∫ para un negocio, ordenadas por posici√≥n.
 */
export const getMenuCategoriesByBusiness = async (businessId: string): Promise<MenuCategory[]> => {
    console.log(`[MC_SVC] Fetching menu categories for business ${businessId}`);
    try {
        return await prisma.menuCategory.findMany({
            where: { businessId },
            orderBy: { position: 'asc' },
            // Podr√≠amos incluir √≠tems si fuera necesario para alguna vista: include: { items: true }
        });
    } catch (error) {
        console.error(`[MC_SVC] Error fetching menu categories for business ${businessId}:`, error);
        throw new Error("Error al obtener las categor√≠as de men√∫.");
    }
};

/**
 * Obtiene una categor√≠a de men√∫ espec√≠fica por su ID, verificando que pertenezca al negocio.
 */
export const getMenuCategoryById = async (categoryId: string, businessId: string): Promise<MenuCategory | null> => {
    console.log(`[MC_SVC] Fetching menu category ${categoryId} for business ${businessId}`);
    try {
        return await prisma.menuCategory.findFirst({
            where: {
                id: categoryId,
                businessId: businessId
            },
            // include: { items: true } // Opcional: incluir √≠tems al obtener una categor√≠a espec√≠fica
        });
    } catch (error) {
        console.error(`[MC_SVC] Error fetching menu category ${categoryId}:`, error);
        throw new Error("Error al obtener la categor√≠a de men√∫ por ID.");
    }
};

/**
 * Actualiza una categor√≠a de men√∫ existente.
 */
export const updateMenuCategory = async (
    categoryId: string,
    businessId: string,
    data: UpdateMenuCategoryData
): Promise<MenuCategory> => {
    console.log(`[MC_SVC] Updating menu category ${categoryId} for business ${businessId}:`, data);
    try {
        // Verificar que la categor√≠a existe y pertenece al negocio antes de actualizar
        const existingCategory = await prisma.menuCategory.findFirst({
            where: { id: categoryId, businessId: businessId },
            select: { id: true } // Solo necesitamos saber si existe
        });
        if (!existingCategory) {
            throw new Error(`Categor√≠a de men√∫ con ID ${categoryId} no encontrada o no pertenece a este negocio.`);
        }

        return await prisma.menuCategory.update({
            where: { id: categoryId },
            data: data
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            console.warn(`[MC_SVC] Unique constraint violation on update for category ${categoryId}, business ${businessId}:`, error.meta);
            // El mensaje de error podr√≠a ser m√°s espec√≠fico si sabemos qu√© campo caus√≥ el P2002
            throw new Error(`Error de unicidad al actualizar la categor√≠a (ej: el nuevo nombre ya existe).`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            // Este error significa que el registro a actualizar (where: { id: categoryId }) no se encontr√≥.
            // Ya lo manejamos con la verificaci√≥n previa, pero es bueno tenerlo por si acaso.
            throw new Error(`Categor√≠a de men√∫ con ID ${categoryId} no encontrada al intentar actualizar.`);
        }
        if (error instanceof Error && error.message.startsWith('Categor√≠a de men√∫ con ID')) {
            throw error; // Relanzar el error espec√≠fico de "no encontrado"
        }
        console.error(`[MC_SVC] Error updating menu category ${categoryId}:`, error);
        throw new Error("Error de base de datos al actualizar la categor√≠a de men√∫.");
    }
};

/**
 * Elimina una categor√≠a de men√∫.
 * Prisma se encargar√° de eliminar los MenuItems asociados debido a `onDelete: Cascade`.
 */
export const deleteMenuCategory = async (categoryId: string, businessId: string): Promise<MenuCategory> => {
    console.log(`[MC_SVC] Deleting menu category ${categoryId} for business ${businessId}`);
    try {
        // Verificar que la categor√≠a existe y pertenece al negocio antes de eliminar
        const existingCategory = await prisma.menuCategory.findFirst({
            where: { id: categoryId, businessId: businessId },
            select: { id: true }
        });
        if (!existingCategory) {
            throw new Error(`Categor√≠a de men√∫ con ID ${categoryId} no encontrada o no pertenece a este negocio.`);
        }

        // Opcional: Verificar si la categor√≠a tiene √≠tems que a su vez est√°n en pedidos activos si onDelete:Restrict se usara
        // En nuestro caso, MenuCategory -> MenuItem tiene onDelete: Cascade, as√≠ que borrar la categor√≠a borrar√° sus √≠tems.
        // Y MenuItem -> OrderItem tiene onDelete: Restrict, lo que PREVENDR√çA borrar un MenuItem si est√° en un pedido.
        // Esto significa que si una categor√≠a tiene √≠tems que est√°n en pedidos, la eliminaci√≥n de la categor√≠a (que intenta borrar los √≠tems) fallar√°
        // debido a la restricci√≥n en MenuItem. Esto es probablemente el comportamiento deseado.

        return await prisma.menuCategory.delete({
            where: { id: categoryId }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Categor√≠a de men√∫ con ID ${categoryId} no encontrada al intentar eliminar.`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') {
            // Error de Foreign key constraint failed on the field: `MenuItem_categoryId_fkey (index)` (o similar)
            // Esto ocurrir√≠a si intentamos borrar una categor√≠a cuyos √≠tems est√°n en uso (ej: en OrderItem) y la relaci√≥n MenuItem->OrderItem es Restrict.
            console.warn(`[MC_SVC] Failed to delete category ${categoryId} due to foreign key constraint (likely items in use).`);
            throw new Error(`No se puede eliminar la categor√≠a porque contiene √≠tems que est√°n actualmente en uso (ej: en pedidos). Elimine o desvincule esos √≠tems primero.`);
        }
        if (error instanceof Error && error.message.startsWith('Categor√≠a de men√∫ con ID')) {
            throw error; // Relanzar el error espec√≠fico de "no encontrado"
        }
        console.error(`[MC_SVC] Error deleting menu category ${categoryId}:`, error);
        throw new Error("Error de base de datos al eliminar la categor√≠a de men√∫.");
    }
};


// ====== [5] backend/src/modules/camarero/admin-menu-item.controller.ts ======
// backend/src/camarero/admin-menu-item.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as menuItemAdminService from './admin-menu-item.service';
import { Prisma } from '@prisma/client'; // Para tipos de error

// --- Handlers del Controlador ---

// POST /api/camarero/admin/menu/categories/:categoryId/items
export const createMenuItemHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!categoryId) return res.status(400).json({ message: "Se requiere ID de la categor√≠a." });

    const {
        name_es, name_en, description_es, description_en, price, imageUrl,
        allergens, tags, isAvailable, position, preparationTime, calories, kdsDestination, sku
    } = req.body;

    // Validaci√≥n b√°sica (mejorar con Zod)
    if (!name_es || typeof name_es !== 'string' || name_es.trim() === '') {
        return res.status(400).json({ message: "El campo 'name_es' (nombre en espa√±ol) es obligatorio." });
    }
    if (price === undefined || typeof price !== 'number' || price < 0) {
        return res.status(400).json({ message: "El campo 'price' es obligatorio y debe ser un n√∫mero positivo." });
    }
    // Aqu√≠ podr√≠as a√±adir m√°s validaciones para los otros campos (tipos, formatos)

    try {
        const menuItemData: Omit<menuItemAdminService.CreateMenuItemData, 'businessId' | 'categoryId'> = {
            name_es: name_es.trim(),
            name_en: name_en?.trim() || null,
            description_es: description_es?.trim() || null,
            description_en: description_en?.trim() || null,
            price: new Prisma.Decimal(price), // Convertir a Decimal para Prisma
            imageUrl: imageUrl || null,
            allergens: Array.isArray(allergens) ? allergens.filter(a => typeof a === 'string') : [],
            tags: Array.isArray(tags) ? tags.filter(t => typeof t === 'string') : [],
            isAvailable: typeof isAvailable === 'boolean' ? isAvailable : true,
            position: typeof position === 'number' ? position : 0,
            preparationTime: typeof preparationTime === 'number' ? preparationTime : null,
            calories: typeof calories === 'number' ? calories : null,
            kdsDestination: kdsDestination || null,
            sku: sku?.trim() || null
        };
        const newItem = await menuItemAdminService.createMenuItem(businessId, categoryId, menuItemData);
        res.status(201).json(newItem);
    } catch (error: any) {
        if (error.message && (error.message.includes('Ya existe un √≠tem') || error.message.includes('Conflicto de unicidad'))) {
            return res.status(409).json({ message: error.message });
        }
        if (error.message && error.message.startsWith('Categor√≠a con ID')) { // Error del servicio si la categor√≠a no es v√°lida
            return res.status(400).json({ message: error.message });
        }
        next(error);
    }
};

// GET /api/camarero/admin/menu/categories/:categoryId/items
export const getMenuItemsByCategoryHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;
    const { isAvailable } = req.query; // Filtro opcional

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!categoryId) return res.status(400).json({ message: "Se requiere ID de la categor√≠a." });

    try {
        const filter: { isAvailable?: boolean } = {};
        if (isAvailable !== undefined) {
            filter.isAvailable = String(isAvailable).toLowerCase() === 'true';
        }
        const items = await menuItemAdminService.getMenuItemsByCategory(categoryId, businessId, filter);
        res.status(200).json(items);
    } catch (error: any) {
        if (error.message && error.message.startsWith('Categor√≠a con ID')) {
            return res.status(404).json({ message: error.message }); // Si la categor√≠a no existe
        }
        next(error);
    }
};

// GET /api/camarero/admin/menu/items/:itemId
export const getMenuItemByIdHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    try {
        const item = await menuItemAdminService.getMenuItemById(itemId, businessId);
        if (!item) {
            return res.status(404).json({ message: "√çtem de men√∫ no encontrado o no pertenece a este negocio." });
        }
        res.status(200).json(item);
    } catch (error) {
        next(error);
    }
};

// PUT o PATCH /api/camarero/admin/menu/items/:itemId
export const updateMenuItemHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    const updateDataFromRequest = req.body;
    if (Object.keys(updateDataFromRequest).length === 0) {
        return res.status(400).json({ message: "Se requiere al menos un campo para actualizar." });
    }

    try {
        // Construir el objeto de datos para el servicio, procesando cada campo
        const serviceUpdateData: menuItemAdminService.UpdateMenuItemData = {};

        // Campos string opcionales
        if (updateDataFromRequest.name_es !== undefined) serviceUpdateData.name_es = String(updateDataFromRequest.name_es).trim();
        if (updateDataFromRequest.name_en !== undefined) serviceUpdateData.name_en = updateDataFromRequest.name_en === null ? null : String(updateDataFromRequest.name_en).trim() || null;
        if (updateDataFromRequest.description_es !== undefined) serviceUpdateData.description_es = updateDataFromRequest.description_es === null ? null : String(updateDataFromRequest.description_es).trim() || null;
        if (updateDataFromRequest.description_en !== undefined) serviceUpdateData.description_en = updateDataFromRequest.description_en === null ? null : String(updateDataFromRequest.description_en).trim() || null;
        if (updateDataFromRequest.imageUrl !== undefined) serviceUpdateData.imageUrl = updateDataFromRequest.imageUrl === null ? null : String(updateDataFromRequest.imageUrl) || null;
        if (updateDataFromRequest.kdsDestination !== undefined) serviceUpdateData.kdsDestination = updateDataFromRequest.kdsDestination === null ? null : String(updateDataFromRequest.kdsDestination).trim() || null;
        if (updateDataFromRequest.sku !== undefined) serviceUpdateData.sku = updateDataFromRequest.sku === null ? null : String(updateDataFromRequest.sku).trim() || null;
        
        // Campos num√©ricos
        if (updateDataFromRequest.price !== undefined) {
            const priceNum = parseFloat(updateDataFromRequest.price);
            if (isNaN(priceNum) || priceNum < 0) return res.status(400).json({ message: "El precio debe ser un n√∫mero positivo." });
            serviceUpdateData.price = new Prisma.Decimal(priceNum);
        }
        if (updateDataFromRequest.position !== undefined) {
            const posNum = parseInt(updateDataFromRequest.position, 10);
            if (isNaN(posNum)) return res.status(400).json({ message: "La posici√≥n debe ser un n√∫mero." });
            serviceUpdateData.position = posNum;
        }
        if (updateDataFromRequest.preparationTime !== undefined) {
            serviceUpdateData.preparationTime = updateDataFromRequest.preparationTime === null ? null : parseInt(updateDataFromRequest.preparationTime, 10);
            if (serviceUpdateData.preparationTime !== null && isNaN(serviceUpdateData.preparationTime)) return res.status(400).json({ message: "El tiempo de preparaci√≥n debe ser un n√∫mero o nulo." });
        }
        if (updateDataFromRequest.calories !== undefined) {
            serviceUpdateData.calories = updateDataFromRequest.calories === null ? null : parseInt(updateDataFromRequest.calories, 10);
            if (serviceUpdateData.calories !== null && isNaN(serviceUpdateData.calories)) return res.status(400).json({ message: "Las calor√≠as deben ser un n√∫mero o nulo." });
        }

        // Campos booleanos
        if (updateDataFromRequest.isAvailable !== undefined) {
            if (typeof updateDataFromRequest.isAvailable !== 'boolean') return res.status(400).json({ message: "isAvailable debe ser booleano." });
            serviceUpdateData.isAvailable = updateDataFromRequest.isAvailable;
        }

        // Campos array
        if (updateDataFromRequest.allergens !== undefined) {
            if (!Array.isArray(updateDataFromRequest.allergens) || !updateDataFromRequest.allergens.every((s: any) => typeof s === 'string')) return res.status(400).json({ message: "Los al√©rgenos deben ser un array de strings." });
            serviceUpdateData.allergens = updateDataFromRequest.allergens;
        }
        if (updateDataFromRequest.tags !== undefined) {
            if (!Array.isArray(updateDataFromRequest.tags) || !updateDataFromRequest.tags.every((s: any) => typeof s === 'string')) return res.status(400).json({ message: "Las etiquetas deben ser un array de strings." });
            serviceUpdateData.tags = updateDataFromRequest.tags;
        }
        
        // Campo categoryId (para mover el √≠tem de categor√≠a)
        if (updateDataFromRequest.categoryId !== undefined) {
            if (typeof updateDataFromRequest.categoryId !== 'string' || updateDataFromRequest.categoryId.trim() === '') return res.status(400).json({ message: "categoryId debe ser un string v√°lido si se proporciona." });
            serviceUpdateData.categoryId = updateDataFromRequest.categoryId.trim();
        }

        if (Object.keys(serviceUpdateData).length === 0) {
            return res.status(400).json({ message: "No se proporcionaron datos v√°lidos para actualizar." });
        }

        const updatedItem = await menuItemAdminService.updateMenuItem(itemId, businessId, serviceUpdateData);
        res.status(200).json(updatedItem);
    } catch (error: any) {
        if (error.message && (error.message.includes('no encontrado') || error.message.includes('no pertenece'))) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && (error.message.includes('Ya existe un √≠tem') || error.message.includes('Conflicto de unicidad'))) {
            return res.status(409).json({ message: error.message });
        }
         if (error.message && error.message.startsWith('La nueva categor√≠a de destino')) {
            return res.status(400).json({ message: error.message });
        }
        next(error);
    }
};

// DELETE /api/camarero/admin/menu/items/:itemId
export const deleteMenuItemHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    try {
        const deletedItem = await menuItemAdminService.deleteMenuItem(itemId, businessId);
        res.status(200).json({ message: "√çtem de men√∫ eliminado con √©xito.", id: deletedItem.id });
    } catch (error: any) {
         if (error.message && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('est√° en uso')) { // Mensaje del servicio para P2003
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};


// ====== [6] backend/src/modules/camarero/admin-menu-item.service.ts ======
// backend/src/camarero/admin-menu-item.service.ts
import { PrismaClient, MenuItem, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

export type CreateMenuItemData = Omit<
    Prisma.MenuItemCreateInput,
    'business' | 'category' | 'modifierGroups' | 'orderItems'
> & { categoryId: string };

export type UpdateMenuItemData = Partial<
    Omit<Prisma.MenuItemUncheckedUpdateInput, 'id' | 'businessId' | 'createdAt' | 'updatedAt' | 'modifierGroups' | 'orderItems' | 'category'>
    // No necesitamos omitir 'businessId' si no lo vamos a permitir cambiar desde aqu√≠.
    // 'id', 'createdAt', 'updatedAt' son gestionados por Prisma o no deber√≠an ser actualizables.
    // 'category' como relaci√≥n se maneja a trav√©s de 'categoryId'.
    // 'modifierGroups' y 'orderItems' son relaciones que se gestionar√≠an por separado.
>;


export const createMenuItem = async (
    businessId: string,
    categoryId: string,
    data: Omit<CreateMenuItemData, 'businessId' | 'categoryId'>
): Promise<MenuItem> => {
    console.log(`[MI_SVC] Creating menu item for business ${businessId}, category ${categoryId}:`, data.name_es);
    try {
        const categoryExists = await prisma.menuCategory.findFirst({
            where: { id: categoryId, businessId: businessId },
            select: { id: true }
        });
        if (!categoryExists) {
            throw new Error(`Categor√≠a con ID ${categoryId} no encontrada o no pertenece al negocio ${businessId}.`);
        }

        const skuValue = data.sku // data.sku puede ser string | null | undefined
            ? (typeof data.sku === 'string' ? data.sku.trim() : data.sku) // si es string, trim√©alo
            : null; // si es undefined o null, queda como null

        const newItem = await prisma.menuItem.create({
            data: {
                ...data,
                sku: skuValue || null, // Asegurar que se env√≠e null si es cadena vac√≠a despu√©s del trim
                business: { connect: { id: businessId } },
                category: { connect: { id: categoryId } },
            }
        });
        return newItem;
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            console.warn(`[MI_SVC] Unique constraint violation for item:`, data.name_es, error.meta);
            const target = error.meta?.target as string[];
            if (target?.includes('name_es') && target?.includes('categoryId')) {
                 throw new Error(`Ya existe un √≠tem con el nombre '${data.name_es}' en esta categor√≠a.`);
            }
            if (target?.includes('sku') && target?.includes('businessId')) {
                 throw new Error(`Ya existe un √≠tem con el SKU '${data.sku || ''}' en este negocio.`);
            }
            throw new Error(`Conflicto de unicidad al crear el √≠tem de men√∫.`);
        }
        if (error instanceof Error && error.message.startsWith('Categor√≠a con ID')) {
            throw error;
        }
        console.error(`[MI_SVC] Error creating menu item for business ${businessId}:`, error);
        throw new Error("Error de base de datos al crear el √≠tem de men√∫.");
    }
};

export const getMenuItemsByCategory = async (
    categoryId: string,
    businessId: string,
    filter?: { isAvailable?: boolean }
): Promise<MenuItem[]> => {
    console.log(`[MI_SVC] Fetching menu items for category ${categoryId}, business ${businessId}, filter:`, filter);
    try {
        const categoryExists = await prisma.menuCategory.findFirst({
            where: { id: categoryId, businessId: businessId },
            select: { id: true }
        });
        if (!categoryExists) {
            throw new Error(`Categor√≠a con ID ${categoryId} no encontrada o no pertenece al negocio ${businessId}.`);
        }

        const whereClause: Prisma.MenuItemWhereInput = { categoryId };
        if (filter?.isAvailable !== undefined) {
            whereClause.isAvailable = filter.isAvailable;
        }

        return await prisma.menuItem.findMany({
            where: whereClause,
            orderBy: { position: 'asc' },
        });
    } catch (error) {
        if (error instanceof Error && error.message.startsWith('Categor√≠a con ID')) {
            throw error;
        }
        console.error(`[MI_SVC] Error fetching menu items for category ${categoryId}:`, error);
        throw new Error("Error al obtener los √≠tems de men√∫.");
    }
};

export const getMenuItemById = async (menuItemId: string, businessId: string): Promise<MenuItem | null> => {
    console.log(`[MI_SVC] Fetching menu item ${menuItemId} for business ${businessId}`);
    try {
        return await prisma.menuItem.findFirst({
            where: {
                id: menuItemId,
                businessId: businessId
            },
        });
    } catch (error) {
        console.error(`[MI_SVC] Error fetching menu item ${menuItemId}:`, error);
        throw new Error("Error al obtener el √≠tem de men√∫ por ID.");
    }
};

export const updateMenuItem = async (
    menuItemId: string,
    businessId: string,
    data: UpdateMenuItemData
): Promise<MenuItem> => {
    console.log(`[MI_SVC] Updating menu item ${menuItemId} for business ${businessId}:`, data);
    try {
        const existingItem = await prisma.menuItem.findFirst({
            where: { id: menuItemId, businessId: businessId },
            select: { id: true, categoryId: true }
        });
        if (!existingItem) {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado o no pertenece a este negocio.`);
        }

        // --- CORRECCI√ìN en la construcci√≥n de updatePayload ---
        // Clonamos 'data' para no modificar el objeto original y tiparlo correctamente
        const updatePayload: Prisma.MenuItemUpdateInput = { ...data } as Prisma.MenuItemUpdateInput;

        // Manejo espec√≠fico para SKU: si se proporciona, trimear si es string, o pasar null.
        // Si no se proporciona (undefined), no se incluye en updatePayload, por lo que no se actualiza.
        if (data.sku !== undefined) {
            if (typeof data.sku === 'string') {
                updatePayload.sku = data.sku.trim() || null; // Si despu√©s de trim es vac√≠o, se vuelve null
            } else { // data.sku es null
                updatePayload.sku = null;
            }
        }
        // --- FIN CORRECCI√ìN ---
        
        // Si se intenta cambiar categoryId
        if (data.categoryId && typeof data.categoryId === 'string' && data.categoryId !== existingItem.categoryId) {
            const newCategory = await prisma.menuCategory.findFirst({
                where: { id: data.categoryId, businessId: businessId },
                select: { id: true }
            });
            if (!newCategory) {
                throw new Error(`La nueva categor√≠a de destino (ID: ${data.categoryId}) no es v√°lida o no pertenece a este negocio.`);
            }
            // 'categoryId' se pasar√° directamente en updatePayload si est√° en 'data'
            // y el tipo UpdateMenuItemData lo permite (MenuItemUncheckedUpdateInput lo hace).
        }

        return await prisma.menuItem.update({
            where: { id: menuItemId },
            data: updatePayload, // Aqu√≠ updatePayload contiene los campos procesados
        });
    } catch (error) {
        // ... (manejo de errores sin cambios) ...
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            console.warn(`[MI_SVC] Unique constraint violation on update for item ${menuItemId}:`, error.meta);
            const target = error.meta?.target as string[];
            if (target?.includes('name_es') && target?.includes('categoryId')) {
                 throw new Error(`Ya existe un √≠tem con el nuevo nombre en la categor√≠a especificada.`);
            }
            if (target?.includes('sku') && target?.includes('businessId')) {
                 throw new Error(`Ya existe un √≠tem con el nuevo SKU en este negocio.`);
            }
            throw new Error(`Conflicto de unicidad al actualizar el √≠tem de men√∫.`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado al intentar actualizar.`);
        }
        if (error instanceof Error && (error.message.startsWith('√çtem de men√∫ con ID') || error.message.startsWith('La nueva categor√≠a'))) {
            throw error;
        }
        console.error(`[MI_SVC] Error updating menu item ${menuItemId}:`, error);
        throw new Error("Error de base de datos al actualizar el √≠tem de men√∫.");
    }
};

export const deleteMenuItem = async (menuItemId: string, businessId: string): Promise<MenuItem> => {
    console.log(`[MI_SVC] Deleting menu item ${menuItemId} for business ${businessId}`);
    try {
        const existingItem = await prisma.menuItem.findFirst({
            where: { id: menuItemId, businessId: businessId },
            select: { id: true }
        });
        if (!existingItem) {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado o no pertenece a este negocio.`);
        }

        return await prisma.menuItem.delete({
            where: { id: menuItemId }
        });
    } catch (error) {
        // ... (manejo de errores sin cambios) ...
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado al intentar eliminar.`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') {
             console.warn(`[MI_SVC] Failed to delete menu item ${menuItemId} due to foreign key constraint (P2003).`);
            throw new Error(`No se puede eliminar el √≠tem de men√∫ porque est√° en uso (ej: en pedidos existentes). Considere desactivarlo en su lugar.`);
        }
        if (error instanceof Error && error.message.startsWith('√çtem de men√∫ con ID')) {
            throw error;
        }
        console.error(`[MI_SVC] Error deleting menu item ${menuItemId}:`, error);
        throw new Error("Error de base de datos al eliminar el √≠tem de men√∫.");
    }
};


// ====== [7] backend/src/modules/camarero/admin-modifier.controller.ts ======
// backend/src/camarero/admin-modifier.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as modifierAdminService from './admin-modifier.service';
import { Prisma } from '@prisma/client'; // Para tipos de error

// === Handlers para ModifierGroup ===

// POST /api/camarero/admin/menu/items/:itemId/modifier-groups
export const createModifierGroupHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    const { name_es, name_en, uiType, minSelections, maxSelections, position, isRequired } = req.body;

    // Validaci√≥n b√°sica (mejorar con Zod)
    if (!name_es || typeof name_es !== 'string' || name_es.trim() === '') {
        return res.status(400).json({ message: "El campo 'name_es' (nombre en espa√±ol) es obligatorio para el grupo." });
    }
    // A√±adir m√°s validaciones para uiType, minSelections, maxSelections, etc.

    try {
        const groupData: Omit<modifierAdminService.CreateModifierGroupData, 'businessId' | 'menuItemId'> = {
            name_es: name_es.trim(),
            name_en: name_en?.trim() || null,
            uiType: uiType || "RADIO", // Valor por defecto si no se provee
            minSelections: typeof minSelections === 'number' ? minSelections : 0,
            maxSelections: typeof maxSelections === 'number' ? maxSelections : 1,
            position: typeof position === 'number' ? position : 0,
            isRequired: typeof isRequired === 'boolean' ? isRequired : false,
        };
        const newGroup = await modifierAdminService.createModifierGroup(businessId, itemId, groupData);
        res.status(201).json(newGroup);
    } catch (error: any) {
        if (error.message && (error.message.includes('Ya existe un grupo') || error.message.startsWith('√çtem de men√∫ con ID'))) {
            return res.status(error.message.startsWith('√çtem de men√∫ con ID') ? 404 : 409).json({ message: error.message });
        }
        next(error);
    }
};

// GET /api/camarero/admin/menu/items/:itemId/modifier-groups
export const getModifierGroupsByMenuItemHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    try {
        const groups = await modifierAdminService.getModifierGroupsByMenuItem(itemId, businessId);
        res.status(200).json(groups);
    } catch (error: any) {
        if (error.message && error.message.startsWith('√çtem de men√∫ con ID')) {
            return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

// PUT o PATCH /api/camarero/admin/modifier-groups/:modifierGroupId
export const updateModifierGroupHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { modifierGroupId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierGroupId) return res.status(400).json({ message: "Se requiere ID del grupo de modificadores." });

    const updateDataFromRequest = req.body;
    if (Object.keys(updateDataFromRequest).length === 0) {
        return res.status(400).json({ message: "Se requiere al menos un campo para actualizar." });
    }
    // Aqu√≠ ir√≠an validaciones m√°s detalladas para los campos de updateDataFromRequest

    try {
        // No es necesario construir el objeto 'serviceUpdateData' aqu√≠ si el tipo del servicio es suficientemente permisivo
        // y los nombres de campo coinciden. El servicio se encarga de la l√≥gica.
        const updatedGroup = await modifierAdminService.updateModifierGroup(modifierGroupId, businessId, updateDataFromRequest);
        res.status(200).json(updatedGroup);
    } catch (error: any) {
        if (error.message && error.message.startsWith('Grupo de modificadores con ID')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('Error de unicidad')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};

// DELETE /api/camarero/admin/modifier-groups/:modifierGroupId
export const deleteModifierGroupHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { modifierGroupId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierGroupId) return res.status(400).json({ message: "Se requiere ID del grupo de modificadores." });

    try {
        const deletedGroup = await modifierAdminService.deleteModifierGroup(modifierGroupId, businessId);
        res.status(200).json({ message: "Grupo de modificadores eliminado con √©xito.", id: deletedGroup.id });
    } catch (error: any) {
        if (error.message && error.message.startsWith('Grupo de modificadores con ID')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('opciones est√° en uso')) { // Mensaje del servicio para P2003
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};


// === Handlers para ModifierOption ===

// POST /api/camarero/admin/modifier-groups/:modifierGroupId/options
export const createModifierOptionHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Para verificar pertenencia del grupo padre
    const { modifierGroupId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierGroupId) return res.status(400).json({ message: "Se requiere ID del grupo de modificadores." });

    const { name_es, name_en, priceAdjustment, position, isDefault, isAvailable } = req.body;

    if (!name_es || typeof name_es !== 'string' || name_es.trim() === '') {
        return res.status(400).json({ message: "El campo 'name_es' es obligatorio para la opci√≥n." });
    }
    // A√±adir m√°s validaciones (priceAdjustment debe ser n√∫mero, etc.)

    try {
        const optionData: Omit<modifierAdminService.CreateModifierOptionData, 'groupId'> = {
            name_es: name_es.trim(),
            name_en: name_en?.trim() || null,
            priceAdjustment: priceAdjustment === undefined ? 0 : new Prisma.Decimal(priceAdjustment),
            position: typeof position === 'number' ? position : 0,
            isDefault: typeof isDefault === 'boolean' ? isDefault : false,
            isAvailable: typeof isAvailable === 'boolean' ? isAvailable : true,
        };
        const newOption = await modifierAdminService.createModifierOption(modifierGroupId, businessId, optionData);
        res.status(201).json(newOption);
    } catch (error: any) {
        if (error.message && (error.message.includes('Ya existe una opci√≥n') || error.message.startsWith('Grupo de modificadores con ID'))) {
            return res.status(error.message.startsWith('Grupo de modificadores con ID') ? 404 : 409).json({ message: error.message });
        }
        next(error);
    }
};

// GET /api/camarero/admin/modifier-groups/:modifierGroupId/options
export const getModifierOptionsByGroupHandler = async (req: Request, res: Response, next: NextFunction) => {
    // businessId no es estrictamente necesario aqu√≠ si el servicio conf√≠a en que modifierGroupId es v√°lido
    // pero se podr√≠a a√±adir una capa extra de verificaci√≥n si se desea.
    const { modifierGroupId } = req.params;
    if (!modifierGroupId) return res.status(400).json({ message: "Se requiere ID del grupo de modificadores." });

    try {
        // El servicio getModifierOptionsByGroup podr√≠a necesitar businessId si queremos verificar que el grupo
        // realmente pertenece al negocio del admin autenticado, ANTES de buscar las opciones.
        // Por ahora, el servicio actual no lo requiere, pero es una consideraci√≥n de seguridad/l√≥gica.
        const options = await modifierAdminService.getModifierOptionsByGroup(modifierGroupId);
        res.status(200).json(options);
    } catch (error) {
        next(error);
    }
};

// PUT o PATCH /api/camarero/admin/modifier-options/:modifierOptionId
export const updateModifierOptionHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Para verificar pertenencia
    const { modifierOptionId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierOptionId) return res.status(400).json({ message: "Se requiere ID de la opci√≥n de modificador." });

    const updateDataFromRequest = req.body;
    if (Object.keys(updateDataFromRequest).length === 0) {
        return res.status(400).json({ message: "Se requiere al menos un campo para actualizar." });
    }
    // Aqu√≠ ir√≠an validaciones m√°s detalladas

    try {
        const serviceUpdateData: modifierAdminService.UpdateModifierOptionData = { ...updateDataFromRequest };
        if (updateDataFromRequest.priceAdjustment !== undefined) {
            serviceUpdateData.priceAdjustment = new Prisma.Decimal(updateDataFromRequest.priceAdjustment);
        }
        // ... procesar otros campos si necesitan conversi√≥n o validaci√≥n espec√≠fica ...

        const updatedOption = await modifierAdminService.updateModifierOption(modifierOptionId, businessId, serviceUpdateData);
        res.status(200).json(updatedOption);
    } catch (error: any) {
        if (error.message && error.message.startsWith('Opci√≥n de modificador con ID')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('Error de unicidad')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};

// DELETE /api/camarero/admin/modifier-options/:modifierOptionId
export const deleteModifierOptionHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Para verificar pertenencia
    const { modifierOptionId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierOptionId) return res.status(400).json({ message: "Se requiere ID de la opci√≥n de modificador." });

    try {
        const deletedOption = await modifierAdminService.deleteModifierOption(modifierOptionId, businessId);
        res.status(200).json({ message: "Opci√≥n de modificador eliminada con √©xito.", id: deletedOption.id });
    } catch (error: any) {
        if (error.message && error.message.startsWith('Opci√≥n de modificador con ID')) {
            return res.status(404).json({ message: error.message });
        }
         if (error.message && error.message.includes('est√° en uso')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};


// ====== [8] backend/src/modules/camarero/admin-modifier.service.ts ======
// backend/src/camarero/admin-modifier.service.ts
import { PrismaClient, ModifierGroup, ModifierOption, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

// --- TIPOS PARA ModifierGroup ---
export type CreateModifierGroupData = Omit<Prisma.ModifierGroupCreateInput, 'menuItem' | 'business' | 'options'>;
export type UpdateModifierGroupData = Partial<Omit<Prisma.ModifierGroupUpdateInput, 'menuItem' | 'business' | 'options'>>;

// --- TIPOS PARA ModifierOption ---
export type CreateModifierOptionData = Omit<Prisma.ModifierOptionCreateInput, 'group' | 'orderItems'>;
export type UpdateModifierOptionData = Partial<Omit<Prisma.ModifierOptionUpdateInput, 'group' | 'orderItems'>>;

// === L√ìGICA PARA ModifierGroup ===

/**
 * Crea un nuevo grupo de modificadores para un √≠tem de men√∫ espec√≠fico.
 */
export const createModifierGroup = async (
    businessId: string,
    menuItemId: string,
    data: Omit<CreateModifierGroupData, 'businessId' | 'menuItemId'>
): Promise<ModifierGroup> => {
    console.log(`[MOD_SVC] Creating modifier group for menuItem ${menuItemId}, business ${businessId}:`, data.name_es);
    try {
        // Verificar que el MenuItem pertenece al businessId
        const menuItemExists = await prisma.menuItem.findFirst({
            where: { id: menuItemId, businessId: businessId },
            select: { id: true }
        });
        if (!menuItemExists) {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado o no pertenece al negocio ${businessId}.`);
        }

        return await prisma.modifierGroup.create({
            data: {
                ...data,
                menuItem: { connect: { id: menuItemId } },
                business: { connect: { id: businessId } } // Conectar tambi√©n al negocio
            }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            throw new Error(`Ya existe un grupo de modificadores con el nombre '${data.name_es}' para este √≠tem de men√∫.`);
        }
        if (error instanceof Error && error.message.startsWith('√çtem de men√∫ con ID')) throw error;
        console.error(`[MOD_SVC] Error creating modifier group for menuItem ${menuItemId}:`, error);
        throw new Error("Error de base de datos al crear el grupo de modificadores.");
    }
};

/**
 * Obtiene todos los grupos de modificadores para un √≠tem de men√∫.
 */
export const getModifierGroupsByMenuItem = async (menuItemId: string, businessId: string): Promise<ModifierGroup[]> => {
    console.log(`[MOD_SVC] Fetching modifier groups for menuItem ${menuItemId}, business ${businessId}`);
    try {
        // Verificar que el MenuItem pertenece al businessId (opcional, pero buena pr√°ctica)
        const menuItemExists = await prisma.menuItem.count({ where: { id: menuItemId, businessId: businessId }});
        if (menuItemExists === 0) {
             throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado o no pertenece al negocio ${businessId}.`);
        }

        return await prisma.modifierGroup.findMany({
            where: { menuItemId: menuItemId },
            orderBy: { position: 'asc' },
            include: { options: { orderBy: { position: 'asc' } } } // Incluir opciones ordenadas
        });
    } catch (error) {
        if (error instanceof Error && error.message.startsWith('√çtem de men√∫ con ID')) throw error;
        console.error(`[MOD_SVC] Error fetching modifier groups for menuItem ${menuItemId}:`, error);
        throw new Error("Error al obtener los grupos de modificadores.");
    }
};

/**
 * Actualiza un grupo de modificadores existente.
 */
export const updateModifierGroup = async (
    modifierGroupId: string,
    businessId: string, // Para verificar pertenencia
    data: UpdateModifierGroupData
): Promise<ModifierGroup> => {
    console.log(`[MOD_SVC] Updating modifier group ${modifierGroupId} for business ${businessId}:`, data);
    try {
        const existingGroup = await prisma.modifierGroup.findFirst({
            where: { id: modifierGroupId, businessId: businessId }, // Asegurar que el grupo pertenece al negocio
            select: { id: true }
        });
        if (!existingGroup) {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado o no pertenece a este negocio.`);
        }
        return await prisma.modifierGroup.update({
            where: { id: modifierGroupId },
            data: data
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            throw new Error(`Error de unicidad al actualizar el grupo de modificadores (ej: el nuevo nombre ya existe para el √≠tem).`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado.`);
        }
        if (error instanceof Error && error.message.startsWith('Grupo de modificadores con ID')) throw error;
        console.error(`[MOD_SVC] Error updating modifier group ${modifierGroupId}:`, error);
        throw new Error("Error de base de datos al actualizar el grupo de modificadores.");
    }
};

/**
 * Elimina un grupo de modificadores (y sus opciones en cascada).
 */
export const deleteModifierGroup = async (modifierGroupId: string, businessId: string): Promise<ModifierGroup> => {
    console.log(`[MOD_SVC] Deleting modifier group ${modifierGroupId} for business ${businessId}`);
    try {
        const existingGroup = await prisma.modifierGroup.findFirst({
            where: { id: modifierGroupId, businessId: businessId },
            select: { id: true }
        });
        if (!existingGroup) {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado o no pertenece a este negocio.`);
        }
        // Prisma maneja el borrado en cascada de ModifierOption debido a la relaci√≥n
        return await prisma.modifierGroup.delete({
            where: { id: modifierGroupId }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado.`);
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') {
            throw new Error(`No se puede eliminar el grupo de modificadores porque una de sus opciones est√° en uso (ej: en pedidos).`);
        }
        if (error instanceof Error && error.message.startsWith('Grupo de modificadores con ID')) throw error;
        console.error(`[MOD_SVC] Error deleting modifier group ${modifierGroupId}:`, error);
        throw new Error("Error de base de datos al eliminar el grupo de modificadores.");
    }
};


// === L√ìGICA PARA ModifierOption ===

/**
 * Crea una nueva opci√≥n de modificador para un grupo espec√≠fico.
 */
export const createModifierOption = async (
    modifierGroupId: string,
    businessId: string, // Para verificar que el grupo padre pertenece al negocio
    data: Omit<CreateModifierOptionData, 'groupId'>
): Promise<ModifierOption> => {
    console.log(`[MOD_SVC] Creating modifier option for group ${modifierGroupId}, business ${businessId}:`, data.name_es);
    try {
        // Verificar que el ModifierGroup padre pertenece al businessId
        const groupExists = await prisma.modifierGroup.findFirst({
            where: { id: modifierGroupId, businessId: businessId },
            select: { id: true }
        });
        if (!groupExists) {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado o no pertenece al negocio ${businessId}.`);
        }

        return await prisma.modifierOption.create({
            data: {
                ...data,
                group: { connect: { id: modifierGroupId } }
            }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            throw new Error(`Ya existe una opci√≥n con el nombre '${data.name_es}' en este grupo de modificadores.`);
        }
        if (error instanceof Error && error.message.startsWith('Grupo de modificadores con ID')) throw error;
        console.error(`[MOD_SVC] Error creating modifier option for group ${modifierGroupId}:`, error);
        throw new Error("Error de base de datos al crear la opci√≥n de modificador.");
    }
};

/**
 * Obtiene todas las opciones para un grupo de modificadores espec√≠fico.
 * (La verificaci√≥n de pertenencia del grupo al negocio ya se har√≠a al obtener/validar el grupo)
 */
export const getModifierOptionsByGroup = async (modifierGroupId: string): Promise<ModifierOption[]> => {
    console.log(`[MOD_SVC] Fetching modifier options for group ${modifierGroupId}`);
    try {
        return await prisma.modifierOption.findMany({
            where: { groupId: modifierGroupId },
            orderBy: { position: 'asc' }
        });
    } catch (error) {
        console.error(`[MOD_SVC] Error fetching modifier options for group ${modifierGroupId}:`, error);
        throw new Error("Error al obtener las opciones de modificadores.");
    }
};

/**
 * Actualiza una opci√≥n de modificador existente.
 */
export const updateModifierOption = async (
    modifierOptionId: string,
    businessId: string, // Para verificar que la opci√≥n pertenece a un grupo de ese negocio
    data: UpdateModifierOptionData
): Promise<ModifierOption> => {
    console.log(`[MOD_SVC] Updating modifier option ${modifierOptionId} for business ${businessId}:`, data);
    try {
        // Verificar que la opci√≥n pertenece a un grupo del negocio
        const existingOption = await prisma.modifierOption.findFirst({
            where: {
                id: modifierOptionId,
                group: { businessId: businessId } // Verificar a trav√©s de la relaci√≥n con el grupo
            },
            select: { id: true }
        });
        if (!existingOption) {
            throw new Error(`Opci√≥n de modificador con ID ${modifierOptionId} no encontrada o no pertenece a este negocio.`);
        }

        return await prisma.modifierOption.update({
            where: { id: modifierOptionId },
            data: data
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            throw new Error(`Error de unicidad al actualizar la opci√≥n (ej: el nuevo nombre ya existe en el grupo).`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Opci√≥n de modificador con ID ${modifierOptionId} no encontrada.`);
        }
        if (error instanceof Error && error.message.startsWith('Opci√≥n de modificador con ID')) throw error;
        console.error(`[MOD_SVC] Error updating modifier option ${modifierOptionId}:`, error);
        throw new Error("Error de base de datos al actualizar la opci√≥n de modificador.");
    }
};

/**
 * Elimina una opci√≥n de modificador.
 */
export const deleteModifierOption = async (modifierOptionId: string, businessId: string): Promise<ModifierOption> => {
    console.log(`[MOD_SVC] Deleting modifier option ${modifierOptionId} for business ${businessId}`);
    try {
        const existingOption = await prisma.modifierOption.findFirst({
            where: {
                id: modifierOptionId,
                group: { businessId: businessId }
            },
            select: { id: true }
        });
        if (!existingOption) {
            throw new Error(`Opci√≥n de modificador con ID ${modifierOptionId} no encontrada o no pertenece a este negocio.`);
        }
        // Prisma maneja el borrado en cascada si esta opci√≥n estuviera en OrderItemModifierOption
        // debido a la relaci√≥n en ese modelo de uni√≥n.
        return await prisma.modifierOption.delete({
            where: { id: modifierOptionId }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Opci√≥n de modificador con ID ${modifierOptionId} no encontrada.`);
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') {
            // Foreign key constraint failed on the field: `OrderItemModifierOption_modifierOptionId_fkey (index)`
            throw new Error(`No se puede eliminar la opci√≥n porque est√° en uso (ej: en pedidos existentes).`);
        }
        if (error instanceof Error && error.message.startsWith('Opci√≥n de modificador con ID')) throw error;
        console.error(`[MOD_SVC] Error deleting modifier option ${modifierOptionId}:`, error);
        throw new Error("Error de base de datos al eliminar la opci√≥n de modificador.");
    }
};


// ====== [9] backend/src/modules/camarero/camarero.dto.ts ======
// backend/src/camarero/camarero.dto.ts
// Version: 1.2.0 (Add WaiterOrderListItemDto)

import { OrderItemStatus, OrderStatus, OrderType } from '@prisma/client'; // A√±adido OrderType

/**
 * DTO para la informaci√≥n de un modificador seleccionado que se muestra al camarero
 * como parte de un √≠tem listo para recoger.
 */
export interface WaiterSelectedModifierDto {
  optionName_es: string | null;
  optionName_en: string | null;
}

/**
 * DTO para cada √≠tem de pedido que est√° listo para ser recogido y servido por el personal de camareros.
 * Esta es la estructura de datos que el endpoint GET /api/camarero/staff/ready-for-pickup devolver√°.
 */
export interface ReadyPickupItemDto {
  orderItemId: string;
  orderId: string;
  orderNumber: string;
  orderCreatedAt: Date;
  tableIdentifier: string | null;
  itemNameSnapshot_es: string | null;
  itemNameSnapshot_en: string | null;
  quantity: number;
  itemNotes: string | null;
  kdsDestination: string | null;
  selectedModifiers: WaiterSelectedModifierDto[];
  currentOrderItemStatus: OrderItemStatus;
}

/**
 * DTO para el payload del endpoint que permite al camarero marcar un OrderItem como SERVED.
 * Usado en: PATCH /api/camarero/staff/order-items/:orderItemId/status
 */
export interface MarkOrderItemServedPayloadDto {
  newStatus: typeof OrderItemStatus.SERVED;
}

/**
 * DTO para la respuesta est√°ndar al actualizar el estado de un OrderItem
 * desde la interfaz de camarero o KDS.
 */
export interface OrderItemStatusUpdateResponseDto {
  message: string;
  orderItemId: string;
  newStatus: OrderItemStatus;
  orderStatus?: OrderStatus;
}

/**
 * DTO para el payload del endpoint que permite al personal solicitar la cuenta.
 * Usado en: POST /api/camarero/staff/order/:orderId/request-bill
 */
export interface RequestBillPayloadDto {
  paymentPreference?: string;
}

/**
 * DTO para el payload del endpoint que permite al camarero marcar un pedido como PAGADO.
 * Usado en: POST /api/camarero/staff/order/:orderId/mark-as-paid
 */
export interface MarkOrderAsPaidPayloadDto {
  method?: string;
  notes?: string;
}

// ---- NUEVO DTO ----
/**
 * DTO para representar un √≠tem en la lista de pedidos para la interfaz del camarero.
 * Usado en: GET /api/camarero/staff/orders
 */
export interface WaiterOrderListItemDto {
  orderId: string;
  orderNumber: string;
  tableIdentifier: string | null;
  status: OrderStatus;
  finalAmount: number; // O string si prefieres manejarlo como string en el frontend inicialmente
  itemCount: number; // N√∫mero total de √≠tems (no cancelados) en el pedido
  customerName?: string | null; // Nombre del cliente LCo si est√° asociado
  createdAt: Date; // Fecha de creaci√≥n del pedido
  isBillRequested?: boolean; // Para saber si la cuenta ya fue solicitada
  orderType?: OrderType | null; // Tipo de pedido
}
// ---- FIN NUEVO DTO ----


// ====== [10] backend/src/modules/camarero/kds.controller.ts ======
// backend/src/camarero/kds.controller.ts
import { Request, Response, NextFunction } from 'express';
import { OrderItemStatus } from '@prisma/client'; // Para validar el enum
import * as kdsService from './kds.service';

/**
 * Handler para GET /api/camarero/kds/items
 * Obtiene los √≠tems de pedido para una destino KDS espec√≠fico.
 */
export const getItemsForKdsHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Asumimos que authenticateToken ya lo a√±adi√≥
    const { destination, status } = req.query;

    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado en la sesi√≥n del usuario." });
    }
    if (!destination || typeof destination !== 'string' || destination.trim() === '') {
        return res.status(400).json({ message: "El par√°metro 'destination' (destino KDS) es obligatorio." });
    }

    let statusFilter: OrderItemStatus[] | undefined = undefined;
    if (status) {
        if (typeof status === 'string') {
            const singleStatus = status.toUpperCase() as OrderItemStatus;
            if (Object.values(OrderItemStatus).includes(singleStatus)) {
                statusFilter = [singleStatus];
            } else {
                return res.status(400).json({ message: `Valor de 'status' inv√°lido: ${status}` });
            }
        } else if (Array.isArray(status)) {
            statusFilter = [];
            for (const s of status) {
                if (typeof s === 'string') {
                    const singleStatus = s.toUpperCase() as OrderItemStatus;
                     if (Object.values(OrderItemStatus).includes(singleStatus)) {
                        statusFilter.push(singleStatus);
                    } else {
                        return res.status(400).json({ message: `Valor de 'status' inv√°lido en el array: ${s}` });
                    }
                } else {
                     return res.status(400).json({ message: "Todos los valores de 'status' en el array deben ser strings." });
                }
            }
            if (statusFilter.length === 0) statusFilter = undefined; // Si el array queda vac√≠o, no filtrar
        } else {
            return res.status(400).json({ message: "El par√°metro 'status' debe ser un string o un array de strings." });
        }
    }
    
    console.log(`[KDS CTRL] Request for KDS items. Business: ${businessId}, Dest: ${destination}, Status: ${statusFilter?.join(',') || 'Default'}`);

    try {
        const items = await kdsService.getItemsForKds(businessId, destination.trim().toUpperCase(), statusFilter);
        res.status(200).json(items);
    } catch (error) {
        console.error(`[KDS CTRL] Error getting items for KDS (Dest: ${destination}):`, error);
        next(error); // Pasar al manejador de errores global
    }
};

/**
 * Handler para PATCH /api/camarero/kds/items/:orderItemId/status
 * Actualiza el estado de un OrderItem espec√≠fico.
 */
export const updateOrderItemStatusHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Asumimos que authenticateToken ya lo a√±adi√≥
    const { orderItemId } = req.params;
    const { newStatus } = req.body; // Esperamos { "newStatus": "PREPARING" } por ejemplo

    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado en la sesi√≥n del usuario." });
    }
    if (!orderItemId) {
        return res.status(400).json({ message: "Falta el ID del √≠tem de pedido (orderItemId) en la URL." });
    }
    if (!newStatus || typeof newStatus !== 'string') {
        return res.status(400).json({ message: "Falta el campo 'newStatus' o no es un string en el cuerpo de la petici√≥n." });
    }

    const validatedNewStatus = newStatus.toUpperCase() as OrderItemStatus;
    if (!Object.values(OrderItemStatus).includes(validatedNewStatus)) {
        return res.status(400).json({ message: `El valor de 'newStatus' ('${newStatus}') no es un estado v√°lido.` });
    }
    
    console.log(`[KDS CTRL] Request to update OrderItem ${orderItemId} to status ${validatedNewStatus} for business ${businessId}`);

    try {
        const updatedItem = await kdsService.updateOrderItemStatus(orderItemId, validatedNewStatus, businessId);
        res.status(200).json(updatedItem);
    } catch (error: any) { // Especificar 'any' o un tipo m√°s espec√≠fico
        console.error(`[KDS CTRL] Error updating status for OrderItem ${orderItemId} to ${validatedNewStatus}:`, error);
        // El servicio ya puede lanzar errores con mensajes espec√≠ficos (ej: transici√≥n no permitida, √≠tem no encontrado)
        // Si el mensaje es espec√≠fico del servicio y queremos mostrarlo, lo pasamos tal cual.
        if (error.message) {
            // Podr√≠amos mapear ciertos mensajes de error a c√≥digos de estado HTTP espec√≠ficos
            if (error.message.includes('no encontrado')) {
                return res.status(404).json({ message: error.message });
            }
            if (error.message.includes('no permitida')) {
                return res.status(400).json({ message: error.message }); // Bad Request por l√≥gica de negocio
            }
        }
        next(error); // Pasar otros errores al manejador global
    }
};


// ====== [11] backend/src/modules/camarero/kds.service.ts ======
// backend/src/camarero/kds.service.ts
// Version: 1.1.1 (Corrected enums based on TS errors, refined Order.status logic - FULL FILE)

import { PrismaClient, Prisma, OrderItem, OrderItemStatus, OrderStatus } from '@prisma/client';

const prisma = new PrismaClient();

// Tipo para la informaci√≥n que necesita el KDS para cada OrderItem
export interface KdsOrderItemData {
    id: string; // OrderItem ID
    quantity: number;
    status: OrderItemStatus; // Usar√° los enums del cliente: PENDING_KDS, PREPARING, READY, etc.
    notes: string | null;
    kdsDestination: string | null;
    menuItemName_es: string | null;
    menuItemName_en: string | null;
    selectedModifiers: {
        optionName_es: string | null;
        optionName_en: string | null;
    }[];
    orderInfo: {
        id: string; // Order ID
        orderNumber: string;
        createdAt: Date;
        tableIdentifier: string | null;
    };
    preparationTime?: number | null;
    preparedAt?: Date | null;
    servedAt?: Date | null;
}


/**
 * Obtiene los √≠tems de pedido para una destino KDS espec√≠fico.
 * @param businessId - ID del negocio.
 * @param kdsDestination - El destino KDS (ej. "COCINA", "BARRA").
 * @param filterStatus - Array opcional de OrderItemStatus para filtrar.
 * @returns Array de KdsOrderItemData.
 */
export const getItemsForKds = async (
    businessId: string,
    kdsDestination: string,
    filterStatus?: OrderItemStatus[]
): Promise<KdsOrderItemData[]> => {
    console.log(`[KDS SVC] Fetching items for KDS. Business: ${businessId}, Destination: ${kdsDestination}, StatusFilter: ${filterStatus?.join(',')}`);

    // Usamos los estados de Prisma que el entorno espera: PENDING_KDS, PREPARING
    const statusFilterToUse = filterStatus && filterStatus.length > 0
        ? filterStatus
        : [OrderItemStatus.PENDING_KDS, OrderItemStatus.PREPARING];

    try {
        const orderItems = await prisma.orderItem.findMany({
            where: {
                order: {
                    businessId: businessId,
                    // Pedidos que est√°n listos para cocina/KDS: RECEIVED, IN_PROGRESS, PARTIALLY_READY, ALL_ITEMS_READY
                    // Excluimos PENDING_PAYMENT, PAID, COMPLETED, CANCELLED, PAYMENT_FAILED
                    status: {
                        in: [
                            OrderStatus.RECEIVED,
                            OrderStatus.IN_PROGRESS,
                            OrderStatus.PARTIALLY_READY,
                            OrderStatus.ALL_ITEMS_READY
                        ],
                    }
                },
                kdsDestination: kdsDestination,
                status: {
                    in: statusFilterToUse,
                },
            },
            include: {
                menuItem: {
                    select: {
                        name_es: true,
                        name_en: true,
                        preparationTime: true,
                    }
                },
                selectedModifiers: {
                    include: {
                        modifierOption: {
                            select: {
                                name_es: true,
                                name_en: true,
                            }
                        }
                    }
                },
                order: {
                    select: {
                        id: true,
                        orderNumber: true,
                        createdAt: true,
                        table: {
                            select: {
                                identifier: true,
                            }
                        }
                    }
                }
            },
            orderBy: {
                order: {
                    createdAt: 'asc',
                }
            }
        });

        const kdsItems: KdsOrderItemData[] = orderItems.map(item => ({
            id: item.id,
            quantity: item.quantity,
            status: item.status,
            notes: item.notes,
            kdsDestination: item.kdsDestination,
            menuItemName_es: item.menuItem?.name_es || item.itemNameSnapshot,
            menuItemName_en: item.menuItem?.name_en || null,
            selectedModifiers: item.selectedModifiers.map(sm => ({
                optionName_es: sm.modifierOption?.name_es || sm.optionNameSnapshot,
                optionName_en: sm.modifierOption?.name_en || null,
            })),
            orderInfo: {
                id: item.order.id,
                orderNumber: item.order.orderNumber,
                createdAt: item.order.createdAt,
                tableIdentifier: item.order.table?.identifier || null,
            },
            preparationTime: item.menuItem?.preparationTime,
            preparedAt: item.preparedAt,
            servedAt: item.servedAt,
        }));

        console.log(`[KDS SVC] Found ${kdsItems.length} items for KDS Destination '${kdsDestination}'.`);
        return kdsItems;

    } catch (error) {
        console.error(`[KDS SVC] Error fetching items for KDS (Destination: ${kdsDestination}):`, error);
        if (error instanceof Error) {
            throw new Error(`Error al obtener los √≠tems para el KDS: ${error.message}`);
        }
        throw new Error('Error al obtener los √≠tems para el KDS desde la base de datos.');
    }
};


/**
 * Actualiza el estado de un OrderItem espec√≠fico.
 * Tambi√©n maneja la l√≥gica para actualizar el estado del Order general.
 * @param orderItemId - ID del OrderItem a actualizar.
 * @param newOrderItemStatus - El nuevo OrderItemStatus (debe ser uno de los definidos en el Prisma del entorno).
 * @param businessId - ID del negocio (para verificaci√≥n de pertenencia).
 * @returns El OrderItem actualizado con sus relaciones (order, menuItem, selectedModifiers).
 */
export const updateOrderItemStatus = async (
    orderItemId: string,
    newOrderItemStatus: OrderItemStatus, // Usamos el enum del entorno
    businessId: string
): Promise<OrderItem> => {
    console.log(`[KDS SVC] Attempting to update OrderItem ${orderItemId} to ${newOrderItemStatus} for business ${businessId}`);

    // Transiciones permitidas usando los enums del entorno
    const allowedTransitions: Partial<Record<OrderItemStatus, OrderItemStatus[]>> = {
        [OrderItemStatus.PENDING_KDS]: [OrderItemStatus.PREPARING, OrderItemStatus.CANCELLED, OrderItemStatus.CANCELLATION_REQUESTED],
        [OrderItemStatus.PREPARING]:   [OrderItemStatus.READY, OrderItemStatus.PENDING_KDS, OrderItemStatus.CANCELLED, OrderItemStatus.CANCELLATION_REQUESTED],
        [OrderItemStatus.READY]:       [OrderItemStatus.SERVED, OrderItemStatus.PREPARING], // SERVED lo har√≠a un camarero, KDS lo pasa a READY, quiz√° puede volver a PREPARING
        [OrderItemStatus.CANCELLATION_REQUESTED]: [OrderItemStatus.CANCELLED, OrderItemStatus.PENDING_KDS, OrderItemStatus.PREPARING], // Si se rechaza la cancelaci√≥n
        // SERVED y CANCELLED son finales desde KDS
    };

    const finalUpdatedOrderItem = await prisma.$transaction(async (tx) => {
        let currentOrderItem = await tx.orderItem.findFirst({
            where: { id: orderItemId, order: { businessId: businessId } },
            include: { order: { select: { id: true, status: true } } }
        });

        if (!currentOrderItem) {
            throw new Error(`√çtem de pedido con ID ${orderItemId} no encontrado o no pertenece a este negocio.`);
        }
        if (!currentOrderItem.order?.id) {
             throw new Error(`Error interno: El √≠tem de pedido ${orderItemId} no est√° asociado a un pedido.`);
        }

        const currentOrderItemStatusValue = currentOrderItem.status;

        if (currentOrderItemStatusValue !== newOrderItemStatus) {
            if (allowedTransitions[currentOrderItemStatusValue] && !allowedTransitions[currentOrderItemStatusValue]?.includes(newOrderItemStatus)) {
                throw new Error(`Transici√≥n de estado no permitida para el √≠tem de '${currentOrderItemStatusValue}' a '${newOrderItemStatus}'.`);
            }

            const dataToUpdateForOrderItem: Prisma.OrderItemUpdateInput = { status: newOrderItemStatus };
            let newPreparedAtDate: Date | null = currentOrderItem.preparedAt;
            let newServedAtDate: Date | null = currentOrderItem.servedAt;

            if (newOrderItemStatus === OrderItemStatus.PREPARING && !currentOrderItem.preparedAt) {
                newPreparedAtDate = new Date();
                dataToUpdateForOrderItem.preparedAt = newPreparedAtDate;
            } else if (newOrderItemStatus === OrderItemStatus.READY && !currentOrderItem.preparedAt) {
                newPreparedAtDate = new Date();
                dataToUpdateForOrderItem.preparedAt = newPreparedAtDate;
            } else if (newOrderItemStatus === OrderItemStatus.SERVED && !currentOrderItem.servedAt) {
                newServedAtDate = new Date();
                dataToUpdateForOrderItem.servedAt = newServedAtDate;
                if (!currentOrderItem.preparedAt) { // Si se sirve directamente (ej. bebidas)
                    newPreparedAtDate = new Date();
                    dataToUpdateForOrderItem.preparedAt = newPreparedAtDate;
                }
            }

            await tx.orderItem.update({
                where: { id: orderItemId },
                data: dataToUpdateForOrderItem,
            });
            console.log(`[KDS SVC] OrderItem ${orderItemId} status updated to ${newOrderItemStatus} in DB.`);

            currentOrderItem.status = newOrderItemStatus;
            currentOrderItem.preparedAt = newPreparedAtDate;
            currentOrderItem.servedAt = newServedAtDate;

        } else {
            console.log(`[KDS SVC] OrderItem ${orderItemId} ya est√° en estado ${newOrderItemStatus}. No se requiere actualizaci√≥n de √≠tem.`);
        }

        // --- L√ìGICA DE ACTUALIZACI√ìN DEL ESTADO DEL PEDIDO (Order.status) CON ENUMS DEL ENTORNO ---
        const orderId = currentOrderItem.order.id;
        const currentOrderStatusInDb = currentOrderItem.order.status;

        const allItemsOfThisOrder = await tx.orderItem.findMany({
            where: { orderId: orderId },
            select: { status: true, id: true }
        });

        console.log(`[KDS SVC - OrderStatusLogic] For Order ${orderId} - Current Order Status in DB: ${currentOrderStatusInDb}`);
        console.log(`[KDS SVC - OrderStatusLogic] All items for order ${orderId} (after potential item update):`, allItemsOfThisOrder.map(i => ({id: i.id, status: i.status})));

        // Filtrar √≠tems que no est√°n CANCELLED. CANCELLATION_REQUESTED se trata como activo hasta que se confirma.
        const activeItems = allItemsOfThisOrder.filter(item =>
            item.status !== OrderItemStatus.CANCELLED
        );

        let determinedNewOrderStatus: OrderStatus = currentOrderStatusInDb;

        if (allItemsOfThisOrder.length === 0) {
            console.log(`[KDS SVC - OrderStatusLogic] No items found for order ${orderId}. Status remains ${determinedNewOrderStatus}`);
        } else if (activeItems.length === 0) {
            // Todos los √≠tems originales fueron CANCELLED
            determinedNewOrderStatus = OrderStatus.CANCELLED;
            console.log(`[KDS SVC - OrderStatusLogic] All items are CANCELLED. New OrderStatus -> ${determinedNewOrderStatus}`);
        } else {
            const allServed = activeItems.every(item => item.status === OrderItemStatus.SERVED);
            const allReadyOrServed = activeItems.every(item => item.status === OrderItemStatus.READY || item.status === OrderItemStatus.SERVED);
            const anyReady = activeItems.some(item => item.status === OrderItemStatus.READY);
            const anyPreparing = activeItems.some(item => item.status === OrderItemStatus.PREPARING);
            // const allPendingKds = activeItems.every(item => item.status === OrderItemStatus.PENDING_KDS);

            if (allServed) {
                // Si todos los √≠tems activos est√°n servidos, el pedido se considera completado.
                // La transici√≥n a PAID se manejar√≠a en otro flujo (POS o similar).
                determinedNewOrderStatus = OrderStatus.COMPLETED;
                console.log(`[KDS SVC - OrderStatusLogic] All active items SERVED. New OrderStatus -> ${determinedNewOrderStatus}`);
            } else if (allReadyOrServed) {
                // Si todos los √≠tems activos est√°n listos (READY) o ya servidos (pero no todos servidos)
                determinedNewOrderStatus = OrderStatus.ALL_ITEMS_READY;
                console.log(`[KDS SVC - OrderStatusLogic] All active items READY or SERVED. New OrderStatus -> ${determinedNewOrderStatus}`);
            } else if (anyReady) {
                // Si algunos √≠tems est√°n listos (READY), pero no todos (y no todos servidos)
                // Y el pedido estaba en progreso o reci√©n recibido.
                if (currentOrderStatusInDb === OrderStatus.IN_PROGRESS || currentOrderStatusInDb === OrderStatus.RECEIVED || currentOrderStatusInDb === OrderStatus.PARTIALLY_READY) {
                    determinedNewOrderStatus = OrderStatus.PARTIALLY_READY;
                    console.log(`[KDS SVC - OrderStatusLogic] Some items READY. Order status was ${currentOrderStatusInDb}. New OrderStatus -> ${determinedNewOrderStatus}`);
                } else {
                    console.log(`[KDS SVC - OrderStatusLogic] Some items READY, but current order status ${currentOrderStatusInDb} prevents auto-move to PARTIALLY_READY. Status remains ${determinedNewOrderStatus}`);
                }
            } else if (anyPreparing) {
                 // Si alg√∫n √≠tem se est√° preparando
                if (currentOrderStatusInDb === OrderStatus.RECEIVED || currentOrderStatusInDb === OrderStatus.IN_PROGRESS || currentOrderStatusInDb === OrderStatus.PARTIALLY_READY ) {
                    determinedNewOrderStatus = OrderStatus.IN_PROGRESS;
                    console.log(`[KDS SVC - OrderStatusLogic] Some items PREPARING. Order status was ${currentOrderStatusInDb}. New OrderStatus -> ${determinedNewOrderStatus}`);
                } else {
                    console.log(`[KDS SVC - OrderStatusLogic] Some items PREPARING, but current order status ${currentOrderStatusInDb} prevents auto-move to IN_PROGRESS. Status remains ${determinedNewOrderStatus}`);
                }
            }
            // No es necesario un 'else if (allPendingKds)' porque si el pedido est√° RECEIVED y todos los √≠tems est√°n PENDING_KDS, el estado no deber√≠a cambiar.
            // Si estaba IN_PROGRESS y todos vuelven a PENDING_KDS (raro), podr√≠a volver a RECEIVED o quedarse IN_PROGRESS seg√∫n la pol√≠tica.
            // Por ahora, si no se cumplen las condiciones anteriores, se mantiene el 'determinedNewOrderStatus'
            else {
                console.log(`[KDS SVC - OrderStatusLogic] No specific aggregate condition met for active items to change OrderStatus from ${currentOrderStatusInDb}.`);
                 // Si el estado actual es RECEIVED y hay alg√∫n item que no sea PENDING_KDS (ej. PREPARING, READY), deber√≠a pasar a IN_PROGRESS o PARTIALLY_READY
                if (currentOrderStatusInDb === OrderStatus.RECEIVED && activeItems.some(it => it.status !== OrderItemStatus.PENDING_KDS) ) {
                    if (activeItems.some(it => it.status === OrderItemStatus.READY)) {
                        determinedNewOrderStatus = OrderStatus.PARTIALLY_READY;
                         console.log(`[KDS SVC - OrderStatusLogic] Order was RECEIVED, now has READY items. New OrderStatus -> ${determinedNewOrderStatus}`);
                    } else if (activeItems.some(it => it.status === OrderItemStatus.PREPARING)) {
                        determinedNewOrderStatus = OrderStatus.IN_PROGRESS;
                        console.log(`[KDS SVC - OrderStatusLogic] Order was RECEIVED, now has PREPARING items. New OrderStatus -> ${determinedNewOrderStatus}`);
                    }
                }
            }
        }

        if (currentOrderStatusInDb !== determinedNewOrderStatus) {
            // Asegurar que el determinedNewOrderStatus es uno de los valores v√°lidos del enum OrderStatus
            if (Object.values(OrderStatus).includes(determinedNewOrderStatus)) {
                 await tx.order.update({
                    where: { id: orderId },
                    data: { status: determinedNewOrderStatus }
                });
                console.log(`[KDS SVC - DB UPDATE] Order ${orderId} status was ${currentOrderStatusInDb}, NOW UPDATED to ${determinedNewOrderStatus}.`);
            } else {
                 // Esto no deber√≠a ocurrir si la l√≥gica es correcta y solo asigna valores del enum
                 console.error(`[KDS SVC - INVALID STATUS] Attempted to set invalid OrderStatus '${determinedNewOrderStatus}'. Order status REMAINS ${currentOrderStatusInDb}.`);
            }
        } else {
            console.log(`[KDS SVC - NO DB UPDATE] Order ${orderId} status REMAINS ${currentOrderStatusInDb}. (Determined new status was also: ${determinedNewOrderStatus})`);
        }
        // --- FIN L√ìGICA DE ACTUALIZACI√ìN DEL ESTADO DEL PEDIDO ---

        const finalOrderItemResult = await tx.orderItem.findUniqueOrThrow({
            where: { id: orderItemId },
            include: {
                order: true,
                menuItem: true,
                selectedModifiers: { include: { modifierOption: true }}
            }
        });
        return finalOrderItemResult;
    });
    return finalUpdatedOrderItem;
};


// ====== [12] backend/src/modules/camarero/public/OrderValidationService.ts ======
// backend/src/public/order-item-processor.service.ts
import {
    PrismaClient,
    Prisma,
    MenuItem,
    ModifierGroup,
    OrderItemStatus, // Necesario para el estado inicial del OrderItem
} from '@prisma/client';
import {
    BadRequestException,
    InternalServerErrorException,
    Logger,
    NotFoundException,
} from '@nestjs/common';

// Tipos importados de los DTOs internos (o definidos aqu√≠ si es preferible)
interface SelectedModifierOptionInternalDto {
    modifierOptionId: string;
}

interface OrderItemInternalDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: SelectedModifierOptionInternalDto[] | null;
}

// Tipos para la estructura de datos que este servicio devolver√°
// Esto es lo que se necesita para crear un OrderItem en la BD
export interface ProcessedOrderItemData {
    menuItemId: string;
    quantity: number;
    priceAtPurchase: Prisma.Decimal;
    totalItemPrice: Prisma.Decimal;
    notes?: string | null;
    kdsDestination: string | null;
    itemNameSnapshot: string; // Asumiendo que el snapshot se toma aqu√≠
    itemDescriptionSnapshot: string | null; // Asumiendo que el snapshot se toma aqu√≠
    status: OrderItemStatus; // Estado inicial
    // Datos para crear los OrderItemModifierOption asociados
    modifierOptionsToCreate: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[];
}

// Tipos internos para el manejo de modificadores (similares a los que ten√≠as)
interface SelectedModifierOptionShape {
    id: string;
    name_es: string | null;
    priceAdjustment: Prisma.Decimal;
    isAvailable: boolean;
    groupId: string; // Clave para la l√≥gica de validaci√≥n de grupos
}

type ModifierGroupWithSelectedOptions = ModifierGroup & {
    options: SelectedModifierOptionShape[];
};

// Prisma.validator para obtener MenuItem con sus modificadores y opciones activas
const menuItemWithFullModifiersArgs = Prisma.validator<Prisma.MenuItemDefaultArgs>()({
    include: {
        modifierGroups: {
            orderBy: { position: 'asc' }, // Importante para la l√≥gica de validaci√≥n si el orden importa
            include: {
                options: {
                    where: { isAvailable: true }, // Solo opciones disponibles
                    orderBy: { position: 'asc' },
                    select: { // Seleccionar solo lo necesario
                        id: true,
                        name_es: true, // Para snapshots
                        // name_en: true, // Si tuvieras i18n para snapshots
                        priceAdjustment: true,
                        isAvailable: true, // Aunque ya filtramos, es bueno tenerlo
                        groupId: true,
                    },
                },
            },
        },
    },
});
type MenuItemWithFullModifiers = Prisma.MenuItemGetPayload<typeof menuItemWithFullModifiersArgs>;


export class OrderItemProcessorService {
    private readonly logger = new Logger(OrderItemProcessorService.name);

    /**
     * Procesa una lista de √≠tems de un DTO, valida su contenido (incluyendo modificadores)
     * y calcula los precios.
     *
     * @param tx - Cliente Prisma de la transacci√≥n actual.
     * @param businessId - ID del negocio al que deben pertenecer los √≠tems.
     * @param itemsDto - Array de √≠tems tal como vienen en el payload de la orden.
     * @returns Un array de ProcessedOrderItemData, listos para ser usados en la creaci√≥n de OrderItems.
     */
    async processOrderItems(
        tx: Prisma.TransactionClient,
        businessId: string,
        itemsDto: OrderItemInternalDto[]
    ): Promise<ProcessedOrderItemData[]> {
        this.logger.log(`[OrderItemProcessor] Processing ${itemsDto.length} items for business ${businessId}`);
        const processedItems: ProcessedOrderItemData[] = [];

        for (const itemDto of itemsDto) {
            const menuItem = await this.fetchAndValidateMenuItem(tx, itemDto.menuItemId, businessId);

            const {
                itemPriceWithModifiers,
                modifierOptionsToCreateForDb,
            } = this.processModifiersForItem(menuItem, itemDto.selectedModifierOptions || []);

            const priceAtPurchase = menuItem.price.add(itemPriceWithModifiers);
            const totalItemPrice = priceAtPurchase.mul(itemDto.quantity);

            processedItems.push({
                menuItemId: menuItem.id,
                quantity: itemDto.quantity,
                priceAtPurchase,
                totalItemPrice,
                notes: itemDto.notes,
                kdsDestination: menuItem.kdsDestination,
                itemNameSnapshot: menuItem.name_es || '√çtem sin nombre ES', // Tomar snapshot del nombre
                itemDescriptionSnapshot: menuItem.description_es, // Tomar snapshot de la descripci√≥n
                status: OrderItemStatus.PENDING_KDS, // Estado inicial por defecto
                modifierOptionsToCreate: modifierOptionsToCreateForDb,
            });
        }
        this.logger.log(`[OrderItemProcessor] Finished processing ${processedItems.length} items.`);
        return processedItems;
    }

    /**
     * Obtiene y valida un MenuItem.
     */
    private async fetchAndValidateMenuItem(
        tx: Prisma.TransactionClient,
        menuItemId: string,
        businessId: string
    ): Promise<MenuItemWithFullModifiers> {
        const menuItem = await tx.menuItem.findUnique({
            where: { id: menuItemId },
            ...menuItemWithFullModifiersArgs,
        });

        if (!menuItem) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItemId}' not found.`);
            throw new NotFoundException(`√çtem de men√∫ con ID '${menuItemId}' no encontrado.`);
        }
        if (menuItem.businessId !== businessId) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItemId}' does not belong to business '${businessId}'.`);
            throw new BadRequestException(`√çtem de men√∫ con ID '${menuItemId}' no pertenece a este negocio.`);
        }
        if (!menuItem.isAvailable) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItem.name_es}' is not available.`);
            throw new BadRequestException(`El √≠tem '${menuItem.name_es || menuItemId}' no est√° disponible actualmente.`);
        }
        return menuItem;
    }

    /**
     * Procesa los modificadores seleccionados para un √≠tem de men√∫,
     * calcula el ajuste total de precio y valida las selecciones.
     */
    private processModifiersForItem(
        menuItem: MenuItemWithFullModifiers,
        selectedOptionsDto: SelectedModifierOptionInternalDto[]
    ): {
        itemPriceWithModifiers: Prisma.Decimal; // Es el total de los priceAdjustments
        modifierOptionsToCreateForDb: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[];
    } {
        let totalModifierPriceAdjustment = new Prisma.Decimal(0);
        const modifierOptionsToCreateForDb: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[] = [];
        const typedModifierGroups = menuItem.modifierGroups as ModifierGroupWithSelectedOptions[];

        // Mapear las opciones seleccionadas por el cliente a sus datos completos de la BD
        // y agruparlas por su modifierGroupId para f√°cil validaci√≥n.
        const selectedOptionsDataByGroup: Record<string, SelectedModifierOptionShape[]> = {};

        for (const selectedOptDto of selectedOptionsDto) {
            let foundOption: SelectedModifierOptionShape | undefined;
            let foundInGroup: ModifierGroupWithSelectedOptions | undefined;

            for (const group of typedModifierGroups) {
                const option = group.options.find(opt => opt.id === selectedOptDto.modifierOptionId);
                if (option) {
                    foundOption = option;
                    foundInGroup = group;
                    break;
                }
            }

            if (!foundOption || !foundInGroup) {
                this.logger.warn(`[OrderItemProcessor] Invalid or unavailable modifierOptionId '${selectedOptDto.modifierOptionId}' for MenuItem '${menuItem.id}'.`);
                throw new BadRequestException(`Opci√≥n de modificador con ID '${selectedOptDto.modifierOptionId}' no es v√°lida o no est√° disponible para el √≠tem '${menuItem.name_es}'.`);
            }
            
            if (!foundOption.groupId) { // Esto no deber√≠a pasar si el schema es correcto
                 this.logger.error(`[OrderItemProcessor] Critical: ModifierOption '${foundOption.id}' has no groupId.`);
                 throw new InternalServerErrorException(`Error de configuraci√≥n: Opci√≥n de modificador '${foundOption.id}' no tiene grupo.`);
            }

            if (!selectedOptionsDataByGroup[foundOption.groupId]) {
                selectedOptionsDataByGroup[foundOption.groupId] = [];
            }
            selectedOptionsDataByGroup[foundOption.groupId].push(foundOption);

            totalModifierPriceAdjustment = totalModifierPriceAdjustment.add(foundOption.priceAdjustment);
            modifierOptionsToCreateForDb.push({
                modifierOptionId: foundOption.id,
                optionNameSnapshot: foundOption.name_es || 'Opci√≥n sin nombre ES', // Snapshot
                optionPriceAdjustmentSnapshot: foundOption.priceAdjustment,
            });
        }

        // Validar cada grupo de modificadores del MenuItem contra las selecciones hechas
        for (const group of typedModifierGroups) {
            const selectionsInThisGroup = selectedOptionsDataByGroup[group.id] || [];
            const selectedCount = selectionsInThisGroup.length;

            if (group.isRequired && selectedCount < group.minSelections) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for group '${group.name_es}': required min ${group.minSelections}, got ${selectedCount}.`);
                throw new BadRequestException(`Para el √≠tem '${menuItem.name_es}', el grupo de modificadores '${group.name_es}' requiere al menos ${group.minSelections} selecci√≥n(es).`);
            }
            if (selectedCount > group.maxSelections) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for group '${group.name_es}': allowed max ${group.maxSelections}, got ${selectedCount}.`);
                throw new BadRequestException(`Para el √≠tem '${menuItem.name_es}', el grupo de modificadores '${group.name_es}' permite como m√°ximo ${group.maxSelections} selecci√≥n(es).`);
            }
            // Adicionalmente, si es RADIO, solo debe haber una selecci√≥n
            if (group.uiType === 'RADIO' && selectedCount > 1) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for RADIO group '${group.name_es}': got ${selectedCount} selections.`);
                throw new BadRequestException(`El grupo de modificadores '${group.name_es}' (tipo RADIO) solo permite una selecci√≥n.`);
            }
        }

        return {
            itemPriceWithModifiers: totalModifierPriceAdjustment,
            modifierOptionsToCreateForDb,
        };
    }
}


// ====== [13] backend/src/modules/camarero/public/menu.controller.ts ======
// backend/src/public/menu.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as publicMenuService from './menu.service'; // Asumimos que el servicio se llamar√° menu.service.ts en la misma carpeta

export const getPublicDigitalMenuHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessSlug } = req.params;

    if (!businessSlug || typeof businessSlug !== 'string' || businessSlug.trim() === '') {
        return res.status(400).json({ message: 'Se requiere el slug del negocio en la URL.' });
    }

    console.log(`[PublicMenu CTRL] Requesting public menu for business slug: ${businessSlug}`);

    try {
        const menuData = await publicMenuService.getPublicDigitalMenuBySlug(businessSlug.trim());

        if (!menuData) {
            // El servicio devolver√° null si el negocio no existe o el m√≥dulo camarero no est√° activo
            return res.status(404).json({ message: 'Men√∫ no encontrado o no disponible para este negocio.' });
        }

        res.status(200).json(menuData);
    } catch (error) {
        // Loguear el error en el backend para diagn√≥stico
        console.error(`[PublicMenu CTRL] Error fetching public menu for slug ${businessSlug}:`, error);
        // Pasar el error al manejador de errores global de Express
        // El manejador global puede decidir enviar una respuesta 500 gen√©rica
        // o manejar errores espec√≠ficos si los lanzamos desde el servicio.
        next(error);
    }
};


// ====== [14] backend/src/modules/camarero/public/menu.service.ts ======
// backend/src/public/menu.service.ts
// Version: 1.0.0 (Initial functional version for public menu display)

import { PrismaClient, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

// Definici√≥n local de ModifierUiType (como en seed.ts y como se usa en tus otros servicios)
const ModifierUiTypeEnum = {
    RADIO: 'RADIO',
    CHECKBOX: 'CHECKBOX',
} as const;
type LocalModifierUiType = typeof ModifierUiTypeEnum[keyof typeof ModifierUiTypeEnum];


// --- Definici√≥n de Tipos de Salida ---
interface PublicMenuCategoryItemModifierOption {
    id: string;
    name_es: string | null;
    name_en: string | null;
    priceAdjustment: Prisma.Decimal;
    position: number;
    isDefault: boolean;
}

interface PublicMenuCategoryItemModifierGroup {
    id: string;
    name_es: string | null;
    name_en: string | null;
    uiType: LocalModifierUiType; // Usar el tipo LocalModifierUiType
    minSelections: number;
    maxSelections: number;
    isRequired: boolean;
    position: number;
    options: PublicMenuCategoryItemModifierOption[];
}

interface PublicMenuCategoryItem {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    price: Prisma.Decimal;
    imageUrl: string | null;
    allergens: string[];
    tags: string[];
    position: number;
    modifierGroups: PublicMenuCategoryItemModifierGroup[];
}

interface PublicMenuCategory {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    imageUrl: string | null;
    position: number;
    items: PublicMenuCategoryItem[];
}

interface PublicDigitalMenu {
    businessName: string;
    businessSlug: string;
    businessLogoUrl: string | null;
    categories: PublicMenuCategory[];
}
// --- Fin Definici√≥n de Tipos de Salida ---


export const getPublicDigitalMenuBySlug = async (businessSlug: string): Promise<PublicDigitalMenu | null> => {
    console.log(`[PublicMenu SVC] Fetching public digital menu for business slug: ${businessSlug}`);

    try {
        const businessWithMenu = await prisma.business.findUnique({
            where: { slug: businessSlug },
            select: {
                id: true,
                name: true,
                slug: true,
                logoUrl: true,
                isCamareroActive: true,
                isActive: true,
                menuCategories: {
                    where: { isActive: true },
                    orderBy: { position: 'asc' },
                    select: {
                        id: true,
                        name_es: true,
                        name_en: true,
                        description_es: true,
                        description_en: true,
                        imageUrl: true,
                        position: true,
                        items: {
                            where: {
                                // Asumiendo que MenuItem usa 'isAvailable' para la vista p√∫blica
                                // y 'isActive' para la habilitaci√≥n general del √≠tem.
                                // Si solo 'isAvailable' controla la vista p√∫blica, quitar 'isActive: true'.
                                // Si el schema de MenuItem NO tiene 'isActive', esta l√≠nea dar√° error.
                                // Basado en el √∫ltimo error, comentaremos 'isActive' para MenuItem.
                                // isActive: true, 
                                isAvailable: true
                            },
                            orderBy: { position: 'asc' },
                            select: {
                                id: true,
                                name_es: true,
                                name_en: true,
                                description_es: true,
                                description_en: true,
                                price: true,
                                imageUrl: true,
                                allergens: true,
                                tags: true,
                                position: true,
                                modifierGroups: {
                                    // Asumiendo que ModifierGroup usa 'isActive'
                                    // Si no tiene 'isActive' filtrable, esta l√≠nea debe comentarse o ajustarse.
                                    // Basado en el √∫ltimo error, comentaremos 'isActive' para ModifierGroup.
                                    // where: { isActive: true }, 
                                    orderBy: { position: 'asc' },
                                    select: {
                                        id: true,
                                        name_es: true,
                                        name_en: true,
                                        uiType: true,
                                        minSelections: true,
                                        maxSelections: true,
                                        isRequired: true,
                                        position: true,
                                        options: {
                                            where: { isAvailable: true }, // ModifierOption usa isAvailable
                                            orderBy: { position: 'asc' },
                                            select: {
                                                id: true,
                                                name_es: true,
                                                name_en: true,
                                                priceAdjustment: true,
                                                position: true,
                                                isDefault: true,
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        });

        if (!businessWithMenu) {
            console.log(`[PublicMenu SVC] Business not found for slug: ${businessSlug}`);
            return null;
        }

        if (!businessWithMenu.isActive) {
            console.log(`[PublicMenu SVC] Business ${businessSlug} (ID: ${businessWithMenu.id}) is not active. Menu not available.`);
            return null;
        }

        if (!businessWithMenu.isCamareroActive) {
            console.log(`[PublicMenu SVC] Camarero module is not active for business ${businessSlug} (ID: ${businessWithMenu.id}). Menu not available.`);
            return null;
        }
        
        type CategoryFromPrisma = typeof businessWithMenu.menuCategories[0];
        type ItemFromPrisma = CategoryFromPrisma['items'][0];
        type GroupFromPrisma = ItemFromPrisma['modifierGroups'][0];
        type OptionFromPrisma = GroupFromPrisma['options'][0];

        const mapCategory = (category: CategoryFromPrisma): PublicMenuCategory => ({
            id: category.id,
            name_es: category.name_es,
            name_en: category.name_en,
            description_es: category.description_es,
            description_en: category.description_en,
            imageUrl: category.imageUrl,
            position: category.position,
            items: category.items.map(mapItem),
        });

        const mapItem = (item: ItemFromPrisma): PublicMenuCategoryItem => ({
            id: item.id,
            name_es: item.name_es,
            name_en: item.name_en,
            description_es: item.description_es,
            description_en: item.description_en,
            price: item.price,
            imageUrl: item.imageUrl,
            allergens: item.allergens,
            tags: item.tags,
            position: item.position,
            modifierGroups: item.modifierGroups.map(mapGroup),
        });

        const mapGroup = (group: GroupFromPrisma): PublicMenuCategoryItemModifierGroup => ({
            id: group.id,
            name_es: group.name_es,
            name_en: group.name_en,
            uiType: group.uiType as LocalModifierUiType,
            minSelections: group.minSelections,
            maxSelections: group.maxSelections,
            isRequired: group.isRequired,
            position: group.position,
            options: group.options.map(mapOption),
        });

        const mapOption = (option: OptionFromPrisma): PublicMenuCategoryItemModifierOption => ({
            id: option.id,
            name_es: option.name_es,
            name_en: option.name_en,
            priceAdjustment: option.priceAdjustment,
            position: option.position,
            isDefault: option.isDefault,
        });

        const categoriesTyped: PublicMenuCategory[] = businessWithMenu.menuCategories.map(mapCategory);

        const menuToReturn: PublicDigitalMenu = {
            businessName: businessWithMenu.name,
            businessSlug: businessWithMenu.slug,
            businessLogoUrl: businessWithMenu.logoUrl,
            categories: categoriesTyped,
        };

        return menuToReturn;

    } catch (error) {
        console.error(`[PublicMenu SVC] Error fetching public menu for slug ${businessSlug}:`, error);
        throw new Error('Error al obtener los datos del men√∫ desde la base de datos.');
    }
};


// ====== [15] backend/src/modules/camarero/public/order-creation.service.ts ======
// backend/src/modules/camarero/public/order-creation.service.ts (CORREGIDO)
import {
    PrismaClient,
    Prisma,
    Order,
    OrderStatus,
    TableStatus,
} from '@prisma/client';
import {
    Injectable,
    Logger,
    NotFoundException,
    BadRequestException,
    InternalServerErrorException,
} from '@nestjs/common';

// Importar los servicios que vamos a usar
import { OrderItemProcessorService, ProcessedOrderItemData } from './order-item-processor.service';
// --- RUTA CORREGIDA ---
import { TableService } from '../../../shared/services/table.service';

// Tipos del payload que este servicio espera
export interface CreateOrderPayloadInternalDto {
    tableIdentifier?: string | null;
    customerId?: string | null;
    orderNotes?: string | null;
    items: OrderItemInternalDto[];
}

interface OrderItemInternalDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: { modifierOptionId: string }[] | null;
}

interface BusinessContextForOrder {
    id: string;
    isActive: boolean;
    isCamareroActive: boolean;
}

@Injectable()
export class OrderCreationService {
    private readonly logger = new Logger(OrderCreationService.name);
    private readonly orderItemProcessorService: OrderItemProcessorService;
    private readonly tableService: TableService;
    private prisma: PrismaClient;

    constructor() {
        this.prisma = new PrismaClient();
        this.orderItemProcessorService = new OrderItemProcessorService();
        this.tableService = new TableService();
        this.logger.log("OrderCreationService instantiated");
    }

    async createNewOrder(
        businessSlug: string,
        payload: CreateOrderPayloadInternalDto,
        requestingCustomerId?: string | null
    ): Promise<Order> {
        this.logger.log(`[OrderCreationService] Attempting to create new order for business slug '${businessSlug}'. Items: ${payload.items.length}`);

        const businessContext = await this.validateBusinessForOrdering(businessSlug);
        const businessId = businessContext.id;

        return this.prisma.$transaction(async (tx) => {
            this.logger.log(`[OrderCreationService TX] Transaction started for new order.`);

            const processedItems: ProcessedOrderItemData[] =
                await this.orderItemProcessorService.processOrderItems(
                    tx,
                    businessId,
                    payload.items
                );

            if (processedItems.length === 0 && payload.items.length > 0) {
                this.logger.warn(`[OrderCreationService TX] All items in payload were invalid. No items to create for order.`);
                throw new BadRequestException('Ninguno de los √≠tems proporcionados pudo ser procesado.');
            }
            if (processedItems.length === 0 && payload.items.length === 0) {
                 this.logger.warn(`[OrderCreationService TX] No items provided in the payload.`);
                 throw new BadRequestException('El pedido debe contener al menos un √≠tem.');
            }

            const totalAmount = processedItems.reduce(
                (sum, item) => sum.add(item.totalItemPrice),
                new Prisma.Decimal(0)
            );
            this.logger.log(`[OrderCreationService TX] Calculated totalAmount: ${totalAmount}`);

            const orderNumber = await this._generateOrderNumber(tx, businessId);
            this.logger.log(`[OrderCreationService TX] Generated orderNumber: ${orderNumber}`);

            const orderCreateData: Prisma.OrderCreateInput = {
                business: { connect: { id: businessId } },
                orderNumber: orderNumber,
                notes: payload.orderNotes,
                totalAmount: totalAmount,
                finalAmount: totalAmount,
                status: OrderStatus.RECEIVED,
                isBillRequested: false,
                source: payload.customerId || requestingCustomerId ? 'CUSTOMER_APP' : 'CUSTOMER_APP_ANONYMOUS',
                orderType: payload.tableIdentifier ? 'DINE_IN' : 'TAKE_AWAY',
                items: {
                    create: processedItems.map(pItem => ({
                        menuItemId: pItem.menuItemId,
                        quantity: pItem.quantity,
                        priceAtPurchase: pItem.priceAtPurchase,
                        totalItemPrice: pItem.totalItemPrice,
                        notes: pItem.notes,
                        kdsDestination: pItem.kdsDestination,
                        itemNameSnapshot: pItem.itemNameSnapshot,
                        itemDescriptionSnapshot: pItem.itemDescriptionSnapshot,
                        status: pItem.status,
                        ...(pItem.modifierOptionsToCreate.length > 0 && {
                            selectedModifiers: {
                                createMany: {
                                    data: pItem.modifierOptionsToCreate,
                                },
                            },
                        }),
                    })),
                },
            };

            if (payload.tableIdentifier) {
                const table = await this.tableService.findTableByIdentifier(
                    tx,
                    businessId,
                    payload.tableIdentifier
                );
                if (table) {
                    orderCreateData.table = { connect: { id: table.id } };
                    await this.tableService.updateTableStatus(tx, table.id, TableStatus.OCCUPIED);
                    this.logger.log(`[OrderCreationService TX] Table '${payload.tableIdentifier}' (ID: ${table.id}) connected and set to OCCUPIED.`);
                } else {
                    this.logger.warn(`[OrderCreationService TX] Table identifier '${payload.tableIdentifier}' provided but table not found for business '${businessId}'. Order will be created without table assignment.`);
                }
            }

            const finalCustomerId = payload.customerId || requestingCustomerId;
            if (finalCustomerId) {
                const customerExists = await tx.user.findFirst({ where: { id: finalCustomerId, businessId: businessId }});
                if(customerExists) {
                    orderCreateData.customerLCo = { connect: { id: finalCustomerId } };
                    this.logger.log(`[OrderCreationService TX] CustomerLCoId '${finalCustomerId}' connected to order.`);
                } else {
                    this.logger.warn(`[OrderCreationService TX] CustomerLCoId '${finalCustomerId}' provided but not found for business '${businessId}'. Order will be created without LCo customer.`);
                }
            }

            const newOrder = await tx.order.create({
                data: orderCreateData,
                include: { items: { include: { selectedModifiers: true } }, table: true },
            });

            this.logger.log(`[OrderCreationService TX] Order ${newOrder.id} (Number: ${newOrder.orderNumber}) created successfully with ${newOrder.items.length} item(s).`);
            return newOrder;
        });
    }

    private async validateBusinessForOrdering(businessSlug: string): Promise<BusinessContextForOrder> {
        const business = await this.prisma.business.findUnique({
            where: { slug: businessSlug },
            select: { id: true, isActive: true, isCamareroActive: true },
        });

        if (!business) {
            this.logger.warn(`[OrderCreationService] Business with slug '${businessSlug}' not found.`);
            throw new NotFoundException(`Negocio con slug '${businessSlug}' no encontrado.`);
        }
        if (!business.isActive) {
            this.logger.warn(`[OrderCreationService] Business '${businessSlug}' is not active.`);
            throw new BadRequestException(`El negocio '${businessSlug}' no est√° activo y no puede recibir pedidos.`);
        }
        if (!business.isCamareroActive) {
            this.logger.warn(`[OrderCreationService] Camarero module not active for business '${businessSlug}'.`);
            throw new BadRequestException(`El m√≥dulo de pedidos (Camarero) no est√° activo para el negocio '${businessSlug}'.`);
        }
        this.logger.log(`[OrderCreationService] Business '${businessSlug}' validated for ordering. ID: ${business.id}`);
        return business;
    }

    private async _generateOrderNumber(tx: Prisma.TransactionClient, businessId: string): Promise<string> {
        const orderCount = await tx.order.count({
            where: { businessId: businessId },
        });
        const datePrefix = new Date().toISOString().slice(0, 10).replace(/-/g, '');
        const newCount = orderCount + 1;
        return `P-${datePrefix}-${String(newCount).padStart(5, '0')}`;
    }
}


// ====== [16] backend/src/modules/camarero/public/order-item-processor.service.ts ======
// backend/src/public/order-item-processor.service.ts
import {
    PrismaClient, // Aunque no lo use directamente, es com√∫n para servicios Prisma
    Prisma,
    MenuItem,
    ModifierGroup,
    OrderItemStatus, // Necesario para el estado inicial del OrderItem
} from '@prisma/client';
import {
    BadRequestException,
    InternalServerErrorException,
    Logger,
    NotFoundException,
} from '@nestjs/common';

// Tipos importados o definidos (aseg√∫rate de que `SelectedModifierOptionInternalDto` est√© definido si no se importa)
// Si estos DTOs se definen en un archivo central (ej. order.types.ts), imp√≥rtalos desde all√≠.
// Por ahora, los definir√© aqu√≠ para que el archivo sea autocontenido.
interface SelectedModifierOptionInternalDto {
    modifierOptionId: string;
}

interface OrderItemInternalDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: SelectedModifierOptionInternalDto[] | null;
}

// Tipo de retorno de este servicio para cada √≠tem procesado
export interface ProcessedOrderItemData {
    menuItemId: string;
    quantity: number;
    priceAtPurchase: Prisma.Decimal; // Precio unitario del √≠tem con modificadores
    totalItemPrice: Prisma.Decimal;  // priceAtPurchase * quantity
    notes?: string | null;
    kdsDestination: string | null;
    itemNameSnapshot: string;
    itemDescriptionSnapshot: string | null;
    status: OrderItemStatus;
    // Datos para crear los OrderItemModifierOption asociados
    modifierOptionsToCreate: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[];
}

// Tipos internos para el manejo de modificadores, similares a los que ten√≠as
interface SelectedModifierOptionShape {
    id: string;
    name_es: string | null;
    // name_en: string | null; // Si necesitas i18n para snapshots de modificadores
    priceAdjustment: Prisma.Decimal;
    isAvailable: boolean;
    groupId: string;
}

// Tipo para ModifierGroup cuando se incluye sus opciones (con los campos seleccionados)
type ModifierGroupWithSelectedOptions = ModifierGroup & {
    options: SelectedModifierOptionShape[];
};

// Prisma.validator para obtener MenuItem con sus modificadores y opciones activas
// Esta definici√≥n es crucial y debe ser consistente con tu schema.prisma
const menuItemWithFullModifiersArgs = Prisma.validator<Prisma.MenuItemDefaultArgs>()({
    include: {
        modifierGroups: {
            orderBy: { position: 'asc' },
            include: {
                options: {
                    where: { isAvailable: true }, // Solo opciones disponibles
                    orderBy: { position: 'asc' },
                    select: {
                        id: true,
                        name_es: true, // Para snapshots
                        // name_en: true, // Descomentar si tienes name_en y lo usas para snapshots
                        priceAdjustment: true,
                        isAvailable: true, // Aunque ya filtramos, es bueno tenerlo para confirmaci√≥n
                        groupId: true, // Esencial para la l√≥gica de grupo
                    },
                },
            },
        },
    },
});
type MenuItemWithFullModifiers = Prisma.MenuItemGetPayload<typeof menuItemWithFullModifiersArgs>;

export class OrderItemProcessorService {
    private readonly logger = new Logger(OrderItemProcessorService.name);
    // Este servicio no necesita su propia instancia de Prisma si siempre se le pasa 'tx'.
    // constructor(private prisma: PrismaClient) {} // Si se inyectara

    /**
     * Procesa una lista de √≠tems de un DTO, valida su contenido (incluyendo modificadores)
     * y calcula los precios.
     *
     * @param tx - Cliente Prisma de la transacci√≥n actual.
     * @param businessId - ID del negocio al que deben pertenecer los √≠tems.
     * @param itemsDto - Array de √≠tems tal como vienen en el payload de la orden.
     * @returns Un array de ProcessedOrderItemData, listos para ser usados en la creaci√≥n de OrderItems.
     */
    async processOrderItems(
        tx: Prisma.TransactionClient, // Siempre operamos dentro de una transacci√≥n
        businessId: string,
        itemsDto: OrderItemInternalDto[]
    ): Promise<ProcessedOrderItemData[]> {
        this.logger.log(`[OrderItemProcessor] Processing ${itemsDto.length} items for business ${businessId}`);
        const processedItems: ProcessedOrderItemData[] = [];

        for (const itemDto of itemsDto) {
            const menuItem = await this.fetchAndValidateMenuItem(tx, itemDto.menuItemId, businessId);

            const {
                accumulatedModifierPrice, // Cambiado el nombre para mayor claridad
                modifierOptionsToCreateForDb,
            } = this.processAndValidateModifiersForItem(menuItem, itemDto.selectedModifierOptions || []);

            // El precio base del √≠tem ya lo tenemos en menuItem.price
            // priceAtPurchase = precio base del √≠tem + suma de ajustes de los modificadores
            const priceAtPurchase = new Prisma.Decimal(menuItem.price).add(accumulatedModifierPrice);
            const totalItemPrice = priceAtPurchase.mul(itemDto.quantity);

            processedItems.push({
                menuItemId: menuItem.id,
                quantity: itemDto.quantity,
                priceAtPurchase,
                totalItemPrice,
                notes: itemDto.notes,
                kdsDestination: menuItem.kdsDestination,
                itemNameSnapshot: menuItem.name_es || '√çtem (ES) no disponible', // Tomar snapshot
                itemDescriptionSnapshot: menuItem.description_es, // Tomar snapshot
                status: OrderItemStatus.PENDING_KDS, // Estado inicial por defecto
                modifierOptionsToCreate: modifierOptionsToCreateForDb,
            });
        }
        this.logger.log(`[OrderItemProcessor] Finished processing ${processedItems.length} items successfully.`);
        return processedItems;
    }

    /**
     * Obtiene y valida un MenuItem, asegurando que existe, pertenece al negocio y est√° disponible.
     * Incluye los grupos de modificadores y sus opciones disponibles.
     */
    private async fetchAndValidateMenuItem(
        tx: Prisma.TransactionClient,
        menuItemId: string,
        businessId: string
    ): Promise<MenuItemWithFullModifiers> {
        const menuItem = await tx.menuItem.findUnique({
            where: { id: menuItemId },
            ...menuItemWithFullModifiersArgs, // Usar el validador definido
        });

        if (!menuItem) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItemId}' not found.`);
            throw new NotFoundException(`√çtem de men√∫ con ID '${menuItemId}' no encontrado.`);
        }
        if (menuItem.businessId !== businessId) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItemId}' (negocio: ${menuItem.businessId}) does not belong to specified business '${businessId}'.`);
            throw new BadRequestException(`√çtem de men√∫ con ID '${menuItem.name_es || menuItemId}' no pertenece a este negocio.`);
        }
        if (!menuItem.isAvailable) {
            this.logger.warn(`[OrderItemProcessor] MenuItem '${menuItem.name_es || menuItemId}' is not available.`);
            throw new BadRequestException(`El √≠tem '${menuItem.name_es || menuItemId}' no est√° disponible actualmente.`);
        }
        return menuItem;
    }

    /**
     * Procesa los modificadores seleccionados para un √≠tem de men√∫,
     * calcula el ajuste total de precio y valida las selecciones contra las reglas del grupo.
     *
     * @param menuItem - El MenuItem completo con sus grupos de modificadores y opciones cargadas.
     * @param selectedOptionsDto - Array de IDs de las ModifierOption seleccionadas por el cliente para este √≠tem.
     * @returns Objeto con el ajuste total de precio de los modificadores y los datos para crear OrderItemModifierOption.
     */
    private processAndValidateModifiersForItem(
        menuItem: MenuItemWithFullModifiers,
        selectedOptionsDto: SelectedModifierOptionInternalDto[]
    ): {
        accumulatedModifierPrice: Prisma.Decimal; // Suma de todos los priceAdjustments de las opciones v√°lidas
        modifierOptionsToCreateForDb: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[];
    } {
        let accumulatedModifierPrice = new Prisma.Decimal(0);
        const modifierOptionsToCreateForDb: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[] = [];

        // Casteo seguro, ya que menuItemWithFullModifiersArgs incluye esto
        const typedModifierGroups = menuItem.modifierGroups as ModifierGroupWithSelectedOptions[];

        // Un mapa para rastrear cu√°ntas opciones se seleccionaron por grupo
        const selectionsByGroupId: Record<string, SelectedModifierOptionShape[]> = {};

        // Primero, iterar sobre las opciones seleccionadas por el cliente para validarlas y calcular precios
        for (const selectedOptDto of selectedOptionsDto) {
            let foundOption: SelectedModifierOptionShape | undefined;
            let parentGroupForOption: ModifierGroupWithSelectedOptions | undefined;

            // Buscar la opci√≥n seleccionada dentro de todos los grupos del √≠tem
            for (const group of typedModifierGroups) {
                // option es de tipo SelectedModifierOptionShape (definido arriba)
                const option = group.options.find(opt => opt.id === selectedOptDto.modifierOptionId);
                if (option) {
                    foundOption = option;
                    parentGroupForOption = group;
                    break;
                }
            }

            if (!foundOption || !parentGroupForOption) {
                this.logger.warn(`[OrderItemProcessor] Invalid or unavailable modifierOptionId '${selectedOptDto.modifierOptionId}' for MenuItem '${menuItem.id}' ('${menuItem.name_es}'). Option not found in any group or group not found.`);
                throw new BadRequestException(`Opci√≥n de modificador con ID '${selectedOptDto.modifierOptionId}' no es v√°lida, no est√° disponible o no pertenece a ning√∫n grupo del √≠tem '${menuItem.name_es}'.`);
            }
            
            // Asegurarse de que la opci√≥n tiene un groupId (deber√≠a ser as√≠ por el schema y la consulta)
            if (!foundOption.groupId) {
                 this.logger.error(`[OrderItemProcessor] Critical: ModifierOption '${foundOption.id}' ('${foundOption.name_es}') has no groupId. This indicates a data integrity issue or an error in the Prisma query.`);
                 throw new InternalServerErrorException(`Error de configuraci√≥n: La opci√≥n de modificador '${foundOption.name_es}' no tiene un grupo asignado.`);
            }
            // Asegurarse de que el groupId de la opci√≥n coincide con el ID del grupo donde se encontr√≥
             if (foundOption.groupId !== parentGroupForOption.id) {
                this.logger.error(`[OrderItemProcessor] Critical: ModifierOption '${foundOption.id}' groupId '${foundOption.groupId}' does not match parent group ID '${parentGroupForOption.id}'.`);
                throw new InternalServerErrorException(`Error de configuraci√≥n: Inconsistencia en la asignaci√≥n de grupo para la opci√≥n '${foundOption.name_es}'.`);
            }


            // Registrar la selecci√≥n para el grupo padre
            if (!selectionsByGroupId[parentGroupForOption.id]) {
                selectionsByGroupId[parentGroupForOption.id] = [];
            }
            selectionsByGroupId[parentGroupForOption.id].push(foundOption);

            // Acumular ajuste de precio
            accumulatedModifierPrice = accumulatedModifierPrice.add(foundOption.priceAdjustment);

            // Preparar datos para la tabla de uni√≥n OrderItemModifierOption
            modifierOptionsToCreateForDb.push({
                modifierOptionId: foundOption.id,
                optionNameSnapshot: foundOption.name_es || 'Opci√≥n sin nombre ES', // Tomar snapshot
                optionPriceAdjustmentSnapshot: foundOption.priceAdjustment,
            });
        }

        // Segundo, validar las reglas de cada grupo del MenuItem
        for (const group of typedModifierGroups) {
            const selectedOptionsInThisGroup = selectionsByGroupId[group.id] || [];
            const countInThisGroup = selectedOptionsInThisGroup.length;

            this.logger.debug(`[OrderItemProcessor] Validating Group ID: ${group.id} ('${group.name_es}'). Required: ${group.isRequired}, Min: ${group.minSelections}, Max: ${group.maxSelections}, UI: ${group.uiType}. Selected count: ${countInThisGroup}`);

            if (group.isRequired && countInThisGroup < group.minSelections) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for group '${group.name_es}': required min ${group.minSelections}, got ${countInThisGroup}.`);
                throw new BadRequestException(`Para el √≠tem '${menuItem.name_es}', el grupo de opciones '${group.name_es}' requiere al menos ${group.minSelections} selecci√≥n(es). Se recibieron ${countInThisGroup}.`);
            }

            if (countInThisGroup > group.maxSelections) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for group '${group.name_es}': allowed max ${group.maxSelections}, got ${countInThisGroup}.`);
                throw new BadRequestException(`Para el √≠tem '${menuItem.name_es}', el grupo de opciones '${group.name_es}' permite como m√°ximo ${group.maxSelections} selecci√≥n(es). Se recibieron ${countInThisGroup}.`);
            }

            // Si es tipo RADIO, y se seleccion√≥ m√°s de uno (aunque el frontend deber√≠a prevenirlo, es una guarda)
            if (group.uiType === 'RADIO' && countInThisGroup > 1) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for RADIO group '${group.name_es}': got ${countInThisGroup} selections, expected 0 or 1.`);
                throw new BadRequestException(`El grupo de opciones '${group.name_es}' (tipo RADIO) solo permite una selecci√≥n como m√°ximo.`);
            }
        }

        this.logger.log(`[OrderItemProcessor] Modifier processing for item '${menuItem.name_es}' complete. Accumulated adjustment: ${accumulatedModifierPrice}. Options to create: ${modifierOptionsToCreateForDb.length}`);
        return {
            accumulatedModifierPrice,
            modifierOptionsToCreateForDb,
        };
    }
}


// ====== [17] backend/src/modules/camarero/public/order-modification.service.ts ======
// backend/src/public/order-modification.service.ts
import {
    PrismaClient,
    Prisma,
    Order,
    OrderStatus,
    OrderItemStatus,
} from '@prisma/client';
import {
    Injectable,
    Logger,
    NotFoundException,
    BadRequestException,
    InternalServerErrorException,
} from '@nestjs/common';

import { OrderItemProcessorService, ProcessedOrderItemData } from './order-item-processor.service';

// Importar tipos desde el archivo centralizado
import {
    FrontendAddItemsToOrderDto,
    FrontendAddItemsOrderItemDto, // Este tipo ahora deber√≠a tener 'notes' y 'selectedModifierOptions'
    OrderItemInternalDto,         // Tipo que espera OrderItemProcessorService
    SelectedModifierOptionInternalDto // Tipo que espera OrderItemProcessorService
} from './order.types';

interface BusinessContextForOrder {
    id: string;
    isActive: boolean;
    isCamareroActive: boolean;
}

@Injectable()
export class OrderModificationService {
    private readonly logger = new Logger(OrderModificationService.name);
    private readonly orderItemProcessorService: OrderItemProcessorService;
    private prisma: PrismaClient;

    constructor() {
        this.prisma = new PrismaClient();
        this.orderItemProcessorService = new OrderItemProcessorService();
        this.logger.log("OrderModificationService instantiated");
    }

    async addItemsToExistingOrder(
        orderId: string,
        addItemsDto: FrontendAddItemsToOrderDto, // DTO del frontend
        businessSlug: string,
        _requestingCustomerId?: string | null
    ): Promise<Order> {
        this.logger.log(`[OrderModificationService] Attempting to add ${addItemsDto.items.length} items to order '${orderId}' for business slug '${businessSlug}'.`);

        const businessContext = await this._validateBusinessForOrdering(businessSlug);
        const businessId = businessContext.id;

        return this.prisma.$transaction(async (tx) => {
            this.logger.log(`[OrderModificationService TX] Transaction started for adding items to order '${orderId}'.`);

            const order = await tx.order.findUnique({
                where: { id: orderId },
                select: { id: true, status: true, businessId: true, totalAmount: true, finalAmount: true, notes: true, isBillRequested: true }
            });

            if (!order) {
                this.logger.warn(`[OrderModificationService TX] Order with ID '${orderId}' not found.`);
                throw new NotFoundException(`Pedido con ID '${orderId}' no encontrado.`);
            }
            if (order.businessId !== businessId) {
                this.logger.warn(`[OrderModificationService TX] Order '${orderId}' (business: ${order.businessId}) does not belong to specified business '${businessId}'.`);
                throw new BadRequestException(`El pedido no pertenece al negocio especificado.`);
            }

            const validStatusToAddItems: OrderStatus[] = [
                OrderStatus.RECEIVED, OrderStatus.IN_PROGRESS,
                OrderStatus.PARTIALLY_READY, OrderStatus.ALL_ITEMS_READY,
                OrderStatus.COMPLETED, OrderStatus.PENDING_PAYMENT,
            ];
            if (!validStatusToAddItems.includes(order.status)) {
                this.logger.warn(`[OrderModificationService TX] Cannot add items to order '${orderId}' in status '${order.status}'.`);
                throw new BadRequestException(`No se pueden a√±adir √≠tems a un pedido en estado '${order.status}'.`);
            }

            // --- CORRECCI√ìN EN EL MAPEO Y TIPADO ---
            // Mapear FrontendAddItemsOrderItemDto a OrderItemInternalDto
            const itemsToProcessDto: OrderItemInternalDto[] = addItemsDto.items.map((item: FrontendAddItemsOrderItemDto) => ({
                menuItemId: item.menuItemId,
                quantity: item.quantity,
                notes: item.notes, // 'notes' ahora existe en FrontendAddItemsOrderItemDto
                selectedModifierOptions: item.selectedModifierOptions?.map(
                    (sm: { modifierOptionId: string }) => ({ // Tipo expl√≠cito para 'sm'
                        modifierOptionId: sm.modifierOptionId
                    })
                ) || [], // Asegurar que sea un array vac√≠o si es undefined
            }));
            // --- FIN CORRECCI√ìN ---

            const processedNewItems: ProcessedOrderItemData[] =
                await this.orderItemProcessorService.processOrderItems(
                    tx,
                    businessId,
                    itemsToProcessDto
                );

            // ... (resto de la l√≥gica de la funci√≥n sin cambios)...
            if (processedNewItems.length === 0 && addItemsDto.items.length > 0) {
                this.logger.warn(`[OrderModificationService TX] All new items in payload were invalid. No items to add to order '${orderId}'.`);
                throw new BadRequestException('Ninguno de los nuevos √≠tems proporcionados pudo ser procesado.');
            }
             if (processedNewItems.length === 0 && addItemsDto.items.length === 0) {
                this.logger.warn(`[OrderModificationService TX] No new items provided in the payload to add to order '${orderId}'.`);
                throw new BadRequestException('No se proporcionaron √≠tems para a√±adir al pedido.');
            }

            const additionalAmount = processedNewItems.reduce(
                (sum, item) => sum.add(item.totalItemPrice),
                new Prisma.Decimal(0)
            );
            const newTotalAmount = new Prisma.Decimal(order.totalAmount).add(additionalAmount);
            const newFinalAmount = new Prisma.Decimal(order.finalAmount || order.totalAmount).add(additionalAmount);
            this.logger.log(`[OrderModificationService TX] Additional amount for order '${orderId}': ${additionalAmount}. New total: ${newTotalAmount}`);

            let updatedOrderNotes = order.notes;
            if (addItemsDto.customerNotes && addItemsDto.customerNotes.trim() !== '') {
                const additionNotePrefix = "Adici√≥n de √≠tems:";
                updatedOrderNotes = order.notes
                    ? `${order.notes}\n---\n${additionNotePrefix} ${addItemsDto.customerNotes.trim()}`
                    : `${additionNotePrefix} ${addItemsDto.customerNotes.trim()}`;
            }

            let newOrderStatus = order.status;
            let resetBillRequested = false;
            if (
                (order.status === OrderStatus.COMPLETED ||
                 order.status === OrderStatus.ALL_ITEMS_READY ||
                 order.status === OrderStatus.PENDING_PAYMENT) &&
                processedNewItems.length > 0
            ) {
                newOrderStatus = OrderStatus.IN_PROGRESS;
                this.logger.log(`[OrderModificationService TX] Order '${orderId}' was '${order.status}', new items added. Changing status to '${newOrderStatus}'.`);
                if (order.status === OrderStatus.PENDING_PAYMENT && order.isBillRequested) {
                    resetBillRequested = true;
                    this.logger.log(`[OrderModificationService TX] Bill was requested for order '${orderId}', resetting flag.`);
                }
            }

            const orderUpdateData: Prisma.OrderUpdateInput = {
                items: {
                    create: processedNewItems.map(pItem => ({
                        menuItemId: pItem.menuItemId,
                        quantity: pItem.quantity,
                        priceAtPurchase: pItem.priceAtPurchase,
                        totalItemPrice: pItem.totalItemPrice,
                        notes: pItem.notes,
                        kdsDestination: pItem.kdsDestination,
                        itemNameSnapshot: pItem.itemNameSnapshot,
                        itemDescriptionSnapshot: pItem.itemDescriptionSnapshot,
                        status: pItem.status,
                        ...(pItem.modifierOptionsToCreate.length > 0 && {
                            selectedModifiers: {
                                createMany: { data: pItem.modifierOptionsToCreate },
                            },
                        }),
                    })),
                },
                totalAmount: newTotalAmount,
                finalAmount: newFinalAmount,
                notes: updatedOrderNotes,
                status: newOrderStatus,
            };

            if (resetBillRequested) {
                orderUpdateData.isBillRequested = false;
            }

            const updatedOrder = await tx.order.update({
                where: { id: orderId },
                data: orderUpdateData,
                include: { items: { include: { selectedModifiers: true } }, table: true },
            });

            this.logger.log(`[OrderModificationService TX] Items successfully added to order '${orderId}'. New total: ${updatedOrder.totalAmount}. New status: ${updatedOrder.status}`);
            return updatedOrder;
        });
    }

    private async _validateBusinessForOrdering(businessSlug: string): Promise<BusinessContextForOrder> {
        // ... (sin cambios)
        const business = await this.prisma.business.findUnique({
            where: { slug: businessSlug },
            select: { id: true, isActive: true, isCamareroActive: true },
        });

        if (!business) {
            this.logger.warn(`[OrderModificationService] Business with slug '${businessSlug}' not found.`);
            throw new NotFoundException(`Negocio con slug '${businessSlug}' no encontrado.`);
        }
        if (!business.isActive) {
            this.logger.warn(`[OrderModificationService] Business '${businessSlug}' is not active.`);
            throw new BadRequestException(`El negocio '${businessSlug}' no est√° activo y no puede procesar pedidos.`);
        }
        if (!business.isCamareroActive) {
            this.logger.warn(`[OrderModificationService] Camarero module not active for business '${businessSlug}'.`);
            throw new BadRequestException(`El m√≥dulo de pedidos (Camarero) no est√° activo para el negocio '${businessSlug}'.`);
        }
        this.logger.log(`[OrderModificationService] Business '${businessSlug}' validated for ordering. ID: ${business.id}`);
        return business;
    }
}


// ====== [18] backend/src/modules/camarero/public/order-payment.service.ts ======
// backend/src/modules/camarero/public/order-payment.service.ts (CORREGIDO)
import {
    PrismaClient,
    Prisma,
    Order,
    OrderStatus,
    TableStatus,
    User,
    Business,
    ActivityType,
    TierBenefit,
} from '@prisma/client';
import {
    Injectable,
    Logger,
    NotFoundException,
    BadRequestException,
    ForbiddenException,
    InternalServerErrorException,
} from '@nestjs/common';

// --- RUTAS CORREGIDAS ---
import { TableService } from '../../../shared/services/table.service';
import { LoyaltyPointsService } from '../../../shared/services/loyalty-points.service';
import { updateUserTier } from '../../../modules/loyalpyme/tiers/tier-logic.service';
// --- FIN RUTAS CORREGIDAS ---

// Tipos para los datos que necesita LoyaltyPointsService
type OrderForLoyalty = Pick<Order, 'id' | 'orderNumber' | 'finalAmount' | 'totalAmount' | 'customerLCoId' | 'businessId'>;
type CustomerForLoyalty = User & {
    currentTier?: ({ benefits: Pick<TierBenefit, 'type' | 'value' | 'isActive'>[] } & { id: string; name: string }) | null;
};
type BusinessForLoyalty = Pick<Business, 'id' | 'pointsPerEuro' | 'isLoyaltyCoreActive'>;

@Injectable()
export class OrderPaymentService {
    private readonly logger = new Logger(OrderPaymentService.name);
    private readonly tableService: TableService;
    private readonly loyaltyPointsService: LoyaltyPointsService;
    private prisma: PrismaClient;

    constructor() {
        this.prisma = new PrismaClient();
        this.tableService = new TableService();
        this.loyaltyPointsService = new LoyaltyPointsService();
        this.logger.log("OrderPaymentService instantiated");
    }

    async requestBillForClient(
        orderId: string,
        paymentPreference?: string | null
    ): Promise<Order> {
        this.logger.log(`[OrderPaymentService] Client requesting bill for order '${orderId}'. Preference: ${paymentPreference || 'N/A'}`);

        return this.prisma.$transaction(async (tx) => {
            const order = await tx.order.findUnique({
                where: { id: orderId },
                select: { id: true, status: true, businessId: true, tableId: true, orderNumber: true },
            });

            if (!order) {
                this.logger.warn(`[OrderPaymentService TX] Order '${orderId}' not found for client bill request.`);
                throw new NotFoundException(`Pedido con ID '${orderId}' no encontrado.`);
            }

            const allowedStates: OrderStatus[] = [
                OrderStatus.RECEIVED, OrderStatus.IN_PROGRESS,
                OrderStatus.PARTIALLY_READY, OrderStatus.ALL_ITEMS_READY,
                OrderStatus.COMPLETED,
            ];
            if (!allowedStates.includes(order.status)) {
                this.logger.warn(`[OrderPaymentService TX] Cannot request bill for order '${orderId}' in status '${order.status}'.`);
                throw new BadRequestException(`No se puede solicitar la cuenta para un pedido en estado '${order.status}'.`);
            }

            const updateData: Prisma.OrderUpdateInput = {
                status: OrderStatus.PENDING_PAYMENT,
                isBillRequested: true,
            };
            if (paymentPreference !== undefined) {
                updateData.paymentMethodPreference = paymentPreference;
            }

            const updatedOrder = await tx.order.update({
                where: { id: orderId },
                data: updateData,
            });
            this.logger.log(`[OrderPaymentService TX] Order '${orderId}' status set to PENDING_PAYMENT by client request.`);

            if (order.tableId && order.businessId) {
                try {
                    await this.tableService.updateTableStatus(tx, order.tableId, TableStatus.PENDING_PAYMENT_TABLE);
                    this.logger.log(`[OrderPaymentService TX] Table ID '${order.tableId}' status updated to PENDING_PAYMENT_TABLE.`);
                } catch (tableError) {
                    this.logger.error(`[OrderPaymentService TX] Failed to update table status for table '${order.tableId}' during client bill request. Continuing. Error:`, tableError);
                }
            }
            return updatedOrder;
        });
    }

    async markOrderAsPaid(
        orderId: string,
        paidByStaffId: string,
        businessId: string,
        paymentDetails?: { method?: string; notes?: string }
    ): Promise<Order> {
        this.logger.log(`[OrderPaymentService] Staff '${paidByStaffId}' attempting to mark order '${orderId}' as PAID for business '${businessId}'. Payment method: ${paymentDetails?.method || 'N/A'}`);

        return this.prisma.$transaction(async (tx) => {
            const order = await tx.order.findUnique({
                where: { id: orderId },
                include: {
                    business: { select: { id: true, isLoyaltyCoreActive: true, pointsPerEuro: true } },
                    table: { select: { id: true, status: true } },
                    customerLCo: {
                        include: {
                            currentTier: {
                                include: {
                                    benefits: { where: { isActive: true, type: 'POINTS_MULTIPLIER' } }
                                }
                            }
                        }
                    }
                }
            });

            if (!order) {
                this.logger.warn(`[OrderPaymentService TX] Order '${orderId}' not found.`);
                throw new NotFoundException(`Pedido con ID '${orderId}' no encontrado.`);
            }
            if (order.businessId !== businessId) {
                this.logger.warn(`[OrderPaymentService TX] Order '${orderId}' (business: ${order.businessId}) does not belong to staff's business '${businessId}'.`);
                throw new ForbiddenException("El pedido no pertenece al negocio del personal.");
            }

            if (order.status !== OrderStatus.PENDING_PAYMENT && order.status !== OrderStatus.COMPLETED) {
                this.logger.warn(`[OrderPaymentService TX] Cannot mark order '${orderId}' as PAID. Current status: '${order.status}'.`);
                throw new BadRequestException(`Solo se pueden marcar como pagados pedidos en estado 'PENDING_PAYMENT' o 'COMPLETED'. Estado actual: ${order.status}`);
            }

            const updatedOrder = await tx.order.update({
                where: { id: orderId },
                data: {
                    status: OrderStatus.PAID,
                    paidAt: new Date(),
                    paidByUserId: paidByStaffId,
                    paymentMethodUsed: paymentDetails?.method,
                },
            });
            this.logger.log(`[OrderPaymentService TX] Order '${orderId}' status updated to PAID.`);

            if (order.tableId && order.table && order.table.status !== TableStatus.AVAILABLE) {
                await this.tableService.updateTableStatus(tx, order.tableId, TableStatus.AVAILABLE);
                this.logger.log(`[OrderPaymentService TX] Table ID '${order.tableId}' status updated to AVAILABLE.`);
            }

            if (order.customerLCoId && order.business?.isLoyaltyCoreActive && order.customerLCo) {
                const loyaltyResult = await this.loyaltyPointsService.awardPointsForLcOrder(
                    tx,
                    order as OrderForLoyalty,
                    order.customerLCo as CustomerForLoyalty,
                    order.business as BusinessForLoyalty
                );
                if (loyaltyResult) {
                    this.logger.log(`[OrderPaymentService TX] Loyalty points awarded: ${loyaltyResult.pointsAwarded} for order '${orderId}'.`);
                } else {
                    this.logger.warn(`[OrderPaymentService TX] Loyalty points awarding process for order '${orderId}' returned null (possibly skipped or failed internally).`);
                }
            } else {
                if (order.customerLCoId) {
                    this.logger.log(`[OrderPaymentService TX] LCo module not active for business '${order.businessId}' or customer data missing. Skipping LCo points for order '${order.id}'.`);
                }
            }
            return updatedOrder;
        });
    }
}


// ====== [19] backend/src/modules/camarero/public/order.controller.ts ======
// backend/src/public/order.controller.ts
// Version 1.2.1 (Fix private logger access in NestJS controller part)
import { Controller, Post, Body, Param, Get, Req, BadRequestException, NotFoundException } from '@nestjs/common';
import { Request as ExpressRequest, Response as ExpressResponse, NextFunction } from 'express';
import { Order } from '@prisma/client';
import { plainToInstance } from 'class-transformer';
import { validate } from 'class-validator';

import { CreateOrderDto, AddItemsToOrderDto, RequestBillClientPayloadDto } from './order.dto';
import { CreateOrderPayloadInternalDto, PublicOrderStatusInfo } from './order.types';

import { OrderService } from './order.service';
import { OrderCreationService } from './order-creation.service';
import { OrderModificationService } from './order-modification.service';
import { OrderPaymentService } from './order-payment.service';

const orderServiceInstance = new OrderService();
const orderCreationServiceInstance = new OrderCreationService();
const orderModificationServiceInstance = new OrderModificationService();
const orderPaymentServiceInstance = new OrderPaymentService();

// --- Handlers Express (sin cambios respecto a la versi√≥n anterior que te pas√©) ---

export const createPublicOrderHandler = async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
    try {
        const businessSlug = req.params.businessSlug;
        const createOrderDto = plainToInstance(CreateOrderDto, req.body as Record<string, any>);
        const validationErrors = await validate(createOrderDto, { whitelist: true, forbidNonWhitelisted: true });

        if (validationErrors.length > 0) {
            console.error('[OrderCtrl createPublic] DTO validation errors:', JSON.stringify(validationErrors, null, 2));
            const formattedErrors = validationErrors.map(err => ({ property: err.property, constraints: err.constraints }));
            return res.status(400).json({ message: 'Error de validaci√≥n en los datos del pedido.', errors: formattedErrors });
        }

        if (!businessSlug) {
            return res.status(400).json({ message: 'Business slug es requerido en la ruta.' });
        }

        const servicePayload: CreateOrderPayloadInternalDto = {
            tableIdentifier: createOrderDto.tableIdentifier,
            orderNotes: createOrderDto.customerNotes,
            customerId: createOrderDto.customerId,
            items: createOrderDto.items.map(item => ({
                menuItemId: item.menuItemId,
                quantity: item.quantity,
                notes: item.notes,
                selectedModifierOptions: item.selectedModifierOptions?.map(mod => ({ modifierOptionId: mod.modifierOptionId })) || [],
            })),
        };

        const newOrder: Order = await orderCreationServiceInstance.createNewOrder(
            businessSlug,
            servicePayload,
            createOrderDto.customerId
        );
        res.status(201).json(newOrder);
    } catch (error) {
        next(error);
    }
};

export const addItemsToExistingOrderHandler = async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
    try {
        const orderId = req.params.orderId;
        const addItemsToOrderDto = plainToInstance(AddItemsToOrderDto, req.body as Record<string, any>);
        const validationErrors = await validate(addItemsToOrderDto, { whitelist: true, forbidNonWhitelisted: true });

        if (validationErrors.length > 0) {
            console.error('[OrderCtrl addItems] DTO validation errors:', JSON.stringify(validationErrors, null, 2));
            const formattedErrors = validationErrors.map(err => ({ property: err.property, constraints: err.constraints }));
            return res.status(400).json({ message: 'Error de validaci√≥n al a√±adir √≠tems.', errors: formattedErrors });
        }

        const businessSlugFromHeader = req.headers['x-loyalpyme-business-slug'] as string;

        if (!orderId) return res.status(400).json({ message: 'Order ID es requerido.' });
        if (!businessSlugFromHeader) return res.status(400).json({ message: 'Contexto de Business Slug (x-loyalpyme-business-slug header) es requerido.' });

        const updatedOrder: Order = await orderModificationServiceInstance.addItemsToExistingOrder(
            orderId,
            addItemsToOrderDto,
            businessSlugFromHeader,
        );
        res.status(200).json(updatedOrder);
    } catch (error) {
        next(error);
    }
};

export const getPublicOrderStatusHandler = async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
    try {
        const orderId = req.params.orderId;
        if (!orderId) {
            return res.status(400).json({ message: 'Order ID es requerido.' });
        }
        const statusInfo: PublicOrderStatusInfo | null = await orderServiceInstance.getOrderStatus(orderId);
        if (!statusInfo) {
            return res.status(404).json({ message: `Pedido con ID ${orderId} no encontrado.` });
        }
        res.status(200).json(statusInfo);
    } catch (error) {
        next(error);
    }
};

export const requestBillByClientHandler = async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
    const { orderId } = req.params;
    const requestBillDto = plainToInstance(RequestBillClientPayloadDto, (req.body || {}) as Record<string, any>);
    const validationErrors = await validate(requestBillDto);

    if (validationErrors.length > 0) {
        const formattedErrors = validationErrors.map(err => ({ property: err.property, constraints: err.constraints }));
        return res.status(400).json({ message: 'Datos inv√°lidos para solicitar la cuenta.', errors: formattedErrors });
    }

    if (!orderId) {
        return res.status(400).json({ message: "Falta el ID del pedido (orderId) en la URL." });
    }

    console.log(`[OrderCtrl requestBillClient] Client requesting bill for order ${orderId}. Preference: ${requestBillDto.paymentPreference || 'N/A'}`);

    try {
        const updatedOrder: Order = await orderPaymentServiceInstance.requestBillForClient(
            orderId,
            requestBillDto.paymentPreference
        );

        res.status(200).json({
            message: `Cuenta solicitada para el pedido #${updatedOrder.orderNumber}. Estado: ${updatedOrder.status}.`,
            order: {
                id: updatedOrder.id,
                orderNumber: updatedOrder.orderNumber,
                status: updatedOrder.status,
                isBillRequested: updatedOrder.isBillRequested,
            }
        });
    } catch (error) {
        next(error);
    }
};

// --- Clase de Controlador NestJS (DEPRECADA o para futura migraci√≥n completa a NestJS) ---
@Controller('public/orders_nest')
export class OrderController {
  constructor(
    private readonly creationService: OrderCreationService,
    private readonly modificationService: OrderModificationService,
    private readonly paymentService: OrderPaymentService,
    private readonly statusService: OrderService
  ) {}

  @Post(':businessSlug')
  async createOrderNest(
    @Param('businessSlug') businessSlug: string,
    @Body() createOrderDto: CreateOrderDto,
    @Req() req: any,
  ) {
    const user = req.user;
    const servicePayload: CreateOrderPayloadInternalDto = {
      tableIdentifier: createOrderDto.tableIdentifier,
      orderNotes: createOrderDto.customerNotes,
      customerId: createOrderDto.customerId || user?.id,
      items: createOrderDto.items.map((item) => ({
        menuItemId: item.menuItemId,
        quantity: item.quantity,
        notes: item.notes,
        selectedModifierOptions: item.selectedModifierOptions?.map(mod => ({
            modifierOptionId: mod.modifierOptionId
        })) || []
      })),
    };
    return this.creationService.createNewOrder(
        businessSlug,
        servicePayload,
        createOrderDto.customerId || user?.id
    );
  }

  @Get(':orderId/status')
  async getOrderStatusNest(@Param('orderId') orderId: string) {
    const statusInfo = await this.statusService.getOrderStatus(orderId);
    if (!statusInfo) {
        throw new NotFoundException(`Pedido con ID ${orderId} no encontrado.`);
    }
    return statusInfo;
  }

  @Post(':orderId/items')
  async addItemsToExistingOrderNest(
    @Param('orderId') orderId: string,
    @Body() addItemsToOrderDto: AddItemsToOrderDto,
    @Req() req: any,
  ) {
    const businessSlugFromHeader = req.headers['x-loyalpyme-business-slug'] as string;
    const user = req.user;
    if (!businessSlugFromHeader) {
      throw new BadRequestException('Contexto de Business Slug (x-loyalpyme-business-slug header) es requerido.');
    }
    return this.modificationService.addItemsToExistingOrder(
      orderId,
      addItemsToOrderDto,
      businessSlugFromHeader,
      user?.id,
    );
  }

  @Post(':orderId/request-bill')
  async requestBillByClientNest(
      @Param('orderId') orderId: string,
      @Body() requestBillDto: RequestBillClientPayloadDto
  ) {
      if (!orderId) {
          throw new BadRequestException("Falta el ID del pedido (orderId) en la URL.");
      }
      // --- CORRECCI√ìN: Quitar el log que accede a logger privado ---
      // this.paymentService.logger.log(`[NestCtrl requestBillClient] Client requesting bill for order ${orderId}. Preference: ${requestBillDto.paymentPreference || 'N/A'}`);
      // El OrderPaymentService ya loguea esto internamente.
      // --- FIN CORRECCI√ìN ---
      const updatedOrder = await this.paymentService.requestBillForClient(
          orderId,
          requestBillDto.paymentPreference
      );
      return {
          message: `Cuenta solicitada para el pedido #${updatedOrder.orderNumber}. Estado: ${updatedOrder.status}.`,
          order: {
              id: updatedOrder.id,
              orderNumber: updatedOrder.orderNumber,
              status: updatedOrder.status,
              isBillRequested: updatedOrder.isBillRequested,
          }
      };
  }
}


// ====== [20] backend/src/modules/camarero/public/order.dto.ts ======
// backend/src/public/order.dto.ts
// Versi√≥n 1.7.1 (Add IsArray() to selectedModifierOptions and make optional)

import { Type } from 'class-transformer';
import {
  IsArray,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
  IsUUID,
  Min,
  ValidateNested,
} from 'class-validator';

// DTO para cada opci√≥n de modificador seleccionada DENTRO de un √≠tem de pedido
export class SelectedOrderModifierOptionDto {
  @IsString()
  @IsNotEmpty({ message: 'modifierOptionId no puede estar vac√≠o.'})
  modifierOptionId!: string;
}

// DTO para cada √≠tem de pedido en la creaci√≥n
export class CreateOrderItemDto {
  @IsUUID()
  @IsNotEmpty({ message: 'El ID del art√≠culo del men√∫ no puede estar vac√≠o al crear.' })
  menuItemId!: string;

  @IsNumber({}, { message: 'La cantidad debe ser un n√∫mero al crear.' })
  @Min(1, { message: 'La cantidad debe ser como m√≠nimo 1 al crear.' })
  quantity!: number;

  @IsOptional()
  @IsString()
  notes?: string;

  // --- CORRECCI√ìN AQU√ç ---
  @IsOptional() // El array completo es opcional
  @IsArray({ message: 'Los modificadores seleccionados deben ser un array.' }) // Asegurarse de que, si viene, sea un array
  @ValidateNested({ each: true })
  @Type(() => SelectedOrderModifierOptionDto)
  selectedModifierOptions?: SelectedOrderModifierOptionDto[];
  // --- FIN CORRECCI√ìN ---
}

// DTO principal para crear un pedido
export class CreateOrderDto {
  @IsOptional()
  @IsString()
  businessId?: string;

  @IsString({ message: 'El identificador de mesa debe ser texto.' })
  @IsOptional()
  tableIdentifier?: string;

  @IsArray({ message: 'Los √≠tems deben ser un array al crear.' })
  @ValidateNested({ each: true, message: 'Cada √≠tem debe ser v√°lido al crear.' })
  @Type(() => CreateOrderItemDto)
  items!: CreateOrderItemDto[];

  @IsString({ message: 'Las notas del cliente deben ser texto.' })
  @IsOptional()
  customerNotes?: string;

  @IsUUID()
  @IsOptional()
  customerId?: string;
}

// --- DTOs para A√ëADIR √≠tems a un pedido existente (tambi√©n corregido) ---

export class AddItemsOrderItemDto {
    @IsUUID()
    @IsNotEmpty({ message: 'El ID del art√≠culo del men√∫ no puede estar vac√≠o.' })
    menuItemId!: string;

    @IsNumber({}, { message: 'La cantidad debe ser un n√∫mero.' })
    @Min(1, { message: 'La cantidad debe ser como m√≠nimo 1.' })
    quantity!: number;

    @IsOptional()
    @IsString()
    notes?: string;
    
    // --- CORRECCI√ìN AQU√ç ---
    @IsOptional()
    @IsArray({ message: 'Los modificadores seleccionados deben ser un array.' })
    @ValidateNested({ each: true })
    @Type(() => SelectedOrderModifierOptionDto)
    selectedModifierOptions?: SelectedOrderModifierOptionDto[];
    // --- FIN CORRECCI√ìN ---
}

export class AddItemsToOrderDto {
    @IsArray({ message: 'Los √≠tems deben ser un array.' })
    @ValidateNested({ each: true, message: 'Cada √≠tem debe ser v√°lido.' })
    @Type(() => AddItemsOrderItemDto)
    items!: AddItemsOrderItemDto[];

    @IsString({ message: 'Las notas del cliente deben ser texto.' })
    @IsOptional()
    customerNotes?: string;
}

// DTO para solicitar la cuenta (sin cambios)
export class RequestBillClientPayloadDto {
  @IsOptional()
  @IsString({ message: 'La preferencia de pago debe ser texto.' })
  paymentPreference?: string;
}


// ====== [21] backend/src/modules/camarero/public/order.service.ts ======
// backend/src/public/order.service.ts
// Versi√≥n 2.1.0 (Refactored to use dedicated sub-services for creation, modification, and payment logic)
import {
    Injectable,
    Logger,
    // Las excepciones espec√≠ficas ya no se lanzan desde aqu√≠, sino desde los sub-servicios.
} from '@nestjs/common';
import {
    PrismaClient,
    Order,
    // Ya no se necesitan la mayor√≠a de los otros tipos de Prisma aqu√≠
} from '@prisma/client';

// Importar los nuevos servicios que har√°n el trabajo pesado
import { OrderCreationService } from './order-creation.service';
import { OrderModificationService } from './order-modification.service';
import { OrderPaymentService } from './order-payment.service';

// Importar los tipos necesarios desde el archivo centralizado
import {
    CreateOrderPayloadInternalDto,
    PublicOrderStatusInfo,
    PublicOrderItemStatusInfo,
    FrontendAddItemsToOrderDto,
} from './order.types'; // Asumiendo que se llama order.types.ts

@Injectable()
export class OrderService {
    private readonly logger = new Logger(OrderService.name);

    // Instanciar los nuevos servicios. En un entorno NestJS completo, se inyectar√≠an.
    private readonly orderCreationService: OrderCreationService;
    private readonly orderModificationService: OrderModificationService;
    private readonly orderPaymentService: OrderPaymentService;
    private readonly prisma: PrismaClient; // Necesario solo para getOrderStatus si se queda aqu√≠

    constructor() {
        this.orderCreationService = new OrderCreationService();
        this.orderModificationService = new OrderModificationService();
        this.orderPaymentService = new OrderPaymentService();
        this.prisma = new PrismaClient();
        this.logger.log("OrderService (Public Orchestrator) instantiated");
    }

    /**
     * Orquesta la creaci√≥n de un nuevo pedido delegando al OrderCreationService.
     */
    async createOrder(
        businessSlug: string,
        payload: CreateOrderPayloadInternalDto,
        requestingCustomerId?: string | null
    ): Promise<Order> {
        this.logger.log(`[OrderService -> Create] Orchestrating new order for business slug '${businessSlug}'.`);
        // La l√≥gica compleja ahora vive en OrderCreationService
        return this.orderCreationService.createNewOrder(businessSlug, payload, requestingCustomerId);
    }

    /**
     * Orquesta la adici√≥n de √≠tems a un pedido existente delegando al OrderModificationService.
     */
    async addItemsToOrder(
        orderId: string,
        addItemsDto: FrontendAddItemsToOrderDto,
        businessSlug: string,
        requestingCustomerId?: string | null,
    ): Promise<Order> {
        this.logger.log(`[OrderService -> AddItems] Orchestrating add items to order '${orderId}' for business slug '${businessSlug}'.`);
        // La l√≥gica compleja ahora vive en OrderModificationService
        return this.orderModificationService.addItemsToExistingOrder(
            orderId,
            addItemsDto,
            businessSlug,
            requestingCustomerId
        );
    }

    /**
     * Orquesta la solicitud de cuenta por parte de un cliente delegando al OrderPaymentService.
     */
    async requestBillForClient(
        orderId: string,
        paymentPreference?: string | null
    ): Promise<Order> {
        this.logger.log(`[OrderService -> RequestBillClient] Orchestrating client bill request for order '${orderId}'.`);
        // La l√≥gica compleja ahora vive en OrderPaymentService
        return this.orderPaymentService.requestBillForClient(orderId, paymentPreference);
    }

    /**
     * Orquesta el marcado de un pedido como pagado delegando al OrderPaymentService.
     * Este m√©todo ser√≠a llamado t√≠picamente desde un servicio de staff (como WaiterService), no directamente desde un controlador p√∫blico.
     */
    async markOrderAsPaid(
        orderId: string,
        paidByStaffId: string,
        businessId: string,
        paymentDetails?: { method?: string; notes?: string }
    ): Promise<Order> {
        this.logger.log(`[OrderService -> MarkPaid] Orchestrating mark order '${orderId}' as PAID by staff '${paidByStaffId}'.`);
        // La l√≥gica compleja ahora vive en OrderPaymentService
        return this.orderPaymentService.markOrderAsPaid(orderId, paidByStaffId, businessId, paymentDetails);
    }

    /**
     * Obtiene la informaci√≥n p√∫blica del estado de un pedido.
     * Esta funci√≥n es principalmente de lectura y puede permanecer aqu√≠.
     */
    async getOrderStatus(orderId: string): Promise<PublicOrderStatusInfo | null> {
        this.logger.log(`[OrderService -> GetStatus] Fetching public status for order '${orderId}'.`);
        try {
            const order = await this.prisma.order.findUnique({
                where: { id: orderId },
                select: {
                    id: true, orderNumber: true, status: true, notes: true, createdAt: true,
                    isBillRequested: true,
                    table: { select: { identifier: true } },
                    items: {
                        select: { id: true, itemNameSnapshot: true, itemDescriptionSnapshot: true, quantity: true, status: true },
                        orderBy: { createdAt: 'asc' }
                    }
                }
            });

            if (!order) {
                this.logger.warn(`[OrderService getOrderStatus] Pedido con ID ${orderId} no encontrado.`);
                return null;
            }

            const itemsInfo: PublicOrderItemStatusInfo[] = order.items.map(item => ({
                id: item.id,
                menuItemName_es: item.itemNameSnapshot,
                menuItemName_en: null, // Si tuvieras itemNameSnapshot_en, lo usar√≠as aqu√≠
                quantity: item.quantity,
                status: item.status,
            }));

            const orderStatusInfo: PublicOrderStatusInfo = {
                orderId: order.id,
                orderNumber: order.orderNumber,
                orderStatus: order.status,
                items: itemsInfo,
                tableIdentifier: order.table?.identifier || null,
                orderNotes: order.notes,
                createdAt: order.createdAt,
                isBillRequested: order.isBillRequested,
            };

            this.logger.log(`[OrderService -> GetStatus] Status for order '${orderId}': ${orderStatusInfo.orderStatus}`);
            return orderStatusInfo;
        } catch (error) {
            this.logger.error(`[OrderService -> GetStatus] Error fetching status for order '${orderId}':`, error);
            // Relanzar para que el controlador lo maneje
            throw error;
        }
    }
}


// ====== [22] backend/src/modules/camarero/public/order.types.ts ======
// backend/src/public/order.types.ts
import { OrderStatus, OrderItemStatus, Prisma } from '@prisma/client';

// --- DTOs y Tipos para la L√≥gica Interna de los Servicios de Pedidos ---

/**
 * Representa una opci√≥n de modificador seleccionada, usado internamente por los servicios
 * al procesar los payloads de entrada.
 */
export interface SelectedModifierOptionInternalDto {
    modifierOptionId: string;
}

/**
 * Representa un √≠tem de pedido en su forma interna, tal como lo esperan los servicios
 * de procesamiento y creaci√≥n antes de la validaci√≥n completa y el c√°lculo de precios.
 */
export interface OrderItemInternalDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: SelectedModifierOptionInternalDto[] | null; // Array de IDs de opciones
}

/**
 * Payload interno que usan OrderCreationService y OrderModificationService,
 * derivado de lo que env√≠an los DTOs del frontend/controlador.
 */
export interface CreateOrderPayloadInternalDto {
    tableIdentifier?: string | null;
    customerId?: string | null; // Cliente LCo
    orderNotes?: string | null; // Notas generales del pedido
    items: OrderItemInternalDto[];
}

/**
 * Estructura de datos que devuelve OrderItemProcessorService para cada √≠tem procesado.
 * Contiene toda la informaci√≥n validada y calculada lista para la creaci√≥n en BD.
 */
export interface ProcessedOrderItemData {
    menuItemId: string;
    quantity: number;
    priceAtPurchase: Prisma.Decimal; // Precio unitario del √≠tem CON modificadores
    totalItemPrice: Prisma.Decimal;  // priceAtPurchase * quantity
    notes?: string | null;           // Notas espec√≠ficas del √≠tem
    kdsDestination: string | null;
    itemNameSnapshot: string;         // Snapshot del nombre del √≠tem (ej. en ES)
    itemDescriptionSnapshot: string | null; // Snapshot de la descripci√≥n (ej. en ES)
    status: OrderItemStatus;         // Estado inicial (ej. PENDING_KDS)
    // Datos para crear los OrderItemModifierOption asociados
    modifierOptionsToCreate: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[];
}


// --- Estructuras para la Respuesta P√∫blica del Estado del Pedido ---

/**
 * Informaci√≥n de un √≠tem de pedido para la vista p√∫blica de estado.
 */
export interface PublicOrderItemStatusInfo {
    id: string;                     // ID del OrderItem
    menuItemName_es: string | null; // Snapshot del nombre en espa√±ol
    menuItemName_en: string | null; // Snapshot del nombre en ingl√©s (o el idioma secundario)
    quantity: number;
    status: OrderItemStatus;
}

/**
 * Informaci√≥n completa del estado de un pedido para la vista p√∫blica.
 */
export interface PublicOrderStatusInfo {
    orderId: string;
    orderNumber: string;
    orderStatus: OrderStatus;
    items: PublicOrderItemStatusInfo[];
    tableIdentifier?: string | null;
    orderNotes?: string | null;
    createdAt: Date;
    isBillRequested?: boolean; // Indica si el cliente/personal ya solicit√≥ la cuenta
    // Podr√≠as a√±adir m√°s campos si el cliente los necesita en esta vista,
    // como finalAmount, paymentMethodPreference, etc.
    // finalAmount?: Prisma.Decimal;
}


// --- DTOs que representan los payloads esperados desde el Frontend/Controlador ---
// Estos son los que se validar√≠an con class-validator en el controlador (order.dto.ts).
// Los replicamos aqu√≠ (o los importar√≠amos desde order.dto.ts) para claridad en los servicios.

/**
 * DTO para una opci√≥n de modificador seleccionada dentro de un √≠tem, tal como viene del frontend.
 */
export interface FrontendSelectedOrderModifierOptionDto {
    modifierOptionId: string;
}

/**
 * DTO para un √≠tem de pedido individual al crear un nuevo pedido, tal como viene del frontend.
 */
export interface FrontendCreateOrderItemDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: FrontendSelectedOrderModifierOptionDto[] | null;
}

/**
 * DTO principal para crear un nuevo pedido, tal como viene del frontend.
 */
export interface FrontendCreateOrderDto {
    tableIdentifier?: string | null;
    customerNotes?: string | null; // Notas generales del pedido
    customerId?: string | null;    // ID del cliente LCo (opcional)
    items: FrontendCreateOrderItemDto[];
    // businessId o businessSlug no vienen en el body para la creaci√≥n p√∫blica, van en la URL del endpoint.
}

/**
 * DTO para un √≠tem individual al a√±adir √≠tems a un pedido existente, tal como viene del frontend.
 */
export interface FrontendAddItemsOrderItemDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;                                       // Notas espec√≠ficas para este √≠tem
    selectedModifierOptions?: Array<{ modifierOptionId: string }>; // Consistente con CreateOrderItemDto
}

/**
 * DTO principal para a√±adir √≠tems a un pedido existente, tal como viene del frontend.
 */
export interface FrontendAddItemsToOrderDto {
    items: FrontendAddItemsOrderItemDto[];
    customerNotes?: string; // Notas generales para ESTA ADICI√ìN de √≠tems (podr√≠an concatenarse a las existentes)
}

/**
 * DTO para el payload opcional que el cliente puede enviar al solicitar la cuenta.
 */
export interface FrontendRequestBillClientPayloadDto {
  paymentPreference?: string | null; // Ej: "EFECTIVO", "TARJETA"
}

/**
 * DTO para el payload que el personal puede enviar al solicitar la cuenta (desde WaiterController).
 */
export interface FrontendRequestBillStaffPayloadDto {
  paymentPreference?: string | null;
  // Podr√≠a incluir m√°s campos si es necesario, como payAmountInput del Development Plan
}

/**
 * DTO para el payload que el personal env√≠a al marcar un pedido como pagado (desde WaiterController).
 */
export interface FrontendMarkOrderAsPaidPayloadDto {
  method?: string; // Ej: "EFECTIVO_CAJA", "TARJETA_VISA_XXXX"
  notes?: string | null; // Notas adicionales sobre el pago
  // Podr√≠a incluir amountPaid si se maneja cambio, etc.
}


// ====== [23] backend/src/modules/camarero/waiter.controller.ts ======
// backend/src/camarero/waiter.controller.ts
// Version 1.3.1 (Adjusted for waiter.service v1.3.0 and simplified markAsPaid response)

import { Request, Response, NextFunction } from 'express';
import { OrderItemStatus, Order, OrderStatus, Prisma, OrderItem } from '@prisma/client';

// Importar el servicio de camarero existente
import * as waiterService from './waiter.service'; // Asume que waiter.service.ts est√° en la misma carpeta
// Importar el OrderPaymentService para marcar como pagado
import { OrderPaymentService } from './public/order-payment.service';

// DTOs y tipos
import {
    MarkOrderItemServedPayloadDto,
    OrderItemStatusUpdateResponseDto,
} from './camarero.dto';
import { FrontendMarkOrderAsPaidPayloadDto, FrontendRequestBillStaffPayloadDto } from './public/order.types';

// Instanciar OrderPaymentService
const orderPaymentServiceInstance = new OrderPaymentService();

/**
 * Handler para GET /api/camarero/staff/ready-for-pickup
 */
export const getReadyForPickupItemsHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    if (!businessId) {
        console.error("[WaiterCtrl] Critical: businessId missing from req.user in getReadyForPickupItemsHandler.");
        return res.status(403).json({ message: "Identificador de negocio no encontrado en la sesi√≥n del usuario." });
    }
    console.log(`[WaiterCtrl] Request for ready-for-pickup items for business: ${businessId}`);
    try {
        const items = await waiterService.getReadyForPickupItems(businessId);
        res.status(200).json(items);
    } catch (error) {
        console.error(`[WaiterCtrl] Error getting ready-for-pickup items for business ${businessId}:`, error);
        next(error);
    }
};

/**
 * Handler para PATCH /api/camarero/staff/order-items/:orderItemId/status
 * Marca un OrderItem como SERVED.
 */
export const markOrderItemServedHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const waiterUserId = req.user?.id;
    const { orderItemId } = req.params;
    const payload: MarkOrderItemServedPayloadDto = req.body;

    if (!businessId || !waiterUserId) {
        console.error("[WaiterCtrl] Critical: businessId or waiterUserId missing for markOrderItemServedHandler.");
        return res.status(403).json({ message: "Informaci√≥n de autenticaci√≥n de personal incompleta." });
    }
    if (!orderItemId) {
        return res.status(400).json({ message: "Falta el ID del √≠tem de pedido (orderItemId) en la URL." });
    }
    if (!payload || payload.newStatus !== OrderItemStatus.SERVED) {
        return res.status(400).json({ message: "Payload inv√°lido. Se esperaba que 'newStatus' sea 'SERVED'." });
    }

    console.log(`[WaiterCtrl] Request to mark OrderItem ${orderItemId} as SERVED by waiter ${waiterUserId} for business ${businessId}.`);

    try {
        // Asumimos que waiterService.markOrderItemAsServed ahora devuelve { updatedOrderItem, finalOrderStatus }
        const result = await waiterService.markOrderItemAsServed(
            orderItemId,
            businessId,
            waiterUserId
        );

        const responseDto: OrderItemStatusUpdateResponseDto = {
            message: `√çtem '${result.updatedOrderItem.itemNameSnapshot || orderItemId}' marcado como ${OrderItemStatus.SERVED}.`,
            orderItemId: result.updatedOrderItem.id,
            newStatus: result.updatedOrderItem.status,
            orderStatus: result.finalOrderStatus, // Usar el estado del pedido devuelto por el servicio
        };
        res.status(200).json(responseDto);

    } catch (error: any) {
        console.error(`[WaiterCtrl] Error marking OrderItem ${orderItemId} as SERVED:`, error);
        if (error.message) {
            if (error.message.includes('no encontrado') || (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025')) {
                return res.status(404).json({ message: error.message });
            }
            if (error.message.includes('no est√° en estado \'READY\'') || error.message.includes('Transici√≥n de estado no permitida')) {
                return res.status(409).json({ message: `Conflicto de estado: ${error.message}` });
            }
        }
        next(error);
    }
};

/**
 * Handler para POST /api/camarero/staff/order/:orderId/request-bill
 */
export const requestBillByStaffHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const staffUserId = req.user?.id;
    const { orderId } = req.params;
    const payload: FrontendRequestBillStaffPayloadDto = req.body;

    if (!businessId || !staffUserId) {
        console.error("[WaiterCtrl] Critical: businessId or staffUserId missing for requestBillByStaffHandler.");
        return res.status(403).json({ message: "Informaci√≥n de autenticaci√≥n de personal incompleta." });
    }
    if (!orderId) {
        return res.status(400).json({ message: "Falta el ID del pedido (orderId) en la URL." });
    }

    console.log(`[WaiterCtrl] Staff ${staffUserId} requesting bill for order ${orderId}. Preference: ${payload.paymentPreference || 'N/A'}`);
    try {
        const paymentPreferenceForService = payload.paymentPreference ?? undefined;

        // Podr√≠amos decidir que waiterService.requestBillByStaff llame internamente a OrderPaymentService
        // o hacer la llamada a OrderPaymentService aqu√≠ directamente.
        // Por consistencia con markOrderAsPaid, si el servicio de pago centraliza, lo llamar√≠amos aqu√≠.
        // Por ahora, seguimos con la estructura donde WaiterService lo maneja.
        const updatedOrder: Order = await waiterService.requestBillByStaff(
            orderId,
            staffUserId,
            businessId,
            paymentPreferenceForService
        );
        res.status(200).json({
            message: `Cuenta solicitada para el pedido #${updatedOrder.orderNumber}. Estado: ${updatedOrder.status}.`,
            order: {
                id: updatedOrder.id,
                orderNumber: updatedOrder.orderNumber,
                status: updatedOrder.status,
                isBillRequested: updatedOrder.isBillRequested,
                paymentMethodPreference: updatedOrder.paymentMethodPreference,
            }
        });
    } catch (error: any) {
        console.error(`[WaiterCtrl] Error requesting bill for order ${orderId} by staff ${staffUserId}:`, error);
        if (error.message) {
            if (error.message.includes('no encontrado') || (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025')) {
                return res.status(404).json({ message: error.message });
            }
            if (error.message.includes('No se puede solicitar la cuenta') || error.message.includes('estado inv√°lido')) {
                return res.status(400).json({ message: error.message });
            }
            if (error.message.includes('no pertenece al negocio')) {
                return res.status(403).json({ message: error.message });
            }
        }
        next(error);
    }
};

/**
 * Handler para POST /api/camarero/staff/order/:orderId/mark-as-paid
 */
export const markOrderAsPaidHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const staffUserId = req.user?.id;
    const { orderId } = req.params;
    const payloadFromFrontend: FrontendMarkOrderAsPaidPayloadDto = req.body;

    if (!businessId || !staffUserId) {
        console.error("[WaiterCtrl] Critical: businessId or staffUserId missing for markOrderAsPaidHandler.");
        return res.status(403).json({ message: "Informaci√≥n de autenticaci√≥n de personal incompleta." });
    }
    if (!orderId) {
        return res.status(400).json({ message: "Falta el ID del pedido (orderId) en la URL." });
    }

    const paymentDetailsForService: { method?: string; notes?: string } = {
        method: payloadFromFrontend.method,
        notes: payloadFromFrontend.notes ?? undefined,
    };

    console.log(`[WaiterCtrl] Staff ${staffUserId} marking order ${orderId} as PAID. Payment Details: ${JSON.stringify(paymentDetailsForService)}`);

    try {
        const updatedOrder: Order = await orderPaymentServiceInstance.markOrderAsPaid(
            orderId,
            staffUserId,
            businessId,
            paymentDetailsForService
        );

        // Respuesta simplificada. El frontend puede hacer un refetch de la lista de pedidos
        // o del estado de la mesa si necesita la info actualizada inmediatamente.
        res.status(200).json({
            message: `Pedido #${updatedOrder.orderNumber || orderId} marcado como PAGADO.`,
            order: { // Devolver la informaci√≥n esencial del pedido actualizado
                id: updatedOrder.id,
                orderNumber: updatedOrder.orderNumber,
                status: updatedOrder.status,
                paidAt: updatedOrder.paidAt,
                paymentMethodUsed: updatedOrder.paymentMethodUsed,
                tableId: updatedOrder.tableId, // Enviar tableId para que el frontend sepa si debe refetchear mesas
            }
        });

    } catch (error: any) {
        console.error(`[WaiterCtrl] Error marking order ${orderId} as PAID by staff ${staffUserId}:`, error);
        // El tipo de error de NestJS (error.name) podr√≠a no estar disponible si no se est√° ejecutando en un contexto NestJS puro
        // Usaremos instanceof para los errores de Prisma y mensajes para el resto
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             return res.status(404).json({ message: 'Pedido no encontrado.' });
        }
        if (error.message?.includes('no encontrado')) {
             return res.status(404).json({ message: error.message });
        }
        if (error.message?.includes('Solo se pueden marcar como pagados') || error.message?.includes('estado inv√°lido')) {
            return res.status(400).json({ message: error.message });
        }
        if (error.message?.includes('no pertenece al negocio')) {
            return res.status(403).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para GET /api/camarero/staff/orders
 */
export const getStaffOrdersHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    if (!businessId) {
        console.error("[WaiterCtrl] Critical: businessId missing from req.user in getStaffOrdersHandler.");
        return res.status(403).json({ message: "Identificador de negocio no encontrado en la sesi√≥n del usuario." });
    }
    const statusQuery = req.query.status as string | string[] | undefined;
    let statusFilter: OrderStatus[] | undefined = undefined;
    if (statusQuery) {
        const statuses = Array.isArray(statusQuery) ? statusQuery : (typeof statusQuery === 'string' ? statusQuery.split(',') : []);
        statusFilter = statuses
            .map(s => s.trim().toUpperCase() as OrderStatus)
            .filter(s => Object.values(OrderStatus).includes(s));
        if (statusFilter.length === 0) {
            statusFilter = undefined;
        }
    }
    console.log(`[WaiterCtrl] Request for staff orders for business: ${businessId}. Filters: ${JSON.stringify({ status: statusFilter })}`);
    try {
        const orders = await waiterService.getOrdersForStaff(businessId, { status: statusFilter });
        res.status(200).json(orders);
    } catch (error: any) {
        console.error(`[WaiterCtrl] Error fetching staff orders for business ${businessId}:`, error);
        next(error);
    }
};


// ====== [24] backend/src/modules/camarero/waiter.service.ts ======
// backend/src/camarero/waiter.service.ts
// Version 1.3.1 (Corrected orderBy clause in getOrdersForStaff)

import {
    PrismaClient,
    OrderItem,
    OrderItemStatus,
    OrderStatus,
    Prisma,
    TableStatus,
    Order,
    OrderType,
    User, // Asegurarse de importar User si se usa en tipos
} from '@prisma/client';
import {
    ReadyPickupItemDto,
    WaiterSelectedModifierDto,
    WaiterOrderListItemDto
} from './camarero.dto';
import {
    NotFoundException,
    BadRequestException,
    ForbiddenException,
    Logger,
    InternalServerErrorException,
} from '@nestjs/common';

const prisma = new PrismaClient(); // Instancia de Prisma para este servicio
const logger = new Logger('WaiterService'); // Logger para este servicio

/**
 * Obtiene la lista de √≠tems de pedido que est√°n listos para ser recogidos por el personal de sala.
 * @param businessId - ID del negocio.
 * @returns Un array de ReadyPickupItemDto.
 */
export const getReadyForPickupItems = async (businessId: string): Promise<ReadyPickupItemDto[]> => {
    logger.log(`[WaiterService] Fetching items ready for pickup for business: ${businessId}`);
    try {
        const orderItemsFromDb = await prisma.orderItem.findMany({
            where: {
                status: OrderItemStatus.READY,
                order: {
                    businessId: businessId,
                    status: {
                        in: [
                            OrderStatus.IN_PROGRESS,
                            OrderStatus.PARTIALLY_READY,
                            OrderStatus.ALL_ITEMS_READY,
                        ],
                    },
                },
            },
            include: {
                order: {
                    include: {
                        table: { select: { identifier: true } },
                    },
                },
                selectedModifiers: {
                    select: {
                        optionNameSnapshot: true,
                        modifierOption: {
                            select: { name_en: true, name_es: true }
                        }
                    },
                },
            },
            orderBy: [
                { order: { createdAt: 'asc' } },
                { createdAt: 'asc' }
            ]
        });

        const readyItemsDto: ReadyPickupItemDto[] = orderItemsFromDb.map(item => {
            const selectedModifiersDto: WaiterSelectedModifierDto[] = item.selectedModifiers.map(sm => {
                return {
                    optionName_es: sm.optionNameSnapshot || sm.modifierOption?.name_es || null,
                    optionName_en: sm.modifierOption?.name_en || null,
                };
            });

            return {
                orderItemId: item.id,
                orderId: item.orderId,
                orderNumber: item.order.orderNumber,
                orderCreatedAt: item.order.createdAt,
                tableIdentifier: item.order.table?.identifier || null,
                itemNameSnapshot_es: item.itemNameSnapshot,
                itemNameSnapshot_en: null, // Ajustar si tienes snapshot_en
                quantity: item.quantity,
                itemNotes: item.notes,
                kdsDestination: item.kdsDestination,
                selectedModifiers: selectedModifiersDto,
                currentOrderItemStatus: item.status,
            };
        });

        logger.log(`[WaiterService] Found ${readyItemsDto.length} items ready for pickup for business ${businessId}.`);
        return readyItemsDto;

    } catch (error) {
        logger.error(`[WaiterService] Error fetching 'ready for pickup' items for business ${businessId}:`, error);
        throw new InternalServerErrorException('Error al obtener los √≠tems listos para servir desde la base de datos.');
    }
};

export interface MarkServedResult {
    updatedOrderItem: OrderItem;
    finalOrderStatus: OrderStatus;
}

export const markOrderItemAsServed = async (
    orderItemId: string,
    businessId: string,
    waiterUserId?: string
): Promise<MarkServedResult> => {
    logger.log(`[WaiterService] Attempting to mark OrderItem ${orderItemId} as SERVED by waiter ${waiterUserId || 'unknown'} for business ${businessId}.`);

    return prisma.$transaction(async (tx) => {
        const orderItem = await tx.orderItem.findFirst({
            where: {
                id: orderItemId,
                order: { businessId: businessId }
            },
            include: {
                order: {
                    select: { id: true, status: true }
                }
            }
        });

        if (!orderItem) {
            logger.warn(`[WaiterService TX] OrderItem '${orderItemId}' not found or not in business '${businessId}'.`);
            throw new NotFoundException(`√çtem de pedido con ID ${orderItemId} no encontrado o no pertenece a este negocio.`);
        }
        if (!orderItem.order) {
            logger.error(`[WaiterService TX] Critical: OrderItem '${orderItemId}' has no associated order.`);
            throw new InternalServerErrorException(`Error interno: El √≠tem de pedido ${orderItemId} no est√° asociado a ning√∫n pedido.`);
        }

        if (orderItem.status !== OrderItemStatus.READY) {
            logger.warn(`[WaiterService TX] OrderItem '${orderItemId}' is in status '${orderItem.status}', not 'READY'. Cannot mark as served.`);
            throw new BadRequestException(`El √≠tem de pedido '${orderItem.itemNameSnapshot || orderItemId}' no est√° en estado 'READY'. Estado actual: ${orderItem.status}. No se puede marcar como servido.`);
        }

        const dataToUpdateOrderItem: Prisma.OrderItemUpdateArgs['data'] = {
            status: OrderItemStatus.SERVED,
            servedAt: new Date(),
        };
        if (waiterUserId) {
            dataToUpdateOrderItem.servedById = waiterUserId;
        }

        const updatedOrderItem = await tx.orderItem.update({
            where: { id: orderItemId },
            data: dataToUpdateOrderItem,
        });
        logger.log(`[WaiterService TX] OrderItem ${orderItemId} marked as SERVED in DB.`);

        const orderId = orderItem.order.id;
        const allItemsInThisOrder = await tx.orderItem.findMany({
            where: { orderId: orderId },
            select: { status: true }
        });

        const activeItems = allItemsInThisOrder.filter(item => item.status !== OrderItemStatus.CANCELLED);
        let newOrderStatusForParent: OrderStatus = orderItem.order.status;

        if (activeItems.length > 0 && activeItems.every(item => item.status === OrderItemStatus.SERVED)) {
            if (
                orderItem.order.status !== OrderStatus.PAID &&
                orderItem.order.status !== OrderStatus.CANCELLED &&
                orderItem.order.status !== OrderStatus.COMPLETED
            ) {
                newOrderStatusForParent = OrderStatus.COMPLETED;
                await tx.order.update({
                    where: { id: orderId },
                    data: { status: newOrderStatusForParent }
                });
                logger.log(`[WaiterService TX] Order ${orderId} status updated to COMPLETED as all active items are SERVED.`);
            } else {
                 logger.log(`[WaiterService TX] Order ${orderId} already in final/completed state (${orderItem.order.status}). Not changing to COMPLETED.`);
            }
        } else if (activeItems.length === 0 && allItemsInThisOrder.length > 0) {
             if (orderItem.order.status !== OrderStatus.CANCELLED && orderItem.order.status !== OrderStatus.PAID) {
                newOrderStatusForParent = OrderStatus.CANCELLED;
                await tx.order.update({
                    where: { id: orderId },
                    data: { status: newOrderStatusForParent }
                });
                logger.log(`[WaiterService TX] Order ${orderId} status updated to CANCELLED as all items were cancelled.`);
            }
        } else {
            logger.log(`[WaiterService TX] Order ${orderId} still has items not SERVED or no active items. Order status remains ${newOrderStatusForParent}.`);
        }
        return { updatedOrderItem, finalOrderStatus: newOrderStatusForParent };
    });
};

export const requestBillByStaff = async (
    orderId: string,
    staffUserId: string,
    businessId: string,
    paymentPreference?: string | undefined
): Promise<Order> => {
    logger.log(`[WaiterService] Staff ${staffUserId} requesting bill for order ${orderId} in business ${businessId}. Preference: ${paymentPreference || 'N/A'}`);

    return prisma.$transaction(async (tx) => {
        const order = await tx.order.findUnique({
            where: { id: orderId },
            select: { id: true, status: true, businessId: true, tableId: true, orderNumber: true }
        });

        if (!order) {
            throw new NotFoundException(`Pedido con ID ${orderId} no encontrado.`);
        }
        if (order.businessId !== businessId) {
            throw new ForbiddenException("El pedido no pertenece al negocio del personal.");
        }

        const allowedStates: OrderStatus[] = [
            OrderStatus.RECEIVED, OrderStatus.IN_PROGRESS, OrderStatus.PARTIALLY_READY,
            OrderStatus.ALL_ITEMS_READY, OrderStatus.COMPLETED,
        ];
        if (!allowedStates.includes(order.status)) {
            throw new BadRequestException(`No se puede solicitar la cuenta para un pedido en estado '${order.status}'.`);
        }

        const updateData: Prisma.OrderUpdateInput = {
            status: OrderStatus.PENDING_PAYMENT,
            isBillRequested: true,
            ...(paymentPreference !== undefined && { paymentMethodPreference: paymentPreference }),
        };

        const updatedOrder = await tx.order.update({ where: { id: orderId }, data: updateData });
        logger.log(`[WaiterService TX] Bill requested by staff ${staffUserId} for order ${orderId}. Status set to PENDING_PAYMENT.`);

        if (order.tableId) {
            try {
                await tx.table.update({
                    where: { id: order.tableId },
                    data: { status: TableStatus.PENDING_PAYMENT_TABLE }
                });
                logger.log(`[WaiterService TX] Table ID '${order.tableId}' status updated to PENDING_PAYMENT_TABLE.`);
            } catch (tableError) {
                logger.error(`[WaiterService TX] Failed to update table status for table '${order.tableId}' on staff bill request. Continuing. Error:`, tableError);
            }
        }
        return updatedOrder;
    });
};

export const getOrdersForStaff = async (
    businessId: string,
    filters?: { status?: OrderStatus[] }
): Promise<WaiterOrderListItemDto[]> => {
    logger.log(`[WaiterService] Fetching orders for staff UI. Business: ${businessId}, Filters: ${JSON.stringify(filters)}`);

    const whereClause: Prisma.OrderWhereInput = {
        businessId: businessId,
    };

    if (filters?.status && filters.status.length > 0) {
        whereClause.status = { in: filters.status };
    } else {
        whereClause.status = {
            in: [
                OrderStatus.PENDING_PAYMENT, OrderStatus.COMPLETED,
                OrderStatus.ALL_ITEMS_READY, OrderStatus.PARTIALLY_READY,
                OrderStatus.IN_PROGRESS, OrderStatus.RECEIVED
            ]
        };
    }

    try {
        const ordersFromDb = await prisma.order.findMany({
            where: whereClause,
            select: {
                id: true,
                orderNumber: true,
                table: { select: { identifier: true } },
                status: true,
                finalAmount: true,
                totalAmount: true,
                items: {
                    where: { status: { not: OrderItemStatus.CANCELLED } },
                    select: { quantity: true }
                },
                customerLCo: { select: { name: true, email: true } },
                createdAt: true,
                isBillRequested: true,
                orderType: true,
            },
            // --- CORRECCI√ìN APLICADA ---
            orderBy: [
                { status: 'asc' },    // Primer criterio de ordenaci√≥n
                { createdAt: 'asc' }  // Segundo criterio de ordenaci√≥n
            ]
            // --- FIN CORRECCI√ìN ---
        });

        const orderListItems: WaiterOrderListItemDto[] = ordersFromDb.map(order => {
            const itemCount = order.items.reduce((sum, item) => sum + item.quantity, 0);
            let customerDisplayName: string | null = null;
            if (order.customerLCo) {
                customerDisplayName = order.customerLCo.name || order.customerLCo.email;
            }

            return {
                orderId: order.id,
                orderNumber: order.orderNumber,
                tableIdentifier: order.table?.identifier || null,
                status: order.status,
                finalAmount: (order.finalAmount ?? order.totalAmount).toNumber(),
                itemCount: itemCount,
                customerName: customerDisplayName,
                createdAt: order.createdAt,
                isBillRequested: order.isBillRequested,
                orderType: order.orderType as OrderType | null, // Casteo al enum local si es necesario
            };
        });

        logger.log(`[WaiterService] Found ${orderListItems.length} orders for staff UI for business ${businessId}.`);
        return orderListItems;

    } catch (error) {
        logger.error(`[WaiterService] Error fetching orders for staff UI (Business: ${businessId}):`, error);
        if (error instanceof Prisma.PrismaClientValidationError) {
            logger.error("[WaiterService] Prisma Client Validation Error details:", error.message);
            throw new InternalServerErrorException(`Error de validaci√≥n de Prisma al obtener pedidos: ${error.message}`);
        }
        throw new InternalServerErrorException('Error al obtener la lista de pedidos para el personal.');
    }
};

// (No se necesita exportar `prisma` si el controlador no lo usa directamente)


// ====== [25] backend/src/shared/auth/__tests__/auth.service.test.ts ======
import { describe, it, expect } from 'vitest';
import { hashPassword, comparePassword } from '../auth.service'; // Ajusta ruta si auth.service no est√° en el nivel superior

describe('Auth Service Helpers', () => {
  it('should hash a password correctly', async () => {
    const plainPassword = 'password123';
    const hashedPassword = await hashPassword(plainPassword);

    expect(hashedPassword).toBeTypeOf('string');
    expect(hashedPassword).not.toBe(plainPassword);
    expect(hashedPassword.length).toBeGreaterThan(50);
  });

  it('should compare a correct password successfully', async () => {
    const plainPassword = 'password123';
    const hashedPassword = await hashPassword(plainPassword);
    const isMatch = await comparePassword(plainPassword, hashedPassword);

    expect(isMatch).toBe(true);
  });

  it('should fail comparing an incorrect password', async () => {
    const plainPassword = 'password123';
    const wrongPassword = 'password456';
    const hashedPassword = await hashPassword(plainPassword);
    const isMatch = await comparePassword(wrongPassword, hashedPassword);

    expect(isMatch).toBe(false);
  });
});


// ====== [26] backend/src/shared/auth/auth.controller.ts ======
// filename: backend/src/auth/auth.controller.ts
// Version: 2.1.0 (Refactored: Only contains login handler, cleaned)

import { Request, Response } from 'express';
import { User } from '@prisma/client'; // Needed for type casting if generateToken expects User

// Importar solo utilidades necesarias para login desde auth.service
import { comparePassword, generateToken, findUserByEmail } from './auth.service';

/**
 * Handles user login. POST /api/auth/login
 */
export const login = async (req: Request, res: Response) => {
    const { email, password } = req.body;
    // console.log(`[AUTH CTRL] Attempting login for email: ${email}`); // Log reducido

    if (!email || !password) {
        // console.log('[AUTH CTRL] Login failed: Email or password missing.'); // Log reducido
        return res.status(400).json({ message: 'Se requieren email y contrase√±a.' }); // Corregido: contrase√±a
    }

    try {
        // console.log(`[AUTH CTRL] Finding user by email: ${email}`); // Log reducido
        const user = await findUserByEmail(email);
        if (!user || !user.isActive) {
            // console.log(`[AUTH CTRL] User not found or inactive for email: ${email}. Sending 401.`); // Log reducido
            // Devolvemos 401 Unauthorized para ambos casos (no encontrado o inactivo) por seguridad
            return res.status(401).json({ message: 'Credenciales inv√°lidas o usuario inactivo.' }); // Corregido: inv√°lidas
        }

        // console.log(`[AUTH CTRL] User found: ${user.id}. Comparing password...`); // Log reducido
        const passwordMatch = await comparePassword(password, user.password);
        if (!passwordMatch) {
            // console.log(`[AUTH CTRL] Password mismatch for user ${user.id}. Sending 401.`); // Log reducido
            return res.status(401).json({ message: 'Credenciales inv√°lidas.' }); // Corregido: inv√°lidas
        }

        // console.log(`[AUTH CTRL] Password matches for user ${user.id}. Generating token...`); // Log reducido
        const token = generateToken(user); // generateToken necesita id, role, businessId

        // Excluimos campos sensibles de la respuesta. Ahora quitamos las variables no usadas directamente.
        const {
            password: _password, // Renombrar para evitar conflicto y marcar como no usado
            documentId: _documentId,
            resetPasswordToken: _resetPasswordToken,
            resetPasswordExpires: _resetPasswordExpires,
            ...userWithoutSensitiveData // El resto de campos del usuario
        } = user;

        console.log(`[AUTH CTRL] Login successful for user ${user.id}. Sending 200.`);
        res.status(200).json({ user: userWithoutSensitiveData, token });

    } catch (error) {
        console.error('[AUTH CTRL] Error during login:', error); // Mantener log de error
        res.status(500).json({ message: 'Error del servidor durante el inicio de sesi√≥n.' }); // Corregido: sesi√≥n
    }
};

// Las funciones register, registerBusinessHandler, forgotPasswordHandler, resetPasswordHandler han sido movidas.

// End of File: backend/src/auth/auth.controller.ts


// ====== [27] backend/src/shared/auth/auth.dto.ts ======
// filename: backend/src/auth/auth.dto.ts
// --- INICIO DEL C√ìDIGO COMPLETO ---
// File: backend/src/auth/auth.dto.ts
// Version: 1.2.0 (Add RegisterBusinessDto)

import { UserRole, DocumentType } from '@prisma/client';

// DTO para Registro de Cliente (existente)
export interface RegisterUserDto {
  email: string;
  password: string;
  name?: string;
  phone: string; // Tel√©fono del cliente
  documentId: string; // Documento del cliente
  documentType: DocumentType; // Tipo doc cliente
  businessId: string; // ID del negocio al que se une
  role: UserRole; // Debe ser CUSTOMER_FINAL
}

// DTO para solicitar reseteo (existente)
export interface ForgotPasswordDto {
    email: string;
}

// DTO para realizar el reseteo (existente)
export interface ResetPasswordDto {
    password: string; // La nueva contrase√±a
    // El token vendr√° por la URL (req.params)
}

// --- NUEVO: DTO para registrar un Negocio y su Admin ---
export interface RegisterBusinessDto {
    businessName: string;   // Nombre del nuevo negocio
    adminEmail: string;     // Email para el usuario administrador inicial
    adminPassword: string;  // Contrase√±a para ese administrador
    adminName?: string;      // Nombre opcional para el administrador
    // No necesitamos m√°s datos por ahora para el MVP (slug se generar√°, etc.)
    // No pasamos role porque siempre ser√° BUSINESS_ADMIN
    // No pasamos businessId porque se va a crear uno nuevo
}
// --- FIN NUEVO ---


// End of File: backend/src/auth/auth.dto.ts
// --- FIN DEL C√ìDIGO COMPLETO ---


// ====== [28] backend/src/shared/auth/auth.service.ts ======
// filename: backend/src/auth/auth.service.ts
// Version: 2.1.0 (Add conditional logging for test environment)

import { PrismaClient, User } from '@prisma/client';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

const prisma = new PrismaClient();
const JWT_SECRET = process.env.JWT_SECRET as string;

// Validaci√≥n de JWT_SECRET
if (!JWT_SECRET) {
    console.error('FATAL ERROR: JWT_SECRET is not defined in auth.service.');
    // process.exit(1); // Considerar salir
}

// --- Funciones de Utilidad B√°sicas ---

/**
 * Hashea una contrase√±a usando bcrypt.
 */
export const hashPassword = async (password: string): Promise<string> => {
    const salt = await bcrypt.genSalt(10);
    return bcrypt.hash(password, salt);
};

/**
 * Compara una contrase√±a en texto plano con una hasheada.
 */
export const comparePassword = async (plainPassword: string, hashedPassword: string): Promise<boolean> => {
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - comparePassword] Comparing provided password with hash ${hashedPassword ? hashedPassword.substring(0,10) : 'N/A'}...`);
    }
    // --- FIN LOG DE DEBUG ---
    const isMatch = await bcrypt.compare(plainPassword, hashedPassword);
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - comparePassword] Result: ${isMatch}`);
    }
    // --- FIN LOG DE DEBUG ---
    return isMatch;
};

/**
 * Genera un token JWT para un usuario.
 */
export const generateToken = (user: Pick<User, 'id' | 'role' | 'businessId'>): string => {
    const payload = {
        userId: user.id,
        role: user.role,
        businessId: user.businessId
    };
    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: '7d' }); // 7 d√≠as de expiraci√≥n
    return token;
};

/**
 * Encuentra un usuario por su direcci√≥n de email.
 */
export const findUserByEmail = async (email: string): Promise<User | null> => {
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - findUserByEmail] Searching for email: ${email}`);
    }
    // --- FIN LOG DE DEBUG ---
    const user = await prisma.user.findUnique({ where: { email } });
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - findUserByEmail] User found: ${user ? `{ id: ${user.id}, email: ${user.email}, isActive: ${user.isActive} }` : 'null'}`);
    }
    // --- FIN LOG DE DEBUG ---
    return user;
};

// --- Funciones movidas a otros servicios ---
// createUser -> registration.service.ts
// handleForgotPassword, handleResetPassword -> password-reset.service.ts
// createBusinessAndAdmin, generateSlug -> registration.service.ts

// End of File: backend/src/auth/auth.service.ts


// ====== [29] backend/src/shared/auth/password-reset.controller.ts ======
// filename: backend/src/auth/password-reset.controller.ts
// Version: 1.0.3 (Remove Swagger annotations)

import { Request, Response } from 'express';
// DTOs necesarios para reseteo
import { ForgotPasswordDto, ResetPasswordDto } from './auth.dto';

// Servicios necesarios
import { hashPassword } from './auth.service';
import { handleForgotPassword, handleResetPassword } from './password-reset.service';

// SIN ANOTACI√ìN @openapi
export const forgotPasswordHandler = async (req: Request, res: Response) => {
    const { email }: ForgotPasswordDto = req.body;

    if (!email) {
        return res.status(400).json({ message: 'Se requiere el email.' });
    }
    try {
        await handleForgotPassword(email);
        res.status(200).json({ message: 'Si existe una cuenta con ese email, se ha enviado un enlace para restablecer la contrase√±a.' });
    } catch (error: any) {
        console.error('[PWD_RESET CTRL] Error in forgotPasswordHandler:', error.message);
        res.status(200).json({ message: 'Si existe una cuenta con ese email, se ha enviado un enlace para restablecer la contrase√±a.' });
    }
};

// SIN ANOTACI√ìN @openapi
export const resetPasswordHandler = async (req: Request, res: Response) => {
    const { token } = req.params;
    const { password: newPassword }: ResetPasswordDto = req.body;

    if (!token) {
        return res.status(400).json({ message: 'Falta el token de reseteo.' });
    }
    if (!newPassword) {
        return res.status(400).json({ message: 'Se requiere la nueva contrase√±a.' });
    }
    if (newPassword.length < 6) {
        return res.status(400).json({ message: 'La nueva contrase√±a debe tener al menos 6 caracteres.' });
    }

    try {
        const hashedNewPassword = await hashPassword(newPassword);
        await handleResetPassword(token, hashedNewPassword);

        res.status(200).json({ message: 'Contrase√±a restablecida con √©xito.' });
    } catch (error: any) {
        console.error(`[PWD_RESET CTRL] Error in resetPasswordHandler for token ${token ? token.substring(0,5)+'...' : 'undefined'}:`, error.message);
        res.status(400).json({ message: error.message || 'No se pudo restablecer la contrase√±a.' });
    }
};

// End of File: backend/src/auth/password-reset.controller.ts


// ====== [30] backend/src/shared/auth/password-reset.service.ts ======
// filename: backend/src/auth/password-reset.service.ts
// Version: 1.0.1 (Fix encoding, remove insecure log, cleanup comments)

import { PrismaClient, User } from '@prisma/client';
// bcrypt ya no se usa directamente aqu√≠ si usamos comparePassword desde auth.service
import crypto from 'crypto';

// Importar utilidades necesarias desde el servicio principal de auth
// ASUNCI√ìN: Estas funciones permanecer√°n o ser√°n exportadas desde auth.service.ts
import { hashPassword, comparePassword, findUserByEmail } from './auth.service';

const prisma = new PrismaClient();

// Constante de expiraci√≥n (espec√≠fica de este flujo)
const RESET_TOKEN_EXPIRATION_MS = 60 * 60 * 1000; // 1 hour

// --- Funciones para Reseteo de Contrase√±a ---

export const handleForgotPassword = async (email: string): Promise<void> => {
    console.log(`[PWD_RESET SVC] Handling forgot password for: ${email}`);
    const user = await findUserByEmail(email); // Usa la utilidad importada
    if (!user) {
        console.log(`[PWD_RESET SVC] User not found for forgot password: ${email}. Responding generically.`);
        return; // Salir silenciosamente
    }

    const resetToken = crypto.randomBytes(32).toString('hex');
    // console.log(`[PWD_RESET SVC] Generated PLAIN reset token for ${email}: ${resetToken}`); // <-- LOG INSEGURO ELIMINADO
    const hashedResetToken = await hashPassword(resetToken);
    const expires = new Date(Date.now() + RESET_TOKEN_EXPIRATION_MS);

    try {
        await prisma.user.update({
            where: { email: email },
            data: {
                resetPasswordToken: hashedResetToken,
                resetPasswordExpires: expires,
            },
        });
        console.log(`[PWD_RESET SVC] Hashed reset token stored successfully for user ${user.id}`);
        // Aqu√≠ ir√≠a la l√≥gica real de env√≠o de email con el 'resetToken' (el original, NO el hasheado)
        // Ejemplo: await sendPasswordResetEmail(user.email, resetToken);
        // Por ahora, el token plano solo se logueaba (y ya hemos quitado eso)
    } catch (error) {
        console.error(`[PWD_RESET SVC] Failed to store reset token for user ${user.id}:`, error);
        // Considerar si relanzar o manejar el error de forma diferente
    }
};

export const handleResetPassword = async (token: string, hashedNewPassword: string): Promise<void> => {
    console.log(`[PWD_RESET SVC] Handling reset password with token starting: ${token.substring(0, 5)}...`);

    const potentialUsers = await prisma.user.findMany({
        where: {
            resetPasswordToken: { not: null },
            resetPasswordExpires: { gt: new Date() } // Buscar solo tokens no expirados
        }
    });

    if (!potentialUsers || potentialUsers.length === 0) {
        console.log('[PWD_RESET SVC] No users found with potentially valid (non-null, non-expired) reset tokens.');
        throw new Error('Token inv√°lido o expirado.'); // Error gen√©rico
    }
    console.log(`[PWD_RESET SVC] Found ${potentialUsers.length} users with active tokens. Verifying provided token...`);

    // Comparar token plano proporcionado con los hashes guardados
    let userToUpdate: User | null = null;
    for (const user of potentialUsers) {
        if (user.resetPasswordToken) {
            const isTokenMatch = await comparePassword(token, user.resetPasswordToken);
            if (isTokenMatch) {
                console.log(`[PWD_RESET SVC] Token match found for user ID: ${user.id}`);
                userToUpdate = user;
                break; // Encontramos el usuario, salimos del bucle
            }
        }
    }

    if (!userToUpdate) {
        // Si recorrimos todos los usuarios con token activo y ninguno coincidi√≥
        console.log(`[PWD_RESET SVC] No user matched the provided token among active ones.`);
        throw new Error('Token inv√°lido o expirado.'); // Mismo error gen√©rico
    }

    // Actualizar contrase√±a y limpiar campos de reseteo
    try {
        await prisma.user.update({
            where: { id: userToUpdate.id },
            data: {
                password: hashedNewPassword,
                resetPasswordToken: null, // Limpiar token
                resetPasswordExpires: null, // Limpiar expiraci√≥n
            },
        });
        console.log(`[PWD_RESET SVC] Password reset successful for user ${userToUpdate.id}`);
    } catch (error) {
        console.error(`[PWD_RESET SVC] Failed to update password for user ${userToUpdate.id}:`, error);
        throw new Error('Error al actualizar la contrase√±a.'); // Error m√°s espec√≠fico para el frontend
    }
};

// End of File: backend/src/auth/password-reset.service.ts


// ====== [31] backend/src/shared/auth/registration.controller.ts ======
// filename: backend/src/auth/registration.controller.ts
// Version: 1.0.2 (Remove Swagger annotations)

import { Request, Response } from 'express';
import { Prisma, DocumentType, User } from '@prisma/client';

// DTOs necesarios para registro
import { RegisterUserDto, RegisterBusinessDto } from './auth.dto';
// Utils de Validaci√≥n
import { isValidDni, isValidNie, isValidPhoneNumber } from '../utils/validation';

// Servicios necesarios
import { findUserByEmail, generateToken } from './auth.service';
import { createUser, createBusinessAndAdmin } from './registration.service';

// SIN ANOTACI√ìN @openapi
export const register = async (req: Request, res: Response) => {
    const { email, password, name, phone, documentId, documentType, businessId, role }: RegisterUserDto = req.body;

    if (!email || !password || !phone || !documentId || !documentType || !businessId || !role || role !== 'CUSTOMER_FINAL') {
        return res.status(400).json({ message: 'Faltan campos obligatorios o rol inv√°lido para registro de cliente.' });
    }

    try {
        const existingUser = await findUserByEmail(email);
        if (existingUser) {
            return res.status(409).json({ message: 'El email ya est√° registrado.' });
        }

        if (!isValidPhoneNumber(phone)) {
             return res.status(400).json({ message: 'Formato de tel√©fono inv√°lido.' });
        }
        let isDocumentValid = false;
        const upperDocumentId = documentId.toUpperCase();
        switch (documentType) {
            case DocumentType.DNI: isDocumentValid = isValidDni(upperDocumentId); break;
            case DocumentType.NIE: isDocumentValid = isValidNie(upperDocumentId); break;
            case DocumentType.PASSPORT: isDocumentValid = upperDocumentId.trim().length > 3; break;
            case DocumentType.OTHER: isDocumentValid = upperDocumentId.trim().length > 0; break;
            default: return res.status(400).json({ message: 'Tipo de documento inv√°lido.' });
        }
        if (!isDocumentValid) { return res.status(400).json({ message: `Formato de ${documentType} inv√°lido.` }); }

        const userDataForService: RegisterUserDto = {
             email, password, name, phone,
             documentId: upperDocumentId, // Enviar normalizado
             documentType, businessId, role
        };
        const newUser = await createUser(userDataForService);

        const {
            password: _password,
            documentId: _documentId,
            resetPasswordToken: _resetToken,
            resetPasswordExpires: _resetExpires,
            ...userWithoutSensitiveData
        } = newUser;
        console.log(`[REG CTRL] Customer registration successful for user ${newUser.id}. Sending 201.`);
        res.status(201).json({ user: userWithoutSensitiveData });
    } catch (error) {
        if (error instanceof Error && (error.message.includes('tel√©fono') || error.message.includes('documento') || error.message.includes('Business with ID') || error.message.includes('ya est√° registrado'))) {
             return res.status(409).json({ message: error.message });
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            const target = (error.meta?.target as string[])?.join(', ');
            console.error(`[REG CTRL] Registration failed: Unique constraint DB error on ${target}.`);
            return res.status(409).json({ message: `Error de unicidad en ${target}` });
        }
        console.error('[REG CTRL] Error during customer registration:', error);
        res.status(500).json({ message: 'Error del servidor durante el registro.' });
    }
};


// SIN ANOTACI√ìN @openapi
export const registerBusinessHandler = async (req: Request, res: Response) => {
    const { businessName, adminEmail, adminPassword, adminName }: RegisterBusinessDto = req.body;
    console.log(`[REG CTRL] Attempting business registration for: ${businessName} / ${adminEmail}`);

    if (!businessName || !adminEmail || !adminPassword) {
        return res.status(400).json({ message: 'Nombre del negocio, email del administrador y contrase√±a son requeridos.' });
    }
    if (businessName.trim().length < 2) {
        return res.status(400).json({ message: 'El nombre del negocio debe tener al menos 2 caracteres.' });
    }
    if (adminPassword.length < 6) {
        return res.status(400).json({ message: 'La contrase√±a debe tener al menos 6 caracteres.' });
    }

    try {
        const newAdminUser = await createBusinessAndAdmin({
            businessName: businessName.trim(),
            adminEmail,
            adminPassword,
            adminName: adminName?.trim()
        });
        const token = generateToken(newAdminUser as User);

        console.log(`[REG CTRL] Business registration successful for ${newAdminUser.email}. Sending 201.`);
        res.status(201).json({
            user: newAdminUser,
            token: token
        });
    } catch (error: any) {
        console.error('[REG CTRL] Error during business registration:', error);
        if (error instanceof Error) {
             if (error.message.includes('El email proporcionado ya est√° registrado') ||
                 error.message.includes('Ya existe un negocio con un nombre similar')) {
                 return res.status(409).json({ message: error.message });
             }
              if (error.message.includes('nombre del negocio') || error.message.includes('Error de base de datos')) {
                   return res.status(400).json({ message: error.message });
              }
        }
        res.status(500).json({ message: error.message || 'Error del servidor durante el registro del negocio.' });
    }
};

// End of File: backend/src/auth/registration.controller.ts


// ====== [32] backend/src/shared/auth/registration.service.ts ======
// backend/src/shared/auth/registration.service.ts (CORREGIDO)
import { PrismaClient, User, UserRole, DocumentType, Prisma, Business } from '@prisma/client';
import { RegisterUserDto, RegisterBusinessDto } from './auth.dto';
import { hashPassword, findUserByEmail } from './auth.service';

// --- RUTA CORREGIDA ---
import { updateUserTier } from '../../modules/loyalpyme/tiers/tier-logic.service';
// --- FIN RUTA CORREGIDA ---

const prisma = new PrismaClient();

export const createUser = async (userData: RegisterUserDto): Promise<User> => {
    console.log(`[REG SVC] Creating CUSTOMER user: ${userData.email}`);
    const businessExists = await prisma.business.findUnique({ where: { id: userData.businessId } });
    if (!businessExists) {
        throw new Error(`Business with ID ${userData.businessId} not found.`);
    }
    if (userData.phone) {
        const existingPhone = await prisma.user.findUnique({ where: { phone: userData.phone }, select: { id: true } });
        if (existingPhone) throw new Error('El tel√©fono ya est√° registrado.');
    } else {
        throw new Error('El tel√©fono es un campo obligatorio para clientes.');
    }
    if (userData.documentId) {
        const existingDocument = await prisma.user.findUnique({ where: { documentId: userData.documentId }, select: { id: true } });
        if (existingDocument) throw new Error('El documento de identidad ya est√° registrado.');
    } else {
        throw new Error('El documento de identidad es un campo obligatorio para clientes.');
    }
    console.log(`[REG SVC] Uniqueness checks passed for ${userData.email}. Hashing password...`);

    const hashedPassword = await hashPassword(userData.password);
    let newUser: User | null = null;

    try {
        newUser = await prisma.user.create({
            data: {
                email: userData.email,
                password: hashedPassword,
                name: userData.name,
                phone: userData.phone,
                documentId: userData.documentId,
                documentType: userData.documentType,
                role: UserRole.CUSTOMER_FINAL,
                business: {
                    connect: { id: userData.businessId }
                }
            },
        });
        console.log(`[REG SVC] Customer user created successfully with ID: ${newUser.id}`);

        try {
             console.log(`[REG SVC] Attempting initial tier assignment for new user: ${newUser.id}`);
             await updateUserTier(newUser.id);
             console.log(`[REG SVC] Initial tier assignment process completed for user: ${newUser.id}`);
        } catch (tierError: any) {
            console.error(`[REG SVC] WARNING: Failed to assign initial tier for user ${newUser.id}. Tier can be updated later. Error:`, tierError);
        }

        return newUser;

    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            const target = (error.meta?.target as string[])?.join(', ');
            console.error(`[REG SVC] Customer creation failed: Unique constraint DB error on ${target}.`);
            if (target?.includes('email')) throw new Error('El email ya est√° registrado.');
            if (target?.includes('phone')) throw new Error('El tel√©fono ya est√° registrado.');
            if (target?.includes('documentId')) throw new Error('El documento de identidad ya est√° registrado.');
            throw new Error(`Conflicto de unicidad en ${target}.`);
        }
        console.error(`[REG SVC] Unexpected error creating customer ${userData.email}:`, error);
        throw new Error('Error inesperado al crear el usuario cliente.');
    }
};

const generateSlug = (name: string): string => {
    return name
        .toLowerCase()
        .trim()
        .replace(/[^\w\s-]/g, '')
        .replace(/[\s_-]+/g, '-')
        .replace(/^-+|-+$/g, '');
};

export const createBusinessAndAdmin = async (
    data: RegisterBusinessDto
): Promise<Omit<User, 'password'>> => {
    console.log('[REG SVC] Attempting to create business and admin:', data.businessName, data.adminEmail);

    const existingUser = await findUserByEmail(data.adminEmail);
    if (existingUser) {
        console.warn(`[REG SVC] Admin email ${data.adminEmail} already exists.`);
        throw new Error('El email proporcionado ya est√° registrado.');
    }

    const slug = generateSlug(data.businessName);
    if (!slug) {
        console.error(`[REG SVC] Could not generate slug from business name: ${data.businessName}`);
        throw new Error('El nombre del negocio proporcionado no es v√°lido para generar un identificador.');
    }
    const existingBusiness = await prisma.business.findUnique({
        where: { slug: slug },
        select: { id: true }
    });
    if (existingBusiness) {
        console.warn(`[REG SVC] Business slug ${slug} already exists.`);
        throw new Error(`Ya existe un negocio con un nombre similar ('${slug}'). Por favor, elige otro nombre.`);
    }

    const hashedPassword = await hashPassword(data.adminPassword);

    try {
        console.log(`[REG SVC] Starting transaction to create business '${data.businessName}' (slug: ${slug}) and admin '${data.adminEmail}'`);
        const newUser = await prisma.$transaction(async (tx) => {
            const newBusiness = await tx.business.create({
                data: {
                    name: data.businessName,
                    slug: slug,
                },
                select: { id: true }
            });
            console.log(`[REG SVC - TX] Business created with ID: ${newBusiness.id}`);

            const adminUser = await tx.user.create({
                data: {
                    email: data.adminEmail,
                    password: hashedPassword,
                    name: data.adminName,
                    role: UserRole.BUSINESS_ADMIN,
                    businessId: newBusiness.id,
                }
            });
            console.log(`[REG SVC - TX] Admin user created with ID: ${adminUser.id} for business ${newBusiness.id}`);
            return adminUser;
        });

        const { password, ...userWithoutPassword } = newUser;
        console.log(`[REG SVC] Business and admin creation successful for ${data.adminEmail}.`);
        return userWithoutPassword;

    } catch (error) {
        console.error('[REG SVC] Error during business/admin creation transaction:', error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             const target = (error.meta?.target as string[])?.join(', ');
             console.error(`[REG SVC] Unique constraint failed on: ${target}`);
             throw new Error(`Error de base de datos: Conflicto de unicidad en ${target}.`);
        }
        throw new Error('No se pudo completar el registro del negocio. Error interno del servidor.');
    }
};


// ====== [33] backend/src/shared/businesses/businesses.controller.ts ======
// filename: backend/src/businesses/businesses.controller.ts
// Version: 1.0.0

import { Request, Response, NextFunction } from 'express';
// Importamos la funci√≥n del servicio que acabamos de crear
import { findPublicBusinesses, PublicBusinessInfo } from './businesses.service'; // Usamos ruta relativa './'

/**
 * Handler para obtener la lista p√∫blica de negocios (ID y Nombre).
 * GET /api/businesses/public-list (o la ruta que definamos)
 * No requiere autenticaci√≥n.
 */
export const handleGetPublicBusinesses = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  console.log('[BusinessController] Solicitud de lista p√∫blica de negocios...');

  try {
    // Llamamos a la funci√≥n del servicio para obtener los datos
    const businesses: PublicBusinessInfo[] = await findPublicBusinesses();

    // Enviamos la respuesta exitosa con la lista de negocios
    res.status(200).json(businesses);
    console.log('[BusinessController] Lista p√∫blica de negocios enviada.');

  } catch (error) {
    // Si el servicio lanza un error, lo pasamos al manejador de errores global
    console.error('[BusinessController] Error al obtener lista p√∫blica de negocios:', error);
    next(error);
  }
};

// Aqu√≠ podr√≠an ir otros handlers del controlador relacionados con Business en el futuro
// (ej: getBusinessDetails, updateBusinessSettings - que s√≠ requerir√≠an autenticaci√≥n/rol)

// End of file: backend/src/businesses/businesses.controller.ts


// ====== [34] backend/src/shared/businesses/businesses.service.ts ======
// filename: backend/src/businesses/businesses.service.ts
// Version: 1.0.2 (Remove obsolete comments)

import { PrismaClient, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Define la estructura de datos devuelta para la lista p√∫blica de negocios.
 */
export interface PublicBusinessInfo {
  id: string;
  name: string;
}

/**
 * Busca y devuelve una lista de negocios (solo ID y Nombre) para mostrar p√∫blicamente.
 * Por ahora, devuelve todos los negocios ordenados por nombre.
 * En el futuro, se podr√≠a filtrar por negocios activos o verificados si fuera necesario.
 *
 * @returns Una promesa que resuelve con un array de objetos PublicBusinessInfo.
 * @throws Error si ocurre un problema al consultar la base de datos.
 */
export const findPublicBusinesses = async (): Promise<PublicBusinessInfo[]> => {
  console.log('[BusinessService] Buscando lista p√∫blica de negocios...');
  try {
    const businesses = await prisma.business.findMany({
      select: {
        id: true,
        name: true,
      },
      orderBy: {
        name: 'asc',
      },
    });
    console.log(`[BusinessService] Encontrados ${businesses.length} negocios.`);
    return businesses;
  } catch (error) {
    console.error('[BusinessService] Error al buscar negocios p√∫blicos:', error);
    throw new Error('No se pudo obtener la lista de negocios.');
  }
};

// End of file: backend/src/businesses/businesses.service.ts


// ====== [35] backend/src/shared/middleware/auth.middleware.ts ======
// backend/src/middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { PrismaClient, UserRole, Prisma, User } from '@prisma/client'; // User ya estaba importado

const prisma = new PrismaClient();
const JWT_SECRET = process.env.JWT_SECRET as string;

if (!JWT_SECRET) {
    console.error('FATAL ERROR: JWT_SECRET is not defined in auth.middleware.');
    // Considerar process.exit(1) en un escenario real si esto es cr√≠tico
}

// Definici√≥n de req.user (Aseg√∫rate de que este tipo global ya incluya los nuevos campos o aj√∫stalo)
// Esta declaraci√≥n ya estaba en tu archivo original, la adaptamos.
declare global {
    namespace Express {
        interface Request {
            user?: {
                id: string;
                email: string;
                role: UserRole;
                businessId: string | null;
                isActive: boolean;
                name?: string | null;
                points?: number;
                totalSpend?: number;
                totalVisits?: number;
                currentTier?: { id: string; name: string; benefits: any[]; } | null; // 'any[]' para benefits es gen√©rico, considera tiparlo mejor si es posible
                
                // Flags del negocio
                businessIsActive?: boolean;
                isLoyaltyCoreActive?: boolean;
                isCamareroActive?: boolean;

                // --- NUEVOS CAMPOS PARA EL NEGOCIO ---
                businessName?: string | null;
                businessSlug?: string | null;
                businessLogoUrl?: string | null;
                // --- FIN NUEVOS CAMPOS ---
            };
        }
    }
}

export const authenticateToken = async (req: Request, res: Response, next: NextFunction) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (token == null) {
        console.log('[AUTH MIDDLEWARE] No token provided. Sending 401.');
        return res.sendStatus(401);
    }

    jwt.verify(token, JWT_SECRET, async (err: any, payload: any) => {
        if (err || !payload || !payload.userId || !payload.role) {
            console.error('[AUTH MIDDLEWARE] JWT verification failed or invalid payload:', { err, payload_userId: payload?.userId, payload_role: payload?.role });
            return res.sendStatus(403); // Token inv√°lido o corrupto
        }
        // console.log('[AUTH MIDDLEWARE DEBUG] JWT Payload OK:', payload);

        try {
            // Define el tipo de selecci√≥n para Prisma, incluyendo campos del negocio
            const userProfileSelect: Prisma.UserSelect = {
                id: true,
                email: true,
                role: true,
                businessId: true, // Necesario para la l√≥gica de negocio y para obtener los detalles del negocio
                isActive: true,
                name: true,
            };

            // Si el usuario tiene un businessId (es decir, no es SUPER_ADMIN que no tiene businessId directo)
            if (payload.businessId) {
                // console.log('[AUTH MIDDLEWARE DEBUG] Payload has businessId, selecting business data...');
                userProfileSelect.business = { // Seleccionar la relaci√≥n 'business'
                    select: {
                        isActive: true,
                        isLoyaltyCoreActive: true,
                        isCamareroActive: true,
                        name: true,         // <--- A√ëADIDO
                        slug: true,         // <--- A√ëADIDO
                        logoUrl: true,      // <--- A√ëADIDO (Opcional, pero √∫til para el header)
                    }
                };
            }

            // Si el rol es CUSTOMER_FINAL y tiene businessId (para asegurar que no se intente para SUPER_ADMIN)
            if (payload.role === UserRole.CUSTOMER_FINAL && payload.businessId) {
                // console.log('[AUTH MIDDLEWARE DEBUG] Role is CUSTOMER_FINAL, selecting LCo specific fields...');
                userProfileSelect.points = true;
                userProfileSelect.totalSpend = true;
                userProfileSelect.totalVisits = true;
                userProfileSelect.currentTier = {
                    select: {
                        id: true,
                        name: true,
                        benefits: { // Considerar si realmente se necesitan todos los beneficios aqu√≠
                            where: { isActive: true },
                            select: { id: true, type: true, value: true, description: true }
                        }
                    }
                };
            } else if (payload.role !== UserRole.SUPER_ADMIN && !payload.businessId) {
                 // Esto es un caso an√≥malo: un rol que no es SUPER_ADMIN deber√≠a tener un businessId.
                 console.error(`[AUTH MIDDLEWARE] User role ${payload.role} requires a businessId, but none found for user ${payload.userId}. Denying access.`);
                 return res.sendStatus(403); // Prohibido
            }
            // console.log('[AUTH MIDDLEWARE DEBUG] Prisma User Select Query:', JSON.stringify(userProfileSelect, null, 2));

            const userFromDb = await prisma.user.findUnique({
                where: { id: payload.userId },
                select: userProfileSelect
            });
            // console.log('[AUTH MIDDLEWARE DEBUG] User fetched from DB:', JSON.stringify(userFromDb, null, 2));

            if (!userFromDb || !userFromDb.isActive) {
                console.log(`[AUTH MIDDLEWARE] User ${payload.userId} not found or not active in DB. Sending 403.`);
                return res.sendStatus(403); // Usuario no encontrado o inactivo
            }

            // Extraer datos del negocio si existen en el usuario cargado
            // @ts-ignore Prisma genera el tipo `business` en `userFromDb` si se incluy√≥ en el select
            const businessDataFromDb = userFromDb.business;
            // console.log('[AUTH MIDDLEWARE DEBUG] Business data from DB relation:', JSON.stringify(businessDataFromDb, null, 2));


            // Si el usuario no es SUPER_ADMIN y su negocio asociado NO est√° activo, denegar acceso
            if (userFromDb.role !== UserRole.SUPER_ADMIN && businessDataFromDb && !businessDataFromDb.isActive) {
                console.log(`[AUTH MIDDLEWARE] Business ${userFromDb.businessId} for user ${userFromDb.id} is not active. Denying access.`);
                return res.sendStatus(403); // Negocio inactivo
            }
            
            // Construir el objeto req.user
            const reqUserObject: Express.Request['user'] = {
                id: userFromDb.id,
                email: userFromDb.email,
                role: userFromDb.role,
                businessId: userFromDb.businessId,
                isActive: userFromDb.isActive,
                name: userFromDb.name,
            };

            // A√±adir campos espec√≠ficos de LCo si es CUSTOMER_FINAL
            if (userFromDb.role === UserRole.CUSTOMER_FINAL) {
                // @ts-ignore
                reqUserObject.points = userFromDb.points;
                // @ts-ignore
                reqUserObject.totalSpend = userFromDb.totalSpend;
                // @ts-ignore
                reqUserObject.totalVisits = userFromDb.totalVisits;
                // @ts-ignore
                reqUserObject.currentTier = userFromDb.currentTier ?? null;
            }

            // A√±adir flags y detalles del negocio si existen
            if (businessDataFromDb) {
                reqUserObject.businessIsActive = businessDataFromDb.isActive;
                reqUserObject.isLoyaltyCoreActive = businessDataFromDb.isLoyaltyCoreActive;
                reqUserObject.isCamareroActive = businessDataFromDb.isCamareroActive;
                reqUserObject.businessName = businessDataFromDb.name;           // <--- A√ëADIDO
                reqUserObject.businessSlug = businessDataFromDb.slug;           // <--- A√ëADIDO
                reqUserObject.businessLogoUrl = businessDataFromDb.logoUrl;     // <--- A√ëADIDO
            } else if (userFromDb.role !== UserRole.SUPER_ADMIN && payload.businessId) {
                // Caso borde: El token ten√≠a businessId, pero no se pudo cargar la info del negocio.
                // Esto podr√≠a indicar un problema de datos (ej. negocio borrado pero usuario a√∫n lo referencia).
                // Por seguridad, podr√≠amos denegar o loguear y continuar con flags undefined/null.
                console.warn(`[AUTH MIDDLEWARE] Business data for businessId ${payload.businessId} was expected but not found for user ${userFromDb.id}. Module flags and business details will be undefined.`);
            }
            
            req.user = reqUserObject; // Asignar el objeto construido a req.user
            
            // console.log('[AUTH MIDDLEWARE DEBUG] Final req.user object being set:', JSON.stringify(req.user, null, 2));
            console.log(`[AUTH MIDDLEWARE] User ${req.user.id} (Role: ${req.user.role}, BizId: ${req.user.businessId || 'N/A'}, BizSlug: ${req.user.businessSlug || 'N/A'}) authenticated.`);

            next();
        } catch (dbError) {
            console.error('[AUTH MIDDLEWARE] Database error during user/business fetch:', dbError);
            delete req.user; // Limpiar req.user en caso de error
            res.status(500).json({ message: 'Server error during authentication process.' });
        }
    });
};


// ====== [36] backend/src/shared/middleware/module.middleware.ts ======
// backend/src/middleware/module.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Definimos los c√≥digos de m√≥dulo que usaremos.
// Podr√≠as expandir esto o usar un Enum de Prisma si los m√≥dulos se vuelven m√°s complejos.
export type ModuleCode = 'LOYALTY_CORE' | 'CAMARERO';

/**
 * Middleware factory para verificar si un m√≥dulo espec√≠fico est√° activo para el negocio
 * del usuario autenticado.
 *
 * @param moduleCode El c√≥digo del m√≥dulo a verificar.
 * @returns Una funci√≥n middleware de Express.
 */
export const checkModuleActive = (moduleCode: ModuleCode) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    // Asumimos que authenticateToken ya se ejecut√≥ y req.user y req.user.businessId existen.
    // El rol ya deber√≠a haber sido verificado por checkRole si es necesario para la ruta.
    if (!req.user || !req.user.businessId) {
      console.warn('[ModuleMiddleware] User or businessId missing from request. Is authenticateToken running first?');
      return res.status(403).json({ message: 'Acceso denegado. No se pudo identificar el negocio para la verificaci√≥n del m√≥dulo.' });
    }

    const businessId = req.user.businessId;

    try {
      const business = await prisma.business.findUnique({
        where: { id: businessId },
        select: {
          isLoyaltyCoreActive: true,
          isCamareroActive: true,
          // Podr√≠amos seleccionar tambi√©n business.isActive aqu√≠ si quisi√©ramos
          // que un m√≥dulo no funcione si el negocio entero est√° inactivo,
          // pero eso se puede manejar en checkRole o un middleware de estado de negocio.
        }
      });

      if (!business) {
        // Esto ser√≠a raro si el token es v√°lido y tiene un businessId.
        console.warn(`[ModuleMiddleware] Business with ID ${businessId} not found during module check.`);
        return res.status(404).json({ message: 'Negocio asociado no encontrado.' });
      }

      let moduleIsCurrentlyActive = false;
      if (moduleCode === 'LOYALTY_CORE') {
        moduleIsCurrentlyActive = business.isLoyaltyCoreActive;
      } else if (moduleCode === 'CAMARERO') {
        moduleIsCurrentlyActive = business.isCamareroActive;
      } else {
        // C√≥digo de m√≥dulo desconocido, por seguridad denegar.
        console.error(`[ModuleMiddleware] Unknown moduleCode specified: ${moduleCode}`);
        return res.status(500).json({ message: 'Error interno: C√≥digo de m√≥dulo no reconocido.' });
      }

      if (moduleIsCurrentlyActive) {
        next(); // El m√≥dulo est√° activo, continuar.
      } else {
        console.log(`[ModuleMiddleware] Access denied. Module '${moduleCode}' is not active for business ${businessId}.`);
        return res.status(403).json({ message: `Acceso denegado. El m√≥dulo ${moduleCode} no est√° activo para este negocio.` });
      }
    } catch (error) {
      console.error(`[ModuleMiddleware] Error checking module '${moduleCode}' for business ${businessId}:`, error);
      return res.status(500).json({ message: 'Error interno al verificar el estado del m√≥dulo.' });
    }
  };
};


// ====== [37] backend/src/shared/middleware/multer.config.ts ======
// filename: backend/src/middleware/multer.config.ts
// Version: 1.0.0 (Initial Multer configuration for image uploads)

import multer, { FileFilterCallback } from 'multer';
import { Request } from 'express';

// Tipos de archivo permitidos (MIME types)
const ALLOWED_MIMETYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
// L√≠mite de tama√±o (ej. 5MB)
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5 MB in bytes

// Configuraci√≥n de almacenamiento en memoria
const storage = multer.memoryStorage();

// Funci√≥n de filtro de archivos
const fileFilter = (
    req: Request,
    file: Express.Multer.File,
    cb: FileFilterCallback
) => {
    console.log(`[Multer Filter] Checking file: ${file.originalname}, MIME type: ${file.mimetype}`);
    if (ALLOWED_MIMETYPES.includes(file.mimetype)) {
        // Aceptar el archivo
        console.log(`[Multer Filter] File type ${file.mimetype} accepted.`);
        cb(null, true);
    } else {
        // Rechazar el archivo
        console.warn(`[Multer Filter] File type ${file.mimetype} rejected.`);
        // Pasamos un error para que pueda ser manejado por el controlador/manejador de errores
        cb(new Error('Tipo de archivo no permitido. Solo se aceptan im√°genes (jpeg, png, webp, gif).'));
        // Alternativa: cb(null, false); // Simplemente rechaza sin error expl√≠cito
    }
};

// Crear la instancia de Multer configurada
const upload = multer({
    storage: storage,
    fileFilter: fileFilter,
    limits: {
        fileSize: MAX_FILE_SIZE, // L√≠mite de 5MB
    },
});

// Exportar la instancia configurada (espec√≠ficamente para manejar un solo archivo llamado 'image')
// Usaremos upload.single('imageField') en la ruta. El nombre 'imageField' debe coincidir
// con el nombre del campo que env√≠a el frontend en el FormData.
// Exportamos la instancia base para usarla en la ruta.
export default upload;

// End of File: backend/src/middleware/multer.config.ts


// ====== [38] backend/src/shared/middleware/role.middleware.ts ======
// filename: backend/src/middleware/role.middleware.ts
// Version: 1.0.1 (Remove verbose log and inline comments)

import { Request, Response, NextFunction } from 'express';
import { UserRole } from '@prisma/client';

/**
 * Middleware factory para verificar si el rol del usuario autenticado
 * est√° incluido en la lista de roles permitidos.
 *
 * @param allowedRoles Un array de UserRole permitidos para la ruta.
 * @returns Una funci√≥n middleware de Express.
 */
export const checkRole = (allowedRoles: UserRole[]) => {
    return (req: Request, res: Response, next: NextFunction) => {
        // Verifica que authenticateToken haya adjuntado un usuario con rol
        if (!req.user || !req.user.role) {
            console.warn('[Role Middleware] User or user role not found on request. Is authenticateToken running first?');
            return res.status(403).json({ message: 'Acceso denegado: Autenticaci√≥n requerida o rol no disponible.' });
        }

        const userRole = req.user.role;
        // console.log(`[Role Middleware] Checking role: User has '${userRole}', Allowed: [${allowedRoles.join(', ')}] for route ${req.originalUrl}`); // Log eliminado por verbosidad

        // Comprueba si el rol est√° permitido
        if (allowedRoles.includes(userRole)) {
            next(); // Rol permitido, continuar
        } else {
            // Rol no permitido
            console.warn(`[Role Middleware] Access Forbidden for role '${userRole}' on route ${req.originalUrl}. Allowed: [${allowedRoles.join(', ')}]`);
            res.status(403).json({ message: 'Acceso denegado: Permisos insuficientes.' });
        }
    };
};

// End of File: backend/src/middleware/role.middleware.ts


// ====== [39] backend/src/shared/services/loyalty-points.service.ts ======
// backend/src/shared/services/loyalty-points.service.ts (CORREGIDO)
import {
    PrismaClient,
    Prisma,
    Order,
    User,
    Business,
    ActivityType,
    TierBenefit,
} from '@prisma/client';
import { Logger, InternalServerErrorException } from '@nestjs/common';
// --- RUTA CORREGIDA ---
import { updateUserTier } from '../../modules/loyalpyme/tiers/tier-logic.service';
// --- FIN RUTA CORREGIDA ---

type OrderForLoyalty = Pick<Order, 'id' | 'orderNumber' | 'finalAmount' | 'totalAmount' | 'customerLCoId' | 'businessId'>;
type CustomerForLoyalty = User & {
    currentTier?: ({ benefits: Pick<TierBenefit, 'type' | 'value' | 'isActive'>[] } & { id: string; name: string }) | null;
};
type BusinessForLoyalty = Pick<Business, 'id' | 'pointsPerEuro' | 'isLoyaltyCoreActive'>;


export class LoyaltyPointsService {
    private readonly logger = new Logger(LoyaltyPointsService.name);

    async awardPointsForLcOrder(
        tx: Prisma.TransactionClient,
        order: OrderForLoyalty,
        customer: CustomerForLoyalty,
        business: BusinessForLoyalty
    ): Promise<{ pointsAwarded: number } | null> {
        if (!order.customerLCoId) {
            this.logger.warn(`[LoyaltyPointsService] Order ${order.id} has no customerLCoId. No points to award.`);
            return null;
        }
        if (!business.isLoyaltyCoreActive) {
            this.logger.log(`[LoyaltyPointsService] LoyaltyCore module is not active for business ${business.id}. Skipping points for order ${order.id}.`);
            return null;
        }
        if (customer.id !== order.customerLCoId) {
             this.logger.error(`[LoyaltyPointsService] Mismatch: Order customerLCoId ${order.customerLCoId} vs provided customer ID ${customer.id}. Aborting points.`);
             throw new InternalServerErrorException("Discrepancia en IDs de cliente al otorgar puntos.");
        }

        this.logger.log(`[LoyaltyPointsService TX] Processing LCo points for customer ${customer.id} (Order: ${order.id}, Business: ${business.id})`);

        const orderAmountForPoints = order.finalAmount ?? order.totalAmount;
        let pointsToEarnDecimal = new Prisma.Decimal(orderAmountForPoints).mul(business.pointsPerEuro ?? 1);

        const multiplierBenefit = customer.currentTier?.benefits.find(
            b => b.type === 'POINTS_MULTIPLIER' && b.isActive
        );

        if (multiplierBenefit?.value) {
            const multiplier = parseFloat(multiplierBenefit.value);
            if (!isNaN(multiplier) && multiplier > 0) {
                pointsToEarnDecimal = pointsToEarnDecimal.mul(multiplier);
                this.logger.log(`[LoyaltyPointsService TX] Applied tier '${customer.currentTier?.name}' multiplier ${multiplier} for LCo points.`);
            } else {
                this.logger.warn(`[LoyaltyPointsService TX] Invalid LCo tier multiplier value '${multiplierBenefit.value}' for user ${customer.id} on tier '${customer.currentTier?.name}'.`);
            }
        }

        const finalPointsToAward = Math.floor(pointsToEarnDecimal.toNumber());

        if (finalPointsToAward <= 0) {
            this.logger.log(`[LoyaltyPointsService TX] No LCo points to award (calculated ${finalPointsToAward}) for customer ${customer.id} on order ${order.id}.`);
            return { pointsAwarded: 0 };
        }

        try {
            await tx.user.update({
                where: { id: customer.id },
                data: {
                    points: { increment: finalPointsToAward },
                    totalSpend: { increment: orderAmountForPoints.toNumber() },
                    totalVisits: { increment: 1 },
                    lastActivityAt: new Date(),
                },
            });
            this.logger.log(`[LoyaltyPointsService TX] Customer ${customer.id} updated: +${finalPointsToAward} points, +${orderAmountForPoints} spend, +1 visit.`);

            await tx.activityLog.create({
                data: {
                    userId: customer.id,
                    businessId: business.id,
                    type: ActivityType.POINTS_EARNED_ORDER_LC,
                    pointsChanged: finalPointsToAward,
                    description: `Puntos por pedido LC #${order.orderNumber}`,
                    relatedOrderId: order.id,
                },
            });
            this.logger.log(`[LoyaltyPointsService TX] ActivityLog created for order ${order.id}, user ${customer.id}.`);

            updateUserTier(customer.id).catch((tierError: any) => {
                this.logger.error(`[LoyaltyPointsService] Background tier update failed for customer ${customer.id} after LC order points:`, tierError);
            });
            this.logger.log(`[LoyaltyPointsService] Tier update process initiated for customer ${customer.id}.`);

            return { pointsAwarded: finalPointsToAward };

        } catch (error) {
            this.logger.error(`[LoyaltyPointsService TX] Error during points awarding transaction for order ${order.id}, customer ${customer.id}:`, error);
            return null;
        }
    }
}


// ====== [40] backend/src/shared/services/table.service.ts ======
// backend/src/services/table.service.ts (o backend/src/camarero/table.service.ts si prefieres)
import {
    PrismaClient,
    Prisma,
    Table,
    TableStatus,
} from '@prisma/client';
import {
    Logger,
    NotFoundException,
    InternalServerErrorException,
} from '@nestjs/common';

export class TableService {
    private readonly logger = new Logger(TableService.name);

    /**
     * Encuentra una mesa por su identificador y el ID del negocio.
     *
     * @param tx - Cliente Prisma de la transacci√≥n actual.
     * @param businessId - ID del negocio.
     * @param tableIdentifier - Identificador de la mesa (ej. "M1", "T2").
     * @returns El objeto Table si se encuentra, o null si no.
     */
    async findTableByIdentifier(
        tx: Prisma.TransactionClient,
        businessId: string,
        tableIdentifier: string
    ): Promise<Table | null> {
        this.logger.log(`[TableService] Finding table with identifier '${tableIdentifier}' for business '${businessId}'.`);
        try {
            const table = await tx.table.findUnique({
                where: {
                    businessId_identifier: {
                        businessId: businessId,
                        identifier: tableIdentifier,
                    },
                },
            });
            if (table) {
                this.logger.log(`[TableService] Table '${tableIdentifier}' found with ID '${table.id}'.`);
            } else {
                this.logger.warn(`[TableService] Table '${tableIdentifier}' not found for business '${businessId}'.`);
            }
            return table;
        } catch (error) {
            this.logger.error(`[TableService] Error finding table '${tableIdentifier}':`, error);
            throw new InternalServerErrorException('Error al buscar la mesa en la base de datos.');
        }
    }

    /**
     * Actualiza el estado de una mesa espec√≠fica.
     *
     * @param tx - Cliente Prisma de la transacci√≥n actual.
     * @param tableId - ID de la mesa a actualizar.
     * @param newStatus - El nuevo TableStatus para la mesa.
     * @returns El objeto Table actualizado.
     * @throws NotFoundException si la mesa no existe.
     */
    async updateTableStatus(
        tx: Prisma.TransactionClient,
        tableId: string,
        newStatus: TableStatus
    ): Promise<Table> {
        this.logger.log(`[TableService] Updating status of table '${tableId}' to '${newStatus}'.`);
        try {
            // Primero, verificar si la mesa existe para dar un error m√°s claro si no.
            // Esto podr√≠a ser redundante si la operaci√≥n que llama ya verific√≥, pero es una salvaguarda.
            const existingTable = await tx.table.findUnique({ where: { id: tableId }, select: { id: true } });
            if (!existingTable) {
                this.logger.warn(`[TableService] Table with ID '${tableId}' not found for status update.`);
                throw new NotFoundException(`Mesa con ID '${tableId}' no encontrada.`);
            }

            const updatedTable = await tx.table.update({
                where: { id: tableId },
                data: { status: newStatus },
            });
            this.logger.log(`[TableService] Table '${tableId}' status successfully updated to '${newStatus}'.`);
            return updatedTable;
        } catch (error) {
            if (error instanceof NotFoundException) throw error; // Relanzar si es nuestro error espec√≠fico
            
            this.logger.error(`[TableService] Error updating status for table '${tableId}':`, error);
            if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
                // P2025 = "An operation failed because it depends on one or more records that were required but not found."
                // (Registro para actualizar no encontrado)
                throw new NotFoundException(`Mesa con ID '${tableId}' no encontrada al intentar actualizar estado.`);
            }
            throw new InternalServerErrorException('Error al actualizar el estado de la mesa.');
        }
    }

    // --- Podr√≠as a√±adir m√°s m√©todos aqu√≠ si son necesarios, como: ---
    // async getTableById(tx: Prisma.TransactionClient, tableId: string): Promise<Table | null> { ... }
    // async createTable(tx: Prisma.TransactionClient, businessId: string, data: Prisma.TableCreateWithoutBusinessInput): Promise<Table> { ... }
    // etc.
}


// ====== [41] backend/src/shared/uploads/uploads.controller.ts ======
// filename: backend/src/uploads/uploads.controller.ts
// Version: 1.0.1 (Correct service import path)

import { Request, Response, NextFunction } from 'express';
// --- MODIFICADO: Importar desde 'uploads.service' (plural) ---
import { uploadImageToCloudinary } from './uploads.service';
// --- FIN MODIFICADO ---

/**
 * Maneja la subida de una imagen (generalmente para recompensas).
 * Espera que el middleware Multer (upload.single('image')) se haya ejecutado antes.
 */
export const handleImageUpload = async (req: Request, res: Response, next: NextFunction) => {
    console.log('[Upload CTRL] Received image upload request.');

    // Multer a√±ade 'file' a la request
    if (!req.file) {
        console.error('[Upload CTRL] No file found in req.file. Check field name in client and Multer config.');
        // El campo en Multer y en RewardForm debe ser 'image' seg√∫n c√≥digo anterior
        return res.status(400).json({ message: 'No se recibi√≥ ning√∫n archivo de imagen o el campo no es "image".' });
    }

    if (!req.file.buffer) {
        console.error('[Upload CTRL] File buffer is missing.');
        return res.status(500).json({ message: 'Error interno al procesar el archivo.' });
    }

    // Carpeta en Cloudinary
    const folderName = `loyalpyme/rewards_${process.env.NODE_ENV || 'development'}`;

    try {
        console.log(`[Upload CTRL] Uploading file ${req.file.originalname} (${(req.file.size / 1024).toFixed(1)} KB) to Cloudinary folder '${folderName}'...`);
        const imageUrl = await uploadImageToCloudinary(req.file.buffer, folderName);

        console.log(`[Upload CTRL] Image uploaded successfully. URL: ${imageUrl}`);
        // Devolver la URL (ajustado a como lo espera el form v2.1.0)
        res.status(200).json({
            // message: 'Imagen subida correctamente.', // El form no espera message
            url: imageUrl // El form espera 'url'
        });

    } catch (error) {
        console.error('[Upload CTRL] Error during image upload process:', error);
        next(error); // Pasar al manejador global
    }
};

// End of File: backend/src/uploads/uploads.controller.ts


// ====== [42] backend/src/shared/uploads/uploads.service.ts ======
// filename: backend/src/uploads/upload.service.ts
// Version: 1.0.0 (CORRECTED - Standard Cloudinary upload service with folder)

import cloudinary from '../utils/cloudinary.config'; // Importa config est√°ndar (lee .env)
import streamifier from 'streamifier';
import { UploadApiResponse, UploadApiErrorResponse } from 'cloudinary';

// --- ASEG√öRATE DE QUE LA FIRMA DE LA FUNCI√ìN EST√â AS√ç ---
export const uploadImageToCloudinary = (
    fileBuffer: Buffer,      // <-- Par√°metro para el buffer
    folderName: string       // <-- Par√°metro para la carpeta
): Promise<string> => {
// --- FIN FIRMA ---

    return new Promise((resolve, reject) => {
        // Usamos folderName en el log
        console.log(`[Upload SVC] Attempting to upload image buffer to Cloudinary folder: ${folderName}`);

        const uploadStream = cloudinary.uploader.upload_stream(
            {
                folder: folderName, // <-- Usamos el par√°metro folderName
                resource_type: 'image',
            },
            (error: UploadApiErrorResponse | undefined, result: UploadApiResponse | undefined) => {
                if (error) {
                    console.error('[Upload SVC] Cloudinary upload failed:', error);
                    // Usar un mensaje gen√©rico o el espec√≠fico de Cloudinary
                    reject(new Error(`Error al subir imagen a Cloudinary: ${error.message}`));
                } else if (result) {
                    console.log(`[Upload SVC] Cloudinary upload successful! Secure URL: ${result.secure_url}`);
                    resolve(result.secure_url); // Devuelve la URL segura
                } else {
                    // Caso improbable
                    console.error('[Upload SVC] Cloudinary upload stream finished without error or result.');
                    reject(new Error('La subida a Cloudinary finaliz√≥ sin resultado ni error.'));
                }
            }
        );
        // Usamos fileBuffer para crear el stream de lectura
        streamifier.createReadStream(fileBuffer).pipe(uploadStream);
    });
}; // <-- Aseg√∫rate que la llave de cierre de la funci√≥n est√°

// End of File: backend/src/uploads/upload.service.ts


// ====== [43] backend/src/shared/utils/cloudinary.config.ts ======
// filename: backend/src/utils/cloudinary.config.ts
// Version: 1.0.0 (Standard - Using process.env)
import { v2 as cloudinary } from 'cloudinary';
import dotenv from 'dotenv';
dotenv.config();
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;
if (!cloudName || !apiKey || !apiSecret) {
  console.error("ERROR: Cloudinary environment variables are missing!"); // ... resto del mensaje de error ...
} else {
   console.log("[Cloudinary Config] Credentials found from .env, configuring Cloudinary SDK...");
   cloudinary.config({ cloud_name: cloudName, api_key: apiKey, api_secret: apiSecret, secure: true });
   console.log("[Cloudinary Config] Cloudinary SDK configured successfully from .env.");
}
export default cloudinary;


// ====== [44] backend/src/shared/utils/validation.ts ======
// filename: backend/src/utils/validation.ts
// Version: 1.0.1 (Fix character encoding)

// Contiene funciones de utilidad para validaciones comunes

/**
 * Valida si un string tiene formato de DNI espa√±ol v√°lido.
 * @param dni - El string a validar.
 * @returns true si es v√°lido, false en caso contrario.
 */
export function isValidDni(dni: string): boolean {
    if (!/^\d{8}[A-Z]$/i.test(dni)) {
        return false;
    }
    const numero = parseInt(dni.substring(0, 8), 10);
    const letra = dni.substring(8, 9).toUpperCase();
    const letrasControl = "TRWAGMYFPDXBNJZSQVHLCKE";
    const letraCalculada = letrasControl.charAt(numero % 23);
    return letra === letraCalculada;
}

/**
 * Valida si un string tiene formato de NIE espa√±ol v√°lido.
 * @param nie - El string a validar.
 * @returns true si es v√°lido, false en caso contrario.
 */
export function isValidNie(nie: string): boolean {
    if (!/^[XYZ]\d{7}[A-Z]$/i.test(nie)) {
        return false;
    }
    let numeroStr = nie.substring(1, 8);
    const letraInicial = nie.substring(0, 1).toUpperCase();
    // Reemplazar letra inicial por su equivalente num√©rico para el c√°lculo
    if (letraInicial === 'Y') numeroStr = '1' + numeroStr;
    if (letraInicial === 'Z') numeroStr = '2' + numeroStr;
    // Si es X, se trata como 0, lo cual ya est√° impl√≠cito al no a√±adir prefijo

    const numero = parseInt(numeroStr, 10);
    const letra = nie.substring(8, 9).toUpperCase();
    const letrasControl = "TRWAGMYFPDXBNJZSQVHLCKE";
    const letraCalculada = letrasControl.charAt(numero % 23);
    return letra === letraCalculada;
}

/**
 * Valida si un string tiene formato de n√∫mero de tel√©fono internacional b√°sico.
 * @param phone - El string a validar.
 * @returns true si es v√°lido, false en caso contrario.
 */
export function isValidPhoneNumber(phone: string): boolean {
    // Regex simple: empieza con +, seguido de 9 a 15 d√≠gitos.
    const phoneRegex = /^\+[0-9]{9,15}$/;
    return phoneRegex.test(phone);
}

// Aqu√≠ podr√≠an a√±adirse m√°s funciones de validaci√≥n comunes en el futuro

// End of File: backend/src/utils/validation.ts


// ====== [45] backend/tsconfig.json ======
{
  "compilerOptions": {
    "target": "es2022",
    "module": "commonjs",
    "rootDir": "./src",
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "experimentalDecorators": true, // <--- A√ëADIDO
    "emitDecoratorMetadata": true   // <--- A√ëADIDO
  },
  "include": [
    "src/**/*.ts"
  ]
}


// ====== [46] frontend/index.html ======
<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LoyalPyME</title>

    <style>
      body {
        margin: 0; /* Asegura que no haya m√°rgenes por defecto */
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; /* Fuente simple de sistema */
      }
      #initial-loader {
        position: fixed; /* Posici√≥n fija para cubrir todo */
        inset: 0; /* Equivalente a top: 0; right: 0; bottom: 0; left: 0; */
        background-color: #f8f9fa; /* Un fondo claro simple (ajusta si prefieres oscuro) */
        display: flex;
        flex-direction: column; /* Apila texto y spinner */
        align-items: center;
        justify-content: center;
        z-index: 9999; /* Asegura que est√© por encima de todo */
        color: #495057;
        transition: opacity 0.5s ease-out; /* Transici√≥n suave al ocultar */
      }
      #initial-loader .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border-left-color: #09f; /* Color del spinner (puedes usar tu azul Mantine) */
        margin-top: 20px;
        animation: spin 1s ease infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      /* Estilo opcional para ocultar cuando se a√±ade la clase 'hidden' */
       #initial-loader.hidden {
          opacity: 0;
          pointer-events: none; /* No interferir con clics */
       }
    </style>
    </head>
  <body>
    <div id="initial-loader">
      <p>Cargando LoyalPyME...</p>
      <div class="spinner"></div>
    </div>
    <div id="root"></div>

    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


// ====== [47] frontend/package.json ======
{
  "name": "frontend",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "license": "SEE LICENSE IN ../LICENSE.md",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@mantine/core": "^7.17.4",
    "@mantine/form": "^7.17.4",
    "@mantine/hooks": "^7.17.4",
    "@mantine/modals": "^7.17.5",
    "@mantine/notifications": "^7.17.4",
    "@tabler/icons-react": "^3.31.0",
    "axios": "^1.8.4",
    "html5-qrcode": "^2.3.8",
    "i18next": "^23.13.2",
    "i18next-browser-languagedetector": "^8.0.1",
    "i18next-http-backend": "^2.5.2",
    "qrcode.react": "^4.2.0",
    "react": "^19.0.0",
    "react-country-flag": "^3.1.0",
    "react-dom": "^19.0.0",
    "react-i18next": "^15.0.1",
    "react-image-crop": "^11.0.10",
    "react-router-dom": "^6.26.1",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@eslint/js": "^9.22.0",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.7.1",
    "@testing-library/react": "^16.0.0",
    "@testing-library/user-event": "^14.5.2",
    "@types/qrcode.react": "^1.0.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.22.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "jsdom": "^24.1.1",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.26.1",
    "vite": "^5.4.0",
    "vite-plugin-mkcert": "^1.17.8",
    "vitest": "^2.0.4"
  }
}


// ====== [48] frontend/src/modules/camarero/components/admin/menu/MenuCategoryFormModal.tsx ======
// frontend/src/components/admin/camarero/menu/MenuCategoryFormModal.tsx
// Version 2.0.1 (Corrected aspect ratio to 1:1 and minDimension to 150px)

import React, { useEffect } from 'react';
import {
    Modal, TextInput, Textarea, NumberInput, Switch, Button, Group, Stack, Text
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next';
import { IconDeviceFloppy } from '@tabler/icons-react';
import { MenuCategoryData, MenuCategoryFormData } from '../../../types/menu.types';

// Importar el componente reutilizable
import ImageUploadCropper from '../../../../../shared/components/utils/ImageUploadCropper';

const createCategoryFormSchema = (t: Function) => z.object({
  name_es: z.string().min(1, { message: t('common.requiredField') }),
  name_en: z.string().nullable().optional(),
  description_es: z.string().nullable().optional(),
  description_en: z.string().nullable().optional(),
  imageUrl: z.string().url({ message: t('validation.invalidUrl') }).nullable().optional(),
  position: z.number().min(0, { message: t('validation.minValueMin0') }),
  isActive: z.boolean(),
});

type CategoryFormValues = z.infer<ReturnType<typeof createCategoryFormSchema>>;

interface MenuCategoryFormModalProps {
    opened: boolean;
    onClose: () => void;
    onSubmit: (values: MenuCategoryFormData) => Promise<void>;
    initialData?: MenuCategoryData | null;
    isSubmitting: boolean;
}

const MenuCategoryFormModal: React.FC<MenuCategoryFormModalProps> = ({
    opened,
    onClose,
    onSubmit,
    initialData,
    isSubmitting,
}) => {
    const { t } = useTranslation();
    
    const form = useForm<CategoryFormValues>({
        initialValues: {
            name_es: '', name_en: null, description_es: null, description_en: null,
            imageUrl: null, position: 0, isActive: true,
        },
        validate: zodResolver(createCategoryFormSchema(t)),
    });

    useEffect(() => {
        if (opened) {
            if (initialData) {
                form.setValues({
                    name_es: initialData.name_es, name_en: initialData.name_en || null,
                    description_es: initialData.description_es || null, description_en: initialData.description_en || null,
                    imageUrl: initialData.imageUrl || null, position: initialData.position, isActive: initialData.isActive,
                });
            } else {
                form.reset();
            }
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, initialData]);


    const handleSubmitForm = async (values: CategoryFormValues) => {
        const submitData: MenuCategoryFormData = {
            name_es: values.name_es, name_en: values.name_en?.trim() || null,
            description_es: values.description_es?.trim() || null, description_en: values.description_en?.trim() || null,
            imageUrl: values.imageUrl || null, position: values.position, isActive: values.isActive,
        };
        await onSubmit(submitData);
    };

    const handleModalClose = () => { if (!isSubmitting) onClose(); }

    return (
        <Modal
            opened={opened} onClose={handleModalClose}
            title={initialData ? t('adminCamarero.manageMenu.editCategoryTitle') : t('adminCamarero.manageMenu.addCategoryTitle')}
            centered size="lg" overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
            trapFocus closeOnClickOutside={!isSubmitting} closeOnEscape={!isSubmitting}
        >
            <form onSubmit={form.onSubmit(handleSubmitForm)}>
                <Stack gap="md">
                    <TextInput label={t('component.rewardForm.nameEsLabel')} placeholder={t('adminCamarero.manageMenu.categoryNameEsPlaceholder')} required disabled={isSubmitting} {...form.getInputProps('name_es')} />
                    <TextInput label={t('component.rewardForm.nameEnLabel')} placeholder={t('adminCamarero.manageMenu.categoryNameEnPlaceholder')} disabled={isSubmitting} {...form.getInputProps('name_en')} />
                    <Textarea label={t('component.rewardForm.descriptionEsLabel')} placeholder={t('adminCamarero.manageMenu.categoryDescEsPlaceholder')} rows={2} disabled={isSubmitting} {...form.getInputProps('description_es')} />
                    <Textarea label={t('component.rewardForm.descriptionEnLabel')} placeholder={t('adminCamarero.manageMenu.categoryDescEnPlaceholder')} rows={2} disabled={isSubmitting} {...form.getInputProps('description_en')} />
                    
                    <ImageUploadCropper
                        aspectRatio={1} // <-- CORRECCI√ìN AQU√ç: Cambiado de 16/9 a 1
                        minDimension={150} // <-- CORRECCI√ìN AQU√ç: Cambiado de 300 a 150
                        initialImageUrl={form.values.imageUrl || null}
                        onUploadSuccess={(url) => form.setFieldValue('imageUrl', url)}
                        onUploadError={(errorMsg) => form.setFieldError('imageUrl', errorMsg)}
                        onClearImage={() => form.setFieldValue('imageUrl', null)}
                        folderName="loyalpyme/categories"
                        disabled={isSubmitting}
                        imagePreviewAltText={t('adminCamarero.menuCategoryForm.altPreview')}
                    />
                     {form.errors.imageUrl && (
                        <Text c="red" size="xs" mt={-10}>{form.errors.imageUrl}</Text>
                    )}

                    <NumberInput label={t('adminCamarero.manageMenu.categoryPositionLabel')} placeholder={t('adminCamarero.manageMenu.categoryPositionPlaceholder')} description={t('adminCamarero.manageMenu.categoryPositionDesc')} required min={0} step={1} allowDecimal={false} disabled={isSubmitting} {...form.getInputProps('position')} />
                    <Switch label={t('adminCamarero.manageMenu.categoryActiveLabel')} description={t('adminCamarero.manageMenu.categoryActiveDesc')} mt="sm" disabled={isSubmitting} {...form.getInputProps('isActive', { type: 'checkbox' })} />

                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={handleModalClose} disabled={isSubmitting}>
                            {t('common.cancel')}
                        </Button>
                        <Button type="submit" loading={isSubmitting} disabled={isSubmitting} leftSection={<IconDeviceFloppy size={18} />} >
                            {initialData ? t('common.save') : t('common.add')}
                        </Button>
                    </Group>
                </Stack>
            </form>
        </Modal>
    );
};

export default MenuCategoryFormModal;


// ====== [49] frontend/src/modules/camarero/components/admin/menu/MenuCategoryManager.tsx ======
// frontend/src/components/admin/camarero/menu/MenuCategoryManager.tsx
import React, { useState } from 'react';
import {
    Button,
    Text, 
    Stack,
    Group,
    Loader,
    Alert,
    Table,
    ActionIcon,
    Badge,
    Image as MantineImage,
    AspectRatio,
    Center,
    Tooltip,
    Box // <--- A√ëADIDO Box
} from '@mantine/core';
import { IconPlus, IconAlertCircle, IconPencil, IconTrash, IconPhoto, IconPlayerPlay, IconPlayerStop, IconListDetails } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useModals } from '@mantine/modals';

import { useAdminMenuCategories } from '../../../hooks/useAdminMenuCategories';
import { MenuCategoryData, MenuCategoryFormData } from '../../../types/menu.types';
import MenuCategoryFormModal from './MenuCategoryFormModal';

interface MenuCategoryManagerProps {
    onSelectCategoryForItems: (category: MenuCategoryData) => void;
}

const MenuCategoryManager: React.FC<MenuCategoryManagerProps> = ({ onSelectCategoryForItems }) => {
    const { t, i18n } = useTranslation();
    const modals = useModals();
    const currentLanguage = i18n.language;

    const {
        categories,
        loading: loadingCategories,
        error: errorCategories,
        addCategory,
        updateCategory,
        deleteCategory,
    } = useAdminMenuCategories();

    const [modalOpened, setModalOpened] = useState(false);
    const [editingCategory, setEditingCategory] = useState<MenuCategoryData | null>(null);
    const [isSubmittingForm, setIsSubmittingForm] = useState(false);
    const [isUpdatingStatusId, setIsUpdatingStatusId] = useState<string | null>(null);
    const [isDeletingId, setIsDeletingId] = useState<string | null>(null);

    // console.log("[MenuCategoryManager - V2 con Prop] Renderizando. Categor√≠as:", categories.length, "Loading:", loadingCategories);

    const handleOpenAddModal = () => { setEditingCategory(null); setModalOpened(true); };
    const handleOpenEditModal = (category: MenuCategoryData) => { setEditingCategory(category); setModalOpened(true); };
    const handleCloseModal = () => { setModalOpened(false); setEditingCategory(null); };

    const handleSubmitCategoryForm = async (formData: MenuCategoryFormData) => {
        setIsSubmittingForm(true);
        let success = false;
        if (editingCategory) {
            const result = await updateCategory(editingCategory.id, formData);
            if (result) success = true;
        } else {
            const result = await addCategory(formData);
            if (result) success = true;
        }
        if (success) { handleCloseModal(); }
        setIsSubmittingForm(false);
    };

    const handleDeleteCategoryClick = (category: MenuCategoryData) => {
        const categoryName = (currentLanguage === 'es' ? category.name_es : category.name_en) || category.name_es || `ID ${category.id}`;
        modals.openConfirmModal({
            title: t('adminCommon.confirmDeleteTitle'), centered: true,
            children: ( <Text size="sm"> {t('adminCommon.confirmDeleteMessage')}{' '} {t('adminCamarero.manageMenu.category')}: <strong>"{categoryName}"</strong>? </Text> ),
            labels: { confirm: t('common.delete'), cancel: t('common.cancel') }, confirmProps: { color: 'red' },
            onConfirm: async () => { setIsDeletingId(category.id); await deleteCategory(category.id); setIsDeletingId(null); },
        });
    };

    const handleToggleCategoryActive = async (category: MenuCategoryData) => {
        setIsUpdatingStatusId(category.id);
        const newStatus = !category.isActive;
        try { await updateCategory(category.id, { isActive: newStatus }); }
        catch (error) { console.error(`Error toggling status for category ${category.id}:`, error); }
        finally { setIsUpdatingStatusId(null); }
    };

    const rows = categories.map((category) => {
        const displayName = (currentLanguage === 'es' ? category.name_es : category.name_en) || category.name_es || 'N/A';
        const isLoadingThisRowStatus = isUpdatingStatusId === category.id;
        const isLoadingThisRowDelete = isDeletingId === category.id;
        const disableActions = isSubmittingForm || !!isDeletingId || !!isUpdatingStatusId;

        return (
            <Table.Tr key={category.id}>
                <Table.Td>
                    <AspectRatio ratio={16 / 9} w={60}>
                        {category.imageUrl ? ( <MantineImage src={category.imageUrl} alt={displayName} radius="xs" fit="contain" /> )
                         : ( <Center bg="gray.1" h="100%" style={{ borderRadius: 'var(--mantine-radius-xs)' }}> <IconPhoto size={24} color="var(--mantine-color-gray-5)" /> </Center> )}
                    </AspectRatio>
                </Table.Td>
                <Table.Td>
                    <Text fw={500}>{displayName}</Text>
                    {displayName !== category.name_es && category.name_es && <Text size="xs" c="dimmed">ES: {category.name_es}</Text>}
                    {displayName !== category.name_en && category.name_en && <Text size="xs" c="dimmed">EN: {category.name_en}</Text>}
                </Table.Td>
                <Table.Td>{category.position}</Table.Td>
                <Table.Td> <Badge color={category.isActive ? 'green' : 'gray'} variant="light"> {category.isActive ? t('common.active') : t('common.inactive')} </Badge> </Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        {/* Clave de traducci√≥n: "adminCamarero.manageMenu.viewItemsTooltip": "Ver/Gestionar √çtems de esta Categor√≠a" */}
                        <Tooltip label={t('adminCamarero.manageMenu.viewItemsTooltip')} withArrow position="top">
                            <Box> {/* <--- Envolver ActionIcon en Box */}
                                <ActionIcon variant="subtle" color="cyan" onClick={() => onSelectCategoryForItems(category)} disabled={disableActions || isLoadingThisRowStatus || isLoadingThisRowDelete} >
                                    <IconListDetails size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                        
                        <Tooltip label={t('common.edit')} withArrow position="top">
                            <Box> {/* <--- Envolver ActionIcon en Box */}
                                <ActionIcon variant="subtle" color="blue" onClick={() => handleOpenEditModal(category)} disabled={disableActions || isLoadingThisRowStatus || isLoadingThisRowDelete} >
                                    <IconPencil size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>

                        <Tooltip label={category.isActive ? t('adminRewardsPage.tooltipDeactivate') : t('adminRewardsPage.tooltipActivate')} withArrow position="top" >
                            <Box> {/* <--- Envolver ActionIcon en Box */}
                                <ActionIcon variant="subtle" color={category.isActive ? 'orange' : 'teal'} onClick={() => handleToggleCategoryActive(category)} loading={isLoadingThisRowStatus} disabled={disableActions || isLoadingThisRowDelete || (isUpdatingStatusId !== null && isUpdatingStatusId !== category.id)} >
                                    {category.isActive ? <IconPlayerStop size={16} /> : <IconPlayerPlay size={16} />}
                                </ActionIcon>
                            </Box>
                        </Tooltip>

                        <Tooltip label={t('common.delete')} withArrow position="top">
                            <Box> {/* <--- Envolver ActionIcon en Box */}
                                <ActionIcon variant="subtle" color="red" onClick={() => handleDeleteCategoryClick(category)} loading={isLoadingThisRowDelete} disabled={disableActions || isLoadingThisRowStatus || (isDeletingId !== null && isDeletingId !== category.id)} >
                                    <IconTrash size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    return (
        <Stack gap="md">
            <Group justify="space-between">
                {/* Clave de traducci√≥n: "adminCamarero.manageMenu.category": "Categor√≠a" */}
                <Button leftSection={<IconPlus size={16} />} onClick={handleOpenAddModal} disabled={loadingCategories || isSubmittingForm || !!isDeletingId || !!isUpdatingStatusId} >
                    {t('common.add')} {t('adminCamarero.manageMenu.category')}
                </Button>
            </Group>
            {loadingCategories && <Group justify="center" mt="xl"><Loader /></Group>}
            {errorCategories && !loadingCategories && ( <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{errorCategories}</Alert> )}
            {!loadingCategories && !errorCategories && categories.length === 0 && ( <Text c="dimmed" ta="center" mt="md">{t('common.noItems')}</Text> )}
            {!loadingCategories && !errorCategories && categories.length > 0 && (
                <Table.ScrollContainer minWidth={600}>
                    <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                        <Table.Thead>
                            <Table.Tr>
                                <Table.Th style={{width: '80px'}}>{t('component.rewardForm.imageLabel')}</Table.Th>
                                <Table.Th>{t('common.name')}</Table.Th>
                                <Table.Th>{t('adminCamarero.manageMenu.categoryPositionLabel')}</Table.Th>
                                <Table.Th>{t('common.status')}</Table.Th>
                                <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                            </Table.Tr>
                        </Table.Thead>
                        <Table.Tbody>{rows}</Table.Tbody>
                    </Table>
                </Table.ScrollContainer>
            )}
            <MenuCategoryFormModal opened={modalOpened} onClose={handleCloseModal} onSubmit={handleSubmitCategoryForm} initialData={editingCategory} isSubmitting={isSubmittingForm} />
        </Stack>
    );
};

export default MenuCategoryManager;


// ====== [50] frontend/src/modules/camarero/components/admin/menu/MenuItemFormModal.tsx ======
// frontend/src/components/admin/camarero/menu/MenuItemFormModal.tsx
// Version 2.0.0 (Refactored to use ImageUploadCropper component)

import React, { useEffect } from 'react';
import {
    Modal, TextInput, Textarea, NumberInput, Switch, Button, Group, Stack, MultiSelect, 
    NativeScrollArea, Title, useMantineTheme, Box, Text as MantineText
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next';
import {
    IconDeviceFloppy, IconCurrencyEuro, IconSettings
} from '@tabler/icons-react';
import { useDisclosure } from '@mantine/hooks';
import { MenuItemData, MenuItemFormData } from '../../../types/menu.types';

// Importar el componente reutilizable
import ImageUploadCropper from '../../../../../shared/components/utils/ImageUploadCropper';
import ModifierGroupsManagementModal from './ModifierGroupsManagementModal';

// El schema de Zod no cambia
const createItemFormSchema = (t: Function) => z.object({
    name_es: z.string().min(1, { message: t('common.requiredField') }),
    name_en: z.string().nullable().optional(),
    description_es: z.string().nullable().optional(),
    description_en: z.string().nullable().optional(),
    price: z.number().min(0, { message: t('validation.minValueMin0') }),
    imageUrl: z.string().url({ message: t('validation.invalidUrl') }).nullable().optional(),
    allergens: z.array(z.string()).optional(),
    tags: z.array(z.string()).optional(),
    isAvailable: z.boolean(),
    position: z.number().min(0, { message: t('validation.minValueMin0') }),
    preparationTime: z.number().min(0, { message: t('common.errorMustBePositiveOrZero') }).nullable().optional(),
    calories: z.number().min(0, { message: t('common.errorMustBePositiveOrZero') }).nullable().optional(),
    kdsDestination: z.string().nullable().optional(),
    sku: z.string().nullable().optional(),
});

type ItemFormValues = z.infer<ReturnType<typeof createItemFormSchema>>;

interface MenuItemFormModalProps {
    opened: boolean;
    onClose: () => void;
    onSubmit: (values: MenuItemFormData) => Promise<void>;
    initialData?: MenuItemData | null;
    isSubmitting: boolean;
    categoryId: string;
}

const MenuItemFormModal: React.FC<MenuItemFormModalProps> = ({
    opened,
    onClose,
    onSubmit,
    initialData,
    isSubmitting,
}) => {
    const { t } = useTranslation();
    const theme = useMantineTheme();
    
    const form = useForm<ItemFormValues>({
        initialValues: {
            name_es: '', name_en: null, description_es: null, description_en: null,
            price: 0, imageUrl: null, allergens: [], tags: [],
            isAvailable: true, position: 0, preparationTime: null, calories: null,
            kdsDestination: null, sku: null,
        },
        validate: zodResolver(createItemFormSchema(t)),
    });

    const [groupsModalOpened, { open: openGroupsModal, close: closeGroupsModal }] = useDisclosure(false);

    useEffect(() => {
        if (opened) {
            if (initialData) {
                form.setValues({
                    name_es: initialData.name_es, name_en: initialData.name_en || null,
                    description_es: initialData.description_es || null, description_en: initialData.description_en || null,
                    price: initialData.price, imageUrl: initialData.imageUrl || null,
                    allergens: initialData.allergens || [], tags: initialData.tags || [],
                    isAvailable: initialData.isAvailable, position: initialData.position,
                    preparationTime: initialData.preparationTime || null, calories: initialData.calories || null,
                    kdsDestination: initialData.kdsDestination || null, sku: initialData.sku || null,
                });
            } else {
                form.reset();
            }
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, initialData]);

    const handleSubmitForm = async (values: ItemFormValues) => {
        const submitData: MenuItemFormData = {
            ...values,
            name_en: values.name_en?.trim() || null,
            description_es: values.description_es?.trim() || null,
            description_en: values.description_en?.trim() || null,
            imageUrl: values.imageUrl || null,
            allergens: values.allergens || [],
            tags: values.tags || [],
            preparationTime: values.preparationTime ?? null,
            calories: values.calories ?? null,
            kdsDestination: values.kdsDestination?.trim() || null,
            sku: values.sku?.trim() || null,
        };
        await onSubmit(submitData);
    };

    const handleModalClose = () => { if (!isSubmitting) onClose(); }
    
    const allergenOptions = ['GLUTEN', 'LACTOSE', 'NUTS', 'SOY', 'FISH', 'CRUSTACEANS', 'CELERY', 'MUSTARD', 'SESAME', 'SULPHITES', 'LUPIN', 'MOLLUSCS'].map(val => ({value: val, label: t(`adminCamarero.menuItem.allergen.${val}`, val)}));
    const tagOptions = ['VEGAN', 'VEGETARIAN', 'SPICY', 'NEW', 'POPULAR', 'HOUSE_SPECIAL'].map(val => ({value: val, label: t(`adminCamarero.menuItem.tag.${val}`, val)}));

    const allergenInputProps = form.getInputProps('allergens');
    const tagInputProps = form.getInputProps('tags');

    const menuItemIdForGroupsModal = initialData ? initialData.id : null;
    const menuItemDisplayNameForModal = initialData ? (initialData.name_es || initialData.name_en || t('adminCamarero.manageMenu.itemFallbackName')) : t('adminCamarero.manageMenu.itemNew');

    return (
        <>
            <Modal
                opened={opened} onClose={handleModalClose}
                title={initialData ? t('adminCamarero.manageMenu.editItemTitle') : t('adminCamarero.manageMenu.addItemTitle')}
                centered size="xl"
                overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
                trapFocus closeOnClickOutside={!isSubmitting} closeOnEscape={!isSubmitting}
                scrollAreaComponent={NativeScrollArea}
            >
                <form onSubmit={form.onSubmit(handleSubmitForm)}>
                    <Stack gap="md">
                        <Group grow>
                            <TextInput label={t('component.rewardForm.nameEsLabel')} placeholder={t('adminCamarero.manageMenu.itemNameEsPlaceholder')} required disabled={isSubmitting} {...form.getInputProps('name_es')} />
                            <TextInput label={t('component.rewardForm.nameEnLabel')} placeholder={t('adminCamarero.manageMenu.itemNameEnPlaceholder')} disabled={isSubmitting} {...form.getInputProps('name_en')} />
                        </Group>
                        <Textarea label={t('component.rewardForm.descriptionEsLabel')} placeholder={t('adminCamarero.manageMenu.itemDescEsPlaceholder')} rows={3} disabled={isSubmitting} {...form.getInputProps('description_es')} />
                        <Textarea label={t('component.rewardForm.descriptionEnLabel')} placeholder={t('adminCamarero.manageMenu.itemDescEnPlaceholder')} rows={3} disabled={isSubmitting} {...form.getInputProps('description_en')} />

                        <NumberInput
                            label={t('adminCamarero.manageMenu.itemPrice')}
                            placeholder="0.00" required min={0} step={0.01} decimalScale={2} fixedDecimalScale
                            leftSection={<IconCurrencyEuro size={16} />}
                            disabled={isSubmitting}
                            {...form.getInputProps('price')}
                        />
                        
                        <ImageUploadCropper
                            aspectRatio={1}
                            minDimension={150}
                            initialImageUrl={form.values.imageUrl || null}
                            onUploadSuccess={(url) => form.setFieldValue('imageUrl', url)}
                            onUploadError={(errorMsg) => form.setFieldError('imageUrl', errorMsg)}
                            onClearImage={() => form.setFieldValue('imageUrl', null)}
                            folderName="loyalpyme/menu-items"
                            disabled={isSubmitting}
                            imagePreviewAltText={t('adminCamarero.menuItemForm.altPreview')}
                            imageToCropAltText={t('adminCamarero.menuItemForm.altCropImage')}
                        />
                         {form.errors.imageUrl && (
                            <MantineText c="red" size="xs" mt={-10}>{form.errors.imageUrl}</MantineText>
                        )}

                        <MultiSelect
                            label={t('adminCamarero.manageMenu.itemAllergens')}
                            placeholder={t('adminCamarero.manageMenu.itemAllergensPlaceholder')}
                            data={allergenOptions}
                            searchable
                            // @ts-expect-error creatable is a valid prop for Mantine v7 MultiSelect
                            creatable
                            getCreateLabel={(query: string) => `+ ${t('common.add')} "${query}"`}
                            disabled={isSubmitting}
                            {...allergenInputProps}
                        />
                        <MultiSelect
                            label={t('adminCamarero.manageMenu.itemTags')}
                            placeholder={t('adminCamarero.manageMenu.itemTagsPlaceholder')}
                            data={tagOptions}
                            searchable
                            // @ts-expect-error creatable is a valid prop for Mantine v7 MultiSelect
                            creatable
                            getCreateLabel={(query: string) => `+ ${t('common.add')} "${query}"`}
                            disabled={isSubmitting}
                            {...tagInputProps}
                        />
                        <Group grow>
                            <NumberInput label={t('adminCamarero.manageMenu.itemPosition')} placeholder="0" min={0} step={1} allowDecimal={false} disabled={isSubmitting} {...form.getInputProps('position')} />
                            <NumberInput label={t('adminCamarero.manageMenu.itemPrepTime')} placeholder={t('common.optional')} min={0} step={1} allowDecimal={false} disabled={isSubmitting} {...form.getInputProps('preparationTime')} />
                        </Group>
                        <Group grow>
                            <NumberInput label={t('adminCamarero.manageMenu.itemCalories')} placeholder={t('common.optional')} min={0} step={1} allowDecimal={false} disabled={isSubmitting} {...form.getInputProps('calories')} />
                            <TextInput label={t('adminCamarero.manageMenu.itemSku')} placeholder={t('common.optional')} disabled={isSubmitting} {...form.getInputProps('sku')} />
                        </Group>
                        <TextInput label={t('adminCamarero.manageMenu.itemKds')} placeholder={t('adminCamarero.manageMenu.itemKdsPlaceholder')} description={t('adminCamarero.manageMenu.itemKdsDesc')} disabled={isSubmitting} {...form.getInputProps('kdsDestination')} />
                        <Switch label={t('adminCamarero.manageMenu.itemIsAvailable')} description={t('adminCamarero.manageMenu.itemIsAvailableDesc')} mt="sm" disabled={isSubmitting} {...form.getInputProps('isAvailable', { type: 'checkbox' })} />

                        {initialData && (
                            <Box mt="lg" pt="lg" style={{ borderTop: `1px solid ${theme.colors.gray[3]}` }}>
                                <Group justify="space-between" mb="sm">
                                    <Title order={5}>{t('adminCamarero.manageMenu.modifierGroupsTitle')}</Title>
                                    <Button
                                        variant="outline" size="xs"
                                        leftSection={<IconSettings size={16} />}
                                        onClick={openGroupsModal}
                                        disabled={isSubmitting}
                                    >
                                        {t('adminCamarero.manageMenu.manageGroupsButton')}
                                    </Button>
                                </Group>
                                <MantineText size="xs" c="dimmed" mb="md">
                                    {t('adminCamarero.manageMenu.modifierGroupsDescription')}
                                </MantineText>
                            </Box>
                        )}

                        <Group justify="flex-end" mt="lg">
                            <Button variant="default" onClick={handleModalClose} disabled={isSubmitting}>{t('common.cancel')}</Button>
                            <Button type="submit" loading={isSubmitting} leftSection={<IconDeviceFloppy size={18} />} >
                                {initialData ? t('common.save') : t('common.add')}
                            </Button>
                        </Group>
                    </Stack>
                </form>
            </Modal>

            {initialData && menuItemIdForGroupsModal && (
                <ModifierGroupsManagementModal
                    opened={groupsModalOpened}
                    onClose={closeGroupsModal}
                    menuItemId={menuItemIdForGroupsModal}
                    menuItemName={menuItemDisplayNameForModal}
                />
            )}
        </>
    );
};

export default MenuItemFormModal;


// ====== [51] frontend/src/modules/camarero/components/admin/menu/MenuItemManager.tsx ======
// frontend/src/components/admin/camarero/menu/MenuItemManager.tsx
// Version 1.0.1 (Remove unused categoryName prop)

import React, { useState } from 'react';
import {
    Box, Button, Text, Stack, Group, Loader, Alert,
    Table, ActionIcon, Badge, Tooltip,
    Image as MantineImage, AspectRatio, Center,
} from '@mantine/core';
import {
    IconPlus, IconAlertCircle, IconPencil, IconTrash, IconPhoto,
    IconPlayerPlay, IconPlayerStop, IconFileDescription
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useModals } from '@mantine/modals';
import { notifications } from '@mantine/notifications'; // A√±adido para handleManageModifiers

import { useAdminMenuItems } from '../../../hooks/useAdminMenuItems';
import { MenuItemData, MenuItemFormData } from '../../../types/menu.types';
import MenuItemFormModal from './MenuItemFormModal';

interface MenuItemManagerProps {
    categoryId: string;
    // categoryName: string; // <-- PROP ELIMINADA
}

// --- CORRECCI√ìN: Quitar categoryName de la desestructuraci√≥n ---
const MenuItemManager: React.FC<MenuItemManagerProps> = ({ categoryId /*, categoryName*/ }) => {
    const { t, i18n } = useTranslation();
    const modals = useModals();
    const currentLanguage = i18n.language;

    const {
        items,
        loading: loadingItems,
        error: errorItems,
        addItem,
        updateItem,
        deleteItem,
    } = useAdminMenuItems(categoryId);

    const [itemModalOpened, setItemModalOpened] = useState(false);
    const [editingItem, setEditingItem] = useState<MenuItemData | null>(null);
    const [isSubmittingItemForm, setIsSubmittingItemForm] = useState(false);
    const [isUpdatingItemStatusId, setIsUpdatingItemStatusId] = useState<string | null>(null);
    const [isDeletingItemId, setIsDeletingItemId] = useState<string | null>(null);

    const handleOpenAddItemModal = () => {
        setEditingItem(null);
        setItemModalOpened(true);
    };

    const handleOpenEditItemModal = (item: MenuItemData) => {
        setEditingItem(item);
        setItemModalOpened(true);
    };

    const handleCloseItemModal = () => {
        setItemModalOpened(false);
        setEditingItem(null);
    };

    const handleSubmitItemForm = async (formData: MenuItemFormData) => {
        setIsSubmittingItemForm(true);
        let success = false;
        if (editingItem) {
            const result = await updateItem(editingItem.id, formData);
            if (result) success = true;
        } else {
            const result = await addItem(formData);
            if (result) success = true;
        }
        if (success) {
            handleCloseItemModal();
        }
        setIsSubmittingItemForm(false);
    };

    const handleToggleItemAvailable = async (item: MenuItemData) => {
        setIsUpdatingItemStatusId(item.id);
        const newStatus = !item.isAvailable;
        try {
            // Asegurarse de que solo se env√≠a el campo que se quiere actualizar
            await updateItem(item.id, { isAvailable: newStatus });
        } catch (error) {
            console.error(`Error toggling availability for item ${item.id}:`, error);
            // La notificaci√≥n de error ya la maneja el hook si ocurre
        } finally {
            setIsUpdatingItemStatusId(null);
        }
    };

    const handleDeleteItemClick = (item: MenuItemData) => {
        const itemName = (currentLanguage === 'es' && item.name_es) ? item.name_es : (item.name_en || item.name_es || t('adminCamarero.manageMenu.itemFallbackName'));
        modals.openConfirmModal({
            title: t('adminCommon.confirmDeleteTitle'),
            centered: true,
            children: ( <Text size="sm"> {t('adminCommon.confirmDeleteMessage')}{' '} {t('adminCamarero.manageMenu.itemLabel')}: <strong>"{itemName}"</strong>? </Text> ),
            labels: { confirm: t('common.delete'), cancel: t('common.cancel') },
            confirmProps: { color: 'red' },
            onConfirm: async () => {
                setIsDeletingItemId(item.id);
                await deleteItem(item.id); // El hook maneja la notificaci√≥n
                setIsDeletingItemId(null);
            },
        });
    };
    
    const handleManageModifiers = (item: MenuItemData) => {
        const itemName = (currentLanguage === 'es' && item.name_es) ? item.name_es : (item.name_en || item.name_es || t('adminCamarero.manageMenu.itemFallbackName'));
        // Implementaci√≥n real para abrir el modal de modificadores
        // Esto es solo un placeholder:
        notifications.show({
             title: t('common.upcomingFeatureTitle'),
             message: `${t('adminCamarero.manageMenu.manageModifiersTooltip')} para: ${itemName} (ID: ${item.id})`,
             color: 'blue'
        });
        console.log("Abrir modal de modificadores para el √≠tem:", item.id, itemName);
    };


    const rows = items.map((item) => {
        const displayName = (currentLanguage === 'es' && item.name_es) ? item.name_es : (item.name_en || item.name_es || t('common.nameNotAvailable'));
        const isLoadingThisRowStatus = isUpdatingItemStatusId === item.id;
        const isLoadingThisRowDelete = isDeletingItemId === item.id;
        const disableActions = isSubmittingItemForm || !!isDeletingItemId || !!isUpdatingItemStatusId;
        const itemAvailabilityText = item.isAvailable ? t('adminCamarero.manageMenu.itemAvailable') : t('adminCamarero.manageMenu.itemNotAvailable');
        const tooltipToggleAvailable = item.isAvailable ? t('adminCamarero.manageMenu.markNotAvailable') : t('adminCamarero.manageMenu.markAvailable');

        return (
            <Table.Tr key={item.id}>
                <Table.Td>
                    <AspectRatio ratio={1 / 1} w={50}>
                        {item.imageUrl ? ( <MantineImage src={item.imageUrl} alt={displayName} radius="xs" fit="cover" fallbackSrc="/placeholder-item.png" /> )
                         : ( <Center bg="gray.1" h="100%" style={{ borderRadius: 'var(--mantine-radius-xs)' }}> <IconPhoto size={20} color="var(--mantine-color-gray-5)" /> </Center> )}
                    </AspectRatio>
                </Table.Td>
                <Table.Td>
                    <Text fw={500}>{displayName}</Text>
                    {displayName !== item.name_es && item.name_es && <Text size="xs" c="dimmed">ES: {item.name_es}</Text>}
                    {displayName !== item.name_en && item.name_en && <Text size="xs" c="dimmed">EN: {item.name_en}</Text>}
                </Table.Td>
                <Table.Td ta="right">{Number(item.price).toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}</Table.Td>
                <Table.Td>{item.position}</Table.Td>
                <Table.Td>
                    <Badge color={item.isAvailable ? 'green' : 'gray'} variant="light">
                        {itemAvailabilityText}
                    </Badge>
                </Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        <Tooltip label={t('adminCamarero.manageMenu.manageModifiersTooltip')} withArrow position="top">
                            <Box>
                                <ActionIcon variant="subtle" color="violet" onClick={() => handleManageModifiers(item)} disabled={disableActions || isLoadingThisRowStatus || isLoadingThisRowDelete}>
                                    <IconFileDescription size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                        <Tooltip label={t('common.edit')} withArrow position="top">
                            <Box>
                                <ActionIcon variant="subtle" color="blue" onClick={() => handleOpenEditItemModal(item)} disabled={disableActions || isLoadingThisRowStatus || isLoadingThisRowDelete} >
                                    <IconPencil size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                        <Tooltip label={tooltipToggleAvailable} withArrow position="top" >
                           <Box>
                                <ActionIcon
                                    variant="subtle"
                                    color={item.isAvailable ? "orange" : "teal"}
                                    onClick={() => handleToggleItemAvailable(item)}
                                    loading={isLoadingThisRowStatus}
                                    disabled={disableActions || isLoadingThisRowDelete || (isUpdatingItemStatusId !== null && isUpdatingItemStatusId !== item.id)}
                                >
                                    {item.isAvailable ? <IconPlayerStop size={16} /> : <IconPlayerPlay size={16} />}
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                        <Tooltip label={t('common.delete')} withArrow position="top">
                            <Box>
                                <ActionIcon
                                    variant="subtle"
                                    color="red"
                                    onClick={() => handleDeleteItemClick(item)}
                                    loading={isLoadingThisRowDelete}
                                    disabled={disableActions || isLoadingThisRowStatus || (isDeletingItemId !== null && isDeletingItemId !== item.id)}
                                >
                                    <IconTrash size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    return (
        <Stack gap="md" mt="lg">
            <Group justify="space-between">
                <Button
                    leftSection={<IconPlus size={16} />}
                    onClick={handleOpenAddItemModal}
                    disabled={loadingItems || isSubmittingItemForm || !!isDeletingItemId || !!isUpdatingItemStatusId}
                >
                    {t('common.add')} {t('adminCamarero.manageMenu.itemLabel')}
                </Button>
            </Group>

            {loadingItems && <Group justify="center" mt="xl"><Loader /></Group>}
            {errorItems && !loadingItems && (
                <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{errorItems}</Alert>
            )}

            {!loadingItems && !errorItems && items.length === 0 && (
                <Text c="dimmed" ta="center" mt="md">
                    {t('adminCamarero.manageMenu.noItemsInCategory')}
                </Text>
            )}

            {!loadingItems && !errorItems && items.length > 0 && (
                <Table.ScrollContainer minWidth={700}>
                    <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                        <Table.Thead>
                            <Table.Tr>
                                <Table.Th style={{width: '70px'}}>{t('adminCamarero.manageMenu.itemImageLabel')}</Table.Th>
                                <Table.Th>{t('common.name')}</Table.Th>
                                <Table.Th ta="right">{t('adminCamarero.manageMenu.itemPrice')}</Table.Th>
                                <Table.Th>{t('adminCamarero.manageMenu.itemPosition')}</Table.Th>
                                <Table.Th>{t('adminCamarero.manageMenu.itemAvailability')}</Table.Th>
                                <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                            </Table.Tr>
                        </Table.Thead>
                        <Table.Tbody>{rows}</Table.Tbody>
                    </Table>
                </Table.ScrollContainer>
            )}

            {categoryId && ( // categoryId existe porque es una prop requerida
                 <MenuItemFormModal
                    opened={itemModalOpened}
                    onClose={handleCloseItemModal}
                    onSubmit={handleSubmitItemForm}
                    initialData={editingItem}
                    isSubmitting={isSubmittingItemForm}
                    categoryId={categoryId}
                />
            )}
        </Stack>
    );
};

export default MenuItemManager;


// ====== [52] frontend/src/modules/camarero/components/admin/menu/ModifierGroupsManagementModal.tsx ======
// frontend/src/components/admin/camarero/menu/ModifierGroupsManagementModal.tsx
import React, { useState, useEffect } from 'react';
import {
    Modal, Button, Stack, Group, Title, Text, Loader, Alert,
    Table, ActionIcon, Badge, Tooltip, TextInput, Select, NumberInput, Switch,
    Paper, Divider, NativeScrollArea
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import { z } from 'zod';
import {
    IconPlus, IconAlertCircle, IconPencil, IconTrash, IconDeviceFloppy, IconSettings
} from '@tabler/icons-react';
import { useAdminModifierGroups } from '../../../hooks/useAdminModifierGroups';
import { ModifierGroupData, ModifierGroupFormData, ModifierUiType } from '../../../types/menu.types';
import ModifierOptionsManagementModal from './ModifierOptionsManagementModal';
import { useTranslation } from 'react-i18next'; // Asegurarse de importar

const createModifierGroupSchema = (t: Function) => z.object({
    name_es: z.string().min(1, { message: t('adminCamarero.modifierGroupForm.validation.nameEsRequired') }),
    name_en: z.string().nullable().optional(),
    uiType: z.nativeEnum(ModifierUiType, { errorMap: () => ({ message: t('adminCamarero.modifierGroupForm.validation.uiTypeInvalid') }) }),
    minSelections: z.number().min(0, { message: t('adminCamarero.modifierGroupForm.validation.minSelectionsInvalid') }).default(0),
    maxSelections: z.number().min(1, { message: t('adminCamarero.modifierGroupForm.validation.maxSelectionsInvalid') }).default(1),
    position: z.number().min(0).default(0),
    isRequired: z.boolean().default(false),
}).refine(data => data.minSelections <= data.maxSelections, {
    message: t('adminCamarero.modifierGroupForm.validation.minMaxMismatch'),
    path: ["maxSelections"],
});

type ModifierGroupFormValues = z.infer<ReturnType<typeof createModifierGroupSchema>>;

interface ModifierGroupsManagementModalProps {
    opened: boolean;
    onClose: () => void;
    menuItemId: string | null;
    menuItemName: string;
}

const ModifierGroupsManagementModal: React.FC<ModifierGroupsManagementModalProps> = ({
    opened,
    onClose,
    menuItemId,
    menuItemName,
}) => {
    const { t, i18n } = useTranslation(); // A√±adir i18n para currentLanguage si es necesario
    const currentLanguage = i18n.language;

    const {
        modifierGroups,
        loading: loadingGroups,
        error: errorGroups,
        addModifierGroup,
        updateModifierGroup,
        deleteModifierGroup,
        fetchModifierGroups,
    } = useAdminModifierGroups(menuItemId);

    const [showForm, setShowForm] = useState(false);
    const [editingGroup, setEditingGroup] = useState<ModifierGroupData | null>(null);
    const [isSubmittingForm, setIsSubmittingForm] = useState(false);
    const [isDeletingGroupId, setIsDeletingGroupId] = useState<string | null>(null);

    const [optionsModalOpened, { open: openOptionsModal, close: closeOptionsModal }] = useDisclosure(false);
    const [selectedGroupForOptions, setSelectedGroupForOptions] = useState<ModifierGroupData | null>(null);

    const form = useForm<ModifierGroupFormValues>({
        initialValues: {
            name_es: '', name_en: null, uiType: ModifierUiType.RADIO,
            minSelections: 0, maxSelections: 1, position: 0, isRequired: false,
        },
        validate: zodResolver(createModifierGroupSchema(t)),
    });

    useEffect(() => {
        if (opened && menuItemId) {
            fetchModifierGroups();
        }
        if (!opened) {
            setShowForm(false);
            setEditingGroup(null);
            form.reset();
            closeOptionsModal();
            setSelectedGroupForOptions(null);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, menuItemId, closeOptionsModal]);

    const handleOpenAddForm = () => {
        setEditingGroup(null);
        form.reset();
        form.setFieldValue('position', modifierGroups.length > 0 ? Math.max(...modifierGroups.map(g => g.position)) + 1 : 0);
        setShowForm(true);
    };

    const handleOpenEditForm = (group: ModifierGroupData) => {
        setEditingGroup(group);
        form.setValues({
            name_es: group.name_es,
            name_en: group.name_en || null,
            uiType: group.uiType,
            minSelections: group.minSelections,
            maxSelections: group.maxSelections,
            position: group.position,
            isRequired: group.isRequired,
        });
        setShowForm(true);
    };

    const handleFormSubmit = async (values: ModifierGroupFormValues) => {
        if (!menuItemId) return;
        setIsSubmittingForm(true);
        const formData: ModifierGroupFormData = {
            name_es: values.name_es,
            name_en: values.name_en || null,
            uiType: values.uiType,
            minSelections: values.minSelections,
            maxSelections: values.maxSelections,
            position: values.position,
            isRequired: values.isRequired,
        };

        let success = false;
        if (editingGroup) {
            const result = await updateModifierGroup(editingGroup.id, formData);
            if (result) success = true;
        } else {
            const result = await addModifierGroup(formData);
            if (result) success = true;
        }

        if (success) {
            setShowForm(false);
            setEditingGroup(null);
            form.reset();
        }
        setIsSubmittingForm(false);
    };

    const handleDeleteGroup = async (groupId: string) => {
        setIsDeletingGroupId(groupId);
        await deleteModifierGroup(groupId); // El hook se encarga de la notificaci√≥n
        setIsDeletingGroupId(null);
    };

    const handleManageOptions = (group: ModifierGroupData) => {
        setSelectedGroupForOptions(group);
        openOptionsModal();
    };

    const groupRows = modifierGroups.map((group) => {
        const groupDisplayName = (currentLanguage === 'es' && group.name_es) ? group.name_es : (group.name_en || group.name_es || t('common.nameNotAvailable'));
        return (
            <Table.Tr key={group.id}>
                <Table.Td>
                    <Text fw={500}>{groupDisplayName}</Text>
                    {groupDisplayName !== group.name_es && group.name_es && <Text size="xs" c="dimmed">ES: {group.name_es}</Text>}
                    {groupDisplayName !== group.name_en && group.name_en && <Text size="xs" c="dimmed">EN: {group.name_en}</Text>}
                </Table.Td>
                <Table.Td><Badge color="cyan" variant="light">{group.uiType}</Badge></Table.Td>
                <Table.Td>{group.minSelections} - {group.maxSelections}</Table.Td>
                <Table.Td>{group.isRequired ? t('common.yes') : t('common.no')}</Table.Td>
                <Table.Td>{group.position}</Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        <Tooltip label={t('adminCamarero.modifierGroupsModal.tooltipManageOptions')} withArrow>
                            <ActionIcon variant="subtle" color="green" onClick={() => handleManageOptions(group)} disabled={!!isDeletingGroupId}>
                                <IconSettings size={16} />
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={t('adminCamarero.modifierGroupsModal.tooltipEditGroup')} withArrow>
                            <ActionIcon variant="subtle" color="blue" onClick={() => handleOpenEditForm(group)} disabled={!!isDeletingGroupId}>
                                <IconPencil size={16} />
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={t('adminCamarero.modifierGroupsModal.tooltipDeleteGroup')} withArrow>
                            <ActionIcon variant="subtle" color="red" onClick={() => handleDeleteGroup(group.id)} loading={isDeletingGroupId === group.id} disabled={!!isDeletingGroupId && isDeletingGroupId !== group.id}>
                                <IconTrash size={16} />
                            </ActionIcon>
                        </Tooltip>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    const uiTypeOptions = Object.values(ModifierUiType).map(type => ({
        value: type,
        label: t(`adminCamarero.modifierGroupForm.uiType.${type}`, type) // Claves como 'adminCamarero.modifierGroupForm.uiType.RADIO'
    }));


    return (
        <>
            <Modal
                opened={opened && !!menuItemId}
                onClose={onClose}
                title={t('adminCamarero.modifierGroupsModal.title', { itemName: menuItemName })}
                size="xl"
                centered
                scrollAreaComponent={NativeScrollArea}
                overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
            >
                <Stack gap="lg">
                    {!showForm ? (
                        <>
                            <Group justify="space-between">
                                <Title order={5}>{t('adminCamarero.modifierGroupsModal.existingGroupsTitle')}</Title>
                                <Button leftSection={<IconPlus size={16} />} onClick={handleOpenAddForm} disabled={loadingGroups}>
                                    {t('adminCamarero.modifierGroupsModal.createNewGroupButton')}
                                </Button>
                            </Group>

                            {loadingGroups && <Group justify="center" mt="md"><Loader /></Group>}
                            {errorGroups && !loadingGroups && <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{errorGroups}</Alert>}
                            {!loadingGroups && !errorGroups && modifierGroups.length === 0 && <Text c="dimmed" ta="center" mt="md">{t('adminCamarero.modifierGroupsModal.noGroupsForItem')}</Text>}
                            {!loadingGroups && !errorGroups && modifierGroups.length > 0 && (
                                <Table.ScrollContainer minWidth={600}>
                                    <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                                        <Table.Thead>
                                            <Table.Tr>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderName')}</Table.Th>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderUiType')}</Table.Th>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderSelections')}</Table.Th>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderRequired')}</Table.Th>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderPosition')}</Table.Th>
                                                <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                                            </Table.Tr>
                                        </Table.Thead>
                                        <Table.Tbody>{groupRows}</Table.Tbody>
                                    </Table>
                                </Table.ScrollContainer>
                            )}
                        </>
                    ) : (
                        <Paper withBorder p="md" radius="md">
                            <Title order={5} mb="md">{editingGroup ? t('adminCamarero.modifierGroupsModal.formEditTitle', { groupName: (currentLanguage === 'es' && editingGroup.name_es) ? editingGroup.name_es : (editingGroup.name_en || editingGroup.name_es || '') }) : t('adminCamarero.modifierGroupsModal.formCreateTitle')}</Title>
                            <form onSubmit={form.onSubmit(handleFormSubmit)}>
                                <Stack gap="sm">
                                    <TextInput label={t('adminCamarero.modifierGroupForm.nameEsLabel')} required {...form.getInputProps('name_es')} disabled={isSubmittingForm} />
                                    <TextInput label={t('adminCamarero.modifierGroupForm.nameEnLabel')} {...form.getInputProps('name_en')} disabled={isSubmittingForm} />
                                    <Select
                                        label={t('adminCamarero.modifierGroupForm.uiTypeLabel')}
                                        data={uiTypeOptions}
                                        required
                                        {...form.getInputProps('uiType')}
                                        disabled={isSubmittingForm}
                                    />
                                    <Group grow>
                                        <NumberInput label={t('adminCamarero.modifierGroupForm.minSelectionsLabel')} min={0} {...form.getInputProps('minSelections')} disabled={isSubmittingForm} />
                                        <NumberInput label={t('adminCamarero.modifierGroupForm.maxSelectionsLabel')} min={1} {...form.getInputProps('maxSelections')} disabled={isSubmittingForm} />
                                    </Group>
                                    <NumberInput label={t('adminCamarero.modifierGroupForm.positionLabel')} min={0} {...form.getInputProps('position')} disabled={isSubmittingForm} />
                                    <Switch label={t('adminCamarero.modifierGroupForm.isRequiredLabel')} {...form.getInputProps('isRequired', { type: 'checkbox' })} disabled={isSubmittingForm} />

                                    <Group justify="flex-end" mt="md">
                                        <Button variant="default" onClick={() => { setShowForm(false); setEditingGroup(null); form.reset(); }} disabled={isSubmittingForm}>
                                            {t('common.cancel')}
                                        </Button>
                                        <Button type="submit" loading={isSubmittingForm} leftSection={<IconDeviceFloppy size={16} />}>
                                            {editingGroup ? t('common.saveChanges') : t('adminCamarero.modifierGroupsModal.formCreateButton')}
                                        </Button>
                                    </Group>
                                </Stack>
                            </form>
                        </Paper>
                    )}
                    <Divider mt="lg" />
                    <Group justify="flex-end" mt="md">
                        <Button variant="outline" onClick={onClose}>{t('adminCamarero.modifierGroupsModal.closeButton')}</Button>
                    </Group>
                </Stack>
            </Modal>

            {selectedGroupForOptions && (
                <ModifierOptionsManagementModal
                    opened={optionsModalOpened}
                    onClose={() => {
                        closeOptionsModal();
                        setSelectedGroupForOptions(null);
                        fetchModifierGroups();
                    }}
                    modifierGroupId={selectedGroupForOptions.id}
                    modifierGroupName={(currentLanguage === 'es' && selectedGroupForOptions.name_es) ? selectedGroupForOptions.name_es : (selectedGroupForOptions.name_en || selectedGroupForOptions.name_es || t('common.nameNotAvailable'))}
                />
            )}
        </>
    );
};

export default ModifierGroupsManagementModal;


// ====== [53] frontend/src/modules/camarero/components/admin/menu/ModifierOptionsManagementModal.tsx ======
// frontend/src/components/admin/camarero/menu/ModifierOptionsManagementModal.tsx
import React, { useState, useEffect } from 'react';
import {
    Modal, Button, Stack, Group, Title, Text, Loader, Alert,
    Table, ActionIcon, Badge, Tooltip, TextInput, NumberInput, Switch,
    Paper, Divider, NativeScrollArea
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import {
    IconPlus, IconAlertCircle, IconPencil, IconTrash, IconDeviceFloppy, IconCurrencyEuro,
    IconPlayerPlay, IconPlayerStop
} from '@tabler/icons-react';
import { useAdminModifierOptions } from '../../../hooks/useAdminModifierOptions';
import { ModifierOptionData, ModifierOptionFormData } from '../../../types/menu.types';
import { useTranslation } from 'react-i18next'; // Asegurarse de importar

// Schema de validaci√≥n Zod usando la funci√≥n t
const createModifierOptionSchema = (t: Function) => z.object({
    name_es: z.string().min(1, { message: t('adminCamarero.modifierOptionForm.validation.nameEsRequired') }),
    name_en: z.string().nullable().optional(),
    priceAdjustment: z.coerce.number().default(0),
    position: z.coerce.number().min(0).default(0),
    isDefault: z.boolean().default(false),
    isAvailable: z.boolean().default(true),
});

type ModifierOptionFormValues = z.infer<ReturnType<typeof createModifierOptionSchema>>;

interface ModifierOptionsManagementModalProps {
    opened: boolean;
    onClose: () => void;
    modifierGroupId: string | null;
    modifierGroupName: string;
}

const ModifierOptionsManagementModal: React.FC<ModifierOptionsManagementModalProps> = ({
    opened,
    onClose,
    modifierGroupId,
    modifierGroupName,
}) => {
    const { t, i18n } = useTranslation(); // A√±adir i18n para currentLanguage si es necesario
    const currentLanguage = i18n.language;

    const {
        modifierOptions,
        loading: loadingOptions,
        error: errorOptions,
        addModifierOption,
        updateModifierOption,
        deleteModifierOption,
        fetchModifierOptions,
    } = useAdminModifierOptions(modifierGroupId);

    const [showOptionForm, setShowOptionForm] = useState(false);
    const [editingOption, setEditingOption] = useState<ModifierOptionData | null>(null);
    const [isSubmittingOptionForm, setIsSubmittingOptionForm] = useState(false);
    const [isDeletingOptionId, setIsDeletingOptionId] = useState<string | null>(null);
    const [isTogglingStatusOptionId, setIsTogglingStatusOptionId] = useState<string | null>(null);

    const form = useForm<ModifierOptionFormValues>({
        initialValues: {
            name_es: '', name_en: null, priceAdjustment: 0,
            position: 0, isDefault: false, isAvailable: true,
        },
        validate: zodResolver(createModifierOptionSchema(t)), // Pasar t al resolver
    });

    useEffect(() => {
        if (opened && modifierGroupId) {
            fetchModifierOptions();
        }
        if (!opened) {
            setShowOptionForm(false);
            setEditingOption(null);
            form.reset();
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, modifierGroupId]);

    const handleOpenAddOptionForm = () => {
        setEditingOption(null);
        form.reset();
        form.setFieldValue('position', modifierOptions.length > 0 ? Math.max(...modifierOptions.map(o => o.position)) + 1 : 0);
        setShowOptionForm(true);
    };

    const handleOpenEditOptionForm = (option: ModifierOptionData) => {
        setEditingOption(option);
        form.setValues({
            name_es: option.name_es,
            name_en: option.name_en || null,
            priceAdjustment: Number(option.priceAdjustment),
            position: Number(option.position),
            isDefault: option.isDefault,
            isAvailable: option.isAvailable,
        });
        setShowOptionForm(true);
    };

    const handleOptionFormSubmit = async (values: ModifierOptionFormValues) => {
        if (!modifierGroupId) return;
        setIsSubmittingOptionForm(true);
        const formData: ModifierOptionFormData = {
            name_es: values.name_es,
            name_en: values.name_en || null,
            priceAdjustment: values.priceAdjustment,
            position: values.position,
            isDefault: values.isDefault,
            isAvailable: values.isAvailable,
        };
        let success = false;
        if (editingOption) {
            const result = await updateModifierOption(editingOption.id, formData);
            if (result) success = true;
        } else {
            const result = await addModifierOption(formData);
            if (result) success = true;
        }
        if (success) {
            setShowOptionForm(false);
            setEditingOption(null);
            form.reset();
        }
        setIsSubmittingOptionForm(false);
    };

    const handleDeleteOption = async (optionId: string) => {
        setIsDeletingOptionId(optionId);
        await deleteModifierOption(optionId); // El hook maneja la notificaci√≥n
        setIsDeletingOptionId(null);
    };

    const handleToggleOptionAvailable = async (option: ModifierOptionData) => {
        setIsTogglingStatusOptionId(option.id);
        const newStatus = !option.isAvailable;
        try {
            await updateModifierOption(option.id, { isAvailable: newStatus });
        } catch (error) {
            console.error(`Error toggling availability for option ${option.id}:`, error);
        } finally {
            setIsTogglingStatusOptionId(null);
        }
    };


    const optionRows = modifierOptions.map((option) => {
        const optionDisplayName = (currentLanguage === 'es' && option.name_es) ? option.name_es : (option.name_en || option.name_es || t('common.nameNotAvailable'));
        const isLoadingThisStatus = isTogglingStatusOptionId === option.id;
        const isLoadingThisDelete = isDeletingOptionId === option.id;
        const disableActionsGeneral = isSubmittingOptionForm || !!isDeletingOptionId || !!isTogglingStatusOptionId;
        const optionAvailabilityText = option.isAvailable ? t('adminCamarero.modifierOption.statusAvailable') : t('adminCamarero.modifierOption.statusNotAvailable');
        const tooltipToggleAvailable = option.isAvailable ? t('adminCamarero.modifierOption.tooltipMarkNotAvailable') : t('adminCamarero.modifierOption.tooltipMarkAvailable');

        return (
            <Table.Tr key={option.id}>
                <Table.Td>
                    <Text fw={500}>{optionDisplayName}</Text>
                    {optionDisplayName !== option.name_es && option.name_es && <Text size="xs" c="dimmed">ES: {option.name_es}</Text>}
                    {optionDisplayName !== option.name_en && option.name_en && <Text size="xs" c="dimmed">EN: {option.name_en}</Text>}
                </Table.Td>
                <Table.Td ta="right">
                    {option.priceAdjustment.toLocaleString(undefined, { style: 'currency', currency: 'EUR' })}
                </Table.Td>
                <Table.Td>{option.position}</Table.Td>
                <Table.Td>{option.isDefault ? t('common.yes') : t('common.no')}</Table.Td>
                <Table.Td>
                    <Badge color={option.isAvailable ? 'green' : 'gray'} variant="light">
                        {optionAvailabilityText}
                    </Badge>
                </Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        <Tooltip label={t('adminCamarero.modifierOption.tooltipEditOption')} withArrow>
                            <ActionIcon variant="subtle" color="blue"
                                onClick={() => handleOpenEditOptionForm(option)}
                                disabled={disableActionsGeneral || isLoadingThisStatus || isLoadingThisDelete}
                            >
                                <IconPencil size={16} />
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={tooltipToggleAvailable} withArrow>
                            <ActionIcon
                                variant="subtle"
                                color={option.isAvailable ? "orange" : "teal"}
                                onClick={() => handleToggleOptionAvailable(option)}
                                loading={isLoadingThisStatus}
                                disabled={disableActionsGeneral || isLoadingThisDelete || (isTogglingStatusOptionId !== null && isTogglingStatusOptionId !== option.id)}
                            >
                                {option.isAvailable ? <IconPlayerStop size={16} /> : <IconPlayerPlay size={16} />}
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={t('adminCamarero.modifierOption.tooltipDeleteOption')} withArrow>
                            <ActionIcon variant="subtle" color="red"
                                onClick={() => handleDeleteOption(option.id)}
                                loading={isLoadingThisDelete}
                                disabled={disableActionsGeneral || isLoadingThisStatus || (isDeletingOptionId !== null && isDeletingOptionId !== option.id)}
                            >
                                <IconTrash size={16} />
                            </ActionIcon>
                        </Tooltip>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    return (
        <Modal
            opened={opened && !!modifierGroupId}
            onClose={onClose}
            title={t('adminCamarero.modifierOptionsModal.title', { groupName: modifierGroupName })}
            size="lg"
            centered
            scrollAreaComponent={NativeScrollArea}
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            <Stack gap="lg">
                {!showOptionForm ? (
                    <>
                        <Group justify="space-between">
                            <Title order={5}>{t('adminCamarero.modifierOptionsModal.existingOptionsTitle')}</Title>
                            <Button leftSection={<IconPlus size={16} />} onClick={handleOpenAddOptionForm} disabled={loadingOptions}>
                                {t('adminCamarero.modifierOptionsModal.createNewOptionButton')}
                            </Button>
                        </Group>

                        {loadingOptions && <Group justify="center" mt="md"><Loader /></Group>}
                        {errorOptions && !loadingOptions && <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{errorOptions}</Alert>}
                        {!loadingOptions && !errorOptions && modifierOptions.length === 0 && <Text c="dimmed" ta="center" mt="md">{t('adminCamarero.modifierOptionsModal.noOptionsForGroup')}</Text>}
                        {!loadingOptions && !errorOptions && modifierOptions.length > 0 && (
                            <Table.ScrollContainer minWidth={500}>
                                <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                                    <Table.Thead>
                                        <Table.Tr>
                                            <Table.Th>{t('adminCamarero.modifierOptionsModal.tableHeaderName')}</Table.Th>
                                            <Table.Th ta="right">{t('adminCamarero.modifierOptionsModal.tableHeaderPriceAdjustment')}</Table.Th>
                                            <Table.Th>{t('adminCamarero.modifierOptionsModal.tableHeaderPosition')}</Table.Th>
                                            <Table.Th>{t('adminCamarero.modifierOptionsModal.tableHeaderDefault')}</Table.Th>
                                            <Table.Th>{t('adminCamarero.modifierOptionsModal.tableHeaderAvailable')}</Table.Th>
                                            <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                                        </Table.Tr>
                                    </Table.Thead>
                                    <Table.Tbody>{optionRows}</Table.Tbody>
                                </Table>
                            </Table.ScrollContainer>
                        )}
                    </>
                ) : (
                    <Paper withBorder p="md" radius="md">
                        <Title order={5} mb="md">{editingOption ? t('adminCamarero.modifierOptionsModal.formEditTitle', { optionName: (currentLanguage === 'es' && editingOption.name_es) ? editingOption.name_es : (editingOption.name_en || editingOption.name_es || '') }) : t('adminCamarero.modifierOptionsModal.formCreateTitle')}</Title>
                        <form onSubmit={form.onSubmit(handleOptionFormSubmit)}>
                            <Stack gap="sm">
                                <TextInput label={t('adminCamarero.modifierOptionForm.nameEsLabel')} required {...form.getInputProps('name_es')} disabled={isSubmittingOptionForm} />
                                <TextInput label={t('adminCamarero.modifierOptionForm.nameEnLabel')} {...form.getInputProps('name_en')} disabled={isSubmittingOptionForm} />
                                <NumberInput
                                    label={t('adminCamarero.modifierOptionForm.priceAdjustmentLabel')}
                                    description={t('adminCamarero.modifierOptionForm.priceAdjustmentDescription')}
                                    decimalScale={2}
                                    fixedDecimalScale
                                    step={0.10}
                                    leftSection={<IconCurrencyEuro size={16} />}
                                    {...form.getInputProps('priceAdjustment')}
                                    disabled={isSubmittingOptionForm}
                                />
                                <NumberInput
                                    label={t('adminCamarero.modifierOptionForm.positionLabel')}
                                    min={0}
                                    step={1}
                                    allowDecimal={false}
                                    {...form.getInputProps('position')}
                                    disabled={isSubmittingOptionForm}
                                />
                                <Switch label={t('adminCamarero.modifierOptionForm.isDefaultLabel')} {...form.getInputProps('isDefault', { type: 'checkbox' })} disabled={isSubmittingOptionForm} />
                                <Switch label={t('adminCamarero.modifierOptionForm.isAvailableLabel')} {...form.getInputProps('isAvailable', { type: 'checkbox' })} disabled={isSubmittingOptionForm} />

                                <Group justify="flex-end" mt="md">
                                    <Button variant="default" onClick={() => { setShowOptionForm(false); setEditingOption(null); form.reset(); }} disabled={isSubmittingOptionForm}>
                                        {t('common.cancel')}
                                    </Button>
                                    <Button type="submit" loading={isSubmittingOptionForm} leftSection={<IconDeviceFloppy size={16} />}>
                                        {editingOption ? t('common.saveChanges') : t('adminCamarero.modifierOptionsModal.formCreateButton')}
                                    </Button>
                                </Group>
                            </Stack>
                        </form>
                    </Paper>
                )}
                 <Divider mt="lg" />
                <Group justify="flex-end" mt="md">
                    <Button variant="outline" onClick={onClose}>{t('adminCamarero.modifierOptionsModal.closeButton')}</Button>
                </Group>
            </Stack>
        </Modal>
    );
};

export default ModifierOptionsManagementModal;


// ====== [54] frontend/src/modules/camarero/components/public/menu/CategoryAccordion.tsx ======
// frontend/src/components/public/menu/CategoryAccordion.tsx
// Version: 1.0.1 (Fix itemDetails access and use initialQuantity)

import React from 'react';
import { Accordion, Group, Image, Stack, Title, Text } from '@mantine/core';
import { IconChevronDown } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import {
    PublicMenuCategory,
    PublicMenuItem,
    ModifierUiType
} from '../../../types/menu.types';
import MenuItemCard, { MenuItemCardConfiguringState } from './MenuItemCard';

interface CategoryAccordionProps {
    categories: PublicMenuCategory[];
    activeAccordionItems: string[];
    onAccordionChange: (value: string[]) => void;
    
    // NUEVA PROP: ID del √≠tem que se est√° configurando actualmente
    configuringItemId: string | null; 
    configuringItemState: MenuItemCardConfiguringState | null;
    
    onStartConfigureItem: (item: PublicMenuItem) => void;
    onCancelConfiguration: () => void;
    onConfigQuantityChange: (newQuantity: number) => void;
    onConfigModifierSelectionChange: (groupId: string, newSelection: string | string[], groupUiType: ModifierUiType) => void;
    onConfigNotesChange: (newNotes: string) => void;
    onConfigAddToCart: () => void;
    onSimpleAddToCart: (item: PublicMenuItem, quantity: number) => void;
}

const CategoryAccordion: React.FC<CategoryAccordionProps> = ({
    categories,
    activeAccordionItems,
    onAccordionChange,
    configuringItemId, // <<< NUEVA PROP
    configuringItemState,
    onStartConfigureItem,
    onCancelConfiguration,
    onConfigQuantityChange,
    onConfigModifierSelectionChange,
    onConfigNotesChange,
    onConfigAddToCart,
    onSimpleAddToCart,
}) => {
    const { t, i18n } = useTranslation();

    if (!categories || categories.length === 0) {
        return <Text c="dimmed" ta="center">{t('publicMenu.noCategories', 'No hay categor√≠as de men√∫ disponibles.')}</Text>;
    }

    return (
        <Accordion
            variant="separated"
            chevron={<IconChevronDown />}
            multiple
            value={activeAccordionItems}
            onChange={onAccordionChange}
        >
            {categories.map((category: PublicMenuCategory) => (
                <Accordion.Item key={category.id} value={category.id}>
                    <Accordion.Control>
                        <Group wrap="nowrap">
                            {category.imageUrl && (
                                <Image src={category.imageUrl} alt={(i18n.language === 'es' && category.name_es) ? category.name_es : (category.name_en || category.name_es || '')} w={60} h={60} fit="cover" radius="sm" />
                            )}
                            <Stack gap={0}>
                                <Title order={4}>
                                    {i18n.language === 'es' && category.name_es ? category.name_es : category.name_en || category.name_es || t('publicMenu.unnamedCategory', 'Categor√≠a sin nombre')}
                                </Title>
                                {(category.description_es && i18n.language === 'es') && <Text size="sm" c="dimmed" lineClamp={1}>{category.description_es}</Text>}
                                {(category.description_en && i18n.language === 'en') && <Text size="sm" c="dimmed" lineClamp={1}>{category.description_en}</Text>}
                            </Stack>
                        </Group>
                    </Accordion.Control>
                    <Accordion.Panel>
                        {category.items.length > 0 ? (
                            <Stack gap="md" pt="md">
                                {category.items.map((item: PublicMenuItem) => {
                                    // CORRECCI√ìN: Usar configuringItemId para determinar si se est√° configurando este √≠tem
                                    const isConfiguringThisItem = configuringItemId === item.id;
                                    const itemConfigForCard = isConfiguringThisItem ? configuringItemState : null;
                                    
                                    // Usar la cantidad del estado de configuraci√≥n si este √≠tem se est√° configurando, sino 1
                                    const quantityForCard = isConfiguringThisItem && itemConfigForCard ? itemConfigForCard.quantity : 1;

                                    return (
                                        <MenuItemCard
                                            key={item.id}
                                            item={item}
                                            isConfiguringThisItem={isConfiguringThisItem}
                                            currentConfig={itemConfigForCard ? { // Asegurarse de pasar todos los campos de MenuItemCardConfiguringState
                                                quantity: quantityForCard,
                                                selectedOptionsByGroup: itemConfigForCard.selectedOptionsByGroup,
                                                currentUnitPrice: itemConfigForCard.currentUnitPrice,
                                                itemNotes: itemConfigForCard.itemNotes,
                                                areModifiersValid: itemConfigForCard.areModifiersValid,
                                            } : null}
                                            onStartConfigure={() => onStartConfigureItem(item)}
                                            onCancelConfiguration={onCancelConfiguration}
                                            // Asegurarse que los callbacks para actualizar la config se pasan correctamente
                                            onQuantityChange={onConfigQuantityChange}
                                            onModifierSelectionChange={onConfigModifierSelectionChange}
                                            onNotesChange={onConfigNotesChange}
                                            onAddToCart={isConfiguringThisItem ? onConfigAddToCart : () => {
                                                const quantityInput = document.getElementById(`quantity-${item.id}`) as HTMLInputElement;
                                                const quantity = quantityInput ? parseInt(quantityInput.value, 10) : 1;
                                                onSimpleAddToCart(item, quantity >= 1 ? quantity : 1);
                                            }}
                                        />
                                    );
                                })}
                            </Stack>
                        ) : (
                            <Text c="dimmed">{t('publicMenu.noItemsInCategory', 'No hay √≠tems en esta categor√≠a.')}</Text>
                        )}
                    </Accordion.Panel>
                </Accordion.Item>
            ))}
        </Accordion>
    );
};

export default CategoryAccordion;


// ====== [55] frontend/src/modules/camarero/components/public/menu/MenuItemCard.tsx ======
// frontend/src/components/public/menu/MenuItemCard.tsx
// Version: 1.0.4 (Correct i18n key path for allergens and tags)

import React, { useState, useEffect } from 'react';
import {
    Paper, Title, Text, Stack, Group, Badge, Box, Image,
    NumberInput, Button as MantineButton, TextInput as MantineTextInput
} from '@mantine/core';
import { IconShoppingCartPlus, IconNotes, IconListDetails } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import {
    PublicMenuItem,
    ModifierUiType,
    PublicMenuModifierGroup,
} from '../../../types/menu.types';
import ModifierGroupInteractiveRenderer from './ModifierGroupInteractiveRenderer';

export interface MenuItemCardConfiguringState {
    quantity: number;
    selectedOptionsByGroup: Record<string, string[] | string>;
    currentUnitPrice: number;
    itemNotes: string;
    areModifiersValid: boolean;
}

interface MenuItemCardProps {
    item: PublicMenuItem;
    isConfiguringThisItem: boolean;
    currentConfig: MenuItemCardConfiguringState | null;
    onStartConfigure: () => void;
    onCancelConfiguration: () => void;
    onQuantityChange: (newQuantity: number) => void;
    onModifierSelectionChange: (groupId: string, newSelection: string | string[], groupUiType: ModifierUiType) => void;
    onNotesChange: (newNotes: string) => void;
    onAddToCart: (quantityIfSimple?: number) => void;
}

const MenuItemCard: React.FC<MenuItemCardProps> = ({
    item,
    isConfiguringThisItem,
    currentConfig,
    onStartConfigure,
    onCancelConfiguration,
    onQuantityChange,
    onModifierSelectionChange,
    onNotesChange,
    onAddToCart,
}) => {
    const { t, i18n } = useTranslation();
    const [simpleQuantity, setSimpleQuantity] = useState<number>(1);

    useEffect(() => {
        if (!isConfiguringThisItem) {
            setSimpleQuantity(1);
        }
    }, [isConfiguringThisItem]);

    const displayPrice = isConfiguringThisItem && currentConfig ? currentConfig.currentUnitPrice : item.price;
    const displayQuantity = isConfiguringThisItem && currentConfig ? currentConfig.quantity : simpleQuantity;
    
    let mainButtonText: string;
    let mainButtonAction: () => void;
    let mainButtonDisabled = false;

    if (isConfiguringThisItem && currentConfig) {
        mainButtonAction = () => onAddToCart();
        mainButtonText = t('publicMenu.confirmAndAddToCart');
        mainButtonDisabled = !currentConfig.areModifiersValid;
    } else if (item.modifierGroups && item.modifierGroups.length > 0) {
        mainButtonAction = onStartConfigure;
        mainButtonText = t('publicMenu.customizeAndAdd');
    } else {
        mainButtonAction = () => onAddToCart(simpleQuantity);
        mainButtonText = t('publicMenu.addToCart');
    }

    const handleNumberInputChange = (value: number | string) => {
        const newQty = Number(value) < 1 ? 1 : Number(value);
        if (isConfiguringThisItem) {
            onQuantityChange(newQty);
        } else {
            setSimpleQuantity(newQty);
        }
    };

    return (
        <Paper p="md" radius="sm" withBorder>
            <Group wrap="nowrap" align="flex-start" gap="md">
                {item.imageUrl && (
                    <Image src={item.imageUrl} alt={(i18n.language === 'es' && item.name_es) ? item.name_es : (item.name_en || item.name_es || '')} w={100} h={100} fit="cover" radius="sm" />
                )}
                <Stack gap="xs" style={{ flexGrow: 1 }}>
                    <Title order={5}>
                        {i18n.language === 'es' && item.name_es ? item.name_es : item.name_en || item.name_es || t('publicMenu.unnamedItem')}
                    </Title>
                    <Text c="blue.7" fw={700} fz="lg">
                        {displayPrice.toLocaleString(i18n.language, { style: 'currency', currency: 'EUR' })}
                    </Text>
                    {(item.description_es && i18n.language === 'es') && <Text size="sm" c="dimmed" lineClamp={3}>{item.description_es}</Text>}
                    {(item.description_en && i18n.language === 'en') && <Text size="sm" c="dimmed" lineClamp={3}>{item.description_en}</Text>}

                    {!isConfiguringThisItem && item.modifierGroups && item.modifierGroups.length > 0 && (
                        <MantineButton 
                            variant="subtle" 
                            size="xs" 
                            onClick={onStartConfigure}
                            leftSection={<IconListDetails size={14}/>}
                            mt="xs"
                        >
                            {t('publicMenu.customizeButton')}
                        </MantineButton>
                    )}

                    {isConfiguringThisItem && currentConfig && item.modifierGroups && item.modifierGroups.length > 0 && (
                        <Box mt="sm" pl="xs">
                            <Title order={6} c="dimmed" tt="uppercase" fz="xs" mb="xs">{t('publicMenu.optionsTitle')}</Title>
                            {item.modifierGroups.map((group: PublicMenuModifierGroup) => (
                                <ModifierGroupInteractiveRenderer
                                    key={group.id}
                                    group={group}
                                    selectedOptionsForThisGroup={currentConfig.selectedOptionsByGroup[group.id] || (group.uiType === ModifierUiType.RADIO ? '' : [])}
                                    onSelectionChange={(newSelection) => onModifierSelectionChange(group.id, newSelection, group.uiType)}
                                />
                            ))}
                            <MantineTextInput
                                label={t('publicMenu.itemNotesLabel')}
                                placeholder={t('publicMenu.itemNotesPlaceholder')}
                                value={currentConfig.itemNotes}
                                onChange={(event) => onNotesChange(event.currentTarget.value)}
                                mt="sm"
                                rightSection={<IconNotes size={16} />}
                            />
                        </Box>
                    )}
                    
                    {/* ---------- CORRECCI√ìN AQU√ç ---------- */}
                    {(item.allergens.length > 0 || item.tags.length > 0) && (
                        <Group gap="xs" mt="sm">
                            {item.allergens.map(allergen => (
                                <Badge key={allergen} variant="outline" color="orange" size="xs">
                                    {t(`adminCamarero.menuItem.allergen.${allergen}`, allergen)} {/* <--- A√±adido adminCamarero. */}
                                </Badge>
                            ))}
                            {item.tags.map(tag => (
                                <Badge key={tag} variant="light" color="grape" size="xs">
                                    {t(`adminCamarero.menuItem.tag.${tag}`, tag)} {/* <--- A√±adido adminCamarero. */}
                                </Badge>
                            ))}
                        </Group>
                    )}
                    {/* ---------- FIN CORRECCI√ìN ---------- */}


                    <Group mt="md" justify="flex-end" align="flex-end">
                        <NumberInput
                            label={t('publicMenu.quantity')}
                            value={displayQuantity}
                            onChange={handleNumberInputChange}
                            min={1} max={20} step={1} size="xs"
                            style={{ width: '100px' }}
                            readOnly={!isConfiguringThisItem && !!(item.modifierGroups && item.modifierGroups.length > 0)}
                        />
                        <MantineButton 
                            onClick={mainButtonAction}
                            leftSection={<IconShoppingCartPlus size={16} />}
                            size="sm"
                            variant="filled"
                            disabled={mainButtonDisabled}
                        >
                            {mainButtonText}
                        </MantineButton>
                        {isConfiguringThisItem && (
                            <MantineButton variant="subtle" size="sm" onClick={onCancelConfiguration}>
                                {t('common.cancel')}
                            </MantineButton>
                        )}
                    </Group>
                </Stack>
            </Group>
        </Paper>
    );
};

export default MenuItemCard;


// ====== [56] frontend/src/modules/camarero/components/public/menu/ModifierGroupInteractiveRenderer.tsx ======
// frontend/src/components/public/menu/ModifierGroupInteractiveRenderer.tsx
// Version: 1.0.1 (Corrected imports)

import React from 'react';
import { 
    Stack, Text, Radio, Checkbox, 
    Box // <--- A√ëADIDO Box
} from '@mantine/core';
// Group, Badge, ThemeIcon, IconPoint eliminados de las importaciones ya que no se usan aqu√≠
import { useTranslation } from 'react-i18next';
import { PublicMenuModifierGroup, PublicMenuModifierOption, ModifierUiType } from '../../../types/menu.types';

interface ModifierGroupInteractiveRendererProps {
    group: PublicMenuModifierGroup;
    selectedOptionsForThisGroup: string | string[]; 
    onSelectionChange: (newSelection: string | string[]) => void;
}

const ModifierGroupInteractiveRenderer: React.FC<ModifierGroupInteractiveRendererProps> = ({
    group,
    selectedOptionsForThisGroup,
    onSelectionChange,
}) => {
    const { t, i18n } = useTranslation();

    const getModifierGroupSelectionText = (grp: PublicMenuModifierGroup): string => {
        const { isRequired, uiType, minSelections, maxSelections } = grp;
        if (isRequired) {
            if (uiType === ModifierUiType.RADIO) { return t('publicMenu.modifier.chooseOneRequired', 'Elige 1 (obligatorio)'); }
            if (minSelections === 1 && maxSelections === 1) { return t('publicMenu.modifier.chooseOneRequired', 'Elige 1 (obligatorio)');}
            if (minSelections === 1 && maxSelections > 1) { return t('publicMenu.modifier.chooseAtLeastOneUpToMax', { max: maxSelections, context: 'required' }); }
            if (minSelections > 0 && maxSelections >= minSelections) { return t('publicMenu.modifier.chooseMinUpToMax', { min: minSelections, max: maxSelections, context: 'required' }); }
        } else { 
            if (uiType === ModifierUiType.RADIO && maxSelections === 1) { return t('publicMenu.modifier.chooseOneOptional', 'Elige 1 (opcional)'); }
            if (maxSelections > 0) { return t('publicMenu.modifier.chooseUpToMaxOptional', { max: maxSelections }); }
        }
        return t('publicMenu.modifier.chooseOptional', 'Opcional');
    };
    
    const renderOptionLabel = (option: PublicMenuModifierOption) => (
        <>
            {i18n.language === 'es' && option.name_es ? option.name_es : option.name_en || option.name_es}
            {option.priceAdjustment !== 0 && (
                <Text span c={option.priceAdjustment > 0 ? "teal.7" : "pink.7"} ml={5} fz="xs">
                    ({option.priceAdjustment > 0 ? '+' : ''}{option.priceAdjustment.toFixed(2)}‚Ç¨)
                </Text>
            )}
        </>
    );

    return (
        <Box key={group.id} mb="md" pl="sm" style={{borderLeft: `2px solid var(--mantine-color-gray-3)`, marginLeft:'4px'}}>
            <Text size="sm" fw={500}>
                {i18n.language === 'es' && group.name_es ? group.name_es : group.name_en || group.name_es}
                {group.isRequired && <Text span c="red.7" ml={4} fw={700}>*</Text>}
            </Text>
            <Text size="xs" c="dimmed" mb={4}>
                {getModifierGroupSelectionText(group)}
            </Text>
            <Stack gap="xs" mt={4}>
                {group.uiType === ModifierUiType.RADIO && (
                    <Radio.Group
                        value={selectedOptionsForThisGroup as string || ''}
                        onChange={(value) => onSelectionChange(value)}
                        name={`radio-group-${group.id}`}
                    >
                        <Stack gap="xs">
                            {group.options.map((option: PublicMenuModifierOption) => (
                                <Radio 
                                    key={option.id} 
                                    value={option.id}
                                    label={renderOptionLabel(option)} 
                                />
                            ))}
                        </Stack>
                    </Radio.Group>
                )}
                {group.uiType === ModifierUiType.CHECKBOX && (
                    <Checkbox.Group
                        value={selectedOptionsForThisGroup as string[] || []}
                        onChange={(values) => onSelectionChange(values)}
                    >
                         <Stack gap="xs">
                            {group.options.map((option: PublicMenuModifierOption) => (
                                <Checkbox
                                    key={option.id}
                                    value={option.id}
                                    label={renderOptionLabel(option)}
                                />
                            ))}
                        </Stack>
                    </Checkbox.Group>
                )}
            </Stack>
        </Box>
    );
};

export default ModifierGroupInteractiveRenderer;


// ====== [57] frontend/src/modules/camarero/components/public/menu/ShoppingCartModal.tsx ======
// frontend/src/components/public/menu/ShoppingCartModal.tsx
// Version: 0.1.4 (Add new props for "add to existing order" context)

import React from 'react';
import {
    Modal,
    Text,
    Stack,
    Group,
    Button,
    Divider,
    ScrollArea,
    Box,
    NumberInput,
    ActionIcon,
    Textarea,
    Paper,
    Tooltip,
} from '@mantine/core';
import { useTranslation } from 'react-i18next';
import {
    IconTrash,
    IconSend,
    IconCirclePlus,
    IconCircleMinus,
    IconShoppingCartOff
} from '@tabler/icons-react';

// Interfaz OrderItemFE (debe coincidir con la de PublicMenuViewPage o importarse de un tipo com√∫n)
interface OrderItemFE {
    cartItemId: string;
    menuItemName_es: string | null;
    menuItemName_en: string | null;
    quantity: number;
    currentPricePerUnit: number;
    totalPriceForItem: number;
    notes?: string | null;
    selectedModifiers: { 
        modifierOptionId: string;
        name_es?: string | null;
        name_en?: string | null;
        priceAdjustment: number;
        modifierGroupName_es?: string | null;
        modifierGroupName_en?: string | null;
    }[];
}

interface ShoppingCartModalProps {
    opened: boolean;
    onClose: () => void;
    orderItems: OrderItemFE[];
    orderNotes: string;
    onUpdateItemQuantity: (cartItemId: string, newQuantity: number) => void;
    onRemoveItem: (cartItemId: string) => void;
    onUpdateOrderNotes: (notes: string) => void;
    onSubmitOrder: () => Promise<void>;
    isSubmittingOrder: boolean;
    onClearCart: () => void;
    // --- NUEVAS PROPS A√ëADIDAS ---
    isAddingToExistingOrder?: boolean; 
    activeOrderNumber?: string | null;
}

const ShoppingCartModal: React.FC<ShoppingCartModalProps> = ({
    opened,
    onClose,
    orderItems,
    orderNotes,
    onUpdateItemQuantity,
    onRemoveItem,
    onUpdateOrderNotes,
    onSubmitOrder,
    isSubmittingOrder,
    onClearCart,
    // --- RECIBIR NUEVAS PROPS ---
    isAddingToExistingOrder,
    activeOrderNumber,
}) => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;

    const calculateSubtotal = () => {
        return orderItems.reduce((acc, item) => acc + item.totalPriceForItem, 0);
    };

    const subtotal = calculateSubtotal();
    const totalOrderAmount = subtotal;

    const handleQuantityChange = (cartItemId: string, value: number | string) => {
        const newQuantity = Number(value);
        onUpdateItemQuantity(cartItemId, Math.max(1, newQuantity));
    };

    // Determinar el t√≠tulo del modal y el texto del bot√≥n de env√≠o
    const modalTitle = isAddingToExistingOrder 
        ? t('publicMenu.cart.titleAddToOrder', { orderNumber: activeOrderNumber || '' })
        : t('publicMenu.cart.title', 'Tu Pedido');
    
    const submitButtonText = isAddingToExistingOrder
        ? t('publicMenu.cart.submitAddToOrder', 'A√±adir al Pedido')
        : t('publicMenu.cart.submitOrder', 'Enviar Pedido');


    return (
        <Modal
            opened={opened}
            onClose={onClose}
            title={modalTitle} // <-- T√≠tulo din√°mico
            size="lg"
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
            scrollAreaComponent={ScrollArea.Autosize}
            centered
        >
            <Stack gap="md">
                {orderItems.length > 0 && (
                    <Group justify="flex-end">
                        <Button
                            variant="outline"
                            color="red"
                            size="xs"
                            leftSection={<IconShoppingCartOff size={14} />}
                            onClick={onClearCart}
                            disabled={isSubmittingOrder}
                        >
                            {t('publicMenu.cart.clearCartButton', 'Vaciar Carrito')}
                        </Button>
                    </Group>
                )}

                {orderItems.length === 0 ? (
                    <Text c="dimmed" ta="center" py="xl">
                        {isAddingToExistingOrder 
                            ? t('publicMenu.cart.emptyAddToOrder', 'Selecciona √≠tems para a√±adir a tu pedido.')
                            : t('publicMenu.cart.empty', 'Tu carrito de pedido est√° vac√≠o.')
                        }
                    </Text>
                ) : (
                    <ScrollArea.Autosize mah="40vh">
                        <Stack gap="md">
                            {orderItems.map((item) => {
                                const itemNameForLabel = (currentLanguage === 'es' && item.menuItemName_es ? item.menuItemName_es : item.menuItemName_en || item.menuItemName_es) || t('publicMenu.unnamedItem');
                                return (
                                <Paper key={item.cartItemId} p="sm" withBorder radius="sm">
                                    <Group justify="space-between" align="flex-start">
                                        <Box style={{ flex: 1 }}>
                                            <Text fw={500}>
                                                {itemNameForLabel}
                                            </Text>
                                            {item.selectedModifiers && item.selectedModifiers.length > 0 && (
                                                <Box ml="xs" mt={2}>
                                                    {item.selectedModifiers.map(mod => (
                                                        <Text key={mod.modifierOptionId} size="xs" c="dimmed">
                                                            + {(currentLanguage === 'es' && mod.name_es ? mod.name_es : mod.name_en || mod.name_es) || t('publicMenu.unnamedModifier')}
                                                            {mod.priceAdjustment !== 0 && ` (${mod.priceAdjustment > 0 ? '+' : ''}${mod.priceAdjustment.toFixed(2)}‚Ç¨)`}
                                                        </Text>
                                                    ))}
                                                </Box>
                                            )}
                                            {item.notes && (
                                                <Text size="xs" c="dimmed" fs="italic" mt={2}>
                                                    {t('publicMenu.cart.itemNotesLabel', 'Notas:')} {item.notes}
                                                </Text>
                                            )}
                                        </Box>
                                        <Stack align="flex-end" gap={4}>
                                            <Text fw={500} size="sm">
                                                {item.totalPriceForItem.toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}
                                            </Text>
                                            <Group gap="xs" wrap="nowrap">
                                                <ActionIcon 
                                                    variant="default" 
                                                    size="sm" 
                                                    onClick={() => handleQuantityChange(item.cartItemId, item.quantity - 1)} 
                                                    disabled={item.quantity <= 1 || isSubmittingOrder}
                                                    aria-label={t('publicMenu.cart.decreaseQuantity', { itemName: itemNameForLabel })}
                                                >
                                                    <IconCircleMinus size={16} />
                                                </ActionIcon>
                                                <NumberInput
                                                    value={item.quantity}
                                                    onChange={(val) => handleQuantityChange(item.cartItemId, val)}
                                                    min={1}
                                                    max={20}
                                                    step={1}
                                                    hideControls
                                                    disabled={isSubmittingOrder}
                                                    styles={{ input: { width: '40px', textAlign: 'center', paddingLeft: '0', paddingRight: '0'} }}
                                                    aria-label={t('publicMenu.cart.itemQuantity', { itemName: itemNameForLabel })}
                                                />
                                                <ActionIcon 
                                                    variant="default" 
                                                    size="sm" 
                                                    onClick={() => handleQuantityChange(item.cartItemId, item.quantity + 1)} 
                                                    disabled={isSubmittingOrder}
                                                    aria-label={t('publicMenu.cart.increaseQuantity', { itemName: itemNameForLabel })}
                                                >
                                                    <IconCirclePlus size={16} />
                                                </ActionIcon>
                                                <Tooltip label={t('publicMenu.cart.removeItem', 'Eliminar √≠tem')} withArrow>
                                                    <Box> 
                                                        <ActionIcon 
                                                            color="red" 
                                                            variant="light" 
                                                            onClick={() => onRemoveItem(item.cartItemId)} 
                                                            disabled={isSubmittingOrder}
                                                            aria-label={t('publicMenu.cart.removeItemFromOrder', { itemName: itemNameForLabel })}
                                                        >
                                                            <IconTrash size={16} />
                                                        </ActionIcon>
                                                    </Box>
                                                </Tooltip>
                                            </Group>
                                        </Stack>
                                    </Group>
                                </Paper>
                            )})}
                        </Stack>
                    </ScrollArea.Autosize>
                )}

                <Divider my="sm" />

                <Textarea
                    label={t('publicMenu.cart.orderNotesLabel', 'Notas para el Pedido (Opcional)')}
                    placeholder={t('publicMenu.cart.orderNotesPlaceholder', 'Ej: Alergias generales, preferencia de entrega...')}
                    value={orderNotes}
                    onChange={(event) => onUpdateOrderNotes(event.currentTarget.value)}
                    minRows={2}
                    disabled={isSubmittingOrder}
                />

                <Divider my="sm" />

                <Group justify="space-between">
                    <Text fw={700} size="lg">
                        {isAddingToExistingOrder 
                            ? t('publicMenu.cart.totalAddItems', 'Total a A√±adir:')
                            : t('publicMenu.cart.totalOrder', 'Total del Pedido:')
                        }
                    </Text>
                    <Text fw={700} size="lg">
                        {totalOrderAmount.toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}
                    </Text>
                </Group>

                <Group justify="flex-end" mt="xl">
                    <Button variant="default" onClick={onClose} disabled={isSubmittingOrder}>
                        {t('publicMenu.cart.continueShopping', 'Seguir Pidiendo')}
                    </Button>
                    <Button
                        onClick={onSubmitOrder}
                        loading={isSubmittingOrder}
                        disabled={orderItems.length === 0}
                        leftSection={<IconSend size={16} />}
                        color="green"
                    >
                        {submitButtonText} {/* <-- Texto din√°mico del bot√≥n */}
                    </Button>
                </Group>
            </Stack>
        </Modal>
    );
};

export default ShoppingCartModal;


// ====== [58] frontend/src/modules/camarero/hooks/useActiveOrderState.ts ======
// frontend/src/hooks/useActiveOrderState.ts
import { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { OrderStatus as PageOrderStatus, PublicOrderStatusInfo as PagePublicOrderStatusInfo } from '../pages/OrderStatusPage'; // Aseg√∫rate que la ruta es correcta

// Importar tipo ActiveOrderInfo
interface ActiveOrderInfo {
    orderId: string;
    orderNumber: string;
    businessSlug: string;
    tableIdentifier?: string;
    savedAt: number; // timestamp de cuando se guard√≥
}

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL_PUBLIC || 'http://localhost:3000/public';
const ACTIVE_ORDER_INFO_KEY_PREFIX = 'loyalpyme_active_order_info_';

export interface UseActiveOrderStateReturn {
    activeOrderId: string | null;
    activeOrderNumber: string | null;
    canCurrentlyAddToExistingOrder: boolean;
    loadingActiveOrderStatus: boolean;
    checkActiveOrderStatus: () => Promise<void>; // Para una comprobaci√≥n manual si es necesario
    clearActiveOrder: () => void;
    setActiveOrderManually: (orderId: string, orderNumber: string) => void; // Para cuando se crea un nuevo pedido
}

export const useActiveOrderState = (businessSlug: string | undefined, tableIdentifier: string | undefined): UseActiveOrderStateReturn => {
    const activeOrderKey = businessSlug ? `${ACTIVE_ORDER_INFO_KEY_PREFIX}${businessSlug}${tableIdentifier ? `_${tableIdentifier}` : ''}` : null;

    const [activeOrderId, setActiveOrderId] = useState<string | null>(null);
    const [activeOrderNumber, setActiveOrderNumber] = useState<string | null>(null);
    const [canCurrentlyAddToExistingOrder, setCanCurrentlyAddToExistingOrder] = useState<boolean>(false);
    const [loadingActiveOrderStatus, setLoadingActiveOrderStatus] = useState<boolean>(true); // Inicia en true

    const canAddMoreItemsToOrderStatus = useCallback((status: PageOrderStatus | undefined): boolean => {
        if (!status) return false;
        return [
            PageOrderStatus.RECEIVED, PageOrderStatus.IN_PROGRESS, PageOrderStatus.PARTIALLY_READY,
            PageOrderStatus.ALL_ITEMS_READY, PageOrderStatus.COMPLETED
        ].includes(status);
    }, []);

    const checkActiveOrderStatus = useCallback(async (currentOrderId?: string, currentOrderNumber?: string) => {
        const orderIdToCheck = currentOrderId || activeOrderId;
        const orderNumberToCheck = currentOrderNumber || activeOrderNumber;

        if (!orderIdToCheck || !orderNumberToCheck) {
            setCanCurrentlyAddToExistingOrder(false);
            setLoadingActiveOrderStatus(false);
            return;
        }

        setLoadingActiveOrderStatus(true);
        try {
            const response = await axios.get<PagePublicOrderStatusInfo>(`${API_BASE_URL}/order/${orderIdToCheck}/status`);
            if (response.data && canAddMoreItemsToOrderStatus(response.data.orderStatus)) {
                setCanCurrentlyAddToExistingOrder(true);
                // Reafirmar el estado si la comprobaci√≥n fue exitosa, en caso de que currentOrderId viniera de localStorage y a√∫n no estuviera en el estado
                setActiveOrderId(orderIdToCheck);
                setActiveOrderNumber(orderNumberToCheck);
            } else {
                setCanCurrentlyAddToExistingOrder(false);
                if (activeOrderKey) localStorage.removeItem(activeOrderKey);
                setActiveOrderId(null);
                setActiveOrderNumber(null);
            }
        } catch (error) {
            console.error(`[useActiveOrderState] Error checking status for order ${orderIdToCheck}:`, error);
            setCanCurrentlyAddToExistingOrder(false);
            if (activeOrderKey) localStorage.removeItem(activeOrderKey);
            setActiveOrderId(null);
            setActiveOrderNumber(null);
        } finally {
            setLoadingActiveOrderStatus(false);
        }
    }, [activeOrderId, activeOrderNumber, activeOrderKey, canAddMoreItemsToOrderStatus]);


    useEffect(() => {
        // console.log(`[useActiveOrderState] useEffect triggered. activeOrderKey: ${activeOrderKey}`);
        if (activeOrderKey) {
            const storedActiveOrderInfo = localStorage.getItem(activeOrderKey);
            if (storedActiveOrderInfo) {
                try {
                    const parsedInfo: ActiveOrderInfo = JSON.parse(storedActiveOrderInfo);
                    if (parsedInfo.orderId && parsedInfo.orderNumber) {
                        // console.log(`[useActiveOrderState] Found active order in localStorage: ${parsedInfo.orderId}`);
                        setActiveOrderId(parsedInfo.orderId);
                        setActiveOrderNumber(parsedInfo.orderNumber);
                        checkActiveOrderStatus(parsedInfo.orderId, parsedInfo.orderNumber);
                    } else {
                        // console.log(`[useActiveOrderState] Invalid info in localStorage for key ${activeOrderKey}, removing.`);
                        localStorage.removeItem(activeOrderKey);
                        setActiveOrderId(null); setActiveOrderNumber(null); setCanCurrentlyAddToExistingOrder(false);
                        setLoadingActiveOrderStatus(false);
                    }
                } catch (e) {
                    // console.error(`[useActiveOrderState] Error parsing localStorage for key ${activeOrderKey}:`, e);
                    localStorage.removeItem(activeOrderKey);
                    setActiveOrderId(null); setActiveOrderNumber(null); setCanCurrentlyAddToExistingOrder(false);
                    setLoadingActiveOrderStatus(false);
                }
            } else {
                // console.log(`[useActiveOrderState] No active order info in localStorage for key ${activeOrderKey}.`);
                setActiveOrderId(null); setActiveOrderNumber(null); setCanCurrentlyAddToExistingOrder(false);
                setLoadingActiveOrderStatus(false);
            }
        } else {
            // console.log(`[useActiveOrderState] activeOrderKey is null.`);
            setActiveOrderId(null); setActiveOrderNumber(null); setCanCurrentlyAddToExistingOrder(false);
            setLoadingActiveOrderStatus(false);
        }
    }, [activeOrderKey, checkActiveOrderStatus]); // Ejecutar solo cuando activeOrderKey cambia

    const clearActiveOrder = useCallback(() => {
        if (activeOrderKey) {
            localStorage.removeItem(activeOrderKey);
        }
        setActiveOrderId(null);
        setActiveOrderNumber(null);
        setCanCurrentlyAddToExistingOrder(false);
        // console.log(`[useActiveOrderState] Active order cleared.`);
    }, [activeOrderKey]);

    const setActiveOrderManually = useCallback((orderId: string, orderNumber: string) => {
        if (activeOrderKey && businessSlug) {
            const activeOrderData: ActiveOrderInfo = { orderId, orderNumber, businessSlug, tableIdentifier, savedAt: Date.now() };
            localStorage.setItem(activeOrderKey, JSON.stringify(activeOrderData));
            setActiveOrderId(orderId);
            setActiveOrderNumber(orderNumber);
            setCanCurrentlyAddToExistingOrder(true); // Asumimos que un nuevo pedido puede tener √≠tems a√±adidos
            // console.log(`[useActiveOrderState] Active order set manually: ${orderId}`);
        }
    }, [activeOrderKey, businessSlug, tableIdentifier]);


    return {
        activeOrderId,
        activeOrderNumber,
        canCurrentlyAddToExistingOrder,
        loadingActiveOrderStatus,
        checkActiveOrderStatus: () => checkActiveOrderStatus(), // Envolver para que no requiera params
        clearActiveOrder,
        setActiveOrderManually,
    };
};


// ====== [59] frontend/src/modules/camarero/hooks/useAdminMenuCategories.ts ======
// Nuevo archivo: frontend/src/hooks/useAdminMenuCategories.ts

import { useState, useCallback, useEffect } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
import { MenuCategoryData, MenuCategoryFormData } from '../types/menu.types'; // Importar nuestros nuevos tipos

const API_ENDPOINT = '/camarero/admin/menu/categories'; // Endpoint base para categor√≠as

export interface UseAdminMenuCategoriesReturn {
    categories: MenuCategoryData[];
    loading: boolean;
    error: string | null;
    fetchCategories: () => Promise<void>;
    addCategory: (data: MenuCategoryFormData) => Promise<MenuCategoryData | null>;
    updateCategory: (id: string, data: Partial<MenuCategoryFormData>) => Promise<MenuCategoryData | null>;
    deleteCategory: (id: string) => Promise<boolean>;
    // Podr√≠amos a√±adir aqu√≠ funciones para reordenar si fuera necesario
}

export const useAdminMenuCategories = (): UseAdminMenuCategoriesReturn => {
    const { t } = useTranslation();
    const [categories, setCategories] = useState<MenuCategoryData[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);

    const fetchCategories = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
            const response = await axiosInstance.get<MenuCategoryData[]>(API_ENDPOINT);
            // El backend ya deber√≠a devolverlas ordenadas por 'position'
            setCategories(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            setError(msg);
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
        } finally {
            setLoading(false);
        }
    }, [t]);

    useEffect(() => {
        fetchCategories();
    }, [fetchCategories]);

    const addCategory = async (data: MenuCategoryFormData): Promise<MenuCategoryData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.post<MenuCategoryData>(API_ENDPOINT, data);
            notifications.show({
                title: t('adminCommon.createSuccess'),
                message: t('adminCamarero.manageMenu.categoryCreateSuccess', { name: response.data.name_es }), // Necesitaremos esta clave i18n
                color: 'green',
            });
            await fetchCategories(); // Refrescar la lista
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.createError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false); // Asegurar que loading se desactiva en error
            return null;
        }
    };

    const updateCategory = async (id: string, data: Partial<MenuCategoryFormData>): Promise<MenuCategoryData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.put<MenuCategoryData>(`${API_ENDPOINT}/${id}`, data);
            notifications.show({
                title: t('adminCommon.updateSuccess'),
                message: t('adminCamarero.manageMenu.categoryUpdateSuccess', { name: response.data.name_es }), // Necesitaremos esta clave i18n
                color: 'green',
            });
            await fetchCategories(); // Refrescar
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.updateError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        }
    };

    const deleteCategory = async (id: string): Promise<boolean> => {
        setLoading(true);
        try {
            await axiosInstance.delete(`${API_ENDPOINT}/${id}`);
            notifications.show({
                title: t('adminCommon.deleteSuccess'),
                message: t('adminCamarero.manageMenu.categoryDeleteSuccess'), // Necesitaremos esta clave i18n
                color: 'green',
            });
            await fetchCategories(); // Refrescar
            return true;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.deleteError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return false;
        }
    };

    return {
        categories,
        loading,
        error,
        fetchCategories,
        addCategory,
        updateCategory,
        deleteCategory,
    };
};


// ====== [60] frontend/src/modules/camarero/hooks/useAdminMenuItems.ts ======
// frontend/src/hooks/useAdminMenuItems.ts
import { useState, useCallback, useEffect } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
import { MenuItemData, MenuItemFormData } from '../types/menu.types';

const ITEMS_API_BASE = `/camarero/admin/menu/items`;
const CATEGORY_ITEMS_API_BASE = (categoryId: string) => `/camarero/admin/menu/categories/${categoryId}/items`;

export interface UseAdminMenuItemsReturn {
    items: MenuItemData[];
    loading: boolean;
    error: string | null;
    fetchItems: () => Promise<void>;
    addItem: (data: MenuItemFormData) => Promise<MenuItemData | null>;
    updateItem: (itemId: string, data: Partial<MenuItemFormData>) => Promise<MenuItemData | null>;
    deleteItem: (itemId: string) => Promise<boolean>;
}

export const useAdminMenuItems = (categoryId: string | null): UseAdminMenuItemsReturn => {
    const { t } = useTranslation();
    const [items, setItems] = useState<MenuItemData[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    const fetchItems = useCallback(async () => {
        if (!categoryId) {
            setItems([]);
            setLoading(false);
            return;
        }
        setLoading(true);
        setError(null);
        try {
            const response = await axiosInstance.get<MenuItemData[]>(CATEGORY_ITEMS_API_BASE(categoryId));
            setItems(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            setError(msg);
            // No mostrar notificaci√≥n aqu√≠ directamente
        } finally {
            setLoading(false);
        }
    }, [categoryId, t]);

    useEffect(() => {
        if (categoryId) {
            fetchItems();
        } else {
            setItems([]);
        }
    }, [categoryId, fetchItems]);

    const addItem = async (data: MenuItemFormData): Promise<MenuItemData | null> => {
        if (!categoryId) {
            notifications.show({
                title: t('common.error'),
                message: t('adminCamarero.menuItemHook.errorNoCategoryForItem'),
                color: 'red'
            });
            return null;
        }
        setLoading(true);
        try {
            const response = await axiosInstance.post<MenuItemData>(CATEGORY_ITEMS_API_BASE(categoryId), data);
            notifications.show({
                title: t('adminCommon.createSuccess'),
                message: t('adminCamarero.manageMenu.itemCreateSuccess', { name: response.data.name_es || t('adminCamarero.manageMenu.itemFallbackName') }),
                color: 'green',
            });
            fetchItems();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.createError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            // Asegurar que loading se desactive si no se hizo ya
            if (loading) setLoading(false);
        }
    };

    const updateItem = async (itemId: string, data: Partial<MenuItemFormData>): Promise<MenuItemData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.put<MenuItemData>(`${ITEMS_API_BASE}/${itemId}`, data);
            notifications.show({
                title: t('adminCommon.updateSuccess'),
                message: t('adminCamarero.manageMenu.itemUpdateSuccess', { name: response.data.name_es || t('adminCamarero.manageMenu.itemFallbackName') }),
                color: 'green',
            });
            fetchItems();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.updateError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const deleteItem = async (itemId: string): Promise<boolean> => {
        setLoading(true);
        try {
            await axiosInstance.delete(`${ITEMS_API_BASE}/${itemId}`);
            notifications.show({
                title: t('adminCommon.deleteSuccess'),
                message: t('adminCamarero.manageMenu.itemDeleteSuccess'),
                color: 'green',
            });
            fetchItems();
            return true;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.deleteError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return false;
        } finally {
            if (loading) setLoading(false);
        }
    };

    return {
        items,
        loading,
        error,
        fetchItems,
        addItem,
        updateItem,
        deleteItem,
    };
};


// ====== [61] frontend/src/modules/camarero/hooks/useAdminModifierGroups.ts ======
// frontend/src/hooks/useAdminModifierGroups.ts
import { useState, useCallback, useEffect } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
import { ModifierGroupData, ModifierGroupFormData } from '../types/menu.types';

const getGroupsApiEndpoint = (menuItemId: string) => `/camarero/admin/menu/items/${menuItemId}/modifier-groups`;
const groupApiEndpoint = (modifierGroupId: string) => `/camarero/admin/modifier-groups/${modifierGroupId}`;

export interface UseAdminModifierGroupsReturn {
    modifierGroups: ModifierGroupData[];
    loading: boolean;
    error: string | null;
    fetchModifierGroups: () => Promise<void>;
    addModifierGroup: (data: ModifierGroupFormData) => Promise<ModifierGroupData | null>;
    updateModifierGroup: (groupId: string, data: Partial<ModifierGroupFormData>) => Promise<ModifierGroupData | null>;
    deleteModifierGroup: (groupId: string) => Promise<boolean>;
}

export const useAdminModifierGroups = (menuItemId: string | null): UseAdminModifierGroupsReturn => {
    const { t } = useTranslation();
    const [modifierGroups, setModifierGroups] = useState<ModifierGroupData[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    const fetchModifierGroups = useCallback(async () => {
        if (!menuItemId) {
            setModifierGroups([]);
            setLoading(false);
            return;
        }
        setLoading(true);
        setError(null);
        console.log(`[useAdminModifierGroups] Fetching groups for menuItemId: ${menuItemId}`);
        try {
            const response = await axiosInstance.get<ModifierGroupData[]>(getGroupsApiEndpoint(menuItemId));
            setModifierGroups(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            setError(msg);
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
        } finally {
            setLoading(false);
        }
    }, [menuItemId, t]);

    useEffect(() => {
        fetchModifierGroups();
    }, [fetchModifierGroups]);

    const addModifierGroup = async (data: ModifierGroupFormData): Promise<ModifierGroupData | null> => {
        if (!menuItemId) {
            notifications.show({
                title: t('common.error'),
                message: t('adminCamarero.modifierGroupHook.errorNoMenuItemForGroup'), // Nueva clave
                color: 'red'
            });
            return null;
        }
        setLoading(true);
        try {
            const response = await axiosInstance.post<ModifierGroupData>(getGroupsApiEndpoint(menuItemId), data);
            notifications.show({
                title: t('adminCommon.createSuccess'),
                message: t('adminCamarero.manageMenu.modifierGroupCreateSuccess', { name: response.data.name_es || t('adminCamarero.modifierGroupHook.fallbackGroupName') }), // Nueva clave para fallback
                color: 'green',
            });
            await fetchModifierGroups();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.createError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const updateModifierGroup = async (groupId: string, data: Partial<ModifierGroupFormData>): Promise<ModifierGroupData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.put<ModifierGroupData>(groupApiEndpoint(groupId), data);
            notifications.show({
                title: t('adminCommon.updateSuccess'),
                message: t('adminCamarero.manageMenu.modifierGroupUpdateSuccess', { name: response.data.name_es || t('adminCamarero.modifierGroupHook.fallbackGroupName') }),
                color: 'green',
            });
            await fetchModifierGroups();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.updateError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const deleteModifierGroup = async (groupId: string): Promise<boolean> => {
        setLoading(true);
        try {
            await axiosInstance.delete(groupApiEndpoint(groupId));
            notifications.show({
                title: t('adminCommon.deleteSuccess'),
                message: t('adminCamarero.manageMenu.modifierGroupDeleteSuccess'),
                color: 'green',
            });
            await fetchModifierGroups();
            return true;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.deleteError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return false;
        } finally {
            if (loading) setLoading(false);
        }
    };

    return {
        modifierGroups,
        loading,
        error,
        fetchModifierGroups,
        addModifierGroup,
        updateModifierGroup,
        deleteModifierGroup,
    };
};


// ====== [62] frontend/src/modules/camarero/hooks/useAdminModifierOptions.ts ======
// frontend/src/hooks/useAdminModifierOptions.ts
import { useState, useCallback, useEffect } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next'; // Importar useTranslation
import { ModifierOptionData, ModifierOptionFormData } from '../types/menu.types';

const getOptionsApiEndpoint = (modifierGroupId: string) => `/camarero/admin/modifier-groups/${modifierGroupId}/options`;
const optionApiEndpoint = (modifierOptionId: string) => `/camarero/admin/modifier-options/${modifierOptionId}`;

export interface UseAdminModifierOptionsReturn {
    modifierOptions: ModifierOptionData[];
    loading: boolean;
    error: string | null;
    fetchModifierOptions: () => Promise<void>;
    addModifierOption: (data: ModifierOptionFormData) => Promise<ModifierOptionData | null>;
    updateModifierOption: (optionId: string, data: Partial<ModifierOptionFormData>) => Promise<ModifierOptionData | null>;
    deleteModifierOption: (optionId: string) => Promise<boolean>;
}

export const useAdminModifierOptions = (modifierGroupId: string | null): UseAdminModifierOptionsReturn => {
    const { t } = useTranslation(); // Inicializar hook
    const [modifierOptions, setModifierOptions] = useState<ModifierOptionData[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    const fetchModifierOptions = useCallback(async () => {
        if (!modifierGroupId) {
            setModifierOptions([]);
            setLoading(false);
            return;
        }
        setLoading(true);
        setError(null);
        console.log(`[useAdminModifierOptions] Fetching options for modifierGroupId: ${modifierGroupId}`);
        try {
            const response = await axiosInstance.get<ModifierOptionData[]>(getOptionsApiEndpoint(modifierGroupId));
            setModifierOptions(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCamarero.modifierOptionHook.errorLoadingOptions'); // Usar clave
            setError(msg);
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
        } finally {
            setLoading(false);
        }
    }, [modifierGroupId, t]); // A√±adir t como dependencia

    useEffect(() => {
        if (modifierGroupId) {
            fetchModifierOptions();
        } else {
            setModifierOptions([]);
        }
    }, [modifierGroupId, fetchModifierOptions]);

    const addModifierOption = async (data: ModifierOptionFormData): Promise<ModifierOptionData | null> => {
        if (!modifierGroupId) {
            notifications.show({
                title: t('common.error'),
                message: t('adminCamarero.modifierOptionHook.errorNoGroupForOption'), // Usar clave
                color: 'red'
            });
            return null;
        }
        setLoading(true);
        try {
            const response = await axiosInstance.post<ModifierOptionData>(getOptionsApiEndpoint(modifierGroupId), data);
            notifications.show({
                title: t('common.success'),
                message: t('adminCamarero.modifierOptionHook.createSuccess', { optionName: response.data.name_es || t('adminCamarero.modifierOptionHook.fallbackOptionName') }), // Usar clave
                color: 'green',
            });
            await fetchModifierOptions();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCamarero.modifierOptionHook.errorCreatingOption'); // Usar clave
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const updateModifierOption = async (optionId: string, data: Partial<ModifierOptionFormData>): Promise<ModifierOptionData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.put<ModifierOptionData>(optionApiEndpoint(optionId), data);
            notifications.show({
                title: t('common.success'),
                message: t('adminCamarero.modifierOptionHook.updateSuccess', { optionName: response.data.name_es || t('adminCamarero.modifierOptionHook.fallbackOptionName') }), // Usar clave
                color: 'green',
            });
            await fetchModifierOptions();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCamarero.modifierOptionHook.errorUpdatingOption'); // Usar clave
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const deleteModifierOption = async (optionId: string): Promise<boolean> => {
        setLoading(true);
        try {
            await axiosInstance.delete(optionApiEndpoint(optionId));
            notifications.show({
                title: t('common.success'),
                message: t('adminCamarero.modifierOptionHook.deleteSuccess'), // Usar clave
                color: 'green',
            });
            await fetchModifierOptions();
            return true;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCamarero.modifierOptionHook.errorDeletingOption'); // Usar clave
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return false;
        } finally {
            if (loading) setLoading(false);
        }
    };

    return {
        modifierOptions,
        loading,
        error,
        fetchModifierOptions,
        addModifierOption,
        updateModifierOption,
        deleteModifierOption,
    };
};


// ====== [63] frontend/src/modules/camarero/hooks/useMenuItemConfigurator.ts ======
// frontend/src/hooks/useMenuItemConfigurator.ts
import { useState, useEffect, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import {
    PublicMenuItem,
    ModifierUiType,
} from '../types/menu.types';
import { ConfiguringItemState } from '../types/publicOrder.types';

const getTranslatedNameHelper = (item: { name_es?: string | null, name_en?: string | null }, lang: string, defaultName: string = 'Unnamed') => {
    if (lang === 'es' && item.name_es) return item.name_es;
    if (lang === 'en' && item.name_en) return item.name_en;
    return item.name_es || item.name_en || defaultName;
};

export interface UseMenuItemConfiguratorReturn {
    configuringItem: ConfiguringItemState | null;
    startConfiguringItem: (item: PublicMenuItem) => void;
    cancelConfiguration: () => void;
    updateConfigQuantity: (newQuantity: number) => void;
    updateConfigModifierSelection: (groupId: string, newSelection: string | string[], groupUiType: ModifierUiType) => void;
    updateConfigNotes: (newNotes: string) => void;
}

export const useMenuItemConfigurator = (): UseMenuItemConfiguratorReturn => {
    const { i18n } = useTranslation();
    const currentLang = i18n.language;
    const [configuringItem, setConfiguringItem] = useState<ConfiguringItemState | null>(null);

    const calculatePriceAndValidate = useCallback((itemDetails: PublicMenuItem, selectedOptions: Record<string, string[] | string>): { newPrice: number; isValid: boolean } => {
        let newPrice = itemDetails.price;
        let isValid = true;
        const itemNameForLog = getTranslatedNameHelper(itemDetails, currentLang, "Item Desconocido");

        if (Array.isArray(itemDetails.modifierGroups)) {
            for (const group of itemDetails.modifierGroups) {
                const groupNameForLog = getTranslatedNameHelper(group, currentLang, "Grupo Desconocido");
                const selections = selectedOptions[group.id];
                let count = 0;
                let currentSelectionsForGroup: string[] = [];

                if (Array.isArray(selections)) {
                    currentSelectionsForGroup = selections.filter(s => s && s.trim() !== '');
                    count = currentSelectionsForGroup.length;
                } else if (typeof selections === 'string' && selections.trim() !== '') {
                    currentSelectionsForGroup = [selections.trim()];
                    count = 1;
                }

                if (group.isRequired && count < group.minSelections) isValid = false;
                if (count > group.maxSelections) isValid = false;
                if (group.uiType === ModifierUiType.RADIO && count > 1) isValid = false;
                
                if(Array.isArray(group.options)) {
                    currentSelectionsForGroup.forEach(optionId => {
                        const option = group.options.find(opt => opt.id === optionId);
                        if (option) {
                            newPrice += option.priceAdjustment;
                        } else {
                            console.warn(`[useMenuItemConfigurator] Option ID "${optionId}" not found in group "${groupNameForLog}" for item "${itemNameForLog}".`);
                        }
                    });
                }
            }
        }
        return { newPrice, isValid };
    }, [currentLang]);

    useEffect(() => {
        if (configuringItem) {
            const { newPrice, isValid } = calculatePriceAndValidate(configuringItem.itemDetails, configuringItem.selectedOptionsByGroup);
            if (newPrice !== configuringItem.currentUnitPrice || isValid !== configuringItem.areModifiersValid) {
                setConfiguringItem(prev => prev ? { ...prev, currentUnitPrice: newPrice, areModifiersValid: isValid } : null);
            }
        }
    }, [configuringItem, calculatePriceAndValidate, currentLang]);

    const startConfiguringItem = useCallback((item: PublicMenuItem) => {
        const initialSelectedOptions: Record<string, string[] | string> = {};
        if (Array.isArray(item.modifierGroups)) {
            item.modifierGroups.forEach(group => {
                const optionsAvailable = Array.isArray(group.options) ? group.options : [];
                const defaultOptions = optionsAvailable.filter(opt => opt.isDefault && opt.isAvailable);

                if (group.uiType === ModifierUiType.RADIO) {
                    let defaultRadioOptionId = '';
                    if (defaultOptions.length > 0) {
                        defaultRadioOptionId = defaultOptions[0].id;
                    } else if (optionsAvailable.length > 0 && group.isRequired && group.minSelections === 1) {
                        const firstAvailableOption = optionsAvailable.find(opt => opt.isAvailable);
                        if (firstAvailableOption) defaultRadioOptionId = firstAvailableOption.id;
                    }
                    initialSelectedOptions[group.id] = defaultRadioOptionId;
                } else {
                    initialSelectedOptions[group.id] = defaultOptions.map(opt => opt.id);
                }
            });
        }
        const {newPrice, isValid} = calculatePriceAndValidate(item, initialSelectedOptions);
        setConfiguringItem({
            itemDetails: item,
            quantity: 1,
            selectedOptionsByGroup: initialSelectedOptions,
            currentUnitPrice: newPrice,
            itemNotes: '',
            areModifiersValid: isValid
        });
    }, [calculatePriceAndValidate, currentLang]);

    const cancelConfiguration = useCallback(() => setConfiguringItem(null), []);
    const updateConfigQuantity = useCallback((newQuantity: number) => setConfiguringItem(prev => prev ? { ...prev, quantity: newQuantity } : null), []);

    const updateConfigModifierSelection = useCallback((groupId: string, newSelection: string | string[]) => {
        setConfiguringItem(prev => {
            if (!prev) return null;
            return {
                ...prev,
                selectedOptionsByGroup: {
                    ...prev.selectedOptionsByGroup,
                    [groupId]: newSelection
                }
            };
        });
    }, []);
    
    const updateConfigNotes = useCallback((newNotes: string) => setConfiguringItem(prev => prev ? { ...prev, itemNotes: newNotes } : null), []);

    return {
        configuringItem,
        startConfiguringItem,
        cancelConfiguration,
        updateConfigQuantity,
        updateConfigModifierSelection,
        updateConfigNotes,
    };
};


// ====== [64] frontend/src/modules/camarero/hooks/usePublicMenuData.ts ======
// frontend/src/hooks/usePublicMenuData.ts
// Version 1.0.0 (Created to encapsulate menu fetching logic)

import { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { useTranslation } from 'react-i18next';
import { PublicDigitalMenuData } from '../types/menu.types';

const API_MENU_BASE_URL = import.meta.env.VITE_API_BASE_URL_PUBLIC || 'http://localhost:3000/public';

export interface UsePublicMenuDataReturn {
    menuData: PublicDigitalMenuData | null;
    loadingMenu: boolean;
    errorMenu: string | null;
    fetchMenu: () => void;
}

export const usePublicMenuData = (businessSlug: string | undefined): UsePublicMenuDataReturn => {
    const { t } = useTranslation();
    const [menuData, setMenuData] = useState<PublicDigitalMenuData | null>(null);
    const [loadingMenu, setLoadingMenu] = useState<boolean>(true);
    const [errorMenu, setErrorMenu] = useState<string | null>(null);

    const fetchMenu = useCallback(async () => {
        if (!businessSlug) {
            setErrorMenu(t('error.missingBusinessSlug'));
            setLoadingMenu(false);
            return;
        }
        setLoadingMenu(true);
        setErrorMenu(null);
        try {
            const response = await axios.get<PublicDigitalMenuData>(`${API_MENU_BASE_URL}/menu/business/${businessSlug}`);
            if (response.data) {
                // Parse prices from string to number, as Prisma Decimal can be serialized as string
                const parsedMenuData = {
                    ...response.data,
                    categories: response.data.categories.map(c => ({
                        ...c,
                        items: c.items.map(i => ({
                            ...i,
                            price: parseFloat(String(i.price)),
                            modifierGroups: Array.isArray(i.modifierGroups) ? i.modifierGroups.map(g => ({
                                ...g,
                                options: Array.isArray(g.options) ? g.options.map(o => ({ ...o, priceAdjustment: parseFloat(String(o.priceAdjustment)) })) : []
                            })) : []
                        }))
                    }))
                };
                setMenuData(parsedMenuData);
            } else {
                throw new Error(t('error.noMenuDataReceived'));
            }
        } catch (err: any) {
            setErrorMenu(err.response?.data?.message || err.message || t('common.errorUnknown'));
            setMenuData(null);
        } finally {
            setLoadingMenu(false);
        }
    }, [businessSlug, t]);

    useEffect(() => {
        fetchMenu();
    }, [fetchMenu]);

    return { menuData, loadingMenu, errorMenu, fetchMenu };
};


// ====== [65] frontend/src/modules/camarero/hooks/usePublicOrderCart.ts ======
// frontend/src/hooks/usePublicOrderCart.ts
import React, { useState, useEffect, useCallback } from 'react'; // <-- A√ëADIDO React
import { notifications, NotificationData } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
import { IconShoppingCartPlus, IconCheck } from '@tabler/icons-react';

import { OrderItemFE } from '../types/publicOrder.types';
import { PublicMenuItem } from '../types/menu.types';

const LOCAL_STORAGE_CART_KEY_PREFIX = 'loyalpyme_public_cart_';
const LOCAL_STORAGE_ORDER_NOTES_KEY_PREFIX = 'loyalpyme_public_order_notes_';

const getTranslatedNameHelper = (item: { name_es?: string | null, name_en?: string | null }, lang: string, defaultName: string = 'Unnamed') => {
    if (lang === 'es' && item.name_es) return item.name_es;
    if (lang === 'en' && item.name_en) return item.name_en;
    return item.name_es || item.name_en || defaultName;
};

export interface UsePublicOrderCartReturn {
    currentOrderItems: OrderItemFE[];
    orderNotes: string;
    totalCartItems: number;
    totalCartAmount: number;
    addItemToCart: (item: OrderItemFE) => void;
    addSimpleItemToCart: (menuItem: PublicMenuItem, quantity: number) => void;
    updateItemQuantityInCart: (cartItemId: string, newQuantity: number) => void;
    removeItemFromCart: (cartItemId: string) => void;
    updateOrderNotes: (notes: string) => void;
    clearCart: () => void;
    loadCartFromStorage: () => void;
    clearCartStorage: () => void;
}

export const usePublicOrderCart = (
    businessSlug: string | undefined,
    tableIdentifier: string | undefined,
    activeOrderId: string | null
): UsePublicOrderCartReturn => {
    const { t, i18n } = useTranslation();
    const currentLang = i18n.language;

    const cartStorageKey = `${LOCAL_STORAGE_CART_KEY_PREFIX}${businessSlug || 'default'}${tableIdentifier ? `_${tableIdentifier}` : ''}`;
    const notesStorageKey = `${LOCAL_STORAGE_ORDER_NOTES_KEY_PREFIX}${businessSlug || 'default'}${tableIdentifier ? `_${tableIdentifier}` : ''}`;

    const [currentOrderItemsState, setCurrentOrderItemsState] = useState<OrderItemFE[]>([]);
    const [orderNotesState, setOrderNotesState] = useState<string>('');

    const loadCartFromStorage = useCallback((): void => {
        if (activeOrderId) {
            setCurrentOrderItemsState([]);
            setOrderNotesState('');
            return;
        }
        const savedCart = localStorage.getItem(cartStorageKey);
        const savedNotes = localStorage.getItem(notesStorageKey);
        try {
            setCurrentOrderItemsState(savedCart ? JSON.parse(savedCart) : []);
        } catch (e) {
            console.error("Error parsing cart from localStorage", e);
            setCurrentOrderItemsState([]);
        }
        setOrderNotesState(savedNotes || '');
    }, [cartStorageKey, notesStorageKey, activeOrderId]);

    useEffect(() => {
        loadCartFromStorage();
    }, [loadCartFromStorage]);

    useEffect(() => {
        if (!activeOrderId) {
            localStorage.setItem(cartStorageKey, JSON.stringify(currentOrderItemsState));
        }
    }, [currentOrderItemsState, cartStorageKey, activeOrderId]);

    useEffect(() => {
        if (!activeOrderId) {
            localStorage.setItem(notesStorageKey, orderNotesState);
        }
    }, [orderNotesState, notesStorageKey, activeOrderId]);

    const addItemToCart = useCallback((newItem: OrderItemFE): void => {
        setCurrentOrderItemsState((prevItems: OrderItemFE[]) => {
            const existingItemIndex = prevItems.findIndex(item => item.cartItemId === newItem.cartItemId);
            if (existingItemIndex > -1) {
                const updatedItems = [...prevItems];
                const existing = updatedItems[existingItemIndex];
                existing.quantity += newItem.quantity;
                existing.totalPriceForItem = existing.currentPricePerUnit * existing.quantity;
                return updatedItems;
            } else {
                return [...prevItems, newItem];
            }
        });
        const itemName = getTranslatedNameHelper({name_es: newItem.menuItemName_es, name_en: newItem.menuItemName_en}, currentLang, t('publicMenu.unnamedItem'));
        
        const notificationData: NotificationData = {
            title: t('publicMenu.itemAddedTitle'),
            message: t('publicMenu.itemAddedMessage', { itemName: itemName, quantity: newItem.quantity }),
            color: 'green',
            icon: React.createElement(IconShoppingCartPlus, { size: 18 })
        };
        notifications.show(notificationData);
    }, [currentLang, t]);

    const addSimpleItemToCart = useCallback((menuItem: PublicMenuItem, quantity: number): void => {
        const cartItemId = menuItem.id;
        const itemName = getTranslatedNameHelper(menuItem, currentLang, t('publicMenu.unnamedItem'));
        
        setCurrentOrderItemsState((prevItems: OrderItemFE[]) => {
            const existingSimpleItemIndex = prevItems.findIndex(
                (ci: OrderItemFE) => ci.menuItemId === menuItem.id && 
                      (!ci.selectedModifiers || ci.selectedModifiers.length === 0) && 
                      !ci.notes
            );

            if (existingSimpleItemIndex > -1) {
                const updatedItems = [...prevItems];
                const existing = updatedItems[existingSimpleItemIndex];
                existing.quantity += quantity;
                existing.totalPriceForItem = existing.currentPricePerUnit * existing.quantity;
                return updatedItems;
            } else {
                const newCartItem: OrderItemFE = {
                    cartItemId: cartItemId,
                    menuItemId: menuItem.id,
                    menuItemName_es: menuItem.name_es,
                    menuItemName_en: menuItem.name_en,
                    quantity: quantity,
                    basePrice: menuItem.price,
                    currentPricePerUnit: menuItem.price,
                    totalPriceForItem: menuItem.price * quantity,
                    notes: undefined,
                    selectedModifiers: [],
                };
                return [...prevItems, newCartItem];
            }
        });
        
        const notificationData: NotificationData = {
            title: t('publicMenu.itemAddedTitle'),
            message: t('publicMenu.itemAddedMessage', { itemName: itemName, quantity: quantity }),
            color: 'green',
            icon: React.createElement(IconShoppingCartPlus, { size: 18 })
        };
        notifications.show(notificationData);
    }, [currentLang, t]);


    const updateItemQuantityInCart = useCallback((cartItemId: string, newQuantity: number): void => {
        setCurrentOrderItemsState((prevItems: OrderItemFE[]) =>
            prevItems.map((item: OrderItemFE) =>
                item.cartItemId === cartItemId
                    ? { ...item, quantity: newQuantity, totalPriceForItem: item.currentPricePerUnit * newQuantity }
                    : item
            ).filter((item: OrderItemFE) => item.quantity > 0)
        );
    }, []);

    const removeItemFromCart = useCallback((cartItemId: string): void => {
        setCurrentOrderItemsState((prevItems: OrderItemFE[]) => prevItems.filter((item: OrderItemFE) => item.cartItemId !== cartItemId));
    }, []);

    const updateOrderNotes = useCallback((notes: string): void => {
        setOrderNotesState(notes);
    }, []);

    const clearCart = useCallback((): void => {
        setCurrentOrderItemsState([]);
        setOrderNotesState('');
        
        const notificationData: NotificationData = {
            title: t('publicMenu.cart.clearedTitle'),
            message: t('publicMenu.cart.clearedMsg'),
            color: 'blue',
            icon: React.createElement(IconCheck, { size: 18 })
        };
        notifications.show(notificationData);
    }, [t]);

    const clearCartStorage = useCallback((): void => {
        localStorage.removeItem(cartStorageKey);
        localStorage.removeItem(notesStorageKey);
    }, [cartStorageKey, notesStorageKey]);

    const totalCartItems = currentOrderItemsState.reduce((sum: number, item: OrderItemFE) => sum + item.quantity, 0);
    const totalCartAmount = currentOrderItemsState.reduce((sum: number, item: OrderItemFE) => sum + item.totalPriceForItem, 0);

    // Devolver solo las funciones que se usan
    return {
        currentOrderItems: currentOrderItemsState,
        orderNotes: orderNotesState,
        totalCartItems, // Usado en PublicMenuViewPage
        totalCartAmount, // Usado en PublicMenuViewPage
        addItemToCart, // Usado en PublicMenuViewPage
        addSimpleItemToCart, // Usado en PublicMenuViewPage
        updateItemQuantityInCart, // Usado en ShoppingCartModal (pasado desde PublicMenuViewPage)
        removeItemFromCart, // Usado en ShoppingCartModal (pasado desde PublicMenuViewPage)
        updateOrderNotes, // Usado en ShoppingCartModal (pasado desde PublicMenuViewPage)
        clearCart, // Usado en ShoppingCartModal (pasado desde PublicMenuViewPage)
        loadCartFromStorage, // No se usa externamente, pero es parte de la l√≥gica interna del hook
        clearCartStorage, // Usado en PublicMenuViewPage
    };
};


// ====== [66] frontend/src/modules/camarero/hooks/useWaiterPickupItems.ts ======
// frontend/src/hooks/useWaiterPickupItems.ts
import { useState, useCallback, useEffect, useRef } from 'react';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
// IconCheck y IconX no se usar√°n temporalmente en las notificaciones para depurar
// import { IconCheck, IconX } from '@tabler/icons-react'; 

import { getReadyForPickupItems, markOrderItemAsServed } from '../services/waiterService';
import type { ReadyPickupItem } from '../types/camarero.types';

const POLLING_INTERVAL_MS = 15000;

export interface UseWaiterPickupItemsReturn {
    items: ReadyPickupItem[];
    isLoadingInitial: boolean;
    fetchError: string | null;
    markingItemId: string | null;
    fetchItems: (isInitialLoad?: boolean) => Promise<void>; // La declaraci√≥n es Promise<void>
    handleMarkAsServed: (orderItemId: string) => Promise<void>;
}

export const useWaiterPickupItems = (): UseWaiterPickupItemsReturn => {
    const { t, i18n } = useTranslation();
    const [items, setItems] = useState<ReadyPickupItem[]>([]);
    const [isLoadingInitial, setIsLoadingInitial] = useState<boolean>(true);
    const [fetchError, setFetchError] = useState<string | null>(null);
    const [markingItemId, setMarkingItemId] = useState<string | null>(null);

    const pollingTimeoutRef = useRef<number | null>(null);
    const isMountedRef = useRef<boolean>(true);

    // fetchItems: Obtiene los √≠tems listos del servidor.
    // La declaraci√≥n de retorno es Promise<void> porque es una funci√≥n async que no devuelve un valor expl√≠cito.
    const fetchItems = useCallback(async (isInitialLoad = false): Promise<void> => {
        if (isInitialLoad) {
            setIsLoadingInitial(true);
            setFetchError(null);
        }
        // console.log(`[useWaiterPickupItems] Fetching items. Initial: ${isInitialLoad}`);

        try {
            const fetchedItems = await getReadyForPickupItems();
            if (isMountedRef.current) {
                setItems(fetchedItems);
                if (fetchError && !isInitialLoad) { // Limpiar error si un fetch posterior es exitoso
                    setFetchError(null);
                }
            }
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            if (isMountedRef.current) {
                setFetchError(msg);
                // console.error("[useWaiterPickupItems] Error fetching items:", msg);
            }
        } finally {
            if (isMountedRef.current && isInitialLoad) {
                setIsLoadingInitial(false);
            }
        }
    }, [t, fetchError]); // Dependencias: t, fetchError

    // Efecto para la carga inicial y limpieza al desmontar
    useEffect(() => {
        isMountedRef.current = true;
        fetchItems(true); // Carga inicial
        return () => {
            isMountedRef.current = false;
            if (pollingTimeoutRef.current) {
                clearTimeout(pollingTimeoutRef.current);
            }
        };
    }, [fetchItems]); // Solo depende de fetchItems para la carga inicial

    // Efecto para el polling
    useEffect(() => {
        if (pollingTimeoutRef.current) {
            clearTimeout(pollingTimeoutRef.current);
        }
        // Condiciones para activar el polling
        if (!isLoadingInitial && !fetchError && !markingItemId && isMountedRef.current) {
            pollingTimeoutRef.current = window.setTimeout(() => {
                // console.log(`[useWaiterPickupItems] Polling for new items...`);
                fetchItems(false);
            }, POLLING_INTERVAL_MS);
        }
        // Funci√≥n de limpieza para este efecto espec√≠fico (se ejecuta si las dependencias cambian o al desmontar)
        return () => {
            if (pollingTimeoutRef.current) {
                clearTimeout(pollingTimeoutRef.current);
            }
        };
    }, [items, isLoadingInitial, fetchError, markingItemId, fetchItems]); // Dependencias que reinician el polling

    // handleMarkAsServed: Marca un √≠tem como servido
    const handleMarkAsServed = async (orderItemId: string): Promise<void> => {
        if (markingItemId) { // Prevenir acciones concurrentes
            notifications.show({
                title: t('common.info'),
                message: t('waiterInterface.actionInProgress', 'Por favor, espera a que la acci√≥n actual termine.'),
                color: 'yellow',
            });
            return;
        }

        setMarkingItemId(orderItemId);

        const itemToMark = items.find(it => it.orderItemId === orderItemId);
        const itemNameForNotification =
            (i18n.language === 'es' && itemToMark?.itemNameSnapshot_es)
                ? itemToMark.itemNameSnapshot_es
                : (itemToMark?.itemNameSnapshot_en || itemToMark?.itemNameSnapshot_es || t('common.item', '√çtem'));

        try {
            await markOrderItemAsServed(orderItemId); // Llamada al servicio

            if (isMountedRef.current) {
                notifications.show({ // Notificaci√≥n SIN icono temporalmente
                    title: t('common.success'),
                    message: t('waiterInterface.itemMarkedServedSuccess', { itemName: itemNameForNotification }),
                    color: 'green',
                    // icon: <IconCheck size={18} />, // TEMPORALMENTE COMENTADO
                });
                fetchItems(); // Refrescar la lista para mostrar los cambios
            }
        } catch (err: any) {
            const errorMsg = err.response?.data?.message || err.message || t('waiterInterface.errorMarkingServed', 'Error al marcar el √≠tem como servido.');
            if (isMountedRef.current) {
                notifications.show({ // Notificaci√≥n SIN icono temporalmente
                    title: t('common.error'),
                    message: errorMsg,
                    color: 'red',
                    // icon: <IconX size={18} />, // TEMPORALMENTE COMENTADO
                });
                // console.error(`[useWaiterPickupItems] Error marking item ${orderItemId} as served:`, err);
            }
        } finally {
            if (isMountedRef.current) {
                setMarkingItemId(null);
            }
        }
    };

    return {
        items,
        isLoadingInitial,
        fetchError,
        markingItemId,
        fetchItems,
        handleMarkAsServed,
    };
};


// ====== [67] frontend/src/modules/camarero/pages/OrderStatusPage.tsx ======
// frontend/src/pages/OrderStatusPage.tsx
// Version 1.1.2 (Fix TypeError on items[0] after requesting bill by refetching)

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useParams, useLocation, Link, useNavigate } from 'react-router-dom';
import axios from 'axios';
import {
    Container, Title, Text, Loader, Alert, Paper, Stack, Group,
    Button, Divider, Badge, List, ThemeIcon, Box
} from '@mantine/core';
import {
    IconAlertCircle, IconClipboardList, IconToolsKitchen, IconChefHat,
    IconCircleCheck, IconCircleX, IconReload, IconArrowLeft, IconShoppingCart,
    IconPlus,
    IconCreditCard
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { notifications } from '@mantine/notifications';

// Tipos para el estado del pedido
export enum OrderItemStatus {
    PENDING_KDS = 'PENDING_KDS', PREPARING = 'PREPARING', READY = 'READY',
    SERVED = 'SERVED', CANCELLED = 'CANCELLED', CANCELLATION_REQUESTED = 'CANCELLATION_REQUESTED',
}
export enum OrderStatus {
    RECEIVED = 'RECEIVED', IN_PROGRESS = 'IN_PROGRESS', PARTIALLY_READY = 'PARTIALLY_READY',
    ALL_ITEMS_READY = 'ALL_ITEMS_READY', COMPLETED = 'COMPLETED', PENDING_PAYMENT = 'PENDING_PAYMENT',
    PAID = 'PAID', CANCELLED = 'CANCELLED', PAYMENT_FAILED = 'PAYMENT_FAILED',
}
export interface PublicOrderItemStatusInfo {
    id: string; menuItemName_es: string | null; menuItemName_en: string | null;
    quantity: number; status: OrderItemStatus;
}
export interface PublicOrderStatusInfo {
    orderId: string; orderNumber: string; orderStatus: OrderStatus;
    items: PublicOrderItemStatusInfo[]; tableIdentifier?: string | null;
    orderNotes?: string | null; createdAt: string;
    isBillRequested?: boolean;
}

const API_BASE_URL_PUBLIC = import.meta.env.VITE_API_BASE_URL_PUBLIC || 'http://localhost:3000/public';
const POLLING_INTERVAL = 10000;
const ACTIVE_ORDER_INFO_KEY_PREFIX = 'loyalpyme_active_order_info_';
const LOCAL_STORAGE_CART_KEY_PREFIX = 'loyalpyme_public_cart_';
const LOCAL_STORAGE_ORDER_NOTES_KEY_PREFIX = 'loyalpyme_public_order_notes_';

const OrderStatusPage: React.FC = () => {
    const { t, i18n } = useTranslation();
    const { orderId, tableIdentifier: tableIdFromParams } = useParams<{ orderId: string; tableIdentifier?: string }>();
    const location = useLocation();
    const navigate = useNavigate();

    const navigationState = location.state as { orderNumber?: string; businessSlug?: string, tableIdentifier?: string } | null;
    const displayOrderNumber = navigationState?.orderNumber || orderId;
    const businessSlugForReturn = navigationState?.businessSlug;
    const currentTableIdentifierForReturn = navigationState?.tableIdentifier || tableIdFromParams || undefined;

    const [orderStatusData, setOrderStatusData] = useState<PublicOrderStatusInfo | null>(null);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const pollingTimeoutRef = useRef<number | null>(null);
    const [isRequestingBill, setIsRequestingBill] = useState<boolean>(false);

    const activeOrderKey = businessSlugForReturn ? `${ACTIVE_ORDER_INFO_KEY_PREFIX}${businessSlugForReturn}${currentTableIdentifierForReturn ? `_${currentTableIdentifierForReturn}` : ''}` : null;

    const isOrderConsideredFinalOrPendingPayment = (status: OrderStatus | undefined): boolean => {
        if (!status) return false;
        return [
            OrderStatus.PAID,
            OrderStatus.CANCELLED,
            OrderStatus.PENDING_PAYMENT,
            OrderStatus.PAYMENT_FAILED
        ].includes(status);
    };

    const canAddMoreItemsToOrder = (status: OrderStatus | undefined): boolean => {
        if (!status) return false;
        return [
            OrderStatus.RECEIVED, OrderStatus.IN_PROGRESS, OrderStatus.PARTIALLY_READY,
            OrderStatus.ALL_ITEMS_READY, OrderStatus.COMPLETED
        ].includes(status);
    };

    const shouldPoll = !isOrderConsideredFinalOrPendingPayment(orderStatusData?.orderStatus) && !loading && !error && !isRequestingBill;

    const fetchOrderStatus = useCallback(async (isInitialFetch = false) => {
        if (!orderId) {
            setError(t('orderStatusPage.error.missingOrderId'));
            if (isInitialFetch) setLoading(false);
            return;
        }
        if (isInitialFetch) {
            setLoading(true);
            setError(null);
        }
        // No mostramos log de fetching si no es inicial para no llenar la consola con el polling
        // console.log(`[OrderStatusPage] Fetching status for order ${orderId}. Initial: ${isInitialFetch}`);
        try {
            const response = await axios.get<PublicOrderStatusInfo>(`${API_BASE_URL_PUBLIC}/order/${orderId}/status`);
            if (response.data) {
                setOrderStatusData(response.data);
                if (error) setError(null); // Limpiar error si el fetch actual es exitoso
            } else {
                // No deber√≠a pasar si la API siempre devuelve algo o un error
                throw new Error(t('orderStatusPage.error.noData'));
            }
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorUnknown');
            setError(msg);
            if (err.response?.status === 404) {
                setOrderStatusData(null);
            }
            console.error(`[OrderStatusPage] Error fetching status for order ${orderId}:`, err);
        } finally {
            if (isInitialFetch) setLoading(false);
        }
    }, [orderId, t, error]); // error como dependencia

    useEffect(() => {
        fetchOrderStatus(true);
    }, [fetchOrderStatus]); // Solo fetchOrderStatus como dependencia para la carga inicial

    useEffect(() => {
        if (shouldPoll) {
            // console.log(`[OrderStatusPage] Setting up polling for order ${orderId}... Interval: ${POLLING_INTERVAL}ms`);
            pollingTimeoutRef.current = window.setTimeout(() => {
                // console.log(`[OrderStatusPage] Polling for order ${orderId}...`);
                fetchOrderStatus(false);
            }, POLLING_INTERVAL);
        } else {
             if (pollingTimeoutRef.current) {
                // console.log(`[OrderStatusPage] Clearing polling timeout (condition not met).`);
                clearTimeout(pollingTimeoutRef.current);
                pollingTimeoutRef.current = null;
            }
        }
        return () => {
            if (pollingTimeoutRef.current) {
                clearTimeout(pollingTimeoutRef.current);
                // console.log(`[OrderStatusPage] Polling timeout cleared on unmount/re-render for order ${orderId}.`);
            }
        };
    }, [orderStatusData, shouldPoll, fetchOrderStatus, orderId]); // A√±adir orderStatusData para que re-eval√∫e shouldPoll

    useEffect(() => {
        if (
            (orderStatusData?.orderStatus === OrderStatus.PAID || orderStatusData?.orderStatus === OrderStatus.CANCELLED) &&
            activeOrderKey &&
            orderStatusData?.orderId === orderId
        ) {
            const storedActiveOrderInfo = localStorage.getItem(activeOrderKey);
            if (storedActiveOrderInfo) {
                try {
                    const parsedInfo = JSON.parse(storedActiveOrderInfo);
                    if (parsedInfo.orderId === orderId) {
                        localStorage.removeItem(activeOrderKey);
                        console.log(`[OrderStatusPage] Active order info for ${orderId} (Key: ${activeOrderKey}) removed from localStorage because order is final.`);
                    }
                } catch(e) {
                    console.error("Error parsing or removing active order info from localStorage:", e);
                }
            }
        }
    }, [orderStatusData?.orderStatus, activeOrderKey, orderId]);

    const getOrderItemStatusInfo = (status: OrderItemStatus): { text: string; color: string; icon: React.ReactNode } => {
        switch (status) {
            case OrderItemStatus.PENDING_KDS: return { text: t('orderStatusPage.itemStatus.pending_kds'), color: 'gray', icon: <IconClipboardList size={16}/> };
            case OrderItemStatus.PREPARING: return { text: t('orderStatusPage.itemStatus.preparing'), color: 'blue', icon: <IconToolsKitchen size={16}/> };
            case OrderItemStatus.READY: return { text: t('orderStatusPage.itemStatus.ready'), color: 'lime', icon: <IconChefHat size={16}/> };
            case OrderItemStatus.SERVED: return { text: t('orderStatusPage.itemStatus.served'), color: 'green', icon: <IconCircleCheck size={16}/> };
            case OrderItemStatus.CANCELLED: return { text: t('orderStatusPage.itemStatus.cancelled'), color: 'red', icon: <IconCircleX size={16}/> };
            case OrderItemStatus.CANCELLATION_REQUESTED: return { text: t('orderStatusPage.itemStatus.cancellation_requested'), color: 'orange', icon: <IconAlertCircle size={16}/> };
            default: return { text: String(t(status as string, status as string)), color: 'gray', icon: <IconClipboardList size={16}/> };
        }
    };

    const getOrderStatusText = (status: OrderStatus): string => {
         return String(t(`orderStatusPage.orderStatus.${status.toLowerCase()}`, status as string));
    };

    const handleStartNewOrder = () => {
        const cartKey = businessSlugForReturn ? `${LOCAL_STORAGE_CART_KEY_PREFIX}${businessSlugForReturn}${currentTableIdentifierForReturn ? `_${currentTableIdentifierForReturn}` : ''}` : null;
        const notesKey = businessSlugForReturn ? `${LOCAL_STORAGE_ORDER_NOTES_KEY_PREFIX}${businessSlugForReturn}${currentTableIdentifierForReturn ? `_${currentTableIdentifierForReturn}` : ''}` : null;

        if (activeOrderKey) localStorage.removeItem(activeOrderKey);
        if (cartKey) localStorage.removeItem(cartKey);
        if (notesKey) localStorage.removeItem(notesKey);
        setOrderStatusData(null);

        if (businessSlugForReturn) {
            navigate(`/m/${businessSlugForReturn}${currentTableIdentifierForReturn ? `/${currentTableIdentifierForReturn}` : ''}`, { replace: true });
        } else {
            navigate('/login', { replace: true });
        }
    };

    const handleRequestBill = async () => {
        if (!orderId || !orderStatusData || isRequestingBill) return;

        setIsRequestingBill(true);
        setError(null);
        console.log(`[OrderStatusPage] Client requesting bill for order ${orderId}`);
        try {
            // La respuesta del backend en este caso no incluye 'items', solo 'id', 'orderNumber', 'status', 'isBillRequested'
            // Por lo tanto, no podemos hacer setOrderStatusData(response.data.order) directamente o perderemos los items.
            // En lugar de eso, solo mostramos la notificaci√≥n y dejamos que el polling actualice el estado completo.
            await axios.post<{order: Pick<PublicOrderStatusInfo, 'orderId' | 'orderNumber' | 'orderStatus' | 'isBillRequested'>}>(
                `${API_BASE_URL_PUBLIC}/order/${orderId}/request-bill`,
                { paymentPreference: undefined }
            );

            notifications.show({
                title: t('common.success'),
                message: t('orderStatusPage.billRequestedSuccess'),
                color: 'green',
                icon: <IconCircleCheck />
            });
            // ---- CORRECCI√ìN: Forzar un refetch despu√©s de la acci√≥n exitosa ----
            // Esto asegura que la UI se actualice con el nuevo estado del pedido (incluyendo items)
            // y el polling se re-eval√∫e correctamente.
            fetchOrderStatus(false);
            // ---- FIN CORRECCI√ìN ----

        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorUnknown');
            setError(msg);
            notifications.show({
                title: t('common.error'),
                message: t('orderStatusPage.errorRequestingBill', { message: msg }),
                color: 'red',
                icon: <IconAlertCircle />
            });
            console.error(`[OrderStatusPage] Error requesting bill for order ${orderId}:`, err);
        } finally {
            setIsRequestingBill(false);
        }
    };

    if (loading && !orderStatusData) {
        return (
            <Container size="sm" py="xl" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: 'calc(100vh - 60px)' }}>
                <Loader size="xl" />
            </Container>
        );
    }

    if (error && !orderStatusData) {
        return (
            <Container size="sm" py="xl">
                <Alert icon={<IconAlertCircle size="1rem" />} title={t('common.error')} color="red" radius="md">
                    {error}
                </Alert>
                {businessSlugForReturn && (
                    <Button
                        component={Link}
                        to={`/m/${businessSlugForReturn}${currentTableIdentifierForReturn ? `/${currentTableIdentifierForReturn}`: ''}`}
                        variant="light" mt="lg" leftSection={<IconArrowLeft size={16}/>}>
                        {t('orderStatusPage.backToMenuButton')}
                    </Button>
                )}
                 {!businessSlugForReturn && (
                    <Button
                        onClick={() => navigate('/login')}
                        variant="light" mt="lg" leftSection={<IconArrowLeft size={16}/>}>
                        {t('common.back')}
                    </Button>
                 )}
            </Container>
        );
    }

    if (!orderStatusData) { // Ya no necesitamos && !loading aqu√≠
        return (
            <Container size="sm" py="xl">
                <Text ta="center" c="dimmed">{t('orderStatusPage.error.notFound')}</Text>
                {businessSlugForReturn && (
                     <Group justify="center" mt="xl">
                        <Button
                            component={Link}
                            to={`/m/${businessSlugForReturn}${currentTableIdentifierForReturn ? `/${currentTableIdentifierForReturn}`: ''}`}
                            variant="outline" leftSection={<IconArrowLeft size={16}/>}>
                            {t('orderStatusPage.backToMenuButton')}
                        </Button>
                    </Group>
                )}
                 {!businessSlugForReturn && (
                     <Group justify="center" mt="xl">
                        <Button
                            onClick={() => navigate('/login')}
                            variant="outline" leftSection={<IconArrowLeft size={16}/>}>
                            {t('common.back')}
                        </Button>
                    </Group>
                 )}
            </Container>
        );
    }

    const { orderNumber, orderStatus, items, tableIdentifier: orderTableIdentifier, orderNotes: generalOrderNotes, createdAt } = orderStatusData;
    const isCurrentOrderEffectivelyFinal = isOrderConsideredFinalOrPendingPayment(orderStatus);
    const showAddMoreItemsButton = !isCurrentOrderEffectivelyFinal && canAddMoreItemsToOrder(orderStatus);

    const canRequestBill =
        !isRequestingBill &&
        (
            orderStatus === OrderStatus.RECEIVED ||
            orderStatus === OrderStatus.IN_PROGRESS ||
            orderStatus === OrderStatus.PARTIALLY_READY ||
            orderStatus === OrderStatus.ALL_ITEMS_READY ||
            orderStatus === OrderStatus.COMPLETED
        );

    return (
        <Container size="md" py="xl">
            <Paper shadow="md" p="xl" radius="lg" withBorder>
                <Stack gap="lg">
                    <Title order={2} ta="center">{t('orderStatusPage.title')}</Title>
                    <Text ta="center" fz="xl" fw={700}>#{orderNumber || displayOrderNumber}</Text>

                    {error && !loading && (
                        <Alert icon={<IconAlertCircle size="1rem" />} title={t('common.error')} color="orange" radius="md" withCloseButton onClose={() => setError(null)}>
                            {String(t('orderStatusPage.error.updateFailed', { message: error }))}
                        </Alert>
                    )}

                    <Paper withBorder p="md" radius="sm" bg={i18n.language === 'dark' ? "dark.6" : "gray.0"}>
                        <Group justify="space-between">
                            <Text fw={500}>{t('orderStatusPage.generalStatus')}</Text>
                            <Badge size="lg"
                                // ---- CORRECCI√ìN AQU√ç para la guarda de items[0] ----
                                color={getOrderItemStatusInfo( (items && items.length > 0 ? items[0]?.status : undefined) || OrderItemStatus.PENDING_KDS).color}
                                variant="filled"
                            >
                                {getOrderStatusText(orderStatus)}
                            </Badge>
                        </Group>
                        {orderTableIdentifier && (
                            <Text size="sm" mt="xs">
                                {t('orderStatusPage.table')} <Text span fw={500}>{orderTableIdentifier}</Text>
                            </Text>
                        )}
                        <Text size="sm" c="dimmed" mt="xs">
                            {t('orderStatusPage.placedAt')} {new Date(createdAt).toLocaleString(i18n.language, { dateStyle: 'medium', timeStyle: 'short' })}
                        </Text>
                    </Paper>

                    <Divider my="sm" label={t('orderStatusPage.itemsTitle')} labelPosition="center" />

                    <Box>
                        {items.length === 0 ? (
                            <Text c="dimmed" ta="center">{t('publicMenu.noItemsInCategory')}</Text>
                        ) : (
                            <List spacing="md" listStyleType="none" p={0}>
                                {items.map((item: PublicOrderItemStatusInfo) => { // <-- Tipo expl√≠cito aqu√≠
                                    const statusInfo = getOrderItemStatusInfo(item.status);
                                    const itemName = (i18n.language === 'es' && item.menuItemName_es) ? item.menuItemName_es : (item.menuItemName_en || item.menuItemName_es || '√çtem');
                                    return (
                                        <List.Item
                                            key={item.id}
                                            icon={
                                                <ThemeIcon color={statusInfo.color} size={24} radius="xl">
                                                    {statusInfo.icon}
                                                </ThemeIcon>
                                            }
                                        >
                                            <Paper p="sm" radius="sm" withBorder style={{ flexGrow: 1 }}>
                                                <Group justify="space-between" wrap="nowrap">
                                                    <Stack gap={2} style={{flexGrow: 1, minWidth: 0}}>
                                                        <Text fw={500} truncate>{itemName}</Text>
                                                        <Text size="sm" c="dimmed">{t('orderStatusPage.quantity')} {item.quantity}</Text>
                                                    </Stack>
                                                    <Text size="sm" c={statusInfo.color} style={{flexShrink: 0}}>{statusInfo.text}</Text>
                                                </Group>
                                            </Paper>
                                        </List.Item>
                                    );
                                })}
                            </List>
                        )}
                    </Box>

                    {generalOrderNotes && (
                        <>
                            <Divider my="sm" label={t('orderStatusPage.orderNotesLabel')} labelPosition="center" />
                            <Paper withBorder p="sm" radius="sm" bg={i18n.language === 'dark' ? "dark.6" : "gray.0"}>
                                <Text size="sm" style={{ whiteSpace: 'pre-wrap' }}>{generalOrderNotes}</Text>
                            </Paper>
                        </>
                    )}

                    <Group justify="space-between" mt="xl" wrap="nowrap">
                        <Group>
                            {showAddMoreItemsButton && businessSlugForReturn && (
                                <Button
                                    component={Link}
                                    to={`/m/${businessSlugForReturn}${currentTableIdentifierForReturn ? `/${currentTableIdentifierForReturn}` : ''}`}
                                    variant="filled"
                                    leftSection={<IconPlus size={16} />}
                                    mr="sm"
                                >
                                    {t('orderStatusPage.addMoreItemsButton')}
                                </Button>
                            )}

                            {canRequestBill && (
                                <Button
                                    variant="gradient"
                                    gradient={{ from: 'orange', to: 'yellow' }}
                                    onClick={handleRequestBill}
                                    loading={isRequestingBill}
                                    disabled={isRequestingBill || loading}
                                    leftSection={<IconCreditCard size={16} />}
                                    mr="sm"
                                >
                                    {t('orderStatusPage.requestBillButton')}
                                </Button>
                            )}

                            {!isCurrentOrderEffectivelyFinal && !canRequestBill && (
                                <Button
                                    variant="outline"
                                    onClick={() => fetchOrderStatus(false)}
                                    leftSection={<IconReload size={16}/>}
                                    loading={loading && !!orderStatusData && !isRequestingBill}
                                    disabled={isRequestingBill || (loading && !orderStatusData)}
                                >
                                    {t('orderStatusPage.refreshButton')}
                                </Button>
                            )}

                            {(orderStatus === OrderStatus.PAID || orderStatus === OrderStatus.CANCELLED) && (
                                <Button
                                    variant="filled"
                                    color="green"
                                    onClick={handleStartNewOrder}
                                    leftSection={<IconShoppingCart size={16} />}
                                >
                                    {t('publicMenu.activeOrder.startNewButton')}
                                </Button>
                            )}
                        </Group>

                        {businessSlugForReturn ? (
                            <Button
                                component={Link}
                                to={`/m/${businessSlugForReturn}${currentTableIdentifierForReturn ? `/${currentTableIdentifierForReturn}`: ''}`}
                                variant="light"
                                leftSection={<IconArrowLeft size={16}/>}
                            >
                                {t('orderStatusPage.backToMenuButton')}
                            </Button>
                        ) : (
                             <Button
                                 onClick={() => navigate('/login')}
                                 variant="light"
                                 leftSection={<IconArrowLeft size={16}/>}
                             >
                                 {t('common.back')}
                             </Button>
                         )}
                    </Group>
                </Stack>
            </Paper>
        </Container>
    );
};

export default OrderStatusPage;


// ====== [68] frontend/src/modules/camarero/pages/PublicMenuViewPage.tsx ======
// frontend/src/pages/PublicMenuViewPage.tsx
// Version 2.2.0 (Refactored to use usePublicMenuData hook)

import React, { useState, useEffect } from 'react';
import { useParams, useNavigate, Link } from 'react-router-dom';
import {
    Container, Title, Loader, Alert, Text, Stack, Paper, Image, Group,
    useMantineTheme, Button, useMantineColorScheme
} from '@mantine/core';
import {
    IconAlertCircle, IconShoppingCart, IconCheck, IconInfoCircle
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { notifications } from '@mantine/notifications';
import { useDisclosure } from '@mantine/hooks';

// Tipos
import { SelectedModifierFE } from '../types/publicOrder.types';

// Componentes
import CategoryAccordion from '../components/public/menu/CategoryAccordion';
import { MenuItemCardConfiguringState } from '../components/public/menu/MenuItemCard';
import ShoppingCartModal from '../components/public/menu/ShoppingCartModal';

// Hooks
import { useActiveOrderState } from '../hooks/useActiveOrderState';
import { usePublicOrderCart } from '../hooks/usePublicOrderCart';
import { useMenuItemConfigurator } from '../hooks/useMenuItemConfigurator';
import { usePublicMenuData } from '../hooks/usePublicMenuData'; // <-- NUEVA IMPORTACI√ìN

// Servicio
import { handleOrderSubmission } from '../services/publicOrderApiService';


const PublicMenuViewPage: React.FC = () => {
    const { t, i18n } = useTranslation();
    const theme = useMantineTheme();
    const { colorScheme } = useMantineColorScheme();
    const { businessSlug, tableIdentifier: tableIdentifierFromParams } = useParams<{ businessSlug: string; tableIdentifier?: string }>();
    const navigate = useNavigate();

    // --- L√ìGICA DE DATOS AHORA CENTRALIZADA EN HOOKS ---
    const { menuData, loadingMenu, errorMenu } = usePublicMenuData(businessSlug);
    const {
        activeOrderId, activeOrderNumber, canCurrentlyAddToExistingOrder,
        loadingActiveOrderStatus, clearActiveOrder, setActiveOrderManually,
    } = useActiveOrderState(businessSlug, tableIdentifierFromParams);
    const {
        currentOrderItems, orderNotes, totalCartItems, totalCartAmount,
        addItemToCart, addSimpleItemToCart, updateItemQuantityInCart,
        removeItemFromCart, updateOrderNotes, clearCart, clearCartStorage,
    } = usePublicOrderCart(businessSlug, tableIdentifierFromParams, activeOrderId);
    const {
        configuringItem, startConfiguringItem, cancelConfiguration,
        updateConfigQuantity, updateConfigModifierSelection, updateConfigNotes,
    } = useMenuItemConfigurator();
    
    // --- ESTADO LOCAL SOLO PARA LA UI ---
    const [activeAccordionItems, setActiveAccordionItems] = useState<string[]>([]);
    const [isCartOpen, { open: openCart, close: closeCart }] = useDisclosure(false);
    const [isSubmittingOrder, setIsSubmittingOrder] = useState(false);

    // Efecto para abrir la primera categor√≠a del men√∫ (ahora depende de menuData)
    useEffect(() => {
        if (menuData && menuData.categories.length > 0 && !activeOrderId) {
            setActiveAccordionItems([menuData.categories[0].id]);
        } else if (activeOrderId) {
            setActiveAccordionItems([]);
        }
    }, [menuData, activeOrderId]);

    // L√≥gica para a√±adir √≠tem configurado al carrito (sin cambios)
    const handleConfiguredItemAddToCart = () => {
        if (!configuringItem) return;
        const { itemDetails, quantity, selectedOptionsByGroup, currentUnitPrice, itemNotes, areModifiersValid } = configuringItem;
        if (!areModifiersValid) {
            notifications.show({ title: t('publicMenu.invalidSelectionTitle'), message: t('publicMenu.invalidSelectionMsg'), color: 'orange' });
            return;
        }
        const flatSelectedModifiers: SelectedModifierFE[] = [];
        if (Array.isArray(itemDetails.modifierGroups)) {
            Object.entries(selectedOptionsByGroup).forEach(([groupId, optionSelections]) => {
                const group = itemDetails.modifierGroups!.find(g => g.id === groupId);
                if (!group || !Array.isArray(group.options)) return;
                const ids = Array.isArray(optionSelections) ? optionSelections.filter(s => s && s.trim() !== '') : ((typeof optionSelections === 'string' && optionSelections.trim() !== '') ? [optionSelections.trim()] : []);
                ids.forEach(optId => {
                    const option = group.options.find(o => o.id === optId);
                    if (option) { flatSelectedModifiers.push({ modifierOptionId: option.id, name_es: option.name_es, name_en: option.name_en, priceAdjustment: option.priceAdjustment, modifierGroupName_es: group.name_es, modifierGroupName_en: group.name_en }); }
                });
            });
        }
        const sortedModifierOptionIds = flatSelectedModifiers.map(m => m.modifierOptionId).sort().join(',');
        const notesHash = itemNotes ? `_notes-${itemNotes.toLocaleLowerCase().replace(/\s/g, '')}` : '';
        const cartItemId = `${itemDetails.id}${flatSelectedModifiers.length > 0 ? `-[${sortedModifierOptionIds}]` : ''}${notesHash}`;
        addItemToCart({ cartItemId, menuItemId: itemDetails.id, menuItemName_es: itemDetails.name_es, menuItemName_en: itemDetails.name_en, quantity, basePrice: itemDetails.price, currentPricePerUnit: currentUnitPrice, totalPriceForItem: currentUnitPrice * quantity, notes: itemNotes || undefined, selectedModifiers: flatSelectedModifiers });
        cancelConfiguration();
    };

    // L√≥gica de env√≠o de pedido (sin cambios)
    const handleSubmitOrderOrAddItems = async () => {
        if (currentOrderItems.length === 0) {
            notifications.show({ title: t('publicMenu.cart.errorTitle'), message: activeOrderId ? t('publicMenu.cart.errorEmptyAddToOrder') : t('publicMenu.cart.errorEmpty'), color: 'orange' });
            return;
        }
        if (!businessSlug) {
            notifications.show({ title: t('common.error'), message: t('error.missingBusinessSlug'), color: 'red' });
            return;
        }
        setIsSubmittingOrder(true);
        try {
            const response = await handleOrderSubmission(
                currentOrderItems,
                orderNotes,
                canCurrentlyAddToExistingOrder ? activeOrderId : null,
                businessSlug,
                tableIdentifierFromParams
            );
            const orderIdToNavigate = response.id;
            const orderNumberToNavigate = response.orderNumber || activeOrderNumber || orderIdToNavigate;
            const successMessage = activeOrderId
                ? t('publicMenu.cart.itemsAddedSuccessMsg', { orderNumber: orderNumberToNavigate })
                : t('publicMenu.cart.orderSuccessMsg', { orderNumber: orderNumberToNavigate });
            notifications.show({
                title: activeOrderId ? t('publicMenu.cart.itemsAddedSuccessTitle') : t('publicMenu.cart.orderSuccessTitle'),
                message: successMessage,
                color: 'green',
                icon: <IconCheck />
            });
            if (!activeOrderId) {
                setActiveOrderManually(orderIdToNavigate, orderNumberToNavigate);
            }
            clearCart();
            clearCartStorage();
            closeCart();
            navigate(`/order-status/${orderIdToNavigate}`, {
                state: { orderNumber: orderNumberToNavigate, businessSlug, tableIdentifier: tableIdentifierFromParams }
            });
        } catch (err: any) {
            const errMsg = err.response?.data?.message || err.message || t('publicMenu.cart.orderErrorMsg');
            notifications.show({
                title: t('publicMenu.cart.orderErrorTitle'),
                message: errMsg,
                color: 'red',
                icon: <IconAlertCircle />
            });
        } finally {
            setIsSubmittingOrder(false);
        }
    };

    // El resto del componente (renderizado) permanece sin cambios...
    const isLoadingPage = loadingMenu || loadingActiveOrderStatus;
    const pageError = errorMenu;

    if (isLoadingPage) {
        return ( <Container size="md" py="xl" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '80vh' }}><Loader size="xl" /></Container> );
    }
    if (pageError) {
        return ( <Container size="md" py="xl"><Alert icon={<IconAlertCircle size="1rem" />} title={t('common.error')} color="red" radius="md">{pageError}</Alert></Container> );
    }
    if (!menuData) {
        return ( <Container size="md" py="xl"><Text ta="center" c="dimmed">{t('publicMenu.menuNotAvailable')}</Text></Container> );
    }
    const menuItemCardConfigState: MenuItemCardConfiguringState | null = configuringItem;
    const topOffsetForCartBar = typeof theme.spacing.md === 'number' ? theme.spacing.md + 10 : 26;
    const cartButtonText = activeOrderId && canCurrentlyAddToExistingOrder ? t('publicMenu.cart.addItemsToOrderButton', { count: totalCartItems, orderNumber: activeOrderNumber }) : t('publicMenu.cart.viewOrderItems', { count: totalCartItems });

    return (
        <>
            <Container size="lg" py="xl">
                <Stack gap="xl">
                    <Group justify="center" align="center" wrap="nowrap">
                        {menuData.businessLogoUrl && ( <Image src={menuData.businessLogoUrl} alt={`${menuData.businessName} logo`} h={50} w="auto" fit="contain" radius="sm" /> )}
                        <Title order={1} ta="center" style={{ flexShrink: 1, minWidth: 0 }}>{menuData.businessName}</Title>
                    </Group>
                    {activeOrderId && canCurrentlyAddToExistingOrder && !configuringItem && (
                        <Paper shadow="md" p="lg" radius="md" withBorder mb="xl" bg={colorScheme === 'dark' ? theme.colors.dark[5] : theme.colors.blue[0]}>
                            <Group justify="space-between" align="center">
                                <Group><IconInfoCircle size={24} color={theme.colors.blue[6]} /><Stack gap={0}>
                                    <Text fw={500}>{t('publicMenu.activeOrder.addingToOrderTitle', {orderNumber: activeOrderNumber})}</Text>
                                    <Text size="sm">{t('publicMenu.activeOrder.addingToOrderMsg')}</Text>
                                </Stack></Group>
                                <Button variant="outline" size="xs" component={Link} to={`/order-status/${activeOrderId}`} state={{ orderNumber: activeOrderNumber, businessSlug, tableIdentifier: tableIdentifierFromParams }}>
                                    {t('publicMenu.activeOrder.viewStatusButton')}
                                </Button>
                            </Group>
                        </Paper>
                    )}
                    {activeOrderId && !canCurrentlyAddToExistingOrder && !loadingActiveOrderStatus && !configuringItem && (
                         <Paper shadow="md" p="lg" radius="md" withBorder mb="xl" bg={colorScheme === 'dark' ? theme.colors.dark[5] : theme.colors.gray[0]}>
                            <Group justify="space-between" align="center">
                                 <Group><IconAlertCircle size={24} color={theme.colors.orange[6]} /><Stack gap={0}>
                                    <Text fw={500}>{t('publicMenu.activeOrder.cannotAddTitle', {orderNumber: activeOrderNumber})}</Text>
                                    <Text size="sm">{t('publicMenu.activeOrder.cannotAddMsg')}</Text>
                                </Stack></Group>
                                <Button variant="outline" size="xs" onClick={clearActiveOrder}>
                                    {t('publicMenu.activeOrder.startNewButtonAlt')}
                                </Button>
                            </Group>
                        </Paper>
                    )}
                    {totalCartItems > 0 && (!activeOrderId || (activeOrderId && canCurrentlyAddToExistingOrder)) && !configuringItem && (
                        <Paper p={0} shadow="xs" withBorder={false} radius="md" style={{ position: 'sticky', top: topOffsetForCartBar, zIndex: 200 }} >
                            <Button fullWidth size="lg" variant="gradient"
                                gradient={{ from: theme.primaryColor, to: theme.colors[theme.primaryColor][4], deg: 105 }}
                                onClick={openCart}
                                disabled={isCartOpen}
                                styles={{ root: { height: 'auto', padding: `${theme.spacing.sm} ${theme.spacing.md}` }, label: { width: '100%' } }}
                            >
                                <Group justify="space-between" style={{ width: '100%' }}>
                                    <Group gap="xs"><IconShoppingCart size={22} stroke={1.8} /><Text fw={500} inherit> {cartButtonText} </Text></Group>
                                    <Text fw={700} inherit>{t('publicMenu.cart.total')}: {totalCartAmount.toLocaleString(i18n.language, { style: 'currency', currency: 'EUR' })}</Text>
                                </Group>
                            </Button>
                        </Paper>
                    )}
                    <CategoryAccordion
                        categories={menuData.categories}
                        activeAccordionItems={activeAccordionItems}
                        onAccordionChange={setActiveAccordionItems}
                        configuringItemId={configuringItem?.itemDetails.id || null}
                        configuringItemState={menuItemCardConfigState}
                        onStartConfigureItem={startConfiguringItem}
                        onCancelConfiguration={cancelConfiguration}
                        onConfigQuantityChange={updateConfigQuantity}
                        onConfigModifierSelectionChange={updateConfigModifierSelection}
                        onConfigNotesChange={updateConfigNotes}
                        onConfigAddToCart={handleConfiguredItemAddToCart}
                        onSimpleAddToCart={addSimpleItemToCart}
                    />
                </Stack>
            </Container>
            {(!activeOrderId || (activeOrderId && canCurrentlyAddToExistingOrder)) && (
                <ShoppingCartModal
                    opened={isCartOpen} onClose={closeCart}
                    orderItems={currentOrderItems} orderNotes={orderNotes}
                    onUpdateItemQuantity={updateItemQuantityInCart} onRemoveItem={removeItemFromCart}
                    onUpdateOrderNotes={updateOrderNotes} onSubmitOrder={handleSubmitOrderOrAddItems}
                    isSubmittingOrder={isSubmittingOrder} onClearCart={clearCart}
                    isAddingToExistingOrder={!!(activeOrderId && canCurrentlyAddToExistingOrder)}
                    activeOrderNumber={activeOrderNumber}
                />
            )}
        </>
    );
};

export default PublicMenuViewPage;


// ====== [69] frontend/src/modules/camarero/pages/admin/camarero/KitchenDisplayPage.tsx ======
// frontend/src/pages/admin/camarero/KitchenDisplayPage.tsx
// Version: 1.1.0 (Add action buttons for KDS item status update)

import React, { useState, useEffect, useCallback, useRef } from 'react';
import {
    Container,
    Title,
    Text,
    Loader,
    Alert,
    Paper,
    List,
    Stack,
    Group,
    Badge,
    SegmentedControl,
    Box,
    Button,
} from '@mantine/core';
import { 
    IconAlertCircle, 
    IconReload,
    IconCheck, // A√±adido para notificaciones
    //IconX,     // A√±adido para notificaciones
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { 
    KdsListItem, 
    getItemsForKds, 
    updateOrderItemKdsStatus // Importar funci√≥n de actualizaci√≥n
} from '../../../services/kdsService'; 
import { OrderItemStatus } from '../../OrderStatusPage'; // Usar enum existente
import { notifications } from '@mantine/notifications'; // Importar notificaciones

// Configuraci√≥n
const DEFAULT_KDS_DESTINATION = 'COCINA';
const POLLING_INTERVAL_MS = 15000; 

const KitchenDisplayPage: React.FC = () => {
    const { t, i18n } = useTranslation();
    const [items, setItems] = useState<KdsListItem[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [currentDestination, setCurrentDestination] = useState<string>(DEFAULT_KDS_DESTINATION);
    
    const pollingTimeoutRef = useRef<number | null>(null);
    const [updatingItemId, setUpdatingItemId] = useState<string | null>(null);

    const fetchKdsItems = useCallback(async (isInitialFetch = false) => {
        if (isInitialFetch) {
            setLoading(true);
            setError(null);
        }
        console.log(`[KDS Page] Fetching items for destination: ${currentDestination}. Initial: ${isInitialFetch}`);
        try {
            const fetchedItems = await getItemsForKds(currentDestination, [
                OrderItemStatus.PENDING_KDS,
                OrderItemStatus.PREPARING,
            ]);
            setItems(fetchedItems);
            if (error && !isInitialFetch) setError(null); 
        } catch (err: any) {
            const errMsg = err.response?.data?.message || err.message || t('common.errorFetchingData');
            setError(errMsg);
            console.error(`[KDS Page] Error fetching KDS items for ${currentDestination}:`, err);
        } finally {
            if (isInitialFetch) {
                setLoading(false);
            }
        }
    }, [currentDestination, t, error]);

    useEffect(() => {
        fetchKdsItems(true); 
    }, [fetchKdsItems]); 

    useEffect(() => {
        if (pollingTimeoutRef.current) {
            clearTimeout(pollingTimeoutRef.current);
        }
        if (!updatingItemId) { // Solo hacer polling si no hay una actualizaci√≥n en curso
            pollingTimeoutRef.current = window.setTimeout(() => {
                console.log(`[KDS Page] Polling for destination: ${currentDestination}...`);
                fetchKdsItems(false); 
            }, POLLING_INTERVAL_MS);
        } else {
            console.log(`[KDS Page] Polling paused due to item update in progress.`);
        }

        return () => {
            if (pollingTimeoutRef.current) {
                clearTimeout(pollingTimeoutRef.current);
                console.log(`[KDS Page] Polling timeout cleared for ${currentDestination}.`);
            }
        };
    }, [items, fetchKdsItems, currentDestination, updatingItemId]); // A√±adir updatingItemId a las dependencias

    const getItemName = (item: KdsListItem | undefined): string => {
        if (!item) return t('kdsPage.unknownItem', '√çtem Desconocido');
        return (i18n.language === 'es' && item.menuItemName_es) ? item.menuItemName_es : (item.menuItemName_en || item.menuItemName_es || t('kdsPage.unknownItem', '√çtem Desconocido'));
    };

    const getOrderItemDisplayInfo = (status: OrderItemStatus): { textKey: string; color: string } => {
        switch (status) {
            case OrderItemStatus.PENDING_KDS: return { textKey: 'orderStatusPage.itemStatus.pending_kds', color: 'gray' };
            case OrderItemStatus.PREPARING: return { textKey: 'orderStatusPage.itemStatus.preparing', color: 'blue' };
            case OrderItemStatus.READY: return { textKey: 'orderStatusPage.itemStatus.ready', color: 'lime' };
            case OrderItemStatus.SERVED: return { textKey: 'orderStatusPage.itemStatus.served', color: 'green' };
            case OrderItemStatus.CANCELLED: return { textKey: 'orderStatusPage.itemStatus.cancelled', color: 'red' };
            case OrderItemStatus.CANCELLATION_REQUESTED: return { textKey: 'orderStatusPage.itemStatus.cancellation_requested', color: 'orange' };
            default: return { textKey: String(status), color: 'gray' };
        }
    };

    const handleUpdateStatus = async (itemId: string, newStatus: OrderItemStatus) => {
        if (updatingItemId) {
            notifications.show({
                title: t('kdsPage.updateInProgressTitle', 'Actualizaci√≥n en Progreso'),
                message: t('kdsPage.updateInProgressMsg', 'Espera a que finalice la acci√≥n actual.'),
                color: 'yellow'
            });
            return;
        }

        const itemBeingUpdated = items.find(i => i.id === itemId);
        const itemNameForNotif = getItemName(itemBeingUpdated);
        const newStatusText = t(`orderStatusPage.itemStatus.${newStatus.toLowerCase()}`, newStatus);

        setUpdatingItemId(itemId);
        try {
            await updateOrderItemKdsStatus(itemId, newStatus);
            notifications.show({
                title: t('kdsPage.statusUpdateSuccessTitle', 'Estado Actualizado'),
                message: t('kdsPage.statusUpdateSuccessMsg', { itemName: itemNameForNotif , status: newStatusText }),
                color: 'green',
                icon: <IconCheck size={18} />
            });
            await fetchKdsItems(false); 
        } catch (err: any) {
            const errorMsg = err.response?.data?.message || err.message || t('kdsPage.statusUpdateErrorMsg', 'Error al actualizar estado');
            notifications.show({
                title: t('common.error'),
                message: errorMsg,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
            console.error(`[KDS Page] Error updating status for item ${itemId} to ${newStatus}:`, err);
        } finally {
            setUpdatingItemId(null);
        }
    };

    if (loading && items.length === 0) { 
        return <Container style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}><Loader size="xl" /></Container>;
    }

    return (
        <Container fluid p="md">
            <Stack gap="lg">
                <Title order={2} ta="center">{t('kdsPage.title', 'Pantalla de Cocina (KDS)')} - {currentDestination}</Title>

                <SegmentedControl
                    value={currentDestination}
                    onChange={(value) => {
                        if (pollingTimeoutRef.current) clearTimeout(pollingTimeoutRef.current);
                        setCurrentDestination(value);
                        setItems([]); 
                    }}
                    data={[
                        { label: t('kdsPage.destination.kitchen', 'COCINA'), value: 'COCINA' },
                        { label: t('kdsPage.destination.bar', 'BARRA'), value: 'BARRA' },
                    ]}
                    fullWidth
                    mb="md"
                />

                {error && (
                    <Alert icon={<IconAlertCircle size="1rem" />} title={t('common.error')} color="red" withCloseButton onClose={() => setError(null)}>
                        {error}
                    </Alert>
                )}

                {items.length === 0 && !loading && !error && (
                    <Paper p="xl" shadow="xs" withBorder>
                        <Text ta="center" c="dimmed">{t('kdsPage.noItems', 'No hay √≠tems pendientes para este destino.')}</Text>
                    </Paper>
                )}

                {items.length > 0 && (
                    <List spacing="sm" listStyleType="none">
                        {items.map((item) => {
                            const displayInfo = getOrderItemDisplayInfo(item.status);
                            const isThisItemUpdating = updatingItemId === item.id;
                            const disableOtherItemsActions = !!updatingItemId && !isThisItemUpdating;

                            return (
                                <List.Item key={item.id}>
                                    <Paper withBorder p="md" radius="sm" shadow="xs">
                                        <Group justify="space-between">
                                            <Stack gap={0}>
                                                <Text fw={500} size="lg">{getItemName(item)}</Text>
                                                <Text size="sm" c="dimmed">{t('kdsPage.quantity', 'Cantidad')}: {item.quantity}</Text>
                                                {item.notes && <Text size="xs" c="orange">{t('kdsPage.notes', 'Notas')}: {item.notes}</Text>}
                                                <Text size="xs" c="dimmed">#{item.orderInfo.orderNumber} ({item.orderInfo.tableIdentifier || t('kdsPage.noTable', 'Sin Mesa')})</Text>
                                                 <Text size="xs" c="dimmed">{t('kdsPage.createdAt', 'Recibido KDS')}: {new Date(item.orderInfo.createdAt).toLocaleTimeString(i18n.language, { hour: '2-digit', minute: '2-digit' })}</Text>
                                            </Stack>
                                            <Badge color={displayInfo.color} variant="filled">
                                                {t(displayInfo.textKey, item.status)}
                                            </Badge>
                                        </Group>
                                        {item.selectedModifiers && item.selectedModifiers.length > 0 && (
                                            <Box mt="xs" pl="sm" style={{ borderLeft: '2px solid #ccc', marginLeft: '4px'}}>
                                                <Text size="xs" fw={500} mb={2}>{t('kdsPage.modifiers', 'Modificadores:')}</Text>
                                                <List listStyleType="disc" size="xs" c="dimmed" spacing={2}>
                                                    {item.selectedModifiers.map((mod, index) => (
                                                        <List.Item key={index}>
                                                            {(i18n.language === 'es' && mod.optionName_es) ? mod.optionName_es : (mod.optionName_en || mod.optionName_es)}
                                                        </List.Item>
                                                    ))}
                                                </List>
                                            </Box>
                                        )}
                                        <Group justify="flex-end" mt="md">
                                            {item.status === OrderItemStatus.PENDING_KDS && (
                                                <Button
                                                    size="xs"
                                                    color="blue"
                                                    onClick={() => handleUpdateStatus(item.id, OrderItemStatus.PREPARING)}
                                                    loading={isThisItemUpdating}
                                                    disabled={disableOtherItemsActions}
                                                >
                                                    {t('kdsPage.action.startPreparing', 'Empezar Preparaci√≥n')}
                                                </Button>
                                            )}
                                            {item.status === OrderItemStatus.PREPARING && (
                                                <Button
                                                    size="xs"
                                                    color="green"
                                                    onClick={() => handleUpdateStatus(item.id, OrderItemStatus.READY)}
                                                    loading={isThisItemUpdating}
                                                    disabled={disableOtherItemsActions}
                                                >
                                                    {t('kdsPage.action.markReady', 'Marcar como Listo')}
                                                </Button>
                                            )}
                                            {(item.status === OrderItemStatus.PENDING_KDS || item.status === OrderItemStatus.PREPARING) && (
                                                <Button
                                                    size="xs"
                                                    color="red"
                                                    variant="outline"
                                                    onClick={() => handleUpdateStatus(item.id, OrderItemStatus.CANCELLED)}
                                                    loading={isThisItemUpdating}
                                                    disabled={disableOtherItemsActions}
                                                >
                                                    {t('kdsPage.action.cancelItem', 'Cancelar √çtem')}
                                                </Button>
                                            )}
                                        </Group>
                                    </Paper>
                                </List.Item>
                            );
                        })}
                    </List>
                )}
                <Group justify="center" mt="md">
                    <Button onClick={() => fetchKdsItems(true)} leftSection={<IconReload size={16}/>} variant="outline" loading={loading && items.length > 0}>
                        {t('kdsPage.refreshManual', 'Refrescar Manualmente')}
                    </Button>
                </Group>
            </Stack>
        </Container>
    );
};

export default KitchenDisplayPage;


// ====== [70] frontend/src/modules/camarero/pages/admin/camarero/MenuManagementPage.tsx ======
// frontend/src/modules/camarero/pages/admin/camarero/MenuManagementPage.tsx (CORREGIDO)
import React, { useState } from 'react';
import { 
    Container, 
    Title, 
    Paper, 
    Stack, 
    Button,
    Group     
} from '@mantine/core';
import { useTranslation } from 'react-i18next';
import { notifications } from '@mantine/notifications'; 
import { IconExternalLink } from '@tabler/icons-react'; 

// --- RUTAS CORREGIDAS ---
import MenuCategoryManager from '../../../../../modules/camarero/components/admin/menu/MenuCategoryManager';
import MenuItemManager from '../../../../../modules/camarero/components/admin/menu/MenuItemManager'; 
import { MenuCategoryData } from '../../../../../modules/camarero/types/menu.types';
import { useLayoutUserData } from '../../../../../shared/hooks/useLayoutUserData'; 
// --- FIN RUTAS CORREGIDAS ---

const MenuManagementPage: React.FC = () => {
    const { t } = useTranslation();
    const [selectedCategory, setSelectedCategory] = useState<MenuCategoryData | null>(null);
    
    const { userData, loadingUser: loadingLayoutUser } = useLayoutUserData();

    const handleViewItems = (category: MenuCategoryData) => {
        setSelectedCategory(category);
    };
    const handleBackToCategories = () => {
        setSelectedCategory(null);
    };

    const handlePreviewMenu = () => {
        if (userData?.businessSlug) {
            window.open(`/m/${userData.businessSlug}`, '_blank');
        } else {
            console.error("[MenuManagementPage] Business slug no disponible para previsualizar el men√∫.");
            notifications.show({
                 title: t('common.error'),
                 message: t('adminCamarero.manageMenu.previewErrorNoSlug'),
                 color: 'red'
            });
        }
    };

    return (
        <Container size="xl" py="xl">
            <Stack gap="lg">
                <Group justify="space-between" align="flex-start">
                    <Title order={2}>
                        {t('adminCamarero.manageMenu.title')}
                    </Title>
                    {userData?.isCamareroActive && !loadingLayoutUser && (
                        <Button
                            variant="outline"
                            leftSection={<IconExternalLink size={16} />}
                            onClick={handlePreviewMenu}
                            disabled={!userData?.businessSlug}
                            title={!userData?.businessSlug ? t('adminCamarero.manageMenu.previewDisabledTooltip') : undefined}
                        >
                            {t('adminCamarero.manageMenu.previewButton')}
                        </Button>
                    )}
                </Group>

                {!selectedCategory ? (
                    <Paper shadow="sm" p="lg" withBorder radius="lg">
                        <Title order={4} mb="md">
                            {t('adminCamarero.manageMenu.categoriesSectionTitle')}
                        </Title>
                        <MenuCategoryManager 
                            onSelectCategoryForItems={handleViewItems}
                        />
                    </Paper>
                ) : (
                    <Paper shadow="sm" p="lg" withBorder radius="lg">
                        <Group justify="space-between" mb="md">
                            <Title order={4}>
                                {t('adminCamarero.manageMenu.itemsSectionTitle')} - {selectedCategory.name_es || selectedCategory.name_en}
                            </Title>
                            <Button variant="outline" onClick={handleBackToCategories}>
                                {t('common.back')} {t('adminCamarero.manageMenu.toCategories')}
                            </Button>
                        </Group>
                        <MenuItemManager 
                            categoryId={selectedCategory.id} 
                        />
                    </Paper>
                )}
            </Stack>
        </Container>
    );
};

export default MenuManagementPage;


// ====== [71] frontend/src/modules/camarero/pages/admin/camarero/WaiterOrderManagementPage.tsx ======
// frontend/src/pages/admin/camarero/WaiterOrderManagementPage.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
    Container,
    Title,
    Text,
    Loader,
    Alert,
    Paper,
    Stack,
    Group,
    Button,
    Table,
    Badge,
    SegmentedControl,
    // Modal, // Para el futuro modal de detalles de pago
    // TextInput, // Para el futuro modal de detalles de pago
} from '@mantine/core';
import {
    IconAlertCircle,
    IconCash, // Para el bot√≥n de "Marcar como Pagado"
    //IconReceipt2, // Para "Pedir Cuenta" (si se a√±ade aqu√≠)
    IconReload,
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX } from '@tabler/icons-react'; // Para notificaciones

// Suponiendo que estos tipos y servicios se crear√°n/adaptar√°n:
import { WaiterOrderListItemDto } from '../../../types/camarero.types'; // Aseg√∫rate que este DTO exista y se importe
import { OrderStatus } from '../../../../../shared/types/user.types'; // Usaremos el enum de OrderStatus
import axiosInstance from '../../../../../shared/services/axiosInstance'; // Para las llamadas API

// Hook para los datos (a√∫n por crear)
// import { useWaiterOrders } from '../../../hooks/useWaiterOrders';

const WaiterOrderManagementPage: React.FC = () => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;

    // Estado para los pedidos
    const [orders, setOrders] = useState<WaiterOrderListItemDto[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [selectedStatusFilter, setSelectedStatusFilter] = useState<string>(OrderStatus.PENDING_PAYMENT); // Filtro inicial
    const [markingPaidOrderId, setMarkingPaidOrderId] = useState<string | null>(null);

    // Opciones para el filtro de estado
    const statusFilterOptions = [
        { label: t('waiterOrderManagement.statusOptionPendingPayment', 'Pendientes de Pago'), value: OrderStatus.PENDING_PAYMENT },
        { label: t('waiterOrderManagement.statusOptionCompleted', 'Completados (No Pagados)'), value: OrderStatus.COMPLETED },
        { label: t('orderStatusPage.orderStatus.all_items_ready', 'Listos para Entregar'), value: OrderStatus.ALL_ITEMS_READY },
        { label: t('orderStatusPage.orderStatus.in_progress', 'En Progreso'), value: OrderStatus.IN_PROGRESS },
        { label: t('orderStatusPage.orderStatus.received', 'Recibidos'), value: OrderStatus.RECEIVED },
        { label: t('waiterOrderManagement.statusOptionPaid', 'Pagados'), value: OrderStatus.PAID },
        { label: t('waiterOrderManagement.statusOptionAll', 'Todos los Pedidos'), value: 'ALL' }, // 'ALL' es un valor especial
    ];

    // Funci√≥n para cargar pedidos
    const fetchOrders = useCallback(async (status?: string) => {
        setLoading(true);
        setError(null);
        console.log(`[WaiterOrderMgmt] Fetching orders with status filter: ${status || 'Default (from service)'}`);
        try {
            const params: { status?: string } = {};
            if (status && status !== 'ALL') {
                params.status = status;
            }
            // El endpoint es /api/camarero/staff/orders
            const response = await axiosInstance.get<WaiterOrderListItemDto[]>('/camarero/staff/orders', { params });
            setOrders(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            setError(msg);
            notifications.show({ title: t('common.error'), message: msg, color: 'red', icon: <IconAlertCircle /> });
        } finally {
            setLoading(false);
        }
    }, [t]);

    // Carga inicial y cuando cambia el filtro
    useEffect(() => {
        fetchOrders(selectedStatusFilter);
    }, [fetchOrders, selectedStatusFilter]);

    // Handler para marcar como pagado
    const handleMarkAsPaid = async (orderId: string, orderNumber: string) => {
        if (markingPaidOrderId) return; // Evitar clics m√∫ltiples

        setMarkingPaidOrderId(orderId);
        // Por ahora, un payload simple. En el futuro, un modal para 'method' y 'notes'.
        const payload = {
            method: "EFECTIVO_CAJA", // Valor por defecto para la prueba
            notes: `Pagado por camarero UI (MVP) - ${new Date().toLocaleTimeString()}`
        };

        try {
            await axiosInstance.post(`/camarero/staff/order/${orderId}/mark-as-paid`, payload);
            notifications.show({
                title: t('common.success'),
                message: t('waiterOrderManagement.markAsPaidSuccess', { orderNumber: orderNumber }),
                color: 'green',
                icon: <IconCheck />,
            });
            fetchOrders(selectedStatusFilter); // Refrescar la lista
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorUnknown');
            notifications.show({
                title: t('common.error'),
                message: t('waiterOrderManagement.markAsPaidError', { orderNumber: orderNumber, error: msg }),
                color: 'red',
                icon: <IconX />,
            });
        } finally {
            setMarkingPaidOrderId(null);
        }
    };

    const getStatusBadgeColor = (status: OrderStatus): string => {
        switch (status) {
            case OrderStatus.PENDING_PAYMENT: return 'orange';
            case OrderStatus.COMPLETED: return 'blue';
            case OrderStatus.PAID: return 'green';
            case OrderStatus.CANCELLED: return 'red';
            case OrderStatus.RECEIVED: return 'gray';
            case OrderStatus.IN_PROGRESS: return 'cyan';
            case OrderStatus.PARTIALLY_READY: return 'yellow';
            case OrderStatus.ALL_ITEMS_READY: return 'lime';
            default: return 'gray';
        }
    };

    const rows = orders.map((order) => {
        const isThisOrderLoading = markingPaidOrderId === order.orderId;
        const canMarkAsPaid = order.status === OrderStatus.PENDING_PAYMENT || order.status === OrderStatus.COMPLETED;
        
        return (
            <Table.Tr key={order.orderId}>
                <Table.Td>{order.orderNumber}</Table.Td>
                <Table.Td>{order.tableIdentifier || 'N/A'}</Table.Td>
                <Table.Td ta="right">
                    {order.finalAmount.toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}
                </Table.Td>
                <Table.Td>
                    <Badge color={getStatusBadgeColor(order.status)} variant="light">
                        {t(`orderStatusPage.orderStatus.${order.status.toLowerCase()}`, order.status)}
                    </Badge>
                </Table.Td>
                <Table.Td>
                    <Text size="xs" c="dimmed">
                        {new Date(order.createdAt).toLocaleString(currentLanguage, { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' })}
                    </Text>
                </Table.Td>
                <Table.Td>
                    <Group justify="flex-end">
                        {canMarkAsPaid && (
                            <Button
                                size="xs"
                                color="green"
                                leftSection={<IconCash size={14} />}
                                onClick={() => handleMarkAsPaid(order.orderId, order.orderNumber)}
                                loading={isThisOrderLoading}
                                disabled={!!markingPaidOrderId && !isThisOrderLoading}
                            >
                                {t('waiterOrderManagement.buttonMarkAsPaid')}
                            </Button>
                        )}
                        {/* Aqu√≠ podr√≠amos a√±adir m√°s acciones, como "Pedir Cuenta" si el estado lo permite */}
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    return (
        <Container size="xl" py="xl">
            <Stack gap="lg">
                <Group justify="space-between">
                    <Title order={2}>{t('waiterOrderManagement.title')}</Title>
                    <Button
                        onClick={() => fetchOrders(selectedStatusFilter)}
                        leftSection={<IconReload size={16} />}
                        variant="outline"
                        loading={loading && orders.length > 0} // Mostrar loading si ya hay datos y se refresca
                        disabled={loading || !!markingPaidOrderId}
                    >
                        {t('orderStatusPage.refreshButton')}
                    </Button>
                </Group>

                <SegmentedControl
                    data={statusFilterOptions}
                    value={selectedStatusFilter}
                    onChange={setSelectedStatusFilter}
                    disabled={loading || !!markingPaidOrderId}
                />

                {loading && orders.length === 0 && <Group justify="center" mt="xl"><Loader /></Group>}
                {error && !loading && (
                    <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>
                        {error}
                    </Alert>
                )}

                {!loading && !error && orders.length === 0 && (
                    <Paper p="xl" shadow="xs" withBorder mt="md">
                        <Text ta="center" c="dimmed">
                            {t('waiterOrderManagement.noOrdersFound')}
                        </Text>
                    </Paper>
                )}

                {!loading && !error && orders.length > 0 && (
                    <Table.ScrollContainer minWidth={700}>
                        <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                            <Table.Thead>
                                <Table.Tr>
                                    <Table.Th>{t('waiterOrderManagement.tableHeaderOrderNum')}</Table.Th>
                                    <Table.Th>{t('waiterOrderManagement.tableHeaderTable')}</Table.Th>
                                    <Table.Th ta="right">{t('waiterOrderManagement.tableHeaderTotal')}</Table.Th>
                                    <Table.Th>{t('waiterOrderManagement.tableHeaderStatus')}</Table.Th>
                                    <Table.Th>{t('common.registered')}</Table.Th>
                                    <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                                </Table.Tr>
                            </Table.Thead>
                            <Table.Tbody>{rows}</Table.Tbody>
                        </Table>
                    </Table.ScrollContainer>
                )}
            </Stack>
        </Container>
    );
};

export default WaiterOrderManagementPage;


// ====== [72] frontend/src/modules/camarero/pages/admin/camarero/WaiterPickupPage.tsx ======
// frontend/src/pages/admin/camarero/WaiterPickupPage.tsx
import React from 'react';
import {
    Container,
    Title,
    Text,
    Loader,
    Alert,
    Paper,
    Stack,
    Group,
    Button,
    Badge,
    ScrollArea,
    Box,
    useMantineTheme,
    List, // <--- A√ëADIDO AQU√ç
} from '@mantine/core';
import {
    IconAlertCircle,
    IconChefHat,
    IconClipboardList,
    IconToolsKitchen,
    IconCircleCheck,
    IconReload,
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useWaiterPickupItems } from '../../../hooks/useWaiterPickupItems'; // Ajusta la ruta si es necesario
import type { ReadyPickupItem } from '../../../types/camarero.types';
import { OrderItemStatus } from '../../../../../shared/types/user.types';

const WaiterPickupPage: React.FC = () => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;
    const theme = useMantineTheme();

    const {
        items,
        isLoadingInitial,
        fetchError,
        markingItemId,
        fetchItems,
        handleMarkAsServed,
    } = useWaiterPickupItems();

    const getItemNameForDisplay = (item: ReadyPickupItem): string => {
        return (currentLanguage === 'es' && item.itemNameSnapshot_es)
            ? item.itemNameSnapshot_es
            : (item.itemNameSnapshot_en || item.itemNameSnapshot_es || t('common.item', '√çtem'));
    };
    
    const getStatusBadge = (status: OrderItemStatus): React.ReactNode => {
        let color = "gray";
        let textKey = '';
        let IconComponent = IconClipboardList;

        switch (status) {
            case OrderItemStatus.READY:
                color = "lime";
                textKey = 'orderStatusPage.itemStatus.ready';
                IconComponent = IconChefHat;
                break;
            case OrderItemStatus.PREPARING:
                color = "blue";
                textKey = 'orderStatusPage.itemStatus.preparing';
                IconComponent = IconToolsKitchen;
                break;
            default:
                textKey = String(status); 
        }
        return <Badge color={color} leftSection={<IconComponent size={14} />} variant="light">{t(textKey, status)}</Badge>;
    };

    if (isLoadingInitial) {
        return (
            <Container size="lg" py="xl" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: 'calc(100vh - 120px)' }}>
                <Loader size="xl" />
            </Container>
        );
    }

    return (
        <Container size="xl" py="xl">
            <Stack gap="lg">
                <Group justify="space-between" align="center">
                    <Title order={2}>
                        {t('waiterInterface.pickupPageTitle', 'Pedidos Listos para Recoger y Servir')}
                    </Title>
                    <Button
                        onClick={() => fetchItems(true)}
                        leftSection={<IconReload size={16} />}
                        variant="outline"
                        loading={isLoadingInitial && items.length > 0}
                        disabled={isLoadingInitial || !!markingItemId}
                    >
                        {t('orderStatusPage.refreshButton', 'Actualizar')}
                    </Button>
                </Group>

                {fetchError && (
                    <Alert
                        icon={<IconAlertCircle size="1rem" />}
                        title={t('common.error')}
                        color="red"
                        radius="md"
                        withCloseButton
                        onClose={() => fetchItems(true)} 
                    >
                        {fetchError}
                    </Alert>
                )}

                {!fetchError && items.length === 0 && (
                    <Paper p="xl" shadow="xs" withBorder mt="xl">
                        <Text ta="center" c="dimmed">
                            {t('waiterInterface.noItemsReady', 'No hay √≠tems listos para recoger en este momento.')}
                        </Text>
                    </Paper>
                )}

                {items.length > 0 && (
                    <ScrollArea style={{ height: 'calc(100vh - 220px)' }} mt="md">
                        <Stack gap="md">
                            {items.map((item) => (
                                <Paper key={item.orderItemId} shadow="sm" p="md" withBorder radius="md">
                                    <Group justify="space-between" align="flex-start" wrap="nowrap">
                                        <Box style={{ flexGrow: 1 }}>
                                            <Title order={4}>{getItemNameForDisplay(item)}</Title>
                                            <Text size="sm">
                                                {t('kdsPage.quantity', 'Cantidad')}: <Text span fw={700}>{item.quantity}</Text>
                                            </Text>
                                            <Text size="xs" c="dimmed">
                                                {t('waiterInterface.orderNumber', 'Pedido')}: #{item.orderNumber}
                                            </Text>
                                            <Text size="xs" c="dimmed">
                                                {t('orderStatusPage.table', 'Mesa')}: {item.tableIdentifier || t('kdsPage.noTable', 'Sin Mesa')}
                                            </Text>
                                            {item.kdsDestination && (
                                                <Text size="xs" c="dimmed">
                                                    {t('waiterInterface.pickupFrom', 'Recoger de')}: <Badge variant="outline" size="xs">{item.kdsDestination}</Badge>
                                                </Text>
                                            )}
                                            <Text size="xs" c="dimmed">
                                                {t('kdsPage.createdAt', 'Recibido KDS')}: {new Date(item.orderCreatedAt).toLocaleTimeString(i18n.language, { hour: '2-digit', minute: '2-digit' })}
                                            </Text>
                                            {item.currentOrderItemStatus && (
                                                <Box mt={4}>{getStatusBadge(item.currentOrderItemStatus)}</Box>
                                            )}
                                        </Box>
                                        <Button
                                            onClick={() => handleMarkAsServed(item.orderItemId)}
                                            loading={markingItemId === item.orderItemId}
                                            disabled={!!markingItemId && markingItemId !== item.orderItemId}
                                            variant="filled"
                                            color="green"
                                            leftSection={<IconCircleCheck size={18} />}
                                        >
                                            {t('waiterInterface.markAsServedButton', 'Marcar como Servido')}
                                        </Button>
                                    </Group>

                                    {item.selectedModifiers && item.selectedModifiers.length > 0 && (
                                        <Box mt="sm" pt="xs" style={{ borderTop: `1px solid ${theme.colors.gray[3]}` }}>
                                            <Text size="xs" fw={500} mb={2}>{t('kdsPage.modifiers', 'Modificadores:')}</Text>
                                            <List listStyleType="none" spacing={2} size="xs" c="dimmed"> {/* <--- Uso de List */}
                                                {item.selectedModifiers.map((mod, index) => (
                                                    <List.Item key={index}> {/* <--- Uso de List.Item */}
                                                        {(currentLanguage === 'es' && mod.optionName_es) ? mod.optionName_es : (mod.optionName_en || mod.optionName_es)}
                                                    </List.Item>
                                                ))}
                                            </List>
                                        </Box>
                                    )}
                                    {item.itemNotes && (
                                        <Box mt="sm" pt="xs" style={{ borderTop: `1px solid ${theme.colors.gray[3]}` }}>
                                            <Text size="xs" fw={500} mb={2}>{t('kdsPage.notes', 'Notas √çtem')}:</Text>
                                            <Text size="xs" c="orange.7" style={{ whiteSpace: 'pre-wrap' }}>{item.itemNotes}</Text>
                                        </Box>
                                    )}
                                </Paper>
                            ))}
                        </Stack>
                    </ScrollArea>
                )}
            </Stack>
        </Container>
    );
};

export default WaiterPickupPage;


// ====== [73] frontend/src/modules/camarero/services/kdsService.ts ======
// frontend/src/services/kdsService.ts
// Version: 1.0.2 (Use baseURL from axiosInstance implicitly)

import axiosInstance from '../../../shared/services/axiosInstance'; // Tu instancia configurada de Axios
import { 
    OrderItemStatus as AppOrderItemStatus, 
    OrderStatus as AppOrderStatus  // Aseg√∫rate que OrderStatus se importa si se usa en los tipos aqu√≠
} from '../pages/OrderStatusPage'; //

// --- Tipos para la respuesta del GET /api/camarero/kds/items ---
// (Estos tipos son los de la versi√≥n 1.0.1 que ya tienes en project-all-code.txt)
export interface KdsListItem {
    id: string; 
    quantity: number;
    status: AppOrderItemStatus;
    notes: string | null;
    kdsDestination: string | null;
    menuItemName_es: string | null;
    menuItemName_en: string | null; 
    selectedModifiers: {
        optionName_es: string | null;
        optionName_en: string | null; 
    }[];
    orderInfo: {
        id: string; 
        orderNumber: string;
        createdAt: string; 
        tableIdentifier: string | null;
    };
    preparationTime?: number | null; 
    preparedAt?: string | null; 
    servedAt?: string | null; 
}

// --- Tipos para la respuesta del PATCH /api/camarero/kds/items/:orderItemId/status ---
// (Estos tipos son los de la versi√≥n 1.0.1 que ya tienes en project-all-code.txt)
interface ModifierOptionInfo {
    id: string;
    name_es: string | null;
    name_en: string | null;
    priceAdjustment: string; 
    position: number;
    isDefault: boolean;
    isAvailable: boolean;
    groupId: string;
    createdAt: string; 
    updatedAt: string; 
}

interface SelectedModifierInfo {
    orderItemId: string;
    modifierOptionId: string;
    optionNameSnapshot: string | null;
    optionPriceAdjustmentSnapshot: string; 
    createdAt: string; 
    modifierOption: ModifierOptionInfo; 
}

interface MenuItemInfoForKdsPatchResponse {
    id: string;
    sku: string | null;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    price: string; 
    imageUrl: string | null;
    allergens: string[]; 
    tags: string[]; 
    isAvailable: boolean;
    position: number;
    preparationTime: number | null;
    calories: number | null;
    kdsDestination: string | null;
    categoryId: string;
    businessId: string;
    trackInventory: boolean;
    stockQuantity: number | null;
    createdAt: string; 
    updatedAt: string; 
}

interface OrderInfoForKdsPatchResponse {
    id: string;
    orderNumber: string;
    status: AppOrderStatus; 
    totalAmount: string; 
    discountAmount: string | null; 
    finalAmount: string; 
    notes: string | null;
    source: string | null; 
    tableId: string | null;
    customerLCoId: string | null;
    waiterId: string | null;
    businessId: string;
    createdAt: string; 
    updatedAt: string; 
    confirmedAt: string | null; 
    billedAt: string | null; 
    paidAt: string | null; 
    orderType: string; 
    paymentMethodPreference: string | null;
    amountToPayWith: string | null; 
    paymentIntentId: string | null;
    paymentProvider: string | null;
    deliveryAddressJson: string | null; 
    deliveryFee: string | null; 
    estimatedDeliveryTime: string | null; 
    appliedLcoRewardId: string | null;
    appliedLcoRewardDiscountAmount: string | null; 
    appliedLcoTierBenefitDiscountAmount: string | null; 
}

export interface FullOrderItemKdsResponse {
    id: string;
    quantity: number;
    priceAtPurchase: string; 
    totalItemPrice: string; 
    notes: string | null;
    status: AppOrderItemStatus; 
    kdsDestination: string | null;
    orderId: string;
    menuItemId: string;
    itemNameSnapshot: string | null;
    itemDescriptionSnapshot: string | null;
    servedById: string | null;
    preparedAt: string | null; 
    servedAt: string | null; 
    cancellationReason: string | null;
    createdAt: string; 
    updatedAt: string; 
    order: OrderInfoForKdsPatchResponse;
    menuItem: MenuItemInfoForKdsPatchResponse;
    selectedModifiers: SelectedModifierInfo[];
}

// --- CAMBIO: Definir solo la ruta relativa ---
const KDS_API_PATH = '/camarero/kds'; 
// --- FIN CAMBIO ---

export const getItemsForKds = async (
    destination: string,
    statusValues?: AppOrderItemStatus[]
): Promise<KdsListItem[]> => {
    try {
        const params: Record<string, string | string[]> = { destination: destination.toUpperCase() };
        if (statusValues && statusValues.length > 0) {
            params.status = statusValues; 
        }
        // --- CAMBIO: Usar solo la ruta relativa ---
        const response = await axiosInstance.get<KdsListItem[]>(`${KDS_API_PATH}/items`, { params });
        // --- FIN CAMBIO ---
        console.log('[kdsService.getItemsForKds] Raw response data:', response.data);
        return response.data;
    } catch (error) {
        console.error('[kdsService.getItemsForKds] Error fetching KDS items:', error);
        throw error;
    }
};

export const updateOrderItemKdsStatus = async (
    orderItemId: string,
    newStatus: AppOrderItemStatus
): Promise<FullOrderItemKdsResponse> => { 
    try {
        // --- CAMBIO: Usar solo la ruta relativa ---
        const response = await axiosInstance.patch<FullOrderItemKdsResponse>(
            `${KDS_API_PATH}/items/${orderItemId}/status`,
            { newStatus } 
        );
        // --- FIN CAMBIO ---
        console.log('[kdsService.updateOrderItemKdsStatus] Raw response data:', response.data);
        return response.data;
    } catch (error) {
        console.error(`[kdsService.updateOrderItemKdsStatus] Error updating KDS order item ${orderItemId} status:`, error);
        throw error;
    }
};


// ====== [74] frontend/src/modules/camarero/services/publicOrderApiService.ts ======
// frontend/src/services/publicOrderApiService.ts
// Version 1.1.2 (Fix property name from orderNotes to customerNotes in payload)

import axios from 'axios';
import {
    CreateOrderPayloadDto,
    AddItemsToOrderPayloadDto,
    BackendOrderResponse,
    OrderItemFE,
} from '../types/publicOrder.types';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL_PUBLIC || 'http://localhost:3000/public';

const getProcessedNotesValue = (notesInput: string | null | undefined): string | null => {
    if (notesInput === null || notesInput === undefined) return null;
    const trimmed = notesInput.trim();
    return trimmed === "" ? null : trimmed;
};

export const submitNewOrder = async (
    businessSlug: string,
    payload: CreateOrderPayloadDto
): Promise<BackendOrderResponse> => {
    try {
        const response = await axios.post<BackendOrderResponse>(`${API_BASE_URL}/order/${businessSlug}`, payload);
        return response.data;
    } catch (error) {
        console.error(`[PublicOrderApiService] Error submitting NEW order for slug ${businessSlug}:`, error);
        throw error;
    }
};

export const addItemsToExistingOrderApi = async (
    orderId: string,
    businessSlug: string,
    payload: AddItemsToOrderPayloadDto
): Promise<BackendOrderResponse> => {
    try {
        const headers: Record<string, string> = { 'Content-Type': 'application/json' };
        if (businessSlug) {
            headers['x-loyalpyme-business-slug'] = businessSlug;
        }
        const response = await axios.post<BackendOrderResponse>(
            `${API_BASE_URL}/order/${orderId}/items`,
            payload,
            { headers }
        );
        return response.data;
    } catch (error) {
        console.error(`[PublicOrderApiService] Error adding items to order ${orderId}:`, error);
        throw error;
    }
};

export const handleOrderSubmission = async (
    cartItems: OrderItemFE[],
    generalOrderNotes: string,
    activeOrderId: string | null,
    businessSlug: string,
    tableIdentifier?: string
): Promise<BackendOrderResponse> => {

    const dtoItems = cartItems.map(feItem => ({
        menuItemId: feItem.menuItemId,
        quantity: feItem.quantity,
        notes: getProcessedNotesValue(feItem.notes),
        selectedModifierOptions: feItem.selectedModifiers.length > 0
            ? feItem.selectedModifiers.map(sm => ({ modifierOptionId: sm.modifierOptionId }))
            : [],
    }));

    let customerIdForPayload: string | null = null;
    const storedUser = localStorage.getItem('user');
    if (storedUser) {
        try {
            const parsedUser = JSON.parse(storedUser);
            if (parsedUser?.id && parsedUser.role === 'CUSTOMER_FINAL') {
                customerIdForPayload = parsedUser.id;
            }
        } catch (e) {
            console.error("Error parsing user from localStorage for order submission:", e);
        }
    }

    if (activeOrderId) {
        const payloadForAdd: AddItemsToOrderPayloadDto = {
            items: dtoItems,
            customerNotes: getProcessedNotesValue(generalOrderNotes),
        };
        const response = await addItemsToExistingOrderApi(activeOrderId, businessSlug, payloadForAdd);
        return { ...response, id: activeOrderId };
    } else {
        const payloadForCreate: CreateOrderPayloadDto = {
            items: dtoItems,
            // --- CORRECCI√ìN AQU√ç: Cambiar 'orderNotes' por 'customerNotes' ---
            customerNotes: getProcessedNotesValue(generalOrderNotes),
            // --- FIN CORRECCI√ìN ---
            tableIdentifier: tableIdentifier || null,
            customerId: customerIdForPayload,
        };
        return submitNewOrder(businessSlug, payloadForCreate);
    }
};


// ====== [75] frontend/src/modules/camarero/services/waiterService.ts ======
// frontend/src/services/waiterService.ts
// Version: 1.0.0 (Initial service for waiter actions: get ready items, mark as served)

import axiosInstance from '../../../shared/services/axiosInstance'; // Nuestra instancia de Axios configurada con interceptor de token
import { ReadyPickupItem, OrderItemStatusUpdateResponse } from '../types/camarero.types'; // Tipos que definimos antes
import { OrderItemStatus } from '../../../shared/types/user.types';

const WAITER_STAFF_API_BASE = '/camarero/staff'; // Prefijo base para las rutas de este servicio

/**
 * Obtiene la lista de √≠tems de pedido que est√°n listos para ser recogidos.
 * Llama a GET /api/camarero/staff/ready-for-pickup
 * @returns Una promesa que resuelve con un array de ReadyPickupItem.
 */
export const getReadyForPickupItems = async (): Promise<ReadyPickupItem[]> => {
    console.log('[WaiterService] Fetching items ready for pickup...');
    try {
        const response = await axiosInstance.get<ReadyPickupItem[]>(`${WAITER_STAFF_API_BASE}/ready-for-pickup`);
        console.log(`[WaiterService] Successfully fetched ${response.data?.length || 0} ready items.`);
        return response.data || []; // Devolver array vac√≠o si no hay datos
    } catch (error) {
        // El error ya deber√≠a ser manejado y logueado por el interceptor de axiosInstance,
        // pero podemos a√±adir un log espec√≠fico aqu√≠ si es necesario.
        console.error("[WaiterService] Error fetching ready for pickup items:", error);
        // Relanzar para que el hook o componente que llama pueda manejarlo (ej. mostrar UI de error)
        throw error; 
    }
};

/**
 * Marca un OrderItem espec√≠fico como SERVED.
 * Llama a PATCH /api/camarero/staff/order-items/:orderItemId/status
 * @param orderItemId - El ID del OrderItem a actualizar.
 * @returns Una promesa que resuelve con la respuesta del backend (OrderItemStatusUpdateResponse).
 */
export const markOrderItemAsServed = async (orderItemId: string): Promise<OrderItemStatusUpdateResponse> => {
    console.log(`[WaiterService] Marking order item ${orderItemId} as SERVED...`);
    try {
        // El backend espera un payload: { newStatus: "SERVED" }
        const payload = { newStatus: OrderItemStatus.SERVED }; 

        const response = await axiosInstance.patch<OrderItemStatusUpdateResponse>(
            `${WAITER_STAFF_API_BASE}/order-items/${orderItemId}/status`,
            payload
        );
        console.log(`[WaiterService] Successfully marked item ${orderItemId} as SERVED. Response:`, response.data);
        return response.data;
    } catch (error) {
        console.error(`[WaiterService] Error marking order item ${orderItemId} as served:`, error);
        throw error;
    }
};


// ====== [76] frontend/src/modules/camarero/types/camarero.types.ts ======
// frontend/src/types/camarero.types.ts
// Version: 1.1.0 (Add WaiterOrderListItemDto and import OrderType)

// Aseg√∫rate de que OrderItemStatus, OrderStatus y OrderType se importan correctamente.
import { OrderItemStatus, OrderStatus, OrderType } from './customer'; // OrderType a√±adido al import

/**
 * DTO para la informaci√≥n de un modificador seleccionado que se muestra al camarero.
 */
export interface WaiterSelectedModifier { // Renombrado desde WaiterSelectedModifierDto para consistencia
  optionName_es: string | null;
  optionName_en: string | null;
}

/**
 * DTO para cada √≠tem de pedido que est√° listo para ser recogido y servido por el camarero.
 */
export interface ReadyPickupItem { // Renombrado desde ReadyPickupItemDto
  orderItemId: string;
  orderId: string;
  orderNumber: string;
  orderCreatedAt: Date; // Cambiado a Date, el servicio backend devuelve Date, la serializaci√≥n JSON lo convierte
  tableIdentifier: string | null;
  itemNameSnapshot_es: string | null;
  itemNameSnapshot_en: string | null;
  quantity: number;
  itemNotes: string | null;
  kdsDestination: string | null;
  selectedModifiers: WaiterSelectedModifier[];
  currentOrderItemStatus: OrderItemStatus;
}

/**
 * DTO para la respuesta del backend al actualizar el estado de un OrderItem
 * desde la interfaz de camarero o KDS.
 */
export interface OrderItemStatusUpdateResponse { // Renombrado desde OrderItemStatusUpdateResponseDto
  message: string;
  orderItemId: string;
  newStatus: OrderItemStatus;
  orderStatus?: OrderStatus;
}

// ---- NUEVO DTO A√ëADIDO ----
/**
 * DTO para representar un √≠tem en la lista de pedidos para la interfaz del camarero.
 * Usado en: GET /api/camarero/staff/orders (respuesta del backend)
 */
export interface WaiterOrderListItemDto {
  orderId: string;
  orderNumber: string;
  tableIdentifier: string | null;
  status: OrderStatus;
  finalAmount: number; // El servicio ya lo convierte a n√∫mero
  itemCount: number;
  customerName?: string | null;
  createdAt: Date; // El servicio devuelve Date, la serializaci√≥n JSON lo convierte
  isBillRequested?: boolean;
  orderType?: OrderType | null;
}
// ---- FIN NUEVO DTO ----


// ====== [77] frontend/src/modules/camarero/types/menu.types.ts ======
// frontend/src/types/menu.types.ts
// Version: (tu versi√≥n existente + tipos para men√∫ p√∫blico)

// --- MENU CATEGORY (Existente) ---
export interface MenuCategoryData {
  id: string;
  businessId: string; 
  name_es: string;
  name_en: string | null;
  description_es?: string | null;
  description_en?: string | null;
  imageUrl?: string | null;
  position: number;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  items?: MenuItemData[]; // Opcional para cargas anidadas
}

export interface MenuCategoryFormData {
  name_es: string;
  name_en: string | null;
  description_es?: string | null;
  description_en?: string | null;
  imageUrl?: string | null;
  position: number;
  isActive: boolean;
}

// --- MENU ITEM (Existente) ---
export interface MenuItemData {
  id: string;
  categoryId: string;
  businessId: string;
  name_es: string;
  name_en: string | null;
  description_es: string | null;
  description_en: string | null;
  price: number; 
  imageUrl: string | null;
  allergens: string[];
  tags: string[];
  isAvailable: boolean;
  position: number;
  preparationTime: number | null;
  calories: number | null;
  kdsDestination: string | null;
  sku: string | null;
  createdAt: string;
  updatedAt: string;
  modifierGroups?: ModifierGroupData[]; // MODIFICADO: A√±adido ? para que sea opcional si no se carga siempre
}

export interface MenuItemFormData {
  name_es: string;
  name_en: string | null;
  description_es: string | null;
  description_en: string | null;
  price: number; 
  imageUrl: string | null;
  allergens: string[];
  tags: string[];
  isAvailable: boolean;
  position: number;
  preparationTime?: number | null;
  calories?: number | null;
  kdsDestination?: string | null;
  sku?: string | null;
}

// --- MODIFIER GROUP (Existente) ---
export enum ModifierUiType {
    RADIO = 'RADIO',
    CHECKBOX = 'CHECKBOX',
}

export interface ModifierGroupData {
  id: string;
  menuItemId: string;
  businessId: string;
  name_es: string;
  name_en: string | null;
  uiType: ModifierUiType;
  minSelections: number;
  maxSelections: number;
  position: number;
  isRequired: boolean;
  options?: ModifierOptionData[];
  createdAt: string;
  updatedAt: string;
}

export interface ModifierGroupFormData {
  name_es: string;
  name_en: string | null;
  uiType: ModifierUiType;
  minSelections: number;
  maxSelections: number;
  position: number;
  isRequired: boolean;
}


// --- MODIFIER OPTION (Existente) ---
export interface ModifierOptionData {
  id: string;
  groupId: string;
  name_es: string;
  name_en: string | null;
  priceAdjustment: number;
  position: number;
  isDefault: boolean;
  isAvailable: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface ModifierOptionFormData {
  name_es: string;
  name_en: string | null;
  priceAdjustment: number;
  position: number;
  isDefault: boolean;
  isAvailable: boolean;
}

// --- Tipos para la Visualizaci√≥n P√∫blica del Men√∫ (NUEVOS) ---
export interface PublicMenuModifierOption {
    id: string;
    name_es: string | null;
    name_en: string | null;
    priceAdjustment: number; // En frontend, esperamos un n√∫mero.
    position: number;
    isDefault: boolean;
    isAvailable: boolean;
}

export interface PublicMenuModifierGroup {
    id: string;
    name_es: string | null;
    name_en: string | null;
    uiType: ModifierUiType; // Reutilizamos el enum existente
    minSelections: number;
    maxSelections: number;
    isRequired: boolean;
    position: number;
    options: PublicMenuModifierOption[];
}

export interface PublicMenuItem {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    price: number; // En frontend, esperamos un n√∫mero.
    imageUrl: string | null;
    allergens: string[];
    tags: string[];
    position: number;
    modifierGroups: PublicMenuModifierGroup[];
}

export interface PublicMenuCategory {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    imageUrl: string | null;
    position: number;
    items: PublicMenuItem[];
}

export interface PublicDigitalMenuData {
    businessName: string;
    businessSlug: string;
    businessLogoUrl: string | null;
    categories: PublicMenuCategory[];
}


// ====== [78] frontend/src/modules/camarero/types/publicOrder.types.ts ======
// frontend/src/types/publicOrder.types.ts
// Version: 1.0.5 (Correct property name from orderNotes to customerNotes)

import { PublicMenuItem } from './menu.types';

// --- Tipos para el Frontend del Carrito y Configuraci√≥n de √çtems ---
export interface SelectedModifierFE {
    modifierOptionId: string;
    name_es?: string | null;
    name_en?: string | null;
    priceAdjustment: number;
    modifierGroupName_es?: string | null;
    modifierGroupName_en?: string | null;
}

export interface OrderItemFE {
    cartItemId: string;
    menuItemId: string;
    menuItemName_es: string | null;
    menuItemName_en: string | null;
    quantity: number;
    basePrice: number;
    currentPricePerUnit: number;
    totalPriceForItem: number;
    notes?: string | null;
    selectedModifiers: SelectedModifierFE[];
}

export interface ConfiguringItemState {
    itemDetails: PublicMenuItem;
    quantity: number;
    selectedOptionsByGroup: Record<string, string[] | string>;
    currentUnitPrice: number;
    itemNotes: string;
    areModifiersValid: boolean;
}

// --- Tipos para los DTOs de la API (Payloads para el Backend) ---
export interface CreateOrderItemModifierDto {
    modifierOptionId: string;
}

export interface CreateOrderItemDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: CreateOrderItemModifierDto[] | null;
}

export interface CreateOrderPayloadDto {
    tableIdentifier?: string | null;
    customerId?: string | null;
    // --- CORRECCI√ìN AQU√ç ---
    customerNotes: string | null; // Antes era orderNotes
    // --- FIN CORRECCI√ìN ---
    items: CreateOrderItemDto[];
    businessId?: string;
}

export interface AddItemsToOrderPayloadDto {
    items: CreateOrderItemDto[];
    customerNotes: string | null;
}

// --- Tipos para las Respuestas de la API de Pedidos ---
export interface BackendOrderResponse {
    id: string;
    orderNumber?: string | null;
}

// --- Tipos para la Gesti√≥n del Pedido Activo en localStorage ---
export interface ActiveOrderInfo {
    orderId: string;
    orderNumber: string;
    businessSlug: string;
    tableIdentifier?: string;
    savedAt: number;
}


// ====== [79] frontend/src/shared/components/PrivateRoute.tsx ======
// frontend/src/shared/components/PrivateRoute.tsx (CORREGIDO)
import React from 'react';
import { Navigate, Outlet, useLocation } from 'react-router-dom';

// --- RUTA Y NOMBRE CORREGIDOS ---
import { UserRole } from '../types/user.types';
// --- FIN CORRECCI√ìN ---


interface PrivateRouteProps {
  allowedRoles?: UserRole[];
  children?: React.ReactNode;
}

function PrivateRoute({ allowedRoles, children }: PrivateRouteProps) {
  const location = useLocation();

  const token = localStorage.getItem('token');
  if (!token) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  const userJson = localStorage.getItem('user');
  let user = null;
  try {
      if(userJson) user = JSON.parse(userJson);
  } catch (e) {
      console.error("[PrivateRoute] Failed to parse user from localStorage", e);
      localStorage.removeItem('token');
      localStorage.removeItem('user');
      return <Navigate to="/login" state={{ from: location }} replace />;
  }

  if (!user || (allowedRoles && allowedRoles.length > 0 && (!user.role || !allowedRoles.includes(user.role as UserRole)))) {
    const fallbackPath = user?.role === UserRole.BUSINESS_ADMIN ? '/admin/dashboard'
                       : user?.role === UserRole.CUSTOMER_FINAL ? '/customer/dashboard'
                       : user?.role === UserRole.SUPER_ADMIN ? '/superadmin'
                       // --- A√ëADIDO: Redirecci√≥n para roles de staff ---
                       : user?.role === UserRole.WAITER ? '/admin/camarero/pickup'
                       : user?.role === UserRole.KITCHEN_STAFF || user.role === UserRole.BAR_STAFF ? '/admin/kds'
                       // --- FIN A√ëADIDO ---
                       : '/login';
    return <Navigate to={fallbackPath} replace />;
  }

  return <>{children || <Outlet />}</>;
}

export default PrivateRoute;


// ====== [80] frontend/src/shared/components/layout/AdminNavbar.tsx ======
// frontend/src/components/layout/AdminNavbar.tsx
// Version: 1.2.1 (Add debug logs for WAITER role)

import React from 'react';
import { Link } from 'react-router-dom';
import { NavLink } from '@mantine/core';
import {
    IconGauge,
    IconGift,
    IconQrcode,
    IconUsers,
    IconStairsUp,
    IconSettings,
    IconToolsKitchen,
    IconClipboardText,
    IconFileInvoice
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import type { UserData } from '../../../shared/types/user.types';
import { UserRole } from '../../../shared/types/user.types';

interface AdminNavbarProps {
    pathname: string;
    closeNavbar: () => void;
    userData: UserData | null;
}

const AdminNavbar: React.FC<AdminNavbarProps> = ({ pathname, closeNavbar, userData }) => {
    const { t } = useTranslation();

    // ---- DEBUG LOG ----
    // Loguear siempre que userData cambie o el componente se renderice con userData
    if (userData) {
        console.log("[AdminNavbar DEBUG] UserData received in props:", JSON.stringify(userData, null, 2));
        console.log(`[AdminNavbar DEBUG] Current Role: ${userData.role}, IsCamareroActive: ${userData.isCamareroActive}`);

        if (userData.role === UserRole.WAITER) {
            console.log("[AdminNavbar DEBUG - WAITER CONTEXT] Role matches WAITER.");
            const conditionForPickup = userData?.isCamareroActive === true && (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN);
            console.log("[AdminNavbar DEBUG - WAITER CONTEXT] ShowCondition for '/admin/camarero/pickup':", conditionForPickup);

            const conditionForOrders = userData?.isCamareroActive === true && (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN);
            console.log("[AdminNavbar DEBUG - WAITER CONTEXT] ShowCondition for '/admin/camarero/orders':", conditionForOrders);
        }
    } else {
        console.log("[AdminNavbar DEBUG] UserData is null.");
    }
    // ---- FIN DEBUG LOG ----

    const allPossibleNavLinks = [
        {
            to: "/admin/dashboard",
            labelKey: 'adminCommon.dashboard',
            icon: IconGauge,
            showCondition: userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/rewards",
            labelKey: 'adminCommon.rewards',
            icon: IconGift,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/generate-qr",
            labelKey: 'adminCommon.generateQr',
            icon: IconQrcode,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/customers",
            labelKey: 'adminCommon.customers',
            icon: IconUsers,
            showCondition: (userData?.isLoyaltyCoreActive === true || userData?.isCamareroActive === true) && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/tiers/manage",
            labelKey: 'adminCommon.manageTiers',
            icon: IconStairsUp,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/tiers/settings",
            labelKey: 'adminCommon.tierSettings',
            icon: IconSettings,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/camarero/menu-editor",
            labelKey: 'adminCamarero.manageMenu.title',
            icon: IconToolsKitchen,
            showCondition: userData?.isCamareroActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/camarero/pickup",
            labelKey: 'waiterInterface.navLinkPickup',
            icon: IconClipboardText,
            showCondition: userData?.isCamareroActive === true &&
                           (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN)
        },
        {
            to: "/admin/camarero/orders",
            labelKey: 'waiterOrderManagement.navLinkTitle',
            icon: IconFileInvoice,
            showCondition: userData?.isCamareroActive === true &&
                           (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN)
        },
    ];

    const navLinksToShow = allPossibleNavLinks.filter(link => link.showCondition);
    
    // ---- DEBUG LOG ----
    if (userData?.role === UserRole.WAITER) {
      console.log("[AdminNavbar DEBUG - WAITER CONTEXT] Final navLinksToShow for WAITER:", navLinksToShow.map(l => ({ to: l.to, labelKey: l.labelKey })));
    }
    // ---- FIN DEBUG LOG ----


    return (
        <>
            {navLinksToShow.map((link) => (
                <NavLink
                    key={link.to}
                    label={t(link.labelKey)}
                    leftSection={<link.icon size="1rem" stroke={1.5} />}
                    component={Link}
                    to={link.to}
                    active={pathname.startsWith(link.to) && (pathname === link.to || pathname.startsWith(link.to + '/'))}
                    onClick={closeNavbar}
                />
            ))}
        </>
    );
};

export default AdminNavbar;


// ====== [81] frontend/src/shared/components/layout/AppHeader.tsx ======
// frontend/src/components/layout/AppHeader.tsx
// Version: 1.6.2 (Use full UserRole enum for LayoutUserData)

import React from 'react';
import {
    Group, Burger, Skeleton, Button, Menu, UnstyledButton, Box, Text,
    Container
} from '@mantine/core';
import {
    IconUserCircle,
    IconLogout,
    IconChevronDown,
} from '@tabler/icons-react';
import { useDisclosure } from '@mantine/hooks';
import { useTranslation } from 'react-i18next';
import ReactCountryFlag from 'react-country-flag';
import { Link } from 'react-router-dom';

// ---- MODIFICACI√ìN: Importar UserRole ----
import { UserRole } from '../../../shared/types/user.types'; // Aseg√∫rate que la ruta es correcta

// Interfaz LayoutUserData MODIFICADA
interface LayoutUserData {
    id: string;
    name?: string | null;
    email: string;
    role: UserRole; // <--- CAMBIADO A USAR EL ENUM UserRole COMPLETO
}
// ---- FIN MODIFICACI√ìN ----

interface AppHeaderProps {
    userData: LayoutUserData | null; // Ahora espera el enum UserRole
    loadingUser: boolean;
    handleLogout: () => void;
    navbarOpened?: boolean;
    toggleNavbar?: () => void;
    showAdminNavbar?: boolean;
}

// Componente Logo (sin cambios)
const Logo: React.FC<{ homePath: string }> = ({ homePath }) => (
    <Link
        to={homePath}
        style={{ textDecoration: 'none', color: 'inherit', display: 'flex', alignItems: 'center' }}
        aria-label={homePath === "/" || homePath === "/login" ? "Ir a la p√°gina de inicio de sesi√≥n" : "Ir a mi panel principal"}
    >
        <img
            src="/loyalpymelogo.jpg"
            alt="LoyalPyME Logo"
            style={{ height: '40px', width: 'auto', display: 'block' }}
        />
    </Link>
);

const AppHeader: React.FC<AppHeaderProps> = ({
    userData, loadingUser, handleLogout, navbarOpened, toggleNavbar, showAdminNavbar = false,
}) => {
    const { i18n, t } = useTranslation();
    const [mobileMenuOpened, { toggle: toggleMobileMenu, close: closeMobileMenu }] = useDisclosure(false);

    let logoLinkPath = "/";

    if (userData) {
        // La l√≥gica de redirecci√≥n aqu√≠ ya usa el enum UserRole, lo cual es bueno
        if (userData.role === UserRole.CUSTOMER_FINAL) {
            logoLinkPath = "/customer/dashboard";
        } else if (userData.role === UserRole.BUSINESS_ADMIN) {
            logoLinkPath = "/admin/dashboard";
        } else if (userData.role === UserRole.SUPER_ADMIN) {
            logoLinkPath = "/superadmin";
        // ---- A√ëADIR CASOS PARA NUEVOS ROLES DE STAFF SI QUIERES QUE EL LOGO LOS LLEVE A SU P√ÅGINA ----
        } else if (userData.role === UserRole.WAITER) {
            logoLinkPath = "/admin/camarero/pickup"; // O a /admin/camarero/orders
        } else if (userData.role === UserRole.KITCHEN_STAFF || userData.role === UserRole.BAR_STAFF) {
            logoLinkPath = "/admin/kds";
        }
        // ---- FIN A√ëADIR CASOS ----
    }

    const changeLanguage = (lang: string) => { i18n.changeLanguage(lang); closeMobileMenu(); };
    const currentCountryCode = i18n.resolvedLanguage === 'es' ? 'ES' : 'GB';
    const languages = [ { code: 'es', name: 'Espa√±ol', country: 'ES' }, { code: 'en', name: 'English', country: 'GB' }, ];

    const onLogoutClick = () => {
        handleLogout();
        closeMobileMenu();
    };

    const LogoutButtonInternal = () => ( <Button onClick={onLogoutClick} variant="light" color="red" size="sm" leftSection={<IconLogout size={16}/>}>{t('header.logoutButton')}</Button> );

    const LanguageSwitcherDesktop = () => (
         <Menu shadow="md" width={150} trigger="hover" openDelay={100} closeDelay={200}>
            <Menu.Target>
                 <UnstyledButton style={{ display: 'flex', alignItems: 'center', padding: '5px', borderRadius: 'var(--mantine-radius-sm)'}}>
                    <ReactCountryFlag countryCode={currentCountryCode} svg style={{ display: 'block', width: '1.4em', height: '1.4em' }} aria-label={currentCountryCode} />
                    <IconChevronDown size={16} stroke={1.5} style={{ marginLeft: '4px', color: 'var(--mantine-color-dimmed)' }} />
                 </UnstyledButton>
            </Menu.Target>
            <Menu.Dropdown>
                <Menu.Label>{t('header.languageLabel')}</Menu.Label>
                {languages.map((lang) => ( <Menu.Item key={lang.code} leftSection={<ReactCountryFlag countryCode={lang.country} svg style={{ fontSize: '1.1em', display:'block' }} />} onClick={() => changeLanguage(lang.code)} disabled={i18n.resolvedLanguage === lang.code}>{lang.name}</Menu.Item> ))}
            </Menu.Dropdown>
        </Menu>
    );

    return (
        <Box component="header" h="100%">
            <Container size="lg" h="100%" style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                <Group gap="xs">
                    {showAdminNavbar && toggleNavbar && ( <Burger opened={navbarOpened ?? false} onClick={toggleNavbar} hiddenFrom="sm" size="sm"/> )}
                    <Logo homePath={logoLinkPath} />
                </Group>

                {loadingUser ? ( <Skeleton height={30} width={120} /> )
                 : userData ? (
                    <Group gap="sm">
                        <Group visibleFrom="sm" gap="sm">
                            <Text size="sm" truncate>
                                <IconUserCircle size={18} style={{ verticalAlign: 'middle', marginRight: '4px' }} />
                                {t('header.greeting', { name: userData.name || userData.email })}
                            </Text>
                            <LanguageSwitcherDesktop />
                            <LogoutButtonInternal />
                        </Group>
                         <Box hiddenFrom="sm">
                             <Menu shadow="md" width={200} opened={mobileMenuOpened} onChange={toggleMobileMenu} position="bottom-end">
                                <Menu.Target>
                                     <Burger opened={mobileMenuOpened} onClick={toggleMobileMenu} aria-label={t('header.toggleNavigation', 'Toggle navigation')} size="sm"/>
                                </Menu.Target>
                                <Menu.Dropdown>
                                     <Menu.Label>{userData.name || userData.email}</Menu.Label>
                                    <Menu.Divider />
                                    <Menu.Label>{t('header.languageLabel')}</Menu.Label>
                                    {languages.map((lang) => (
                                        <Menu.Item key={lang.code} leftSection={<ReactCountryFlag countryCode={lang.country} svg style={{ fontSize: '1.1em', display:'block' }} />} onClick={() => changeLanguage(lang.code)} disabled={i18n.resolvedLanguage === lang.code}>
                                            {lang.name}
                                         </Menu.Item>
                                    ))}
                                    <Menu.Divider />
                                     <Menu.Item color="red" leftSection={<IconLogout size={14} />} onClick={onLogoutClick}>
                                         {t('header.logoutButton')}
                                     </Menu.Item>
                                </Menu.Dropdown>
                            </Menu>
                         </Box>
                    </Group>
                ) : (
                    <Group>
                        <LanguageSwitcherDesktop />
                    </Group>
                )}
            </Container>
        </Box>
    );
};

export default AppHeader;


// ====== [82] frontend/src/shared/components/layout/MainLayout.tsx ======
// frontend/src/components/layout/MainLayout.tsx
// Version 1.0.1 (Correct logic for showing AdminNavbar for WAITER and other staff roles)

import React from 'react';
import { Outlet, useLocation } from 'react-router-dom';
import { AppShell } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { useLayoutUserData } from '../../hooks/useLayoutUserData';
import AppHeader from './AppHeader';
import AdminNavbar from './AdminNavbar';
import { UserRole } from '../../types/user.types';

const MainLayout: React.FC = () => {
    const { userData, loadingUser, handleLogout } = useLayoutUserData();
    const location = useLocation();
    const [navbarOpened, { toggle: toggleNavbar, close: closeNavbar }] = useDisclosure();

    // ---- L√ìGICA MODIFICADA PARA MOSTRAR AdminNavbar ----
    // Determinar si la ruta actual es una ruta de "admin" en general
    const isAnyAdminRoute = location.pathname.startsWith('/admin/');

    // Definir qu√© roles deben ver la AdminNavbar en las rutas /admin/*
    const rolesThatSeeAdminNavbar: UserRole[] = [
        UserRole.BUSINESS_ADMIN,
        UserRole.WAITER,
        UserRole.KITCHEN_STAFF,
        UserRole.BAR_STAFF
        // SUPER_ADMIN tiene su propia ruta /superadmin y no usa esta navbar
    ];

    // AdminNavbar se muestra si el usuario tiene uno de los roles permitidos Y est√° en una ruta /admin/*
    const showAdminNavbar = userData?.role &&
                            rolesThatSeeAdminNavbar.includes(userData.role) &&
                            isAnyAdminRoute;
    // ---- FIN L√ìGICA MODIFICADA ----


    // Debug log para la condici√≥n de la navbar
    // console.log(`[MainLayout] Path: ${location.pathname}, Role: ${userData?.role}, isAnyAdminRoute: ${isAnyAdminRoute}, showAdminNavbar: ${showAdminNavbar}`);

    return (
        <AppShell
            header={{ height: 60 }}
            navbar={{
                width: 250,
                breakpoint: 'sm',
                // Mostrar/ocultar navbar si showAdminNavbar es true y navbarOpened es true (para m√≥vil)
                collapsed: { mobile: !navbarOpened || !showAdminNavbar, desktop: !showAdminNavbar }
            }}
            padding="md"
        >
            <AppShell.Header>
                <AppHeader
                    userData={userData}
                    loadingUser={loadingUser}
                    handleLogout={handleLogout}
                    navbarOpened={navbarOpened}
                    toggleNavbar={toggleNavbar}
                    // El burger del header debe aparecer si showAdminNavbar es true,
                    // independientemente de si la navbar est√° colapsada o no en desktop.
                    showAdminNavbar={showAdminNavbar}
                />
            </AppShell.Header>

            {/* Mostrar AdminNavbar solo si showAdminNavbar es true */}
            {showAdminNavbar && (
                <AppShell.Navbar p="md">
                    <AdminNavbar
                        pathname={location.pathname}
                        closeNavbar={closeNavbar}
                        userData={userData}
                    />
                </AppShell.Navbar>
            )}

            <AppShell.Main>
                <Outlet />
            </AppShell.Main>
        </AppShell>
    );
};

export default MainLayout;


// ====== [83] frontend/src/shared/components/layout/PublicLayout.tsx ======
// filename: frontend/src/components/layout/PublicLayout.tsx
// Nuevo layout simple para p√°ginas p√∫blicas, solo incluye el Header.

import React from 'react';
import { Outlet } from 'react-router-dom';
import { AppShell } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks'; // Necesario para AppHeader
import { useLayoutUserData } from '../../hooks/useLayoutUserData'; // Necesario para AppHeader
import AppHeader from './AppHeader'; // Importamos el header existente

const PublicLayout: React.FC = () => {
    // Necesitamos obtener los datos y el estado de la navbar para pasarlos al AppHeader
    const { userData, loadingUser, handleLogout } = useLayoutUserData();
    // Aunque no mostramos la navbar aqu√≠, AppHeader necesita el estado y el toggle para el Burger en m√≥vil
    const [navbarOpened, { toggle: toggleNavbar }] = useDisclosure();

    return (
        <AppShell
            header={{ height: 60 }}
            // NO definimos navbar aqu√≠
            padding="md" // Mantenemos padding general
        >
            {/* Cabecera (la misma que en MainLayout) */}
            <AppShell.Header>
                <AppHeader
                    userData={userData}
                    loadingUser={loadingUser}
                    handleLogout={handleLogout}
                    navbarOpened={navbarOpened}
                    toggleNavbar={toggleNavbar}
                    showAdminNavbar={false} // Nunca mostramos navbar admin en layout p√∫blico
                />
            </AppShell.Header>

            {/* Contenido principal de la p√°gina p√∫blica actual */}
            <AppShell.Main>
                <Outlet /> {/* Aqu√≠ se renderiza LoginPage, RegisterPage, etc. */}
            </AppShell.Main>
        </AppShell>
    );
};

export default PublicLayout;

// End of File: frontend/src/components/layout/PublicLayout.tsx


// ====== [84] frontend/src/shared/components/utils/ImageUploadCropper.tsx ======
// frontend/src/components/utils/ImageUploadCropper.tsx
// Version 1.1.0 (Set default crop to 100% width)

import React, { useState, useRef, SyntheticEvent, useEffect } from 'react';
import {
    FileInput, Button, Group, AspectRatio, Image as MantineImage,
    Center, Text, Alert, Box, Stack, LoadingOverlay
} from '@mantine/core';
import {
    IconUpload, IconPhoto, IconX, IconAlertCircle, IconCrop, IconCameraRotate
} from '@tabler/icons-react';
import ReactCrop, {
    centerCrop,
    makeAspectCrop,
    type Crop,
    type PixelCrop,
} from 'react-image-crop';
import 'react-image-crop/dist/ReactCrop.css';
import { canvasPreview, canvasToBlob } from '../utils/canvasPreview';
import { useTranslation } from 'react-i18next';
import axiosInstance from '../../services/axiosInstance';

export interface ImageUploadCropperProps {
    aspectRatio: number;
    minDimension: number;
    outputWidth?: number;
    outputHeight?: number;
    initialImageUrl: string | null;
    onUploadSuccess: (imageUrl: string) => void;
    onUploadError: (errorMessage: string) => void;
    onClearImage: () => void;
    folderName?: string;
    disabled?: boolean;
    selectImageButtonLabel?: string;
    confirmCropButtonLabel?: string;
    removeImageButtonLabel?: string;
    cropInstructionsLabel?: string;
    imagePreviewAltText?: string;
    imageToCropAltText?: string;
}

const DEFAULT_CLOUDINARY_FOLDER = 'loyalpyme/uploads';

const ImageUploadCropper: React.FC<ImageUploadCropperProps> = ({
    aspectRatio,
    minDimension,
    outputWidth,
    outputHeight,
    initialImageUrl,
    onUploadSuccess,
    onUploadError,
    onClearImage,
    folderName = DEFAULT_CLOUDINARY_FOLDER,
    disabled = false,
    selectImageButtonLabel,
    confirmCropButtonLabel,
    removeImageButtonLabel,
    cropInstructionsLabel,
    imagePreviewAltText,
    imageToCropAltText,
}) => {
    const { t } = useTranslation();
    const imgRef = useRef<HTMLImageElement>(null);
    const previewCanvasRef = useRef<HTMLCanvasElement>(null);

    const [currentDisplayUrl, setCurrentDisplayUrl] = useState<string | null>(initialImageUrl);
    const [imgSrcForCropper, setImgSrcForCropper] = useState<string>('');
    const [crop, setCrop] = useState<Crop>();
    const [completedCrop, setCompletedCrop] = useState<PixelCrop>();
    const [isUploading, setIsUploading] = useState<boolean>(false);
    const [internalUploadError, setInternalUploadError] = useState<string | null>(null);
    const [selectedFile, setSelectedFile] = useState<File | null>(null);

    useEffect(() => {
        setCurrentDisplayUrl(initialImageUrl);
        if (initialImageUrl && imgSrcForCropper) {
            setImgSrcForCropper('');
            setSelectedFile(null);
            setCrop(undefined);
            setCompletedCrop(undefined);
        }
    }, [initialImageUrl, imgSrcForCropper]);


    const handleFileSelect = (file: File | null) => {
        setInternalUploadError(null);
        setSelectedFile(file);
        if (file) {
            setCrop(undefined);
            setCompletedCrop(undefined);
            setCurrentDisplayUrl(null);
            const reader = new FileReader();
            reader.addEventListener('load', () => {
                setImgSrcForCropper(reader.result?.toString() || '');
            });
            reader.readAsDataURL(file);
        } else {
            setImgSrcForCropper('');
            if (initialImageUrl) {
                setCurrentDisplayUrl(initialImageUrl);
            }
        }
    };

    const onImageLoad = (e: SyntheticEvent<HTMLImageElement>) => {
        const { naturalWidth, naturalHeight } = e.currentTarget;
        setInternalUploadError(null);

        if (naturalWidth < minDimension || naturalHeight < minDimension) {
            const errorMsg = t('common.errorImageTooSmall', { minSize: minDimension });
            setInternalUploadError(errorMsg);
            onUploadError(errorMsg);
            setImgSrcForCropper('');
            setSelectedFile(null);
            return;
        }

        // --- CAMBIO CLAVE: Cambiar width de 90 a 100 para seleccionar todo por defecto ---
        const newCrop = centerCrop(
            makeAspectCrop(
                {
                    unit: '%',
                    width: 100, // <--- ANTES 90, AHORA 100
                },
                aspectRatio,
                naturalWidth,
                naturalHeight
            ),
            naturalWidth,
            naturalHeight
        );
        // --- FIN CAMBIO CLAVE ---
        
        setCrop(newCrop);
        
        if (naturalWidth && naturalHeight) {
             setCompletedCrop({
                 unit: 'px',
                 x: (newCrop.x / 100) * naturalWidth,
                 y: (newCrop.y / 100) * naturalHeight,
                 width: (newCrop.width / 100) * naturalWidth,
                 height: (newCrop.height / 100) * naturalHeight,
             });
        }
    };

    const handleConfirmCropAndUpload = async () => {
        if (!imgRef.current || !previewCanvasRef.current || !completedCrop || completedCrop.width === 0 || completedCrop.height === 0) {
            const errorMsg = t('adminCamarero.menuCategoryForm.errorInvalidCropOrImage');
            setInternalUploadError(errorMsg);
            onUploadError(errorMsg);
            return;
        }
        setIsUploading(true);
        setInternalUploadError(null);
        try {
            const targetWidth = outputWidth || completedCrop.width;
            const targetHeight = outputHeight || completedCrop.height;

            await canvasPreview(
                imgRef.current,
                previewCanvasRef.current,
                completedCrop,
                1, 0,
                targetWidth,
                targetHeight
            );
            const blob = await canvasToBlob(previewCanvasRef.current);

            if (!blob) { throw new Error(t('adminCamarero.menuCategoryForm.errorCreatingCroppedFile')); }
            const formData = new FormData();
            formData.append('image', blob, selectedFile?.name || `cropped-image-${Date.now()}.png`);
            
            // Usamos la carpeta especificada en las props
            const response = await axiosInstance.post<{ url: string }>('/uploads/image', formData, {
                headers: { 'Content-Type': 'multipart/form-data', 'X-Upload-Folder': folderName }
            });

            if (response.data && response.data.url) {
                onUploadSuccess(response.data.url);
                setCurrentDisplayUrl(response.data.url);
                setImgSrcForCropper(''); setSelectedFile(null); setCrop(undefined); setCompletedCrop(undefined);
            } else { throw new Error(t('adminCamarero.menuCategoryForm.errorApiNoUrl')); }
        } catch (err: any) {
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
            const errorMsg = t('adminCamarero.menuCategoryForm.errorUploadingWithDetail', { error: apiError });
            setInternalUploadError(errorMsg);
            onUploadError(errorMsg);
        } finally { setIsUploading(false); }
    };

    const handleRemoveImage = () => {
        setCurrentDisplayUrl(null);
        setImgSrcForCropper('');
        setSelectedFile(null);
        setCrop(undefined);
        setCompletedCrop(undefined);
        setInternalUploadError(null);
        onClearImage();
    };

    const showCropper = !!imgSrcForCropper;
    const effectiveImagePreviewAlt = imagePreviewAltText || t('component.rewardForm.altImagePreview', { name: 'Imagen' });
    const effectiveImageToCropAlt = imageToCropAltText || t('component.rewardForm.altCropImage');

    return (
        <Stack gap="sm">
            <LoadingOverlay visible={isUploading} overlayProps={{ radius: "sm", blur: 2 }} />
            <Text fw={500} size="sm">{t('component.rewardForm.imageLabel')}</Text>
            {!showCropper && (
                <AspectRatio ratio={aspectRatio} maw={300} mx="auto">
                    <Center bg="gray.1" style={{ borderRadius: 'var(--mantine-radius-md)', border: `1px dashed var(--mantine-color-gray-4)` }}>
                        {currentDisplayUrl ? (
                            <MantineImage src={currentDisplayUrl} alt={effectiveImagePreviewAlt} radius="sm" fit="contain" style={{ maxHeight: '100%', maxWidth: '100%' }} fallbackSrc="/placeholder-image.png" />
                        ) : ( <IconPhoto size={48} color="var(--mantine-color-gray-5)" stroke={1.5} /> )}
                    </Center>
                </AspectRatio>
            )}
            {showCropper && (
                <Box mt="xs" style={{ maxWidth: 500, margin: 'auto' }}>
                    <ReactCrop crop={crop} onChange={(_, percentCrop) => setCrop(percentCrop)} onComplete={(c) => setCompletedCrop(c)} aspect={aspectRatio} minWidth={50} minHeight={50 / aspectRatio} >
                        <img ref={imgRef} src={imgSrcForCropper} style={{ display: 'block', maxHeight: '400px', objectFit: 'contain' }} onLoad={onImageLoad} alt={effectiveImageToCropAlt} />
                    </ReactCrop>
                    {completedCrop && completedCrop.width > 0 && ( <canvas ref={previewCanvasRef} style={{ display: 'none', border: '1px solid black', objectFit: 'contain', width: completedCrop.width, height: completedCrop.height, }} /> )}
                </Box>
            )}
            <Group justify="center" mt="xs" wrap="nowrap">
                <FileInput placeholder={selectImageButtonLabel || t('component.rewardForm.selectImageButton')} accept="image/png,image/jpeg,image/webp,image/gif" onChange={handleFileSelect} leftSection={<IconUpload size={16} />} clearable disabled={disabled || isUploading} style={{ flexGrow: 1, maxWidth: showCropper ? 'calc(50% - 4px)' : '100%' }} value={selectedFile} />
                {showCropper && ( <Button onClick={handleConfirmCropAndUpload} loading={isUploading} disabled={!completedCrop || isUploading || disabled} leftSection={<IconCrop size={16} />} style={{ flexGrow: 1, maxWidth: 'calc(50% - 4px)' }} > {confirmCropButtonLabel || t('component.rewardForm.confirmCropButton')} </Button> )}
            </Group>
            {imgSrcForCropper && ( <Button variant="outline" color="gray" size="xs" mt="xs" onClick={() => { setImgSrcForCropper(''); setSelectedFile(null); setCrop(undefined); setCompletedCrop(undefined); if(initialImageUrl) setCurrentDisplayUrl(initialImageUrl); }} leftSection={<IconCameraRotate size={14}/>} disabled={isUploading || disabled} fullWidth > {t('common.cancel')} {t('common.edit')} / {t('common.selectPlaceholder')} </Button> )}
            {currentDisplayUrl && !showCropper && ( <Button variant="subtle" color="red" size="xs" mt="xs" onClick={handleRemoveImage} leftSection={<IconX size={14} />} disabled={disabled || isUploading} > {removeImageButtonLabel || t('component.rewardForm.removeImageButton')} </Button> )}
            {internalUploadError && ( <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />} mt="sm" withCloseButton onClose={() => setInternalUploadError(null)} > <Text size="sm">{internalUploadError}</Text> </Alert> )}
            {cropInstructionsLabel && showCropper && <Text size="xs" c="dimmed" ta="center" mt="xs">{cropInstructionsLabel}</Text>}
        </Stack>
    );
};
export default ImageUploadCropper;


// ====== [85] frontend/src/shared/components/utils/canvasPreview.ts ======
// frontend/src/utils/canvasPreview.ts
// Version 1.0.2 (Removed unused centerX, centerY for current logic)
import { PixelCrop } from 'react-image-crop';

const TO_RADIANS = Math.PI / 180;

export async function canvasPreview(
  image: HTMLImageElement,
  canvas: HTMLCanvasElement,
  crop: PixelCrop,
  scale = 1,
  rotate = 0,
  outputWidth?: number,
  outputHeight?: number
) {
  const ctx = canvas.getContext('2d');

  if (!ctx) {
    throw new Error('No 2d context');
  }

  const scaleX = image.naturalWidth / image.width;  // Relaci√≥n entre tama√±o natural y tama√±o mostrado
  const scaleY = image.naturalHeight / image.height; // Usado para convertir crop de % a px si fuera el caso

  canvas.width = Math.floor(outputWidth || crop.width);   // Usar outputWidth o el ancho del crop en p√≠xeles
  canvas.height = Math.floor(outputHeight || crop.height); // Usar outputHeight o el alto del crop en p√≠xeles

  ctx.imageSmoothingQuality = 'high';

  const cropXInOriginal = crop.x * scaleX; // Coordenada X del crop en la imagen original
  const cropYInOriginal = crop.y * scaleY; // Coordenada Y del crop en la imagen original
  const cropWidthInOriginal = crop.width * scaleX; // Ancho del crop en la imagen original
  const cropHeightInOriginal = crop.height * scaleY; // Alto del crop en la imagen original

  const rotateRads = rotate * TO_RADIANS;

  ctx.save();
  // Mover el origen del canvas al centro del canvas para la rotaci√≥n/escalado
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.rotate(rotateRads);
  ctx.scale(scale, scale);
  // Mover el origen de nuevo para que (0,0) del drawImage sea la esquina superior izquierda del √°rea de destino
  ctx.translate(-canvas.width / 2, -canvas.height / 2);

  // Dibujar la porci√≥n recortada de la imagen original,
  // y que se ajuste a las dimensiones completas del canvas (que son outputWidth/Height o el tama√±o del crop).
  ctx.drawImage(
    image,
    cropXInOriginal,
    cropYInOriginal,
    cropWidthInOriginal,
    cropHeightInOriginal,
    0, // Dibujar en la esquina (0,0) del canvas (ya transformado)
    0,
    canvas.width,  // Estirar/encoger a todo el ancho del canvas
    canvas.height  // Estirar/encoger a todo el alto del canvas
  );

  ctx.restore();
}

// canvasToBlob (sin cambios)
export function canvasToBlob(
  canvas: HTMLCanvasElement,
  type = 'image/png',
  quality = 0.9
): Promise<Blob | null> {
    return new Promise((resolve) => {
        canvas.toBlob(
            (blob) => { resolve(blob); },
            type,
            quality
        );
    });
}


// ====== [86] frontend/src/shared/hooks/useLayoutUserData.ts ======
// frontend/src/hooks/useLayoutUserData.ts
import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import axiosInstance from '../services/axiosInstance';
import type { UserData } from '../../types/customer';

interface UseLayoutUserDataReturn {
    userData: UserData | null;
    loadingUser: boolean;
    handleLogout: () => void;
}

export const useLayoutUserData = (): UseLayoutUserDataReturn => {
    const navigate = useNavigate();
    const [userData, setUserData] = useState<UserData | null>(null);
    const [loadingUser, setLoadingUser] = useState(true);

    const handleLogout = useCallback(() => {
        console.log("[useLayoutUserData] Executing logout...");
        localStorage.removeItem('token');
        localStorage.removeItem('user'); // Tambi√©n limpiar el usuario al hacer logout
        setUserData(null);
        if (window.location.pathname !== '/login') {
            navigate('/login', { replace: true });
        }
    }, [navigate]);

    useEffect(() => {
        const fetchAndSetUserData = async () => {
            console.log("[useLayoutUserData] Starting user data check/fetch...");
            setLoadingUser(true);
            const token = localStorage.getItem('token');

            if (!token) {
                console.log("[useLayoutUserData] No token found. Ensuring user is null.");
                if (userData !== null) setUserData(null); // Asegurar que userData es null si no hay token
                setLoadingUser(false);
                return;
            }

            // SIEMPRE intentamos obtener de /api/profile si hay token para datos frescos
            console.log("[useLayoutUserData] Token found. Fetching user profile from API...");
            try {
                const response = await axiosInstance.get<UserData>('/profile');
                if (response.data && response.data.id && response.data.email && response.data.role) {
                    setUserData(response.data);
                    localStorage.setItem('user', JSON.stringify(response.data)); // Actualizar localStorage con datos frescos
                    console.log("[useLayoutUserData] User data fetched from API and saved to localStorage:", response.data);
                } else {
                    console.error("[useLayoutUserData] Invalid or incomplete data received from API /profile endpoint. Logging out.");
                    handleLogout(); // Logout si API devuelve datos inv√°lidos/incompletos
                }
            } catch (apiError: any) {
                console.error("[useLayoutUserData] Error fetching user profile from API:", apiError);
                // Si falla /profile (ej. token expirado o inv√°lido), hacemos logout.
                // Esto tambi√©n limpia el localStorage.
                // Podr√≠amos intentar cargar desde localStorage como fallback aqu√≠,
                // pero es m√°s seguro hacer logout si /profile falla con un token existente.
                if (apiError.response?.status === 401 || apiError.response?.status === 403) {
                    console.log("[useLayoutUserData] API /profile returned 401/403, logging out.");
                    handleLogout();
                } else {
                    // Otro error de red, etc. No necesariamente invalida el token.
                    // Podr√≠amos intentar cargar desde localStorage como √∫ltimo recurso.
                    console.warn("[useLayoutUserData] API /profile fetch failed with other error. Attempting to load from localStorage if available.");
                    const storedUserJson = localStorage.getItem('user');
                    if (storedUserJson) {
                        try {
                            const parsed = JSON.parse(storedUserJson) as UserData;
                            if (parsed && parsed.id && parsed.email && parsed.role) {
                                setUserData(parsed);
                                console.log("[useLayoutUserData] Loaded stale data from localStorage due to API error.");
                            } else {
                                handleLogout(); // Stored data is invalid
                            }
                        } catch (e) {
                            handleLogout(); // Error parsing stored data
                        }
                    } else {
                        // No hay nada en localStorage y la API fall√≥, nos rendimos y hacemos logout.
                        handleLogout();
                    }
                }
            } finally {
                setLoadingUser(false);
                console.log("[useLayoutUserData] User data fetch/check process finished.");
            }
        };

        fetchAndSetUserData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [navigate]); // handleLogout no necesita estar aqu√≠ si su referencia no cambia, pero navigate s√≠

    // useEffect para reaccionar a cambios en localStorage (ej: logout en otra pesta√±a)
    useEffect(() => {
        const handleStorageChange = (event: StorageEvent) => {
            if (event.key === 'token' || event.key === 'user') {
                console.log('[useLayoutUserData] localStorage changed in another tab. Re-evaluating auth state.');
                // Forzar una re-evaluaci√≥n. Si 'token' es null, el efecto principal har√° logout.
                // Si 'token' existe pero 'user' cambi√≥ (o se borr√≥), el efecto principal deber√≠a recargar de /profile.
                // Una forma simple de forzarlo es recargar los datos.
                // O, si el token ya no existe, hacer logout.
                const token = localStorage.getItem('token');
                if (!token && userData !== null) { // Si el token se borr√≥ y ten√≠amos datos, hacemos logout
                    handleLogout();
                } else if (token && (!userData || (event.key === 'user' && localStorage.getItem('user') !== JSON.stringify(userData)))) {
                    // Si hay token pero no userData, o si 'user' cambi√≥, podemos forzar una recarga
                    // Esto es m√°s complejo, por ahora, el efecto principal al montar/cambiar navigate deber√≠a ser suficiente
                    // para la mayor√≠a de los casos de carga inicial.
                    // Para una sincronizaci√≥n perfecta entre pesta√±as, se necesitar√≠a una l√≥gica m√°s robusta
                    // o una librer√≠a de gesti√≥n de estado global.
                }
            }
        };

        window.addEventListener('storage', handleStorageChange);
        return () => {
            window.removeEventListener('storage', handleStorageChange);
        };
    }, [userData, handleLogout]);


    return { userData, loadingUser, handleLogout };
};


// ====== [87] frontend/src/shared/services/axiosInstance.ts ======
// filename: frontend/src/services/axiosInstance.ts
// Version: 1.1.1 (Remove meta-comments)

import axios from 'axios';

// Usar ruta relativa para baseURL
// El proxy de Vite redirigir√° /api a http://localhost:3000/api
const API_BASE_URL = '/api'; // Ruta relativa para que funcione el proxy

// Crea una instancia de Axios con la configuraci√≥n base
const axiosInstance = axios.create({
  baseURL: API_BASE_URL,
});

// A√±ade un interceptor de peticiones (request interceptor)
axiosInstance.interceptors.request.use(
  (config) => {
    // Obtener el token de localStorage
    const token = localStorage.getItem('token');
    if (token) {
      // A√±adir la cabecera Authorization si existe el token
      config.headers.set('Authorization', `Bearer ${token}`);
    }
    return config; // Devolver la configuraci√≥n modificada (o la original si no hay token)
  },
  (error) => {
    // Manejar errores que ocurran durante la configuraci√≥n de la petici√≥n
    console.error('Error in request interceptor:', error);
    return Promise.reject(error); // Rechazar la promesa con el error
  }
);

// Opcional: A√±adir interceptor de respuestas aqu√≠ si fuera necesario
/*
axiosInstance.interceptors.response.use(
  (response) => {
    // Cualquier c√≥digo de estado que este dentro del rango de 2xx causa la ejecuci√≥n de esta funci√≥n
    // Haz algo con los datos de la respuesta
    return response;
  },
  (error) => {
    // Cualquier c√≥digo de estado que caiga fuera del rango de 2xx causa la ejecuci√≥n de esta funci√≥n
    // Por ejemplo, manejar errores 401/403 globales aqu√≠
    if (error.response?.status === 401) {
      // Podr√≠amos hacer logout autom√°tico aqu√≠
      console.error("Unauthorized (401) response detected by interceptor.");
      // localStorage.removeItem('token');
      // localStorage.removeItem('user');
      // window.location.href = '/login'; // Redirecci√≥n forzada
    }
    return Promise.reject(error); // Rechazar la promesa con el error
  }
);
*/

// Exporta la instancia configurada para usarla en otros servicios
export default axiosInstance;

// End of File: frontend/src/services/axiosInstance.ts


// ====== [88] frontend/src/shared/services/businessService.ts ======
// filename: frontend/src/services/businessService.ts
// Version: 1.1.1 (Remove meta-comments, fix encoding)

import axios from 'axios'; // Usamos axios base, NO axiosInstance, porque es una ruta p√∫blica

/**
 * Interface para la estructura de datos de cada negocio en la lista p√∫blica.
 * Contiene lo necesario para un desplegable (valor y etiqueta).
 */
export interface BusinessOption {
  id: string;
  name: string;
}

// Usar ruta relativa para que funcione con el proxy de Vite
// El proxy definido en vite.config.ts para '/public' redirigir√° esto
const PUBLIC_BUSINESS_LIST_URL = '/public/businesses/public-list';


/**
 * Obtiene la lista p√∫blica de negocios (ID y Nombre) desde la API.
 * @returns Una promesa que resuelve con un array de objetos BusinessOption.
 * @throws Lanza un error si la petici√≥n a la API falla.
 */
export const getPublicBusinessList = async (): Promise<BusinessOption[]> => {
  console.log('[BusinessService] Fetching public business list...');
  try {
    // La llamada ahora usa la URL relativa
    const response = await axios.get<BusinessOption[]>(PUBLIC_BUSINESS_LIST_URL);

    console.log(`[BusinessService] Received ${response.data?.length ?? 0} businesses.`);
    return response.data || []; // Devolver array vac√≠o si la data es null/undefined

  } catch (error: any) {
    console.error('[BusinessService] Error fetching public business list:', error);
    const errorMessage = error.response?.data?.message ||
                           error.message ||
                           'Error desconocido al obtener la lista de negocios.'; // Corregido: desconocido
    // Relanzar el error para que el componente que llama lo maneje (ej: en RegisterPage)
    throw new Error(errorMessage);
  }
};

// End of file: frontend/src/services/businessService.ts


// ====== [89] frontend/src/shared/types/superadmin.types.ts ======
// frontend/src/types/superadmin.types.ts

// El tipo de dato que la API /superadmin/businesses devuelve para cada negocio
export interface SuperAdminBusiness {
    id: string;
    name: string;
    slug: string;
    isActive: boolean;
    isLoyaltyCoreActive: boolean;
    isCamareroActive: boolean;
    createdAt: string;
    monthlyPrice: string | number | null; // La API puede enviar Decimal como string
    currency: string;
    paymentStatus: 'PAID' | 'PENDING' | 'OVERDUE';
    lastPayment?: { month: number; year: number };
    pendingMonths: number;
}

// El tipo de dato para un registro de pago individual
export interface BusinessPayment {
    id: string;
    paymentDate: string;
    amountPaid: number;
    month: number;
    year: number;
    paymentMethod: string | null;
    notes: string | null;
}


// ====== [90] frontend/src/shared/types/user.types.ts ======
// frontend/src/types/customer.ts
// Version: 1.1.3 (Ensure OrderType is exported)

import React from 'react';

export enum UserRole {
    SUPER_ADMIN = 'SUPER_ADMIN',
    BUSINESS_ADMIN = 'BUSINESS_ADMIN',
    CUSTOMER_FINAL = 'CUSTOMER_FINAL',
    WAITER = 'WAITER',
    KITCHEN_STAFF = 'KITCHEN_STAFF',
    BAR_STAFF = 'BAR_STAFF'
}

export enum OrderItemStatus {
    PENDING_KDS = 'PENDING_KDS', PREPARING = 'PREPARING', READY = 'READY',
    SERVED = 'SERVED', CANCELLED = 'CANCELLED', CANCELLATION_REQUESTED = 'CANCELLATION_REQUESTED',
}

export enum OrderStatus {
    RECEIVED = 'RECEIVED', IN_PROGRESS = 'IN_PROGRESS', PARTIALLY_READY = 'PARTIALLY_READY',
    ALL_ITEMS_READY = 'ALL_ITEMS_READY', COMPLETED = 'COMPLETED', PENDING_PAYMENT = 'PENDING_PAYMENT',
    PAID = 'PAID', CANCELLED = 'CANCELLED', PAYMENT_FAILED = 'PAYMENT_FAILED',
}

// ---- A√ëADIR Y EXPORTAR OrderType SI NO EXISTE ----
export enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKE_AWAY = 'TAKE_AWAY',
  DELIVERY = 'DELIVERY',
}
// ---- FIN A√ëADIR/EXPORTAR OrderType ----


export enum TierCalculationBasis {
    SPEND = 'SPEND',
    VISITS = 'VISITS',
    POINTS_EARNED = 'POINTS_EARNED'
}

export interface CustomerBusinessConfig {
    tierCalculationBasis: TierCalculationBasis | null;
}

export interface TierBenefitData {
  id: string;
  type: string;
  value: string;
  description: string | null;
  isActive?: boolean;
}

export interface TierData {
    id: string;
    name: string;
    level: number;
    minValue: number;
    isActive: boolean;
    benefits?: TierBenefitData[];
}

export interface UserData {
    id: string;
    email: string;
    name?: string | null;
    role: UserRole;
    businessId: string | null;
    isActive: boolean;
    points?: number;
    totalSpend?: number;
    totalVisits?: number;
    currentTier?: {
        id: string;
        name: string;
        benefits: TierBenefitData[];
    } | null;
    businessIsActive?: boolean;
    isLoyaltyCoreActive?: boolean;
    isCamareroActive?: boolean;
    businessName?: string | null;
    businessSlug?: string | null;
    businessLogoUrl?: string | null;
}
export interface Reward {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es?: string | null;
    description_en?: string | null;
    pointsCost: number;
    isActive: boolean;
    businessId?: string;
    imageUrl?: string | null;
    createdAt?: string;
    updatedAt?: string;
}
export interface GrantedReward {
    id: string;
    status: string;
    assignedAt: string;
    reward: Pick<Reward, 'id' | 'name_es' | 'name_en' | 'description_es' | 'description_en' | 'imageUrl'>;
    assignedBy?: { name?: string | null; email: string; } | null;
    business?: { name: string; } | null;
}
export type DisplayReward =
    {
        isGift: false;
        id: string;
        name_es: string | null;
        name_en: string | null;
        description_es?: string | null;
        description_en?: string | null;
        pointsCost: number;
        imageUrl?: string | null;
        grantedRewardId?: undefined;
        assignedByString?: undefined;
        assignedAt?: undefined;
    } |
    {
        isGift: true;
        grantedRewardId: string;
        id: string;
        name_es: string | null;
        name_en: string | null;
        description_es?: string | null;
        description_en?: string | null;
        pointsCost: 0;
        imageUrl?: string | null;
        assignedByString: string;
        assignedAt: string;
    };

export interface UseProfileResult {
    userData: UserData | null;
    loading: boolean;
    error: string | null;
    refetch: () => Promise<void>;
    setUserData: React.Dispatch<React.SetStateAction<UserData | null>>;
}

export interface UseCustomerTierDataResult {
    allTiers: TierData[] | null;
    businessConfig: CustomerBusinessConfig | null;
    loading: boolean;
    error: string | null;
    refetch: () => Promise<void>;
}

export type ActivityType =
    | 'POINTS_EARNED_QR'
    | 'POINTS_REDEEMED_REWARD'
    | 'GIFT_REDEEMED'
    | 'POINTS_ADJUSTED_ADMIN'
    | 'POINTS_EARNED_ORDER_LC'; // Aseg√∫rate que este tambi√©n est√© si lo usas en el frontend

export interface ActivityLogItem {
  id: string;
  type: ActivityType;
  pointsChanged: number | null;
  description: string | null;
  createdAt: string;
}

export interface PaginatedActivityResponse {
  logs: ActivityLogItem[];
  totalPages: number;
  currentPage: number;
  totalItems: number;
}


// ====== [91] frontend/tsconfig.json ======
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



// ====== [92] frontend/vite.config.ts ======
// filename: frontend/vite.config.ts
// Version: 1.1.3 (Use mergeConfig to combine Vite and Vitest configs)

// Importar defineConfig y mergeConfig de Vite
import { defineConfig, mergeConfig } from 'vite';
// Importar defineConfig de Vitest con un alias
import { defineConfig as defineVitestConfig } from 'vitest/config';

import react from '@vitejs/plugin-react';
import mkcert from 'vite-plugin-mkcert';

// Configuraci√≥n espec√≠fica de Vite
const viteConfig = defineConfig({
  plugins: [react(), mkcert()],
  server: {
    host: true,
    port: 5173,
    https: true,
    proxy: {
      '/api': { target: 'http://localhost:3000', changeOrigin: true },
      '/public': { target: 'http://localhost:3000', changeOrigin: true }
    }
  },
  // Aqu√≠ ir√≠an otras opciones espec√≠ficas de Vite si las tuvieras
});

// Configuraci√≥n espec√≠fica de Vitest
const vitestConfig = defineVitestConfig({
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts', // Seguimos necesitando este archivo
    css: true,
  },
  // Aqu√≠ ir√≠an otras opciones espec√≠ficas de Vitest si las tuvieras
});

// Exportar la configuraci√≥n combinada
export default mergeConfig(viteConfig, vitestConfig);

// End of File: frontend/vite.config.ts

