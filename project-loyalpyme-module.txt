# √çNDICE DE ARCHIVOS (M√ìDULO LOYALPYME + SHARED)

1. README.md
2. backend/package.json
3. backend/src/modules/loyalpyme/activity/activity.controller.ts
4. backend/src/modules/loyalpyme/activity/activity.service.ts
5. backend/src/modules/loyalpyme/admin/admin-customer-bulk.controller.ts
6. backend/src/modules/loyalpyme/admin/admin-customer-bulk.service.ts
7. backend/src/modules/loyalpyme/admin/admin-customer-individual.controller.ts
8. backend/src/modules/loyalpyme/admin/admin-customer-individual.service.ts
9. backend/src/modules/loyalpyme/admin/admin-customer-list.controller.ts
10. backend/src/modules/loyalpyme/admin/admin-customer-list.service.ts
11. backend/src/modules/loyalpyme/admin/admin-stats.controller.ts
12. backend/src/modules/loyalpyme/admin/admin-stats.service.ts
13. backend/src/modules/loyalpyme/customer/customer.controller.ts
14. backend/src/modules/loyalpyme/customer/customer.service.ts
15. backend/src/modules/loyalpyme/points/points.controller.ts
16. backend/src/modules/loyalpyme/points/points.service.ts
17. backend/src/modules/loyalpyme/rewards/rewards.controller.ts
18. backend/src/modules/loyalpyme/rewards/rewards.service.ts
19. backend/src/modules/loyalpyme/tiers/__tests__/tier-logic.helpers.test.ts
20. backend/src/modules/loyalpyme/tiers/tier-benefit.controller.ts
21. backend/src/modules/loyalpyme/tiers/tier-benefit.service.ts
22. backend/src/modules/loyalpyme/tiers/tier-config.controller.ts
23. backend/src/modules/loyalpyme/tiers/tier-config.service.ts
24. backend/src/modules/loyalpyme/tiers/tier-crud.controller.ts
25. backend/src/modules/loyalpyme/tiers/tier-logic.helpers.ts
26. backend/src/modules/loyalpyme/tiers/tier-logic.service.ts
27. backend/src/modules/loyalpyme/tiers/tiers.controller.ts
28. backend/src/modules/loyalpyme/tiers/tiers.service.ts
29. backend/src/shared/auth/__tests__/auth.service.test.ts
30. backend/src/shared/auth/auth.controller.ts
31. backend/src/shared/auth/auth.dto.ts
32. backend/src/shared/auth/auth.service.ts
33. backend/src/shared/auth/password-reset.controller.ts
34. backend/src/shared/auth/password-reset.service.ts
35. backend/src/shared/auth/registration.controller.ts
36. backend/src/shared/auth/registration.service.ts
37. backend/src/shared/businesses/businesses.controller.ts
38. backend/src/shared/businesses/businesses.service.ts
39. backend/src/shared/middleware/auth.middleware.ts
40. backend/src/shared/middleware/module.middleware.ts
41. backend/src/shared/middleware/multer.config.ts
42. backend/src/shared/middleware/role.middleware.ts
43. backend/src/shared/services/loyalty-points.service.ts
44. backend/src/shared/services/table.service.ts
45. backend/src/shared/uploads/uploads.controller.ts
46. backend/src/shared/uploads/uploads.service.ts
47. backend/src/shared/utils/cloudinary.config.ts
48. backend/src/shared/utils/validation.ts
49. backend/tsconfig.json
50. frontend/index.html
51. frontend/package.json
52. frontend/src/modules/loyalpyme/components/AddRewardForm.tsx
53. frontend/src/modules/loyalpyme/components/GenerateQrCode.tsx
54. frontend/src/modules/loyalpyme/components/admin/AdjustPointsModal.tsx
55. frontend/src/modules/loyalpyme/components/admin/AssignRewardModal.tsx
56. frontend/src/modules/loyalpyme/components/admin/BulkAdjustPointsModal.tsx
57. frontend/src/modules/loyalpyme/components/admin/ChangeTierModal.tsx
58. frontend/src/modules/loyalpyme/components/admin/CustomerBulkActionsBar.tsx
59. frontend/src/modules/loyalpyme/components/admin/CustomerDetailsModal.tsx
60. frontend/src/modules/loyalpyme/components/admin/CustomerFiltersBar.tsx
61. frontend/src/modules/loyalpyme/components/admin/CustomerTable.tsx
62. frontend/src/modules/loyalpyme/components/admin/StatCard.module.css
63. frontend/src/modules/loyalpyme/components/admin/StatCard.test.tsx
64. frontend/src/modules/loyalpyme/components/admin/StatCard.tsx
65. frontend/src/modules/loyalpyme/components/admin/rewards/RewardForm.tsx
66. frontend/src/modules/loyalpyme/components/admin/tiers/AddTierBenefitForm.tsx
67. frontend/src/modules/loyalpyme/components/admin/tiers/CreateTierModal.tsx
68. frontend/src/modules/loyalpyme/components/admin/tiers/DeleteTierModal.tsx
69. frontend/src/modules/loyalpyme/components/admin/tiers/EditTierModal.tsx
70. frontend/src/modules/loyalpyme/components/admin/tiers/TierBenefitsModal.tsx
71. frontend/src/modules/loyalpyme/components/admin/tiers/TierForm.tsx
72. frontend/src/modules/loyalpyme/components/admin/tiers/TierTable.tsx
73. frontend/src/modules/loyalpyme/components/customer/NextTierPreview.tsx
74. frontend/src/modules/loyalpyme/components/customer/QrValidationSection.tsx
75. frontend/src/modules/loyalpyme/components/customer/RewardList.tsx
76. frontend/src/modules/loyalpyme/components/customer/TierBenefitsDisplay.tsx
77. frontend/src/modules/loyalpyme/components/customer/UserInfoDisplay.tsx
78. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/ActivityTab.tsx
79. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/OffersTab.tsx
80. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/ProfileTab.tsx
81. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/RewardsTab.tsx
82. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/SummaryTab.tsx
83. frontend/src/modules/loyalpyme/hooks/useAdminCustomersData.ts
84. frontend/src/modules/loyalpyme/hooks/useAdminOverviewStats.ts
85. frontend/src/modules/loyalpyme/hooks/useAdminRewards.ts
86. frontend/src/modules/loyalpyme/hooks/useCustomerActivity.ts
87. frontend/src/modules/loyalpyme/hooks/useCustomerRewardsData.ts
88. frontend/src/modules/loyalpyme/hooks/useCustomerTierData.ts
89. frontend/src/modules/loyalpyme/hooks/useQrScanner.ts
90. frontend/src/modules/loyalpyme/hooks/useUserProfileData.ts
91. frontend/src/modules/loyalpyme/pages/CustomerDashboardPage.tsx
92. frontend/src/modules/loyalpyme/pages/admin/AdminCustomerManagementPage.module.css
93. frontend/src/modules/loyalpyme/pages/admin/AdminCustomerManagementPage.tsx
94. frontend/src/modules/loyalpyme/pages/admin/AdminGenerateQr.tsx
95. frontend/src/modules/loyalpyme/pages/admin/AdminOverview.tsx
96. frontend/src/modules/loyalpyme/pages/admin/AdminRewardsManagement.tsx
97. frontend/src/modules/loyalpyme/pages/admin/tiers/TierManagementPage.tsx
98. frontend/src/modules/loyalpyme/pages/admin/tiers/TierSettingsPage.tsx
99. frontend/src/modules/loyalpyme/services/adminCustomerService.ts
100. frontend/src/modules/loyalpyme/services/adminService.ts
101. frontend/src/shared/components/PrivateRoute.tsx
102. frontend/src/shared/components/layout/AdminNavbar.tsx
103. frontend/src/shared/components/layout/AppHeader.tsx
104. frontend/src/shared/components/layout/MainLayout.tsx
105. frontend/src/shared/components/layout/PublicLayout.tsx
106. frontend/src/shared/components/utils/ImageUploadCropper.tsx
107. frontend/src/shared/components/utils/canvasPreview.ts
108. frontend/src/shared/hooks/useLayoutUserData.ts
109. frontend/src/shared/services/axiosInstance.ts
110. frontend/src/shared/services/businessService.ts
111. frontend/src/shared/types/superadmin.types.ts
112. frontend/src/shared/types/user.types.ts
113. frontend/tsconfig.json
114. frontend/vite.config.ts


# CONTENIDO DE ARCHIVOS


// ====== [1] README.md ======
# LoyalPyME üá™üá∏ (v1.21.0)

**LoyalPyME** es una plataforma web integral y modular, desarrollada con un stack **Frontend React (TypeScript, Mantine UI, Vite)** y **Backend Node.js (TypeScript, Express, Prisma, PostgreSQL)**, dise√±ada espec√≠ficamente para Peque√±as y Medianas Empresas (PyMEs). La plataforma se estructura en m√≥dulos activables individualmente por cada negocio cliente, permitiendo una soluci√≥n a medida y adaptada a sus necesidades operativas y de marketing.

- ‚≠ê **LoyalPyME Core (LCo) - M√≥dulo de Fidelizaci√≥n [Estable y Funcional]:**
  Un sistema robusto y completo para la gesti√≥n de programas de lealtad digitales.

  - **Gesti√≥n de Clientes:** Administraci√≥n detallada de clientes, incluyendo su historial de puntos, nivel de fidelizaci√≥n, y actividad.
  - **Sistema de Puntos:** Configuraci√≥n de ratio de puntos por gasto, generaci√≥n de QR para acumulaci√≥n en punto de venta f√≠sico.
  - **Niveles de Fidelizaci√≥n (Tiers):** Creaci√≥n de m√∫ltiples niveles con umbrales personalizables (basados en gasto, visitas, o puntos acumulados) y asignaci√≥n de beneficios exclusivos por nivel (ej. multiplicadores de puntos, acceso a recompensas especiales).
  - **Cat√°logo de Recompensas:** Gesti√≥n de un cat√°logo de recompensas canjeables por puntos, con soporte completo para internacionalizaci√≥n (nombres y descripciones en ES/EN) e im√°genes individuales por recompensa.
  - **Panel de Cliente Interactivo:** Un dashboard personalizado para que los clientes finales consulten su saldo de puntos, nivel actual y progreso hacia el siguiente, visualicen las recompensas disponibles y regalos asignados, canjeen beneficios, y revisen su historial completo de transacciones de fidelizaci√≥n.

- üöÄ **LoyalPyME Camarero (LC) - M√≥dulo de Hosteler√≠a [Ciclo Completo de Pedido y Servicio Validado]:**
  Un m√≥dulo avanzado enfocado en la digitalizaci√≥n y optimizaci√≥n integral del servicio en el sector hostelero (restaurantes, bares, cafeter√≠as), mejorando la eficiencia operativa y la experiencia del cliente.
  - **Funcionalidad Actual Clave:**
    1.  **Gesti√≥n de Carta Digital por el Administrador:** Interfaz administrativa completa y detallada (`/admin/dashboard/camarero/menu-editor`) para crear, editar y organizar:
        - **Categor√≠as del Men√∫:** Con nombre (ES/EN), descripci√≥n (ES/EN), imagen (con recorte), posici√≥n y estado de activaci√≥n.
        - **√çtems del Men√∫:** Dentro de cada categor√≠a, con nombre (ES/EN), descripci√≥n (ES/EN), precio, imagen (con recorte), listado de al√©rgenos, etiquetas (ej. "Vegano", "Popular"), disponibilidad, posici√≥n, tiempo de preparaci√≥n estimado, calor√≠as, SKU y destino KDS.
        - **Grupos de Modificadores:** Asociados a cada √≠tem, con nombre (ES/EN), tipo de interfaz de usuario (`RADIO` para selecci√≥n √∫nica, `CHECKBOX` para m√∫ltiple), y reglas de selecci√≥n (m√≠nimo/m√°ximo, obligatorio).
        - **Opciones de Modificador:** Dentro de cada grupo, con nombre (ES/EN) y ajuste de precio.
    2.  **Visualizaci√≥n de Carta P√∫blica por el Cliente Final:** Acceso mediante URL directa (`/m/:businessSlug/:tableIdentifier?`). Los clientes pueden:
        - Navegar por categor√≠as y ver detalles de cada √≠tem.
        - Personalizar √≠tems seleccionando opciones de los modificadores, con el precio actualiz√°ndose din√°micamente.
    3.  **Flujo de Pedido Completo por el Cliente Final:**
        - **Carrito de Compra Local:** Los √≠tems configurados se a√±aden a un carrito que persiste en el `localStorage`.
        - **Modal de Carrito (`ShoppingCartModal.tsx`):** Permite revisar el pedido, modificar cantidades, eliminar √≠tems y a√±adir notas generales.
        - **Env√≠o y Adici√≥n a Pedido:** Al confirmar, el sistema env√≠a un `CreateOrderPayloadDto` al backend, gestionando inteligentemente si se debe crear un pedido nuevo o a√±adir los √≠tems a uno ya existente.
        - **Procesamiento Backend:** Validaci√≥n exhaustiva de disponibilidad, reglas y precios, con creaci√≥n transaccional en la base de datos.
        - **Feedback al Cliente:** Notificaci√≥n de √©xito y redirecci√≥n a la p√°gina de estado del pedido.
    4.  **Visualizaci√≥n del Estado del Pedido por el Cliente (`OrderStatusPage.tsx`):**
        - Muestra el estado general del pedido y de cada √≠tem (`En preparaci√≥n`, `Listo`, `Servido`).
        - Se actualiza autom√°ticamente mediante polling.
        - Permite al cliente **solicitar la cuenta** para iniciar el proceso de pago.
    5.  **Kitchen Display System (KDS) - Backend y Frontend (Funcional):**
        - **API KDS Backend:** Endpoints validados para obtener y actualizar el estado de los √≠tems de preparaci√≥n.
        - **Interfaz KDS Frontend:** Permite al personal de cocina/barra visualizar los √≠tems por destino y cambiar su estado (`PENDING_KDS` -> `PREPARING` -> `READY`).
    6.  **Interfaz de Camarero y Ciclo de Pago Completo (Funcional):**
        - **Recogida y Entrega:** La interfaz de camarero (`WaiterPickupPage.tsx`) muestra los √≠tems listos para recoger, permitiendo marcarlos como servidos.
        - **Gesti√≥n de Pago:** La interfaz de gesti√≥n (`WaiterOrderManagementPage.tsx`) muestra los pedidos pendientes de pago, permitiendo al camarero marcarlos como `PAID`.
        - **Automatizaci√≥n:** Al marcar como pagado, el sistema libera la mesa y asigna puntos de fidelidad LCo al cliente de forma autom√°tica.

La plataforma LoyalPyME est√° dise√±ada con un enfoque en la **mantenibilidad**, **escalabilidad** y **adaptabilidad**, buscando ser el socio tecnol√≥gico que impulse la eficiencia operativa y el crecimiento sostenible de las PyMEs.

## Visi√≥n y Prop√≥sito ‚ú®

LoyalPyME aspira a ser el **aliado tecnol√≥gico integral de las Peque√±as y Medianas Empresas (PyMEs)**, proporcionando herramientas digitales sofisticadas pero intuitivas y f√°ciles de usar, integradas en una √∫nica plataforma modular que se adapta a las necesidades espec√≠ficas de cada negocio.

Con **LoyalPyME Core (LCo)**, buscamos empoderar a las empresas para que puedan cultivar relaciones m√°s profundas, significativas y duraderas con sus clientes. El objetivo es fomentar la lealtad y la recurrencia a trav√©s de programas de recompensas personalizados, comunicaci√≥n efectiva y una experiencia de cliente gratificante que los haga sentir valorados.

Con el m√≥dulo **LoyalPyME Camarero (LC)**, nuestra visi√≥n es transformar y modernizar la operativa en el sector de la hosteler√≠a. Queremos que los negocios puedan:

- **Modernizar su servicio:** Ofreciendo una experiencia de pedido digital √°gil y sin fricciones directamente desde la mesa del cliente.
- **Reducir errores manuales:** Minimizando las imprecisiones en la toma de comandas y la comunicaci√≥n con cocina/barra.
- **Agilizar la comunicaci√≥n interna:** Optimizando el flujo de informaci√≥n entre el personal de sala, la cocina y la barra a trav√©s del KDS y la interfaz de camarero.
- **Mejorar significativamente la experiencia del cliente final:** Permiti√©ndole explorar la carta a su ritmo, personalizar sus pedidos con total control y transparencia, y seguir el estado de su comanda en tiempo real.
- **Obtener datos operativos valiosos:** Recopilando informaci√≥n sobre ventas, popularidad de √≠tems, y tiempos de preparaci√≥n para la toma de decisiones estrat√©gicas y la optimizaci√≥n continua del negocio.

La plataforma es inherentemente vers√°til: **LoyalPyME Core** es aplicable a una amplia gama de sectores empresariales (retail, servicios profesionales, bienestar, etc.) que busquen implementar programas de fidelizaci√≥n. Por su parte, **LoyalPyME Camarero** ofrece una soluci√≥n especializada, potente y adaptada a las particularidades del sector de la restauraci√≥n, desde peque√±as cafeter√≠as hasta restaurantes con mayor volumen de operaciones. La sinergia entre ambos m√≥dulos permite una experiencia de cliente altamente integrada y datos de negocio enriquecidos.

_(Para un an√°lisis exhaustivo del estado actual del proyecto, incluyendo la versi√≥n actual, los hitos completados en detalle, las decisiones de dise√±o clave y las lecciones aprendidas, consulta nuestro [**PROJECT_STATUS.md**](./PROJECT_STATUS.md). La hoja de ruta completa, el backlog de funcionalidades futuras para ambos m√≥dulos, y la visi√≥n a largo plazo se encuentran detallados en [**DEVELOPMENT_PLAN.md**](./DEVELOPMENT_PLAN.md))._

## Caracter√≠sticas Principales Implementadas ‚úÖ

**Plataforma Base y Gesti√≥n Multi-M√≥dulo:**

- **Panel Super Admin:** Interfaz dedicada (`/superadmin`) para el rol `SUPER_ADMIN`, permitiendo la administraci√≥n global de los negocios clientes registrados. Funcionalidades: listar negocios, ver su estado general (`isActive`), y **activar/desactivar individualmente los m√≥dulos LoyalPyME Core (`isLoyaltyCoreActive`) y LoyalPyME Camarero (`isCamareroActive`)** para cada negocio.
- **Gesti√≥n de M√≥dulos por Negocio:** La funcionalidad de cada m√≥dulo (LCo, LC) se habilita o deshabilita a nivel de la entidad `Business` en la base de datos. El perfil de usuario (`/api/profile`) que se obtiene tras el login incluye estos flags de activaci√≥n para el negocio asociado, permitiendo al frontend adaptar la UI din√°micamente.
- **Control de Acceso Basado en M√≥dulos y Roles (RBAC + MBAC):**
  - **RBAC (Role-Based Access Control):** El acceso a las funcionalidades (APIs backend y componentes UI frontend) est√° condicionado por el rol del usuario (`SUPER_ADMIN`, `BUSINESS_ADMIN`, `CUSTOMER_FINAL`, `KITCHEN_STAFF`, `BAR_STAFF`, y futuro `WAITER`).
  - **MBAC (Module-Based Access Control):** Un middleware backend (`checkModuleActive`) y l√≥gica en frontend verifican que el m√≥dulo requerido est√© activo para el negocio del usuario antes de permitir el acceso a funcionalidades espec√≠ficas de dicho m√≥dulo.

**LoyalPyME Core (LCo) - M√≥dulo de Fidelizaci√≥n [Estable y Funcional]:**

- **Autenticaci√≥n Completa y Segura:**
  - Registro de Negocios con su primer `BUSINESS_ADMIN`.
  - Registro de `CUSTOMER_FINAL` asociados a un negocio espec√≠fico.
  - Login robusto con email/contrase√±a, utilizando JWT para la gesti√≥n de sesiones.
  - Funcionalidad completa de Reseteo de Contrase√±a.
- **Gesti√≥n Avanzada de Clientes (Panel Admin LCo):**
  - Listado paginado con b√∫squeda por nombre/email, filtros y ordenaci√≥n.
  - Funcionalidades CRUD para clientes, incluyendo: notas internas, ajuste manual de puntos, cambio manual de nivel, asignaci√≥n de regalos, activaci√≥n/desactivaci√≥n y marcado como favoritos.
  - Acciones Masivas sobre clientes seleccionados: activar/desactivar, eliminar y ajustar puntos.
- **Sistema de Niveles/Tiers Din√°mico y Configurable (Panel Admin LCo):**
  - CRUD completo para niveles de fidelizaci√≥n y sus beneficios asociados.
  - Configuraci√≥n global del sistema de tiers: base de c√°lculo, periodo y pol√≠ticas de descenso.
- **Gesti√≥n Integral de Recompensas (Panel Admin LCo):**
  - CRUD completo para recompensas canjeables por puntos, con soporte i18n y subida de im√°genes.
- **Flujo de Acumulaci√≥n de Puntos y QR (LCo):**
  - Generaci√≥n de QR √∫nicos y temporales por parte del administrador.
  - Validaci√≥n de QR por parte del cliente mediante escaneo con la c√°mara o introducci√≥n manual.
- **L√≥gica de Tiers y Actualizaci√≥n Autom√°tica (LCo - Backend):** Tarea programada (Cron Job) para recalcular y actualizar el nivel de los clientes.
- **Panel de Cliente Completo (LCo - Frontend - `CustomerDashboardPage.tsx`):**
  - Interfaz organizada en pesta√±as:
    - **Resumen (`SummaryTab.tsx`):** Informaci√≥n clave, barra de progreso al siguiente nivel, y secci√≥n para validar QR.
    - **Recompensas (`RewardsTab.tsx`):** Listado de recompensas canjeables y regalos pendientes.
    - **Actividad (`ActivityTab.tsx`):** Historial paginado de todas las transacciones de puntos.

**M√≥dulo LoyalPyME Camarero (LC) [Ciclo de Pedido Completo Validado]:**

- **Modelo de Datos Robusto para Hosteler√≠a (Backend - Prisma):**
  - Definici√≥n detallada de entidades como `MenuCategory`, `MenuItem`, `ModifierGroup`, `Order`, `OrderItem`, `Table`, `StaffPin`.
- **API de Gesti√≥n de Carta por el Administrador (Backend):**
  - Endpoints CRUD completos y protegidos para gestionar toda la carta digital.
- **Interfaz de Usuario para Gesti√≥n de Carta (Admin Frontend):**
  - Componentes dedicados para un CRUD intuitivo de la estructura de la carta, incluyendo subida y recorte de im√°genes.
- **Visualizaci√≥n de Carta P√∫blica y Flujo de Pedido por Cliente Final:**
  - **Frontend:** P√°gina responsive para visualizaci√≥n y personalizaci√≥n de √≠tems con precios din√°micos.
  - **Carrito de Compra Local:** Con persistencia en `localStorage` y funcionalidades de edici√≥n.
  - **Env√≠o y Adici√≥n de √çtems:** El sistema gestiona inteligentemente si crear un nuevo pedido o a√±adir √≠tems a uno ya existente.
- **Visualizaci√≥n del Estado del Pedido por el Cliente:**
  - P√°gina con polling autom√°tico que muestra el estado del `Order` y de cada `OrderItem`.
  - Incluye la funcionalidad para "Pedir la Cuenta".
- **Kitchen Display System (KDS) - Backend y Frontend:**
  - **API KDS:** Endpoints validados para obtener y actualizar el estado de los √≠tems de preparaci√≥n.
  - **Interfaz KDS:** Permite al personal de cocina/barra visualizar los √≠tems y cambiar su estado de preparaci√≥n.
- **Ciclo de Servicio y Pago Completo (Camarero):**
  - **Recogida:** Interfaz para que el personal de sala vea los √≠tems listos y los marque como servidos.
  - **Pago:** Interfaz para ver los pedidos pendientes de pago y marcarlos como `PAID`.
  - **Automatizaci√≥n:** El marcado como pagado libera la mesa y asigna puntos LCo.

## Estado Actual y Pr√≥ximos Pasos üó∫Ô∏è

La plataforma ha alcanzado la **versi√≥n v1.21.0**.

- **LoyalPyME Core (LCo):** Estable, completamente funcional y probado.
- **Arquitectura Multi-M√≥dulo y Panel Super Admin:** Implementada y operativa.
- **M√≥dulo Camarero (LC):** El ciclo de vida completo de un pedido est√° **completo y validado.**

El **enfoque principal de desarrollo inmediato** es a√±adir funcionalidades avanzadas de gesti√≥n al M√≥dulo Camarero (LC):

1.  ‚≠ê **LC - Dividir la Cuenta (Split Bill):**
    - **Objetivo:** Permitir al personal de sala dividir una cuenta entre m√∫ltiples clientes.

Posteriormente, se abordar√°n funcionalidades como la gesti√≥n de personal con PINs, mejoras en la interfaz del camarero (TPV), y un sistema de reservas.

- Consulta **[PROJECT_STATUS.md](./PROJECT_STATUS.md)** para un an√°lisis detallado.
- Revisa **[DEVELOPMENT_PLAN.md](./DEVELOPMENT_PLAN.md)** para la hoja de ruta completa.

## Tecnolog√≠as Utilizadas üõ†Ô∏è

**Frontend:**
React (v19+, Hooks, Context API), TypeScript, Vite (v5+, bundler y servidor de desarrollo HMR), Mantine UI (v7+, biblioteca de componentes y hooks), Axios (cliente HTTP), React Router DOM (v6+, para enrutamiento SPA), `html5-qrcode` (para escaneo de c√≥digos QR por el cliente en LCo), `react-image-crop` (para recorte de im√°genes en interfaces de administraci√≥n), `i18next` y `react-i18next` (para internacionalizaci√≥n ES/EN con archivos JSON), `zod` (para validaci√≥n de formularios, implementaci√≥n progresiva).

**Backend:**
Node.js (runtime), Express.js (framework web), TypeScript (lenguaje principal), Prisma ORM (v6+, para acceso a base de datos PostgreSQL, gesti√≥n de migraciones y generaci√≥n de cliente tipado), PostgreSQL (sistema de gesti√≥n de base deatos relacional), JSON Web Tokens (JWT) (para autenticaci√≥n stateless), `bcryptjs` (para hashing seguro de contrase√±as), Cloudinary SDK (para almacenamiento y gesti√≥n de im√°genes en la nube), Multer (middleware para manejo de subidas de archivos `multipart/form-data`), Vitest (para testing unitario y de integraci√≥n), Supertest (para testing de API HTTP), Swagger/OpenAPI (`swagger-jsdoc`, `swagger-ui-express`) (para documentaci√≥n interactiva de la API RESTful), `node-cron` (para la ejecuci√≥n de tareas programadas, ej. actualizaci√≥n de tiers en LCo).

## Inicio R√°pido (Desarrollo Local) üöÄ

1.  **Clonar el Repositorio:**
    ```bash
    git clone <URL_DEL_REPOSITORIO_GIT> LoyalPyME
    cd LoyalPyME
    ```
2.  **Configuraci√≥n del Backend (`backend/`):**
    - Instalar dependencias: `yarn install` (o `npm install`).
    - Configurar Variables de Entorno: Copiar `backend/.env.example` a `backend/.env` y rellenar todas las variables.
    - Base de Datos (PostgreSQL debe estar corriendo):
      1.  Crear la base de datos (ej. `loyalpymedb`).
      2.  Desde `backend/`, ejecutar `npx prisma migrate reset`.
      3.  Ejecutar `npx prisma db seed` para poblar con datos de demostraci√≥n.
      4.  Ejecutar `npx ts-node ./scripts/create-superadmin.ts` para crear el Super Administrador.
    - Ejecutar el Backend (desde `backend/`, en dos terminales separadas):
      1.  `yarn dev:build` (o `npx tsc --watch`): Compilaci√≥n continua de TypeScript.
      2.  `yarn dev:run` (o `npx nodemon dist/index.js`): Iniciar servidor Node.js con Nodemon.
3.  **Configuraci√≥n del Frontend (`frontend/`):**
    - Instalar dependencias: `yarn install` (o `npm install`).
    - Ejecutar el Frontend (desde `frontend/`): `yarn dev`.
4.  **Acceso a las Aplicaciones (URLs por defecto):**
    - **Carta P√∫blica:** `https://localhost:5173/m/restaurante-demo-loyalpyme`
    - **Login / Dashboards:** `https://localhost:5173`
    - **Documentaci√≥n API (Swagger):** `http://localhost:3000/api-docs`

**¬°Importante!** Para instrucciones **exhaustivas y detalladas**, consulta la gu√≠a **[SETUP_GUIDE.md](./SETUP_GUIDE.md)**. Para soluciones a problemas comunes, revisa la **[TROUBLESHOOTING_GUIDE.md](./TROUBLESHOOTING_GUIDE.md)**.

---

## Contribuciones ü§ù

Este proyecto es software propietario desarrollado por Olivier Hottelet. No se aceptan contribuciones externas directas en este momento. Si se detectan errores o se tienen sugerencias de mejora, pueden ser comunicadas al propietario. Si el repositorio fuera p√∫blico y permitiera la creaci√≥n de "Issues" en la plataforma de hosting de c√≥digo (ej. GitHub, GitLab), esa ser√≠a la v√≠a formal para reportar bugs o proponer nuevas funcionalidades.

## Licencia üìú

Este proyecto es software propietario.
**Copyright (c) 2024-2025 Olivier Hottelet. Todos los derechos reservados.**

El uso, copia, reproducci√≥n, distribuci√≥n, modificaci√≥n, descompilaci√≥n, ingenier√≠a inversa o cualquier otra forma de explotaci√≥n de este software o su c√≥digo fuente, en su totalidad o en parte, est√° estrictamente prohibido sin el permiso previo, expl√≠cito y por escrito del propietario de los derechos de autor. Este software se considera informaci√≥n confidencial y un secreto comercial.

Para m√°s detalles sobre los t√©rminos de la licencia, consulta el archivo [LICENSE.md](./LICENSE.MD) en el directorio ra√≠z del proyecto.

## Contacto üìß

Para consultas sobre el proyecto, licencias, adquisici√≥n, o cualquier otro asunto relacionado:

- **Olivier Hottelet**
- [olivierhottelet1980@gmail.com](mailto:olivierhottelet1980@gmail.com)



// ====== [2] backend/package.json ======
{
  "name": "backend",
  "version": "1.15.0",
  "main": "dist/index.js",
  "license": "SEE LICENSE IN ../LICENSE.md",
  "scripts": {
    "build": "npx tsc",
    "start": "node dist/index.js",
    "dev:build": "npx tsc --watch",
    "dev:run": "npx nodemon dist/index.js",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "db:seed": "ts-node --compiler-options \"{\\\"module\\\":\\\"commonjs\\\"}\" prisma/seed.ts"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@nestjs/common": "^11.1.2",
    "@nestjs/core": "^11.1.2",
    "@prisma/client": "^6.6.0",
    "@types/multer": "^1.4.12",
    "@types/node-cron": "^3.0.11",
    "@types/streamifier": "^0.1.2",
    "bcryptjs": "^2.4.3",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "cloudinary": "^2.6.0",
    "cors": "^2.8.5",
    "date-fns": "^3.6.0",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.2",
    "node-cron": "^3.0.3",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.2",
    "streamifier": "^0.1.1",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1",
    "uuid": "^10.0.0"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/date-fns": "^2.6.0",
    "@types/dotenv": "^8.2.0",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^20.14.10",
    "@types/supertest": "^6.0.2",
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.8",
    "@types/uuid": "^10.0.0",
    "@vitest/coverage-v8": "^2.0.4",
    "nodemon": "^3.1.4",
    "prisma": "^6.6.0",
    "supertest": "^7.0.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.5.3",
    "vitest": "^2.0.4"
  },
  "resolutions": {
    "@types/express": "^4.17.21",
    "@types/express-serve-static-core": "^4.17.42"
  }
}



// ====== [3] backend/src/modules/loyalpyme/activity/activity.controller.ts ======
// filename: backend/src/activity/activity.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as activityService from './activity.service'; // Importar el servicio

/**
 * Handler para obtener el historial de actividad paginado del cliente autenticado.
 * GET / (montado bajo /api/customer/activity)
 */
export const getCustomerActivityHandler = async (req: Request, res: Response, next: NextFunction) => {
    // El userId viene de req.user a√±adido por authenticateToken
    const userId = req.user?.id;

    if (!userId) {
        // Esto no deber√≠a ocurrir si el middleware funciona, pero es una guarda
        return res.status(401).json({ message: 'Usuario no autenticado.' });
    }

    // Obtener par√°metros de paginaci√≥n de la query string, con valores por defecto
    const pageQuery = req.query.page as string | undefined;
    const limitQuery = req.query.limit as string | undefined;

    const page = parseInt(pageQuery || '1', 10);
    const limit = parseInt(limitQuery || '15', 10); // Default 15 items por p√°gina

    // Validar que sean n√∫meros v√°lidos
    if (isNaN(page) || page < 1) {
        return res.status(400).json({ message: 'Par√°metro "page" inv√°lido. Debe ser un n√∫mero mayor o igual a 1.' });
    }
    if (isNaN(limit) || limit < 1 || limit > 100) { // Limitar el m√°ximo por petici√≥n
        return res.status(400).json({ message: 'Par√°metro "limit" inv√°lido. Debe ser un n√∫mero entre 1 y 100.' });
    }

    console.log(`[Activity CTRL] Request received for user ${userId} activity. Page: ${page}, Limit: ${limit}`);

    try {
        const paginatedResult = await activityService.getCustomerActivityLog(userId, page, limit);
        res.status(200).json(paginatedResult);
    } catch (error) {
        // Pasar el error al manejador global de errores
        next(error);
    }
};


// ====== [4] backend/src/modules/loyalpyme/activity/activity.service.ts ======
// filename: backend/src/activity/activity.service.ts
import { PrismaClient, ActivityLog, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

// Tipo para la respuesta paginada
export interface PaginatedActivityLog {
    logs: Pick<ActivityLog, 'id' | 'type' | 'pointsChanged' | 'description' | 'createdAt'>[]; // Devolvemos solo campos necesarios
    totalPages: number;
    currentPage: number;
    totalItems: number;
}

/**
 * Obtiene el historial de actividad paginado para un usuario espec√≠fico.
 * @param userId ID del usuario.
 * @param page N√∫mero de p√°gina solicitada.
 * @param limit N√∫mero de items por p√°gina.
 * @returns Objeto con los logs paginados y metadatos de paginaci√≥n.
 */
export const getCustomerActivityLog = async (
    userId: string,
    page: number,
    limit: number
): Promise<PaginatedActivityLog> => {
    console.log(`[Activity SVC] Fetching activity log for user ${userId}, Page: ${page}, Limit: ${limit}`);

    const skip = (page - 1) * limit;

    try {
        // Usar transacci√≥n para obtener count y logs en una sola llamada a DB
        const [totalItems, logs] = await prisma.$transaction([
            prisma.activityLog.count({
                where: { userId: userId },
            }),
            prisma.activityLog.findMany({
                where: { userId: userId },
                select: { // Seleccionar solo los campos que necesita el frontend
                    id: true,
                    type: true,
                    pointsChanged: true,
                    description: true,
                    createdAt: true,
                },
                orderBy: {
                    createdAt: 'desc', // M√°s recientes primero
                },
                skip: skip,
                take: limit,
            }),
        ]);

        const totalPages = Math.ceil(totalItems / limit);
        console.log(`[Activity SVC] Found ${logs.length} logs on page ${page}. Total items: ${totalItems}, Total pages: ${totalPages}`);

        return {
            logs,
            totalPages,
            currentPage: page,
            totalItems,
        };

    } catch (error) {
        console.error(`[Activity SVC] Error fetching activity log for user ${userId}:`, error);
        // Podr√≠amos relanzar un error m√°s espec√≠fico si quisi√©ramos
        throw new Error('Error al obtener el historial de actividad desde la base de datos.');
    }
};


// ====== [5] backend/src/modules/loyalpyme/admin/admin-customer-bulk.controller.ts ======
// filename: backend/src/admin/admin-customer-bulk.controller.ts
// Version: 1.0.0 (Handlers extracted from admin-customer.controller, @ts-ignore removed, cleaned)

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client'; // Para tipos de error

// Importar solo los servicios necesarios para acciones masivas
import {
    bulkUpdateStatusForCustomers,
    bulkDeleteCustomers,
    bulkAdjustPointsForCustomers
} from './admin-customer-bulk.service'; // Ajustado a la nueva ubicaci√≥n del servicio

/**
 * Handler para actualizar estado activo/inactivo masivo.
 * PATCH /api/admin/customers/bulk-status
 */
export const bulkUpdateCustomerStatusHandler = async (req: Request, res: Response, next: NextFunction) => {
    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_BULK_CTRL] Critical: User or businessId missing in bulkUpdateCustomerStatusHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    const { customerIds, isActive } = req.body;
    console.log(`[ADM_CUST_BULK_CTRL] Request for bulk status update to ${isActive} for customers [${customerIds?.join(', ')}] by admin from business ${adminBusinessId}`);

    // Validaciones
    if (!adminBusinessId) { return res.status(403).json({ message: "Informaci√≥n de administrador no disponible." }); } // Doble check por si acaso
    if (!Array.isArray(customerIds) || customerIds.length === 0) { return res.status(400).json({ message: "Se requiere un array 'customerIds' con al menos un ID de cliente." }); }
    if (typeof isActive !== 'boolean') { return res.status(400).json({ message: "Se requiere el campo 'isActive' (true o false) para indicar el estado deseado." }); }
    if (!customerIds.every(id => typeof id === 'string')) { return res.status(400).json({ message: "Todos los elementos en 'customerIds' deben ser strings." }); }

    try {
        const result = await bulkUpdateStatusForCustomers(customerIds, adminBusinessId, isActive);
        res.status(200).json({ message: `Estado actualizado a ${isActive ? 'Activo' : 'Inactivo'} para ${result.count} cliente(s).`, count: result.count }); // Corregido: cliente(s)
    } catch (error) {
        console.error(`[ADM_CUST_BULK_CTRL] Failed bulk status update for customers [${customerIds.join(', ')}]:`, error);
        next(error);
    }
};

/**
 * Handler para eliminar m√∫ltiples clientes.
 * DELETE /api/admin/customers/bulk-delete
 */
export const bulkDeleteCustomersHandler = async (req: Request, res: Response, next: NextFunction) => {
     // --- FIX: Comprobaci√≥n expl√≠cita ---
     if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_BULK_CTRL] Critical: User or businessId missing in bulkDeleteCustomersHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    const { customerIds } = req.body; // Los IDs vienen en el body para DELETE masivo
    console.log(`[ADM_CUST_BULK_CTRL] Request for bulk delete for customers [${customerIds?.join(', ')}] by admin from business ${adminBusinessId}`);

    // Validaciones
    if (!adminBusinessId) { return res.status(403).json({ message: "Informaci√≥n de administrador no disponible." }); }
    if (!Array.isArray(customerIds) || customerIds.length === 0) { return res.status(400).json({ message: "Se requiere un array 'customerIds' con al menos un ID de cliente." }); }
    if (!customerIds.every(id => typeof id === 'string')) { return res.status(400).json({ message: "Todos los elementos en 'customerIds' deben ser strings." }); }

    try {
        const result = await bulkDeleteCustomers(customerIds, adminBusinessId);
        res.status(200).json({ message: `${result.count} cliente(s) eliminados correctamente.`, count: result.count }); // Corregido: cliente(s), correctamente
    } catch (error) {
        console.error(`[ADM_CUST_BULK_CTRL] Failed bulk delete for customers [${customerIds.join(', ')}]:`, error);
        // Si el servicio lanza un error espec√≠fico por FK, el manejador global lo capturar√°
        // pero podr√≠amos querer manejarlo aqu√≠ si el frontend necesita un c√≥digo de estado espec√≠fico (ej: 409 Conflict)
        if (error instanceof Error && error.message.includes('datos asociados')) {
             return res.status(409).json({ message: error.message }); // 409 Conflict
        }
        next(error);
    }
};

/**
 * Handler para ajustar los puntos de m√∫ltiples clientes.
 * POST /api/admin/customers/bulk-adjust-points
 */
export const bulkAdjustPointsHandler = async (req: Request, res: Response, next: NextFunction) => {
    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId) { // No necesitamos user.id aqu√≠ en el controller
        console.error("[ADM_CUST_BULK_CTRL] Critical: User or businessId missing in bulkAdjustPointsHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // const adminUserId = req.user.id; // Lo obtenemos pero no lo usamos activamente aqu√≠
    // --- FIN FIX ---

    const { customerIds, amount, reason } = req.body;
    // Log con menos info sensible
    console.log(`[ADM_CUST_BULK_CTRL] Request for bulk points adjustment by ${amount} for ${customerIds?.length} customers from business ${adminBusinessId}. Reason: ${reason || 'N/A'}`);

    // Validaciones
    if (!adminBusinessId) { return res.status(403).json({ message: "Informaci√≥n de administrador no disponible." }); }
    if (!Array.isArray(customerIds) || customerIds.length === 0) { return res.status(400).json({ message: "Se requiere un array 'customerIds' con al menos un ID de cliente." }); }
    if (typeof amount !== 'number' || amount === 0) { return res.status(400).json({ message: "La cantidad ('amount') debe ser un n√∫mero distinto de cero." }); }
    if (reason !== undefined && reason !== null && typeof reason !== 'string') { return res.status(400).json({ message: "La raz√≥n ('reason') debe ser un texto o nula/omitida." }); } // Corregido: raz√≥n
    if (!customerIds.every(id => typeof id === 'string')) { return res.status(400).json({ message: "Todos los elementos en 'customerIds' deben ser strings." }); }

    try {
        const result = await bulkAdjustPointsForCustomers( customerIds, adminBusinessId, amount, reason || null );
        const actionText = amount > 0 ? 'a√±adidos' : 'restados'; // Corregido: √±
        res.status(200).json({
            message: `${Math.abs(amount)} puntos ${actionText} correctamente para ${result.count} cliente(s).`, // Corregido: √±, cliente(s)
            count: result.count
        });
    } catch (error) {
        console.error(`[ADM_CUST_BULK_CTRL] Failed bulk points adjustment for customers [${customerIds?.join(', ')}]:`, error);
        next(error);
    }
};

// End of File: backend/src/admin/admin-customer-bulk.controller.ts


// ====== [6] backend/src/modules/loyalpyme/admin/admin-customer-bulk.service.ts ======
// filename: backend/src/admin/admin-customer-bulk.service.ts
// Version: 1.1.1 (Store reason or null in ActivityLog description for bulk adjustments)

import {
    PrismaClient, Prisma, UserRole,
    ActivityType // Aseg√∫rate que est√© importado
} from '@prisma/client';

const prisma = new PrismaClient();

// Tipos (sin cambios)
interface BatchPayload { count: number; }

// bulkUpdateStatusForCustomers (sin cambios)
export const bulkUpdateStatusForCustomers = async ( customerIds: string[], adminBusinessId: string, isActive: boolean ): Promise<BatchPayload> => {
    const action = isActive ? 'Activating' : 'Deactivating'; console.log(`[ADM_CUST_BULK_SVC] ${action} ${customerIds.length} customers for business ${adminBusinessId}`); try { const result = await prisma.user.updateMany({ where: { id: { in: customerIds, }, businessId: adminBusinessId, role: UserRole.CUSTOMER_FINAL }, data: { isActive: isActive }, }); console.log(`[ADM_CUST_BULK_SVC] Bulk status update successful. ${result.count} customers updated to isActive=${isActive}.`); return result; } catch (error) { console.error(`[ADM_CUST_BULK_SVC] Error during bulk status update for customers [${customerIds.join(', ')}] of business ${adminBusinessId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { throw new Error(`Error de base de datos durante la actualizaci√≥n masiva: ${error.message}`); } throw new Error('Error inesperado durante la actualizaci√≥n masiva de estado.'); }
};

// bulkDeleteCustomers (sin cambios)
export const bulkDeleteCustomers = async ( customerIds: string[], adminBusinessId: string ): Promise<BatchPayload> => {
    console.log(`[ADM_CUST_BULK_SVC] Deleting ${customerIds.length} customers for business ${adminBusinessId}`); try { const result = await prisma.user.deleteMany({ where: { id: { in: customerIds, }, businessId: adminBusinessId, role: UserRole.CUSTOMER_FINAL }, }); console.log(`[ADM_CUST_BULK_SVC] Bulk delete successful. ${result.count} customers deleted.`); return result; } catch (error) { console.error(`[ADM_CUST_BULK_SVC] Error during bulk delete for customers [${customerIds.join(', ')}] of business ${adminBusinessId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2003') { throw new Error(`No se pudieron eliminar todos los clientes porque tienen datos asociados (registros de puntos, regalos, etc.). C√≥digo: ${error.code}`); } throw new Error(`Error de base de datos durante el borrado masivo: ${error.message} (C√≥digo: ${error.code})`); } throw new Error('Error inesperado durante el borrado masivo de clientes.'); }
};


// --- bulkAdjustPointsForCustomers MODIFICADO ---
/**
 * Ajusta puntos masivamente y crea logs individuales guardando la raz√≥n (o null).
 */
export const bulkAdjustPointsForCustomers = async (
    customerIds: string[],
    adminBusinessId: string,
    amount: number,
    reason: string | null // La raz√≥n viene como argumento
): Promise<BatchPayload> => {
    const action = amount > 0 ? 'Adding' : 'Subtracting';
    console.log(`[ADM_CUST_BULK_SVC] ${action} ${Math.abs(amount)} points for ${customerIds.length} customers. Business: ${adminBusinessId}. Reason: ${reason || 'N/A'}`);

    if (amount === 0) { console.warn(`[ADM_CUST_BULK_SVC] Attempted bulk adjust points with amount 0. No action taken.`); return { count: 0 }; }

    const whereClause: Prisma.UserWhereInput = { id: { in: customerIds }, businessId: adminBusinessId, role: UserRole.CUSTOMER_FINAL };
    let updateResult: BatchPayload;

    try {
        // 1. Ejecutar la actualizaci√≥n masiva
        updateResult = await prisma.user.updateMany({ where: whereClause, data: { points: { increment: amount } }, });
        console.log(`[ADM_CUST_BULK_SVC] Bulk points update successful. ${updateResult.count} customers updated.`);
    } catch (error) {
        console.error(`[ADM_CUST_BULK_SVC] Error during bulk points update for customers [${customerIds.join(', ')}] of business ${adminBusinessId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { throw new Error(`Error de base de datos durante el ajuste masivo de puntos: ${error.message}`); } throw new Error('Error inesperado durante el ajuste masivo de puntos.');
    }

    // 2. Si se actualiz√≥ algo, intentar crear logs
    if (updateResult.count > 0) {
        try {
            // 2.1 Obtener IDs afectados
            const affectedUsers = await prisma.user.findMany({ where: whereClause, select: { id: true } });
            console.log(`[ADM_CUST_BULK_SVC] Found ${affectedUsers.length} affected user IDs to log.`);

            // 2.2 Crear datos para los logs (MODIFICACI√ìN en description)
            const logsToCreate: Prisma.ActivityLogCreateManyInput[] = affectedUsers.map(user => ({
                userId: user.id,
                businessId: adminBusinessId,
                type: ActivityType.POINTS_ADJUSTED_ADMIN,
                pointsChanged: amount,
                description: reason || null, // <-- GUARDA LA RAZ√ìN O NULL
                // No hay IDs relacionados
            }));

            // 2.3 Crear los logs
            if (logsToCreate.length > 0) {
                const logResult = await prisma.activityLog.createMany({ data: logsToCreate, skipDuplicates: true, });
                console.log(`[ADM_CUST_BULK_SVC] Successfully created ${logResult.count} activity logs for bulk adjustment.`);
            }
        } catch (logError) {
            console.error(`[ADM_CUST_BULK_SVC] WARNING: Failed to create some or all activity logs for bulk adjustment for business ${adminBusinessId}. Error:`, logError);
        }
    }

    // 3. Devolver resultado del updateMany
    return updateResult;
};
// --- FIN bulkAdjustPointsForCustomers ---

// End of File: backend/src/admin/admin-customer-bulk.service.ts


// ====== [7] backend/src/modules/loyalpyme/admin/admin-customer-individual.controller.ts ======
// filename: backend/src/admin/admin-customer-individual.controller.ts
// Version: 1.0.0 (Handlers extracted from admin-customer.controller, @ts-ignore removed, cleaned)

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client'; // Para tipos de error

// Importar solo los servicios necesarios para acciones individuales
import {
    getCustomerDetailsById,
    updateAdminNotesForCustomer,
    adjustPointsForCustomer,
    changeCustomerTier,
    assignRewardToCustomer,
    toggleFavoriteStatus,
    toggleActiveStatusForCustomer
} from './admin-customer-individual.service'; // Ajustado a la nueva ubicaci√≥n del servicio

/**
 * Handler para obtener los detalles completos de un cliente espec√≠fico.
 */
export const getCustomerDetailsHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;

    // --- FIX: Comprobaci√≥n expl√≠cita de req.user y req.user.businessId ---
    if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in getCustomerDetailsHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    console.log(`[ADM_CUST_IND_CTRL] Request to get details for customer ${customerId} by admin from business ${adminBusinessId}`);
    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }

    try {
        const customerDetails = await getCustomerDetailsById(customerId, adminBusinessId);
        if (!customerDetails) { return res.status(404).json({ message: "Cliente no encontrado o no pertenece a este negocio." }); }
        res.status(200).json(customerDetails);
    } catch (error) {
        console.error(`[ADM_CUST_IND_CTRL] Failed to get details for customer ${customerId}:`, error);
        // Pasar error al manejador global, excepto 404
        if (error instanceof Error && (error.message.includes('no encontrado') || error.message.includes('no pertenece'))) {
            return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para actualizar las notas de administrador de un cliente.
 */
export const updateCustomerNotesHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;
    const { notes } = req.body;

    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in updateCustomerNotesHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    console.log(`[ADM_CUST_IND_CTRL] Request to update notes for customer ${customerId} by admin from business ${adminBusinessId}`);
    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }
    // Permitir enviar 'notes' como null expl√≠citamente
    if (notes === undefined) { return res.status(400).json({ message: "Falta el campo 'notes' en el cuerpo de la petici√≥n (puede ser null)." }); }
    if (notes !== null && typeof notes !== 'string') { return res.status(400).json({ message: "El campo 'notes' debe ser un texto o nulo." }); }

    try {
        const updatedCustomer = await updateAdminNotesForCustomer(customerId, adminBusinessId, notes);
        res.status(200).json({ message: `Notas actualizadas correctamente para ${updatedCustomer.email}.` }); // Corregido: correctamente
    } catch (error) {
        console.error(`[ADM_CUST_IND_CTRL] Failed to update notes for customer ${customerId}:`, error);
         if (error instanceof Error && (error.message.includes('no encontrado') || error.message.includes('no pertenece'))) {
             return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para ajustar puntos.
 */
export const adjustCustomerPoints = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;
    const { amount, reason } = req.body;

    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId || !req.user.id) { // Necesitamos id y businessId
        console.error("[ADM_CUST_IND_CTRL] Critical: User, businessId or userId missing in adjustCustomerPoints.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminUserId = req.user.id; // Se usaba impl√≠citamente antes, ahora expl√≠cito
    const adminBusinessId = req.user.businessId;
     // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }
    if (typeof amount !== 'number' || amount === 0) { return res.status(400).json({ message: "La cantidad ('amount') debe ser un n√∫mero distinto de cero." }); }

    try {
        const updatedCustomer = await adjustPointsForCustomer( customerId, adminBusinessId, amount, reason );
        res.status(200).json({ message: `Puntos ajustados correctamente para ${updatedCustomer.email}.`, customer: { id: updatedCustomer.id, points: updatedCustomer.points } }); // Corregido: correctamente
    }
    catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to adjust points for customer ${customerId}:`, error); next(error); }
};

/**
 * Handler para cambiar tier.
 */
export const changeCustomerTierHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;
    const { tierId } = req.body;

     // --- FIX: Comprobaci√≥n expl√≠cita ---
     if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in changeCustomerTierHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }
    if (tierId === undefined) { return res.status(400).json({ message: "Falta el ID del nivel ('tierId') en el cuerpo de la petici√≥n (puede ser nulo)." }); }
    if (tierId !== null && typeof tierId !== 'string') { return res.status(400).json({ message: "El ID del nivel ('tierId') debe ser un texto o nulo." }); }

    try {
        const updatedCustomer = await changeCustomerTier( customerId, adminBusinessId, tierId );
        res.status(200).json({ message: `Nivel cambiado correctamente para ${updatedCustomer.email}.`, customer: { id: updatedCustomer.id, currentTierId: updatedCustomer.currentTierId, tierAchievedAt: updatedCustomer.tierAchievedAt } }); // Corregido: correctamente
    }
    catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to change tier for customer ${customerId} to ${tierId}:`, error); next(error); }
};

/**
 * Handler para asignar recompensa.
 */
export const assignRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;
    const { rewardId } = req.body;

    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId || !req.user.id) { // Necesitamos id y businessId
        console.error("[ADM_CUST_IND_CTRL] Critical: User, businessId or userId missing in assignRewardHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminUserId = req.user.id;
    const adminBusinessId = req.user.businessId;
     // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }
    if (!rewardId || typeof rewardId !== 'string') { return res.status(400).json({ message: "Falta el ID de la recompensa ('rewardId') o no es v√°lido." }); // Corregido: v√°lido
    }

    try {
        const grantedReward = await assignRewardToCustomer( customerId, adminBusinessId, rewardId, adminUserId );
        res.status(201).json({ message: `Recompensa asignada correctamente al cliente.`, grantedRewardId: grantedReward.id }); // Corregido: correctamente
    }
    catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to assign reward ${rewardId} to customer ${customerId}:`, error); next(error); }
};

/**
 * Handler para toggle favorito.
 */
export const toggleFavoriteHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;

    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in toggleFavoriteHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }

    try {
        const updatedCustomer = await toggleFavoriteStatus( customerId, adminBusinessId );
        res.status(200).json({ message: `Estado de favorito cambiado para ${updatedCustomer.email}. Nuevo estado: ${updatedCustomer.isFavorite}`, customer: { id: updatedCustomer.id, isFavorite: updatedCustomer.isFavorite } });
    }
    catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to toggle favorite status for customer ${customerId}:`, error); next(error); }
};

/**
 * Handler para toggle activo.
 */
export const toggleActiveStatusHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;

     // --- FIX: Comprobaci√≥n expl√≠cita ---
     if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in toggleActiveStatusHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }

    try {
        const updatedCustomer = await toggleActiveStatusForCustomer(customerId, adminBusinessId);
        res.status(200).json({ message: `Estado cambiado para ${updatedCustomer.email}. Nuevo estado: ${updatedCustomer.isActive ? 'Activo' : 'Inactivo'}`, customer: { id: updatedCustomer.id, isActive: updatedCustomer.isActive } });
    } catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to toggle active status for customer ${customerId}:`, error); next(error); }
};


// End of File: backend/src/admin/admin-customer-individual.controller.ts


// ====== [8] backend/src/modules/loyalpyme/admin/admin-customer-individual.service.ts ======
// filename: backend/src/admin/admin-customer-individual.service.ts
// Version: 1.2.0 (Use i18n reward fields name_es/name_en)

import {
    PrismaClient, Prisma, UserRole, User, GrantedReward,
    ActivityType, Reward // <-- Reward debe estar aqu√≠ aunque usemos Pick
} from '@prisma/client';
const prisma = new PrismaClient();

// Tipos y Selectores (sin cambios)
const customerDetailsSelector = Prisma.validator<Prisma.UserSelect>()({ id: true, email: true, name: true, points: true, createdAt: true, isActive: true, isFavorite: true, tierAchievedAt: true, adminNotes: true, businessId: true, role: true, currentTier: { select: { id: true, name: true, level: true, description: true } } });
export type CustomerDetails = Prisma.UserGetPayload<{ select: typeof customerDetailsSelector }>;
type FavoriteStatusUpdate = Pick<User, 'id' | 'email' | 'isFavorite'>;
type ActiveStatusUpdate = Pick<User, 'id' | 'email' | 'isActive'>;
type NotesUpdate = Pick<User, 'id' | 'email' | 'adminNotes'>;

// getCustomerDetailsById (sin cambios)
export const getCustomerDetailsById = async (customerId: string, adminBusinessId: string): Promise<CustomerDetails | null> => {
     console.log(`[ADM_CUST_IND_SVC] Getting details for customer ${customerId} by admin from business ${adminBusinessId}`); try { const customerDetails = await prisma.user.findUnique({ where: { id: customerId, businessId: adminBusinessId, role: UserRole.CUSTOMER_FINAL }, select: customerDetailsSelector }); if (!customerDetails) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } console.log(`[ADM_CUST_IND_SVC] Details found for customer ${customerId}`); return customerDetails; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error getting details for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { throw new Error(`Error de base de datos al obtener detalles del cliente: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al obtener los detalles del cliente.'); }
};

// updateAdminNotesForCustomer (sin cambios)
export const updateAdminNotesForCustomer = async ( customerId: string, adminBusinessId: string, notes: string | null ): Promise<NotesUpdate> => {
     console.log(`[ADM_CUST_IND_SVC] Updating admin notes for customer ${customerId} by admin from business ${adminBusinessId}`); try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { adminNotes: notes }, select: { id: true, email: true, adminNotes: true } }); console.log(`[ADM_CUST_IND_SVC] Admin notes updated successfully for customer ${customer.email} (${customerId})`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error updating admin notes for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error(`No se encontr√≥ el cliente especificado al intentar actualizar las notas.`); } throw new Error(`Error de base de datos al actualizar las notas: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al actualizar las notas del administrador.'); }
};

// adjustPointsForCustomer (sin cambios respecto a versi√≥n anterior)
export const adjustPointsForCustomer = async ( customerId: string, adminBusinessId: string, amount: number, reason?: string | null ): Promise<User> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to adjust points for customer ${customerId} by ${amount}. Reason: ${reason || 'N/A'}. Admin Business: ${adminBusinessId}`); if (amount === 0) { throw new Error("La cantidad de puntos a ajustar no puede ser cero."); } try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId }, select: { businessId: true, id: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado.`); } if (customer.businessId !== adminBusinessId) { throw new Error("No tienes permiso para modificar este cliente."); } const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { points: { increment: amount } } }); console.log(`[ADM_CUST_IND_SVC - TX] Points adjusted successfully for customer ${userAfterUpdate.email} (${customerId}). New balance potentially: ${userAfterUpdate.points}`); await tx.activityLog.create({ data: { userId: customerId, businessId: adminBusinessId, type: ActivityType.POINTS_ADJUSTED_ADMIN, pointsChanged: amount, description: reason || null } }); console.log(`[ADM_CUST_IND_SVC - TX] ActivityLog created for admin points adjustment for user ${customerId}.`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error adjusting points for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error(`No se encontr√≥ el cliente especificado para actualizar.`); } throw new Error(`Error de base de datos al ajustar puntos: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al ajustar los puntos.'); }
};

// changeCustomerTier (sin cambios)
export const changeCustomerTier = async ( customerId: string, adminBusinessId: string, tierId: string | null ): Promise<User> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to change tier for customer ${customerId} to tier ${tierId ?? 'NULL'}. Admin Business: ${adminBusinessId}`); try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } if (tierId !== null) { const tierExists = await tx.tier.findUnique({ where: { id: tierId, businessId: adminBusinessId }, select: { id: true } }); if (!tierExists) { throw new Error(`El nivel seleccionado (ID: ${tierId}) no es v√°lido o no pertenece a tu negocio.`); } } const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { currentTierId: tierId, tierAchievedAt: tierId ? new Date() : null } }); console.log(`[ADM_CUST_IND_SVC] Tier changed successfully for customer ${userAfterUpdate.email} (${customerId}) to ${tierId ?? 'NULL'}`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error changing tier for customer ${customerId} to ${tierId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { throw new Error(`Error de base de datos al cambiar nivel: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al cambiar el nivel del cliente.'); }
};

// --- assignRewardToCustomer MODIFICADO ---
/**
 * Asigna una recompensa como "regalo" a un cliente.
 */
export const assignRewardToCustomer = async (
    customerId: string,
    adminBusinessId: string,
    rewardId: string,
    adminUserId: string
): Promise<GrantedReward> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to assign reward ${rewardId} to customer ${customerId} by admin ${adminUserId} from business ${adminBusinessId}`);
     try {
        const grantedReward = await prisma.$transaction(async (tx) => {
            const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, email: true } });
            if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); }

            // --- MODIFICADO: Seleccionar name_es y name_en en lugar de name ---
            const reward = await tx.reward.findUnique({
                where: { id: rewardId, businessId: adminBusinessId },
                select: {
                    id: true,
                    isActive: true,
                    name_es: true, // Seleccionar nombre ES
                    name_en: true  // Seleccionar nombre EN
                }
            });
            // --- FIN MODIFICADO ---

            if (!reward) { throw new Error(`Recompensa con ID ${rewardId} no encontrada o no pertenece a tu negocio.`); }
            if (!reward.isActive) {
                // --- MODIFICADO: Usar name_es o name_en en el mensaje de error ---
                const rewardDisplayName = reward.name_es || reward.name_en || `ID ${rewardId}`;
                throw new Error(`La recompensa "${rewardDisplayName}" no est√° activa y no puede ser asignada.`);
                 // --- FIN MODIFICADO ---
            }

            const newGrantedReward = await tx.grantedReward.create({
                data: { userId: customerId, rewardId: rewardId, businessId: adminBusinessId, assignedById: adminUserId, status: 'PENDING', }
            });

            // --- MODIFICADO: Usar name_es o name_en en el log ---
            const rewardLogName = reward.name_es || reward.name_en || `ID ${rewardId}`;
            console.log(`[ADM_CUST_IND_SVC - TX] Reward ${rewardLogName} (${rewardId}) assigned successfully to customer ${customer.email} (${customerId}). GrantedReward ID: ${newGrantedReward.id}`);
            // --- FIN MODIFICADO ---

            return newGrantedReward;
        });
        return grantedReward;
    } catch (error) {
        console.error(`[ADM_CUST_IND_SVC] Error assigning reward ${rewardId} to customer ${customerId}:`, error);
        // --- MODIFICADO: Usar Prisma.PrismaClientKnownRequestError para chequear error ---
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            // No necesitamos chequear P2002 aqu√≠ espec√≠ficamente, un error gen√©rico est√° bien
            throw new Error(`Error de base de datos al asignar recompensa: ${error.message}`);
        }
        // --- FIN MODIFICADO ---
        if (error instanceof Error) { throw error; }
        throw new Error('Error inesperado al asignar la recompensa.');
    }
};
// --- FIN assignRewardToCustomer ---

// toggleFavoriteStatus (sin cambios)
export const toggleFavoriteStatus = async ( customerId: string, adminBusinessId: string ): Promise<FavoriteStatusUpdate> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to toggle favorite status for customer ${customerId} by admin from business ${adminBusinessId}`); try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, isFavorite: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } const newFavoriteStatus = !customer.isFavorite; const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { isFavorite: newFavoriteStatus }, select: { id: true, email: true, isFavorite: true } }); console.log(`[ADM_CUST_IND_SVC] Favorite status for customer ${customer.email} (${customerId}) toggled to ${newFavoriteStatus}`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error toggling favorite status for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error(`No se encontr√≥ el cliente especificado al intentar actualizar.`); } throw new Error(`Error de base de datos al cambiar estado de favorito: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al cambiar el estado de favorito.'); }
};

// toggleActiveStatusForCustomer (sin cambios)
export const toggleActiveStatusForCustomer = async ( customerId: string, adminBusinessId: string ): Promise<ActiveStatusUpdate> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to toggle active status for customer ${customerId} by admin from business ${adminBusinessId}`); try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, isActive: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } const newActiveStatus = !customer.isActive; const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { isActive: newActiveStatus }, select: { id: true, email: true, isActive: true } }); console.log(`[ADM_CUST_IND_SVC] Active status for customer ${customer.email} (${customerId}) toggled to ${newActiveStatus}`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error toggling active status for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error(`No se encontr√≥ el cliente especificado al intentar actualizar.`); } throw new Error(`Error de base de datos al cambiar estado activo: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al cambiar el estado activo del cliente.'); }
};

// End of File: backend/src/admin/admin-customer-individual.service.ts


// ====== [9] backend/src/modules/loyalpyme/admin/admin-customer-list.controller.ts ======
// filename: backend/src/admin/admin-customer-list.controller.ts
// Version: 1.0.0 (Handler extracted from admin-customer.controller, @ts-ignore removed)

import { Request, Response, NextFunction } from 'express';

// Importar s√≥lo el servicio necesario
import { getCustomersForBusiness } from './admin-customer-list.service'; // Ajustado a la nueva ubicaci√≥n del servicio

// Tipos locales para este controlador (podr√≠an moverse a un DTO o types si se complejizan)
type SortDirection = 'asc' | 'desc';
interface ControllerGetCustomersOptions {
    page?: number;
    limit?: number;
    sortBy?: string;
    sortDir?: SortDirection;
    filters?: {
        search?: string;
        isFavorite?: boolean;
        isActive?: boolean;
        tierId?: string;
    }
}

/**
 * Handler para que el Admin obtenga la lista PAGINADA, FILTRADA y ORDENADA de clientes.
 * GET /api/admin/customers
 */
export const getAdminCustomers = async (req: Request, res: Response, next: NextFunction) => {
    console.log('[ADM_CUST_LIST_CTRL] Entering getAdminCustomers handler...');

    // --- FIX: Comprobaci√≥n expl√≠cita de req.user y req.user.businessId ---
    if (!req.user || !req.user.businessId) {
        // Este error no deber√≠a ocurrir si authenticateToken funciona, pero es una guarda segura.
        console.error("[ADM_CUST_LIST_CTRL] Critical: User or businessId missing after authenticateToken.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId; // Ahora podemos acceder de forma segura
    console.log(`[ADM_CUST_LIST_CTRL] Admin businessId: ${adminBusinessId}`);
    // --- FIN FIX ---

    // Leer par√°metros de query (sin cambios)
    const page = parseInt(req.query.page as string || '1', 10);
    const limit = parseInt(req.query.limit as string || '10', 10);
    const sortBy = req.query.sortBy as string || 'createdAt';
    const sortDirInput = req.query.sortDir as string;
    const sortDir: SortDirection = sortDirInput === 'asc' ? 'asc' : 'desc';
    const search = req.query.search as string | undefined;
    const isActiveParam = req.query.isActive as string | undefined;
    const isFavoriteParam = req.query.isFavorite as string | undefined;
    const tierIdParam = req.query.tierId as string | undefined;

    // Construir objeto de filtros (sin cambios)
    const filters: ControllerGetCustomersOptions['filters'] = {};
    if (search?.trim()) filters.search = search.trim();
    if (isActiveParam !== undefined) filters.isActive = isActiveParam === 'true';
    if (isFavoriteParam !== undefined) filters.isFavorite = isFavoriteParam === 'true';
    if (tierIdParam?.trim()) filters.tierId = tierIdParam.trim();

    // Construir objeto de opciones (sin cambios)
    const options: ControllerGetCustomersOptions = {
        page: isNaN(page) || page < 1 ? 1 : page,
        limit: isNaN(limit) || limit < 1 ? 10 : limit,
        sortBy: sortBy,
        sortDir: sortDir,
        filters: filters
    };

    console.log(`[ADM_CUST_LIST_CTRL] Parsed options being sent to service:`, options);

    try {
        // Llamar al servicio (sin cambios)
        const result = await getCustomersForBusiness(adminBusinessId, options);
        console.log(`[ADM_CUST_LIST_CTRL] Service call returned. Result has ${result?.items?.length ?? 'N/A'} items. Total items: ${result?.totalItems ?? 'N/A'}`);
        res.status(200).json(result);
    } catch (error) {
        console.error("[ADM_CUST_LIST_CTRL] *** ERROR caught in getAdminCustomers handler:", error);
        next(error); // Pasar al manejador de errores global
    }
};

// End of File: backend/src/admin/admin-customer-list.controller.ts


// ====== [10] backend/src/modules/loyalpyme/admin/admin-customer-list.service.ts ======
// filename: backend/src/admin/admin-customer-list.service.ts
// Version: 1.0.0 (Extracted from admin-customer.service.ts and cleaned)

import { PrismaClient, Prisma, UserRole } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos y Selectores (Copiados del original, necesarios para esta funci√≥n) ---
interface GetCustomersOptions {
    page?: number;
    limit?: number;
    sortBy?: string;
    sortDir?: 'asc' | 'desc';
    filters?: {
        search?: string;
        isFavorite?: boolean;
        isActive?: boolean;
        tierId?: string;
    }
}

const customerListItemSelector = Prisma.validator<Prisma.UserSelect>()({
    id: true, name: true, email: true, points: true, createdAt: true, isActive: true, isFavorite: true,
    currentTier: { select: { name: true, id: true, level: true } }
});
type CustomerListItem = Prisma.UserGetPayload<{ select: typeof customerListItemSelector }>;
// --- Fin Tipos y Selectores ---


/**
 * Obtiene una lista paginada, filtrada y ordenada de clientes para un negocio espec√≠fico.
 */
export const getCustomersForBusiness = async (
    businessId: string,
    options: GetCustomersOptions = {}
): Promise<{ items: CustomerListItem[], totalPages: number, currentPage: number, totalItems: number }> => {
    const { page = 1, limit = 10, sortBy = 'createdAt', sortDir = 'desc', filters = {} } = options;
    // Log inicial con todos los par√°metros (√∫til para debug)
    console.log(`[ADM_CUST_LIST_SVC] getCustomersForBusiness - Fetching: businessId=${businessId}, Page=${page}, Limit=${limit}, SortBy=${sortBy}, SortDir=${sortDir}, Filters=`, filters);
    const allowedSortByFields = ['name', 'email', 'points', 'createdAt', 'isActive', 'isFavorite', 'currentTier.level'];
    const safeSortBy = allowedSortByFields.includes(sortBy) ? sortBy : 'createdAt';
    const safeSortDir = sortDir === 'asc' ? 'asc' : 'desc';
    const skip = (page - 1) * limit;

    try {
        // Construcci√≥n de whereClause con todos los filtros
        const whereClause: Prisma.UserWhereInput = {
            businessId: businessId,
            role: UserRole.CUSTOMER_FINAL
        };

        // Filtro de B√∫squeda (Name/Email)
        if (filters.search && filters.search.trim() !== '') {
            const searchTerm = filters.search.trim();
            whereClause.OR = [
                { name: { contains: searchTerm, mode: 'insensitive' } },
                { email: { contains: searchTerm, mode: 'insensitive' } }
            ];
        }

        // Filtro Favorito (isFavorite)
        if (filters.isFavorite !== undefined) {
            whereClause.isFavorite = filters.isFavorite;
        }

        // Filtro Estado (isActive)
        if (filters.isActive !== undefined) {
            whereClause.isActive = filters.isActive;
        }

        // Filtro Nivel (tierId)
        if (filters.tierId && filters.tierId.trim() !== '') {
             if (filters.tierId === 'NONE') { // Manejar expl√≠citamente "Sin Nivel"
                whereClause.currentTierId = null;
             } else {
                whereClause.currentTierId = filters.tierId;
             }
        }

        // Ordenaci√≥n (OrderBy)
        let orderByClause: Prisma.UserOrderByWithRelationInput | Prisma.UserOrderByWithRelationInput[];
        if (safeSortBy === 'currentTier.level') {
            orderByClause = { currentTier: { level: safeSortDir } };
        } else {
            orderByClause = { [safeSortBy]: safeSortDir };
        }

        const selectClause = customerListItemSelector;
        // Log de cl√°usulas finales (√∫til para debug)
        console.log('[ADM_CUST_LIST_SVC] getCustomersForBusiness - Final Clauses:', { where: whereClause, orderBy: orderByClause });

        // Ejecutar Consultas (COUNT y FINDMANY) en transacci√≥n
        const [totalItems, customers] = await prisma.$transaction([
            prisma.user.count({ where: whereClause }),
            prisma.user.findMany({
                where: whereClause,
                select: selectClause,
                orderBy: orderByClause,
                skip: skip,
                take: limit,
            })
        ]);

        console.log(`[ADM_CUST_LIST_SVC] getCustomersForBusiness - Found ${customers.length} customers on page ${page}. Total items matching filters: ${totalItems}`);
        const totalPages = Math.ceil(totalItems / limit);
        console.log(`[ADM_CUST_LIST_SVC] getCustomersForBusiness - Calculation done. Total pages: ${totalPages}`);

        return { items: customers, totalPages: totalPages, currentPage: page, totalItems: totalItems };

    } catch (error) {
        console.error(`[ADM_CUST_LIST_SVC] *** ERROR in getCustomersForBusiness for business ${businessId}:`, error);
        console.error(`[ADM_CUST_LIST_SVC] Options causing error:`, options);
        throw new Error('Error al obtener la lista de clientes desde la base de datos.');
    }
};

// End of File: backend/src/admin/admin-customer-list.service.ts


// ====== [11] backend/src/modules/loyalpyme/admin/admin-stats.controller.ts ======
// filename: backend/src/admin/admin-stats.controller.ts
// Version: 1.0.0

import { Request, Response, NextFunction } from 'express';
// Importamos la funci√≥n del servicio que acabamos de crear
import { getOverviewStats, AdminOverviewStatsData } from './admin-stats.service';

/**
 * Handler para obtener las estad√≠sticas del overview para el dashboard del admin.
 * GET /api/admin/stats/overview
 */
export const handleGetOverviewStats = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  // El middleware 'authenticateToken' ya deber√≠a haber a√±adido req.user
  // El middleware 'checkRole' ya deber√≠a haber verificado que es BUSINESS_ADMIN
  const businessId = req.user?.businessId;

  console.log(`[AdminStatsController] Solicitud de overview stats para businessId: ${businessId}`);

  // Comprobaci√≥n de seguridad adicional (aunque el middleware deber√≠a cubrirlo)
  if (!businessId) {
    console.warn('[AdminStatsController] No se encontr√≥ businessId en req.user. Acceso denegado.');
    // Usamos 403 Forbidden ya que el rol es correcto pero falta asociaci√≥n clave
    res.status(403).json({ message: 'El usuario administrador no est√° asociado a ning√∫n negocio.' });
    return; 
  }

  try {
    // Llamamos a la funci√≥n del servicio para obtener los datos
    const stats: AdminOverviewStatsData = await getOverviewStats(businessId);

    // Enviamos la respuesta exitosa con los datos
    res.status(200).json(stats);
    console.log(`[AdminStatsController] Stats enviadas correctamente para businessId: ${businessId}`);

  } catch (error) {
    // Si el servicio lanza un error, lo pasamos al manejador de errores global
    console.error(`[AdminStatsController] Error al obtener stats para business ${businessId}:`, error);
    next(error); // Pasamos el error al siguiente middleware (manejador de errores global)
  }
};

// Podr√≠an a√±adirse aqu√≠ m√°s handlers para otras estad√≠sticas si fueran necesarias.

// End of file: backend/src/admin/admin-stats.controller.ts


// ====== [12] backend/src/modules/loyalpyme/admin/admin-stats.service.ts ======
// filename: backend/src/admin/admin-stats.service.ts
// Version: 1.2.1 (Count points-based redemptions from ActivityLog)

import { PrismaClient, UserRole, QrCodeStatus, Prisma, ActivityType } from '@prisma/client';
import { startOfDay, endOfDay, subDays } from 'date-fns';

const prisma = new PrismaClient();

export interface AdminOverviewStatsData {
    totalActiveCustomers: number;
    newCustomersLast7Days: number;
    newCustomersPrevious7Days: number;
    pointsIssuedLast7Days: number;
    pointsIssuedPrevious7Days: number;
    rewardsRedeemedLast7Days: number;
    rewardsRedeemedPrevious7Days: number;
}

// Helper Functions (sin cambios respecto a tu versi√≥n anterior que funcionaba parcialmente)
async function _getTotalActiveCustomers(businessId: string): Promise<number> {
    return prisma.user.count({
        where: { businessId, isActive: true, role: UserRole.CUSTOMER_FINAL }
    });
}

async function _getNewCustomersCount(businessId: string, startDate: Date, endDate: Date): Promise<number> {
    return prisma.user.count({
        where: { businessId, role: UserRole.CUSTOMER_FINAL, createdAt: { gte: startDate, lte: endDate } }
    });
}

async function _getPointsIssuedSum(businessId: string, startDate: Date, endDate: Date): Promise<number> {
    const result = await prisma.qrCode.aggregate({
        _sum: { pointsEarned: true },
        where: { businessId, status: QrCodeStatus.COMPLETED, completedAt: { gte: startDate, lte: endDate } }
    });
    return result._sum.pointsEarned ?? 0;
}

// --- FUNCI√ìN MODIFICADA PARA CONTAR TODOS LOS CANJES ---
async function _getRewardsRedeemedCount(businessId: string, startDate: Date, endDate: Date): Promise<number> {
    let giftedRedeemedCount = 0;
    let pointsRedeemedCount = 0;

    try {
        // Contar regalos canjeados (como estaba antes)
        giftedRedeemedCount = await prisma.grantedReward.count({
            where: { businessId, status: 'REDEEMED', redeemedAt: { gte: startDate, lte: endDate } }
        });
    } catch (error) {
        console.error(`[AdminStatsService] Error counting gifted redeemed rewards:`, error);
        // Continuar para intentar contar los otros canjes, pero loguear el error
    }

    try {
        // Contar recompensas canjeadas por puntos (usando ActivityLog)
        pointsRedeemedCount = await prisma.activityLog.count({
            where: {
                businessId,
                type: ActivityType.POINTS_REDEEMED_REWARD, // Usar el tipo de actividad correcto
                createdAt: { gte: startDate, lte: endDate } // Usar createdAt del log
            }
        });
    } catch (error) {
        console.error(`[AdminStatsService] Error counting points redeemed rewards:`, error);
        // Continuar, pero loguear el error
    }
    
    // Log m√°s seguro para depuraci√≥n
    const startDateStr = startDate ? startDate.toISOString() : 'N/A';
    const endDateStr = endDate ? endDate.toISOString() : 'N/A';
    console.log(`[AdminStatsService DEBUG] Period: ${startDateStr} to ${endDateStr}. Gifted redeemed: ${giftedRedeemedCount}, Points redeemed: ${pointsRedeemedCount}`);
    
    return giftedRedeemedCount + pointsRedeemedCount;
}
// --- FIN FUNCI√ìN MODIFICADA ---


export const getOverviewStats = async (businessId: string): Promise<AdminOverviewStatsData> => {
    console.log(`[AdminStatsService] Calculating overview stats for businessId: ${businessId}`);

    try {
        const now = new Date();
        // Definici√≥n precisa de los rangos de fechas
        const startOfLast7Days = startOfDay(subDays(now, 6)); // Incluye hoy y los 6 d√≠as anteriores
        const endOfLast7Days = endOfDay(now);                 // Hasta el final del d√≠a de hoy

        const startOfPrevious7Days = startOfDay(subDays(now, 13)); // Empieza hace 13 d√≠as
        const endOfPrevious7Days = endOfDay(subDays(now, 7));   // Termina al final del d√≠a hace 7 d√≠as

        console.log(`[AdminStatsService DEBUG] Date Ranges - Last 7: ${startOfLast7Days.toISOString()} - ${endOfLast7Days.toISOString()}`);
        console.log(`[AdminStatsService DEBUG] Date Ranges - Prev 7: ${startOfPrevious7Days.toISOString()} - ${endOfPrevious7Days.toISOString()}`);

        const [
            totalActiveCustomers,
            newCustomersLast7Days,
            pointsIssuedLast7Days,
            rewardsRedeemedLast7Days, // Usar√° la funci√≥n modificada
            newCustomersPrevious7Days,
            pointsIssuedPrevious7Days,
            rewardsRedeemedPrevious7Days, // Usar√° la funci√≥n modificada
        ] = await Promise.all([
            _getTotalActiveCustomers(businessId),
            _getNewCustomersCount(businessId, startOfLast7Days, endOfLast7Days),
            _getPointsIssuedSum(businessId, startOfLast7Days, endOfLast7Days),
            _getRewardsRedeemedCount(businessId, startOfLast7Days, endOfLast7Days),
            _getNewCustomersCount(businessId, startOfPrevious7Days, endOfPrevious7Days),
            _getPointsIssuedSum(businessId, startOfPrevious7Days, endOfPrevious7Days),
            _getRewardsRedeemedCount(businessId, startOfPrevious7Days, endOfPrevious7Days),
        ]);

        const result = {
            totalActiveCustomers,
            newCustomersLast7Days,
            newCustomersPrevious7Days,
            pointsIssuedLast7Days,
            pointsIssuedPrevious7Days,
            rewardsRedeemedLast7Days,
            rewardsRedeemedPrevious7Days,
        };

        console.log(`[AdminStatsService] Stats calculated successfully for ${businessId}:`, result);
        return result;

    } catch (error) {
        console.error(`[AdminStatsService] CRITICAL Error calculating overview stats for business ${businessId}:`, error);
        // Es importante que el error se propague para que el controlador lo maneje
        throw new Error('Error cr√≠tico al obtener las estad√≠sticas del dashboard.');
    }
};


// ====== [13] backend/src/modules/loyalpyme/customer/customer.controller.ts ======
// filename: backend/src/customer/customer.controller.ts
// Version: 2.2.0 (Add handler for customer to get business config)

import { Request, Response, NextFunction } from 'express';

// Importar funciones desde el servicio de cliente
import {
    findActiveRewardsForCustomer,
    getPendingGrantedRewards,
    redeemGrantedReward,
    // --- NUEVO: Importar futura funci√≥n de servicio ---
    getCustomerFacingBusinessConfig // A√∫n no existe, se crear√° en customer.service
    // --- FIN NUEVO ---
} from './customer.service';

// Importar TierService para el handler de tiers del cliente
import * as TierService from '../tiers/tiers.service';


/**
 * Handler para que el cliente obtenga las recompensas activas de su negocio.
 * GET /api/customer/rewards
 */
export const getCustomerRewardsHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId || !req.user.id) {
        console.error('[CUST_CTRL] Error: User context (id or businessId) missing from request.');
        return res.status(401).json({ message: 'Informaci√≥n de usuario o negocio no encontrada en la sesi√≥n.' });
    }
    const businessId = req.user.businessId;
    const userId = req.user.id;
    console.log(`[CUST_CTRL] User ${userId} requesting rewards for business ${businessId}`);
    try {
        const rewards = await findActiveRewardsForCustomer(businessId);
        res.status(200).json(rewards);
    } catch (error) {
        console.error(`[CUST_CTRL] Error fetching rewards for business ${businessId}:`, error);
        next(error);
    }
};

/**
 * Handler para que el cliente obtenga sus regalos pendientes.
 * GET /api/customer/granted-rewards
 */
export const getPendingGrantedRewardsHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.id) {
        console.error('[CUST_CTRL] Error: userId missing from req.user for granted rewards request.');
        return res.status(401).json({ message: 'Informaci√≥n de usuario no encontrada en la sesi√≥n.' });
    }
    const userId = req.user.id;
    const userEmail = req.user.email;
    console.log(`[CUST_CTRL] User ${userId} (${userEmail || 'N/A'}) requesting pending granted rewards.`);
    try {
        const grantedRewards = await getPendingGrantedRewards(userId);
        res.status(200).json(grantedRewards);
    }
    catch (error) {
        console.error(`[CUST_CTRL] Failed to fetch pending granted rewards for user ${userId}:`, error);
        next(error);
    }
};

/**
 * Handler para que el cliente canjee un regalo espec√≠fico.
 * POST /api/customer/granted-rewards/:grantedRewardId/redeem
 */
export const redeemGrantedRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.id) {
        console.error('[CUST_CTRL] Error: userId missing from req.user for redeem request.');
        return res.status(401).json({ message: 'Informaci√≥n de usuario no encontrada en la sesi√≥n.' });
    }
    const userId = req.user.id;
    const { grantedRewardId } = req.params;
    console.log(`[CUST_CTRL] User ${userId} attempting to redeem granted reward ID: ${grantedRewardId}`);
    if (!grantedRewardId) { return res.status(400).json({ message: 'Falta el ID del regalo otorgado en la URL.' }); }
    try {
        const redeemedGrant = await redeemGrantedReward(userId, grantedRewardId);
        res.status(200).json({ message: 'Regalo canjeado con √©xito.', grantedRewardId: redeemedGrant.id, rewardId: redeemedGrant.rewardId, redeemedAt: redeemedGrant.redeemedAt });
    }
    catch (error) {
        console.error(`[CUST_CTRL] Failed to redeem granted reward ${grantedRewardId} for user ${userId}:`, error);
        if (error instanceof Error && (error.message.includes('no te pertenece') || error.message.includes('no encontrado'))) {
            return res.status(403).json({ message: error.message });
        }
        if (error instanceof Error && error.message.includes('ya fue canjeado')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};


/**
 * Handler para que el cliente obtenga los Tiers disponibles en su programa.
 * GET /api/customer/tiers
 */
export const getCustomerTiersHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId || !req.user.id) {
        console.error('[CUST_CTRL] Error: User context (id or businessId) missing in getCustomerTiersHandler.');
        return res.status(401).json({ message: 'Informaci√≥n de usuario o negocio no encontrada en la sesi√≥n.' });
    }
    const businessId = req.user.businessId;
    const userId = req.user.id;
    console.log(`[CUST_CTRL] User ${userId} requesting available tiers for business ${businessId}.`);
    try {
        const tiers = await TierService.findTiersByBusiness(businessId, true);
        res.status(200).json(tiers);
    } catch (error: any) {
        console.error(`[CUST_CTRL] Error getting tiers for customer of business ${businessId}:`, error);
        next(error);
    }
};

// --- NUEVO HANDLER ---
/**
 * Handler para que el cliente obtenga la configuraci√≥n relevante de su negocio.
 * GET /api/customer/business-config
 */
export const getCustomerBusinessConfigHandler = async (req: Request, res: Response, next: NextFunction) => {
    // El middleware authenticateToken ya verific√≥ el token y a√±adi√≥ req.user
    // El middleware checkRole ya verific√≥ que es CUSTOMER_FINAL
    if (!req.user || !req.user.businessId) {
        // Doble check por si acaso o si la info no se carg√≥ bien
        console.error('[CUST_CTRL] Error: businessId missing from req.user for business-config request.');
        return res.status(401).json({ message: 'Informaci√≥n de negocio no encontrada en la sesi√≥n.' });
    }
    const businessId = req.user.businessId;
    const userId = req.user.id; // √ötil para logs

    console.log(`[CUST_CTRL] User ${userId} requesting business config for business ${businessId}.`);

    try {
        // Llamar a la nueva funci√≥n del servicio (que crearemos a continuaci√≥n)
        const config = await getCustomerFacingBusinessConfig(businessId);

        if (!config) {
            // Esto podr√≠a pasar si el negocio asociado al usuario ya no existe, por ejemplo
            console.warn(`[CUST_CTRL] Business config not found for businessId: ${businessId}`);
            return res.status(404).json({ message: 'No se encontr√≥ la configuraci√≥n para el negocio asociado.' });
        }

        // Devolver solo la configuraci√≥n relevante para el cliente
        res.status(200).json(config);

    } catch (error) {
        console.error(`[CUST_CTRL] Error getting business config for user ${userId}, business ${businessId}:`, error);
        next(error); // Pasar al manejador de errores global
    }
};
// --- FIN NUEVO HANDLER ---


// End of File: backend/src/customer/customer.controller.ts


// ====== [14] backend/src/modules/loyalpyme/customer/customer.service.ts ======
// filename: backend/src/customer/customer.service.ts
// Version: 2.3.2 (Use i18n reward fields name_es/name_en)

import {
    PrismaClient,
    Reward,
    Prisma,
    User,
    GrantedReward,
    Business,
    TierCalculationBasis,
    ActivityType
} from '@prisma/client';

const prisma = new PrismaClient();

// Tipo CustomerBusinessConfig (sin cambios)
export type CustomerBusinessConfig = Pick<Business, 'tierCalculationBasis'> | null;

// --- findActiveRewardsForCustomer ACTUALIZADO ---
/**
 * Encuentra recompensas activas para el cliente, seleccionando campos i18n.
 */
export const findActiveRewardsForCustomer = async ( businessId: string ): Promise<Reward[]> => { // Devuelve Reward completo
  console.log( `[CUST_SVC] Finding active rewards for customer view for business: ${businessId}` );
  try {
    // Aunque antes no usaba select, lo a√±adimos para ser expl√≠citos
    // y asegurar que obtenemos los campos necesarios, incluidos los nuevos
    const rewards = await prisma.reward.findMany({
        where: { businessId: businessId, isActive: true, },
        select: {
            id: true,
            name_es: true, // Seleccionar campos nuevos
            name_en: true, // Seleccionar campos nuevos
            description_es: true,
            description_en: true,
            pointsCost: true,
            isActive: true,
            imageUrl: true,
            businessId: true, // Incluir si es necesario para alg√∫n tipo
            createdAt: true,
            updatedAt: true
        },
        orderBy: { pointsCost: 'asc', },
    });
    console.log( `[CUST_SVC] Found ${rewards.length} active rewards for business ${businessId}` );
    console.log('[DEBUG findActiveRewardsForCustomer] Rewards found:', rewards);
    // El tipo de retorno sigue siendo Reward[] porque select * devuelve el tipo Reward
    // Si quisi√©ramos un tipo m√°s espec√≠fico, lo ajustar√≠amos aqu√≠
    return rewards;
  } catch (error) {
    console.error( `[CUST_SVC] Error fetching active rewards for business ${businessId}:`, error );
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        throw new Error(`Error de base de datos al buscar recompensas: ${error.message}`);
    }
    throw new Error('Error inesperado al buscar recompensas activas.');
  }
};
// --- FIN findActiveRewardsForCustomer ---


// getPendingGrantedRewards (MODIFICADO para seleccionar name_es/en)
export const getPendingGrantedRewards = async (userId: string): Promise<GrantedReward[]> => {
    console.log(`[CUST_SVC] Fetching pending granted rewards for user ${userId}`);
    try {
        const grantedRewards = await prisma.grantedReward.findMany({
            where: { userId: userId, status: 'PENDING' },
            include: {
                reward: {
                    select: { // Seleccionar campos i18n
                        id: true,
                        name_es: true, // <-- Seleccionar nuevo campo
                        name_en: true, // <-- Seleccionar nuevo campo
                        description_es: true, // <-- Opcional: seleccionar si se necesita
                        description_en: true, // <-- Opcional: seleccionar si se necesita
                        imageUrl: true
                    }
                },
                assignedBy: { select: { name: true, email: true } },
                business: { select: { name: true } } // No necesitamos ID aqu√≠
            },
            orderBy: { assignedAt: 'desc' }
        });
        console.log(`[CUST_SVC] Found ${grantedRewards.length} pending granted rewards for user ${userId}`);
        console.log('[DEBUG getPendingGrantedRewards] Granted rewards found:', JSON.stringify(grantedRewards, null, 2));
        // El tipo GrantedReward[] devuelto ahora tendr√° la estructura interna de reward actualizada
        return grantedRewards;
    } catch (error) {
        console.error(`[CUST_SVC] Error fetching pending granted rewards for user ${userId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
             throw new Error(`Error de base de datos al buscar recompensas otorgadas: ${error.message}`);
        }
        throw new Error('Error inesperado al buscar recompensas otorgadas.');
    }
};


// --- redeemGrantedReward MODIFICADO ---
export const redeemGrantedReward = async ( userId: string, grantedRewardId: string ): Promise<GrantedReward> => {
    console.log(`[CUST_SVC] User ${userId} attempting to redeem granted reward ${grantedRewardId}`);
    try {
        const updatedGrantedReward = await prisma.$transaction(async (tx) => {
            // 1. Encontrar el GrantedReward y verificar estado y pertenencia
            //    Incluimos reward con sus nuevos campos de nombre y el businessId
            const grantedReward = await tx.grantedReward.findUnique({
                where: { id: grantedRewardId },
                include: {
                    // Incluimos la relaci√≥n reward completa para acceder a sus campos
                    reward: {
                        select: { // Seleccionar expl√≠citamente lo necesario
                            id: true,
                            name_es: true,
                            name_en: true
                        }
                    },
                    business: { select: { id: true } } // Necesario para el businessId del log
                }
            });

            if (!grantedReward) { throw new Error(`Regalo con ID ${grantedRewardId} no encontrado.`); }
            // Verificar que las relaciones necesarias existen
            if (!grantedReward.business?.id) { console.error(`[CUST_SVC] Critical: GrantedReward ${grantedRewardId} missing business relation!`); throw new Error(`Error interno: El regalo no est√° asociado a un negocio.`); }
            if (!grantedReward.reward?.id) { console.error(`[CUST_SVC] Critical: GrantedReward ${grantedRewardId} missing reward relation!`); throw new Error(`Error interno: El regalo no est√° asociado a una recompensa.`); }


            if (grantedReward.userId !== userId) { console.warn(`[CUST_SVC] Unauthorized attempt by user ${userId} to redeem granted reward ${grantedRewardId} belonging to user ${grantedReward.userId}`); throw new Error("Este regalo no te pertenece."); }
            if (grantedReward.status !== 'PENDING') {
                 // Usar los nuevos campos de nombre para el mensaje de error
                 const rewardDisplayName = grantedReward.reward.name_es || grantedReward.reward.name_en || `ID ${grantedReward.rewardId}`;
                throw new Error(`Este regalo (${rewardDisplayName}) ya fue canjeado o no es v√°lido (Estado: ${grantedReward.status}).`);
            }

            // 2. Actualizar el estado del GrantedReward
            const redeemed = await tx.grantedReward.update({
                where: { id: grantedRewardId, userId: userId, status: 'PENDING' },
                data: { status: 'REDEEMED', redeemedAt: new Date() }
            });

            // 3. Crear Entrada en ActivityLog
            // Usar los nuevos campos de nombre para la descripci√≥n
            const logDescription = grantedReward.reward.name_es || grantedReward.reward.name_en || null;
            await tx.activityLog.create({
                data: {
                    userId: userId,
                    businessId: grantedReward.business.id, // Usar el ID del negocio incluido
                    type: ActivityType.GIFT_REDEEMED,
                    pointsChanged: null,
                    description: logDescription, // Guardar nombre ES o EN o null
                    relatedGrantedRewardId: grantedRewardId
                }
            });

            console.log(`[CUST_SVC] Granted reward ${grantedRewardId} (${redeemed.rewardId}) successfully redeemed by user ${userId}. Activity logged.`);
            return redeemed;
        });
        return updatedGrantedReward;
    } catch (error) {
        console.error(`[CUST_SVC] Error redeeming granted reward ${grantedRewardId} for user ${userId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error("El regalo no se encontr√≥ o ya no estaba pendiente al intentar canjearlo."); } throw new Error(`Error de base de datos al canjear el regalo: ${error.message}`); }
        if (error instanceof Error) { throw error; }
        throw new Error('Error inesperado al canjear el regalo.');
    }
};
// --- FIN redeemGrantedReward ---

// getCustomerFacingBusinessConfig (sin cambios)
export const getCustomerFacingBusinessConfig = async (businessId: string): Promise<CustomerBusinessConfig> => { /* ... (sin cambios) ... */ console.log(`[CUST_SVC] Fetching customer-facing config for business: ${businessId}`); try { const config = await prisma.business.findUnique({ where: { id: businessId }, select: { tierCalculationBasis: true } }); if (!config) { console.warn(`[CUST_SVC] Business not found when fetching config: ${businessId}`); return null; } return { tierCalculationBasis: config.tierCalculationBasis ?? null }; } catch (error) { console.error(`[CUST_SVC] Error fetching customer-facing config for business ${businessId}:`, error); throw new Error('Error al obtener la configuraci√≥n del negocio.'); } };

// End of File: backend/src/customer/customer.service.ts


// ====== [15] backend/src/modules/loyalpyme/points/points.controller.ts ======
// filename: backend/src/points/points.controller.ts
// Version: 1.3.0 (Handle updated return value from validateQrCode service)

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client';
// --- MODIFICACI√ìN: Importar tambi√©n ValidateQrResult ---
import { generateQrCodeData, validateQrCode, redeemReward, ValidateQrResult } from './points.service';
// --- FIN MODIFICACI√ìN ---

// DTOs (sin cambios)
export interface GenerateQrDto {
    amount: number;
    ticketNumber: string;
}
export interface ValidateQrDto {
    qrToken: string;
}

/**
 * Handles the request to generate QR code data for a points transaction.
 * POST /api/points/generate-qr
 */
export const generateQrHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId || !req.user.role) {
        console.error("[POINTS CTRL] Critical: User context missing in generateQrHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const businessId = req.user.businessId;
    const role = req.user.role;

    if (role !== 'BUSINESS_ADMIN') {
        return res.status(403).json({ message: 'Acceso denegado. Solo administradores pueden generar c√≥digos QR.' });
    }

    const { amount, ticketNumber }: GenerateQrDto = req.body;
    if (amount === undefined || typeof amount !== 'number' || amount <= 0) {
         return res.status(400).json({ message: 'Transaction amount must be a positive number.' });
    }
    if (!ticketNumber || typeof ticketNumber !== 'string' || ticketNumber.trim() === '') {
         return res.status(400).json({ message: 'Ticket number is required.' });
    }

    try {
        const qrData = await generateQrCodeData(businessId, amount, ticketNumber.trim());
        res.status(201).json(qrData);
    } catch (error: unknown) {
        if (error instanceof Error) {
             return res.status(400).json({ message: error.message });
        }
        console.error('Server error in generateQrHandler (unexpected):', error);
        next(new Error('Error del servidor al generar c√≥digo QR.'));
    }
};


/**
 * Handles the request to validate a QR token and assign points to the customer.
 * POST /api/points/validate-qr
 */
export const validateQrHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.id || !req.user.role) {
        console.error("[POINTS CTRL] Critical: User context missing in validateQrHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const customerUserId = req.user.id;
    const role = req.user.role;

    if (role !== 'CUSTOMER_FINAL') {
         console.warn(`User ${customerUserId} with role ${role} attempted to validate QR.`);
         return res.status(403).json({ message: 'Acceso denegado. Solo cuentas de cliente pueden validar c√≥digos QR.' });
    }

    const { qrToken }: ValidateQrDto = req.body;
    if (!qrToken) {
         return res.status(400).json({ message: 'Se requiere el token QR.' });
    }

    try {
        // --- MODIFICACI√ìN: Capturar el objeto ValidateQrResult completo ---
        const result: ValidateQrResult = await validateQrCode(qrToken, customerUserId);
        // --- FIN MODIFICACI√ìN ---

        // --- MODIFICACI√ìN: Devolver el objeto updatedUser en la respuesta ---
        res.status(200).json({
            message: 'C√≥digo QR validado con √©xito. Puntos asignados.',
            pointsEarned: result.pointsEarned,
            user: result.updatedUser // Devolver los datos actualizados del usuario
        });
        // --- FIN MODIFICACI√ìN ---

    } catch (error: unknown) {
         if (error instanceof Error) {
             console.error('Error in validateQrHandler (service error):', error.message);
             return res.status(400).json({ message: error.message });
         }
         console.error('Server error in validateQrHandler (unexpected):', error);
         next(new Error('Ocurri√≥ un error interno durante la validaci√≥n del QR.'));
    }
};


/**
 * Handles the request to redeem a specific reward using customer points.
 * POST /api/points/redeem-reward/:rewardId
 */
export const redeemRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.id || !req.user.role) {
       console.error("[POINTS CTRL] Critical: User context missing in redeemRewardHandler.");
       return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
   }
   const userId = req.user.id;
   const role = req.user.role;
    const rewardId = req.params.rewardId;

    console.log(`[REDEEM CTRL] Handling request for user ${userId}, reward ${rewardId}`);

    if (role !== 'CUSTOMER_FINAL') {
        console.warn(`[REDEEM CTRL] Access denied for user ${userId || 'unknown'} with role ${role}.`);
        return res.status(403).json({ message: 'Acceso denegado. Solo cuentas de cliente autenticadas pueden canjear recompensas.' });
    }
    if (!rewardId) {
        console.error('[REDEEM CTRL] Reward ID missing from request parameters.');
        return res.status(400).json({ message: 'Se requiere el ID de la recompensa.' });
    }

    try {
        console.log(`[REDEEM CTRL] Calling redeemReward service for user ${userId} and reward ${rewardId}...`);
        const result = await redeemReward(userId, rewardId);
        console.log(`[REDEEM CTRL] Service call successful for user ${userId}, reward ${rewardId}.`);
        res.status(200).json(result);
    } catch (error: unknown) {
        console.error(`[REDEEM CTRL - ERROR] Error redeeming reward for user ${userId}, reward ${rewardId}:`, error);
        if (error instanceof Error) {
            return res.status(400).json({ message: error.message });
        }
        next(new Error('Error interno del servidor durante el canje de recompensa.'));
    }
};

// End of File: backend/src/points/points.controller.ts


// ====== [16] backend/src/modules/loyalpyme/points/points.service.ts ======
// backend/src/points/points.service.ts
import {
    PrismaClient,
    User,
    Reward,
    QrCode,
    Business, // Aseg√∫rate que Business est√° importado si lo usas directamente en tipos
    QrCodeStatus,
    UserRole,
    Prisma,
    TierBenefit,
    TierCalculationBasis,
    // Tier, // Tier no se usa directamente en este archivo
    // TierDowngradePolicy, // No se usa directamente
    ActivityType
} from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import { addMinutes, isAfter } from 'date-fns';
import { updateUserTier } from '../tiers/tier-logic.service';

const prisma = new PrismaClient();
const QR_EXPIRATION_MINUTES = 30; // O lee de config si es din√°mico por negocio

// Tipos y Interfaces
interface RedeemResult {
    message: string;
    newPointsBalance: number;
}

// Tipo para el resultado de QR validado, incluyendo datos del usuario actualizados
export interface ValidateQrResult {
    pointsEarned: number;
    updatedUser: { // Estructura devuelta al frontend
        id: string;
        points: number;
        totalSpend: number; // Asegurar que este campo se actualiza y devuelve
        totalVisits: number; // Asegurar que este campo se actualiza y devuelve
        currentTierId: string | null;
        currentTierName: string | null; // Nombre del tier
    };
}


// Tipos internos para helpers
type ValidQrCode = QrCode & {
    business: Pick<Business, 'id' | 'pointsPerEuro' | 'tierSystemEnabled' | 'tierCalculationBasis'>; // Ajustado
    ticketNumber: string; // Asegurar que no sea null
};

type ValidCustomer = User & {
    currentTier: ({ benefits: TierBenefit[] } & { id: string; name: string }) | null;
    businessId: string; // <--- Aseguramos que aqu√≠ businessId NO es null
};


// ==============================================
// HELPER FUNCTIONS for validateQrCode (Internal)
// ==============================================

const _findAndValidateQrCodeRecord = async (qrToken: string, now: Date): Promise<ValidQrCode> => {
    const qrCode = await prisma.qrCode.findUnique({
        where: { token: qrToken },
        include: {
            business: { // Seleccionar solo lo necesario de business
                select: { id: true, pointsPerEuro: true, tierSystemEnabled: true, tierCalculationBasis: true }
            }
        }
    });

    if (!qrCode) { throw new Error('C√≥digo QR inv√°lido.'); }
    if (qrCode.status !== QrCodeStatus.PENDING) {
        if (qrCode.status === QrCodeStatus.COMPLETED) throw new Error('El c√≥digo QR ya ha sido utilizado.');
        if (qrCode.status === QrCodeStatus.EXPIRED) throw new Error('El c√≥digo QR ha expirado.');
        throw new Error('El c√≥digo QR no est√° disponible para canjear.');
    }
    if (isAfter(now, qrCode.expiresAt)) {
        try {
            await prisma.qrCode.update({ where: { id: qrCode.id }, data: { status: QrCodeStatus.EXPIRED } });
            console.log(`[Points SVC Helper] QR code ${qrToken} marked as EXPIRED.`);
        } catch (updateError) {
            console.error(`[Points SVC Helper] Failed to update QR status to EXPIRED for token ${qrToken}:`, updateError);
        }
        throw new Error('El c√≥digo QR ha expirado.');
    }
    if (!qrCode.business) {
        console.error(`[Points SVC Helper] QR code ${qrCode.id} has no associated business!`);
        throw new Error('Error interno: El QR no est√° asociado a un negocio.');
    }
    if (qrCode.ticketNumber === null) { // Aunque el schema lo hace no-nulo, una verificaci√≥n extra no da√±a
        console.error(`[Points SVC Helper] QR code ${qrCode.id} has null ticketNumber!`);
        throw new Error('Error interno: Falta n√∫mero de ticket en QR.');
    }
    return qrCode as ValidQrCode; // Casteo seguro despu√©s de las validaciones
};

const _findAndValidateCustomerForQr = async (userId: string, qrCodeBusinessId: string): Promise<ValidCustomer> => {
    const customer = await prisma.user.findUnique({
        where: { id: userId },
        include: { currentTier: { include: { benefits: { where: { isActive: true } } } } }
    });

    if (!customer || customer.role !== UserRole.CUSTOMER_FINAL) {
        throw new Error('Solo las cuentas de cliente pueden canjear c√≥digos QR.');
    }
    if (!customer.businessId) { // <--- A√ëADIDA ESTA VALIDACI√ìN
        console.error(`[Points SVC Helper] Customer ${userId} has no businessId! This should not happen for CUSTOMER_FINAL.`);
        throw new Error('Error interno: El cliente no est√° asociado a ning√∫n negocio.');
    }
    if (customer.businessId !== qrCodeBusinessId) {
        throw new Error('El c√≥digo QR no es v√°lido para el negocio de este cliente.');
    }
    return customer as ValidCustomer; // Casteo seguro
};

const _calculatePointsEarned = (qrAmount: number, businessConfig: ValidQrCode['business'], customer: ValidCustomer): number => {
    let effectivePoints = qrAmount * (businessConfig.pointsPerEuro ?? 1); // Usar 1 si pointsPerEuro es null/undefined
    const multiplierBenefit = customer.currentTier?.benefits.find(b => b.type === 'POINTS_MULTIPLIER');
    if (multiplierBenefit) {
        const multiplier = parseFloat(multiplierBenefit.value);
        if (!isNaN(multiplier) && multiplier > 0) {
            effectivePoints *= multiplier;
            console.log(`[Points SVC Helper] Applied tier multiplier ${multiplier} for user ${customer.id}`);
        } else {
            console.warn(`[Points SVC Helper] Invalid multiplier value '${multiplierBenefit.value}' for tier ${customer.currentTier?.id}`);
        }
    }
    const calculatedPoints = Math.floor(effectivePoints);
    return calculatedPoints < 0 ? 0 : calculatedPoints; // Asegurar que no sean negativos
};

const _performQrValidationTransaction = async (
    tx: Prisma.TransactionClient,
    qrCode: ValidQrCode,
    customerId: string, // Este es el ID del usuario que valid√≥
    customerBusinessId: string, // <--- A√ëADIDO: El businessId del cliente que valid√≥
    pointsEarned: number,
    now: Date
): Promise<void> => {
    await tx.user.update({
        where: { id: customerId },
        data: {
            points: { increment: pointsEarned },
            lastActivityAt: now,
            totalVisits: { increment: 1 },
            totalSpend: { increment: qrCode.amount },
        },
    });
    await tx.qrCode.update({
        where: { id: qrCode.id },
        data: {
            status: QrCodeStatus.COMPLETED,
            completedAt: now,
            userId: customerId,
            pointsEarned: pointsEarned
        },
    });

    // --- CORRECCI√ìN EN ActivityLog ---
    await tx.activityLog.create({
        data: {
            userId: customerId,
            // businessId de la actividad debe ser el del negocio del cliente,
            // que ya validamos que es el mismo que el del QR.
            businessId: customerBusinessId, // <--- USAR EL businessId DEL CLIENTE
            type: ActivityType.POINTS_EARNED_QR,
            pointsChanged: pointsEarned,
            description: qrCode.ticketNumber, // ticketNumber ahora es string
            relatedQrId: qrCode.id,
        }
    });
    // --- FIN CORRECCI√ìN ---
    console.log(`[Points SVC Helper TX] User, QR, and ActivityLog updated for QR ${qrCode.id}`);
};


// ==================================
// Funciones de Servicio Exportadas
// ==================================

export const generateQrCodeData = async (businessId: string, amount: number, ticketNumber: string): Promise<{ qrToken: string; amount: number }> => {
    if (amount <= 0 || typeof amount !== 'number') {
        throw new Error('El importe de la transacci√≥n debe ser un n√∫mero positivo.');
    }
    const token = uuidv4();
    const expiresAt = addMinutes(new Date(), QR_EXPIRATION_MINUTES); // Considerar usar qrCodeExpirationMinutes del Business
    try {
        const qrCode = await prisma.qrCode.create({
            data: { token, businessId, amount, ticketNumber, expiresAt, status: QrCodeStatus.PENDING },
            select: { token: true, amount: true }
        });
        console.log(`[Points SVC] QR Code generated for business ${businessId} with token ${token} for amount ${amount}, ticket: ${ticketNumber}.`);
        return { qrToken: qrCode.token, amount: qrCode.amount };
    } catch (error: unknown) {
        console.error('[Points SVC] Error generating QR code data:', error);
        throw new Error('No se pudieron generar los datos del c√≥digo QR.');
    }
};


export const validateQrCode = async (qrToken: string, customerUserId: string): Promise<ValidateQrResult> => {
    const now = new Date();
    console.log(`[Points SVC] Validating QR token starting with ${qrToken.substring(0, 5)}... for user ${customerUserId}`);
    try {
        const qrCode = await _findAndValidateQrCodeRecord(qrToken, now);
        const customer = await _findAndValidateCustomerForQr(customerUserId, qrCode.businessId); // customer.businessId aqu√≠ NO es null
        const calculatedPointsEarned = _calculatePointsEarned(qrCode.amount, qrCode.business, customer);

        await prisma.$transaction(async (tx) => {
            // Pasamos customer.businessId (que sabemos que no es null)
            await _performQrValidationTransaction(
                tx,
                qrCode,
                customerUserId,
                customer.businessId, // <--- PASAR EL businessId del cliente
                calculatedPointsEarned,
                now
            );
        });
        console.log(`[Points SVC] Transaction successful for QR ${qrCode.id} and user ${customerUserId}.`);

        // L√≥gica de actualizaci√≥n de Tier (sin cambios)
        if (qrCode.business.tierSystemEnabled) {
            console.log(`[Points SVC] Triggering tier update for user ${customerUserId} (async)`);
            updateUserTier(customerUserId).catch(err => {
                console.error(`[Points SVC] Background tier update failed for user ${customerUserId}:`, err);
            });
        }

        // Esperar un poco para que la actualizaci√≥n de tier se refleje si es s√≠ncrona (no es el caso ideal)
        // O mejor, el updateUserTier deber√≠a devolver el usuario actualizado o refetchear aqu√≠.
        // Por ahora, un peque√±o delay puede ayudar en algunos casos de prueba, pero no es robusto.
        // await new Promise(resolve => setTimeout(resolve, 150)); // Considerar quitar esto

        const updatedUserData = await prisma.user.findUniqueOrThrow({
            where: { id: customerUserId },
            select: {
                id: true,
                points: true,
                totalSpend: true,
                totalVisits: true,
                currentTierId: true,
                currentTier: { select: { name: true } }
            }
        });
        console.log(`[Points SVC] Fetched latest user data post-validation for ${customerUserId}: TierId=${updatedUserData.currentTierId}`);

        return {
            pointsEarned: calculatedPointsEarned,
            updatedUser: {
                id: updatedUserData.id,
                points: updatedUserData.points,
                totalSpend: updatedUserData.totalSpend ?? 0,
                totalVisits: updatedUserData.totalVisits ?? 0,
                currentTierId: updatedUserData.currentTierId,
                currentTierName: updatedUserData.currentTier?.name ?? null
            }
        };
    } catch (error: unknown) {
        // ... (manejo de errores sin cambios) ...
        if (error instanceof Error && (
            error.message.startsWith('C√≥digo QR inv√°lido') ||
            error.message.includes('ya ha sido utilizado') ||
            error.message.includes('ha expirado') ||
            error.message.includes('no est√° disponible para canjear') ||
            error.message.includes('Solo las cuentas de cliente') ||
            error.message.includes('no es v√°lido para el negocio')
        )) {
            console.warn(`[Points SVC] Validation failed for token ${qrToken}: ${error.message}`);
            throw error; // Relanzar el error espec√≠fico para el controlador
        }
        console.error(`[Points SVC] Unexpected error validating token ${qrToken}:`, error);
        throw new Error('Ocurri√≥ un error interno del servidor durante la validaci√≥n del QR.');
    }
};


export const redeemReward = async (customerUserId: string, rewardId: string): Promise<RedeemResult> => {
    console.log(`[Points SVC] Redeeming standard reward ${rewardId} for user ${customerUserId}`);
    try {
        const user = await prisma.user.findUniqueOrThrow({
            where: { id: customerUserId },
            select: { id: true, points: true, businessId: true, role: true }
        });

        if (!user.businessId) { // <--- CHEQUEO IMPORTANTE
            console.error(`[Points SVC] Customer ${customerUserId} attempting to redeem reward but has no businessId.`);
            throw new Error("El usuario cliente no est√° asociado a ning√∫n negocio.");
        }

        const reward = await prisma.reward.findUniqueOrThrow({
            where: { id: rewardId },
            select: {
                id: true, name_es: true, name_en: true,
                pointsCost: true, isActive: true, businessId: true
            }
        });

        if (user.role !== UserRole.CUSTOMER_FINAL) { throw new Error('Rol de usuario inv√°lido para canjear recompensas.'); }
        if (user.businessId !== reward.businessId) { throw new Error('La recompensa no pertenece al negocio del cliente.'); }
        if (!reward.isActive) { throw new Error('Esta recompensa est√° actualmente inactiva.'); }

        const rewardDisplayName = reward.name_es || reward.name_en || `ID ${rewardId}`;
        if (user.points < reward.pointsCost) {
            throw new Error(`Puntos insuficientes para canjear "${rewardDisplayName}". Necesarios: ${reward.pointsCost}, Disponibles: ${user.points}`);
        }

        const updatedUser = await prisma.$transaction(async (tx) => {
            const resultUser = await tx.user.update({
                where: { id: customerUserId },
                data: { points: { decrement: reward.pointsCost } },
                select: { id: true, points: true }
            });

            // --- CORRECCI√ìN EN ActivityLog ---
            await tx.activityLog.create({
                data: {
                    userId: customerUserId,
                    businessId: user.businessId!, // Usamos '!' porque ya validamos que no es null
                    type: ActivityType.POINTS_REDEEMED_REWARD,
                    pointsChanged: -reward.pointsCost,
                    description: reward.name_es || reward.name_en,
                    relatedRewardId: rewardId
                }
            });
            // --- FIN CORRECCI√ìN ---

            console.log(`[Points SVC - TX SUCCESS] User ${resultUser.id} redeemed reward '${rewardDisplayName}' (${reward.id}) for ${reward.pointsCost} points. Activity logged. New balance: ${resultUser.points}.`);
            return resultUser;
        });

        return {
            message: `¬°Recompensa '${rewardDisplayName}' canjeada con √©xito!`,
            newPointsBalance: updatedUser.points
        };
    } catch (error: unknown) {
        // ... (manejo de errores sin cambios) ...
        console.error(`[Points SVC - ERROR] Failed to redeem reward for user ${customerUserId}, reward ${rewardId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error('No se encontr√≥ el usuario o la recompensa especificada.');
        }
        if (error instanceof Error) { throw error; } // Relanzar errores espec√≠ficos ya lanzados
        throw new Error('Ocurri√≥ un error inesperado durante el canje de la recompensa.');
    }
};


// ====== [17] backend/src/modules/loyalpyme/rewards/rewards.controller.ts ======
// filename: backend/src/rewards/rewards.controller.ts
// Version: 1.3.0 (Adapt controller to use i18n reward fields)

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client';
import {
    createReward,
    findRewardsByBusiness,
    findRewardById,
    updateReward,
    deleteReward,
    // Importar los tipos de datos necesarios del servicio si se definieron all√≠
    // o definirlos aqu√≠/en un DTO
} from './rewards.service';

// --- DTOs ACTUALIZADOS ---
// DTO para la creaci√≥n (ahora espera campos i18n)
export interface CreateRewardDto {
    name_es: string; // Obligatorio
    name_en: string; // Obligatorio
    description_es?: string | null;
    description_en?: string | null;
    pointsCost: number; // Obligatorio
    imageUrl?: string | null;
}

// DTO para la actualizaci√≥n (campos opcionales)
export interface UpdateRewardDto {
    name_es?: string;
    name_en?: string;
    description_es?: string | null;
    description_en?: string | null;
    pointsCost?: number;
    isActive?: boolean;
    imageUrl?: string | null;
}
// --- FIN DTOs ACTUALIZADOS ---


/**
 * Handles creation of a new reward.
 * POST /api/rewards
 */
export const createRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) {
        return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." });
    }
    const businessId = req.user.businessId;

    // --- CORRECCI√ìN: Destructurar y validar campos i18n ---
    const {
        name_es, name_en, description_es, description_en, pointsCost, imageUrl
    }: CreateRewardDto = req.body;

    // Validaci√≥n b√°sica (mejorar con Zod si se desea)
    if (!name_es || typeof name_es !== 'string' || name_es.trim() === '') {
        return res.status(400).json({ message: 'Se requiere el nombre en espa√±ol (name_es).' });
    }
     if (!name_en || typeof name_en !== 'string' || name_en.trim() === '') {
        return res.status(400).json({ message: 'Se requiere el nombre en ingl√©s (name_en).' });
    }
    if (pointsCost === undefined || typeof pointsCost !== 'number' || pointsCost < 0) {
        return res.status(400).json({ message: 'Se requiere un coste en puntos v√°lido (pointsCost).' });
    }
    // --- FIN CORRECCI√ìN ---

    try {
        // --- CORRECCI√ìN: Pasar campos i18n al servicio ---
        const newReward = await createReward({
            name_es: name_es.trim(), // <-- Pasar name_es
            name_en: name_en.trim(), // <-- Pasar name_en
            description_es: description_es?.trim() || null, // <-- Pasar description_es
            description_en: description_en?.trim() || null, // <-- Pasar description_en
            pointsCost, // Ya validado como n√∫mero
            businessId,
            imageUrl // Puede ser null o undefined
        });
        // --- FIN CORRECCI√ìN ---
        res.status(201).json(newReward); // Devuelve el objeto Reward completo (con todos los campos)
    } catch (error) {
        console.error('[REWARDS CTRL] Error creating reward:', error);
        if (error instanceof Prisma.PrismaClientKnownRequestError || error instanceof Error) {
            // Devolver 409 si es error de unicidad del servicio
            if (error.message.includes('unicidad') || error.message.includes('ya existen')) {
                 return res.status(409).json({ message: error.message });
            }
            // Para otros errores Prisma o gen√©ricos, intentar devolver el mensaje
             return res.status(500).json({ message: error.message || 'Error de base de datos al crear la recompensa.' });
        }
        next(new Error('Error del servidor al crear la recompensa.'));
    }
};

/**
 * Handles fetching all rewards for the authenticated business.
 * GET /api/rewards
 */
export const getRewardsHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.businessId) { return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." }); }
    const businessId = req.user.businessId;
    try {
        // El servicio ya devuelve los campos correctos (name_es, name_en, etc.)
        const rewards = await findRewardsByBusiness(businessId);
        res.status(200).json(rewards); // rewards es ahora RewardListItem[]
    } catch (error) {
        console.error('[REWARDS CTRL] Error fetching rewards:', error);
        next(new Error('Error del servidor al obtener recompensas.'));
    }
};

/**
 * Handles fetching a single reward by ID.
 * GET /api/rewards/:id
 */
export const getRewardByIdHandler = async (req: Request, res: Response, next: NextFunction) => {
   if (!req.user || !req.user.businessId) { return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." }); }
    const businessId = req.user.businessId;
    const rewardId = req.params.id;
    if (!rewardId) { return res.status(400).json({ message: 'Se requiere el ID de la recompensa en la URL.' }); }
    try {
        // El servicio devuelve el objeto Reward completo (con name_es, etc.)
        const reward = await findRewardById(rewardId, businessId);
        if (!reward) { return res.status(404).json({ message: 'Recompensa no encontrada o no pertenece a tu negocio.' }); }
        res.status(200).json(reward);
    } catch (error) {
        console.error('[REWARDS CTRL] Error fetching reward by ID:', error);
        next(new Error('Error del servidor al obtener la recompensa por ID.'));
    }
};

/**
 * Handles updating an existing reward (handles PUT and PATCH).
 * PUT/PATCH /api/rewards/:id
 */
export const updateRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.businessId) { return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." }); }
    const businessId = req.user.businessId;
    const rewardId = req.params.id;
    // --- CORRECCI√ìN: Usar DTO actualizado y limpiar datos ---
    const updateInput: UpdateRewardDto = req.body;
    const updateData: UpdateRewardDto = {}; // Objeto limpio para pasar al servicio

    if (!rewardId) { return res.status(400).json({ message: 'Se requiere el ID de la recompensa en la URL.' }); }
    if (Object.keys(updateInput).length === 0) { return res.status(400).json({ message: 'Se requieren datos de actualizaci√≥n en el cuerpo de la petici√≥n.' }); }

    // Copiar y limpiar solo los campos v√°lidos y definidos
    if (updateInput.name_es !== undefined) updateData.name_es = updateInput.name_es.trim();
    if (updateInput.name_en !== undefined) updateData.name_en = updateInput.name_en.trim();
    if (updateInput.description_es !== undefined) updateData.description_es = updateInput.description_es?.trim() || null;
    if (updateInput.description_en !== undefined) updateData.description_en = updateInput.description_en?.trim() || null;
    if (updateInput.pointsCost !== undefined) {
         if (typeof updateInput.pointsCost !== 'number' || updateInput.pointsCost < 0) { return res.status(400).json({ message: 'Si se actualiza, pointsCost debe ser un n√∫mero >= 0.' }); }
         updateData.pointsCost = updateInput.pointsCost;
    }
    if (updateInput.isActive !== undefined) {
        if (typeof updateInput.isActive !== 'boolean') { return res.status(400).json({ message: 'El campo isActive debe ser un valor booleano (true o false).' }); }
        updateData.isActive = updateInput.isActive;
    }
    // Permitir enviar null para quitar la imagen
     if (updateInput.imageUrl !== undefined) {
         updateData.imageUrl = updateInput.imageUrl;
     }

     // Verificar si hay algo que actualizar despu√©s de limpiar
     if (Object.keys(updateData).length === 0) {
        return res.status(400).json({ message: 'No se proporcionaron datos v√°lidos para actualizar.' });
     }
    // --- FIN CORRECCI√ìN ---

    try {
        // Pasar los datos limpios y correctos al servicio
        const updatedReward = await updateReward(rewardId, businessId, updateData);
        res.status(200).json(updatedReward); // Devuelve el objeto completo actualizado
    } catch (error) {
         console.error('[REWARDS CTRL] Error updating reward:', error);
         if (error instanceof Error && error.message.includes('no encontrada o no pertenece')) { return res.status(404).json({ message: error.message }); }
         if (error instanceof Prisma.PrismaClientKnownRequestError || error instanceof Error) {
            // Devolver 409 si es error de unicidad del servicio
            if (error.message.includes('unicidad') || error.message.includes('ya existen')) {
                 return res.status(409).json({ message: error.message });
            }
            return res.status(500).json({ message: error.message || 'Error de base de datos al actualizar recompensa.' });
         }
         next(new Error('Error del servidor al actualizar la recompensa.'));
    }
};

/**
 * Handles deletion of an existing reward. DELETE /api/rewards/:id
 */
export const deleteRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) { return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." }); }
    const businessId = req.user.businessId;
    const rewardId = req.params.id;
    if (!rewardId) { return res.status(400).json({ message: 'Se requiere el ID de la recompensa en la URL.' }); }
    try {
        // deleteReward ahora devuelve el objeto Reward completo (con name_es/en)
        const deletedReward = await deleteReward(rewardId, businessId);
        // Devolvemos el objeto borrado completo
        res.status(200).json({ message: 'Recompensa eliminada con √©xito.', deletedReward });
    } catch (error) {
        console.error('[REWARDS CTRL] Error deleting reward:', error);
        if (error instanceof Error && error.message.includes('no encontrada o no pertenece')) { return res.status(404).json({ message: error.message }); }
        // El servicio ya lanza error espec√≠fico si est√° en uso
        if (error instanceof Error && error.message.includes('siendo utilizada')) { return res.status(409).json({ message: error.message }); }
        // Otros errores
        if (error instanceof Prisma.PrismaClientKnownRequestError || error instanceof Error) { return res.status(500).json({ message: error.message || 'Error de base de datos al eliminar recompensa.' }); }
        next(new Error('Error del servidor al eliminar la recompensa.'));
    }
};

// End of File: backend/src/rewards/rewards.controller.ts


// ====== [18] backend/src/modules/loyalpyme/rewards/rewards.service.ts ======
// filename: backend/src/rewards/rewards.service.ts
// Version: 1.2.1 (Use generated i18n Reward types correctly)

import { PrismaClient, Reward, Prisma, GrantedReward } from '@prisma/client';

const prisma = new PrismaClient();

// Interfaz CreateRewardData (Usa los campos correctos del schema)
interface CreateRewardData {
    name_es: string;
    name_en: string;
    description_es?: string | null;
    description_en?: string | null;
    pointsCost: number;
    businessId: string;
    imageUrl?: string | null;
}

/**
 * Creates a new reward for a specific business with i18n fields.
 */
export const createReward = async (rewardData: CreateRewardData): Promise<Reward> => {
    console.log(`[Rewards SVC] Creating reward for business ${rewardData.businessId}: ${rewardData.name_es} / ${rewardData.name_en}`);
    console.log('[DEBUG createReward] Saving data:', { ...rewardData });
    try {
        // Prisma create ya espera los campos correctos (name_es, etc.)
        // seg√∫n el cliente generado despu√©s de la migraci√≥n
        const newReward = await prisma.reward.create({
            data: {
                name_es: rewardData.name_es,
                name_en: rewardData.name_en,
                description_es: rewardData.description_es,
                description_en: rewardData.description_en,
                pointsCost: rewardData.pointsCost,
                businessId: rewardData.businessId,
                imageUrl: rewardData.imageUrl,
            },
        });
        console.log('[DEBUG createReward] Reward created:', newReward);
        return newReward;
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            console.error(`[Rewards SVC] Prisma error creating reward: ${error.code}`, error);
             if (error.code === 'P2002') {
                const target = (error.meta?.target as string[]) || [];
                // Usamos name_es en el mensaje como ejemplo
                if (target.includes('name_es')) { throw new Error(`Ya existe una recompensa con el nombre (ES) "${rewardData.name_es}" para este negocio.`); }
                if (target.includes('name_en')) { throw new Error(`Ya existe una recompensa con el nombre (EN) "${rewardData.name_en}" para este negocio.`); }
                 throw new Error(`Conflicto de unicidad al crear la recompensa (nombre ES o EN ya existen).`);
             }
        } else { console.error(`[Rewards SVC] Unexpected error creating reward:`, error); }
        throw new Error('Error al crear la recompensa.');
    }
};

// --- Tipo RewardListItem ACTUALIZADO ---
// Ahora usa los campos correctos que seleccionaremos
type RewardListItem = Pick<
    Reward,
    'id' | 'name_es' | 'name_en' | 'pointsCost' | 'description_es' | 'description_en' | 'isActive' | 'imageUrl'
>;

/**
 * Finds all rewards for a specific business, selecting i18n fields.
 */
export const findRewardsByBusiness = async (businessId: string): Promise<RewardListItem[]> => {
    console.log(`[Rewards SVC] Finding ALL rewards (with i18n fields) for business ${businessId}`);
    // Select ya est√° actualizado para seleccionar los campos correctos
    const selectFields = {
        id: true,
        name_es: true,
        name_en: true,
        pointsCost: true,
        description_es: true,
        description_en: true,
        isActive: true,
        imageUrl: true
    };
    console.log('[DEBUG findRewardsByBusiness] Using select:', selectFields);
    try {
        const rewardsFound = await prisma.reward.findMany({
            where: { businessId: businessId, },
            select: selectFields,
            // Usar name_es para ordenar (o name_en si se prefiere)
            orderBy: [ { pointsCost: 'asc' }, { name_es: 'asc' } ]
        });
        console.log('[DEBUG findRewardsByBusiness] Rewards found:', rewardsFound);
        // El tipo de retorno ahora coincide con RewardListItem actualizado
        return rewardsFound;
    } catch (error) {
        console.error(`[Rewards SVC] Error finding rewards for business ${businessId}:`, error);
        throw new Error('Error al buscar las recompensas.');
    }
};


/**
 * Finds a single reward by its ID, ensuring it belongs to a specific business.
 * (Returns full object including i18n fields)
 */
export const findRewardById = async (id: string, businessId: string): Promise<Reward | null> => {
     console.log(`[Rewards SVC] Finding reward by ID ${id} for business ${businessId}`);
     try {
         // findFirst devuelve el tipo Reward completo (que ahora tiene name_es, etc.)
         const reward = await prisma.reward.findFirst({ where: { id: id, businessId: businessId } });
         return reward;
     } catch (error) {
         console.error(`[Rewards SVC] Error finding reward by ID ${id}:`, error);
         throw new Error('Error al buscar la recompensa por ID.');
     }
};

// --- Tipo UpdateRewardData ACTUALIZADO ---
// Ahora Partial<Pick<...>> usa los campos correctos
type UpdateRewardData = Partial<Pick<
    Reward,
    'name_es' | 'name_en' | 'description_es' | 'description_en' | 'pointsCost' | 'isActive' | 'imageUrl'
>>;

/**
 * Updates an existing reward with i18n fields, ensuring it belongs to a specific business.
 */
export const updateReward = async (
    id: string,
    businessId: string,
    updateData: UpdateRewardData // Usa el tipo actualizado
): Promise<Reward> => {
    console.log(`[Rewards SVC] Updating reward ID ${id} for business ${businessId}`);
    const existingReward = await findRewardById(id, businessId);
    if (!existingReward) { throw new Error(`Recompensa con ID ${id} no encontrada o no pertenece al negocio ${businessId}.`); }

    console.log('[DEBUG updateReward] Updating with data:', { ...updateData });
    try {
        // updateData ya debe contener los nombres de campo correctos (name_es, etc.)
        const updatedReward = await prisma.reward.update({
            where: { id: id },
            data: updateData,
        });
        console.log('[DEBUG updateReward] Reward updated:', updatedReward);
        return updatedReward;
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            console.error(`[Rewards SVC] Prisma error updating reward ${id}: ${error.code}`, error);
            // Comprobar unicidad en ambos nombres si se est√°n actualizando
             if (error.code === 'P2002') {
                const target = (error.meta?.target as string[]) || [];
                 if (target.includes('name_es') && updateData.name_es) { // Comprobar si se intent√≥ actualizar name_es
                     throw new Error(`Ya existe otra recompensa con el nombre (ES) "${updateData.name_es}" para este negocio.`);
                 }
                  if (target.includes('name_en') && updateData.name_en) { // Comprobar si se intent√≥ actualizar name_en
                     throw new Error(`Ya existe otra recompensa con el nombre (EN) "${updateData.name_en}" para este negocio.`);
                  }
                 throw new Error(`Conflicto de unicidad al actualizar la recompensa (nombre ES o EN ya existen).`);
             }
            throw new Error(`Error de base de datos al actualizar recompensa: ${error.message}`);
        }
        console.error(`[Rewards SVC] Unexpected error updating reward ${id}:`, error);
        throw new Error('Error inesperado al actualizar la recompensa.');
    }
};

/**
 * Deletes an existing reward, ensuring it belongs to a specific business.
 */
export const deleteReward = async (id: string, businessId: string): Promise<Reward> => {
    console.log(`[Rewards SVC] Deleting reward ID ${id} for business ${businessId}`);
    const existingReward = await findRewardById(id, businessId); // Ahora existingReward tiene name_es, name_en
    if (!existingReward) { throw new Error(`Recompensa con ID ${id} no encontrada o no pertenece al negocio ${businessId}.`); }

    const relatedGrantsCount = await prisma.grantedReward.count({ where: { rewardId: id } });
    if (relatedGrantsCount > 0) {
        // Usar name_es o name_en (o ID) en el mensaje de error
        const displayName = existingReward.name_es || existingReward.name_en || `ID ${id}`;
        throw new Error(`No se puede eliminar la recompensa "${displayName}" porque est√° siendo utilizada (ej: ha sido asignada como regalo ${relatedGrantsCount} veces).`);
    }
    try {
        // delete no necesita cambios, usa el where { id }
        return await prisma.reward.delete({ where: { id: id } });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            console.error(`[Rewards SVC] Prisma error deleting reward ${id}: ${error.code}`, error);
            throw new Error(`Error de base de datos al eliminar recompensa: ${error.message}`);
        }
        console.error(`[Rewards SVC] Unexpected error deleting reward ${id}:`, error);
        throw new Error('Error inesperado al eliminar la recompensa.');
    }
};

// End of File: backend/src/rewards/rewards.service.ts


// ====== [19] backend/src/modules/loyalpyme/tiers/__tests__/tier-logic.helpers.test.ts ======
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { determineTargetTier, calculateUserMetric } from '../tier-logic.helpers';
import { PrismaClient, TierCalculationBasis, QrCodeStatus } from '@prisma/client';

// Mock simple
const prismaMock = {
  qrCode: {
    aggregate: vi.fn(),
    count: vi.fn(),
  },
};


type ActiveTierInfo = {
  id: string;
  name: string;
  level: number;
  minValue: number;
};

describe('Tier Logic Helpers', () => {

  describe('determineTargetTier', () => {
    // ... (tests sin cambios) ...
    const mockActiveTiers: ActiveTierInfo[] = [
        { id: 'tier-oro', name: 'Oro', level: 3, minValue: 1000 },
        { id: 'tier-plata', name: 'Plata', level: 2, minValue: 500 },
        { id: 'tier-bronce', name: 'Bronce', level: 1, minValue: 100 },
      ];
      it('should return null if metric value is below the lowest tier threshold', () => {
        const metricValue = 50;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBeNull();
      });
      it('should return the lowest tier ID if metric value matches its threshold', () => {
        const metricValue = 100;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBe('tier-bronce');
      });
      it('should return the correct tier ID if metric value is between thresholds', () => {
        const metricValue = 650;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBe('tier-plata');
      });
      it('should return the highest tier ID if metric value meets its threshold', () => {
        const metricValue = 1000;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBe('tier-oro');
      });
      it('should return the highest tier ID if metric value exceeds the highest threshold', () => {
        const metricValue = 5000;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBe('tier-oro');
      });
      it('should return null if the list of active tiers is empty', () => {
        const metricValue = 500;
        const emptyTiers: ActiveTierInfo[] = [];
        const targetTierId = determineTargetTier(metricValue, emptyTiers);
        expect(targetTierId).toBeNull();
      });
       it('should handle tiers with minValue 0 correctly', () => {
         const tiersWithZero: ActiveTierInfo[] = [
           { id: 'tier-plata', name: 'Plata', level: 1, minValue: 100 },
           { id: 'tier-basico', name: 'Basico', level: 0, minValue: 0 },
         ];
         const metricValue = 50;
         const targetTierId = determineTargetTier(metricValue, tiersWithZero);
         expect(targetTierId).toBe('tier-basico');
       });
       it('should return the base tier ID if metric value is 0 and a tier starts at 0', () => {
         const tiersWithZero: ActiveTierInfo[] = [
             { id: 'tier-plata', name: 'Plata', level: 1, minValue: 100 },
             { id: 'tier-basico', name: 'Basico', level: 0, minValue: 0 },
           ];
         const metricValue = 0;
         const targetTierId = determineTargetTier(metricValue, tiersWithZero);
         expect(targetTierId).toBe('tier-basico');
       });
  });

  describe('calculateUserMetric', () => {
    const userId = 'test-user-id';
    const testStartDate = new Date('2024-01-01T00:00:00.000Z');

    beforeEach(() => {
      vi.resetAllMocks();
    });

    it('should calculate metric based on SPEND correctly', async () => {
      prismaMock.qrCode.aggregate.mockResolvedValue({ _sum: { amount: 150.75, pointsEarned: null } });
      // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
      // @ts-expect-error: prismaMock is intentionally simplified for this test
      const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.SPEND, undefined);
      // --- FIN CAMBIO ---
      expect(prismaMock.qrCode.aggregate).toHaveBeenCalledWith(expect.objectContaining({
        _sum: { amount: true },
        where: { userId: userId, status: QrCodeStatus.COMPLETED }
      }));
      expect(metric).toBe(150.75);
    });

    it('should calculate metric based on VISITS correctly', async () => {
      prismaMock.qrCode.count.mockResolvedValue(12);
       // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
       // @ts-expect-error: prismaMock is intentionally simplified for this test
      const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.VISITS, undefined);
       // --- FIN CAMBIO ---
      expect(prismaMock.qrCode.count).toHaveBeenCalledWith(expect.objectContaining({
        where: { userId: userId, status: QrCodeStatus.COMPLETED }
      }));
      expect(metric).toBe(12);
    });

    it('should calculate metric based on POINTS_EARNED correctly', async () => {
      prismaMock.qrCode.aggregate.mockResolvedValue({ _sum: { amount: null, pointsEarned: 5430 } });
       // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
       // @ts-expect-error: prismaMock is intentionally simplified for this test
      const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.POINTS_EARNED, undefined);
       // --- FIN CAMBIO ---
      expect(prismaMock.qrCode.aggregate).toHaveBeenCalledWith(expect.objectContaining({
        _sum: { pointsEarned: true },
        where: { userId: userId, status: QrCodeStatus.COMPLETED }
      }));
      expect(metric).toBe(5430);
    });

    it('should calculate metric based on SPEND with a start date', async () => {
      prismaMock.qrCode.aggregate.mockResolvedValue({ _sum: { amount: 99.50, pointsEarned: null } });
       // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
       // @ts-expect-error: prismaMock is intentionally simplified for this test
      const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.SPEND, testStartDate);
       // --- FIN CAMBIO ---
      expect(prismaMock.qrCode.aggregate).toHaveBeenCalledWith(expect.objectContaining({
        _sum: { amount: true },
        where: { userId: userId, status: QrCodeStatus.COMPLETED, completedAt: { gte: testStartDate } }
      }));
      expect(metric).toBe(99.50);
    });

     it('should return 0 if aggregation sum is null', async () => {
       prismaMock.qrCode.aggregate.mockResolvedValue({ _sum: { amount: null, pointsEarned: null } });
        // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
        // @ts-expect-error: prismaMock is intentionally simplified for this test
       const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.SPEND, undefined);
       // --- FIN CAMBIO ---
       expect(prismaMock.qrCode.aggregate).toHaveBeenCalled();
       expect(metric).toBe(0);
     });

     it('should return 0 if count is 0', async () => {
        prismaMock.qrCode.count.mockResolvedValue(0);
         // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
         // @ts-expect-error: prismaMock is intentionally simplified for this test
        const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.VISITS, undefined);
         // --- FIN CAMBIO ---
        expect(prismaMock.qrCode.count).toHaveBeenCalled();
        expect(metric).toBe(0);
      });

     it('should handle Prisma errors gracefully and return 0', async () => {
        prismaMock.qrCode.aggregate.mockRejectedValue(new Error("Database connection failed"));
         // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
         // @ts-expect-error: prismaMock is intentionally simplified for this test
        const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.SPEND, undefined);
         // --- FIN CAMBIO ---
        expect(prismaMock.qrCode.aggregate).toHaveBeenCalled();
        expect(metric).toBe(0);
      });
  });
});

// End of File: backend/src/tiers/__tests__/tier-logic.helpers.test.ts


// ====== [20] backend/src/modules/loyalpyme/tiers/tier-benefit.controller.ts ======
// filename: backend/src/tiers/tier-benefit.controller.ts
// Version: 1.0.1 (Fix encoding, remove @ts-ignore)

import { Request, Response, NextFunction } from 'express'; // Add NextFunction
import { Prisma } from '@prisma/client';
import * as TierBenefitService from './tier-benefit.service';
import * as TierService from './tiers.service';

// --- Handlers para CRUD de TierBenefits (Admin) ---

/**
 * Handler para crear un nuevo beneficio para un Tier espec√≠fico.
 * POST /api/tiers/tiers/:tierId/benefits
 */
export const createTierBenefitHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    // --- FIX: Check req.user ---
    if (!req.user || !req.user.businessId) {
        console.error("[TIER_BENEFIT_CTRL] Critical: User context missing in createTierBenefitHandler.");
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    // --- FIN FIX ---

    const { tierId } = req.params;
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier en la URL.' });

    const benefitData = req.body;
    console.log(`[TIER_BENEFIT_CTRL] Creating benefit for tier ${tierId}`);

     // Validaci√≥n b√°sica (mejorar con DTOs/Zod)
     if (!benefitData.type || !benefitData.value) {
         return res.status(400).json({ message: 'Tipo y valor son requeridos para el beneficio.' });
     }
     // TODO: Validaci√≥n m√°s profunda de 'type' y 'value' seg√∫n el tipo

    try {
        // Verificar que el Tier pertenece al negocio antes de crear el beneficio
        // Esta verificaci√≥n podr√≠a hacerse tambi√©n en el servicio, pero hacerla aqu√≠ es una capa extra.
        const tier = await TierService.findTierById(tierId, businessId);
        if (!tier) {
             return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }

        // Crear el beneficio asociado a ese tierId usando el servicio de beneficios
        const { type, value, description, isActive } = benefitData;
        const newBenefit = await TierBenefitService.createTierBenefit(tierId, { type, value, description, isActive });
        console.log(`[TIER_BENEFIT_CTRL] Benefit created successfully: ${newBenefit.id}`);
        res.status(201).json(newBenefit);
    } catch (error: any) {
         console.error(`[TIER_BENEFIT_CTRL] Error creating benefit for tier ${tierId}:`, error);
         // Manejar error P2025 del servicio si el tierId no existe al hacer connect (ya cubierto por el check previo)
        // Devolver 500 para errores inesperados
        next(new Error('Error interno al crear el beneficio.')); // Pasar a manejador global
    }
};

/**
 * Handler para obtener todos los beneficios de un Tier espec√≠fico.
 * GET /api/tiers/tiers/:tierId/benefits
 */
export const getTierBenefitsHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    // --- FIX: Check req.user ---
     if (!req.user || !req.user.businessId) {
        console.error("[TIER_BENEFIT_CTRL] Critical: User context missing in getTierBenefitsHandler.");
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    // --- FIN FIX ---

    const { tierId } = req.params;
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
     console.log(`[TIER_BENEFIT_CTRL] Getting benefits for tier ${tierId}`);

    try {
        // Opcional: Verificar que el Tier pertenece al negocio (buena pr√°ctica)
        const tier = await TierService.findTierById(tierId, businessId);
        if (!tier) {
             return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }

        // Obtener los beneficios usando el servicio de beneficios
        const benefits = await TierBenefitService.findBenefitsByTier(tierId);
        res.status(200).json(benefits);
    } catch (error: any) {
        console.error(`[TIER_BENEFIT_CTRL] Error getting benefits for tier ${tierId}:`, error);
        next(new Error('Error interno al obtener los beneficios.')); // Pasar a manejador global
    }
};

/**
 * Handler para actualizar un beneficio de Tier existente.
 * PUT /api/tiers/benefits/:benefitId
 */
export const updateTierBenefitHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    const { benefitId } = req.params;
     if (!benefitId) return res.status(400).json({ message: 'Se requiere ID del Beneficio.' });

    const updateData = req.body;
     console.log(`[TIER_BENEFIT_CTRL] Updating benefit ${benefitId}`);
    // Validaci√≥n b√°sica
    if (Object.keys(updateData).length === 0) { return res.status(400).json({ message: 'Se requieren datos para actualizar.' }); }
    // TODO: Validar updateData con DTO/Zod si es necesario

    // Opcional: Verificar que el beneficio pertenece a un tier del negocio logueado (m√°s complejo, podr√≠a hacerse en el servicio)
    // const businessId = req.user?.businessId; // Necesitar√≠a check de req.user
    // const canAccess = await checkBenefitBelongsToBusiness(benefitId, businessId); // Funci√≥n hipot√©tica
    // if (!canAccess) return res.status(403).json({ message: 'Acceso denegado a este beneficio.' });

    try {
        const updatedBenefit = await TierBenefitService.updateTierBenefit(benefitId, updateData);
         console.log(`[TIER_BENEFIT_CTRL] Benefit ${benefitId} updated successfully.`);
        res.status(200).json(updatedBenefit);
    } catch (error: any) {
        console.error(`[TIER_BENEFIT_CTRL] Error updating benefit ${benefitId}:`, error);
        if (error instanceof Error && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message }); // Espec√≠fico 404
        }
        next(new Error('Error interno al actualizar el beneficio.')); // Pasar a manejador global
    }
};

/**
 * Handler para eliminar un beneficio de Tier existente.
 * DELETE /api/tiers/benefits/:benefitId
 */
export const deleteTierBenefitHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    const { benefitId } = req.params;
    if (!benefitId) return res.status(400).json({ message: 'Se requiere ID del Beneficio.' });
     console.log(`[TIER_BENEFIT_CTRL] Deleting benefit ${benefitId}`);

    // Opcional: Verificar pertenencia al negocio logueado antes de borrar (requiere check de req.user)
    try {
        const deletedBenefit = await TierBenefitService.deleteTierBenefit(benefitId);
         console.log(`[TIER_BENEFIT_CTRL] Benefit ${benefitId} deleted successfully.`);
        res.status(200).json({ message: 'Beneficio eliminado correctamente.', deletedBenefit }); // o res.sendStatus(204) // Corregido: correctamente
    } catch (error: any) {
        console.error(`[TIER_BENEFIT_CTRL] Error deleting benefit ${benefitId}:`, error);
        if (error instanceof Error && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message }); // Espec√≠fico 404
        }
        next(new Error('Error interno al eliminar el beneficio.')); // Pasar a manejador global
    }
};

// End of File: backend/src/tiers/tier-benefit.controller.ts


// ====== [21] backend/src/modules/loyalpyme/tiers/tier-benefit.service.ts ======
// filename: backend/src/tiers/tier-benefit.service.ts
// Version: 1.0.1 (Fix character encoding)

import { PrismaClient, TierBenefit, Prisma } from '@prisma/client';
// Importar el enum BenefitType si se necesita para validaciones o l√≥gica futura
import { BenefitType } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Crea un nuevo beneficio y lo asocia a un Tier existente.
 * @param tierId - ID del Tier al que pertenece el beneficio.
 * @param benefitData - Datos del nuevo beneficio (type, value, etc.).
 * @returns El TierBenefit creado.
 */
export const createTierBenefit = async (
    tierId: string,
    benefitData: Omit<Prisma.TierBenefitCreateInput, 'tier'>
): Promise<TierBenefit> => {
    console.log(`[TierBenefit SVC] Creating benefit for tier ${tierId}:`, benefitData);
    // Se podr√≠a a√±adir verificaci√≥n de que el tierId pertenece al businessId correcto si fuera necesario
    try {
        const newBenefit = await prisma.tierBenefit.create({
            data: {
                ...benefitData,
                tier: { // Conectar al Tier padre
                    connect: { id: tierId }
                }
            }
        });
        console.log(`[TierBenefit SVC] Benefit created successfully with ID: ${newBenefit.id}`);
        return newBenefit;
    } catch (error) {
        console.error(`[TierBenefit SVC] Error creating benefit for tier ${tierId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             // Este error ocurre si el tierId no existe al intentar conectar
             throw new Error(`No se encontr√≥ el Nivel (Tier) con ID ${tierId} para asociar el beneficio.`); // Corregido: encontr√≥
         }
        throw new Error('Error al crear el beneficio del nivel.');
    }
};

/**
 * Encuentra todos los beneficios asociados a un Tier espec√≠fico.
 * @param tierId - ID del Tier.
 * @returns Lista de TierBenefits.
 */
export const findBenefitsByTier = async (tierId: string): Promise<TierBenefit[]> => {
    console.log(`[TierBenefit SVC] Finding benefits for tier: ${tierId}`);
    try {
        const benefits = await prisma.tierBenefit.findMany({
            where: { tierId: tierId },
             orderBy: { createdAt: 'asc' } // Opcional: ordenar
        });
        return benefits;
    } catch (error) {
        console.error(`[TierBenefit SVC] Error finding benefits for tier ${tierId}:`, error);
        throw new Error('Error al buscar los beneficios del nivel.');
    }
};

/**
 * Actualiza un beneficio de Tier existente.
 * @param benefitId - ID del beneficio a actualizar.
 * @param updateData - Datos a actualizar.
 * @returns El TierBenefit actualizado.
 * @throws Error si el beneficio no se encuentra.
 */
export const updateTierBenefit = async (
    benefitId: string,
    updateData: Partial<Omit<Prisma.TierBenefitUpdateInput, 'tier'>>
): Promise<TierBenefit> => {
    console.log(`[TierBenefit SVC] Updating benefit ID: ${benefitId}`, updateData);
    try {
        // Usamos update directamente, Prisma lanzar√° P2025 si no lo encuentra
        const updatedBenefit = await prisma.tierBenefit.update({
            where: { id: benefitId },
            data: updateData,
        });
        console.log(`[TierBenefit SVC] Benefit ${benefitId} updated successfully.`);
        return updatedBenefit;
    } catch (error) {
        console.error(`[TierBenefit SVC] Error updating benefit ${benefitId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             throw new Error(`Beneficio con ID ${benefitId} no encontrado.`); // Corregido: encontr√≥
         }
        throw new Error('Error al actualizar el beneficio del nivel.');
    }
};

/**
 * Elimina un beneficio de Tier existente.
 * @param benefitId - ID del beneficio a eliminar.
 * @returns El TierBenefit eliminado.
 * @throws Error si el beneficio no se encuentra.
 */
export const deleteTierBenefit = async (benefitId: string): Promise<TierBenefit> => {
    console.log(`[TierBenefit SVC] Deleting benefit ID: ${benefitId}`);
    try {
         // Usamos delete directamente
        const deletedBenefit = await prisma.tierBenefit.delete({
            where: { id: benefitId },
        });
        console.log(`[TierBenefit SVC] Benefit ${benefitId} deleted successfully.`);
        return deletedBenefit;
    } catch (error) {
         console.error(`[TierBenefit SVC] Error deleting benefit ${benefitId}:`, error);
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             throw new Error(`Beneficio con ID ${benefitId} no encontrado.`); // Corregido: encontr√≥
         }
         throw new Error('Error al eliminar el beneficio del nivel.');
       }
};

// End of File: backend/src/tiers/tier-benefit.service.ts


// ====== [22] backend/src/modules/loyalpyme/tiers/tier-config.controller.ts ======
// filename: backend/src/tiers/tier-config.controller.ts
// Version: 1.0.1 (Fix encoding, remove @ts-ignore)

import { Request, Response, NextFunction } from 'express'; // Add NextFunction
import * as TierConfigService from './tier-config.service';

// --- Handlers para Configuraci√≥n de Tiers del Negocio (Admin) ---

/**
 * Handler para obtener la configuraci√≥n de Tiers del negocio.
 * GET /api/tiers/config
 */
export const getBusinessTierConfigHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    // --- FIX: Check req.user ---
    if (!req.user || !req.user.businessId) {
        console.error("[TIER_CONF_CTRL] Critical: User context missing in getBusinessTierConfigHandler.");
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    // --- FIN FIX ---

    console.log(`[TIER_CONF_CTRL] Getting tier config for business ${businessId}`);
    try {
        const config = await TierConfigService.getBusinessTierConfig(businessId);
        if (!config) {
            // Si el servicio devuelve null (negocio no encontrado, aunque no deber√≠a pasar si el token es v√°lido)
            return res.status(404).json({ message: 'Configuraci√≥n de Tiers no encontrada para este negocio.' }); // Corregido: Configuraci√≥n
        }
        res.status(200).json(config);
    } catch (error: any) {
        console.error(`[TIER_CONF_CTRL] Error getting tier config for business ${businessId}:`, error);
        // Pasar al manejador global
        next(new Error('Error interno al obtener la configuraci√≥n de Tiers.')); // Corregido: configuraci√≥n
    }
};

/**
 * Handler para actualizar la configuraci√≥n de Tiers del negocio.
 * PUT /api/tiers/config
 */
export const updateBusinessTierConfigHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    // --- FIX: Check req.user ---
     if (!req.user || !req.user.businessId) {
        console.error("[TIER_CONF_CTRL] Critical: User context missing in updateBusinessTierConfigHandler.");
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    // --- FIN FIX ---

    const configData = req.body; // Datos a actualizar
    console.log(`[TIER_CONF_CTRL] Updating tier config for business ${businessId}:`, configData);

    // TODO: Validaci√≥n m√°s robusta con DTOs/Zod aqu√≠ si es necesario.
    // Validaciones b√°sicas como ejemplo:
    if (configData.tierSystemEnabled !== undefined && typeof configData.tierSystemEnabled !== 'boolean') {
        return res.status(400).json({ message: 'tierSystemEnabled debe ser booleano.' });
    }
    // A√±adir m√°s validaciones si se requiere...

    try {
        const updatedBusiness = await TierConfigService.updateBusinessTierConfig(businessId, configData);
        // El servicio devuelve Business, lo devolvemos entero.
        console.log(`[TIER_CONF_CTRL] Tier config updated successfully for business ${businessId}`);
        res.status(200).json(updatedBusiness);
    } catch (error: any) {
        console.error(`[TIER_CONF_CTRL] Error updating tier config for business ${businessId}:`, error);
         // Manejar error de 'Negocio no encontrado' del servicio
        if (error instanceof Error && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        // Pasar otros errores al manejador global
        next(new Error('Error interno al actualizar la configuraci√≥n de Tiers.')); // Corregido: configuraci√≥n
    }
};

// End of File: backend/src/tiers/tier-config.controller.ts


// ====== [23] backend/src/modules/loyalpyme/tiers/tier-config.service.ts ======
// filename: backend/src/tiers/tier-config.service.ts
// Version: 1.0.1 (Fix character encoding)

import { PrismaClient, Business, Prisma } from '@prisma/client';
// Importar los Enums relevantes si se usan en los tipos de datos
import { TierCalculationBasis, TierDowngradePolicy } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Obtiene la configuraci√≥n del sistema de Tiers para un negocio espec√≠fico.
 * @param businessId - ID del negocio.
 * @returns Un objeto con la configuraci√≥n de Tiers o null si el negocio no se encuentra.
 */
export const getBusinessTierConfig = async (businessId: string): Promise<Pick<Business, 'tierSystemEnabled' | 'tierCalculationBasis' | 'tierCalculationPeriodMonths' | 'tierDowngradePolicy' | 'inactivityPeriodMonths'> | null> => {
    console.log(`[TierConfig SVC] Getting tier config for business: ${businessId}`);
    try {
        const business = await prisma.business.findUnique({
            where: { id: businessId },
            // Seleccionar solo los campos de configuraci√≥n de Tiers
            select: {
                tierSystemEnabled: true,
                tierCalculationBasis: true,
                tierCalculationPeriodMonths: true,
                tierDowngradePolicy: true,
                inactivityPeriodMonths: true,
            }
        });
        // findUnique devuelve null si no lo encuentra, lo cual es correcto aqu√≠.
        return business;
    } catch (error) {
        console.error(`[TierConfig SVC] Error fetching tier config for business ${businessId}:`, error);
        // Lanzamos un error gen√©rico para que lo maneje el controlador
        throw new Error('Error al obtener la configuraci√≥n de tiers del negocio.'); // Corregido: configuraci√≥n, gen√©rico
    }
};

/**
 * Actualiza la configuraci√≥n del sistema de Tiers para un negocio.
 * @param businessId - ID del negocio.
 * @param configData - Datos de configuraci√≥n a actualizar.
 * @returns El objeto Business completo actualizado (o solo los campos de config si se prefiere).
 */
export const updateBusinessTierConfig = async (
    businessId: string,
    // Tipado para aceptar un subconjunto de los campos de configuraci√≥n
    configData: Partial<Pick<Business, 'tierSystemEnabled' | 'tierCalculationBasis' | 'tierCalculationPeriodMonths' | 'tierDowngradePolicy' | 'inactivityPeriodMonths'>>
): Promise<Business> => { // Devuelve Business completo por defecto
    console.log(`[TierConfig SVC] Updating tier config for business: ${businessId}`, configData);
    try {
        // Usamos update, que arrojar√° error si businessId no existe // Corregido: arrojar√°
        const updatedBusiness = await prisma.business.update({
            where: { id: businessId },
            data: configData, // Prisma solo actualiza los campos presentes en configData
        });
        console.log(`[TierConfig SVC] Tier config updated successfully for business ${businessId}.`);
        return updatedBusiness;
    } catch (error) {
        console.error(`[TierConfig SVC] Error updating tier config for business ${businessId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            // Error espec√≠fico si el businessId no existe
             throw new Error(`Negocio con ID ${businessId} no encontrado.`); // Corregido: espec√≠fico
         }
        // Otros posibles errores (ej: tipo de dato incorrecto para enums si no se valida antes)
        throw new Error('Error al actualizar la configuraci√≥n de tiers del negocio.'); // Corregido: configuraci√≥n
    }
};

// End of File: backend/src/tiers/tier-config.service.ts


// ====== [24] backend/src/modules/loyalpyme/tiers/tier-crud.controller.ts ======
// filename: backend/src/tiers/tier-crud.controller.ts
// Version: 1.1.1 (Fix validation checks and P2002->409 mapping)

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client';
import * as TierService from './tiers.service';

// --- Handlers para CRUD de Tiers (Admin) ---

export const createTierHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) {
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    const tierData = req.body;
    console.log(`[TIER_CRUD_CTRL] Attempting to create tier for business ${businessId}`);

    // --- VALIDACI√ìN REFORZADA ---
    if (!tierData.name || typeof tierData.name !== 'string' || tierData.name.trim() === '') {
        return res.status(400).json({ message: 'El campo "name" es obligatorio y debe ser un texto.' });
    }
    // Comprobar que level sea n√∫mero, entero y >= 0 EXPL√çCITAMENTE
    if (tierData.level === undefined || typeof tierData.level !== 'number' || !Number.isInteger(tierData.level) || tierData.level < 0) {
         return res.status(400).json({ message: 'El campo "level" es obligatorio y debe ser un n√∫mero entero igual o mayor que 0.' });
     }
     // Comprobar que minValue sea n√∫mero y >= 0 EXPL√çCITAMENTE
    if (tierData.minValue === undefined || typeof tierData.minValue !== 'number' || tierData.minValue < 0) {
        return res.status(400).json({ message: 'El campo "minValue" es obligatorio y debe ser un n√∫mero igual o mayor que 0.' });
    }
     if (tierData.isActive !== undefined && typeof tierData.isActive !== 'boolean') {
        return res.status(400).json({ message: 'El campo "isActive" debe ser un valor booleano (true/false) si se proporciona.' });
    }
    // --- FIN VALIDACI√ìN ---

    try {
        const { name, level, minValue, description, benefitsDescription, isActive } = tierData;
        const newTier = await TierService.createTier(businessId, {
            name: name.trim(), level, minValue,
            description: description?.trim() || null,
            benefitsDescription: benefitsDescription?.trim() || null,
            isActive
        });
        console.log(`[TIER_CRUD_CTRL] Tier created successfully: ${newTier.id}`);
        res.status(201).json(newTier);
    } catch (error: any) {
        console.error(`[TIER_CRUD_CTRL] Error creating tier for business ${businessId}:`, error);
        // --- CAPTURA ESPEC√çFICA PARA 409 ---
        // El servicio lanza un Error con un mensaje espec√≠fico para P2002
        if (error instanceof Error && (error.message.includes('Ya existe un Tier con el nivel') || error.message.includes('Ya existe un Tier con el nombre'))) {
             return res.status(409).json({ message: error.message }); // Devolver 409
        }
        // --- FIN CAPTURA 409 ---
        next(error); // Otros errores a 500
    }
};

// getBusinessTiersHandler (sin cambios)
export const getBusinessTiersHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) { return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' }); }
    const businessId = req.user.businessId;
    const includeBenefits = req.query.includeBenefits === 'true';
    try {
        const tiers = await TierService.findTiersByBusiness(businessId, includeBenefits);
        res.status(200).json(tiers);
    } catch (error: any) { next(error); }
};

// getTierByIdHandler (sin cambios)
export const getTierByIdHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) { return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' }); }
    const businessId = req.user.businessId;
    const { tierId } = req.params;
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
    const includeBenefits = req.query.includeBenefits === 'true';
    try {
        const tier = await TierService.findTierById(tierId, businessId, includeBenefits);
        if (!tier) { return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' }); }
        res.status(200).json(tier);
    } catch (error: any) { next(error); }
};

// updateTierHandler (con validaci√≥n a√±adida)
export const updateTierHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.businessId) { return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' }); }
     const businessId = req.user.businessId;
     const { tierId } = req.params;
     if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
     const updateData = req.body;

     // --- VALIDACI√ìN ---
     if (Object.keys(updateData).length === 0) { return res.status(400).json({ message: 'Se requieren datos para actualizar.' }); }
     if (updateData.name !== undefined && (typeof updateData.name !== 'string' || updateData.name.trim() === '')) { return res.status(400).json({ message: 'Si se proporciona "name", no puede estar vac√≠o.' }); }
     if (updateData.level !== undefined && (typeof updateData.level !== 'number' || !Number.isInteger(updateData.level) || updateData.level < 0)) { return res.status(400).json({ message: 'Si se proporciona "level", debe ser un n√∫mero entero igual o mayor que 0.' }); }
     if (updateData.minValue !== undefined && (typeof updateData.minValue !== 'number' || updateData.minValue < 0)) { return res.status(400).json({ message: 'Si se proporciona "minValue", debe ser un n√∫mero igual o mayor que 0.' }); }
     if (updateData.isActive !== undefined && typeof updateData.isActive !== 'boolean') { return res.status(400).json({ message: 'Si se proporciona "isActive", debe ser un valor booleano.' }); }
     // --- FIN VALIDACI√ìN ---

     try {
         const cleanUpdateData: Prisma.TierUpdateInput = {}; // Usar tipo Prisma aqu√≠
         if (updateData.name !== undefined) cleanUpdateData.name = updateData.name.trim();
         if (updateData.level !== undefined) cleanUpdateData.level = updateData.level;
         if (updateData.minValue !== undefined) cleanUpdateData.minValue = updateData.minValue;
         if (updateData.description !== undefined) cleanUpdateData.description = updateData.description?.trim() || null;
         if (updateData.benefitsDescription !== undefined) cleanUpdateData.benefitsDescription = updateData.benefitsDescription?.trim() || null;
         if (updateData.isActive !== undefined) cleanUpdateData.isActive = updateData.isActive;

         const updatedTier = await TierService.updateTier(tierId, businessId, cleanUpdateData);
         console.log(`[TIER_CRUD_CTRL] Tier ${tierId} updated successfully.`);
         res.status(200).json(updatedTier);
     } catch (error: any) {
         console.error(`[TIER_CRUD_CTRL] Error updating tier ${tierId} for business ${businessId}:`, error);
         // --- CAPTURA ESPEC√çFICA 404 y 409 ---
         if (error instanceof Error && error.message.includes('no encontrado')) { return res.status(404).json({ message: error.message }); }
         if (error instanceof Error && (error.message.includes('Ya existe un Tier con el nivel') || error.message.includes('Ya existe un Tier con el nombre'))) { return res.status(409).json({ message: error.message }); }
         // --- FIN CAPTURA ---
         next(error);
     }
};

// deleteTierHandler (con manejo de 409 a√±adido)
export const deleteTierHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.businessId) { return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' }); }
     const businessId = req.user.businessId;
     const { tierId } = req.params;
     if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
     console.log(`[TIER_CRUD_CTRL] Deleting tier ${tierId} for business ${businessId}`);
     try {
         const deletedTier = await TierService.deleteTier(tierId, businessId);
         console.log(`[TIER_CRUD_CTRL] Tier ${tierId} deleted successfully.`);
         res.status(200).json({ message: 'Tier eliminado correctamente.', deletedTier });
     } catch (error: any) {
         console.error(`[TIER_CRUD_CTRL] Error deleting tier ${tierId} for business ${businessId}:`, error);
         // --- CAPTURA ESPEC√çFICA 404 y 409 ---
         if (error instanceof Error && error.message.includes('no encontrado')) { return res.status(404).json({ message: error.message }); }
         if (error instanceof Error && error.message.includes('usuarios asignados')) { return res.status(409).json({ message: error.message }); }
         // --- FIN CAPTURA ---
         next(error);
     }
};

// End of File: backend/src/tiers/tier-crud.controller.ts


// ====== [25] backend/src/modules/loyalpyme/tiers/tier-logic.helpers.ts ======
// filename: backend/src/tiers/tier-logic.helpers.ts
// Version: 1.3.2 (Add null check for calculationBasis in calculateTierForReview)

import { PrismaClient, User, Prisma, QrCodeStatus, Tier, TierCalculationBasis, TierDowngradePolicy } from '@prisma/client';
import { subMonths, isBefore } from 'date-fns';

type ActiveTierInfo = Pick<Tier, 'id' | 'name' | 'level' | 'minValue'>;

export async function calculateUserMetric(
    prismaClient: Pick<PrismaClient, 'qrCode'>,
    userId: string,
    basis: TierCalculationBasis, // Sigue siendo no nulo aqu√≠
    startDate: Date | undefined
): Promise<number> {
    console.log(`[TierLogic Helper DI] Calculating metric for user ${userId}. Basis=${basis}, StartDate=${startDate?.toISOString() ?? 'Lifetime'}`);
    const whereBase: Prisma.QrCodeWhereInput = { userId: userId, status: QrCodeStatus.COMPLETED, };
    if (startDate) {
        whereBase.completedAt = { gte: startDate };
    }
    let userMetricValue = 0;
    try {
        switch (basis) {
            case TierCalculationBasis.SPEND:
                const spendResult = await prismaClient.qrCode.aggregate({ _sum: { amount: true }, where: whereBase, });
                userMetricValue = spendResult._sum.amount ?? 0;
                break;
            case TierCalculationBasis.VISITS:
                const visitCount = await prismaClient.qrCode.count({ where: whereBase, });
                userMetricValue = visitCount;
                break;
            case TierCalculationBasis.POINTS_EARNED:
                const pointsResult = await prismaClient.qrCode.aggregate({ _sum: { pointsEarned: true }, where: whereBase, });
                userMetricValue = pointsResult._sum.pointsEarned ?? 0;
                break;
        }
    } catch (error) {
        console.error(`[TierLogic Helper DI] Error calculating metric ${basis} for user ${userId}:`, error);
        userMetricValue = 0;
    }
    console.log(`[TierLogic Helper DI] User ${userId} - Metric Result (${basis}) = ${userMetricValue}`);
    return userMetricValue;
}

export function determineTargetTier(metricValue: number, activeTiers: ActiveTierInfo[]): string | null {
    // (Sin cambios)
    let targetTierId: string | null = null;
    for (const tier of activeTiers) {
        if (metricValue >= tier.minValue) {
            targetTierId = tier.id;
            break;
        }
    }
    return targetTierId;
}

export async function calculateTierForReview(
    prismaClient: PrismaClient,
    userId: string
): Promise<{ userId: string, currentTierId: string | null, targetTierId: string | null } | null> {
    console.log(`[Tier JOB Helper DI] Calculating target tier for user ${userId}`);
    try {
        const user = await prismaClient.user.findUnique({
             where: { id: userId },
             include: { /* ... include business ... */
                business: {
                    select: {
                        id: true, tierSystemEnabled: true, tierCalculationBasis: true,
                        tierCalculationPeriodMonths: true,
                        tiers: { where: { isActive: true }, orderBy: { level: 'desc' }, select: { id: true, name: true, level: true, minValue: true } }
                    }
                },
             }
        });

         if (!user || !user.business) { return null; }

        // --- NUEVO: Comprobaci√≥n de null ---
        if (!user.business.tierSystemEnabled || !user.business.tierCalculationBasis || !user.business.tiers || user.business.tiers.length === 0) {
            console.log(`[Tier JOB Helper DI] Skipping review calc for user ${userId} due to missing config or no active tiers.`);
            return null;
        }
        // --- FIN NUEVO ---


        const config = user.business;
        const activeTiers: ActiveTierInfo[] = config.tiers;
        const calculationBasis = config.tierCalculationBasis; // Sabemos que no es null aqu√≠
        const periodMonths = config.tierCalculationPeriodMonths;
        const now = new Date();
        let startDate: Date | undefined = (periodMonths && periodMonths > 0) ? subMonths(now, periodMonths) : undefined;

        // --- CAMBIO: A√±adir '!' para asegurar a TS que calculationBasis no es null ---
        const userMetricValue = await calculateUserMetric(prismaClient, userId, calculationBasis!, startDate);
        // --- FIN CAMBIO ---
        const targetTierId = determineTargetTier(userMetricValue, activeTiers);

        return { userId: user.id, currentTierId: user.currentTierId, targetTierId: targetTierId };
    } catch (error) {
        console.error(`[Tier JOB Helper DI] Error calculating tier for review for user ${userId}:`, error);
        return null;
    }
}

export async function handleInactivityCheckUser(
    prismaClient: PrismaClient,
    user: Pick<User, 'id' | 'lastActivityAt' | 'currentTierId'>,
    inactivityPeriodMonths: number,
    now: Date
): Promise<boolean> {
    // (Sin cambios)
     if (user.currentTierId === null) { return false; }
    if (!user.lastActivityAt) { console.log(`[Tier JOB Helper DI] User ${user.id} has no lastActivityAt date.`); return false; }
    const inactivityLimitDate = subMonths(now, inactivityPeriodMonths);
    if (isBefore(user.lastActivityAt, inactivityLimitDate)) {
        console.log(`[Tier JOB Helper DI] Downgrading user ${user.id} due to inactivity.`);
        try {
            await prismaClient.user.update({ where: { id: user.id }, data: { currentTierId: null, tierAchievedAt: null } });
            return true;
        } catch (error) {
            console.error(`[Tier JOB Helper DI] Failed to downgrade user ${user.id} due to inactivity:`, error);
            return false;
        }
    }
    return false;
}

// End of File: backend/src/tiers/tier-logic.helpers.ts


// ====== [26] backend/src/modules/loyalpyme/tiers/tier-logic.service.ts ======
// filename: backend/src/tiers/tier-logic.service.ts
// Version: 2.2.1 (Pass prisma instance to helpers)

import { PrismaClient, User, Prisma, Tier, TierCalculationBasis, TierDowngradePolicy } from '@prisma/client';
import { subMonths } from 'date-fns';
import {
    calculateUserMetric,
    determineTargetTier,
    calculateTierForReview,
    handleInactivityCheckUser
} from './tier-logic.helpers';

// Instancia de Prisma para este servicio
const prisma = new PrismaClient();

type ActiveTierInfo = Pick<Tier, 'id' | 'name' | 'level' | 'minValue'>;


/**
 * Calcula y actualiza el Tier de un usuario basado en la configuraci√≥n del negocio.
 */
export const updateUserTier = async (userId: string): Promise<void> => {
    console.log(`[TierLogic SVC] Checking/Updating tier for user: ${userId}`);
    try {
        const user = await prisma.user.findUniqueOrThrow({
             where: { id: userId },
             include: {
                 business: {
                     select: {
                         id: true, tierSystemEnabled: true, tierCalculationBasis: true,
                         tierCalculationPeriodMonths: true,
                         tiers: { where: { isActive: true }, orderBy: { level: 'desc' }, select: { id: true, name: true, level: true, minValue: true } }
                     }
                 },
             }
        });
        if (!user.business || !user.business.tierSystemEnabled || !user.business.tierCalculationBasis || !user.business.tiers || user.business.tiers.length === 0) {
            console.log(`[TierLogic SVC] Skipping tier update for user ${userId} due to missing config or disabled system.`);
            return;
        }

        const config = user.business;
        const activeTiers: ActiveTierInfo[] = config.tiers;
        const calculationBasis = config.tierCalculationBasis; // Sabemos que no es null
        const periodMonths = config.tierCalculationPeriodMonths;
        const now = new Date();
        let startDate: Date | undefined = (periodMonths && periodMonths > 0) ? subMonths(now, periodMonths) : undefined;

        // --- CORRECCI√ìN: Pasar 'prisma' a calculateUserMetric ---
        const userMetricValue = await calculateUserMetric(prisma, userId, calculationBasis!, startDate);
        // --- FIN CORRECCI√ìN ---
        const targetTierId = determineTargetTier(userMetricValue, activeTiers);

        if (user.currentTierId !== targetTierId) {
            console.log(`[TierLogic SVC] Updating user ${userId} tier from ${user.currentTierId || 'None'} to ${targetTierId || 'None'}`);
            await prisma.user.update({
                where: { id: userId },
                data: {
                    currentTierId: targetTierId,
                    tierAchievedAt: targetTierId ? now : null,
                 },
            });
        } else {
            console.log(`[TierLogic SVC] User ${userId} remains in tier ${user.currentTierId || 'None'}. No update needed.`);
        }
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             console.error(`[TierLogic SVC] User ${userId} not found during tier update check.`);
         } else {
             console.error(`[TierLogic SVC] Error updating tier for user ${userId}:`, error);
         }
    }
};

/**
 * Procesa las actualizaciones y posibles descensos de nivel para todos los usuarios aplicables.
 */
export const processTierUpdatesAndDowngrades = async (): Promise<void> => {
    const jobStartTime = new Date();
    console.log(`[Tier JOB ${jobStartTime.toISOString()}] Starting scheduled tier update/downgrade process...`);
    let businessesProcessed = 0;
    let usersProcessed = 0;
    let usersDowngradedInactivity = 0;
    let usersCheckedPeriodic = 0;
    let usersUpdatedPeriodic = 0;

    try {
        const businessesToProcess = await prisma.business.findMany({
            where: {
                tierSystemEnabled: true,
                 tierDowngradePolicy: { not: TierDowngradePolicy.NEVER }
            },
            select: { id: true, tierDowngradePolicy: true, tierCalculationPeriodMonths: true, inactivityPeriodMonths: true }
        });
        if (businessesToProcess.length === 0) {
            console.log(`[Tier JOB ${jobStartTime.toISOString()}] No businesses with active downgrade policies. Finishing.`);
            return;
        }
        console.log(`[Tier JOB ${jobStartTime.toISOString()}] Found ${businessesToProcess.length} businesses to process.`);
        businessesProcessed = businessesToProcess.length;
        const now = new Date();

        for (const business of businessesToProcess) {
            console.log(`[Tier JOB] Processing business ${business.id} with policy ${business.tierDowngradePolicy}`);
            const users = await prisma.user.findMany({
                where: { businessId: business.id, isActive: true, role: 'CUSTOMER_FINAL' },
                select: { id: true, lastActivityAt: true, currentTierId: true }
            });
            if (users.length === 0) {
                console.log(`[Tier JOB] No active customer users for business ${business.id}. Skipping.`);
                continue;
            }

            for (const user of users) {
                usersProcessed++;
                try {
                    if (business.tierDowngradePolicy === TierDowngradePolicy.PERIODIC_REVIEW) {
                        usersCheckedPeriodic++;
                        // --- CORRECCI√ìN: Pasar 'prisma' a calculateTierForReview ---
                        const reviewResult = await calculateTierForReview(prisma, user.id);
                        // --- FIN CORRECCI√ìN ---
                        if (reviewResult && reviewResult.currentTierId !== reviewResult.targetTierId) {
                            console.log(`[Tier JOB] Updating user ${user.id} tier from ${reviewResult.currentTierId || 'None'} to ${reviewResult.targetTierId || 'None'} based on periodic review.`);
                            await prisma.user.update({
                                where: { id: user.id },
                                data: {
                                     currentTierId: reviewResult.targetTierId,
                                     tierAchievedAt: reviewResult.targetTierId ? now : null
                                }
                            });
                            usersUpdatedPeriodic++;
                        } else if (reviewResult) {
                            // console.log(`[Tier JOB] User ${user.id} tier remains unchanged after periodic review.`);
                        }
                    } else if (business.tierDowngradePolicy === TierDowngradePolicy.AFTER_INACTIVITY && business.inactivityPeriodMonths) {
                        // --- CORRECCI√ìN: Pasar 'prisma' a handleInactivityCheckUser ---
                        const downgraded = await handleInactivityCheckUser(prisma, user, business.inactivityPeriodMonths, now);
                        // --- FIN CORRECCI√ìN ---
                        if (downgraded) usersDowngradedInactivity++;
                    }
                } catch (userProcessingError) {
                    console.error(`[Tier JOB] Unexpected error processing user ${user.id} for business ${business.id}:`, userProcessingError);
                }
            } // Fin loop usuarios
        } // Fin loop negocios
    } catch (error) {
        console.error(`[Tier JOB ${jobStartTime.toISOString()}] Critical error during scheduled processing:`, error);
    } finally {
        const jobEndTime = new Date();
        const duration = (jobEndTime.getTime() - jobStartTime.getTime()) / 1000;
        console.log(`[Tier JOB ${jobStartTime.toISOString()}] Finished processing. Duration: ${duration}s. Businesses: ${businessesProcessed}, Total Users Processed: ${usersProcessed}, Users Checked (Periodic): ${usersCheckedPeriodic}, Updated (Periodic): ${usersUpdatedPeriodic}, Downgraded (Inactivity): ${usersDowngradedInactivity}.`);
    }
};

// End of File: backend/src/tiers/tier-logic.service.ts


// ====== [27] backend/src/modules/loyalpyme/tiers/tiers.controller.ts ======
// File: backend/src/tiers/tiers.controller.ts
// Version: 1.0.0 (Initial controller structure with handlers)

import { Request, Response } from 'express';
import { Prisma } from '@prisma/client'; // Para tipos de error y DTOs

// Importar funciones de los diferentes servicios de Tiers
import * as TierConfigService from './tier-config.service';
import * as TierService from './tiers.service';
import * as TierBenefitService from './tier-benefit.service';
// Todav√≠a no importamos nada de tier-logic.service, ya que updateUserTier se llama internamente o por jobs

// --- Handlers para Configuraci√≥n de Tiers del Negocio (Admin) ---

export const getBusinessTierConfigHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId; // Asumimos que authenticateToken y checkRole(ADMIN) ya pasaron
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });

    try {
        const config = await TierConfigService.getBusinessTierConfig(businessId);
        if (!config) {
            // No es necesariamente un error, podr√≠a ser que el negocio no existe (aunque el token s√≠)
            // O simplemente devolvemos un objeto por defecto si queremos que siempre exista config?
            // Por ahora, devolvemos 404 si no hay negocio o config impl√≠citamente.
             return res.status(404).json({ message: 'Configuraci√≥n de Tiers no encontrada para este negocio.' });
        }
        res.status(200).json(config);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error getting tier config for business ${businessId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener la configuraci√≥n de Tiers.' });
    }
};

export const updateBusinessTierConfigHandler = async (req: Request, res: Response) => {
     const businessId = req.user?.businessId;
     if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });

     // TODO: Validar req.body con un DTO (ej: usando class-validator si se a√±ade)
     const configData = req.body; // Asumimos que el body contiene los campos a actualizar

     // Validaci√≥n b√°sica (mejorar con DTOs)
     if (typeof configData.tierSystemEnabled !== 'boolean' && configData.tierSystemEnabled !== undefined) {
         return res.status(400).json({ message: 'tierSystemEnabled debe ser booleano.' });
     }
     // A√±adir m√°s validaciones para enums, periodos, etc.

     try {
         const updatedBusiness = await TierConfigService.updateBusinessTierConfig(businessId, configData);
         // Devolvemos solo la parte de config actualizada para consistencia con GET? O todo el Business?
         // Devolvemos todo por ahora.
         res.status(200).json(updatedBusiness);
     } catch (error: any) {
         console.error(`[Tiers CTRL] Error updating tier config for business ${businessId}:`, error);
         res.status(500).json({ message: error.message || 'Error interno al actualizar la configuraci√≥n de Tiers.' });
     }
};


// --- Handlers para CRUD de Tiers (Admin) ---

export const createTierHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });

    // TODO: Validar req.body con DTO
    const tierData = req.body;

    // Validaci√≥n b√°sica (mejorar con DTOs)
     if (!tierData.name || typeof tierData.level !== 'number' || typeof tierData.minValue !== 'number') {
         return res.status(400).json({ message: 'Nombre, nivel y valor m√≠nimo son requeridos para el Tier.' });
     }

    try {
        // Pasamos solo los datos relevantes al servicio, excluyendo relaciones/ids
        const { name, level, minValue, description, benefitsDescription, isActive } = tierData;
        const newTier = await TierService.createTier(businessId, { name, level, minValue, description, benefitsDescription, isActive });
        res.status(201).json(newTier);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error creating tier for business ${businessId}:`, error);
        // Devolver 409 si es error de unicidad
        if (error.message.includes('unicidad')) {
            return res.status(409).json({ message: error.message });
        }
        res.status(500).json({ message: error.message || 'Error interno al crear el Tier.' });
    }
};

export const getBusinessTiersHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    const includeBenefits = req.query.includeBenefits === 'true'; // Opci√≥n para incluir beneficios

    try {
        const tiers = await TierService.findTiersByBusiness(businessId, includeBenefits);
        res.status(200).json(tiers);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error getting tiers for business ${businessId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener los Tiers.' });
    }
};

export const getTierByIdHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    const { tierId } = req.params;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
    const includeBenefits = req.query.includeBenefits === 'true';

    try {
        const tier = await TierService.findTierById(tierId, businessId, includeBenefits);
        if (!tier) {
            return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }
        res.status(200).json(tier);
    } catch (error: any) {
         console.error(`[Tiers CTRL] Error getting tier ${tierId} for business ${businessId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener el Tier.' });
    }
};

export const updateTierHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    const { tierId } = req.params;
     if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
     if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });

     // TODO: Validar req.body con DTO
     const updateData = req.body;
      // Validaci√≥n b√°sica
      if (Object.keys(updateData).length === 0) {
         return res.status(400).json({ message: 'Se requieren datos para actualizar.' });
      }

     try {
         const updatedTier = await TierService.updateTier(tierId, businessId, updateData);
         res.status(200).json(updatedTier);
     } catch (error: any) {
         console.error(`[Tiers CTRL] Error updating tier ${tierId} for business ${businessId}:`, error);
         if (error.message.includes('no encontrado')) {
             return res.status(404).json({ message: error.message });
         }
         if (error.message.includes('unicidad')) {
             return res.status(409).json({ message: error.message });
         }
         res.status(500).json({ message: error.message || 'Error interno al actualizar el Tier.' });
     }
};

export const deleteTierHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    const { tierId } = req.params;
     if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
     if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });

     try {
         const deletedTier = await TierService.deleteTier(tierId, businessId);
         res.status(200).json({ message: 'Tier eliminado correctamente.', deletedTier }); // o res.sendStatus(204)
     } catch (error: any) {
         console.error(`[Tiers CTRL] Error deleting tier ${tierId} for business ${businessId}:`, error);
         if (error.message.includes('no encontrado') || error.message.includes('usuarios asignados')) {
             // 404 si no existe, 409 (Conflicto) si tiene usuarios
             const statusCode = error.message.includes('usuarios asignados') ? 409 : 404;
             return res.status(statusCode).json({ message: error.message });
         }
         res.status(500).json({ message: error.message || 'Error interno al eliminar el Tier.' });
     }
};

// --- Handlers para CRUD de TierBenefits (Admin) ---

export const createTierBenefitHandler = async (req: Request, res: Response) => {
    // Necesitamos el ID del Tier al que a√±adir el beneficio (vendr√° en la URL)
    const businessId = req.user?.businessId; // Para verificar pertenencia del Tier
    const { tierId } = req.params;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier en la URL.' });

    // TODO: Validar req.body con DTO
    const benefitData = req.body;
     // Validaci√≥n b√°sica
     if (!benefitData.type || !benefitData.value) {
         return res.status(400).json({ message: 'Tipo y valor son requeridos para el beneficio.' });
     }
     // A√±adir validaci√≥n de enum BenefitType

    try {
        // Verificar que el Tier pertenece al negocio antes de crear el beneficio
        const tier = await TierService.findTierById(tierId, businessId);
        if (!tier) {
             return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }
        // Crear el beneficio asociado a ese tierId
        const { type, value, description, isActive } = benefitData;
        const newBenefit = await TierBenefitService.createTierBenefit(tierId, { type, value, description, isActive });
        res.status(201).json(newBenefit);
    } catch (error: any) {
         console.error(`[Tiers CTRL] Error creating benefit for tier ${tierId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al crear el beneficio.' });
    }
};

export const getTierBenefitsHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId; // Para verificar pertenencia del Tier
    const { tierId } = req.params;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });

    try {
        // Opcional: Verificar que el Tier pertenece al negocio
        const tier = await TierService.findTierById(tierId, businessId);
        if (!tier) {
             return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }
        // Obtener los beneficios
        const benefits = await TierBenefitService.findBenefitsByTier(tierId);
        res.status(200).json(benefits);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error getting benefits for tier ${tierId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener los beneficios.' });
    }
};

export const updateTierBenefitHandler = async (req: Request, res: Response) => {
    const { benefitId } = req.params; // Solo necesitamos el ID del beneficio
     if (!benefitId) return res.status(400).json({ message: 'Se requiere ID del Beneficio.' });
    // TODO: Validar req.body con DTO
    const updateData = req.body;
    if (Object.keys(updateData).length === 0) { return res.status(400).json({ message: 'Se requieren datos para actualizar.' }); }

    // Opcional: Verificar que el beneficio pertenece a un tier del negocio logueado (m√°s complejo)
    // const businessId = req.user?.businessId;
    // const benefit = await prisma.tierBenefit.findUnique({ where: {id: benefitId}, include: { tier: { select: { businessId: true }}}})
    // if (!benefit || benefit.tier.businessId !== businessId) return res.status(404)...

    try {
        const updatedBenefit = await TierBenefitService.updateTierBenefit(benefitId, updateData);
        res.status(200).json(updatedBenefit);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error updating benefit ${benefitId}:`, error);
        if (error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        res.status(500).json({ message: error.message || 'Error interno al actualizar el beneficio.' });
    }
};

export const deleteTierBenefitHandler = async (req: Request, res: Response) => {
    const { benefitId } = req.params;
    if (!benefitId) return res.status(400).json({ message: 'Se requiere ID del Beneficio.' });

    // Opcional: Verificar pertenencia al negocio logueado
    try {
        const deletedBenefit = await TierBenefitService.deleteTierBenefit(benefitId);
        res.status(200).json({ message: 'Beneficio eliminado correctamente.', deletedBenefit }); // o res.sendStatus(204)
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error deleting benefit ${benefitId}:`, error);
        if (error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        res.status(500).json({ message: error.message || 'Error interno al eliminar el beneficio.' });
    }
};


// --- Handlers para Clientes ---

export const getCustomerTiersHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId; // Cliente final autenticado
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token del cliente.' });

    try {
         // Reutilizamos la funci√≥n del servicio de Tiers para obtenerlos
         // Podr√≠amos querer incluir beneficios aqu√≠ tambi√©n para mostrarlos al cliente
        const tiers = await TierService.findTiersByBusiness(businessId, true); // includeBenefits = true
        res.status(200).json(tiers);
    } catch (error: any) {
         console.error(`[Tiers CTRL] Error getting tiers for customer of business ${businessId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener los niveles del programa.' });
    }
};


// End of File: backend/src/tiers/tiers.controller.ts


// ====== [28] backend/src/modules/loyalpyme/tiers/tiers.service.ts ======
// filename: backend/src/tiers/tiers.service.ts
// Version: 1.0.1 (Add debug log)

import { PrismaClient, Tier, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Crea un nuevo Tier para un negocio.
 * @param businessId - ID del negocio.
 * @param tierData - Datos del nuevo Tier.
 * @returns El Tier creado.
 */
export const createTier = async (
    businessId: string,
    tierData: Omit<Prisma.TierCreateInput, 'business' | 'users' | 'benefits'>
): Promise<Tier> => {
    console.log(`[Tier SVC] Creating tier for business ${businessId}:`, tierData);
    try {
        const newTier = await prisma.tier.create({
             data: {
                 ...tierData,
                 business: {
                     connect: { id: businessId }
                 }
             },
        });
        console.log(`[Tier SVC] Tier created successfully with ID: ${newTier.id}`);
        return newTier;
     } catch (error) {
         console.error(`[Tier SVC] Error creating tier for business ${businessId}:`, error);
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             const target = error.meta?.target as string[];
             if (target?.includes('level')) {
                 throw new Error(`Ya existe un Tier con el nivel '${tierData.level}' para este negocio.`);
             } else if (target?.includes('name')) {
                 throw new Error(`Ya existe un Tier con el nombre '${tierData.name}' para este negocio.`);
             }
             throw new Error('Conflicto de unicidad al crear el Tier (nivel o nombre ya existen).');
         }
         throw new Error('Error al crear el nivel de fidelizaci√≥n.');
     }
};

/**
 * Encuentra todos los Tiers de un negocio espec√≠fico, opcionalmente incluyendo sus beneficios.
 * @param businessId ID del negocio.
 * @param includeBenefits Si es true, incluye los beneficios asociados.
 * @returns Lista de Tiers.
 */
export const findTiersByBusiness = async (businessId: string, includeBenefits: boolean = false): Promise<Tier[]> => {
    console.log(`[Tier SVC] Finding tiers for business: ${businessId}, includeBenefits: ${includeBenefits}`);
    try {
        const tiers = await prisma.tier.findMany({
            where: { businessId: businessId },
            orderBy: { level: 'asc' },
            include: {
                benefits: includeBenefits,
            }
        });
        // --- NUEVO LOG ---
        console.log(`[Tier SVC] Prisma findMany finished. Found ${tiers.length} tiers.`);
        // ---------------
        return tiers;
    } catch (error) {
        // --- NUEVO LOG ---
        console.error(`[Tier SVC] *** ERROR within findTiersByBusiness try/catch for business ${businessId}:`, error);
        // ---------------
         console.error(`[Tier SVC] Error finding tiers for business ${businessId}:`, error); // Mantener log original tambi√©n
         throw new Error('Error al buscar los niveles de fidelizaci√≥n.');
    }
};

/**
 * Encuentra un Tier espec√≠fico por su ID, asegurando que pertenece al negocio dado.
 * @param tierId ID del Tier.
 * @param businessId ID del negocio propietario.
 * @param includeBenefits Si es true, incluye los beneficios asociados.
 * @returns El Tier encontrado o null.
 */
export const findTierById = async (tierId: string, businessId: string, includeBenefits: boolean = false): Promise<Tier | null> => {
     console.log(`[Tier SVC] Finding tier by ID: ${tierId} for business: ${businessId}, includeBenefits: ${includeBenefits}`);
     try {
         const tier = await prisma.tier.findFirst({
             where: {
                 id: tierId,
                 businessId: businessId
             },
             include: {
                 benefits: includeBenefits,
             }
         });
         return tier;
     } catch (error) {
         console.error(`[Tier SVC] Error finding tier ${tierId}:`, error);
         throw new Error('Error al buscar el nivel de fidelizaci√≥n por ID.');
     }
};

/**
 * Actualiza un Tier existente.
 * @param tierId ID del Tier a actualizar.
 * @param businessId ID del negocio propietario (para verificaci√≥n).
 * @param updateData Datos a actualizar.
 * @returns El Tier actualizado.
 * @throws Error si el Tier no se encuentra o no pertenece al negocio.
 */
export const updateTier = async (
    tierId: string,
    businessId: string,
    updateData: Partial<Omit<Prisma.TierUpdateInput, 'business' | 'users' | 'benefits'>>
): Promise<Tier> => {
    console.log(`[Tier SVC] Updating tier ID: ${tierId} for business: ${businessId}`, updateData);
    try {
        const existingTier = await prisma.tier.findFirst({
            where: { id: tierId, businessId: businessId },
            select: { id: true }
        });
        if (!existingTier) {
            throw new Error(`Nivel (Tier) con ID ${tierId} no encontrado o no pertenece a este negocio.`);
        }
        const updatedTier = await prisma.tier.update({
            where: { id: tierId },
            data: updateData,
        });
        console.log(`[Tier SVC] Tier ${tierId} updated successfully.`);
        return updatedTier;
    } catch (error) {
        console.error(`[Tier SVC] Error updating tier ${tierId}:`, error);
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             throw new Error('Conflicto de unicidad al actualizar el Tier (nivel o nombre ya existen).');
         }
        if (error instanceof Error && error.message.startsWith('Nivel (Tier) con ID')) {
             throw error;
         }
        throw new Error('Error al actualizar el nivel de fidelizaci√≥n.');
    }
};

/**
 * Elimina un Tier existente.
 * @param tierId ID del Tier a eliminar.
 * @param businessId ID del negocio propietario (para verificaci√≥n).
 * @returns El Tier eliminado.
 * @throws Error si el Tier no se encuentra o no pertenece al negocio, o si tiene usuarios asignados.
 */
export const deleteTier = async (tierId: string, businessId: string): Promise<Tier> => {
    console.log(`[Tier SVC] Deleting tier ID: ${tierId} for business: ${businessId}`);
    try {
        const existingTier = await prisma.tier.findFirst({
            where: { id: tierId, businessId: businessId },
             select: { id: true, _count: { select: { users: true } } }
        });
        if (!existingTier) {
            throw new Error(`Nivel (Tier) con ID ${tierId} no encontrado o no pertenece a este negocio.`);
        }
        if (existingTier._count.users > 0) {
             console.warn(`[Tiers SVC] Attempted to delete tier ${tierId} which has ${existingTier._count.users} users assigned.`);
             throw new Error(`No se puede eliminar el Nivel ${tierId} porque tiene usuarios asignados. Reas√≠gnelos primero.`);
         }
        const deletedTier = await prisma.tier.delete({
            where: { id: tierId },
        });
        console.log(`[Tier SVC] Tier ${tierId} deleted successfully.`);
        return deletedTier;
     } catch (error) {
         console.error(`[Tier SVC] Error deleting tier ${tierId}:`, error);
        if (error instanceof Error && (error.message.startsWith('Nivel (Tier) con ID') || error.message.includes('usuarios asignados'))) {
             throw error;
         }
        throw new Error('Error al eliminar el nivel de fidelizaci√≥n.');
     }
};

// End of File: backend/src/tiers/tiers.service.ts


// ====== [29] backend/src/shared/auth/__tests__/auth.service.test.ts ======
import { describe, it, expect } from 'vitest';
import { hashPassword, comparePassword } from '../auth.service'; // Ajusta ruta si auth.service no est√° en el nivel superior

describe('Auth Service Helpers', () => {
  it('should hash a password correctly', async () => {
    const plainPassword = 'password123';
    const hashedPassword = await hashPassword(plainPassword);

    expect(hashedPassword).toBeTypeOf('string');
    expect(hashedPassword).not.toBe(plainPassword);
    expect(hashedPassword.length).toBeGreaterThan(50);
  });

  it('should compare a correct password successfully', async () => {
    const plainPassword = 'password123';
    const hashedPassword = await hashPassword(plainPassword);
    const isMatch = await comparePassword(plainPassword, hashedPassword);

    expect(isMatch).toBe(true);
  });

  it('should fail comparing an incorrect password', async () => {
    const plainPassword = 'password123';
    const wrongPassword = 'password456';
    const hashedPassword = await hashPassword(plainPassword);
    const isMatch = await comparePassword(wrongPassword, hashedPassword);

    expect(isMatch).toBe(false);
  });
});


// ====== [30] backend/src/shared/auth/auth.controller.ts ======
// filename: backend/src/auth/auth.controller.ts
// Version: 2.1.0 (Refactored: Only contains login handler, cleaned)

import { Request, Response } from 'express';
import { User } from '@prisma/client'; // Needed for type casting if generateToken expects User

// Importar solo utilidades necesarias para login desde auth.service
import { comparePassword, generateToken, findUserByEmail } from './auth.service';

/**
 * Handles user login. POST /api/auth/login
 */
export const login = async (req: Request, res: Response) => {
    const { email, password } = req.body;
    // console.log(`[AUTH CTRL] Attempting login for email: ${email}`); // Log reducido

    if (!email || !password) {
        // console.log('[AUTH CTRL] Login failed: Email or password missing.'); // Log reducido
        return res.status(400).json({ message: 'Se requieren email y contrase√±a.' }); // Corregido: contrase√±a
    }

    try {
        // console.log(`[AUTH CTRL] Finding user by email: ${email}`); // Log reducido
        const user = await findUserByEmail(email);
        if (!user || !user.isActive) {
            // console.log(`[AUTH CTRL] User not found or inactive for email: ${email}. Sending 401.`); // Log reducido
            // Devolvemos 401 Unauthorized para ambos casos (no encontrado o inactivo) por seguridad
            return res.status(401).json({ message: 'Credenciales inv√°lidas o usuario inactivo.' }); // Corregido: inv√°lidas
        }

        // console.log(`[AUTH CTRL] User found: ${user.id}. Comparing password...`); // Log reducido
        const passwordMatch = await comparePassword(password, user.password);
        if (!passwordMatch) {
            // console.log(`[AUTH CTRL] Password mismatch for user ${user.id}. Sending 401.`); // Log reducido
            return res.status(401).json({ message: 'Credenciales inv√°lidas.' }); // Corregido: inv√°lidas
        }

        // console.log(`[AUTH CTRL] Password matches for user ${user.id}. Generating token...`); // Log reducido
        const token = generateToken(user); // generateToken necesita id, role, businessId

        // Excluimos campos sensibles de la respuesta. Ahora quitamos las variables no usadas directamente.
        const {
            password: _password, // Renombrar para evitar conflicto y marcar como no usado
            documentId: _documentId,
            resetPasswordToken: _resetPasswordToken,
            resetPasswordExpires: _resetPasswordExpires,
            ...userWithoutSensitiveData // El resto de campos del usuario
        } = user;

        console.log(`[AUTH CTRL] Login successful for user ${user.id}. Sending 200.`);
        res.status(200).json({ user: userWithoutSensitiveData, token });

    } catch (error) {
        console.error('[AUTH CTRL] Error during login:', error); // Mantener log de error
        res.status(500).json({ message: 'Error del servidor durante el inicio de sesi√≥n.' }); // Corregido: sesi√≥n
    }
};

// Las funciones register, registerBusinessHandler, forgotPasswordHandler, resetPasswordHandler han sido movidas.

// End of File: backend/src/auth/auth.controller.ts


// ====== [31] backend/src/shared/auth/auth.dto.ts ======
// filename: backend/src/auth/auth.dto.ts
// --- INICIO DEL C√ìDIGO COMPLETO ---
// File: backend/src/auth/auth.dto.ts
// Version: 1.2.0 (Add RegisterBusinessDto)

import { UserRole, DocumentType } from '@prisma/client';

// DTO para Registro de Cliente (existente)
export interface RegisterUserDto {
  email: string;
  password: string;
  name?: string;
  phone: string; // Tel√©fono del cliente
  documentId: string; // Documento del cliente
  documentType: DocumentType; // Tipo doc cliente
  businessId: string; // ID del negocio al que se une
  role: UserRole; // Debe ser CUSTOMER_FINAL
}

// DTO para solicitar reseteo (existente)
export interface ForgotPasswordDto {
    email: string;
}

// DTO para realizar el reseteo (existente)
export interface ResetPasswordDto {
    password: string; // La nueva contrase√±a
    // El token vendr√° por la URL (req.params)
}

// --- NUEVO: DTO para registrar un Negocio y su Admin ---
export interface RegisterBusinessDto {
    businessName: string;   // Nombre del nuevo negocio
    adminEmail: string;     // Email para el usuario administrador inicial
    adminPassword: string;  // Contrase√±a para ese administrador
    adminName?: string;      // Nombre opcional para el administrador
    // No necesitamos m√°s datos por ahora para el MVP (slug se generar√°, etc.)
    // No pasamos role porque siempre ser√° BUSINESS_ADMIN
    // No pasamos businessId porque se va a crear uno nuevo
}
// --- FIN NUEVO ---


// End of File: backend/src/auth/auth.dto.ts
// --- FIN DEL C√ìDIGO COMPLETO ---


// ====== [32] backend/src/shared/auth/auth.service.ts ======
// filename: backend/src/auth/auth.service.ts
// Version: 2.1.0 (Add conditional logging for test environment)

import { PrismaClient, User } from '@prisma/client';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

const prisma = new PrismaClient();
const JWT_SECRET = process.env.JWT_SECRET as string;

// Validaci√≥n de JWT_SECRET
if (!JWT_SECRET) {
    console.error('FATAL ERROR: JWT_SECRET is not defined in auth.service.');
    // process.exit(1); // Considerar salir
}

// --- Funciones de Utilidad B√°sicas ---

/**
 * Hashea una contrase√±a usando bcrypt.
 */
export const hashPassword = async (password: string): Promise<string> => {
    const salt = await bcrypt.genSalt(10);
    return bcrypt.hash(password, salt);
};

/**
 * Compara una contrase√±a en texto plano con una hasheada.
 */
export const comparePassword = async (plainPassword: string, hashedPassword: string): Promise<boolean> => {
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - comparePassword] Comparing provided password with hash ${hashedPassword ? hashedPassword.substring(0,10) : 'N/A'}...`);
    }
    // --- FIN LOG DE DEBUG ---
    const isMatch = await bcrypt.compare(plainPassword, hashedPassword);
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - comparePassword] Result: ${isMatch}`);
    }
    // --- FIN LOG DE DEBUG ---
    return isMatch;
};

/**
 * Genera un token JWT para un usuario.
 */
export const generateToken = (user: Pick<User, 'id' | 'role' | 'businessId'>): string => {
    const payload = {
        userId: user.id,
        role: user.role,
        businessId: user.businessId
    };
    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: '7d' }); // 7 d√≠as de expiraci√≥n
    return token;
};

/**
 * Encuentra un usuario por su direcci√≥n de email.
 */
export const findUserByEmail = async (email: string): Promise<User | null> => {
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - findUserByEmail] Searching for email: ${email}`);
    }
    // --- FIN LOG DE DEBUG ---
    const user = await prisma.user.findUnique({ where: { email } });
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - findUserByEmail] User found: ${user ? `{ id: ${user.id}, email: ${user.email}, isActive: ${user.isActive} }` : 'null'}`);
    }
    // --- FIN LOG DE DEBUG ---
    return user;
};

// --- Funciones movidas a otros servicios ---
// createUser -> registration.service.ts
// handleForgotPassword, handleResetPassword -> password-reset.service.ts
// createBusinessAndAdmin, generateSlug -> registration.service.ts

// End of File: backend/src/auth/auth.service.ts


// ====== [33] backend/src/shared/auth/password-reset.controller.ts ======
// filename: backend/src/auth/password-reset.controller.ts
// Version: 1.0.3 (Remove Swagger annotations)

import { Request, Response } from 'express';
// DTOs necesarios para reseteo
import { ForgotPasswordDto, ResetPasswordDto } from './auth.dto';

// Servicios necesarios
import { hashPassword } from './auth.service';
import { handleForgotPassword, handleResetPassword } from './password-reset.service';

// SIN ANOTACI√ìN @openapi
export const forgotPasswordHandler = async (req: Request, res: Response) => {
    const { email }: ForgotPasswordDto = req.body;

    if (!email) {
        return res.status(400).json({ message: 'Se requiere el email.' });
    }
    try {
        await handleForgotPassword(email);
        res.status(200).json({ message: 'Si existe una cuenta con ese email, se ha enviado un enlace para restablecer la contrase√±a.' });
    } catch (error: any) {
        console.error('[PWD_RESET CTRL] Error in forgotPasswordHandler:', error.message);
        res.status(200).json({ message: 'Si existe una cuenta con ese email, se ha enviado un enlace para restablecer la contrase√±a.' });
    }
};

// SIN ANOTACI√ìN @openapi
export const resetPasswordHandler = async (req: Request, res: Response) => {
    const { token } = req.params;
    const { password: newPassword }: ResetPasswordDto = req.body;

    if (!token) {
        return res.status(400).json({ message: 'Falta el token de reseteo.' });
    }
    if (!newPassword) {
        return res.status(400).json({ message: 'Se requiere la nueva contrase√±a.' });
    }
    if (newPassword.length < 6) {
        return res.status(400).json({ message: 'La nueva contrase√±a debe tener al menos 6 caracteres.' });
    }

    try {
        const hashedNewPassword = await hashPassword(newPassword);
        await handleResetPassword(token, hashedNewPassword);

        res.status(200).json({ message: 'Contrase√±a restablecida con √©xito.' });
    } catch (error: any) {
        console.error(`[PWD_RESET CTRL] Error in resetPasswordHandler for token ${token ? token.substring(0,5)+'...' : 'undefined'}:`, error.message);
        res.status(400).json({ message: error.message || 'No se pudo restablecer la contrase√±a.' });
    }
};

// End of File: backend/src/auth/password-reset.controller.ts


// ====== [34] backend/src/shared/auth/password-reset.service.ts ======
// filename: backend/src/auth/password-reset.service.ts
// Version: 1.0.1 (Fix encoding, remove insecure log, cleanup comments)

import { PrismaClient, User } from '@prisma/client';
// bcrypt ya no se usa directamente aqu√≠ si usamos comparePassword desde auth.service
import crypto from 'crypto';

// Importar utilidades necesarias desde el servicio principal de auth
// ASUNCI√ìN: Estas funciones permanecer√°n o ser√°n exportadas desde auth.service.ts
import { hashPassword, comparePassword, findUserByEmail } from './auth.service';

const prisma = new PrismaClient();

// Constante de expiraci√≥n (espec√≠fica de este flujo)
const RESET_TOKEN_EXPIRATION_MS = 60 * 60 * 1000; // 1 hour

// --- Funciones para Reseteo de Contrase√±a ---

export const handleForgotPassword = async (email: string): Promise<void> => {
    console.log(`[PWD_RESET SVC] Handling forgot password for: ${email}`);
    const user = await findUserByEmail(email); // Usa la utilidad importada
    if (!user) {
        console.log(`[PWD_RESET SVC] User not found for forgot password: ${email}. Responding generically.`);
        return; // Salir silenciosamente
    }

    const resetToken = crypto.randomBytes(32).toString('hex');
    // console.log(`[PWD_RESET SVC] Generated PLAIN reset token for ${email}: ${resetToken}`); // <-- LOG INSEGURO ELIMINADO
    const hashedResetToken = await hashPassword(resetToken);
    const expires = new Date(Date.now() + RESET_TOKEN_EXPIRATION_MS);

    try {
        await prisma.user.update({
            where: { email: email },
            data: {
                resetPasswordToken: hashedResetToken,
                resetPasswordExpires: expires,
            },
        });
        console.log(`[PWD_RESET SVC] Hashed reset token stored successfully for user ${user.id}`);
        // Aqu√≠ ir√≠a la l√≥gica real de env√≠o de email con el 'resetToken' (el original, NO el hasheado)
        // Ejemplo: await sendPasswordResetEmail(user.email, resetToken);
        // Por ahora, el token plano solo se logueaba (y ya hemos quitado eso)
    } catch (error) {
        console.error(`[PWD_RESET SVC] Failed to store reset token for user ${user.id}:`, error);
        // Considerar si relanzar o manejar el error de forma diferente
    }
};

export const handleResetPassword = async (token: string, hashedNewPassword: string): Promise<void> => {
    console.log(`[PWD_RESET SVC] Handling reset password with token starting: ${token.substring(0, 5)}...`);

    const potentialUsers = await prisma.user.findMany({
        where: {
            resetPasswordToken: { not: null },
            resetPasswordExpires: { gt: new Date() } // Buscar solo tokens no expirados
        }
    });

    if (!potentialUsers || potentialUsers.length === 0) {
        console.log('[PWD_RESET SVC] No users found with potentially valid (non-null, non-expired) reset tokens.');
        throw new Error('Token inv√°lido o expirado.'); // Error gen√©rico
    }
    console.log(`[PWD_RESET SVC] Found ${potentialUsers.length} users with active tokens. Verifying provided token...`);

    // Comparar token plano proporcionado con los hashes guardados
    let userToUpdate: User | null = null;
    for (const user of potentialUsers) {
        if (user.resetPasswordToken) {
            const isTokenMatch = await comparePassword(token, user.resetPasswordToken);
            if (isTokenMatch) {
                console.log(`[PWD_RESET SVC] Token match found for user ID: ${user.id}`);
                userToUpdate = user;
                break; // Encontramos el usuario, salimos del bucle
            }
        }
    }

    if (!userToUpdate) {
        // Si recorrimos todos los usuarios con token activo y ninguno coincidi√≥
        console.log(`[PWD_RESET SVC] No user matched the provided token among active ones.`);
        throw new Error('Token inv√°lido o expirado.'); // Mismo error gen√©rico
    }

    // Actualizar contrase√±a y limpiar campos de reseteo
    try {
        await prisma.user.update({
            where: { id: userToUpdate.id },
            data: {
                password: hashedNewPassword,
                resetPasswordToken: null, // Limpiar token
                resetPasswordExpires: null, // Limpiar expiraci√≥n
            },
        });
        console.log(`[PWD_RESET SVC] Password reset successful for user ${userToUpdate.id}`);
    } catch (error) {
        console.error(`[PWD_RESET SVC] Failed to update password for user ${userToUpdate.id}:`, error);
        throw new Error('Error al actualizar la contrase√±a.'); // Error m√°s espec√≠fico para el frontend
    }
};

// End of File: backend/src/auth/password-reset.service.ts


// ====== [35] backend/src/shared/auth/registration.controller.ts ======
// filename: backend/src/auth/registration.controller.ts
// Version: 1.0.2 (Remove Swagger annotations)

import { Request, Response } from 'express';
import { Prisma, DocumentType, User } from '@prisma/client';

// DTOs necesarios para registro
import { RegisterUserDto, RegisterBusinessDto } from './auth.dto';
// Utils de Validaci√≥n
import { isValidDni, isValidNie, isValidPhoneNumber } from '../utils/validation';

// Servicios necesarios
import { findUserByEmail, generateToken } from './auth.service';
import { createUser, createBusinessAndAdmin } from './registration.service';

// SIN ANOTACI√ìN @openapi
export const register = async (req: Request, res: Response) => {
    const { email, password, name, phone, documentId, documentType, businessId, role }: RegisterUserDto = req.body;

    if (!email || !password || !phone || !documentId || !documentType || !businessId || !role || role !== 'CUSTOMER_FINAL') {
        return res.status(400).json({ message: 'Faltan campos obligatorios o rol inv√°lido para registro de cliente.' });
    }

    try {
        const existingUser = await findUserByEmail(email);
        if (existingUser) {
            return res.status(409).json({ message: 'El email ya est√° registrado.' });
        }

        if (!isValidPhoneNumber(phone)) {
             return res.status(400).json({ message: 'Formato de tel√©fono inv√°lido.' });
        }
        let isDocumentValid = false;
        const upperDocumentId = documentId.toUpperCase();
        switch (documentType) {
            case DocumentType.DNI: isDocumentValid = isValidDni(upperDocumentId); break;
            case DocumentType.NIE: isDocumentValid = isValidNie(upperDocumentId); break;
            case DocumentType.PASSPORT: isDocumentValid = upperDocumentId.trim().length > 3; break;
            case DocumentType.OTHER: isDocumentValid = upperDocumentId.trim().length > 0; break;
            default: return res.status(400).json({ message: 'Tipo de documento inv√°lido.' });
        }
        if (!isDocumentValid) { return res.status(400).json({ message: `Formato de ${documentType} inv√°lido.` }); }

        const userDataForService: RegisterUserDto = {
             email, password, name, phone,
             documentId: upperDocumentId, // Enviar normalizado
             documentType, businessId, role
        };
        const newUser = await createUser(userDataForService);

        const {
            password: _password,
            documentId: _documentId,
            resetPasswordToken: _resetToken,
            resetPasswordExpires: _resetExpires,
            ...userWithoutSensitiveData
        } = newUser;
        console.log(`[REG CTRL] Customer registration successful for user ${newUser.id}. Sending 201.`);
        res.status(201).json({ user: userWithoutSensitiveData });
    } catch (error) {
        if (error instanceof Error && (error.message.includes('tel√©fono') || error.message.includes('documento') || error.message.includes('Business with ID') || error.message.includes('ya est√° registrado'))) {
             return res.status(409).json({ message: error.message });
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            const target = (error.meta?.target as string[])?.join(', ');
            console.error(`[REG CTRL] Registration failed: Unique constraint DB error on ${target}.`);
            return res.status(409).json({ message: `Error de unicidad en ${target}` });
        }
        console.error('[REG CTRL] Error during customer registration:', error);
        res.status(500).json({ message: 'Error del servidor durante el registro.' });
    }
};


// SIN ANOTACI√ìN @openapi
export const registerBusinessHandler = async (req: Request, res: Response) => {
    const { businessName, adminEmail, adminPassword, adminName }: RegisterBusinessDto = req.body;
    console.log(`[REG CTRL] Attempting business registration for: ${businessName} / ${adminEmail}`);

    if (!businessName || !adminEmail || !adminPassword) {
        return res.status(400).json({ message: 'Nombre del negocio, email del administrador y contrase√±a son requeridos.' });
    }
    if (businessName.trim().length < 2) {
        return res.status(400).json({ message: 'El nombre del negocio debe tener al menos 2 caracteres.' });
    }
    if (adminPassword.length < 6) {
        return res.status(400).json({ message: 'La contrase√±a debe tener al menos 6 caracteres.' });
    }

    try {
        const newAdminUser = await createBusinessAndAdmin({
            businessName: businessName.trim(),
            adminEmail,
            adminPassword,
            adminName: adminName?.trim()
        });
        const token = generateToken(newAdminUser as User);

        console.log(`[REG CTRL] Business registration successful for ${newAdminUser.email}. Sending 201.`);
        res.status(201).json({
            user: newAdminUser,
            token: token
        });
    } catch (error: any) {
        console.error('[REG CTRL] Error during business registration:', error);
        if (error instanceof Error) {
             if (error.message.includes('El email proporcionado ya est√° registrado') ||
                 error.message.includes('Ya existe un negocio con un nombre similar')) {
                 return res.status(409).json({ message: error.message });
             }
              if (error.message.includes('nombre del negocio') || error.message.includes('Error de base de datos')) {
                   return res.status(400).json({ message: error.message });
              }
        }
        res.status(500).json({ message: error.message || 'Error del servidor durante el registro del negocio.' });
    }
};

// End of File: backend/src/auth/registration.controller.ts


// ====== [36] backend/src/shared/auth/registration.service.ts ======
// backend/src/shared/auth/registration.service.ts (CORREGIDO)
import { PrismaClient, User, UserRole, DocumentType, Prisma, Business } from '@prisma/client';
import { RegisterUserDto, RegisterBusinessDto } from './auth.dto';
import { hashPassword, findUserByEmail } from './auth.service';

// --- RUTA CORREGIDA ---
import { updateUserTier } from '../../modules/loyalpyme/tiers/tier-logic.service';
// --- FIN RUTA CORREGIDA ---

const prisma = new PrismaClient();

export const createUser = async (userData: RegisterUserDto): Promise<User> => {
    console.log(`[REG SVC] Creating CUSTOMER user: ${userData.email}`);
    const businessExists = await prisma.business.findUnique({ where: { id: userData.businessId } });
    if (!businessExists) {
        throw new Error(`Business with ID ${userData.businessId} not found.`);
    }
    if (userData.phone) {
        const existingPhone = await prisma.user.findUnique({ where: { phone: userData.phone }, select: { id: true } });
        if (existingPhone) throw new Error('El tel√©fono ya est√° registrado.');
    } else {
        throw new Error('El tel√©fono es un campo obligatorio para clientes.');
    }
    if (userData.documentId) {
        const existingDocument = await prisma.user.findUnique({ where: { documentId: userData.documentId }, select: { id: true } });
        if (existingDocument) throw new Error('El documento de identidad ya est√° registrado.');
    } else {
        throw new Error('El documento de identidad es un campo obligatorio para clientes.');
    }
    console.log(`[REG SVC] Uniqueness checks passed for ${userData.email}. Hashing password...`);

    const hashedPassword = await hashPassword(userData.password);
    let newUser: User | null = null;

    try {
        newUser = await prisma.user.create({
            data: {
                email: userData.email,
                password: hashedPassword,
                name: userData.name,
                phone: userData.phone,
                documentId: userData.documentId,
                documentType: userData.documentType,
                role: UserRole.CUSTOMER_FINAL,
                business: {
                    connect: { id: userData.businessId }
                }
            },
        });
        console.log(`[REG SVC] Customer user created successfully with ID: ${newUser.id}`);

        try {
             console.log(`[REG SVC] Attempting initial tier assignment for new user: ${newUser.id}`);
             await updateUserTier(newUser.id);
             console.log(`[REG SVC] Initial tier assignment process completed for user: ${newUser.id}`);
        } catch (tierError: any) {
            console.error(`[REG SVC] WARNING: Failed to assign initial tier for user ${newUser.id}. Tier can be updated later. Error:`, tierError);
        }

        return newUser;

    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            const target = (error.meta?.target as string[])?.join(', ');
            console.error(`[REG SVC] Customer creation failed: Unique constraint DB error on ${target}.`);
            if (target?.includes('email')) throw new Error('El email ya est√° registrado.');
            if (target?.includes('phone')) throw new Error('El tel√©fono ya est√° registrado.');
            if (target?.includes('documentId')) throw new Error('El documento de identidad ya est√° registrado.');
            throw new Error(`Conflicto de unicidad en ${target}.`);
        }
        console.error(`[REG SVC] Unexpected error creating customer ${userData.email}:`, error);
        throw new Error('Error inesperado al crear el usuario cliente.');
    }
};

const generateSlug = (name: string): string => {
    return name
        .toLowerCase()
        .trim()
        .replace(/[^\w\s-]/g, '')
        .replace(/[\s_-]+/g, '-')
        .replace(/^-+|-+$/g, '');
};

export const createBusinessAndAdmin = async (
    data: RegisterBusinessDto
): Promise<Omit<User, 'password'>> => {
    console.log('[REG SVC] Attempting to create business and admin:', data.businessName, data.adminEmail);

    const existingUser = await findUserByEmail(data.adminEmail);
    if (existingUser) {
        console.warn(`[REG SVC] Admin email ${data.adminEmail} already exists.`);
        throw new Error('El email proporcionado ya est√° registrado.');
    }

    const slug = generateSlug(data.businessName);
    if (!slug) {
        console.error(`[REG SVC] Could not generate slug from business name: ${data.businessName}`);
        throw new Error('El nombre del negocio proporcionado no es v√°lido para generar un identificador.');
    }
    const existingBusiness = await prisma.business.findUnique({
        where: { slug: slug },
        select: { id: true }
    });
    if (existingBusiness) {
        console.warn(`[REG SVC] Business slug ${slug} already exists.`);
        throw new Error(`Ya existe un negocio con un nombre similar ('${slug}'). Por favor, elige otro nombre.`);
    }

    const hashedPassword = await hashPassword(data.adminPassword);

    try {
        console.log(`[REG SVC] Starting transaction to create business '${data.businessName}' (slug: ${slug}) and admin '${data.adminEmail}'`);
        const newUser = await prisma.$transaction(async (tx) => {
            const newBusiness = await tx.business.create({
                data: {
                    name: data.businessName,
                    slug: slug,
                },
                select: { id: true }
            });
            console.log(`[REG SVC - TX] Business created with ID: ${newBusiness.id}`);

            const adminUser = await tx.user.create({
                data: {
                    email: data.adminEmail,
                    password: hashedPassword,
                    name: data.adminName,
                    role: UserRole.BUSINESS_ADMIN,
                    businessId: newBusiness.id,
                }
            });
            console.log(`[REG SVC - TX] Admin user created with ID: ${adminUser.id} for business ${newBusiness.id}`);
            return adminUser;
        });

        const { password, ...userWithoutPassword } = newUser;
        console.log(`[REG SVC] Business and admin creation successful for ${data.adminEmail}.`);
        return userWithoutPassword;

    } catch (error) {
        console.error('[REG SVC] Error during business/admin creation transaction:', error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             const target = (error.meta?.target as string[])?.join(', ');
             console.error(`[REG SVC] Unique constraint failed on: ${target}`);
             throw new Error(`Error de base de datos: Conflicto de unicidad en ${target}.`);
        }
        throw new Error('No se pudo completar el registro del negocio. Error interno del servidor.');
    }
};


// ====== [37] backend/src/shared/businesses/businesses.controller.ts ======
// filename: backend/src/businesses/businesses.controller.ts
// Version: 1.0.0

import { Request, Response, NextFunction } from 'express';
// Importamos la funci√≥n del servicio que acabamos de crear
import { findPublicBusinesses, PublicBusinessInfo } from './businesses.service'; // Usamos ruta relativa './'

/**
 * Handler para obtener la lista p√∫blica de negocios (ID y Nombre).
 * GET /api/businesses/public-list (o la ruta que definamos)
 * No requiere autenticaci√≥n.
 */
export const handleGetPublicBusinesses = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  console.log('[BusinessController] Solicitud de lista p√∫blica de negocios...');

  try {
    // Llamamos a la funci√≥n del servicio para obtener los datos
    const businesses: PublicBusinessInfo[] = await findPublicBusinesses();

    // Enviamos la respuesta exitosa con la lista de negocios
    res.status(200).json(businesses);
    console.log('[BusinessController] Lista p√∫blica de negocios enviada.');

  } catch (error) {
    // Si el servicio lanza un error, lo pasamos al manejador de errores global
    console.error('[BusinessController] Error al obtener lista p√∫blica de negocios:', error);
    next(error);
  }
};

// Aqu√≠ podr√≠an ir otros handlers del controlador relacionados con Business en el futuro
// (ej: getBusinessDetails, updateBusinessSettings - que s√≠ requerir√≠an autenticaci√≥n/rol)

// End of file: backend/src/businesses/businesses.controller.ts


// ====== [38] backend/src/shared/businesses/businesses.service.ts ======
// filename: backend/src/businesses/businesses.service.ts
// Version: 1.0.2 (Remove obsolete comments)

import { PrismaClient, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Define la estructura de datos devuelta para la lista p√∫blica de negocios.
 */
export interface PublicBusinessInfo {
  id: string;
  name: string;
}

/**
 * Busca y devuelve una lista de negocios (solo ID y Nombre) para mostrar p√∫blicamente.
 * Por ahora, devuelve todos los negocios ordenados por nombre.
 * En el futuro, se podr√≠a filtrar por negocios activos o verificados si fuera necesario.
 *
 * @returns Una promesa que resuelve con un array de objetos PublicBusinessInfo.
 * @throws Error si ocurre un problema al consultar la base de datos.
 */
export const findPublicBusinesses = async (): Promise<PublicBusinessInfo[]> => {
  console.log('[BusinessService] Buscando lista p√∫blica de negocios...');
  try {
    const businesses = await prisma.business.findMany({
      select: {
        id: true,
        name: true,
      },
      orderBy: {
        name: 'asc',
      },
    });
    console.log(`[BusinessService] Encontrados ${businesses.length} negocios.`);
    return businesses;
  } catch (error) {
    console.error('[BusinessService] Error al buscar negocios p√∫blicos:', error);
    throw new Error('No se pudo obtener la lista de negocios.');
  }
};

// End of file: backend/src/businesses/businesses.service.ts


// ====== [39] backend/src/shared/middleware/auth.middleware.ts ======
// backend/src/middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { PrismaClient, UserRole, Prisma, User } from '@prisma/client'; // User ya estaba importado

const prisma = new PrismaClient();
const JWT_SECRET = process.env.JWT_SECRET as string;

if (!JWT_SECRET) {
    console.error('FATAL ERROR: JWT_SECRET is not defined in auth.middleware.');
    // Considerar process.exit(1) en un escenario real si esto es cr√≠tico
}

// Definici√≥n de req.user (Aseg√∫rate de que este tipo global ya incluya los nuevos campos o aj√∫stalo)
// Esta declaraci√≥n ya estaba en tu archivo original, la adaptamos.
declare global {
    namespace Express {
        interface Request {
            user?: {
                id: string;
                email: string;
                role: UserRole;
                businessId: string | null;
                isActive: boolean;
                name?: string | null;
                points?: number;
                totalSpend?: number;
                totalVisits?: number;
                currentTier?: { id: string; name: string; benefits: any[]; } | null; // 'any[]' para benefits es gen√©rico, considera tiparlo mejor si es posible
                
                // Flags del negocio
                businessIsActive?: boolean;
                isLoyaltyCoreActive?: boolean;
                isCamareroActive?: boolean;

                // --- NUEVOS CAMPOS PARA EL NEGOCIO ---
                businessName?: string | null;
                businessSlug?: string | null;
                businessLogoUrl?: string | null;
                // --- FIN NUEVOS CAMPOS ---
            };
        }
    }
}

export const authenticateToken = async (req: Request, res: Response, next: NextFunction) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (token == null) {
        console.log('[AUTH MIDDLEWARE] No token provided. Sending 401.');
        return res.sendStatus(401);
    }

    jwt.verify(token, JWT_SECRET, async (err: any, payload: any) => {
        if (err || !payload || !payload.userId || !payload.role) {
            console.error('[AUTH MIDDLEWARE] JWT verification failed or invalid payload:', { err, payload_userId: payload?.userId, payload_role: payload?.role });
            return res.sendStatus(403); // Token inv√°lido o corrupto
        }
        // console.log('[AUTH MIDDLEWARE DEBUG] JWT Payload OK:', payload);

        try {
            // Define el tipo de selecci√≥n para Prisma, incluyendo campos del negocio
            const userProfileSelect: Prisma.UserSelect = {
                id: true,
                email: true,
                role: true,
                businessId: true, // Necesario para la l√≥gica de negocio y para obtener los detalles del negocio
                isActive: true,
                name: true,
            };

            // Si el usuario tiene un businessId (es decir, no es SUPER_ADMIN que no tiene businessId directo)
            if (payload.businessId) {
                // console.log('[AUTH MIDDLEWARE DEBUG] Payload has businessId, selecting business data...');
                userProfileSelect.business = { // Seleccionar la relaci√≥n 'business'
                    select: {
                        isActive: true,
                        isLoyaltyCoreActive: true,
                        isCamareroActive: true,
                        name: true,         // <--- A√ëADIDO
                        slug: true,         // <--- A√ëADIDO
                        logoUrl: true,      // <--- A√ëADIDO (Opcional, pero √∫til para el header)
                    }
                };
            }

            // Si el rol es CUSTOMER_FINAL y tiene businessId (para asegurar que no se intente para SUPER_ADMIN)
            if (payload.role === UserRole.CUSTOMER_FINAL && payload.businessId) {
                // console.log('[AUTH MIDDLEWARE DEBUG] Role is CUSTOMER_FINAL, selecting LCo specific fields...');
                userProfileSelect.points = true;
                userProfileSelect.totalSpend = true;
                userProfileSelect.totalVisits = true;
                userProfileSelect.currentTier = {
                    select: {
                        id: true,
                        name: true,
                        benefits: { // Considerar si realmente se necesitan todos los beneficios aqu√≠
                            where: { isActive: true },
                            select: { id: true, type: true, value: true, description: true }
                        }
                    }
                };
            } else if (payload.role !== UserRole.SUPER_ADMIN && !payload.businessId) {
                 // Esto es un caso an√≥malo: un rol que no es SUPER_ADMIN deber√≠a tener un businessId.
                 console.error(`[AUTH MIDDLEWARE] User role ${payload.role} requires a businessId, but none found for user ${payload.userId}. Denying access.`);
                 return res.sendStatus(403); // Prohibido
            }
            // console.log('[AUTH MIDDLEWARE DEBUG] Prisma User Select Query:', JSON.stringify(userProfileSelect, null, 2));

            const userFromDb = await prisma.user.findUnique({
                where: { id: payload.userId },
                select: userProfileSelect
            });
            // console.log('[AUTH MIDDLEWARE DEBUG] User fetched from DB:', JSON.stringify(userFromDb, null, 2));

            if (!userFromDb || !userFromDb.isActive) {
                console.log(`[AUTH MIDDLEWARE] User ${payload.userId} not found or not active in DB. Sending 403.`);
                return res.sendStatus(403); // Usuario no encontrado o inactivo
            }

            // Extraer datos del negocio si existen en el usuario cargado
            // @ts-ignore Prisma genera el tipo `business` en `userFromDb` si se incluy√≥ en el select
            const businessDataFromDb = userFromDb.business;
            // console.log('[AUTH MIDDLEWARE DEBUG] Business data from DB relation:', JSON.stringify(businessDataFromDb, null, 2));


            // Si el usuario no es SUPER_ADMIN y su negocio asociado NO est√° activo, denegar acceso
            if (userFromDb.role !== UserRole.SUPER_ADMIN && businessDataFromDb && !businessDataFromDb.isActive) {
                console.log(`[AUTH MIDDLEWARE] Business ${userFromDb.businessId} for user ${userFromDb.id} is not active. Denying access.`);
                return res.sendStatus(403); // Negocio inactivo
            }
            
            // Construir el objeto req.user
            const reqUserObject: Express.Request['user'] = {
                id: userFromDb.id,
                email: userFromDb.email,
                role: userFromDb.role,
                businessId: userFromDb.businessId,
                isActive: userFromDb.isActive,
                name: userFromDb.name,
            };

            // A√±adir campos espec√≠ficos de LCo si es CUSTOMER_FINAL
            if (userFromDb.role === UserRole.CUSTOMER_FINAL) {
                // @ts-ignore
                reqUserObject.points = userFromDb.points;
                // @ts-ignore
                reqUserObject.totalSpend = userFromDb.totalSpend;
                // @ts-ignore
                reqUserObject.totalVisits = userFromDb.totalVisits;
                // @ts-ignore
                reqUserObject.currentTier = userFromDb.currentTier ?? null;
            }

            // A√±adir flags y detalles del negocio si existen
            if (businessDataFromDb) {
                reqUserObject.businessIsActive = businessDataFromDb.isActive;
                reqUserObject.isLoyaltyCoreActive = businessDataFromDb.isLoyaltyCoreActive;
                reqUserObject.isCamareroActive = businessDataFromDb.isCamareroActive;
                reqUserObject.businessName = businessDataFromDb.name;           // <--- A√ëADIDO
                reqUserObject.businessSlug = businessDataFromDb.slug;           // <--- A√ëADIDO
                reqUserObject.businessLogoUrl = businessDataFromDb.logoUrl;     // <--- A√ëADIDO
            } else if (userFromDb.role !== UserRole.SUPER_ADMIN && payload.businessId) {
                // Caso borde: El token ten√≠a businessId, pero no se pudo cargar la info del negocio.
                // Esto podr√≠a indicar un problema de datos (ej. negocio borrado pero usuario a√∫n lo referencia).
                // Por seguridad, podr√≠amos denegar o loguear y continuar con flags undefined/null.
                console.warn(`[AUTH MIDDLEWARE] Business data for businessId ${payload.businessId} was expected but not found for user ${userFromDb.id}. Module flags and business details will be undefined.`);
            }
            
            req.user = reqUserObject; // Asignar el objeto construido a req.user
            
            // console.log('[AUTH MIDDLEWARE DEBUG] Final req.user object being set:', JSON.stringify(req.user, null, 2));
            console.log(`[AUTH MIDDLEWARE] User ${req.user.id} (Role: ${req.user.role}, BizId: ${req.user.businessId || 'N/A'}, BizSlug: ${req.user.businessSlug || 'N/A'}) authenticated.`);

            next();
        } catch (dbError) {
            console.error('[AUTH MIDDLEWARE] Database error during user/business fetch:', dbError);
            delete req.user; // Limpiar req.user en caso de error
            res.status(500).json({ message: 'Server error during authentication process.' });
        }
    });
};


// ====== [40] backend/src/shared/middleware/module.middleware.ts ======
// backend/src/middleware/module.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Definimos los c√≥digos de m√≥dulo que usaremos.
// Podr√≠as expandir esto o usar un Enum de Prisma si los m√≥dulos se vuelven m√°s complejos.
export type ModuleCode = 'LOYALTY_CORE' | 'CAMARERO';

/**
 * Middleware factory para verificar si un m√≥dulo espec√≠fico est√° activo para el negocio
 * del usuario autenticado.
 *
 * @param moduleCode El c√≥digo del m√≥dulo a verificar.
 * @returns Una funci√≥n middleware de Express.
 */
export const checkModuleActive = (moduleCode: ModuleCode) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    // Asumimos que authenticateToken ya se ejecut√≥ y req.user y req.user.businessId existen.
    // El rol ya deber√≠a haber sido verificado por checkRole si es necesario para la ruta.
    if (!req.user || !req.user.businessId) {
      console.warn('[ModuleMiddleware] User or businessId missing from request. Is authenticateToken running first?');
      return res.status(403).json({ message: 'Acceso denegado. No se pudo identificar el negocio para la verificaci√≥n del m√≥dulo.' });
    }

    const businessId = req.user.businessId;

    try {
      const business = await prisma.business.findUnique({
        where: { id: businessId },
        select: {
          isLoyaltyCoreActive: true,
          isCamareroActive: true,
          // Podr√≠amos seleccionar tambi√©n business.isActive aqu√≠ si quisi√©ramos
          // que un m√≥dulo no funcione si el negocio entero est√° inactivo,
          // pero eso se puede manejar en checkRole o un middleware de estado de negocio.
        }
      });

      if (!business) {
        // Esto ser√≠a raro si el token es v√°lido y tiene un businessId.
        console.warn(`[ModuleMiddleware] Business with ID ${businessId} not found during module check.`);
        return res.status(404).json({ message: 'Negocio asociado no encontrado.' });
      }

      let moduleIsCurrentlyActive = false;
      if (moduleCode === 'LOYALTY_CORE') {
        moduleIsCurrentlyActive = business.isLoyaltyCoreActive;
      } else if (moduleCode === 'CAMARERO') {
        moduleIsCurrentlyActive = business.isCamareroActive;
      } else {
        // C√≥digo de m√≥dulo desconocido, por seguridad denegar.
        console.error(`[ModuleMiddleware] Unknown moduleCode specified: ${moduleCode}`);
        return res.status(500).json({ message: 'Error interno: C√≥digo de m√≥dulo no reconocido.' });
      }

      if (moduleIsCurrentlyActive) {
        next(); // El m√≥dulo est√° activo, continuar.
      } else {
        console.log(`[ModuleMiddleware] Access denied. Module '${moduleCode}' is not active for business ${businessId}.`);
        return res.status(403).json({ message: `Acceso denegado. El m√≥dulo ${moduleCode} no est√° activo para este negocio.` });
      }
    } catch (error) {
      console.error(`[ModuleMiddleware] Error checking module '${moduleCode}' for business ${businessId}:`, error);
      return res.status(500).json({ message: 'Error interno al verificar el estado del m√≥dulo.' });
    }
  };
};


// ====== [41] backend/src/shared/middleware/multer.config.ts ======
// filename: backend/src/middleware/multer.config.ts
// Version: 1.0.0 (Initial Multer configuration for image uploads)

import multer, { FileFilterCallback } from 'multer';
import { Request } from 'express';

// Tipos de archivo permitidos (MIME types)
const ALLOWED_MIMETYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
// L√≠mite de tama√±o (ej. 5MB)
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5 MB in bytes

// Configuraci√≥n de almacenamiento en memoria
const storage = multer.memoryStorage();

// Funci√≥n de filtro de archivos
const fileFilter = (
    req: Request,
    file: Express.Multer.File,
    cb: FileFilterCallback
) => {
    console.log(`[Multer Filter] Checking file: ${file.originalname}, MIME type: ${file.mimetype}`);
    if (ALLOWED_MIMETYPES.includes(file.mimetype)) {
        // Aceptar el archivo
        console.log(`[Multer Filter] File type ${file.mimetype} accepted.`);
        cb(null, true);
    } else {
        // Rechazar el archivo
        console.warn(`[Multer Filter] File type ${file.mimetype} rejected.`);
        // Pasamos un error para que pueda ser manejado por el controlador/manejador de errores
        cb(new Error('Tipo de archivo no permitido. Solo se aceptan im√°genes (jpeg, png, webp, gif).'));
        // Alternativa: cb(null, false); // Simplemente rechaza sin error expl√≠cito
    }
};

// Crear la instancia de Multer configurada
const upload = multer({
    storage: storage,
    fileFilter: fileFilter,
    limits: {
        fileSize: MAX_FILE_SIZE, // L√≠mite de 5MB
    },
});

// Exportar la instancia configurada (espec√≠ficamente para manejar un solo archivo llamado 'image')
// Usaremos upload.single('imageField') en la ruta. El nombre 'imageField' debe coincidir
// con el nombre del campo que env√≠a el frontend en el FormData.
// Exportamos la instancia base para usarla en la ruta.
export default upload;

// End of File: backend/src/middleware/multer.config.ts


// ====== [42] backend/src/shared/middleware/role.middleware.ts ======
// filename: backend/src/middleware/role.middleware.ts
// Version: 1.0.1 (Remove verbose log and inline comments)

import { Request, Response, NextFunction } from 'express';
import { UserRole } from '@prisma/client';

/**
 * Middleware factory para verificar si el rol del usuario autenticado
 * est√° incluido en la lista de roles permitidos.
 *
 * @param allowedRoles Un array de UserRole permitidos para la ruta.
 * @returns Una funci√≥n middleware de Express.
 */
export const checkRole = (allowedRoles: UserRole[]) => {
    return (req: Request, res: Response, next: NextFunction) => {
        // Verifica que authenticateToken haya adjuntado un usuario con rol
        if (!req.user || !req.user.role) {
            console.warn('[Role Middleware] User or user role not found on request. Is authenticateToken running first?');
            return res.status(403).json({ message: 'Acceso denegado: Autenticaci√≥n requerida o rol no disponible.' });
        }

        const userRole = req.user.role;
        // console.log(`[Role Middleware] Checking role: User has '${userRole}', Allowed: [${allowedRoles.join(', ')}] for route ${req.originalUrl}`); // Log eliminado por verbosidad

        // Comprueba si el rol est√° permitido
        if (allowedRoles.includes(userRole)) {
            next(); // Rol permitido, continuar
        } else {
            // Rol no permitido
            console.warn(`[Role Middleware] Access Forbidden for role '${userRole}' on route ${req.originalUrl}. Allowed: [${allowedRoles.join(', ')}]`);
            res.status(403).json({ message: 'Acceso denegado: Permisos insuficientes.' });
        }
    };
};

// End of File: backend/src/middleware/role.middleware.ts


// ====== [43] backend/src/shared/services/loyalty-points.service.ts ======
// backend/src/shared/services/loyalty-points.service.ts (CORREGIDO)
import {
    PrismaClient,
    Prisma,
    Order,
    User,
    Business,
    ActivityType,
    TierBenefit,
} from '@prisma/client';
import { Logger, InternalServerErrorException } from '@nestjs/common';
// --- RUTA CORREGIDA ---
import { updateUserTier } from '../../modules/loyalpyme/tiers/tier-logic.service';
// --- FIN RUTA CORREGIDA ---

type OrderForLoyalty = Pick<Order, 'id' | 'orderNumber' | 'finalAmount' | 'totalAmount' | 'customerLCoId' | 'businessId'>;
type CustomerForLoyalty = User & {
    currentTier?: ({ benefits: Pick<TierBenefit, 'type' | 'value' | 'isActive'>[] } & { id: string; name: string }) | null;
};
type BusinessForLoyalty = Pick<Business, 'id' | 'pointsPerEuro' | 'isLoyaltyCoreActive'>;


export class LoyaltyPointsService {
    private readonly logger = new Logger(LoyaltyPointsService.name);

    async awardPointsForLcOrder(
        tx: Prisma.TransactionClient,
        order: OrderForLoyalty,
        customer: CustomerForLoyalty,
        business: BusinessForLoyalty
    ): Promise<{ pointsAwarded: number } | null> {
        if (!order.customerLCoId) {
            this.logger.warn(`[LoyaltyPointsService] Order ${order.id} has no customerLCoId. No points to award.`);
            return null;
        }
        if (!business.isLoyaltyCoreActive) {
            this.logger.log(`[LoyaltyPointsService] LoyaltyCore module is not active for business ${business.id}. Skipping points for order ${order.id}.`);
            return null;
        }
        if (customer.id !== order.customerLCoId) {
             this.logger.error(`[LoyaltyPointsService] Mismatch: Order customerLCoId ${order.customerLCoId} vs provided customer ID ${customer.id}. Aborting points.`);
             throw new InternalServerErrorException("Discrepancia en IDs de cliente al otorgar puntos.");
        }

        this.logger.log(`[LoyaltyPointsService TX] Processing LCo points for customer ${customer.id} (Order: ${order.id}, Business: ${business.id})`);

        const orderAmountForPoints = order.finalAmount ?? order.totalAmount;
        let pointsToEarnDecimal = new Prisma.Decimal(orderAmountForPoints).mul(business.pointsPerEuro ?? 1);

        const multiplierBenefit = customer.currentTier?.benefits.find(
            b => b.type === 'POINTS_MULTIPLIER' && b.isActive
        );

        if (multiplierBenefit?.value) {
            const multiplier = parseFloat(multiplierBenefit.value);
            if (!isNaN(multiplier) && multiplier > 0) {
                pointsToEarnDecimal = pointsToEarnDecimal.mul(multiplier);
                this.logger.log(`[LoyaltyPointsService TX] Applied tier '${customer.currentTier?.name}' multiplier ${multiplier} for LCo points.`);
            } else {
                this.logger.warn(`[LoyaltyPointsService TX] Invalid LCo tier multiplier value '${multiplierBenefit.value}' for user ${customer.id} on tier '${customer.currentTier?.name}'.`);
            }
        }

        const finalPointsToAward = Math.floor(pointsToEarnDecimal.toNumber());

        if (finalPointsToAward <= 0) {
            this.logger.log(`[LoyaltyPointsService TX] No LCo points to award (calculated ${finalPointsToAward}) for customer ${customer.id} on order ${order.id}.`);
            return { pointsAwarded: 0 };
        }

        try {
            await tx.user.update({
                where: { id: customer.id },
                data: {
                    points: { increment: finalPointsToAward },
                    totalSpend: { increment: orderAmountForPoints.toNumber() },
                    totalVisits: { increment: 1 },
                    lastActivityAt: new Date(),
                },
            });
            this.logger.log(`[LoyaltyPointsService TX] Customer ${customer.id} updated: +${finalPointsToAward} points, +${orderAmountForPoints} spend, +1 visit.`);

            await tx.activityLog.create({
                data: {
                    userId: customer.id,
                    businessId: business.id,
                    type: ActivityType.POINTS_EARNED_ORDER_LC,
                    pointsChanged: finalPointsToAward,
                    description: `Puntos por pedido LC #${order.orderNumber}`,
                    relatedOrderId: order.id,
                },
            });
            this.logger.log(`[LoyaltyPointsService TX] ActivityLog created for order ${order.id}, user ${customer.id}.`);

            updateUserTier(customer.id).catch((tierError: any) => {
                this.logger.error(`[LoyaltyPointsService] Background tier update failed for customer ${customer.id} after LC order points:`, tierError);
            });
            this.logger.log(`[LoyaltyPointsService] Tier update process initiated for customer ${customer.id}.`);

            return { pointsAwarded: finalPointsToAward };

        } catch (error) {
            this.logger.error(`[LoyaltyPointsService TX] Error during points awarding transaction for order ${order.id}, customer ${customer.id}:`, error);
            return null;
        }
    }
}


// ====== [44] backend/src/shared/services/table.service.ts ======
// backend/src/services/table.service.ts (o backend/src/camarero/table.service.ts si prefieres)
import {
    PrismaClient,
    Prisma,
    Table,
    TableStatus,
} from '@prisma/client';
import {
    Logger,
    NotFoundException,
    InternalServerErrorException,
} from '@nestjs/common';

export class TableService {
    private readonly logger = new Logger(TableService.name);

    /**
     * Encuentra una mesa por su identificador y el ID del negocio.
     *
     * @param tx - Cliente Prisma de la transacci√≥n actual.
     * @param businessId - ID del negocio.
     * @param tableIdentifier - Identificador de la mesa (ej. "M1", "T2").
     * @returns El objeto Table si se encuentra, o null si no.
     */
    async findTableByIdentifier(
        tx: Prisma.TransactionClient,
        businessId: string,
        tableIdentifier: string
    ): Promise<Table | null> {
        this.logger.log(`[TableService] Finding table with identifier '${tableIdentifier}' for business '${businessId}'.`);
        try {
            const table = await tx.table.findUnique({
                where: {
                    businessId_identifier: {
                        businessId: businessId,
                        identifier: tableIdentifier,
                    },
                },
            });
            if (table) {
                this.logger.log(`[TableService] Table '${tableIdentifier}' found with ID '${table.id}'.`);
            } else {
                this.logger.warn(`[TableService] Table '${tableIdentifier}' not found for business '${businessId}'.`);
            }
            return table;
        } catch (error) {
            this.logger.error(`[TableService] Error finding table '${tableIdentifier}':`, error);
            throw new InternalServerErrorException('Error al buscar la mesa en la base de datos.');
        }
    }

    /**
     * Actualiza el estado de una mesa espec√≠fica.
     *
     * @param tx - Cliente Prisma de la transacci√≥n actual.
     * @param tableId - ID de la mesa a actualizar.
     * @param newStatus - El nuevo TableStatus para la mesa.
     * @returns El objeto Table actualizado.
     * @throws NotFoundException si la mesa no existe.
     */
    async updateTableStatus(
        tx: Prisma.TransactionClient,
        tableId: string,
        newStatus: TableStatus
    ): Promise<Table> {
        this.logger.log(`[TableService] Updating status of table '${tableId}' to '${newStatus}'.`);
        try {
            // Primero, verificar si la mesa existe para dar un error m√°s claro si no.
            // Esto podr√≠a ser redundante si la operaci√≥n que llama ya verific√≥, pero es una salvaguarda.
            const existingTable = await tx.table.findUnique({ where: { id: tableId }, select: { id: true } });
            if (!existingTable) {
                this.logger.warn(`[TableService] Table with ID '${tableId}' not found for status update.`);
                throw new NotFoundException(`Mesa con ID '${tableId}' no encontrada.`);
            }

            const updatedTable = await tx.table.update({
                where: { id: tableId },
                data: { status: newStatus },
            });
            this.logger.log(`[TableService] Table '${tableId}' status successfully updated to '${newStatus}'.`);
            return updatedTable;
        } catch (error) {
            if (error instanceof NotFoundException) throw error; // Relanzar si es nuestro error espec√≠fico
            
            this.logger.error(`[TableService] Error updating status for table '${tableId}':`, error);
            if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
                // P2025 = "An operation failed because it depends on one or more records that were required but not found."
                // (Registro para actualizar no encontrado)
                throw new NotFoundException(`Mesa con ID '${tableId}' no encontrada al intentar actualizar estado.`);
            }
            throw new InternalServerErrorException('Error al actualizar el estado de la mesa.');
        }
    }

    // --- Podr√≠as a√±adir m√°s m√©todos aqu√≠ si son necesarios, como: ---
    // async getTableById(tx: Prisma.TransactionClient, tableId: string): Promise<Table | null> { ... }
    // async createTable(tx: Prisma.TransactionClient, businessId: string, data: Prisma.TableCreateWithoutBusinessInput): Promise<Table> { ... }
    // etc.
}


// ====== [45] backend/src/shared/uploads/uploads.controller.ts ======
// filename: backend/src/uploads/uploads.controller.ts
// Version: 1.0.1 (Correct service import path)

import { Request, Response, NextFunction } from 'express';
// --- MODIFICADO: Importar desde 'uploads.service' (plural) ---
import { uploadImageToCloudinary } from './uploads.service';
// --- FIN MODIFICADO ---

/**
 * Maneja la subida de una imagen (generalmente para recompensas).
 * Espera que el middleware Multer (upload.single('image')) se haya ejecutado antes.
 */
export const handleImageUpload = async (req: Request, res: Response, next: NextFunction) => {
    console.log('[Upload CTRL] Received image upload request.');

    // Multer a√±ade 'file' a la request
    if (!req.file) {
        console.error('[Upload CTRL] No file found in req.file. Check field name in client and Multer config.');
        // El campo en Multer y en RewardForm debe ser 'image' seg√∫n c√≥digo anterior
        return res.status(400).json({ message: 'No se recibi√≥ ning√∫n archivo de imagen o el campo no es "image".' });
    }

    if (!req.file.buffer) {
        console.error('[Upload CTRL] File buffer is missing.');
        return res.status(500).json({ message: 'Error interno al procesar el archivo.' });
    }

    // Carpeta en Cloudinary
    const folderName = `loyalpyme/rewards_${process.env.NODE_ENV || 'development'}`;

    try {
        console.log(`[Upload CTRL] Uploading file ${req.file.originalname} (${(req.file.size / 1024).toFixed(1)} KB) to Cloudinary folder '${folderName}'...`);
        const imageUrl = await uploadImageToCloudinary(req.file.buffer, folderName);

        console.log(`[Upload CTRL] Image uploaded successfully. URL: ${imageUrl}`);
        // Devolver la URL (ajustado a como lo espera el form v2.1.0)
        res.status(200).json({
            // message: 'Imagen subida correctamente.', // El form no espera message
            url: imageUrl // El form espera 'url'
        });

    } catch (error) {
        console.error('[Upload CTRL] Error during image upload process:', error);
        next(error); // Pasar al manejador global
    }
};

// End of File: backend/src/uploads/uploads.controller.ts


// ====== [46] backend/src/shared/uploads/uploads.service.ts ======
// filename: backend/src/uploads/upload.service.ts
// Version: 1.0.0 (CORRECTED - Standard Cloudinary upload service with folder)

import cloudinary from '../utils/cloudinary.config'; // Importa config est√°ndar (lee .env)
import streamifier from 'streamifier';
import { UploadApiResponse, UploadApiErrorResponse } from 'cloudinary';

// --- ASEG√öRATE DE QUE LA FIRMA DE LA FUNCI√ìN EST√â AS√ç ---
export const uploadImageToCloudinary = (
    fileBuffer: Buffer,      // <-- Par√°metro para el buffer
    folderName: string       // <-- Par√°metro para la carpeta
): Promise<string> => {
// --- FIN FIRMA ---

    return new Promise((resolve, reject) => {
        // Usamos folderName en el log
        console.log(`[Upload SVC] Attempting to upload image buffer to Cloudinary folder: ${folderName}`);

        const uploadStream = cloudinary.uploader.upload_stream(
            {
                folder: folderName, // <-- Usamos el par√°metro folderName
                resource_type: 'image',
            },
            (error: UploadApiErrorResponse | undefined, result: UploadApiResponse | undefined) => {
                if (error) {
                    console.error('[Upload SVC] Cloudinary upload failed:', error);
                    // Usar un mensaje gen√©rico o el espec√≠fico de Cloudinary
                    reject(new Error(`Error al subir imagen a Cloudinary: ${error.message}`));
                } else if (result) {
                    console.log(`[Upload SVC] Cloudinary upload successful! Secure URL: ${result.secure_url}`);
                    resolve(result.secure_url); // Devuelve la URL segura
                } else {
                    // Caso improbable
                    console.error('[Upload SVC] Cloudinary upload stream finished without error or result.');
                    reject(new Error('La subida a Cloudinary finaliz√≥ sin resultado ni error.'));
                }
            }
        );
        // Usamos fileBuffer para crear el stream de lectura
        streamifier.createReadStream(fileBuffer).pipe(uploadStream);
    });
}; // <-- Aseg√∫rate que la llave de cierre de la funci√≥n est√°

// End of File: backend/src/uploads/upload.service.ts


// ====== [47] backend/src/shared/utils/cloudinary.config.ts ======
// filename: backend/src/utils/cloudinary.config.ts
// Version: 1.0.0 (Standard - Using process.env)
import { v2 as cloudinary } from 'cloudinary';
import dotenv from 'dotenv';
dotenv.config();
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;
if (!cloudName || !apiKey || !apiSecret) {
  console.error("ERROR: Cloudinary environment variables are missing!"); // ... resto del mensaje de error ...
} else {
   console.log("[Cloudinary Config] Credentials found from .env, configuring Cloudinary SDK...");
   cloudinary.config({ cloud_name: cloudName, api_key: apiKey, api_secret: apiSecret, secure: true });
   console.log("[Cloudinary Config] Cloudinary SDK configured successfully from .env.");
}
export default cloudinary;


// ====== [48] backend/src/shared/utils/validation.ts ======
// filename: backend/src/utils/validation.ts
// Version: 1.0.1 (Fix character encoding)

// Contiene funciones de utilidad para validaciones comunes

/**
 * Valida si un string tiene formato de DNI espa√±ol v√°lido.
 * @param dni - El string a validar.
 * @returns true si es v√°lido, false en caso contrario.
 */
export function isValidDni(dni: string): boolean {
    if (!/^\d{8}[A-Z]$/i.test(dni)) {
        return false;
    }
    const numero = parseInt(dni.substring(0, 8), 10);
    const letra = dni.substring(8, 9).toUpperCase();
    const letrasControl = "TRWAGMYFPDXBNJZSQVHLCKE";
    const letraCalculada = letrasControl.charAt(numero % 23);
    return letra === letraCalculada;
}

/**
 * Valida si un string tiene formato de NIE espa√±ol v√°lido.
 * @param nie - El string a validar.
 * @returns true si es v√°lido, false en caso contrario.
 */
export function isValidNie(nie: string): boolean {
    if (!/^[XYZ]\d{7}[A-Z]$/i.test(nie)) {
        return false;
    }
    let numeroStr = nie.substring(1, 8);
    const letraInicial = nie.substring(0, 1).toUpperCase();
    // Reemplazar letra inicial por su equivalente num√©rico para el c√°lculo
    if (letraInicial === 'Y') numeroStr = '1' + numeroStr;
    if (letraInicial === 'Z') numeroStr = '2' + numeroStr;
    // Si es X, se trata como 0, lo cual ya est√° impl√≠cito al no a√±adir prefijo

    const numero = parseInt(numeroStr, 10);
    const letra = nie.substring(8, 9).toUpperCase();
    const letrasControl = "TRWAGMYFPDXBNJZSQVHLCKE";
    const letraCalculada = letrasControl.charAt(numero % 23);
    return letra === letraCalculada;
}

/**
 * Valida si un string tiene formato de n√∫mero de tel√©fono internacional b√°sico.
 * @param phone - El string a validar.
 * @returns true si es v√°lido, false en caso contrario.
 */
export function isValidPhoneNumber(phone: string): boolean {
    // Regex simple: empieza con +, seguido de 9 a 15 d√≠gitos.
    const phoneRegex = /^\+[0-9]{9,15}$/;
    return phoneRegex.test(phone);
}

// Aqu√≠ podr√≠an a√±adirse m√°s funciones de validaci√≥n comunes en el futuro

// End of File: backend/src/utils/validation.ts


// ====== [49] backend/tsconfig.json ======
{
  "compilerOptions": {
    "target": "es2022",
    "module": "commonjs",
    "rootDir": "./src",
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "experimentalDecorators": true, // <--- A√ëADIDO
    "emitDecoratorMetadata": true   // <--- A√ëADIDO
  },
  "include": [
    "src/**/*.ts"
  ]
}


// ====== [50] frontend/index.html ======
<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LoyalPyME</title>

    <style>
      body {
        margin: 0; /* Asegura que no haya m√°rgenes por defecto */
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; /* Fuente simple de sistema */
      }
      #initial-loader {
        position: fixed; /* Posici√≥n fija para cubrir todo */
        inset: 0; /* Equivalente a top: 0; right: 0; bottom: 0; left: 0; */
        background-color: #f8f9fa; /* Un fondo claro simple (ajusta si prefieres oscuro) */
        display: flex;
        flex-direction: column; /* Apila texto y spinner */
        align-items: center;
        justify-content: center;
        z-index: 9999; /* Asegura que est√© por encima de todo */
        color: #495057;
        transition: opacity 0.5s ease-out; /* Transici√≥n suave al ocultar */
      }
      #initial-loader .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border-left-color: #09f; /* Color del spinner (puedes usar tu azul Mantine) */
        margin-top: 20px;
        animation: spin 1s ease infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      /* Estilo opcional para ocultar cuando se a√±ade la clase 'hidden' */
       #initial-loader.hidden {
          opacity: 0;
          pointer-events: none; /* No interferir con clics */
       }
    </style>
    </head>
  <body>
    <div id="initial-loader">
      <p>Cargando LoyalPyME...</p>
      <div class="spinner"></div>
    </div>
    <div id="root"></div>

    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


// ====== [51] frontend/package.json ======
{
  "name": "frontend",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "license": "SEE LICENSE IN ../LICENSE.md",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@mantine/core": "^7.17.4",
    "@mantine/form": "^7.17.4",
    "@mantine/hooks": "^7.17.4",
    "@mantine/modals": "^7.17.5",
    "@mantine/notifications": "^7.17.4",
    "@tabler/icons-react": "^3.31.0",
    "axios": "^1.8.4",
    "html5-qrcode": "^2.3.8",
    "i18next": "^23.13.2",
    "i18next-browser-languagedetector": "^8.0.1",
    "i18next-http-backend": "^2.5.2",
    "qrcode.react": "^4.2.0",
    "react": "^19.0.0",
    "react-country-flag": "^3.1.0",
    "react-dom": "^19.0.0",
    "react-i18next": "^15.0.1",
    "react-image-crop": "^11.0.10",
    "react-router-dom": "^6.26.1",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@eslint/js": "^9.22.0",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.7.1",
    "@testing-library/react": "^16.0.0",
    "@testing-library/user-event": "^14.5.2",
    "@types/qrcode.react": "^1.0.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.22.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "jsdom": "^24.1.1",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.26.1",
    "vite": "^5.4.0",
    "vite-plugin-mkcert": "^1.17.8",
    "vitest": "^2.0.4"
  }
}


// ====== [52] frontend/src/modules/loyalpyme/components/AddRewardForm.tsx ======
// filename: frontend/src/components/AddRewardForm.tsx
// Version: 1.3.1 (Fix encoding, remove logs and meta-comments)

import { useState, useEffect, FormEvent } from 'react';
import axiosInstance from '../services/axiosInstance';

// Mantine Imports
import {
    TextInput, Textarea, NumberInput, Button, Stack, Group
} from '@mantine/core';
// Importar notifications y iconos
import { notifications } from '@mantine/notifications';
import { IconAlertCircle, IconCheck, IconX } from '@tabler/icons-react';


// Interfaz Reward (local)
interface Reward {
    id: string; name: string; description?: string | null; pointsCost: number; isActive: boolean;
}

// Props del componente
interface RewardFormProps {
    mode: 'add' | 'edit';
    initialData?: Reward | null;
    rewardIdToUpdate?: string | null;
    onSubmitSuccess: () => void; // Callback en caso de √©xito
    onCancel: () => void; // Callback para cancelar
}

// Componente renombrado a RewardForm consistentemente
const RewardForm: React.FC<RewardFormProps> = ({
    mode, initialData, rewardIdToUpdate, onSubmitSuccess, onCancel
}) => {

    // Estados
    const [name, setName] = useState<string>('');
    const [description, setDescription] = useState<string>('');
    const [pointsCost, setPointsCost] = useState<number | ''>('');
    const [isSubmitting, setIsSubmitting] = useState<boolean>(false);

    // Efecto para popular/resetear formulario
    useEffect(() => {
        if (mode === 'edit' && initialData) {
            setName(initialData.name || '');
            setDescription(initialData.description || '');
            setPointsCost(initialData.pointsCost !== null ? initialData.pointsCost : '');
        } else {
            // Resetear para modo 'add' o si no hay initialData
            setName(''); setDescription(''); setPointsCost('');
        }
    }, [mode, initialData]);

    const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
        event.preventDefault();

        // Validaci√≥n frontend
        if (!name.trim()) {
            notifications.show({
                title: 'Campo Obligatorio',
                message: 'El nombre de la recompensa no puede estar vac√≠o.',
                color: 'orange', icon: <IconAlertCircle size={18} />,
            });
            return;
        }
        if (pointsCost === '' || pointsCost < 0) {
            notifications.show({
                title: 'Campo Inv√°lido', // Corregido: Inv√°lido
                message: 'El coste en puntos debe ser un n√∫mero igual o mayor que cero.', // Corregido: n√∫mero
                color: 'orange', icon: <IconAlertCircle size={18} />,
            });
            return;
        }

        setIsSubmitting(true);

        const commonData = {
            name: name.trim(),
            description: description.trim() || null, // Enviar null si est√° vac√≠o
            pointsCost: Number(pointsCost), // Asegurar que es n√∫mero
        };

        try {
            let successMessage = '';
            if (mode === 'add') {
                // console.log('Submitting ADD request:', commonData); // Log eliminado
                await axiosInstance.post('/rewards', commonData);
                // console.log('Add successful'); // Log eliminado
                successMessage = `Recompensa "${commonData.name}" a√±adida con √©xito.`; // Corregido: √©xito, a√±adida
            } else { // mode === 'edit'
                if (!rewardIdToUpdate) throw new Error("Falta el ID de la recompensa para actualizar.");
                // console.log(`Submitting EDIT request for ${rewardIdToUpdate}:`, commonData); // Log eliminado
                await axiosInstance.patch(`/rewards/${rewardIdToUpdate}`, commonData);
                // console.log('Edit successful'); // Log eliminado
                successMessage = `Recompensa "${commonData.name}" actualizada con √©xito.`; // Corregido: √©xito
            }

            // Notificaci√≥n de √âxito
            notifications.show({
                title: '√âxito', // Corregido: √âxito
                message: successMessage,
                color: 'green', icon: <IconCheck size={18} />, autoClose: 4000,
            });

            onSubmitSuccess(); // Llama al callback del padre

        } catch (err: any) {
            console.error(`Error ${mode === 'add' ? 'adding' : 'updating'} reward:`, err); // Mantener error log
            const actionText = mode === 'add' ? 'a√±adir' : 'actualizar';
            const errorMessage = `Error al ${actionText} la recompensa: ${err.response?.data?.message || err.message || 'Error desconocido'}`;

            // Notificaci√≥n de Error
            notifications.show({
                title: 'Error', message: errorMessage, color: 'red',
                icon: <IconX size={18} />, autoClose: 6000,
            });
        } finally {
            setIsSubmitting(false);
        }
    };

    const submitButtonText = mode === 'add' ? 'A√±adir Recompensa' : 'Actualizar Recompensa';

    return (
        <form onSubmit={handleSubmit}>
            <Stack gap="md">
                <TextInput label="Nombre de la Recompensa:" placeholder="Ej: Caf√© Gratis" value={name} onChange={(e) => setName(e.currentTarget.value)} required disabled={isSubmitting} radius="lg" />
                <Textarea label="Descripci√≥n (Opcional):" placeholder="Ej: Un caf√© espresso o americano" value={description} onChange={(e) => setDescription(e.currentTarget.value)} rows={3} disabled={isSubmitting} radius="lg" />
                <NumberInput label="Coste en Puntos:" placeholder="Ej: 100" value={pointsCost} onChange={(value) => setPointsCost(typeof value === 'number' ? value : '')} min={0} step={1} allowDecimal={false} required disabled={isSubmitting} radius="lg" />

                {/* Alert de error local eliminada */}

                <Group justify="flex-end" mt="md">
                    <Button variant="light" onClick={onCancel} disabled={isSubmitting} radius="lg"> Cancelar </Button>
                    <Button type="submit" loading={isSubmitting} radius="lg"> {submitButtonText} </Button>
                </Group>
            </Stack>
        </form>
    );
};

export default RewardForm;

// End of File: frontend/src/components/AddRewardForm.tsx


// ====== [53] frontend/src/modules/loyalpyme/components/GenerateQrCode.tsx ======
// filename: frontend/src/components/GenerateQrCode.tsx
import { useState } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { QRCodeCanvas } from 'qrcode.react';
import {
    TextInput, NumberInput, Button, Stack, Alert, Loader,
    Paper, Text, Code, Box, Group, Center
} from '@mantine/core';
import { IconAlertCircle, IconCheck } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

interface QrCodeData {
    qrToken: string;
    amount: number;
}

const GenerateQrCode: React.FC = () => {
    const { t } = useTranslation();
    const [amount, setAmount] = useState<number | ''>('');
    const [ticketNumber, setTicketNumber] = useState<string>('');
    const [isLoading, setIsLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);
    const [generatedData, setGeneratedData] = useState<QrCodeData | null>(null);

    const handleGenerateClick = async () => {
        setError(null);
        setGeneratedData(null);

        if (amount === '' || amount <= 0) {
            setError(t('component.generateQr.errorAmountPositive'));
            return;
        }
        if (!ticketNumber || ticketNumber.trim() === '') {
            setError(t('component.generateQr.errorTicketRequired'));
            return;
        }
        setIsLoading(true);
        try {
            const requestData = { amount: Number(amount), ticketNumber: ticketNumber.trim() };
            const response = await axiosInstance.post<QrCodeData>('/points/generate-qr', requestData);
            setGeneratedData(response.data);
            setAmount('');
            setTicketNumber('');
        } catch (err: any) {
            console.error('Error generating QR code data:', err);
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown'); // Clave com√∫n para error desconocido
            setError(t('component.generateQr.errorGeneric', { error: apiError }));
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Stack gap="md">
            <NumberInput
                label={t('component.generateQr.amountLabel')}
                placeholder={t('component.generateQr.amountPlaceholder')}
                value={amount}
                onChange={(value) => setAmount(typeof value === 'number' ? value : '')}
                min={0.01}
                step={0.01}
                decimalScale={2}
                fixedDecimalScale
                required
                radius="lg"
                disabled={isLoading}
            />
            <TextInput
                label={t('component.generateQr.ticketLabel')}
                placeholder={t('component.generateQr.ticketPlaceholder')}
                value={ticketNumber}
                onChange={(e) => setTicketNumber(e.currentTarget.value)}
                required
                radius="lg"
                disabled={isLoading}
            />
            <Box>
                <Button onClick={handleGenerateClick} loading={isLoading} radius="lg">
                    {t('component.generateQr.buttonText')}
                </Button>
            </Box>

            <Box mt="md" style={{ minHeight: '200px' }}>
                {isLoading && (
                    <Group justify="center"><Loader size="sm" /></Group>
                )}
                {error && (
                    <Alert
                        icon={<IconAlertCircle size={16} />}
                        title={t('common.error')}
                        color="red"
                        radius="lg"
                        withCloseButton
                        onClose={() => setError(null)}
                    >
                        {error}
                    </Alert>
                )}
                {generatedData && (
                    <Paper withBorder p="md" radius="lg" mt="sm">
                        <Group gap="xs" mb="xs">
                            <IconCheck size={16} color="var(--mantine-color-green-7)" />
                            <Text fw={500} size="sm">
                                {t('component.generateQr.successMessage', { amount: generatedData.amount.toFixed(2) })}
                            </Text>
                        </Group>
                        <Text size="sm" mb="md">
                            {t('component.generateQr.successInstructions')}
                        </Text>
                        <Center>
                            <QRCodeCanvas
                                value={generatedData.qrToken}
                                size={160}
                                bgColor={"#ffffff"}
                                fgColor={"#000000"}
                                level={"L"}
                                includeMargin={true}
                            />
                        </Center>
                        <Text size="xs" c="dimmed" mt="md" ta="center">
                            {t('component.generateQr.tokenRef')}{' '}
                            <Code>{generatedData.qrToken}</Code>
                        </Text>
                    </Paper>
                )}
                 {!isLoading && !error && !generatedData && (
                     <Text size="sm" c="dimmed">{t('component.generateQr.initialPrompt', 'Introduce importe y n√∫mero de ticket para generar los datos del QR.')}</Text>
                 )}
            </Box>
        </Stack>
    );
};

export default GenerateQrCode;


// ====== [54] frontend/src/modules/loyalpyme/components/admin/AdjustPointsModal.tsx ======
// frontend/src/components/admin/AdjustPointsModal.tsx
// Version 1.1.0 (Use adminCustomerService for API call)

import React, { useState, useEffect } from 'react';
import { Modal, TextInput, Button, Group, Text, NumberInput } from '@mantine/core';
import { useForm } from '@mantine/form'; // zodResolver no es estrictamente necesario aqu√≠ si la validaci√≥n es simple
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX } from '@tabler/icons-react';
import { Customer } from '../../hooks/useAdminCustomersData';
import { useTranslation } from 'react-i18next';

// --- NUEVO: Importar el servicio ---
import * as adminCustomerService from '../../services/adminCustomerService';
// --- FIN NUEVO ---

interface AdjustPointsModalProps {
    opened: boolean;
    onClose: () => void;
    customer: Customer | null;
    onSuccess: () => void; // Callback para refrescar datos en la p√°gina principal
}

const AdjustPointsModal: React.FC<AdjustPointsModalProps> = ({ opened, onClose, customer, onSuccess }) => {
    const { t } = useTranslation();
    const [loading, setLoading] = useState(false); // Renombrado de isSubmitting a loading para consistencia

    const form = useForm({
        initialValues: { amount: 0, reason: '' },
        validate: {
            amount: (value) => (value === 0 ? t('validation.cannotBeZero') : null),
            // 'reason' es opcional, no necesita validaci√≥n aqu√≠ a menos que cambien los requisitos
        }
    });

    useEffect(() => {
        if (opened) {
             form.reset(); // Resetear el formulario cada vez que se abre
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened]); // No necesitamos customer como dependencia si solo reseteamos

    const handleSubmit = async (values: typeof form.values) => {
        if (!customer) return;
        setLoading(true);
        try {
            // --- CAMBIO: Llamar al servicio en lugar de axiosInstance directamente ---
            await adminCustomerService.adjustCustomerPointsApi(
                customer.id,
                values.amount,
                values.reason.trim() ? values.reason.trim() : null // Enviar null si la raz√≥n est√° vac√≠a
            );
            // --- FIN CAMBIO ---

            notifications.show({
                title: t('common.success'),
                message: t('adminCustomersPage.adjustPointsSuccess', { name: customer.name || customer.email }),
                color: 'green',
                icon: <IconCheck size={18} />,
            });
            onSuccess(); // Llama al callback para refrescar la tabla en la p√°gina principal
            onClose();   // Cierra el modal
        } catch (error: any) {
            console.error("Error adjusting points via modal:", error);
            const apiError = error.response?.data?.message || error.message || t('common.errorUnknown');
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.adjustPointsError', { error: apiError }),
                color: 'red',
                icon: <IconX size={18} />,
            });
            // No cerramos el modal en caso de error para que el usuario pueda corregir si es necesario
        } finally {
            setLoading(false);
        }
    };

    const modalTitle = t('adminCustomersPage.adjustPointsModalTitle', {
        name: customer?.name || customer?.email || t('common.customer')
    });

    return (
        <Modal
            opened={opened}
            onClose={() => { if (!loading) onClose(); }} // Prevenir cierre si est√° enviando
            title={modalTitle}
            centered
            trapFocus // Mantener el foco dentro del modal
            closeOnClickOutside={!loading} // Prevenir cierre al hacer clic fuera si est√° cargando
            closeOnEscape={!loading}     // Prevenir cierre con ESC si est√° cargando
        >
            {customer ? (
                <form onSubmit={form.onSubmit(handleSubmit)}>
                    <Text size="sm" mb="md">
                        {t('adminCustomersPage.adjustPointsCurrent', { points: customer.points })}
                    </Text>
                    <NumberInput
                        label={t('adminCustomersPage.adjustPointsAmountLabel')}
                        placeholder={t('adminCustomersPage.adjustPointsAmountPlaceholder')}
                        required
                        allowNegative
                        disabled={loading}
                        data-autofocus // Enfocar este campo al abrir
                        {...form.getInputProps('amount')}
                    />
                    <TextInput
                        label={t('adminCustomersPage.adjustPointsReasonLabel')}
                        placeholder={t('adminCustomersPage.adjustPointsReasonPlaceholder')}
                        mt="md"
                        disabled={loading}
                        {...form.getInputProps('reason')}
                    />
                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={onClose} disabled={loading}>
                            {t('common.cancel')}
                        </Button>
                        <Button
                            type="submit"
                            loading={loading}
                            disabled={!form.isValid() || form.values.amount === 0 || loading}
                        >
                            {t('adminCustomersPage.adjustPointsButton')}
                        </Button>
                    </Group>
                </form>
            ) : (
                // Esto no deber√≠a mostrarse si el modal solo se abre con un customer
                <Text c="dimmed">{t('adminCustomersPage.noCustomerSelected')}</Text>
            )}
        </Modal>
    );
};

export default AdjustPointsModal;


// ====== [55] frontend/src/modules/loyalpyme/components/admin/AssignRewardModal.tsx ======
// frontend/src/components/admin/AssignRewardModal.tsx
// Version 1.2.0 (Use adminCustomerService for API call)

import React, { useState, useEffect } from 'react';
import { Modal, Select, Button, Group, Text, Loader, Alert } from '@mantine/core';
// axiosInstance ya no se usa aqu√≠ para la acci√≥n principal
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX, IconAlertCircle } from '@tabler/icons-react';
import type { Customer } from '../../hooks/useAdminCustomersData';
import { useTranslation } from 'react-i18next';

// --- NUEVO: Importar el servicio ---
import * as adminCustomerService from '../../services/adminCustomerService';
import axiosInstance from '../../../../shared/services/axiosInstance';// A√∫n necesario para fetchRewards

// Importar el tipo Reward de nuestro archivo centralizado
import type { Reward } from '../../../../shared/types/user.types';

interface AssignRewardModalProps {
    opened: boolean;
    onClose: () => void;
    customer: Customer | null;
    onSuccess: () => void; // Para refrescar la lista de clientes o detalles si es necesario
}

const AssignRewardModal: React.FC<AssignRewardModalProps> = ({ opened, onClose, customer, onSuccess }) => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;

    const [rewards, setRewards] = useState<{ value: string; label: string }[]>([]);
    const [selectedRewardId, setSelectedRewardId] = useState<string | null>(null);
    const [loadingRewards, setLoadingRewards] = useState(false);
    const [loadingAssign, setLoadingAssign] = useState(false);
    const [errorRewards, setErrorRewards] = useState<string | null>(null);

    useEffect(() => {
        if (opened && customer) {
            setLoadingRewards(true);
            setErrorRewards(null);
            setSelectedRewardId(null); // Resetear selecci√≥n al abrir

            // La API /rewards devuelve todos, filtramos las activas en el frontend para este modal
            axiosInstance.get<Reward[]>('/rewards')
                .then(response => {
                    const activeRewards = response.data?.filter(r => r.isActive) ?? [];
                    const availableRewards = activeRewards.map(reward => {
                        const displayName = (currentLanguage === 'es' ? reward.name_es : reward.name_en) || reward.name_es || reward.name_en || `ID: ${reward.id}`;
                        return {
                            value: reward.id,
                            label: `${displayName} (${t('adminCustomersPage.assignRewardOptionPoints', { points: reward.pointsCost ?? 0 })})`
                        };
                    });
                    setRewards(availableRewards);
                })
                .catch(err => {
                    console.error("Error fetching rewards for modal:", err);
                    const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
                    setErrorRewards(t('adminCustomersPage.assignRewardErrorLoading', { error: apiError }));
                })
                .finally(() => {
                    setLoadingRewards(false);
                });
        } else if (!opened) {
            setSelectedRewardId(null);
            setRewards([]);
            setErrorRewards(null);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, customer, t, currentLanguage]); // A√±adir t y currentLanguage

    const handleAssign = async () => {
        if (!customer || !selectedRewardId) return;
        setLoadingAssign(true);
        try {
            // --- CAMBIO: Llamar al servicio en lugar de axiosInstance directamente ---
            await adminCustomerService.assignRewardToCustomerApi(customer.id, selectedRewardId);
            // --- FIN CAMBIO ---

            notifications.show({
                title: t('common.success'),
                message: t('adminCustomersPage.assignRewardSuccess', { name: customer.name || customer.email }),
                color: 'green',
                icon: <IconCheck size={18} />
            });
            onSuccess(); // Refrescar datos en la p√°gina principal
            onClose();   // Cerrar el modal
        } catch (error: any) {
            console.error("Error assigning reward via modal:", error);
            const apiError = error.response?.data?.message || error.message || t('common.errorUnknown');
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.assignRewardError', { error: apiError }),
                color: 'red',
                icon: <IconX size={18} />
            });
        } finally {
            setLoadingAssign(false);
        }
    };

    const modalTitle = t('adminCustomersPage.assignRewardModalTitle', {
        name: customer?.name || customer?.email || t('common.customer')
    });

    return (
        <Modal
            opened={opened}
            onClose={() => { if (!loadingAssign) onClose(); }}
            title={modalTitle}
            centered
            trapFocus
            closeOnClickOutside={!loadingAssign}
            closeOnEscape={!loadingAssign}
        >
            {loadingRewards && <Group justify="center"><Loader /></Group>}
            {errorRewards && !loadingRewards && (
                <Alert title={t('adminCustomersPage.assignRewardLoadingErrorTitle')} color="red" icon={<IconAlertCircle />}>
                    {errorRewards}
                </Alert>
            )}

            {!loadingRewards && !errorRewards && customer && (
                <>
                    <Select
                        label={t('adminCustomersPage.assignRewardSelectLabel')}
                        placeholder={t('adminCustomersPage.assignRewardSelectPlaceholder')}
                        data={rewards}
                        value={selectedRewardId}
                        onChange={setSelectedRewardId}
                        searchable
                        nothingFoundMessage={rewards.length === 0 && !loadingRewards ? t('adminCustomersPage.assignRewardNotFound') : t('common.noResults')}
                        required
                        disabled={rewards.length === 0 || loadingRewards || loadingAssign}
                        mb="md"
                        data-autofocus
                    />
                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={onClose} disabled={loadingAssign}>
                            {t('common.cancel')}
                        </Button>
                        <Button
                            onClick={handleAssign}
                            loading={loadingAssign}
                            disabled={!selectedRewardId || loadingRewards || rewards.length === 0}
                        >
                            {t('adminCustomersPage.assignRewardButton')}
                        </Button>
                    </Group>
                </>
            )}
            {!loadingRewards && !errorRewards && !customer && (
                <Text c="dimmed">{t('adminCustomersPage.noCustomerSelected')}</Text>
            )}
        </Modal>
    );
};

export default AssignRewardModal;


// ====== [56] frontend/src/modules/loyalpyme/components/admin/BulkAdjustPointsModal.tsx ======
// filename: frontend/src/components/admin/BulkAdjustPointsModal.tsx
import React, { useState, useEffect } from 'react';
import {
    Modal, NumberInput, TextInput, Button, Group, Stack
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { IconPlusMinus } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next'; // Importar hook

// Tipo inferido del esquema
type FormValues = z.infer<ReturnType<typeof createValidationSchema>>;

// Funci√≥n para crear el esquema de validaci√≥n (para poder usar t())
const createValidationSchema = (t: Function) => z.object({
  amount: z.number().refine(val => val !== 0, { message: t('validation.cannotBeZero', 'La cantidad no puede ser cero') }),
  reason: z.string().optional(),
});

interface BulkAdjustPointsModalProps {
    opened: boolean;
    onClose: () => void;
    onSubmit: (values: FormValues) => Promise<void>; // La funci√≥n que manejar√° la l√≥gica de env√≠o y notificaciones
    numberOfCustomers: number;
}

const BulkAdjustPointsModal: React.FC<BulkAdjustPointsModalProps> = ({
    opened,
    onClose,
    onSubmit,
    numberOfCustomers
}) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [isSubmitting, setIsSubmitting] = useState(false);

    const form = useForm<FormValues>({
        initialValues: { amount: 0, reason: '', },
        // Pasar t al crear el schema
        validate: zodResolver(createValidationSchema(t)),
    });

    useEffect(() => {
        if (opened) {
            form.reset();
            setIsSubmitting(false);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened]);

    const handleSubmit = async (values: FormValues) => {
        setIsSubmitting(true);
        try {
            await onSubmit(values);
            // Notificaciones y cierre manejados por el padre
        } catch (error) {
            console.error("Error during bulk adjust points submission callback:", error);
            // Notificaci√≥n de error manejada por el padre
        } finally {
            // Decidimos si resetear isSubmitting aqu√≠ o dejarlo al padre/reapertura
            // setIsSubmitting(false);
        }
    };

    // Usar t() para el t√≠tulo del modal
    const modalTitle = t('adminCustomersPage.bulkAdjustPointsModalTitle', { count: numberOfCustomers });

    return (
        <Modal
            opened={opened}
            onClose={() => { if(!isSubmitting) onClose(); }} // Prevenir cierre si est√° enviando
            title={modalTitle}
            centered
        >
            <form onSubmit={form.onSubmit(handleSubmit)}>
                <Stack>
                    <NumberInput
                        label={t('adminCustomersPage.bulkAdjustPointsAmountLabel')}
                        placeholder={t('adminCustomersPage.bulkAdjustPointsAmountPlaceholder')}
                        required
                        allowNegative
                        {...form.getInputProps('amount')}
                        disabled={isSubmitting}
                        data-autofocus // Enfocar este campo al abrir
                    />
                    <TextInput
                        label={t('adminCustomersPage.bulkAdjustPointsReasonLabel')}
                        placeholder={t('adminCustomersPage.bulkAdjustPointsReasonPlaceholder')}
                        {...form.getInputProps('reason')}
                        disabled={isSubmitting}
                    />
                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={onClose} disabled={isSubmitting}>
                            {t('common.cancel')}
                        </Button>
                        <Button
                            type="submit"
                            loading={isSubmitting}
                            leftSection={<IconPlusMinus size={16} />}
                            disabled={!form.isValid() || form.values.amount === 0 || isSubmitting}
                        >
                            {t('adminCustomersPage.bulkAdjustPointsButton')}
                        </Button>
                    </Group>
                </Stack>
            </form>
        </Modal>
    );
};

export default BulkAdjustPointsModal;


// ====== [57] frontend/src/modules/loyalpyme/components/admin/ChangeTierModal.tsx ======
// frontend/src/components/admin/ChangeTierModal.tsx
// Version 1.1.0 (Use adminCustomerService for API call)

import React, { useState, useEffect } from 'react';
import { Modal, Select, Button, Group, Text, Loader, Alert } from '@mantine/core';
// axiosInstance ya no es necesario aqu√≠ directamente
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX, IconAlertCircle } from '@tabler/icons-react';
import { Customer } from '../../hooks/useAdminCustomersData';
import { useTranslation } from 'react-i18next';

// --- NUEVO: Importar el servicio ---
import * as adminCustomerService from '../../services/adminCustomerService';
import axiosInstance from '../../../../shared/services/axiosInstance'; // A√∫n necesario para fetchTiers

// Interfaz para los Tiers (se mantiene igual)
interface TierOption {
    value: string;
    label: string;
}
interface TierFromApi { // Para la respuesta de la API de tiers
    id: string;
    name: string;
    level: number;
}

interface ChangeTierModalProps {
    opened: boolean;
    onClose: () => void;
    customer: Customer | null;
    onSuccess: () => void;
}

const ChangeTierModal: React.FC<ChangeTierModalProps> = ({ opened, onClose, customer, onSuccess }) => {
    const { t } = useTranslation();
    const [tiers, setTiers] = useState<TierOption[]>([]);
    const [selectedTierId, setSelectedTierId] = useState<string | null>(null);
    const [loadingTiers, setLoadingTiers] = useState(false);
    const [loadingChange, setLoadingChange] = useState(false);
    const [errorTiers, setErrorTiers] = useState<string | null>(null);

    useEffect(() => {
        if (opened && customer) {
            setLoadingTiers(true);
            setErrorTiers(null);
            // Inicializar con el tier actual del cliente o '' para "Sin Nivel"
            setSelectedTierId(customer.currentTier?.id || '');

            axiosInstance.get<TierFromApi[]>('/tiers') // La ruta es /api/tiers (el servicio de admin para obtener todos los tiers)
                .then(response => {
                    const sortedTiers = response.data.sort((a, b) => a.level - b.level);
                    const availableTiers: TierOption[] = [
                        { value: '', label: t('adminCustomersPage.changeTierOptionNone') }, // Opci√≥n para quitar tier
                        ...sortedTiers.map(tier => ({
                            value: tier.id,
                            label: `${tier.name} (${t('adminCustomersPage.changeTierOptionLevel', { level: tier.level })})`
                        }))
                    ];
                    setTiers(availableTiers);
                })
                .catch(err => {
                    console.error("Error fetching tiers for modal:", err);
                    const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
                    setErrorTiers(t('adminCustomersPage.changeTierErrorLoadingTiers', { error: apiError }));
                })
                .finally(() => {
                    setLoadingTiers(false);
                });
        } else if (!opened) {
            // Resetear al cerrar
            setSelectedTierId(null);
            setTiers([]);
            setErrorTiers(null);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, customer, t]); // t como dependencia por si las claves cambian

    const handleChangeTier = async () => {
        if (!customer) return;

        const tierIdToSend = selectedTierId === '' ? null : selectedTierId; // '' representa "Sin Nivel"

        if (tierIdToSend === (customer.currentTier?.id || null)) {
            notifications.show({
                title: t('adminCustomersPage.changeTierNoChangeTitle'),
                message: t('adminCustomersPage.changeTierNoChange'),
                color: 'blue'
            });
            return;
        }

        setLoadingChange(true);
        try {
            // --- CAMBIO: Llamar al servicio en lugar de axiosInstance directamente ---
            await adminCustomerService.changeCustomerTierApi(customer.id, tierIdToSend);
            // --- FIN CAMBIO ---

            notifications.show({
                title: t('common.success'),
                message: t('adminCustomersPage.changeTierSuccess', { name: customer.name || customer.email }),
                color: 'green',
                icon: <IconCheck size={18} />,
            });
            onSuccess(); // Refrescar datos en la p√°gina principal
            onClose();   // Cerrar el modal
        } catch (error: any) {
            console.error("Error changing tier via modal:", error);
            const apiError = error.response?.data?.message || error.message || t('common.errorUnknown');
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.changeTierError', { error: apiError }),
                color: 'red',
                icon: <IconX size={18} />,
            });
        } finally {
            setLoadingChange(false);
        }
    };

    const modalTitle = t('adminCustomersPage.changeTierModalTitle', {
        name: customer?.name || customer?.email || t('common.customer')
    });
    const currentTierName = customer?.currentTier?.name || t('customerDashboard.baseTier');

    return (
        <Modal
            opened={opened}
            onClose={() => { if (!loadingChange) onClose(); }}
            title={modalTitle}
            centered
            trapFocus
            closeOnClickOutside={!loadingChange}
            closeOnEscape={!loadingChange}
        >
            {customer && (
                <Text size="sm" mb="xs">
                    {t('adminCustomersPage.changeTierCurrent', { tierName: currentTierName })}
                </Text>
            )}

            {loadingTiers && <Group justify="center"><Loader /></Group>}
            {errorTiers && !loadingTiers && (
                <Alert title={t('adminCustomersPage.changeTierLoadingErrorTitle')} color="red" icon={<IconAlertCircle />}>
                    {errorTiers}
                </Alert>
            )}

            {!loadingTiers && !errorTiers && customer && (
                <>
                    <Select
                        label={t('adminCustomersPage.changeTierSelectLabel')}
                        placeholder={t('adminCustomersPage.changeTierSelectPlaceholder')}
                        data={tiers}
                        value={selectedTierId ?? ''} // Usar '' si es null para que coincida con la opci√≥n "Sin Nivel"
                        onChange={(value) => setSelectedTierId(value)} // Select de Mantine devuelve string | null
                        searchable
                        nothingFoundMessage={t('adminCustomersPage.changeTierNotFound')}
                        disabled={loadingTiers || loadingChange || tiers.length === 0}
                        mb="md"
                        clearable={false} // La opci√≥n "Sin Nivel" maneja la "limpieza"
                    />
                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={onClose} disabled={loadingChange}>
                            {t('common.cancel')}
                        </Button>
                        <Button
                            onClick={handleChangeTier}
                            loading={loadingChange}
                            disabled={loadingTiers || (selectedTierId ?? '') === (customer.currentTier?.id || '') || tiers.length === 0}
                        >
                            {t('adminCustomersPage.changeTierButton')}
                        </Button>
                    </Group>
                </>
            )}
            {!loadingTiers && !errorTiers && !customer && (
                <Text c="dimmed">{t('adminCustomersPage.noCustomerSelected')}</Text>
            )}
        </Modal>
    );
};

export default ChangeTierModal;


// ====== [58] frontend/src/modules/loyalpyme/components/admin/CustomerBulkActionsBar.tsx ======
// frontend/src/components/admin/CustomerBulkActionsBar.tsx
import React from 'react';
import { Paper, Group, Text, Button } from '@mantine/core';
import {
    IconPlayerPlay,
    IconPlayerStop,
    IconTrash,
    IconPlusMinus
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

interface CustomerBulkActionsBarProps {
    selectedRowCount: number;
    onBulkDelete: () => void;
    onBulkActivate: () => void; // Ser√° onBulkToggleActive(true)
    onBulkDeactivate: () => void; // Ser√° onBulkToggleActive(false)
    onOpenBulkAdjustPoints: () => void; // Para abrir el modal de ajuste masivo de puntos
    isPerformingBulkAction: boolean; // Para el estado de carga de los botones
}

const CustomerBulkActionsBar: React.FC<CustomerBulkActionsBarProps> = ({
    selectedRowCount,
    onBulkDelete,
    onBulkActivate,
    onBulkDeactivate,
    onOpenBulkAdjustPoints,
    isPerformingBulkAction,
}) => {
    const { t } = useTranslation();

    if (selectedRowCount === 0) {
        return null; // No mostrar nada si no hay filas seleccionadas
    }

    return (
        <Paper p="xs" mb="md" withBorder shadow="xs">
            <Group justify="space-between">
                <Text fw={500} size="sm">
                    {/* Usar clave i18n con pluralizaci√≥n para el conteo */}
                    {t('adminCustomersPage.selectedCount', { count: selectedRowCount })}
                </Text>
                <Group>
                    <Button
                        size="xs"
                        color="red"
                        variant="filled" // O 'outline' si se prefiere
                        leftSection={<IconTrash size={14} />}
                        onClick={onBulkDelete}
                        loading={isPerformingBulkAction} // Asumimos un solo estado de carga para todas las acciones masivas
                        disabled={isPerformingBulkAction}
                    >
                        {t('adminCustomersPage.bulkDeleteButton')}
                    </Button>
                    <Button
                        size="xs"
                        color="green"
                        variant="outline"
                        leftSection={<IconPlayerPlay size={14} />}
                        onClick={onBulkActivate}
                        loading={isPerformingBulkAction}
                        disabled={isPerformingBulkAction}
                    >
                        {t('adminCustomersPage.bulkActivateButton')}
                    </Button>
                    <Button
                        size="xs"
                        color="red" // Podr√≠a ser 'orange' o 'gray' tambi√©n
                        variant="outline"
                        leftSection={<IconPlayerStop size={14} />}
                        onClick={onBulkDeactivate}
                        loading={isPerformingBulkAction}
                        disabled={isPerformingBulkAction}
                    >
                        {t('adminCustomersPage.bulkDeactivateButton')}
                    </Button>
                    <Button
                        size="xs"
                        color="blue"
                        variant="outline"
                        leftSection={<IconPlusMinus size={14} />}
                        onClick={onOpenBulkAdjustPoints} // Esta prop abre el modal
                        disabled={isPerformingBulkAction} // Se deshabilita si otra acci√≥n masiva est√° en curso
                    >
                        {t('adminCustomersPage.bulkPointsButton')}
                    </Button>
                </Group>
            </Group>
        </Paper>
    );
};

export default CustomerBulkActionsBar;


// ====== [59] frontend/src/modules/loyalpyme/components/admin/CustomerDetailsModal.tsx ======
// filename: frontend/src/components/admin/CustomerDetailsModal.tsx
import React, { useState, useEffect } from 'react';
import {
    Modal, LoadingOverlay, Alert, Text, Group, Badge, Divider, Stack, ScrollArea,
    Textarea, Button
} from '@mantine/core';
import { IconAlertCircle, IconDeviceFloppy } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next'; // Importar hook

// Interfaz CustomerDetails
export interface CustomerDetails {
    id: string;
    email: string;
    name?: string | null;
    points: number;
    createdAt: string;
    isActive: boolean;
    isFavorite?: boolean | null;
    tierAchievedAt?: string | null;
    adminNotes?: string | null;
    businessId: string;
    role: string;
    currentTier?: {
        id: string;
        name: string;
        level: number;
        description?: string | null;
    } | null;
}

// Props del Modal
interface CustomerDetailsModalProps {
    opened: boolean;
    onClose: () => void;
    customerDetails: CustomerDetails | null;
    isLoading: boolean;
    error: string | null;
    onSaveNotes: (notes: string | null) => Promise<void>;
}

const CustomerDetailsModal: React.FC<CustomerDetailsModalProps> = ({
    opened,
    onClose,
    customerDetails,
    isLoading,
    error,
    onSaveNotes
}) => {
    const { t, i18n } = useTranslation(); // Hook de traducci√≥n
    const [editedNotes, setEditedNotes] = useState<string>('');
    const [isSaving, setIsSaving] = useState<boolean>(false);

    // Efecto para inicializar/resetear las notas editables
    useEffect(() => {
        if (opened && customerDetails) {
            setEditedNotes(customerDetails.adminNotes || '');
        }
    }, [opened, customerDetails]);

    // Funci√≥n para formatear fechas usando el idioma actual
    const formatDate = (dateString: string | null | undefined) => {
        if (!dateString) return 'N/A';
        try {
            // Usar i18n.language para el locale
            return new Date(dateString).toLocaleDateString(i18n.language, { day: '2-digit', month: '2-digit', year: 'numeric' });
        } catch {
            return t('common.invalidDate', 'Fecha inv√°lida'); // Clave i18n
        }
    };

    // Usar t() para el t√≠tulo del modal
    const modalTitle = t('adminCustomersPage.customerDetailsModalTitle', {
        name: customerDetails?.name || customerDetails?.email || t('common.customer', 'Cliente')
    });

    // Handler para Guardar Notas
    const handleSave = async () => {
        if (!customerDetails) return;
        setIsSaving(true);
        try {
            await onSaveNotes(editedNotes.trim() ? editedNotes.trim() : null);
            // Notificaciones y cierre los maneja el padre
        } catch (saveError) {
            console.error("Error during save callback execution in modal:", saveError);
            // El padre deber√≠a mostrar la notificaci√≥n de error
        } finally {
            setIsSaving(false);
        }
    };

    return (
        <Modal opened={opened} onClose={onClose} title={modalTitle} size="lg" centered scrollAreaComponent={ScrollArea.Autosize} >
            <LoadingOverlay visible={isLoading} zIndex={1000} overlayProps={{ radius: "sm", blur: 2 }} />
            {error && !isLoading && (
                // Usar t() para el t√≠tulo del Alert
                <Alert icon={<IconAlertCircle size="1rem" />} title={t('adminCustomersPage.customerDetailsLoadingError')} color="red">
                    {error}
                </Alert>
            )}

            {!isLoading && !error && customerDetails && (
                <Stack gap="sm">
                    {/* Usar t() para las etiquetas */}
                    <Group justify="space-between"> <Text fw={500}>{t('common.email')}:</Text> <Text>{customerDetails.email}</Text> </Group>
                    <Group justify="space-between"> <Text fw={500}>{t('common.name')}:</Text> <Text>{customerDetails.name || '-'}</Text> </Group>
                    <Divider my="xs" />
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsPoints')}</Text> <Text fw={700} c="blue">{customerDetails.points}</Text> </Group>
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsTier')}</Text> <Badge color={customerDetails.currentTier ? 'teal' : 'gray'} variant="light"> {customerDetails.currentTier?.name || t('customerDashboard.baseTier')} </Badge> </Group>
                    {customerDetails.currentTier?.description && ( <Text size="sm" c="dimmed"> {customerDetails.currentTier.description} </Text> )}
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsTierDate')}</Text> <Text>{formatDate(customerDetails.tierAchievedAt)}</Text> </Group>
                    <Divider my="xs" />
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsStatus')}</Text> <Badge color={customerDetails.isActive ? 'green' : 'red'} variant="filled"> {customerDetails.isActive ? t('common.active') : t('common.inactive')} </Badge> </Group>
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsFavorite')}</Text> <Text>{customerDetails.isFavorite ? t('common.yes') : t('common.no')}</Text> </Group>
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsRegisteredDate')}</Text> <Text>{formatDate(customerDetails.createdAt)}</Text> </Group>

                    <Divider my="sm" />
                    <Textarea
                        label={t('adminCustomersPage.customerDetailsAdminNotesLabel')}
                        placeholder={t('adminCustomersPage.customerDetailsAdminNotesPlaceholder')}
                        value={editedNotes}
                        onChange={(event) => setEditedNotes(event.currentTarget.value)}
                        minRows={4}
                        autosize
                        disabled={isSaving}
                    />
                    <Group justify="flex-end" mt="md">
                        <Button
                            variant="filled"
                            onClick={handleSave}
                            loading={isSaving}
                            leftSection={<IconDeviceFloppy size={16} />}
                            disabled={editedNotes === (customerDetails.adminNotes || '') || isSaving}
                        >
                            {t('adminCustomersPage.customerDetailsSaveNotesButton')}
                        </Button>
                    </Group>
                </Stack>
            )}
            {!isLoading && !error && !customerDetails && (
                <Text c="dimmed">{t('adminCustomersPage.customerDetailsNoDetails')}</Text>
            )}
        </Modal>
    );
};

export default CustomerDetailsModal;


// ====== [60] frontend/src/modules/loyalpyme/components/admin/CustomerFiltersBar.tsx ======
// frontend/src/components/admin/CustomerFiltersBar.tsx
import React from 'react';
import { Paper, Group, Text, TextInput, Select, Checkbox } from '@mantine/core';
import { IconSearch, IconFilter } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

// Tipo para las opciones del Select de Tier (debe coincidir con el de la p√°gina principal)
export interface TierOption {
    value: string;
    label: string;
}

interface CustomerFiltersBarProps {
    searchTerm: string;
    onSearchTermChange: (term: string) => void;
    activeFilterValue: string; // '', 'active', 'inactive'
    onActiveFilterChange: (value: string | null) => void;
    isFavoriteFilterChecked: boolean;
    onIsFavoriteFilterChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
    tierFilterValue: string; // ID del tier, 'NONE', o '' para todos
    onTierFilterChange: (value: string | null) => void;
    tierOptions: TierOption[]; // Opciones para el selector de Tier
    loadingFilters: boolean; // Para deshabilitar inputs mientras cargan datos (ej. tiers)
    disabled: boolean; // Para deshabilitar todos los filtros si la tabla principal est√° cargando
}

const CustomerFiltersBar: React.FC<CustomerFiltersBarProps> = ({
    searchTerm,
    onSearchTermChange,
    activeFilterValue,
    onActiveFilterChange,
    isFavoriteFilterChecked,
    onIsFavoriteFilterChange,
    tierFilterValue,
    onTierFilterChange,
    tierOptions,
    loadingFilters, // Usado para deshabilitar select de tier mientras carga
    disabled,       // Usado para deshabilitar todo mientras la tabla carga
}) => {
    const { t } = useTranslation();

    return (
        <Paper p="md" withBorder radius="md" shadow="xs">
            <Group>
                <IconFilter size={18} />
                <Text fw={500} size="sm">{t('adminCustomersPage.filterLabel')}</Text>
                <TextInput
                    placeholder={t('adminCustomersPage.searchPlaceholder')}
                    leftSection={<IconSearch size={16} stroke={1.5} />}
                    value={searchTerm}
                    onChange={(event) => onSearchTermChange(event.currentTarget.value)}
                    radius="md"
                    style={{ flex: 1, minWidth: 200 }} // Darle flexibilidad y un m√≠nimo
                    disabled={disabled}
                />
                <Select
                    placeholder={t('adminCustomersPage.statusFilterPlaceholder')}
                    data={[
                        { value: '', label: t('adminCustomersPage.statusFilterAll') },
                        { value: 'active', label: t('adminCustomersPage.statusFilterActive') },
                        { value: 'inactive', label: t('adminCustomersPage.statusFilterInactive') }
                    ]}
                    value={activeFilterValue}
                    onChange={onActiveFilterChange}
                    clearable={false} // Para que siempre haya una opci√≥n (aunque sea 'todos')
                    radius="md"
                    disabled={disabled}
                    style={{ minWidth: 150 }}
                />
                <Checkbox
                    label={t('adminCustomersPage.favoriteFilterLabel')}
                    checked={isFavoriteFilterChecked}
                    onChange={onIsFavoriteFilterChange}
                    disabled={disabled}
                />
                <Select
                    placeholder={t('adminCustomersPage.tierFilterPlaceholder')}
                    data={tierOptions} // Las opciones vienen del componente padre
                    value={tierFilterValue}
                    onChange={onTierFilterChange}
                    disabled={disabled || loadingFilters} // Deshabilitar si los tiers est√°n cargando
                    searchable
                    nothingFoundMessage={t('adminCustomersPage.tierFilterError')} // Reutilizar clave
                    clearable={false} // Para que siempre haya una opci√≥n (ej. 'todos')
                    radius="md"
                    style={{ minWidth: 180 }}
                />
            </Group>
        </Paper>
    );
};

export default CustomerFiltersBar;


// ====== [61] frontend/src/modules/loyalpyme/components/admin/CustomerTable.tsx ======
// filename: frontend/src/components/admin/CustomerTable.tsx
import React from 'react';
import {
    Table, Group, ActionIcon, Text, useMantineTheme, UnstyledButton, Center, rem,
    Checkbox, Badge
} from '@mantine/core';
import {
    IconAdjustments, IconGift, IconEye, IconStar,
    IconStairsUp, IconSelector, IconChevronDown, IconChevronUp,
    IconEyeCheck, IconEyeOff
} from '@tabler/icons-react';
import classes from '../../pages/admin/AdminCustomerManagementPage.module.css';
import { useTranslation } from 'react-i18next'; // Importar hook

// Importar tipos necesarios desde el hook
import { Customer, SortStatus, SortColumn } from '../../hooks/useAdminCustomersData';

// --- Componente Th Auxiliar ---
interface ThProps {
    children: React.ReactNode;
    reversed: boolean;
    sorted: boolean;
    onSort(): void;
    sortKey: SortColumn;
    currentSortKey: SortColumn;
    disabled?: boolean;
}

function Th({ children, reversed, sorted, onSort, sortKey, currentSortKey, disabled }: ThProps) {
    const Icon = sorted && currentSortKey === sortKey ? (reversed ? IconChevronUp : IconChevronDown) : IconSelector;
    const isCurrent = sorted && currentSortKey === sortKey;
    return (
        <Table.Th className={classes.th}>
            <UnstyledButton onClick={disabled ? undefined : onSort} className={classes.control} disabled={disabled}>
                <Group justify="space-between" gap={0} data-active-sort={isCurrent || undefined}>
                    <Text fw={500} fz="sm" span>{children}</Text>
                    {!disabled && (
                        <Center className={classes.icon}>
                            <Icon style={{ width: rem(16), height: rem(16), color: isCurrent ? 'var(--mantine-color-blue-filled)' : undefined }} stroke={1.5} />
                        </Center>
                    )}
                </Group>
            </UnstyledButton>
        </Table.Th>
    );
}
// --- Fin Componente Th ---

// --- Props del Componente CustomerTable ---
interface CustomerTableProps {
    customers: Customer[];
    sortStatus: SortStatus;
    togglingFavoriteId: string | null;
    togglingActiveId?: string | null;
    selectedRows: string[];
    onSort: (column: SortColumn) => void;
    onToggleFavorite: (customerId: string, currentIsFavorite: boolean) => void;
    onOpenAdjustPoints: (customer: Customer) => void;
    onOpenChangeTier: (customer: Customer) => void;
    onOpenAssignReward: (customer: Customer) => void;
    onViewDetails: (customer: Customer) => void;
    onToggleActive: (customer: Customer) => void;
    onRowSelectionChange: (selectedIds: string[]) => void;
}
// --- Fin Props ---

// --- COMPONENTE PRINCIPAL: AdminCustomerTable ---
const CustomerTable: React.FC<CustomerTableProps> = ({
    customers,
    sortStatus,
    togglingFavoriteId,
    togglingActiveId,
    selectedRows,
    onSort,
    onToggleFavorite,
    onOpenAdjustPoints,
    onOpenChangeTier,
    onOpenAssignReward,
    onViewDetails,
    onToggleActive,
    onRowSelectionChange
}) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const theme = useMantineTheme();

    // L√≥gica de Selecci√≥n
    const allVisibleSelected = customers.length > 0 && customers.every(customer => selectedRows.includes(customer.id));
    const someVisibleSelected = customers.some(customer => selectedRows.includes(customer.id));
    const indeterminate = someVisibleSelected && !allVisibleSelected;

    const handleSelectAllClick = () => {
        if (allVisibleSelected) {
            const visibleIds = customers.map(c => c.id);
            onRowSelectionChange(selectedRows.filter(id => !visibleIds.includes(id)));
        } else {
            const visibleIds = customers.map(c => c.id);
            onRowSelectionChange(Array.from(new Set([...selectedRows, ...visibleIds])));
        }
    };

    const handleRowCheckboxChange = (customerId: string, checked: boolean) => {
        if (checked) { onRowSelectionChange([...selectedRows, customerId]); }
        else { onRowSelectionChange(selectedRows.filter(id => id !== customerId)); }
    };

    // Mapeo de filas
    const rows = customers.map((customer) => {
        const isActive = customer.isActive ?? false;
        // Usar t() para los t√≠tulos de los tooltips de activar/desactivar
        const ToggleIcon = isActive ? IconEyeOff : IconEyeCheck;
        const toggleTitle = isActive ? t('adminCustomersPage.tooltipDeactivateCustomer') : t('adminCustomersPage.tooltipActivateCustomer');
        const toggleColor = isActive ? 'red' : 'green';
        const isTogglingThisActive = togglingActiveId === customer.id;
        const isTogglingThisFavorite = togglingFavoriteId === customer.id;
        const isSelected = selectedRows.includes(customer.id);
        const favoriteTooltip = customer.isFavorite
            ? t('adminCustomersPage.tooltipUnfavorite', 'Quitar de Favoritos')
            : t('adminCustomersPage.tooltipFavorite', 'Marcar como Favorito');

        return (
            <Table.Tr key={customer.id} bg={isSelected ? theme.colors.blue[0] : undefined}>
                <Table.Td>
                    <Checkbox
                        aria-label={t('adminCustomersPage.checkboxAriaLabel', `Seleccionar fila ${customer.id}`)} // Nueva clave i18n
                        checked={isSelected}
                        onChange={(event) => handleRowCheckboxChange(customer.id, event.currentTarget.checked)}
                    />
                </Table.Td>
                <Table.Td>
                    <ActionIcon
                        variant="subtle"
                        onClick={() => onToggleFavorite(customer.id, customer.isFavorite ?? false)}
                        loading={isTogglingThisFavorite}
                        disabled={!!togglingFavoriteId || !!togglingActiveId}
                        title={favoriteTooltip} // Usar variable con clave i18n
                    >
                        <IconStar size={18} stroke={1.5} color={customer.isFavorite ? theme.colors.yellow[6] : theme.colors.gray[4]} fill={customer.isFavorite ? theme.colors.yellow[6] : 'none'} />
                    </ActionIcon>
                </Table.Td>
                <Table.Td>{customer.name || '-'}</Table.Td>
                <Table.Td>{customer.email}</Table.Td>
                <Table.Td ta="right">{customer.points}</Table.Td>
                <Table.Td>{customer.currentTier?.name || t('customerDashboard.baseTier')}</Table.Td>
                <Table.Td>{new Date(customer.createdAt).toLocaleDateString()}</Table.Td>
                <Table.Td> <Badge color={isActive ? 'green' : 'red'} variant="light"> {isActive ? t('common.active') : t('common.inactive')} </Badge> </Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        <ActionIcon variant="subtle" color="gray" title={t('adminCustomersPage.tooltipViewDetails')} onClick={() => onViewDetails(customer)} disabled={isTogglingThisActive || isTogglingThisFavorite}><IconEye size={16} stroke={1.5} /></ActionIcon>
                        <ActionIcon variant="subtle" color="blue" title={t('adminCustomersPage.tooltipAdjustPoints')} onClick={() => onOpenAdjustPoints(customer)} disabled={isTogglingThisActive || isTogglingThisFavorite}><IconAdjustments size={16} stroke={1.5} /></ActionIcon>
                        <ActionIcon variant="subtle" color="teal" title={t('adminCustomersPage.tooltipChangeTier')} onClick={() => onOpenChangeTier(customer)} disabled={isTogglingThisActive || isTogglingThisFavorite}><IconStairsUp size={16} stroke={1.5} /></ActionIcon>
                        <ActionIcon variant="subtle" color="grape" title={t('adminCustomersPage.tooltipAssignReward')} onClick={() => onOpenAssignReward(customer)} disabled={isTogglingThisActive || isTogglingThisFavorite}><IconGift size={16} stroke={1.5} /></ActionIcon>
                        <ActionIcon variant="subtle" color={toggleColor} title={toggleTitle} onClick={() => onToggleActive(customer)} loading={isTogglingThisActive} disabled={!!togglingFavoriteId || !!togglingActiveId}><ToggleIcon size={16} stroke={1.5} /></ActionIcon>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    // Renderizado de la tabla
    return (
        <Table.ScrollContainer minWidth={800}>
            <Table striped highlightOnHover withTableBorder verticalSpacing="sm" className={classes.table}>
                <Table.Thead className={classes.thead}>
                    <Table.Tr>
                        <Table.Th style={{ width: rem(40) }}>
                            <Checkbox
                                aria-label={t('adminCustomersPage.checkboxSelectAllAriaLabel', 'Seleccionar todas las filas visibles')} // Nueva clave i18n
                                checked={allVisibleSelected}
                                indeterminate={indeterminate}
                                onChange={handleSelectAllClick}
                            />
                        </Table.Th>
                        <Th sorted={sortStatus.column === 'isFavorite'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('isFavorite')} sortKey="isFavorite" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderFavorite')}</Th>
                        <Th sorted={sortStatus.column === 'name'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('name')} sortKey="name" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderName')}</Th>
                        <Th sorted={sortStatus.column === 'email'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('email')} sortKey="email" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderEmail')}</Th>
                        <Th sorted={sortStatus.column === 'points'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('points')} sortKey="points" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderPoints')}</Th>
                        <Th sorted={sortStatus.column === 'currentTier.level'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('currentTier.level')} sortKey="currentTier.level" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderTier')}</Th>
                        <Th sorted={sortStatus.column === 'createdAt'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('createdAt')} sortKey="createdAt" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderRegistered')}</Th>
                        <Th sorted={sortStatus.column === 'isActive'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('isActive')} sortKey="isActive" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderStatus')}</Th>
                        <Table.Th style={{ textAlign: 'right' }}>{t('adminCustomersPage.tableHeaderActions')}</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>{rows.length > 0 ? rows : (
                    <Table.Tr><Table.Td colSpan={9}><Text c="dimmed" ta="center">{t('adminCustomersPage.noResults')}</Text></Table.Td></Table.Tr>
                 )}</Table.Tbody>
            </Table>
        </Table.ScrollContainer>
    );
};

export default CustomerTable;


// ====== [62] frontend/src/modules/loyalpyme/components/admin/StatCard.module.css ======
/* filename: frontend/src/components/admin/StatCard.module.css */
.card {
    position: relative;
    overflow: hidden;
    background-color: var(--mantine-color-body); /* Asegura fondo */
  }
  
  .value {
    font-size: var(--mantine-font-size-xl); /* Usa variable Mantine o rem(24px) */
    font-weight: 700;
    line-height: 1.3; 
  }
  
  .label {
    font-size: var(--mantine-font-size-xs);
    line-height: var(--mantine-line-height-xs);
    color: var(--mantine-color-dimmed);
    text-transform: uppercase; /* A√±adido para coincidir con dise√±o com√∫n */
  }


// ====== [63] frontend/src/modules/loyalpyme/components/admin/StatCard.test.tsx ======
// filename: frontend/src/components/admin/StatCard.test.tsx
// Version: 1.0.2 (Import screen directly from @testing-library/dom)

import React from 'react';
// --- CAMBIO: Importar render y screen por separado ---
import { render } from '@testing-library/react';
import { screen } from '@testing-library/dom';
// --- FIN CAMBIO ---
import { describe, it, expect } from 'vitest';
import StatCard from './StatCard';
import { IconUsers } from '@tabler/icons-react';
import { MantineProvider } from '@mantine/core';
import { theme } from '../../theme';

describe('StatCard Component', () => {

    const renderWithTheme = (ui: React.ReactElement) => {
        return render(<MantineProvider theme={theme}>{ui}</MantineProvider>);
    };

    it('should render title and value correctly', () => {
        renderWithTheme(<StatCard title="CLIENTES" value={123} />);
        expect(screen.getByText('CLIENTES')).toBeInTheDocument();
        expect(screen.getByText('123')).toBeInTheDocument();
    });

    it('should render icon when provided', () => {
        renderWithTheme(<StatCard title="Test" value={10} icon={<IconUsers data-testid="users-icon" size={24}/>} />);
        expect(screen.getByTestId('users-icon')).toBeInTheDocument();
    });

    it('should render "-" when value is null or undefined', () => {
        const { rerender } = renderWithTheme(<StatCard title="Test Null" value={null} />);
        expect(screen.getByText('-')).toBeInTheDocument();

        rerender(<MantineProvider theme={theme}><StatCard title="Test Undefined" value={undefined} /></MantineProvider>);
        expect(screen.getByText('-')).toBeInTheDocument();
    });

    it('should render trend up icon and value correctly', () => {
        renderWithTheme(<StatCard title="Trend Up" value={100} trendValue="+10.5%" trendDirection="up" />);
        expect(screen.getByText('+10.5%')).toBeInTheDocument();
    });

    it('should render trend down icon and value correctly', () => {
        renderWithTheme(<StatCard title="Trend Down" value={90} trendValue="-5.0%" trendDirection="down" />);
        expect(screen.getByText('-5.0%')).toBeInTheDocument();
    });

     it('should render neutral trend value without arrow', () => {
        const { rerender } = renderWithTheme(<StatCard title="Trend Neutral" value={100} trendValue="N/A" trendDirection="neutral" />);
        expect(screen.getByText('N/A')).toBeInTheDocument();

        rerender(<MantineProvider theme={theme}><StatCard title="Trend Zero" value={100} trendValue="+0.0%" trendDirection="neutral" /></MantineProvider>);
        expect(screen.getByText('+0.0%')).toBeInTheDocument();
    });

    it('should not render trend section if trendValue is null/undefined', () => {
        renderWithTheme(<StatCard title="No Trend" value={100} trendValue={null} trendDirection="neutral" />);
        expect(screen.queryByText(/%/)).not.toBeInTheDocument();
        expect(screen.queryByText('+')).not.toBeInTheDocument();
    });

    it('should display skeletons when loading', () => {
        renderWithTheme(<StatCard title="Loading Test" value={null} loading={true} />);
        expect(screen.queryByText(/-/)).not.toBeInTheDocument();
        expect(screen.getByText('Loading Test')).toBeInTheDocument();
    });

});


// ====== [64] frontend/src/modules/loyalpyme/components/admin/StatCard.tsx ======
// filename: frontend/src/components/admin/StatCard.tsx
import React from 'react';
import { Paper, Group, Text, ThemeIcon, Skeleton, MantineColor, useMantineTheme, Stack } from '@mantine/core';
import { IconArrowUpRight, IconArrowDownRight } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import classes from './StatCard.module.css';

// Tipo para la direcci√≥n de la tendencia
type TrendDirection = 'up' | 'down' | 'neutral';

// Props que acepta nuestro componente StatCard
interface StatCardProps {
  title: string;
  value: number | string | null | undefined;
  icon?: React.ReactNode;
  loading?: boolean;
  color?: MantineColor;
  trendValue?: string | null | undefined; // Aseguramos que trendValue siempre sea string o null/undefined
  trendDirection?: TrendDirection | null | undefined;
}

const StatCard: React.FC<StatCardProps> = ({
  title,
  value,
  icon,
  loading,
  color = 'gray',
  trendValue, // Recibe el string formateado o null/undefined desde el hook
  trendDirection,
}) => {
  const { i18n } = useTranslation(); // Solo para i18n.language
  const theme = useMantineTheme();

  // Formateo del valor principal (sin cambios)
  const displayValue = loading || value === null || value === undefined
    ? '-'
    : typeof value === 'number' ? value.toLocaleString(i18n.language) : value;

  // Determinar icono y color de la tendencia (sin cambios)
  let TrendIcon = null;
  let trendColor: MantineColor = 'dimmed';
  if (trendDirection === 'up') {
    TrendIcon = IconArrowUpRight;
    trendColor = 'teal';
  } else if (trendDirection === 'down') {
    TrendIcon = IconArrowDownRight;
    trendColor = 'red';
  }

  // **CORRECCI√ìN:** No necesitamos formatear `trendValue` aqu√≠, ya viene formateado.
  // Simplemente comprobamos si existe para renderizar la secci√≥n de tendencia.
  const displayTrendValue = trendValue; // Usamos directamente el valor recibido
  const renderTrend = displayTrendValue !== null && displayTrendValue !== undefined && trendDirection;

  return (
    <Paper withBorder p="md" radius="md" className={classes.card}>
      <Group justify="space-between" wrap="nowrap" align="flex-start">
        <Stack gap={0}>
          <Text c="dimmed" tt="uppercase" fw={700} fz="xs" className={classes.label}>
            {title}
          </Text>
          {loading ? (
            <Skeleton height={28} mt={5} width={70} />
          ) : (
             <Text fw={700} fz="xl" className={classes.value} c={color}>
               {displayValue}
             </Text>
          )}
        </Stack>

        {icon && !loading && (
          <ThemeIcon color={color} variant="light" size={38} radius="md">
            {icon}
          </ThemeIcon>
        )}
         {loading && (
            <Skeleton height={38} width={38} radius="md" />
         )}
      </Group>

      {/* Mostramos la tendencia si renderTrend es true */}
      {!loading && renderTrend && (
           <Group gap={4} mt={5} wrap="nowrap">
               {TrendIcon && <TrendIcon size={16} stroke={1.5} color={theme.colors[trendColor][6]} />}
               <Text c={trendColor} fz="xs" fw={500}>
                   {displayTrendValue} {/* Mostramos el string directamente */}
               </Text>
           </Group>
      )}
    </Paper>
  );
};

export default StatCard;


// ====== [65] frontend/src/modules/loyalpyme/components/admin/rewards/RewardForm.tsx ======
// frontend/src/components/admin/rewards/RewardForm.tsx
// Version 2.0.2 (Remove unused imports)

import { useState, useEffect } from 'react';
import {
    TextInput, Textarea, NumberInput, Button, Stack, Group, Text as MantineText
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import axiosInstance from '../../../../../shared/services/axiosInstance';
import type { Reward } from '../../../../../shared/types/user.types';

// Importar el nuevo componente reutilizable
import ImageUploadCropper from '../../../../../shared/components/utils/ImageUploadCropper';

// Schema de Zod para la validaci√≥n del formulario
const createRewardFormSchema = (t: Function) => z.object({
  name_es: z.string().min(1, { message: t('component.rewardForm.errorNameEsRequired') }),
  name_en: z.string().min(1, { message: t('component.rewardForm.errorNameEnRequired') }),
  description_es: z.string().optional(),
  description_en: z.string().optional(),
  pointsCost: z.number().min(0, { message: t('component.rewardForm.errorPointsCostInvalid') }),
  imageUrl: z.string().url({ message: t('validation.invalidUrl') }).nullable().optional(),
});

type RewardFormValues = z.infer<ReturnType<typeof createRewardFormSchema>>;

interface RewardFormProps {
    mode: 'add' | 'edit';
    initialData?: Reward | null;
    rewardIdToUpdate?: string | null;
    onSubmitSuccess: () => void;
    onCancel: () => void;
}

const RewardForm: React.FC<RewardFormProps> = ({
    mode, initialData, rewardIdToUpdate, onSubmitSuccess, onCancel
}) => {
    const { t } = useTranslation();
    const [isSubmitting, setIsSubmitting] = useState<boolean>(false);

    const form = useForm<RewardFormValues>({
        initialValues: {
            name_es: '', name_en: '', description_es: '', description_en: '',
            pointsCost: 0, imageUrl: null,
        },
        validate: zodResolver(createRewardFormSchema(t)),
    });

    useEffect(() => {
        if (mode === 'edit' && initialData) {
            form.setValues({
                name_es: initialData.name_es || '',
                name_en: initialData.name_en || '',
                description_es: initialData.description_es || '',
                description_en: initialData.description_en || '',
                pointsCost: initialData.pointsCost ?? 0,
                imageUrl: initialData.imageUrl || null,
            });
        } else {
            form.reset();
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [mode, initialData]);

    const handleSubmit = async (values: RewardFormValues) => {
        setIsSubmitting(true);
        const payload = {
            ...values,
            description_es: values.description_es?.trim() || null,
            description_en: values.description_en?.trim() || null,
        };
        
        try {
            let successMessage = '';
            let savedReward: Reward | null = null;
            if (mode === 'add') {
                const response = await axiosInstance.post<Reward>('/rewards', payload);
                savedReward = response.data;
                successMessage = t('adminRewardsPage.createSuccessMessage', { name: savedReward.name_es });
            } else {
                if (!rewardIdToUpdate) throw new Error(t('component.rewardForm.errorMissingIdForUpdate'));
                const response = await axiosInstance.patch<Reward>(`/rewards/${rewardIdToUpdate}`, payload);
                savedReward = response.data;
                successMessage = t('adminRewardsPage.updateSuccessMessage', { name: savedReward.name_es });
            }
            
            notifications.show({
                title: t('common.success'),
                message: successMessage,
                color: 'green', icon: <IconCheck size={18} />,
            });
            onSubmitSuccess();
        } catch (err: any) {
            const errorMessage = err.response?.data?.message || err.message || t('common.errorUnknown');
            notifications.show({
                title: t('common.error'),
                message: errorMessage,
                color: 'red', icon: <IconX size={18} />,
            });
        } finally {
            setIsSubmitting(false);
        }
    };

    const submitButtonText = mode === 'add' ? t('adminRewardsPage.addButton') : t('common.save');

    return (
        <Stack gap="md">
            <form onSubmit={form.onSubmit(handleSubmit)}>
                <Stack gap="md">
                    <TextInput label={t('component.rewardForm.nameEsLabel')} placeholder={t('component.rewardForm.nameEsPlaceholder')} required disabled={isSubmitting} {...form.getInputProps('name_es')} />
                    <TextInput label={t('component.rewardForm.nameEnLabel')} placeholder={t('component.rewardForm.nameEnPlaceholder')} required disabled={isSubmitting} {...form.getInputProps('name_en')} />
                    <Textarea label={t('component.rewardForm.descriptionEsLabel')} placeholder={t('component.rewardForm.descriptionEsPlaceholder')} rows={2} disabled={isSubmitting} {...form.getInputProps('description_es')} />
                    <Textarea label={t('component.rewardForm.descriptionEnLabel')} placeholder={t('component.rewardForm.descriptionEnPlaceholder')} rows={2} disabled={isSubmitting} {...form.getInputProps('description_en')} />
                    <NumberInput label={t('component.rewardForm.pointsCostLabel')} placeholder={t('component.rewardForm.pointsCostPlaceholder')} min={0} step={1} required disabled={isSubmitting} {...form.getInputProps('pointsCost')} />
                    
                    {/* Componente reutilizable de subida y recorte */}
                    <ImageUploadCropper
                        aspectRatio={1}
                        minDimension={150}
                        initialImageUrl={form.values.imageUrl || null}
                        onUploadSuccess={(url) => form.setFieldValue('imageUrl', url)}
                        onUploadError={(errorMsg) => form.setFieldError('imageUrl', errorMsg)}
                        onClearImage={() => form.setFieldValue('imageUrl', null)}
                        folderName="loyalpyme/rewards"
                        disabled={isSubmitting}
                        imagePreviewAltText={t('component.rewardForm.altImagePreview', { name: form.values.name_es })}
                    />
                    {form.errors.imageUrl && (
                        <MantineText c="red" size="xs" mt={-10}>{form.errors.imageUrl}</MantineText>
                    )}

                    <Group justify="flex-end" mt="md">
                        <Button variant="light" onClick={onCancel} disabled={isSubmitting}> {t('common.cancel')} </Button>
                        <Button type="submit" loading={isSubmitting}> {submitButtonText} </Button>
                    </Group>
                </Stack>
            </form>
        </Stack>
    );
};

export default RewardForm;


// ====== [66] frontend/src/modules/loyalpyme/components/admin/tiers/AddTierBenefitForm.tsx ======
// filename: frontend/src/components/admin/tiers/AddTierBenefitForm.tsx
import React from 'react';
import { TextInput, Textarea, Select, Switch, Stack } from '@mantine/core';
import { UseFormReturnType } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next'; // Importar hook

// --- Tipos/Enums ---
export enum BenefitType {
    POINTS_MULTIPLIER = 'POINTS_MULTIPLIER',
    EXCLUSIVE_REWARD_ACCESS = 'EXCLUSIVE_REWARD_ACCESS',
    CUSTOM_BENEFIT = 'CUSTOM_BENEFIT'
}

// Este schema no se usa directamente aqu√≠ para validar, pero define el tipo
const benefitFormSchema = z.object({
    type: z.nativeEnum(BenefitType),
    value: z.string().min(1),
    description: z.string().optional(),
    isActive: z.boolean(),
});
export type BenefitFormValues = z.infer<typeof benefitFormSchema>;
// --- Fin Tipos/Enums ---


// --- Props del Componente ---
interface AddTierBenefitFormProps {
    form: UseFormReturnType<BenefitFormValues>;
    isSubmitting: boolean;
}
// --- Fin Props ---

const AddTierBenefitForm: React.FC<AddTierBenefitFormProps> = ({ form, isSubmitting }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n

    // Las etiquetas para las opciones del Select se generan en el componente padre (TierBenefitsModal)
    // usando t(), aqu√≠ solo necesitamos los valores del enum.
    const typeOptions = Object.values(BenefitType).map(value => ({
        value: value,
        label: t(`component.addTierBenefitForm.benefitType_${value}`) // Usar t() para la etiqueta si fuera necesario aqu√≠, pero se hace en el padre
    }));

    return (
        <Stack gap="sm">
            <Select
                label={t('component.addTierBenefitForm.typeLabel')}
                placeholder={t('component.addTierBenefitForm.typePlaceholder')}
                data={typeOptions} // Las etiquetas ya vienen traducidas del padre
                required
                disabled={isSubmitting}
                {...form.getInputProps('type')}
            />
            <TextInput
                label={t('component.addTierBenefitForm.valueLabel')}
                placeholder={t('component.addTierBenefitForm.valuePlaceholder')}
                description={t('component.addTierBenefitForm.valueDescription')}
                required
                disabled={isSubmitting}
                {...form.getInputProps('value')}
            />
            <Textarea
                label={t('component.addTierBenefitForm.descriptionLabel')}
                placeholder={t('component.addTierBenefitForm.descriptionPlaceholder')}
                rows={2}
                disabled={isSubmitting}
                {...form.getInputProps('description')}
            />
            <Switch
                label={t('component.addTierBenefitForm.activeLabel')}
                disabled={isSubmitting}
                {...form.getInputProps('isActive', { type: 'checkbox' })}
            />
        </Stack>
    );
};

export default AddTierBenefitForm;


// ====== [67] frontend/src/modules/loyalpyme/components/admin/tiers/CreateTierModal.tsx ======
// filename: frontend/src/components/admin/tiers/CreateTierModal.tsx
import React, { useState } from 'react';
import { Modal, Button, Group } from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { notifications } from '@mantine/notifications';
import { IconDeviceFloppy, IconCheck, IconAlertCircle } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';
import TierForm from './TierForm'; // Este componente tambi√©n necesitar√° i18n
import { useTranslation } from 'react-i18next'; // Importar hook

// Tipos
interface Tier { id: string; name: string; level: number; /* ... otros campos si los devuelve la API ... */ }

// Funci√≥n para crear el esquema Zod, aceptando t
const createTierFormSchema = (t: Function) => z.object({
    name: z.string().min(1, { message: t('validation.nameRequired', 'El nombre es obligatorio') }),
    level: z.number().int().min(0, { message: t('validation.levelMin0', 'El nivel debe ser 0 o mayor') }),
    minValue: z.number().min(0, { message: t('validation.minValueMin0', 'El valor m√≠nimo debe ser 0 o mayor') }),
    description: z.string().optional(),
    benefitsDescription: z.string().optional(),
    isActive: z.boolean(),
});

// Tipo inferido del schema
type TierFormValues = z.infer<ReturnType<typeof createTierFormSchema>>;

// Props
interface CreateTierModalProps {
    opened: boolean;
    onClose: () => void;
    onSuccess: (newTier: Tier) => void;
}

const CreateTierModal: React.FC<CreateTierModalProps> = ({ opened, onClose, onSuccess }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [isCreating, setIsCreating] = useState<boolean>(false);

    // useForm - pasar t al resolver
    const form = useForm<TierFormValues>({
        initialValues: { name: '', level: 0, minValue: 0, description: '', benefitsDescription: '', isActive: true, },
        validate: zodResolver(createTierFormSchema(t)),
    });

    // handleSubmit
    const handleSubmit = async (values: TierFormValues) => {
        setIsCreating(true);
        try {
            const response = await axiosInstance.post<Tier>('/tiers/tiers', values);
            notifications.show({
                title: t('adminTiersManagePage.createSuccessTitle'),
                message: t('adminTiersManagePage.createSuccessMessage', { name: response.data.name }),
                color: 'green',
                icon: <IconCheck size={18} />
            });
            form.reset();
            onSuccess(response.data);
            onClose();
        } catch (err: any) {
            console.error("Error creating tier:", err);
            const apiError = err.response?.data?.message || t('adminTiersManagePage.createErrorMessage');
            notifications.show({
                title: t('adminTiersManagePage.createErrorTitle'),
                message: apiError,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
        } finally {
            setIsCreating(false);
        }
    };

    // handleClose
    const handleClose = () => { form.reset(); onClose(); }

    // JSX
    return (
        <Modal
            opened={opened}
            onClose={handleClose}
            title={t('adminTiersManagePage.createModalTitle')} // Usar t() para el t√≠tulo
            centered
            size="md"
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            <form onSubmit={form.onSubmit(handleSubmit)}>
                {/* TierForm necesita i18n internamente */}
                <TierForm form={form} />
                <Group justify="flex-end" mt="lg">
                    <Button variant="default" onClick={handleClose} disabled={isCreating}>{t('common.cancel')}</Button>
                    <Button type="submit" loading={isCreating} leftSection={<IconDeviceFloppy size={18} />}>
                        {/* Reutilizamos la clave del bot√≥n de la p√°gina principal */}
                        {t('adminTiersManagePage.addButton')}
                    </Button>
                </Group>
            </form>
        </Modal>
    );
};

export default CreateTierModal;


// ====== [68] frontend/src/modules/loyalpyme/components/admin/tiers/DeleteTierModal.tsx ======
// filename: frontend/src/components/admin/tiers/DeleteTierModal.tsx
import React from 'react';
import { Modal, Text, Button, Group } from '@mantine/core';
import { useTranslation } from 'react-i18next'; // Importar hook

// --- Props del Componente ---
interface DeleteTierModalProps {
    opened: boolean;
    onClose: () => void;
    onConfirm: () => void;
    tierName?: string | null;
    loading?: boolean;
}
// --- Fin Props ---

const DeleteTierModal: React.FC<DeleteTierModalProps> = ({ opened, onClose, onConfirm, tierName, loading }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n

    return (
        <Modal
            opened={opened}
            onClose={onClose}
            title={t('adminTiersManagePage.deleteModalTitle')} // Usar t() para el t√≠tulo
            centered
            size="sm"
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            {/* Usar t() para el mensaje, pasando el nombre del tier */}
            <Text size="sm">
                {t('adminTiersManagePage.deleteModalMessage', { name: tierName || '' })}
            </Text>
            <Group justify="flex-end" mt="lg">
                <Button variant="default" onClick={onClose} disabled={loading}>
                    {t('common.cancel')}
                </Button>
                <Button color="red" onClick={onConfirm} loading={loading}>
                    {t('adminTiersManagePage.deleteModalConfirm')}
                </Button>
            </Group>
        </Modal>
    );
};

export default DeleteTierModal;


// ====== [69] frontend/src/modules/loyalpyme/components/admin/tiers/EditTierModal.tsx ======
// filename: frontend/src/components/admin/tiers/EditTierModal.tsx
import React, { useState, useEffect } from 'react';
import { Modal, Button, Group } from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { notifications } from '@mantine/notifications';
import { IconDeviceFloppy, IconCheck, IconAlertCircle } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';
import TierForm from './TierForm'; // Este componente tambi√©n necesita i18n
import { useTranslation } from 'react-i18next'; // Importar hook

// --- Tipos ---
interface Tier {
    id: string;
    name: string;
    level: number;
    minValue: number;
    description: string | null;
    benefitsDescription: string | null;
    isActive: boolean;
}

// Funci√≥n para crear el esquema Zod, aceptando t
const createTierFormSchema = (t: Function) => z.object({
    name: z.string().min(1, { message: t('validation.nameRequired', 'El nombre es obligatorio') }),
    level: z.number().int().min(0, { message: t('validation.levelMin0', 'El nivel debe ser 0 o mayor') }),
    minValue: z.number().min(0, { message: t('validation.minValueMin0', 'El valor m√≠nimo debe ser 0 o mayor') }),
    description: z.string().optional(),
    benefitsDescription: z.string().optional(),
    isActive: z.boolean(),
});

type TierFormValues = z.infer<ReturnType<typeof createTierFormSchema>>;
// --- Fin Tipos ---

// --- Props del Componente ---
interface EditTierModalProps {
    opened: boolean;
    onClose: () => void;
    onSuccess: () => void;
    tier: Tier | null;
}
// --- Fin Props ---

const EditTierModal: React.FC<EditTierModalProps> = ({ opened, onClose, onSuccess, tier }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [isSaving, setIsSaving] = useState<boolean>(false);

    const form = useForm<TierFormValues>({
        initialValues: {
            name: '', level: 0, minValue: 0, description: '',
            benefitsDescription: '', isActive: true,
        },
        validate: zodResolver(createTierFormSchema(t)), // Pasar t al resolver
    });

    useEffect(() => {
        if (tier && opened) {
            form.setValues({
                name: tier.name,
                level: tier.level,
                minValue: tier.minValue,
                description: tier.description ?? '',
                benefitsDescription: tier.benefitsDescription ?? '',
                isActive: tier.isActive,
            });
        } else if (!opened) {
            form.reset();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [tier, opened]);

    const handleSubmit = async (values: TierFormValues) => {
        if (!tier) return;
        setIsSaving(true);
        try {
            await axiosInstance.put(`/tiers/tiers/${tier.id}`, values);
            notifications.show({
                title: t('adminTiersManagePage.updateSuccessTitle'),
                message: t('adminTiersManagePage.updateSuccessMessage', { name: values.name }),
                color: 'green',
                icon: <IconCheck size={18} />
            });
            onSuccess();
            onClose();
        } catch (err: any) {
            console.error(`Error updating tier ${tier.id}:`, err);
            const apiError = err.response?.data?.message || t('adminTiersManagePage.updateErrorMessage');
            notifications.show({
                title: t('adminTiersManagePage.updateErrorTitle'),
                message: apiError,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
        } finally {
            setIsSaving(false);
        }
    };

    const handleClose = () => {
        onClose();
    }

    return (
        <Modal
            opened={opened}
            onClose={handleClose}
            // Usar t() para el t√≠tulo
            title={t('adminTiersManagePage.editModalTitle', { name: tier?.name || '' })}
            centered
            size="md"
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            <form onSubmit={form.onSubmit(handleSubmit)}>
                {/* TierForm necesita i18n internamente */}
                <TierForm form={form} />
                <Group justify="flex-end" mt="lg">
                    <Button variant="default" onClick={handleClose} disabled={isSaving}>{t('common.cancel')}</Button>
                    <Button type="submit" loading={isSaving} leftSection={<IconDeviceFloppy size={18} />}>
                        {t('common.save')}
                    </Button>
                </Group>
            </form>
        </Modal>
    );
};

export default EditTierModal;


// ====== [70] frontend/src/modules/loyalpyme/components/admin/tiers/TierBenefitsModal.tsx ======
// filename: frontend/src/components/admin/tiers/TierBenefitsModal.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
    Modal, Title, Text, Stack, Group, Button, Loader, Alert, Table, ActionIcon,
    Divider, Box, Badge
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next'; // Importar hook
import AddTierBenefitForm, { BenefitFormValues, BenefitType } from './AddTierBenefitForm'; // Este componente tambi√©n necesita i18n
import { notifications } from '@mantine/notifications';
import { IconPencil, IconTrash, IconAlertCircle, IconCheck } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';

// --- Tipos ---
interface TierBenefit { id: string; type: BenefitType; value: string; description: string | null; isActive: boolean; }
interface Tier { id: string; name: string; }

// --- Funci√≥n para crear Schema Zod con t() ---
const createBenefitFormSchema = (t: Function) => z.object({
    type: z.nativeEnum(BenefitType, { errorMap: () => ({ message: t('validation.benefitTypeRequired', 'Selecciona un tipo de beneficio v√°lido.') }) }),
    value: z.string().min(1, { message: t('component.addTierBenefitForm.errorValueRequired', 'El valor es obligatorio') }), // Usando clave del componente hijo (deber√≠a estar all√≠)
    description: z.string().optional(),
    isActive: z.boolean(),
});
// --- FIN ---

// --- Props ---
interface TierBenefitsModalProps {
    opened: boolean;
    onClose: () => void;
    tier: Tier | null;
}
// --- Fin Props ---

const TierBenefitsModal: React.FC<TierBenefitsModalProps> = ({ opened, onClose, tier }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [benefits, setBenefits] = useState<TierBenefit[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);
    const [isSubmitting, setIsSubmitting] = useState<boolean>(false);

    // Definir etiquetas de tipos de beneficio usando t()
    const benefitTypeLabels: Record<BenefitType, string> = {
        [BenefitType.POINTS_MULTIPLIER]: t('component.addTierBenefitForm.benefitType_POINTS_MULTIPLIER'),
        [BenefitType.EXCLUSIVE_REWARD_ACCESS]: t('component.addTierBenefitForm.benefitType_EXCLUSIVE_REWARD_ACCESS'),
        [BenefitType.CUSTOM_BENEFIT]: t('component.addTierBenefitForm.benefitType_CUSTOM_BENEFIT')
    };

    // useForm usa el schema con t()
    const form = useForm<BenefitFormValues>({
        initialValues: { type: BenefitType.CUSTOM_BENEFIT, value: '', description: '', isActive: true, },
        validate: zodResolver(createBenefitFormSchema(t)),
    });

    // Cargar beneficios
    const fetchBenefits = useCallback(async () => {
        if (!tier?.id || !opened) { setBenefits([]); return; }
        setLoading(true); setError(null);
        try {
            const response = await axiosInstance.get<TierBenefit[]>(`/tiers/tiers/${tier.id}/benefits`);
            setBenefits(response.data);
        } catch (err: any) {
            console.error(`Error fetching benefits for tier ${tier.id}:`, err);
            const message = err.response?.data?.message || t('component.tierBenefitsModal.errorLoading');
            setError(message);
            notifications.show({
                title: t('common.errorLoadingData'), // T√≠tulo gen√©rico
                message,
                color: 'red',
                icon: <IconAlertCircle />
            });
        } finally { setLoading(false); }
    }, [tier?.id, opened, t]); // A√±adir t como dependencia

    useEffect(() => { fetchBenefits(); }, [fetchBenefits]);

    // Handler para A√ëADIR beneficio
    const handleAddBenefit = async (values: BenefitFormValues) => {
        if (!tier?.id) return;
        setIsSubmitting(true);
        try {
            await axiosInstance.post(`/tiers/tiers/${tier.id}/benefits`, values);
            notifications.show({
                title: t('component.tierBenefitsModal.addSuccessTitle'),
                message: t('component.tierBenefitsModal.addSuccessMessage'),
                color: 'green',
                icon: <IconCheck />
            });
            form.reset();
            fetchBenefits();
        } catch (err: any) {
            console.error(`Error adding benefit to tier ${tier.id}:`, err);
            notifications.show({
                title: t('component.tierBenefitsModal.addErrorTitle'),
                message: err.response?.data?.message || t('component.tierBenefitsModal.addErrorMessage'),
                color: 'red',
                icon: <IconAlertCircle />
            });
        } finally { setIsSubmitting(false); }
    };

    // Handlers para Editar/Eliminar (Placeholders con t())
    const handleEditBenefit = (benefit: TierBenefit) => {
        console.log("TODO: Edit benefit", benefit);
        notifications.show({
            title: t('common.upcomingFeatureTitle', 'Pr√≥ximamente'), // Nueva clave
            message: t('component.tierBenefitsModal.editUpcoming'),
            color: 'blue'
        });
    };
    const handleDeleteBenefit = async (benefitId: string) => {
        console.log("TODO: Delete benefit", benefitId);
        notifications.show({
            title: t('common.upcomingFeatureTitle', 'Pr√≥ximamente'), // Nueva clave
            message: t('component.tierBenefitsModal.deleteUpcoming'),
            color: 'blue'
        });
    };

    // Filas tabla beneficios (Usa benefitTypeLabels local con t())
    const benefitRows = benefits.map((benefit) => (
        <Table.Tr key={benefit.id}>
            <Table.Td>{benefitTypeLabels[benefit.type] || benefit.type}</Table.Td>
            <Table.Td><Text size="sm" truncate style={{ maxWidth: 150 }}>{benefit.value}</Text></Table.Td>
            <Table.Td><Text size="sm" truncate style={{ maxWidth: 200 }}>{benefit.description || '-'}</Text></Table.Td>
            <Table.Td>
                <Badge color={benefit.isActive ? 'green' : 'gray'} variant="light">
                    {benefit.isActive ? t('common.active') : t('common.inactive')}
                </Badge>
            </Table.Td>
            <Table.Td>
                <Group gap="xs" wrap="nowrap">
                    <ActionIcon variant="subtle" color="blue" onClick={() => handleEditBenefit(benefit)} title={t('component.tierBenefitsModal.tooltipEditBenefit')}>
                        <IconPencil size={16} />
                    </ActionIcon>
                    <ActionIcon variant="subtle" color="red" onClick={() => handleDeleteBenefit(benefit.id)} title={t('component.tierBenefitsModal.tooltipDeleteBenefit')}>
                        <IconTrash size={16} />
                    </ActionIcon>
                </Group>
            </Table.Td>
        </Table.Tr>
    ));

    // JSX Modal
    return (
        <Modal
            opened={opened}
            onClose={() => { form.reset(); onClose(); }}
            // Usar t() para el t√≠tulo
            title={t('component.tierBenefitsModal.modalTitle', { name: tier?.name || '...' })}
            size="xl" centered
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            <Stack gap="lg">
                {/* Secci√≥n a√±adir */}
                <Box>
                    <Title order={4} mb="sm">{t('component.tierBenefitsModal.addSectionTitle')}</Title>
                    <form onSubmit={form.onSubmit(handleAddBenefit)}>
                        {/* AddTierBenefitForm necesita i18n internamente */}
                        <AddTierBenefitForm form={form} isSubmitting={isSubmitting} />
                        <Group justify="flex-end" mt="md">
                            <Button type="submit" loading={isSubmitting} size="sm">
                                {t('component.tierBenefitsModal.addBenefitButton')}
                            </Button>
                        </Group>
                    </form>
                </Box>

                <Divider my="sm" />

                {/* Secci√≥n listar beneficios */}
                <Box>
                    <Title order={4} mb="sm">{t('component.tierBenefitsModal.listSectionTitle')}</Title>
                    {loading && <Group justify="center"><Loader size="sm" /></Group>}
                    {error && !loading &&
                        <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>
                            {error}
                        </Alert>
                    }
                    {!loading && !error && benefits.length === 0 && (
                        <Text c="dimmed" ta="center">{t('component.tierBenefitsModal.noBenefits')}</Text>
                    )}
                    {!loading && !error && benefits.length > 0 && (
                        <Table.ScrollContainer minWidth={500}>
                            <Table striped highlightOnHover withTableBorder withColumnBorders verticalSpacing="sm">
                                <Table.Thead>
                                    <Table.Tr>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderType')}</Table.Th>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderValue')}</Table.Th>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderDescription')}</Table.Th>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderStatus')}</Table.Th>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderActions')}</Table.Th>
                                    </Table.Tr>
                                </Table.Thead>
                                <Table.Tbody>{benefitRows}</Table.Tbody>
                            </Table>
                        </Table.ScrollContainer>
                    )}
                </Box>

                {/* Bot√≥n cerrar */}
                <Group justify="flex-end" mt="lg">
                    <Button variant="default" onClick={() => { form.reset(); onClose(); }}>{t('common.close')}</Button>
                </Group>
            </Stack>
        </Modal>
    );
};

export default TierBenefitsModal;


// ====== [71] frontend/src/modules/loyalpyme/components/admin/tiers/TierForm.tsx ======
// filename: frontend/src/components/admin/tiers/TierForm.tsx
import React from 'react';
import { TextInput, NumberInput, Textarea, Switch, Stack } from '@mantine/core';
import { UseFormReturnType } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next'; // Importar hook

// --- Tipos ---
// Esquema Zod (no necesita 't' aqu√≠ ya que los mensajes se definen en el componente padre)
const tierFormSchema = z.object({
    name: z.string().min(1),
    level: z.number().int().min(0),
    minValue: z.number().min(0),
    description: z.string().optional(),
    benefitsDescription: z.string().optional(),
    isActive: z.boolean(),
});

export type TierFormValues = z.infer<typeof tierFormSchema>;
// --- Fin Tipos ---

// --- Props del Componente ---
interface TierFormProps {
    form: UseFormReturnType<TierFormValues>;
    disabled?: boolean;
}
// --- Fin Props ---

const TierForm: React.FC<TierFormProps> = ({ form, disabled }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n

    return (
        <Stack gap="md">
            <TextInput
                label={t('component.tierForm.nameLabel')}
                placeholder={t('component.tierForm.namePlaceholder')}
                required
                disabled={disabled}
                {...form.getInputProps('name')}
            />
            <NumberInput
                label={t('component.tierForm.levelLabel')}
                placeholder={t('component.tierForm.levelPlaceholder')}
                description={t('component.tierForm.levelDescription')}
                required
                min={0}
                step={1}
                allowDecimal={false}
                disabled={disabled}
                {...form.getInputProps('level')}
            />
            <NumberInput
                label={t('component.tierForm.minValueLabel')}
                placeholder={t('component.tierForm.minValuePlaceholder')}
                description={t('component.tierForm.minValueDescription')}
                required
                min={0}
                decimalScale={2} // Permite decimales para gasto, pero step=1 si es para visitas/puntos
                // step={1} // Considera ajustar esto seg√∫n la l√≥gica de minValue
                disabled={disabled}
                {...form.getInputProps('minValue')}
            />
            <Textarea
                label={t('component.tierForm.descriptionLabel')}
                placeholder={t('component.tierForm.descriptionPlaceholder')}
                rows={2}
                disabled={disabled}
                {...form.getInputProps('description')}
            />
            <Textarea
                label={t('component.tierForm.benefitsDescriptionLabel')}
                placeholder={t('component.tierForm.benefitsDescriptionPlaceholder')}
                rows={3}
                disabled={disabled}
                {...form.getInputProps('benefitsDescription')}
            />
            <Switch
                label={t('component.tierForm.activeLabel')}
                description={t('component.tierForm.activeDescription')}
                mt="sm"
                disabled={disabled}
                {...form.getInputProps('isActive', { type: 'checkbox' })}
            />
        </Stack>
    );
};

export default TierForm;


// ====== [72] frontend/src/modules/loyalpyme/components/admin/tiers/TierTable.tsx ======
// filename: frontend/src/components/admin/tiers/TierTable.tsx
import React from 'react';
import { Table, Group, ActionIcon, Badge, Text } from '@mantine/core';
import { IconPencil, IconTrash, IconListDetails } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next'; // Importar hook

// Tipos
enum BenefitType { POINTS_MULTIPLIER = 'POINTS_MULTIPLIER', EXCLUSIVE_REWARD_ACCESS = 'EXCLUSIVE_REWARD_ACCESS', CUSTOM_BENEFIT = 'CUSTOM_BENEFIT' }
interface TierBenefit { id: string; isActive: boolean; type: BenefitType; value: string; description: string | null; }
interface Tier { id: string; name: string; level: number; minValue: number; description: string | null; benefitsDescription: string | null; isActive: boolean; benefits: TierBenefit[]; }

// Props
interface TierTableProps {
    tiers: Tier[];
    onEditClick: (tierId: string) => void;
    onDeleteClick: (tierId: string) => void;
    onManageBenefitsClick: (tier: Tier) => void;
}

const TierTable: React.FC<TierTableProps> = ({ tiers, onEditClick, onDeleteClick, onManageBenefitsClick }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n

    // Funci√≥n interna para formatear resumen de beneficios
    const formatBenefitsSummary = (benefits: TierBenefit[]): string => {
        if (!benefits || benefits.length === 0) return t('adminTiersManagePage.benefitsSummaryNone');
        const activeBenefits = benefits.filter(b => b.isActive);
        if (activeBenefits.length === 0) return t('adminTiersManagePage.benefitsSummaryNoneActive');
        // Usar clave con pluralizaci√≥n
        return t('adminTiersManagePage.benefitsSummaryActive', { count: activeBenefits.length });
    };

    // Crear filas de la tabla
    const rows = tiers.map((tier) => (
        <Table.Tr key={tier.id}>
            <Table.Td>{tier.level}</Table.Td>
            <Table.Td fw={500}>{tier.name}</Table.Td>
            <Table.Td>{tier.minValue}</Table.Td>
            <Table.Td>{formatBenefitsSummary(tier.benefits)}</Table.Td>
            <Table.Td>
                <Badge color={tier.isActive ? 'green' : 'gray'} variant="light">
                    {tier.isActive ? t('common.active') : t('common.inactive')}
                </Badge>
            </Table.Td>
            <Table.Td>
                <Group gap="xs" wrap="nowrap">
                    <ActionIcon variant="subtle" color="teal" onClick={() => onManageBenefitsClick(tier)} title={t('adminTiersManagePage.tooltipManageBenefits')}>
                        <IconListDetails size={16} />
                    </ActionIcon>
                    <ActionIcon variant="subtle" color="blue" onClick={() => onEditClick(tier.id)} title={t('adminTiersManagePage.tooltipEditTier')}>
                        <IconPencil size={16} />
                    </ActionIcon>
                    <ActionIcon variant="subtle" color="red" onClick={() => onDeleteClick(tier.id)} title={t('adminTiersManagePage.tooltipDeleteTier')}>
                        <IconTrash size={16} />
                    </ActionIcon>
                </Group>
            </Table.Td>
        </Table.Tr>
    ));

    // Renderizado de la tabla
    return (
        <Table.ScrollContainer minWidth={600}>
            <Table verticalSpacing="sm" striped highlightOnHover withTableBorder withColumnBorders>
                <Table.Thead>
                    <Table.Tr>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderLevel')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderName')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderThreshold')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderBenefits')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderStatus')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderActions')}</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>
                    {rows.length > 0 ? rows : (
                        <Table.Tr>
                            <Table.Td colSpan={6}>
                                <Text c="dimmed" ta="center">{t('adminTiersManagePage.noTiersDefined')}</Text>
                            </Table.Td>
                        </Table.Tr>
                    )}
                </Table.Tbody>
            </Table>
        </Table.ScrollContainer>
    );
};

export default TierTable;


// ====== [73] frontend/src/modules/loyalpyme/components/customer/NextTierPreview.tsx ======
// filename: frontend/src/components/customer/NextTierPreview.tsx
// Version: 1.0.1 (Remove unused imports/function, use i18n for title)

import React from 'react';
// --- MODIFICACI√ìN: Quitar Paper ---
import { Title, List, ThemeIcon, Text, Stack, Box } from '@mantine/core';
// --- MODIFICACI√ìN: Quitar iconos no usados ---
import { IconSparkles } from '@tabler/icons-react'; // Mantenemos IconSparkles
// --- FIN MODIFICACI√ìN ---
import { useTranslation } from 'react-i18next';

// Importar el tipo desde el archivo de tipos compartido
import { TierBenefitData } from '../../types/customer';

// --- Props del Componente ---
interface NextTierPreviewProps {
    nextTierName: string;
    nextTierBenefits: TierBenefitData[];
}
// --- Fin Props ---

const NextTierPreview: React.FC<NextTierPreviewProps> = ({ nextTierName, nextTierBenefits }) => {
    const { t } = useTranslation(); // Ahora s√≠ se usa t

    if (!nextTierBenefits || nextTierBenefits.length === 0) {
        return null;
    }

    // --- ELIMINADO: Funci√≥n getBenefitIcon eliminada ---
    // const getBenefitIcon = (type: string) => { ... };
    // --- FIN ELIMINADO ---

    // Funci√≥n helper para formatear texto de beneficio (se mantiene)
    const formatBenefitText = (benefit: TierBenefitData) => {
        switch (benefit.type) {
            case 'POINTS_MULTIPLIER':
                // TODO: Usar clave i18n
                return <>Multiplicador de Puntos: <Text span fw={700}>x{benefit.value}</Text></>;
            case 'EXCLUSIVE_REWARD_ACCESS':
                 // TODO: Usar clave i18n
                return <>Acceso Exclusivo: <Text span fw={500}>Recompensa ID {benefit.value}</Text></>;
            case 'CUSTOM_BENEFIT':
            default:
                return benefit.value;
        }
    }

    return (
        <Box mt="xl">
            <Stack gap="md">
                {/* --- MODIFICACI√ìN: Usar t() para el t√≠tulo --- */}
                <Title order={5} c="dimmed">
                    {t('customerDashboard.nextTierBenefitsTitle', { tierName: nextTierName })}
                    {/* Aseg√∫rate que la clave 'customerDashboard.nextTierBenefitsTitle' existe en tus JSON con valor tipo: "Al alcanzar {{tierName}} tendr√°s:" */}
                </Title>
                {/* --- FIN MODIFICACI√ìN --- */}

                {/* Lista de beneficios futuros */}
                <List
                    spacing="sm"
                    size="sm"
                    center
                    icon={
                        <ThemeIcon color="gray" variant='light' size={24} radius="xl">
                            <IconSparkles style={{ width: '70%', height: '70%' }} />
                        </ThemeIcon>
                    }
                >
                    {nextTierBenefits.map((benefit) => (
                        <List.Item key={benefit.id}>
                            <Text span c="dimmed">
                                {formatBenefitText(benefit)}
                            </Text>
                            {benefit.description && (
                                <Text size="xs" c="dimmed" display="block">
                                    {benefit.description}
                                </Text>
                            )}
                        </List.Item>
                    ))}
                </List>
            </Stack>
        </Box>
    );
};

export default NextTierPreview;

// End of File: frontend/src/components/customer/NextTierPreview.tsx


// ====== [74] frontend/src/modules/loyalpyme/components/customer/QrValidationSection.tsx ======
// filename: frontend/src/components/customer/QrValidationSection.tsx
// Version: 2.3.2 (Remove isMobile check, Add console log for isValidating prop)

import React, { useState, useCallback } from 'react';
import {
    Paper, Title, Group, TextInput, Button, Modal, Stack, Alert, Text, Box, 
} from '@mantine/core';
import { IconAlertCircle, IconScan, IconTicket } from '@tabler/icons-react';
import { useQrScanner } from '../../hooks/useQrScanner'; // Asume v1.2.1 con try/catch
// useMediaQuery ya no es necesario
import { useTranslation } from 'react-i18next';

// Props (sin cambios)
interface QrValidationSectionProps {
    onValidate: (token: string) => Promise<void>;
    isValidating: boolean;
    scannerOpened: boolean;
    onOpenScanner: () => void;
    onCloseScanner: () => void;
}

const QrValidationSection: React.FC<QrValidationSectionProps> = ({
    onValidate,
    isValidating, // <-- La prop que queremos comprobar
    scannerOpened,
    onOpenScanner,
    onCloseScanner
}) => {
    const { t } = useTranslation();
    const [qrTokenInput, setQrTokenInput] = useState('');
    const qrcodeRegionId = "html5qr-code-reader-region";

    // --- Log de Depuraci√≥n ---
    console.log('[QrValidationSection] Rendering. isValidating =', isValidating);
    // --- Fin Log ---

    const handleScanSuccess = useCallback((decodedText: string) => { if (!isValidating) { onValidate(decodedText); onCloseScanner(); } }, [isValidating, onValidate, onCloseScanner]);
    const { scannerError, clearScannerError } = useQrScanner({ qrcodeRegionId: qrcodeRegionId, enabled: scannerOpened, onScanSuccess: handleScanSuccess, config: { fps: 10, qrbox: { width: 250, height: 250 } } });
    const handleManualSubmit = () => { if (qrTokenInput.trim() && !isValidating) { onValidate(qrTokenInput.trim()); } };
    const handleCloseModal = () => { clearScannerError(); onCloseScanner(); };

    return (
        <>
            <Paper shadow="sm" p="lg" mb="xl" withBorder radius="lg">
                <Title order={4} mb="md">{t('customerDashboard.validateQrSectionTitle')}</Title>
                <Group align="flex-end">
                     <TextInput label={t('customerDashboard.qrInputLabel')} placeholder={t('customerDashboard.qrInputPlaceholder')} value={qrTokenInput} onChange={(event) => setQrTokenInput(event.currentTarget.value)} style={{ flexGrow: 1 }} disabled={isValidating || scannerOpened} />
                     <Button onClick={handleManualSubmit} leftSection={<IconTicket size={18} />} loading={isValidating && !scannerOpened} disabled={!qrTokenInput.trim() || isValidating || scannerOpened} variant='outline'> {t('customerDashboard.validateButton')} </Button>
                    {/* --- Bot√≥n Scan: ELIMINADA condici√≥n !isMobile de 'disabled' --- */}
                    <Button
                        onClick={onOpenScanner}
                        leftSection={<IconScan size={18} />}
                        disabled={isValidating} // <-- SOLO deshabilitado si isValidating es true
                        variant='gradient'
                        gradient={{ from: 'blue', to: 'cyan', deg: 90 }}
                    >
                        {t('customerDashboard.scanButton')}
                    </Button>
                    {/* --- FIN CAMBIO --- */}
                </Group>
            </Paper>

            {/* Modal (sin cambios aqu√≠) */}
            <Modal opened={scannerOpened} onClose={handleCloseModal} title={t('customerDashboard.scanModalTitle')} size="auto" centered>
                <Stack>
                   <Text size="sm" ta="center" c="dimmed">{t('customerDashboard.scanInstructions')}</Text>
                    <Box id={qrcodeRegionId} w="100%"></Box>
                    {/* El error del scanner ahora se mostrar√° aqu√≠ si no hay c√°mara */}
                    {scannerError && ( <Alert icon={<IconAlertCircle size="1rem" />} title={t('customerDashboard.errorScanningQr')} color="red" withCloseButton onClose={clearScannerError} mt="sm"> {scannerError} </Alert> )}
                    {isValidating && <Group justify='center'><Text>{t('customerDashboard.validating')}</Text></Group>}
                    <Button variant="outline" onClick={handleCloseModal} disabled={isValidating}> {t('customerDashboard.scanCancelButton')} </Button>
                </Stack>
            </Modal>
        </>
    );
};

export default QrValidationSection;

// End of File: frontend/src/components/customer/QrValidationSection.tsx


// ====== [75] frontend/src/modules/loyalpyme/components/customer/RewardList.tsx ======
// filename: frontend/src/components/customer/RewardList.tsx
// Version: 1.5.1 (Wrap Tooltip child in Box to fix ref error)

import React from 'react';
import {
    SimpleGrid, Card, Button, Alert, Group, Text, Badge, Tooltip, Title,
    AspectRatio, Image as MantineImage, Stack, Box // <-- A√±adido Box
} from '@mantine/core';
import { IconGift, IconAlertCircle, IconInfoCircle, IconCoin } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { DisplayReward } from '../../types/customer';

// Props (sin cambios)
interface RewardListProps {
    rewards: DisplayReward[];
    userPoints: number | undefined;
    redeemingRewardId: string | null;
    errorRewards: string | null;
    loadingRewards: boolean;
    loadingGrantedRewards: boolean;
    onRedeemPoints: (rewardId: string) => void;
    onRedeemGift: (grantedRewardId: string, rewardName: string) => void;
}

const RewardList: React.FC<RewardListProps> = ({
    rewards,
    userPoints,
    redeemingRewardId,
    errorRewards,
    // loadingRewards,
    // loadingGrantedRewards,
    onRedeemPoints,
    onRedeemGift
}) => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;

    const formatDate = (dateString: string | undefined) => { if (!dateString) return '?'; try { return new Date(dateString).toLocaleDateString(i18n.language); } catch { return '?'; } };

    if (errorRewards) { return ( <Alert icon={<IconAlertCircle size="1rem" />} title={t('common.error')} color="red" mt="lg"> {t('customerDashboard.errorLoadingRewards', { error: errorRewards })} </Alert> ); }
    if (rewards.length === 0) { return <Text mt="md">{t('customerDashboard.noRewardsAvailable')}</Text>; }

    return (
        <>
            <SimpleGrid cols={{ base: 1, xs: 2, md: 3 }} spacing="lg">
                {rewards.map((item) => {
                    const displayName = (currentLanguage === 'es' ? item.name_es : item.name_en) || item.name_es || item.name_en || '(Sin nombre)';
                    const displayDescription = (currentLanguage === 'es' ? item.description_es : item.description_en) || item.description_es || item.description_en;
                    const isPointsRedeemDisabled = typeof userPoints === 'undefined' || userPoints < item.pointsCost || redeemingRewardId === item.id || !!redeemingRewardId;
                    const isGiftRedeemDisabled = redeemingRewardId === item.grantedRewardId || !!redeemingRewardId;
                    const isCurrentlyRedeemingThis = redeemingRewardId === (item.isGift ? item.grantedRewardId : item.id);

                    return (
                        <Card shadow="sm" padding="sm" radius="md" withBorder key={item.isGift ? `G-${item.grantedRewardId}` : `R-${item.id}`}>
                            <Stack gap="md">
                                <AspectRatio ratio={1 / 1}>
                                    <MantineImage src={item.imageUrl || '/placeholder-reward.png'} alt={displayName} fit="cover" radius="sm" fallbackSrc="/placeholder-reward.png" />
                                </AspectRatio>
                                <Stack gap="xs" style={{ flexGrow: 1 }}>
                                    <Title order={5}>{displayName}</Title>
                                    {displayDescription && <Text size="sm" c="dimmed" lineClamp={2}>{displayDescription}</Text>}
                                </Stack>
                                {item.isGift ? (
                                    <>
                                        <Group gap="xs" mt="sm" justify='space-between'>
                                            <Badge color="lime" variant='light' size="lg" radius="sm">{t('customerDashboard.giftFree')}</Badge>
                                            {/* --- MODIFICACI√ìN: Envolver hijo de Tooltip en Box --- */}
                                            <Tooltip multiline w={220} withArrow position="top" label={t('customerDashboard.giftAssignedBy', { assigner: item.assignedByString, date: formatDate(item.assignedAt) })}>
                                                <Box style={{ display: 'inline-block', cursor: 'help' }}> {/* A√±adir Box wrapper */}
                                                    <Group gap={4}>
                                                        <IconInfoCircle size={16} stroke={1.5} style={{ display: 'block' }}/>
                                                        <Text size="xs" c="dimmed">{t('customerDashboard.giftInfo')}</Text>
                                                    </Group>
                                                </Box>
                                            </Tooltip>
                                            {/* --- FIN MODIFICACI√ìN --- */}
                                        </Group>
                                        <Button variant="filled" color="yellow" fullWidth mt="sm" radius="md" size="sm" onClick={() => onRedeemGift(item.grantedRewardId!, displayName)} disabled={isGiftRedeemDisabled} loading={isCurrentlyRedeemingThis} leftSection={<IconGift size={16}/>}> {t('customerDashboard.redeemGiftButton')} </Button>
                                    </>
                                ) : (
                                    <>
                                        <Group justify="space-between" align="center" mt="sm"> <Text fw={500} size="sm">{item.pointsCost} {t('common.points')}</Text> {(userPoints !== undefined && userPoints >= item.pointsCost) && ( <Badge color="green" variant="light" size="xs">Asequible</Badge> )} </Group>
                                        <Button variant="light" color="blue" fullWidth mt="sm" radius="md" size="sm" onClick={() => onRedeemPoints(item.id)} disabled={isPointsRedeemDisabled} loading={isCurrentlyRedeemingThis} leftSection={<IconCoin size={16}/>}> {!isPointsRedeemDisabled || isCurrentlyRedeemingThis ? t('customerDashboard.redeemRewardButton') : t('customerDashboard.insufficientPoints')} </Button>
                                    </>
                                )}
                            </Stack>
                        </Card>
                    );
                })}
            </SimpleGrid>
        </>
    );
};

export default RewardList;


// ====== [76] frontend/src/modules/loyalpyme/components/customer/TierBenefitsDisplay.tsx ======
// filename: frontend/src/components/customer/TierBenefitsDisplay.tsx
// Version: 1.0.2 (Use i18n key for title)

import React from 'react';
import { Paper, Title, List, ThemeIcon, Text, Stack } from '@mantine/core';
import { IconCircleCheck } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

// Importar el tipo desde el archivo de tipos compartido
import { TierBenefitData } from '../../types/customer';

// --- Props del Componente ---
interface TierBenefitsDisplayProps {
    tierName: string;
    benefits: TierBenefitData[];
}
// --- Fin Props ---

const TierBenefitsDisplay: React.FC<TierBenefitsDisplayProps> = ({ tierName, benefits }) => {
    const { t } = useTranslation();

    if (!benefits || benefits.length === 0) {
        return null;
    }

    return (
        <Paper shadow="sm" p="lg" mt="xl" mb="xl" withBorder radius="lg">
            <Stack gap="md">
                {/* --- MODIFICACI√ìN: Usar t() para el t√≠tulo --- */}
                <Title order={4}>
                    {t('customerDashboard.tierBenefitsTitle', { tierName })}
                </Title>
                {/* --- FIN MODIFICACI√ìN --- */}

                {/* Lista de beneficios */}
                <List
                    spacing="xs"
                    size="sm"
                    center
                    icon={
                        <ThemeIcon color="teal" size={20} radius="xl">
                            <IconCircleCheck style={{ width: '70%', height: '70%' }} />
                        </ThemeIcon>
                    }
                >
                    {benefits.map((benefit) => (
                        <List.Item key={benefit.id}>
                            {/* TODO: Mejorar la visualizaci√≥n seg√∫n el 'benefit.type' */}
                            <Text fw={500} span>
                                {benefit.type === 'POINTS_MULTIPLIER' ? `Multiplicador x${benefit.value}` :
                                 benefit.type === 'EXCLUSIVE_REWARD_ACCESS' ? `Acceso a Recompensa Exclusiva (ID: ${benefit.value})` :
                                 benefit.value}
                            </Text>
                            {benefit.description && (
                                <Text size="xs" c="dimmed" display="block">
                                    {benefit.description}
                                </Text>
                            )}
                        </List.Item>
                    ))}
                </List>
            </Stack>
        </Paper>
    );
};

export default TierBenefitsDisplay;

// End of File: frontend/src/components/customer/TierBenefitsDisplay.tsx


// ====== [77] frontend/src/modules/loyalpyme/components/customer/UserInfoDisplay.tsx ======
// frontend/src/components/customer/UserInfoDisplay.tsx
// La versi√≥n que me pasaste era frontend/src/components/customer/dashboard/UserInfoDisplay.tsx
// Usar√© esa ruta. Si es diferente, d√≠melo.

import React from 'react';
import {
    Card, Text, Group, Progress, Stack, Popover, List, ThemeIcon, Loader, Alert, Box,
    ActionIcon
} from '@mantine/core';
import {
    IconCircleCheck, IconGift, IconDiscount2, IconStar, IconAlertCircle,
    IconHelp
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { TFunction } from 'i18next';
import { useDisclosure, useMediaQuery } from '@mantine/hooks';
import { UserData, TierBenefitData, TierCalculationBasis, TierData } from '../../types/customer'; // Asumiendo que TierData tambi√©n se importa aqu√≠ si se usa

type ProgressBarDataType = {
    type: 'progress';
    percentage: number;
    currentValueLabel: string;
    targetValueLabel: string;
    unit: string;
    nextTierName: string;
} | {
    type: 'max_level';
    currentTierName: string;
} | null;

export interface UserInfoDisplayProps {
    userData: UserData | null; // UserData ahora tiene points? opcional
    loadingUser: boolean;
    errorUser: string | null;
    progressBarData: ProgressBarDataType;
    benefits: TierBenefitData[];
    nextTierName: string | null; // Se usa para el popover
    nextTierBenefits: TierBenefitData[];
    tierCalculationBasis?: TierCalculationBasis | null;
    allTiers?: TierData[];
}

const renderBenefitItem = (benefit: TierBenefitData, index: number, t: TFunction): JSX.Element => {
    let icon = <IconStar size={16} />;
    let text = benefit.description || `${benefit.type}: ${benefit.value}`;
    switch (benefit.type) {
        case 'POINTS_MULTIPLIER': icon = <IconCircleCheck size={16} />; text = t('benefits.pointsMultiplier', { value: benefit.value }); break;
        case 'EXCLUSIVE_REWARD_ACCESS': icon = <IconGift size={16} />; text = t('benefits.exclusiveRewardAccess', { value: benefit.value }); break;
        case 'CUSTOM_BENEFIT': icon = <IconDiscount2 size={16} />; text = t('benefits.customBenefit', { value: benefit.value }); break;
    }
    return ( <List.Item key={benefit.id || index} icon={<ThemeIcon color="teal" size={24} radius="xl">{icon}</ThemeIcon>}>{text}</List.Item> );
};


const UserInfoDisplay: React.FC<UserInfoDisplayProps> = ({
    userData,
    loadingUser,
    errorUser,
    progressBarData,
    benefits,
    nextTierBenefits, // nextTierName se saca de progressBarData
    // tierCalculationBasis, // No se usa directamente en el render
    // allTiers // No se usa directamente en el render
}) => {
    const { t } = useTranslation();
    const isMobile = useMediaQuery('(max-width: em(768px))');
    const [popoverOpened, { open: openPopover, close: closePopover, toggle: togglePopover }] = useDisclosure(false);

    if (loadingUser) { return <Card withBorder radius="md" p="xl"><Loader size="sm" data-testid="user-info-loader" /></Card>; }
    if (errorUser || !userData) { return ( <Card withBorder radius="md" p="xl"><Alert title={t('customerDashboard.errorLoadingProfileTitle')} color="red" icon={<IconAlertCircle size="1rem" />} data-testid="user-info-error">{errorUser || t('customerDashboard.errorLoadingProfileDefault')}</Alert></Card> ); }

    const currentTierDisplayName = userData.currentTier?.name ?? t('customerDashboard.baseTier');

    // --- CORRECCI√ìN AQU√ç para userData.points ---
    const displayPoints = userData.points ?? 0; // Si points es undefined, mostrar 0
    // --- FIN CORRECCI√ìN ---

    const nextTierTitle = progressBarData?.type === 'progress' ? progressBarData.nextTierName : null;
    const popoverTitleText = nextTierTitle ? t('customerDashboard.nextTierBenefitsTitle', { tierName: nextTierTitle }) : '';

    const nextTierContent = nextTierTitle ? (
        <Stack gap="xs">
            <Text fw={500}>{popoverTitleText}</Text>
            {nextTierBenefits && nextTierBenefits.length > 0 ? (
                <List spacing="xs" size="sm" center>{nextTierBenefits.map((b, i) => renderBenefitItem(b, i, t))}</List>
            ) : ( <Text size="sm" c="dimmed">{t('common.noItems')}</Text> )}
        </Stack>
    ) : null;

    return (
        <Card withBorder radius="md" p="xl" data-testid="user-info-card">
            <Stack gap="lg">
                <Group justify="space-between">
                    <Text fz="lg" fw={600}>{userData.name || userData.email}</Text>
                    {/* --- USAR displayPoints --- */}
                    <Text fz="lg" fw={700} c="blue">{displayPoints.toLocaleString()} {t('common.points')}</Text>
                    {/* --- FIN USAR --- */}
                </Group>

                <Stack gap="xs">
                    <Group justify="space-between">
                        <Text fz="sm" fw={500} c="dimmed">{t('customerDashboard.currentTier')}</Text>
                        <Text fz="sm" fw={700} data-testid="current-tier-name">{currentTierDisplayName}</Text>
                    </Group>

                    {progressBarData?.type === 'progress' && nextTierContent && (
                        <Box>
                            <Popover
                                width={300}
                                position="top"
                                withArrow
                                shadow="md"
                                opened={popoverOpened}
                            >
                                <Popover.Target>
                                    <Group
                                        wrap="nowrap"
                                        gap="xs"
                                        onMouseEnter={!isMobile ? openPopover : undefined}
                                        onMouseLeave={!isMobile ? closePopover : undefined}
                                        style={{ cursor: !isMobile ? 'help' : 'default' }}
                                    >
                                        <Progress
                                            value={progressBarData.percentage}
                                            size="lg" radius="xl" striped animated
                                            style={{ flexGrow: 1 }}
                                            data-testid="progress-bar"
                                        />
                                        <ActionIcon
                                            variant="subtle"
                                            color="gray"
                                            onClick={togglePopover}
                                            hiddenFrom="sm"
                                            aria-label={t('customerDashboard.nextTierBenefitsTitle', { tierName: nextTierTitle || ''})}
                                            title={t('customerDashboard.nextTierBenefitsTitle', { tierName: nextTierTitle || ''})}
                                            data-testid="mobile-popover-trigger"
                                        >
                                            <IconHelp size={18} stroke={1.5}/>
                                        </ActionIcon>
                                    </Group>
                                </Popover.Target>
                                <Popover.Dropdown>
                                    {nextTierContent}
                                </Popover.Dropdown>
                            </Popover>
                            <Group justify="space-between" mt={5}>
                                <Text fz="xs" c="dimmed" data-testid="progress-label">
                                    {t('customerDashboard.progressLabel', {
                                        currentValue: progressBarData.currentValueLabel,
                                        targetValue: progressBarData.targetValueLabel,
                                        unit: progressBarData.unit,
                                        nextTierName: progressBarData.nextTierName
                                    })}
                                </Text>
                            </Group>
                        </Box>
                    )}
                    {progressBarData?.type === 'max_level' && (
                         <Box data-testid="max-level-indicator">
                            <Progress value={100} size="lg" radius="xl" color="teal" />
                            <Text fz="xs" c="teal" fw={500} mt={5}>{t('customerDashboard.maxLevelReachedShort')}</Text>
                         </Box>
                    )}
                    {!progressBarData && !loadingUser && !errorUser && (
                       <Text fz="xs" c="dimmed">{t('customerDashboard.errorLoadingProgress')}</Text>
                    )}
                </Stack>

                <Stack gap="xs" mt="md" data-testid="current-benefits-section">
                    <Text fw={500}>{t('customerDashboard.tierBenefitsTitle', { tierName: currentTierDisplayName })}</Text>
                    {benefits && benefits.length > 0 ? (
                        <List spacing="xs" size="sm" center icon={<></>}>
                            {benefits.map((b, i) => renderBenefitItem(b, i, t))}
                        </List>
                    ) : (
                        <Text size="sm" c="dimmed">{t('common.noItems')}</Text>
                    )}
                </Stack>
            </Stack>
        </Card>
    );
};

export default UserInfoDisplay;


// ====== [78] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/ActivityTab.tsx ======
// filename: frontend/src/components/customer/dashboard/tabs/ActivityTab.tsx
// Version: 2.1.4 (Use explicitly typed intermediate variable for timeline title)

import React from 'react';
import {
    Stack, Loader, Alert, Text, Pagination, Group, Box,
    Timeline, ThemeIcon, Badge,
    Title
} from '@mantine/core';
import {
    IconAlertCircle, IconGift, IconReceipt, IconTicket, IconAdjustments
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useCustomerActivity } from '../../../../hooks/useCustomerActivity';
// Importaci√≥n de tipos
import type { ActivityLogItem } from '../../../../types/customer';
import { ActivityType } from '../../../../types/customer';


const ActivityTab: React.FC = () => {
    const { t, i18n } = useTranslation();
    const {
        activityLogs,
        loading,
        error,
        currentPage,
        totalPages,
        totalItems,
        setPage,
        // refetch
    } = useCustomerActivity();

    // Funci√≥n para obtener icono y color
    const getActivityVisuals = (type: ActivityType): { icon: React.ReactNode; color: string } => {
        switch (type) {
            case 'POINTS_EARNED_QR': return { icon: <IconTicket size={12} />, color: 'green' };
            case 'POINTS_REDEEMED_REWARD': return { icon: <IconReceipt size={12} />, color: 'blue' };
            case 'GIFT_REDEEMED': return { icon: <IconGift size={12} />, color: 'yellow' };
            case 'POINTS_ADJUSTED_ADMIN': return { icon: <IconAdjustments size={12} />, color: 'grape' };
            default: return { icon: <IconTicket size={12} />, color: 'gray' };
        }
    };

    // Funci√≥n para formatear la fecha
    const formatDate = (dateString: string) => {
        if (!dateString) return 'N/A';
        try { return new Date(dateString).toLocaleString(i18n.language, { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' }); } catch { return t('common.invalidDate', 'Fecha inv√°lida'); }
    };

    // Contenido principal
    const renderContent = () => {
        if (loading && activityLogs.length === 0) { return <Group justify="center" p="lg"><Loader /></Group>; }
        if (error) { return <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{error}</Alert>; }
        if (activityLogs.length === 0) { return <Text c="dimmed" ta="center">{t('customerDashboard.activityTab.noActivity', 'A√∫n no tienes actividad registrada.')}</Text>; }

        return (
            <Timeline active={-1} bulletSize={20} lineWidth={2}>
                {activityLogs.map((item: ActivityLogItem) => {
                    const visuals = getActivityVisuals(item.type);
                    const pointsText = item.pointsChanged !== null ? `${item.pointsChanged > 0 ? '+' : ''}${item.pointsChanged}` : null;
                    const pointsColor = item.pointsChanged === null ? 'gray' : (item.pointsChanged > 0 ? 'green' : 'red');

                    // Variable para calcular el t√≠tulo (tipo inferido puede ser complejo)
                    let timelineTitleCalculationResult: string | ReturnType<typeof t> = '';
                    const descriptionData = item.description || '';

                    // Calcular t√≠tulo traducido con interpolaci√≥n
                    switch(item.type) {
                        case 'POINTS_EARNED_QR':
                            timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_EARNED', { ticketNumber: descriptionData });
                            break;
                        case 'POINTS_REDEEMED_REWARD':
                            timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_REDEEMED', { rewardName: descriptionData });
                            break;
                         case 'GIFT_REDEEMED':
                            timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_GIFT', { rewardName: descriptionData });
                             break;
                        case 'POINTS_ADJUSTED_ADMIN':
                            if (item.description) {
                                timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_ADJUSTED_REASON', { reason: item.description });
                            } else {
                                timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_ADJUSTED');
                            }
                            break;
                        default:
                            // Fallback
                            timelineTitleCalculationResult = item.description || t(`customerDashboard.activityTab.type_${item.type}`, item.type);
                    }

                    // Variable intermedia expl√≠citamente tipada como string
                    const finalTimelineTitle: string = String(timelineTitleCalculationResult);

                    return (
                        <Timeline.Item
                            key={item.id}
                            bullet={ <ThemeIcon size={20} variant="light" color={visuals.color} radius="xl"> {visuals.icon} </ThemeIcon> }
                            // Usar la variable intermedia expl√≠citamente tipada
                            title={finalTimelineTitle}
                        >
                            <Group justify="space-between">
                                <Text c="dimmed" size="xs"> {formatDate(item.createdAt)} </Text>
                                {pointsText && ( <Badge color={pointsColor} variant="light" size="sm"> {pointsText} {t('common.points')} </Badge> )}
                            </Group>
                        </Timeline.Item>
                    );
                })}
            </Timeline>
        );
    };

    return (
        <Stack gap="lg">
            <Title order={3}>{t('customerDashboard.tabActivity', 'Mi Actividad')}</Title>
            <Box style={{ position: 'relative' }}>
                {loading && activityLogs.length > 0 && ( <Box style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(255,255,255,0.5)', zIndex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}> <Loader size="sm" /> </Box> )}
                {renderContent()}
            </Box>
            {totalPages > 1 && !loading && !error && ( <Group justify="center" mt="xl"> <Pagination total={totalPages} value={currentPage} onChange={setPage} disabled={loading} /> </Group> )}
            {totalItems > 0 && !loading && !error && ( <Text size="sm" c="dimmed" ta="center"> {t('customerDashboard.activityTab.totalItems', { count: totalItems })} </Text> )}
        </Stack>
    );
};

export default ActivityTab;


// ====== [79] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/OffersTab.tsx ======
// filename: frontend/src/components/customer/dashboard/tabs/OffersTab.tsx
// Version: 1.0.0 (Placeholder component for Offers & News Tab)

import React from 'react';
import { Text } from '@mantine/core';
import { useTranslation } from 'react-i18next';

// No props needed for this placeholder initially
// interface OffersTabProps {}

const OffersTab: React.FC = (/* props: OffersTabProps */) => {
    const { t } = useTranslation();

    return (
        <Text c="dimmed">
            ({t('common.upcomingFeatureTitle', 'Pr√≥ximamente')}) {t('customerDashboard.tabOffers', 'Ofertas y Noticias')}
        </Text>
        // Future: Replace with actual offers/news feed component
    );
};

export default OffersTab;

// End of File: frontend/src/components/customer/dashboard/tabs/OffersTab.tsx


// ====== [80] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/ProfileTab.tsx ======
// filename: frontend/src/components/customer/dashboard/tabs/ProfileTab.tsx
// Version: 1.0.0 (Placeholder component for Profile Tab)

import React from 'react';
import { Text } from '@mantine/core';
import { useTranslation } from 'react-i18next';

// No props needed for this placeholder initially
// interface ProfileTabProps {}

const ProfileTab: React.FC = (/* props: ProfileTabProps */) => {
    const { t } = useTranslation();

    return (
        <Text c="dimmed">
            ({t('common.upcomingFeatureTitle', 'Pr√≥ximamente')}) {t('customerDashboard.tabProfile', 'Mi Perfil')}
        </Text>
        // Future: Replace with actual profile view/edit component
    );
};

export default ProfileTab;

// End of File: frontend/src/components/customer/dashboard/tabs/ProfileTab.tsx


// ====== [81] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/RewardsTab.tsx ======
// filename: frontend/src/components/customer/dashboard/tabs/RewardsTab.tsx
// Version: 1.0.7 (Remove explicit Title component to avoid duplication)

import React from 'react';
import { Box } from '@mantine/core'; // Title removed from imports
// import { useTranslation } from 'react-i18next'; // Removed if t() is not used

// Import child component
import RewardList from '../../RewardList';

// Import types needed for props
import { DisplayReward } from '../../../../types/customer';

// Define props for the RewardsTab component
interface RewardsTabProps {
    displayRewards: DisplayReward[];
    userPoints: number | undefined;
    redeemingRewardId: string | null;
    loadingRewards: boolean;
    loadingGrantedRewards: boolean;
    errorRewards: string | null;
    onRedeemPoints: (rewardId: string) => Promise<void>;
    onRedeemGift: (grantedRewardId: string, rewardName: string) => Promise<void>;
}

const RewardsTab: React.FC<RewardsTabProps> = ({
    displayRewards,
    userPoints,
    redeemingRewardId,
    loadingRewards,
    loadingGrantedRewards,
    errorRewards,
    onRedeemPoints,
    onRedeemGift
}) => {
    // const { t } = useTranslation(); // Removed if t() is not used

    // Optional: Display error directly in this tab if it occurs
    // if (errorRewards && !loadingRewards && !loadingGrantedRewards) {
    //     return (
    //         <Alert title={t('common.errorLoadingData')} color="red" icon={<IconAlertCircle size="1rem" />} mt="md">
    //             {errorRewards}
    //         </Alert>
    //     );
    // }

    return (
        <Box>
            {/* <Title order={4} mb="md"> // <-- TITLE REMOVED
                {t('customerDashboard.rewardsSectionTitle', 'Recompensas y Regalos')}
            </Title> */}

            <RewardList
                rewards={displayRewards}
                userPoints={userPoints}
                redeemingRewardId={redeemingRewardId}
                loadingRewards={loadingRewards}
                loadingGrantedRewards={loadingGrantedRewards}
                errorRewards={errorRewards}
                onRedeemPoints={onRedeemPoints}
                onRedeemGift={onRedeemGift}
            />
        </Box>
    );
};

export default RewardsTab;

// End of File: frontend/src/components/customer/dashboard/tabs/RewardsTab.tsx


// ====== [82] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/SummaryTab.tsx ======
// frontend/src/components/customer/dashboard/tabs/SummaryTab.tsx
// Version: 1.5.3 (Remove "Next Reward" display from summary)

import React, { useMemo } from 'react';
import {
    Stack, Grid, Paper, Title, Group, Text, Box, Image as MantineImage,
    AspectRatio, Button, Alert, Loader, Center,
    SimpleGrid, Badge
} from '@mantine/core';
import { IconGift, IconArrowRight, IconCoin, IconToolsKitchen2 } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { Link } from 'react-router-dom';

// Importar Componentes Hijos y sus Props
import UserInfoDisplay, { type UserInfoDisplayProps } from '../../UserInfoDisplay';
import QrValidationSection from '../../QrValidationSection';

// Importar Tipos necesarios
import type { DisplayReward, UserData, TierBenefitData } from '../../../../types/customer';

// Props del componente
interface SummaryTabProps {
    userData: UserData | null;
    loadingUser: boolean;
    errorUser: string | null;
    progressBarData: UserInfoDisplayProps['progressBarData'];
    currentTierBenefits: TierBenefitData[];
    nextTierName: string | null;
    nextTierBenefits: TierBenefitData[];
    displayRewards: DisplayReward[] | null;
    userPoints: number | undefined;
    redeemingRewardId: string | null;
    onRedeemGift: (grantedRewardId: string, rewardName: string) => Promise<void>;
    onRedeemPoints: (rewardId: string) => Promise<void>;
    setActiveTab: (tabValue: string | null) => void;
    handleValidateQr: (token: string) => Promise<void>;
    validatingQr: boolean;
    scannerOpened: boolean;
    onOpenScanner: () => void;
    onCloseScanner: () => void;
}

const MAX_PREVIEW_ITEMS = 3;

const SummaryTab: React.FC<SummaryTabProps> = ({
    userData, loadingUser, errorUser, progressBarData, currentTierBenefits,
    nextTierName, nextTierBenefits, displayRewards, userPoints,
    redeemingRewardId, onRedeemGift, onRedeemPoints,
    setActiveTab, handleValidateQr, validatingQr, scannerOpened,
    onOpenScanner, onCloseScanner
}) => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;

    const rewardsSummary = useMemo(() => {
        const pendingGifts = displayRewards?.filter(r => r.isGift) ?? [];
        const pointsRewards = displayRewards?.filter(r => !r.isGift && r.pointsCost > 0) ?? [];
        // No necesitamos ordenar pointsRewards si no vamos a usar nextReward
        // pointsRewards.sort((a, b) => (a.pointsCost ?? 0) - (b.pointsCost ?? 0)); 
        // const nextReward = pointsRewards.length > 0 ? pointsRewards[0] : null; // <-- ELIMINADO
        
        // Aseguramos que previewItems no intente acceder a nextReward si fue eliminado
        const previewItems = [...pendingGifts, ...pointsRewards].slice(0, MAX_PREVIEW_ITEMS);
        return {
            pendingGiftsCount: pendingGifts.length,
            // nextReward, // <-- ELIMINADO
            previewItems,
            hasAnyRewards: !!displayRewards && displayRewards.length > 0
        };
    }, [displayRewards]); // Ya no depende de currentLanguage o t aqu√≠ directamente

    if (loadingUser && !userData) {
        return <Group justify="center" p="xl"><Loader /></Group>;
    }

    return (
        <Grid gutter="xl">
            {/* Columna Izquierda: UserInfo y Validaci√≥n QR */}
            <Grid.Col span={{ base: 12, md: 7 }}>
                <Stack gap="xl">
                    <UserInfoDisplay
                        userData={userData}
                        loadingUser={loadingUser}
                        errorUser={errorUser}
                        progressBarData={progressBarData}
                        benefits={currentTierBenefits}
                        nextTierName={nextTierName}
                        nextTierBenefits={nextTierBenefits}
                    />
                    <QrValidationSection
                        onValidate={handleValidateQr}
                        isValidating={validatingQr}
                        scannerOpened={scannerOpened}
                        onOpenScanner={onOpenScanner}
                        onCloseScanner={onCloseScanner}
                    />
                </Stack>
            </Grid.Col>

            {/* Columna Derecha: Resumen Recompensas Y Tarjeta Acceso Carta */}
            <Grid.Col span={{ base: 12, md: 5 }}>
                <Stack gap="xl" style={{ height: '100%' }}>
                    
                    {/* Tarjeta de Acceso al M√≥dulo Camarero */}
                    {userData?.isCamareroActive && userData?.businessSlug && (
                        <Paper withBorder p="lg" radius="md" shadow="sm">
                            <Group justify="space-between" align="center">
                                <Stack gap={0} style={{ flex: 1, minWidth: 0 }}>
                                    <Text fw={500} size="lg" truncate>
                                        {userData.businessName 
                                            ? t('customerDashboard.summary.viewMenuFor', { businessName: userData.businessName }) 
                                            : t('customerDashboard.summary.viewMenuDefaultTitle')}
                                    </Text>
                                    <Text size="sm" c="dimmed" lineClamp={2}>
                                        {t('customerDashboard.summary.viewMenuSubtitle')}
                                    </Text>
                                </Stack>
                                <Button
                                    component={Link}
                                    to={`/m/${userData.businessSlug}`}
                                    leftSection={<IconToolsKitchen2 size={18} />}
                                    variant="gradient"
                                    gradient={{ from: 'teal', to: 'lime', deg: 105 }}
                                    size="sm"
                                    style={{ flexShrink: 0 }}
                                >
                                    {t('customerDashboard.summary.viewMenuButton')}
                                </Button>
                            </Group>
                        </Paper>
                    )}

                    {/* Tarjeta de Recompensas (existente) */}
                    {userData?.isLoyaltyCoreActive && (
                        <Paper shadow="sm" p="lg" withBorder radius="md" style={{ flexGrow: 1, display: 'flex', flexDirection: 'column' }}>
                            <Stack gap="lg" style={{ flexGrow: 1 }}>
                                <Title order={4}>
                                    {rewardsSummary.pendingGiftsCount > 0 
                                        ? t('customerDashboard.summary.giftsAndRewardsTitle') 
                                        : t('customerDashboard.summary.rewardsTitle')}
                                </Title>
                                {rewardsSummary.pendingGiftsCount > 0 && (
                                    <Alert color="yellow" icon={<IconGift />} title={t('customerDashboard.summary.pendingGifts', { count: rewardsSummary.pendingGiftsCount })} variant='light' radius="md">
                                        {t('customerDashboard.summary.pendingGiftsDesc')}
                                    </Alert>
                                )}

                                {rewardsSummary.previewItems.length > 0 ? (
                                    <SimpleGrid cols={MAX_PREVIEW_ITEMS === 3 ? 3 : 2} spacing="sm" verticalSpacing="md">
                                        {rewardsSummary.previewItems.map(item => {
                                            const displayName = (currentLanguage === 'es' ? item.name_es : item.name_en) || item.name_es || item.name_en || t('common.nameNotAvailable');
                                            const isAffordable = item.isGift || (userPoints !== undefined && userPoints >= item.pointsCost);
                                            const isPointsRedeemDisabled = !isAffordable || !!redeemingRewardId;
                                            const isGiftRedeemDisabled = !!redeemingRewardId;
                                            const isThisItemLoading = redeemingRewardId === (item.isGift ? item.grantedRewardId : item.id);

                                            return (
                                                <Stack 
                                                    key={item.id + (item.isGift ? '-gift' : '-reward')} 
                                                    gap={4} 
                                                    align="center"
                                                >
                                                    <AspectRatio ratio={1 / 1} style={{ width: '80%', maxWidth: '80px' }}>
                                                        <MantineImage src={item.imageUrl || '/placeholder-reward.png'} alt={displayName} radius="sm" fallbackSrc="/placeholder-reward.png" />
                                                    </AspectRatio>
                                                    <Text size="xs" ta="center" lineClamp={2} style={{ height: '2.4em', fontWeight: 500 }}>{displayName}</Text>
                                                    {item.isGift ? (
                                                        <Badge size="xs" color="lime" variant='light' mt={2}>{t('customerDashboard.giftFree')}</Badge>
                                                    ) : (
                                                        <Text size="xs" fw={500} mt={2}>{item.pointsCost} {t('common.points')}</Text>
                                                    )}
                                                    <Button
                                                        mt={4}
                                                        size="compact-xs"
                                                        variant={item.isGift ? "filled" : "light"}
                                                        color={item.isGift ? "yellow" : "blue"}
                                                        onClick={() => {
                                                            if (item.isGift && item.grantedRewardId) { onRedeemGift(item.grantedRewardId, displayName); }
                                                            else if (!item.isGift) { onRedeemPoints(item.id); }
                                                        }}
                                                        disabled={isThisItemLoading || (item.isGift ? isGiftRedeemDisabled : isPointsRedeemDisabled)}
                                                        loading={isThisItemLoading}
                                                        fullWidth
                                                        radius="xl"
                                                        leftSection={item.isGift ? <IconGift size={14}/> : <IconCoin size={14}/>}
                                                    >
                                                        {isAffordable || item.isGift
                                                            ? t('customerDashboard.redeemButton')
                                                            : t('customerDashboard.insufficientPoints')
                                                        }
                                                    </Button>
                                                </Stack>
                                            );
                                        })}
                                    </SimpleGrid>
                                ) : (
                                    <Center style={{flexGrow: 1}}>
                                        <Text c="dimmed">{t('customerDashboard.summary.noRewardsInfo')}</Text>
                                    </Center>
                                )}
                                
                                <Box mt="auto">
                                    {/* --- BLOQUE DE "PR√ìXIMA RECOMPENSA" ELIMINADO --- */}
                                    {rewardsSummary.hasAnyRewards && (
                                        <Button
                                            variant="light"
                                            fullWidth
                                            mt="sm" 
                                            onClick={() => setActiveTab('rewards')}
                                            radius="lg"
                                            rightSection={<IconArrowRight size={16} />}
                                        >
                                            {t('customerDashboard.summary.viewAllButtonShort')}
                                        </Button>
                                    )}
                                </Box>
                            </Stack>
                        </Paper>
                    )}
                </Stack>
            </Grid.Col>
        </Grid>
    );
};

export default SummaryTab;


// ====== [83] frontend/src/modules/loyalpyme/hooks/useAdminCustomersData.ts ======
// filename: frontend/src/hooks/useAdminCustomersData.ts
// Version: 1.1.3 (Fix character encoding)

import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';

// --- Tipos necesarios (Exportados) ---
// TODO: Mover estas interfaces a archivos compartidos (e.g., src/types/)
export interface Customer { id: string; name?: string | null; email: string; points: number; currentTier?: { id: string; name: string; level?: number; } | null; createdAt: string; isFavorite?: boolean; isActive?: boolean; }
interface CustomerApiResponse { items: Customer[]; totalPages: number; currentPage: number; totalItems: number; }
export type SortColumn = 'name' | 'email' | 'points' | 'createdAt' | 'isActive' | 'isFavorite' | 'currentTier.level';
export interface SortStatus { column: SortColumn; direction: 'asc' | 'desc'; }
export interface CustomerFilters {
    search?: string;
    isFavorite?: boolean;
    isActive?: boolean;
    tierId?: string;
}

// Interfaz para el resultado que el hook devolver√° (Exportada)
export interface UseAdminCustomersDataResult {
    customers: Customer[];
    loading: boolean;
    error: string | null;
    totalPages: number;
    currentPage: number;
    totalItems: number;
    searchTerm: string;
    sortStatus: SortStatus;
    filters: CustomerFilters;
    setPage: (page: number) => void;
    setSearchTerm: (term: string) => void;
    setSortStatus: (status: SortStatus) => void;
    setFilters: (filters: Partial<CustomerFilters>) => void;
    refetch: () => Promise<void>;
}
// --- Fin Tipos ---


const useAdminCustomersData = (): UseAdminCustomersDataResult => {
    // Estados internos
    const [customers, setCustomers] = useState<Customer[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [activePage, setPage] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const [totalItems, setTotalItems] = useState(0);
    const [searchTerm, setSearchTerm] = useState<string>('');
    const [sortStatus, setSortStatusState] = useState<SortStatus>({ column: 'createdAt', direction: 'desc' });
    const [filters, setFiltersState] = useState<CustomerFilters>({});

    // Funci√≥n de carga de datos
    const fetchCustomers = useCallback(async () => {
        setLoading(true);
        setError(null);
        console.log(`[useAdminCustomersData] Fetching customers: Page=${activePage}, Search='${searchTerm}', SortBy=${sortStatus.column}, SortDir=${sortStatus.direction}, Filters=`, filters);
        try {
            const params = new URLSearchParams({
                page: activePage.toString(),
                limit: '10', // L√≠mite fijo por ahora
                sortBy: sortStatus.column,
                sortDir: sortStatus.direction
            });
            // A√±adir filtros a los par√°metros
            if (searchTerm) params.append('search', searchTerm);
            if (filters.isFavorite !== undefined) params.append('isFavorite', filters.isFavorite.toString());
            if (filters.isActive !== undefined) params.append('isActive', filters.isActive.toString());
            if (filters.tierId) { params.append('tierId', filters.tierId); }

            const response = await axiosInstance.get<CustomerApiResponse>(`/admin/customers?${params.toString()}`);
            const apiData = response.data;

            if (apiData && Array.isArray(apiData.items) && typeof apiData.currentPage === 'number' && typeof apiData.totalPages === 'number' && typeof apiData.totalItems === 'number') {
                setCustomers(apiData.items);
                setTotalPages(apiData.totalPages);
                setTotalItems(apiData.totalItems);
                // Ajustar p√°gina activa si es necesario
                if(apiData.currentPage !== activePage && apiData.currentPage <= apiData.totalPages) { setPage(apiData.currentPage); }
                else if (activePage > apiData.totalPages && apiData.totalPages > 0) { setPage(apiData.totalPages); }
                else if (apiData.totalPages === 0 && activePage !== 1) { setPage(1); }

                console.log(`[useAdminCustomersData] Fetched ${apiData.items.length} customers. Total: ${apiData.totalItems}, Pages: ${apiData.totalPages}. Current page state: ${activePage}`);
            } else {
                console.error("[useAdminCustomersData] Invalid paginated response structure:", apiData);
                throw new Error("La respuesta del servidor no tiene el formato esperado.");
            }
        } catch (err: any) {
            console.error("[useAdminCustomersData] Error fetching customers:", err);
            const errorMsg = err.response?.data?.message || err.message || 'Error desconocido al cargar clientes.';
            setError(errorMsg);
            setCustomers([]); setTotalPages(1); setTotalItems(0); setPage(1); // Resetear todo en error
        } finally {
            setLoading(false);
        }
    }, [activePage, searchTerm, sortStatus, filters]); // Dependencias correctas

    // Efecto para Carga Inicial y Recarga por cambio de dependencias
    useEffect(() => {
        fetchCustomers();
    }, [fetchCustomers]);

    // Efecto para resetear p√°gina SOLO al cambiar filtros/b√∫squeda (y si no est√°bamos ya en p√°gina 1)
     useEffect(() => {
        if (activePage !== 1) {
             console.log("[useAdminCustomersData] Search or filters changed, resetting page to 1.");
             setPage(1);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [searchTerm, filters]); // No incluir activePage aqu√≠ para evitar bucle


    // Funciones Setters expuestas
    const handleSetPage = useCallback((page: number) => { setPage(page); }, []);
    const handleSetSearchTerm = useCallback((term: string) => { setSearchTerm(term); }, []);
    const handleSetSortStatus = useCallback((status: SortStatus) => { setSortStatusState(status); }, []);
    const handleSetFilters = useCallback((newFilters: Partial<CustomerFilters>) => {
        setFiltersState(prevFilters => {
            const updatedFilters = { ...prevFilters };
             for (const key in newFilters) {
                if (Object.prototype.hasOwnProperty.call(newFilters, key)) {
                    const filterKey = key as keyof CustomerFilters;
                    const value = newFilters[filterKey];
                    // Si el valor es undefined o string vac√≠o, quitar filtro
                    if (value === undefined || value === '') {
                        delete updatedFilters[filterKey];
                    } else {
                        // Validar tipo antes de asignar
                        if ((filterKey === 'isActive' || filterKey === 'isFavorite') && typeof value === 'boolean') {
                            updatedFilters[filterKey] = value;
                        } else if ((filterKey === 'search' || filterKey === 'tierId') && typeof value === 'string') {
                            updatedFilters[filterKey] = value;
                        } else { console.warn(`[useAdminCustomersData] Ignorando filtro con tipo inesperado para key '${filterKey}':`, value); }
                    }
                }
            }
            console.log('[useAdminCustomersData] Filters updated:', updatedFilters);
            return updatedFilters;
        });
    }, []);

    const refetch = useCallback(async () => { await fetchCustomers(); }, [fetchCustomers]);

    // Retorno del hook
    return {
        customers, loading, error, totalPages,
        currentPage: activePage, totalItems, searchTerm, sortStatus, filters,
        setPage: handleSetPage, setSearchTerm: handleSetSearchTerm,
        setSortStatus: handleSetSortStatus, setFilters: handleSetFilters, refetch,
    };
};

export default useAdminCustomersData;

// End of File: frontend/src/hooks/useAdminCustomersData.ts


// ====== [84] frontend/src/modules/loyalpyme/hooks/useAdminOverviewStats.ts ======
// filename: frontend/src/hooks/useAdminOverviewStats.ts
// Version: 1.0.1 (Add console.log inside calculateTrend for debugging)

import { useState, useEffect, useCallback, useMemo } from 'react';
import { getAdminDashboardStats, AdminOverviewStats } from '../services/adminService';

type TrendDirection = 'up' | 'down' | 'neutral';
interface TrendResult {
    trendValue: string | null;
    trendDirection: TrendDirection | null;
}
interface UseAdminOverviewStatsReturn {
    statsData: AdminOverviewStats | null;
    loadingStats: boolean;
    errorStats: string | null;
    newCustomersTrend: TrendResult;
    pointsIssuedTrend: TrendResult;
    rewardsRedeemedTrend: TrendResult;
    refetchStats: () => void;
}

export const useAdminOverviewStats = (): UseAdminOverviewStatsReturn => {
    const [statsData, setStatsData] = useState<AdminOverviewStats | null>(null);
    const [loadingStats, setLoadingStats] = useState<boolean>(true);
    const [errorStats, setErrorStats] = useState<string | null>(null);

    const fetchStats = useCallback(async () => {
        setLoadingStats(true);
        setErrorStats(null);
        console.log("[useAdminOverviewStats] Fetching stats...");
        try {
            const data = await getAdminDashboardStats();
            setStatsData(data);
        } catch (err: any) {
            console.error("[useAdminOverviewStats] Error fetching stats:", err);
            setErrorStats(err.message || 'No se pudieron cargar las estad√≠sticas.');
        } finally {
            setLoadingStats(false);
            console.log("[useAdminOverviewStats] Stats fetch finished.");
        }
    }, []);

    useEffect(() => {
        fetchStats();
    }, [fetchStats]);

    const calculateTrend = useMemo(() => {
        // A√±adimos un identificador para saber qu√© m√©trica se est√° calculando
        return (metricName: string, current: number | null | undefined, previous: number | null | undefined): TrendResult => {
            const currentVal = current ?? 0;
            const previousVal = previous ?? 0;

            // --- DEBUG LOGGING ---
            console.log(`[calculateTrend - ${metricName}] Inputs: current=${currentVal}, previous=${previousVal}`);
            // --- FIN DEBUG LOGGING ---

            if (previousVal === 0) {
                if (currentVal > 0) {
                    // --- DEBUG LOGGING ---
                    console.log(`[calculateTrend - ${metricName}] Result: '+' (Previous was 0)`);
                    // --- FIN DEBUG LOGGING ---
                    return { trendValue: '+', trendDirection: 'up' };
                }
                // --- DEBUG LOGGING ---
                 console.log(`[calculateTrend - ${metricName}] Result: 'N/A' (Both 0 or current <= 0)`);
                 // --- FIN DEBUG LOGGING ---
                return { trendValue: 'N/A', trendDirection: 'neutral' };
            }

            const percentageChange = ((currentVal - previousVal) / previousVal) * 100;
            // --- DEBUG LOGGING ---
            console.log(`[calculateTrend - ${metricName}] Percentage Change: ${percentageChange}`);
            // --- FIN DEBUG LOGGING ---

            if (isNaN(percentageChange) || !isFinite(percentageChange)) {
                 console.warn(`[calculateTrend - ${metricName}] Invalid percentageChange calculated.`);
                return { trendValue: 'Error', trendDirection: 'neutral' };
            }

            let direction: TrendDirection = 'neutral';
            const threshold = 0.1;
            if (percentageChange > threshold) direction = 'up';
            else if (percentageChange < -threshold) direction = 'down';

            const formattedValue = `${percentageChange >= 0 ? '+' : ''}${percentageChange.toFixed(1)}%`;
            // --- DEBUG LOGGING ---
            console.log(`[calculateTrend - ${metricName}] Result: value='${formattedValue}', direction='${direction}'`);
            // --- FIN DEBUG LOGGING ---
            return { trendValue: formattedValue, trendDirection: direction };
        };
    }, []);

    const newCustomersTrend = useMemo(() => {
        if (!statsData) return { trendValue: null, trendDirection: null };
        // Pasar nombre de m√©trica para logs
        return calculateTrend('NewCustomers', statsData.newCustomersLast7Days, statsData.newCustomersPrevious7Days);
    }, [statsData, calculateTrend]);

    const pointsIssuedTrend = useMemo(() => {
        if (!statsData) return { trendValue: null, trendDirection: null };
         // Pasar nombre de m√©trica para logs
        return calculateTrend('PointsIssued', statsData.pointsIssuedLast7Days, statsData.pointsIssuedPrevious7Days);
    }, [statsData, calculateTrend]);

    const rewardsRedeemedTrend = useMemo(() => {
        if (!statsData) return { trendValue: null, trendDirection: null };
         // Pasar nombre de m√©trica para logs
        return calculateTrend('RewardsRedeemed', statsData.rewardsRedeemedLast7Days, statsData.rewardsRedeemedPrevious7Days);
    }, [statsData, calculateTrend]);

    return {
        statsData,
        loadingStats,
        errorStats,
        newCustomersTrend,
        pointsIssuedTrend,
        rewardsRedeemedTrend,
        refetchStats: fetchStats
    };
};

// End of File: frontend/src/hooks/useAdminOverviewStats.ts


// ====== [85] frontend/src/modules/loyalpyme/hooks/useAdminRewards.ts ======
// filename: frontend/src/hooks/useAdminRewards.ts
// Version: 1.2.0 (Ensure correct Reward type with i18n fields is used)

import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';

// --- IMPORTANTE: Asegurarse de importar Reward desde la ubicaci√≥n correcta ---
import { Reward } from '../../../shared/types/user.types'; // Debe importar la interfaz Reward actualizada
// --- FIN IMPORTANTE ---


// Tipos (sin cambios en la definici√≥n, pero ahora usan la Reward importada)
export type ActionLoading = { type: 'toggle' | 'delete'; id: string } | null;

export interface UseAdminRewardsReturn {
    rewards: Reward[]; // <-- Usa la interfaz Reward importada (que ahora tiene name_es/en)
    loading: boolean;
    error: string | null;
    actionLoading: ActionLoading;
    fetchRewards: () => Promise<void>;
    handleToggleActive: (rewardId: string, currentIsActive: boolean) => Promise<void>;
    handleDeleteReward: (rewardId: string, rewardName: string) => Promise<void>; // rewardName puede ser ahora name_es o name_en
}


export const useAdminRewards = (): UseAdminRewardsReturn => {
    // --- Estado interno usa la interfaz Reward importada ---
    const [rewards, setRewards] = useState<Reward[]>([]);
    // --- Fin Estado ---
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [actionLoading, setActionLoading] = useState<ActionLoading>(null);

    // Funciones (sin cambios en la l√≥gica interna, pero ahora trabajan con el tipo Reward correcto)
    const fetchRewards = useCallback(async () => {
        if (rewards.length === 0 || !loading) setLoading(true); // Ajuste para mostrar loading en refetch
        setError(null);
        console.log("[useAdminRewards] Fetching rewards...");
        try {
            // La llamada espera un array de objetos Reward (con name_es/en)
            const response = await axiosInstance.get<Reward[]>('/rewards'); // Usa el tipo Reward correcto
            console.log("[useAdminRewards] Raw rewards data received:", response.data);
            setRewards(response.data ?? []);
        } catch (err: any) {
           console.error('[useAdminRewards] Error fetching rewards:', err);
           const message = err.response?.data?.message || err.message || 'Error desconocido al cargar recompensas.';
           setError(message);
           // Solo mostrar notificaci√≥n si ya hab√≠a datos y falla el refetch
           if (rewards.length > 0) {
                notifications.show({ title: 'Error al Refrescar', message, color: 'red' });
           }
         } finally {
            setLoading(false);
            console.log("[useAdminRewards] Fetch rewards finished.");
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loading]); // Dependencia ajustada para permitir refetch

    useEffect(() => {
        fetchRewards();
    }, [fetchRewards]); // fetchRewards ahora tiene dependencias correctas

    const handleToggleActive = useCallback(async (rewardId: string, currentIsActive: boolean) => {
         setActionLoading({ type: 'toggle', id: rewardId });
        const newIsActive = !currentIsActive;
        const actionText = newIsActive ? 'activada' : 'desactivada'; // TODO: i18n
        try {
            await axiosInstance.patch(`/rewards/${rewardId}`, { isActive: newIsActive });
            // Actualizaci√≥n optimista del estado
            setRewards((prevRewards) =>
                prevRewards.map((r) =>
                    r.id === rewardId ? { ...r, isActive: newIsActive, updatedAt: new Date().toISOString() } : r
                )
            );
            notifications.show({
                 title: `Recompensa ${actionText}`, // TODO: i18n
                message: `La recompensa se ha ${actionText} correctamente.`, // TODO: i18n
                color: 'green',
                autoClose: 4000
            });
        } catch (err: any) {
             console.error('Error toggling reward active state:', err);
             const message = `Error al ${actionText} la recompensa: ${err.response?.data?.message || err.message || 'Error desconocido'}`; // TODO: i18n
             notifications.show({
                title: 'Error al Actualizar Estado', message, color: 'red', // TODO: i18n
                autoClose: 6000
            });
        } finally {
            setActionLoading(null);
        }
    }, []);

    const handleDeleteReward = useCallback(async (rewardId: string, rewardName: string) => { // rewardName es ahora name_es o name_en
        setActionLoading({ type: 'delete', id: rewardId });
        try {
            await axiosInstance.delete(`/rewards/${rewardId}`);
            setRewards((prevRewards) => prevRewards.filter((r) => r.id !== rewardId) );
             notifications.show({
                title: 'Recompensa Eliminada', // TODO: i18n
                message: `La recompensa "${rewardName}" ha sido eliminada.`, // Usa el nombre pasado
                color: 'green',
                autoClose: 4000
            });
         } catch (err: any) {
            console.error('Error deleting reward:', err);
            const apiMessage = err.response?.data?.message || err.message || 'Error desconocido';
            let notifyMessage = `Error al eliminar "${rewardName}": ${apiMessage}`; // TODO: i18n
            if (err.response?.status === 404 || apiMessage.includes('no encontrada')) {
                 notifyMessage = `No se encontr√≥ la recompensa "${rewardName}" (quiz√°s ya fue eliminada).`; // TODO: i18n
            }
             if (err.response?.status === 409 || apiMessage.includes('siendo utilizada')) {
                notifyMessage = `No se puede eliminar "${rewardName}" porque est√° en uso.`; // TODO: i18n
            }
            notifications.show({
                title: 'Error al Eliminar', message: notifyMessage, color: 'red', // TODO: i18n
                autoClose: 6000
            });
        } finally {
            setActionLoading(null);
        }
    }, []);

    // Retorno del Hook (sin cambios)
    return {
        rewards,
        loading,
        error,
        actionLoading,
        fetchRewards,
        handleToggleActive,
        handleDeleteReward
    };
};

// End of File: frontend/src/hooks/useAdminRewards.ts


// ====== [86] frontend/src/modules/loyalpyme/hooks/useCustomerActivity.ts ======
// filename: frontend/src/hooks/useCustomerActivity.ts
import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { ActivityLogItem, PaginatedActivityResponse } from '../../../shared/types/user.types'; // Importar tipos definidos

// Definir el tipo de retorno del hook
export interface UseCustomerActivityResult {
    activityLogs: ActivityLogItem[];
    loading: boolean;
    error: string | null;
    currentPage: number;
    totalPages: number;
    totalItems: number;
    setPage: (page: number) => void; // Funci√≥n para cambiar de p√°gina
    refetch: () => void; // Funci√≥n para recargar la p√°gina actual
}

const ITEMS_PER_PAGE = 15; // N√∫mero de items por p√°gina

export const useCustomerActivity = (): UseCustomerActivityResult => {
    // Estados del hook
    const [activityLogs, setActivityLogs] = useState<ActivityLogItem[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [currentPage, setCurrentPage] = useState<number>(1);
    const [totalPages, setTotalPages] = useState<number>(1);
    const [totalItems, setTotalItems] = useState<number>(0);

    // Funci√≥n para obtener los datos de una p√°gina espec√≠fica
    const fetchActivity = useCallback(async (pageToFetch: number) => {
        setLoading(true);
        // No limpiar el error aqu√≠ necesariamente, podr√≠a ser √∫til verlo mientras carga
        // setError(null);
        console.log(`[useCustomerActivity] Fetching page ${pageToFetch}...`);

        try {
            const response = await axiosInstance.get<PaginatedActivityResponse>('/customer/activity', {
                params: {
                    page: pageToFetch,
                    limit: ITEMS_PER_PAGE,
                },
            });

            const data = response.data;
            if (data && Array.isArray(data.logs)) {
                setActivityLogs(data.logs);
                setTotalPages(data.totalPages ?? 1);
                setTotalItems(data.totalItems ?? 0);
                setCurrentPage(data.currentPage ?? pageToFetch); // Usar la p√°gina devuelta por la API si existe
                setError(null); // Limpiar error en caso de √©xito
                console.log(`[useCustomerActivity] Fetch successful for page ${pageToFetch}. Total Items: ${data.totalItems}`);
            } else {
                console.error('[useCustomerActivity] Invalid response structure:', data);
                throw new Error('La respuesta del servidor para el historial no tiene el formato esperado.');
            }

        } catch (err: any) {
            console.error(`[useCustomerActivity] Error fetching activity page ${pageToFetch}:`, err);
            const errorMsg = err.response?.data?.message || err.message || 'Error desconocido al cargar el historial.';
            setError(errorMsg);
            // No limpiar los logs existentes en caso de error de fetch, podr√≠a ser confuso
            // setActivityLogs([]);
            // setTotalPages(1);
            // setTotalItems(0);
            // setCurrentPage(1);
        } finally {
            setLoading(false);
            console.log(`[useCustomerActivity] Fetch process finished for page ${pageToFetch}.`);
        }
    }, []); // No necesita dependencias si usa 'currentPage' del estado

    // Funci√≥n para establecer la p√°gina (disparar√° el useEffect)
    const setPage = useCallback((page: number) => {
        // Validar que la p√°gina est√© dentro de los l√≠mites si ya conocemos totalPages
        if (page > 0 && (totalPages === 1 || page <= totalPages)) {
             if(page !== currentPage){ // Solo actualiza si la p√°gina es diferente
                console.log(`[useCustomerActivity] Setting page to: ${page}`);
                setCurrentPage(page);
             }
        } else {
             console.warn(`[useCustomerActivity] Attempted to set invalid page: ${page} (Total: ${totalPages})`);
        }
    }, [totalPages, currentPage]); // Depende de totalPages y currentPage

    // Efecto para la carga inicial
    useEffect(() => {
        console.log('[useCustomerActivity] Initial fetch triggered.');
        fetchActivity(1); // Cargar p√°gina 1 al montar
    }, [fetchActivity]);

    // Efecto para recargar cuando cambia la p√°gina (excepto en carga inicial)
    useEffect(() => {
        // Evitar recarga si es la carga inicial (manejada por el otro useEffect)
        // o si la p√°gina no es v√°lida
        if (currentPage !== 1 && currentPage > 0 && (totalPages === 1 || currentPage <= totalPages)) {
             console.log(`[useCustomerActivity] Page changed to ${currentPage}, refetching...`);
            fetchActivity(currentPage);
        }
    }, [currentPage, fetchActivity, totalPages]); // Depende de currentPage

    // Funci√≥n para recargar la p√°gina actual
    const refetch = useCallback(() => {
        console.log(`[useCustomerActivity] Manual refetch triggered for page ${currentPage}.`);
        fetchActivity(currentPage);
    }, [fetchActivity, currentPage]);


    // Retornar el estado y las funciones
    return {
        activityLogs,
        loading,
        error,
        currentPage,
        totalPages,
        totalItems,
        setPage,
        refetch
    };
};


// ====== [87] frontend/src/modules/loyalpyme/hooks/useCustomerRewardsData.ts ======
// filename: frontend/src/hooks/useCustomerRewardsData.ts
// Version: 1.2.2 (Fix infinite loop by correcting useCallback dependencies)

import { useState, useEffect, useCallback, useMemo } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { useTranslation } from 'react-i18next';

// Importar tipos actualizados
import { Reward, GrantedReward, DisplayReward } from '../../../shared/types/user.types';

// Interfaz de retorno (sin cambios)
export interface UseCustomerRewardsDataResult {
    displayRewards: DisplayReward[];
    loadingRewards: boolean;
    loadingGrantedRewards: boolean;
    errorRewards: string | null;
    refreshRewards: () => Promise<void>;
}

// Funci√≥n Helper para combinar y mapear (sin cambios respecto a v1.2.1)
const combineAndMapRewards = ( rewards: Reward[] | null, grantedRewards: GrantedReward[] | null, t: ReturnType<typeof useTranslation>['t'] ): DisplayReward[] => { /* ... (c√≥digo interno sin cambios) ... */ console.log('[useCustomerRewardsData] Combining rewards and gifts...'); const combined: DisplayReward[] = []; if (grantedRewards) { const gifts: DisplayReward[] = grantedRewards .filter(gr => gr && gr.reward) .map((gr): DisplayReward => { let assigner = t('customerDashboard.summary.unknownAssigner', 'Desconocido'); if (gr.assignedBy) { assigner = gr.assignedBy.name || gr.assignedBy.email || assigner; } return { isGift: true, grantedRewardId: gr.id, id: gr.reward.id, name_es: gr.reward.name_es, name_en: gr.reward.name_en, description_es: gr.reward.description_es, description_en: gr.reward.description_en, pointsCost: 0, imageUrl: gr.reward.imageUrl, assignedByString: assigner, assignedAt: gr.assignedAt, }; }); combined.push(...gifts); console.log(`[useCustomerRewardsData] Mapped ${gifts.length} gifts.`); } else { console.log('[useCustomerRewardsData] No granted rewards data received.'); } if (rewards) { const grantedRewardBaseIds = new Set(grantedRewards?.map(gr => gr.reward.id) ?? []); const pointsRewards: DisplayReward[] = rewards .filter(r => r && !grantedRewardBaseIds.has(r.id)) .map((r): DisplayReward => { return { isGift: false, id: r.id, name_es: r.name_es, name_en: r.name_en, description_es: r.description_es, description_en: r.description_en, pointsCost: r.pointsCost, imageUrl: r.imageUrl, }; }); combined.push(...pointsRewards); console.log(`[useCustomerRewardsData] Mapped ${pointsRewards.length} points rewards.`); } else { console.log('[useCustomerRewardsData] No points rewards data received.'); } console.log('[useCustomerRewardsData] Final combined display rewards:', combined); return combined; };


// Hook Principal
export const useCustomerRewardsData = (): UseCustomerRewardsDataResult => {
    const { t } = useTranslation(); // No necesitamos i18n aqu√≠ directamente si solo pasamos t
    const [rewards, setRewards] = useState<Reward[] | null>(null);
    const [grantedRewards, setGrantedRewards] = useState<GrantedReward[] | null>(null);
    const [loadingRewards, setLoadingRewards] = useState<boolean>(true);
    const [loadingGrantedRewards, setLoadingGrantedRewards] = useState<boolean>(true);
    const [errorRewards, setErrorRewards] = useState<string | null>(null);

    // --- useCallback ACTUALIZADO: Dependencias corregidas ---
    const fetchAllRewardsData = useCallback(async () => {
        setLoadingRewards(true); setLoadingGrantedRewards(true); setErrorRewards(null);
        console.log('[useCustomerRewardsData] Fetching rewards data...');
        try {
            const [rewardsResponse, grantedRewardsResponse] = await Promise.all([
                axiosInstance.get<Reward[]>('/customer/rewards'),
                axiosInstance.get<GrantedReward[]>('/customer/granted-rewards')
            ]);
            if (!Array.isArray(rewardsResponse.data) || !Array.isArray(grantedRewardsResponse.data)) { console.error("Invalid API response structure", {rewards: rewardsResponse.data, granted: grantedRewardsResponse.data}); throw new Error("La respuesta de la API no tiene el formato esperado."); }
            setRewards(rewardsResponse.data);
            setGrantedRewards(grantedRewardsResponse.data);
            console.log('[useCustomerRewardsData] Rewards data fetch successful.');
        } catch (err: any) { console.error('[useCustomerRewardsData] Error fetching rewards data:', err); const message = err.response?.data?.message || err.message || t('customerDashboard.errorLoadingRewards'); setErrorRewards(message); /* No mostrar notif aqu√≠, podr√≠a ser molesto en bucle if(!rewards && !grantedRewards) { notifications.show({ title: t('common.errorLoadingData'), message, color: 'red' }); } */
        } finally { setLoadingRewards(false); setLoadingGrantedRewards(false); console.log('[useCustomerRewardsData] Fetch rewards process finished.'); }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [t]); // <-- SOLO depende de 't' ahora
    // --- FIN useCallback ---

    // Carga inicial (sin cambios)
    useEffect(() => {
        fetchAllRewardsData();
    }, [fetchAllRewardsData]); // Este useEffect ahora es seguro porque fetchAllRewardsData no cambia innecesariamente

    // Combinar y mapear (sin cambios)
    const displayRewards = useMemo(() => {
        return combineAndMapRewards(rewards, grantedRewards, t);
    }, [rewards, grantedRewards, t]);

    useEffect(() => { console.log("[useCustomerRewardsData] Display rewards updated.", displayRewards); }, [displayRewards]);

    // Funci√≥n de refresco (sin cambios)
    const refreshRewards = useCallback(() => { console.log("[useCustomerRewardsData] Refresh triggered."); return fetchAllRewardsData(); }, [fetchAllRewardsData]);

    return { displayRewards, loadingRewards, loadingGrantedRewards, errorRewards, refreshRewards };
};

// End of File: frontend/src/hooks/useCustomerRewardsData.ts


// ====== [88] frontend/src/modules/loyalpyme/hooks/useCustomerTierData.ts ======
// filename: frontend/src/hooks/useCustomerTierData.ts
// Version: 1.2.2 (Remove unused TierCalculationBasis import)

import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { AxiosError } from 'axios';
import { notifications } from '@mantine/notifications';
// import { IconAlertCircle } from '@tabler/icons-react'; // Sigue sin usarse

// --- MODIFICACI√ìN: Importar solo los tipos usados directamente por el hook ---
import {
    TierData,
    CustomerBusinessConfig,
    UseCustomerTierDataResult,
} from '../../../shared/types/user.types';


// --- Hook ---

// Usar el tipo importado para el retorno
export const useCustomerTierData = (): UseCustomerTierDataResult => {
    // Usar los tipos importados para el estado
    const [allTiers, setAllTiers] = useState<TierData[] | null>(null);
    const [businessConfig, setBusinessConfig] = useState<CustomerBusinessConfig | null>(null);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);

    const fetchData = useCallback(async () => {
        setLoading(true);
        setError(null);
        console.log('[useCustomerTierData] Fetching all tiers and business config...');

        try {
            const [tiersResponse, configResponse] = await Promise.all([
                // Usar los tipos importados en las llamadas
                axiosInstance.get<TierData[]>('/customer/tiers'),
                axiosInstance.get<CustomerBusinessConfig>('/customer/business-config')
            ]);

            const activeTiers = tiersResponse.data?.filter(t => t.isActive) ?? [];
            setAllTiers(activeTiers);
            console.log('[useCustomerTierData] Active tiers fetched:', activeTiers);

            setBusinessConfig(configResponse.data ?? null);
            console.log('[useCustomerTierData] Business config fetched:', configResponse.data);

        } catch (err) {
            console.error("[useCustomerTierData] Error fetching data:", err);
            let errorMsg = 'Error al cargar datos de niveles o configuraci√≥n.';
            if (err instanceof AxiosError) {
                errorMsg = err.response?.data?.message || err.message || errorMsg;
            } else if (err instanceof Error) {
                errorMsg = err.message;
            }
            setError(errorMsg);

            notifications.show({
                title: 'Error de Carga',
                message: errorMsg,
                color: 'red',
                // icon: <IconAlertCircle />, // Mantenemos sin icono
            });

            setAllTiers(null);
            setBusinessConfig(null);
        } finally {
            setLoading(false);
            console.log('[useCustomerTierData] Fetch process finished.');
        }
    }, []);

    useEffect(() => {
        fetchData();
    }, [fetchData]);

    // El tipo de retorno ya coincide con UseCustomerTierDataResult importado
    return {
        allTiers,
        businessConfig,
        loading,
        error,
        refetch: fetchData
    };
};

// End of File: frontend/src/hooks/useCustomerTierData.ts


// ====== [89] frontend/src/modules/loyalpyme/hooks/useQrScanner.ts ======
// filename: frontend/src/hooks/useQrScanner.ts
// Version: 1.2.1 (Fix type errors and unused warnings)

import { useState, useEffect, useRef, useCallback } from 'react';
// --- MODIFICADO: Eliminar Html5QrcodeError y Html5QrcodeResult ---
import {
    Html5Qrcode,
    // Html5QrcodeError, // <-- Eliminado
    // Html5QrcodeResult, // <-- Eliminado
    QrcodeSuccessCallback,
    QrcodeErrorCallback
} from 'html5-qrcode';
import type { Html5QrcodeScannerConfig } from 'html5-qrcode/html5-qrcode-scanner';

// Props del Hook (sin cambios)
interface UseQrScannerProps {
    qrcodeRegionId: string;
    enabled: boolean;
    onScanSuccess: QrcodeSuccessCallback;
    onScanError?: QrcodeErrorCallback;
    config?: Omit<Html5QrcodeScannerConfig, 'fps' | 'qrbox'> & { fps?: number; qrbox?: { width: number; height: number; } | number };
    verbose?: boolean;
}

// Tipo de Retorno del Hook (sin cambios)
export interface UseQrScannerReturn {
    scannerError: string | null;
    clearScannerError: () => void;
    isScanning: boolean;
}

export const useQrScanner = ({
    qrcodeRegionId,
    enabled,
    onScanSuccess,
    // --- MODIFICADO: Prefijar errorMessage no usado ---
    onScanError = (_errorMessage) => { /* No hacer nada por defecto */ },
    // --- FIN MODIFICADO ---
    config = {},
    verbose = false,
}: UseQrScannerProps): UseQrScannerReturn => {
    const [scannerError, setScannerError] = useState<string | null>(null);
    const [isScanning, setIsScanning] = useState<boolean>(false);
    const scannerInstanceRef = useRef<Html5Qrcode | null>(null);
    // --- MODIFICADO: Cambiar tipo de Timeout a number ---
    const initTimeoutRef = useRef<number | null>(null); // <- Tipo number
    // --- FIN MODIFICADO ---
    // --- ELIMINADO: initialMount ref ---
    // const initialMount = useRef(true);
    // --- FIN ELIMINADO ---


    const log = useCallback((message: string, ...optionalParams: any[]) => {
        if (verbose) { console.log(`[useQrScanner] ${message}`, ...optionalParams); }
    }, [verbose]);

    const clearScannerError = useCallback(() => { setScannerError(null); }, []);

    const startScanner = useCallback(async () => {
        // ... (l√≥gica interna de startScanner sin cambios funcionales, solo usa tipos correctos) ...
        if (!scannerInstanceRef.current) { log("Scanner instance not ready in startScanner."); setScannerError("El esc√°ner no est√° listo."); return; }
        if (isScanning) { log("Scanner already scanning in startScanner."); return; }
        log("Attempting to start scanner..."); clearScannerError();
        try {
            await scannerInstanceRef.current.start(
                { facingMode: "environment" },
                { fps: 10, qrbox: { width: 250, height: 250 }, ...config },
                (decodedText, result) => { // QrcodeSuccessCallback - result es de tipo Html5QrcodeResult impl√≠citamente
                     log(`Scan successful: ${decodedText}`, result);
                     if (!isScanning) return;
                     setIsScanning(false);
                     onScanSuccess(decodedText, result);
                 },
                (errorMessage, error) => { // QrcodeErrorCallback - error es de tipo Html5QrcodeError impl√≠citamente
                     const commonIgnoredErrors = ['QR code parse error', 'NotFoundException'];
                     if (!commonIgnoredErrors.some(e => errorMessage.includes(e))) {
                         console.warn(`[useQrScanner] Scan Error: ${errorMessage}`, error);
                         if (onScanError) { onScanError(errorMessage, error); }
                     }
                 }
            );
            log("Scanner started successfully."); setIsScanning(true);
        } catch (err: any) {
             console.error("[useQrScanner] Error starting scanner:", err);
             let friendlyError = 'Error desconocido al iniciar esc√°ner.';
             if (err.name === 'NotFoundError' || err.message?.includes('device not found')) { friendlyError = 'No se encontr√≥ una c√°mara compatible.'; }
             else if (err.name === 'NotAllowedError' || err.message?.includes('Permission denied')) { friendlyError = 'Permiso para acceder a la c√°mara denegado.'; }
             else if (err.message) { friendlyError = `Error al iniciar c√°mara: ${err.message}`; }
             setScannerError(friendlyError); setIsScanning(false);
        }
    }, [config, log, onScanError, onScanSuccess, isScanning, clearScannerError]);


    // Efecto para inicializar y limpiar
    useEffect(() => {
        if (enabled) {
            log("Hook enabled. Setting up initialization timeout...");
            // --- MODIFICADO: Usar window.setTimeout y window.clearTimeout ---
            initTimeoutRef.current = window.setTimeout(() => { // Usar window.setTimeout
                log("Initializing Html5Qrcode (after delay)...");
                try {
                    // A√±adir try/catch aqu√≠ por si el constructor falla
                    const scanner = new Html5Qrcode(qrcodeRegionId, verbose);
                    scannerInstanceRef.current = scanner;
                    startScanner();
                } catch (initError: any) {
                    console.error("[useQrScanner] Error initializing Html5Qrcode object:", initError);
                    setScannerError(`Error al inicializar lector QR: ${initError.message || 'Error desconocido'}`);
                }
            }, 500);
            // --- FIN MODIFICADO ---
        } else {
            // Limpieza cuando enabled pasa a false (sin cambios funcionales)
            if (initTimeoutRef.current) { log("Cleanup: Cleared pending initialization timeout."); window.clearTimeout(initTimeoutRef.current); initTimeoutRef.current = null; } // Usar window.clearTimeout
            if (scannerInstanceRef.current && isScanning) { log("Cleanup: Attempting to stop scanner..."); scannerInstanceRef.current.stop().then(() => { log("Cleanup: Scanner stopped successfully."); setIsScanning(false); }).catch((err) => { if (err.message?.includes('not running')) { log("Cleanup Warning: Attempted to stop scanner that wasn't running."); } else { console.error("[useQrScanner] Cleanup: Error stopping scanner:", err); } setIsScanning(false); }).finally(() => { log("Cleanup: Setting scanner instance ref to null."); scannerInstanceRef.current = null; });
            } else { log("Cleanup: No active scanner instance found to stop or hook disabled."); if (scannerInstanceRef.current) { scannerInstanceRef.current = null; } setIsScanning(false); }
        }

        // Funci√≥n de limpieza al desmontar (sin cambios funcionales)
        return () => {
            log("Component unmounting or 'enabled' changed. Running cleanup...");
            if (initTimeoutRef.current) { log("Cleanup: Cleared pending initialization timeout on unmount."); window.clearTimeout(initTimeoutRef.current); } // Usar window.clearTimeout
             if (scannerInstanceRef.current && isScanning) {
                 log("Cleanup: Attempting to stop scanner on unmount...");
                 try { scannerInstanceRef.current.stop().then(() => log("Cleanup: Scanner stopped successfully on unmount.")).catch((err) => { if (err.message?.includes('not running')) { log("Cleanup Warning: Attempted to stop scanner (unmount) that wasn't running."); } else { console.error("[useQrScanner] Cleanup: Error stopping scanner on unmount:", err); } }).finally(() => { scannerInstanceRef.current = null; log("Cleanup: Scanner instance ref set to null on unmount."); }); } catch (stopError) { console.error("[useQrScanner] Cleanup: Immediate error calling stop() on unmount:", stopError); scannerInstanceRef.current = null; }
             } else if (scannerInstanceRef.current) { log("Cleanup: Scanner instance exists but wasn't scanning on unmount. Setting ref to null."); scannerInstanceRef.current = null; }
            setIsScanning(false);
        };
    }, [qrcodeRegionId, enabled, verbose, log, startScanner, isScanning]);

    return { scannerError, clearScannerError, isScanning };
};

// End of File: frontend/src/hooks/useQrScanner.ts


// ====== [90] frontend/src/modules/loyalpyme/hooks/useUserProfileData.ts ======
// filename: frontend/src/hooks/useUserProfileData.ts
// Version: 1.5.0 (Return setUserData function and use imported types)

import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { AxiosError } from 'axios';
// Importar tipos desde el archivo central
import { UserData, UseProfileResult } from '../../../shared/types/user.types'; // Aseg√∫rate que la ruta es correcta


/**
 * Hook para obtener y gestionar los datos del perfil del usuario logueado.
 */
export const useUserProfileData = (): UseProfileResult => { // <-- Usa tipo importado
    const [userData, setUserData] = useState<UserData | null>(null); // <-- Usa tipo importado
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);

    const fetchUserProfile = useCallback(async () => {
        console.log('[useUserProfileData] Fetching user profile...');
        setLoading(true);
        setError(null);
        try {
            const response = await axiosInstance.get<UserData>('/profile'); // <-- Usa tipo importado
            if (response.data) {
                setUserData(response.data);
                console.log('[useUserProfileData] User profile updated.');
            } else {
                console.warn('[useUserProfileData] No user data received from /profile endpoint.');
                setUserData(null);
            }
        } catch (err) {
            console.error("[useUserProfileData] Error fetching user profile:", err);
            const errorMsg = err instanceof Error ? err.message : 'Ocurri√≥ un error desconocido.';
            let detailedError = `Error al cargar perfil: ${errorMsg}.`;
            if (err instanceof AxiosError && err.response) { detailedError += ` (Status: ${err.response.status})`; }
            setError(detailedError);
            setUserData(null);
        } finally {
            setLoading(false);
            console.log('[useUserProfileData] Fetch user profile finished.');
        }
    }, []);

    useEffect(() => {
        fetchUserProfile();
    }, [fetchUserProfile]);

    // Devolver tambi√©n setUserData
    // Aseg√∫rate de que esta secci√≥n es id√©ntica en tu archivo:
    return {
        userData,
        loading,
        error,
        refetch: fetchUserProfile,
        setUserData // <-- La propiedad que falta seg√∫n el error
    };
};

export default useUserProfileData;

// End of File: frontend/src/hooks/useUserProfileData.ts


// ====== [91] frontend/src/modules/loyalpyme/pages/CustomerDashboardPage.tsx ======
// filename: frontend/src/pages/CustomerDashboardPage.tsx
// Version: 3.0.15 (Pass redemption handlers/state to SummaryTab)

import { useState, useCallback, useMemo } from 'react';
import { Container, Title, Alert, Tabs, Text, Space, LoadingOverlay } from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { IconAlertCircle, IconCircleCheck, IconGift, IconLayoutDashboard, IconHistory, IconSpeakerphone, IconUserCircle } from '@tabler/icons-react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { AxiosError } from 'axios';
import { useDisclosure } from '@mantine/hooks';
import { useTranslation } from 'react-i18next';

// Hooks
import { useUserProfileData } from '../hooks/useUserProfileData';
import { useCustomerRewardsData } from '../hooks/useCustomerRewardsData';
import { useCustomerTierData } from '../hooks/useCustomerTierData';
// Componentes de Pesta√±as
import SummaryTab from '../components/customer/dashboard/tabs/SummaryTab';
import RewardsTab from '../components/customer/dashboard/tabs/RewardsTab';
import ActivityTab from '../components/customer/dashboard/tabs/ActivityTab';
import OffersTab from '../components/customer/dashboard/tabs/OffersTab';
import ProfileTab from '../components/customer/dashboard/tabs/ProfileTab';

// Tipos
import {
    UserData,
    TierData,
    TierCalculationBasis,
    TierBenefitData
} from '../../../shared/types/user.types';

// Tipos locales
type ProgressBarDataType = { type: 'progress'; percentage: number; currentValueLabel: string; targetValueLabel: string; unit: string; nextTierName: string; } | { type: 'max_level'; currentTierName: string; } | null;
interface TierDisplayMemoResult { progressBarData: ProgressBarDataType; nextTierName: string | null; nextTierBenefits: TierBenefitData[]; }


function CustomerDashboardPage() {
    const { t } = useTranslation();
    // Hooks de datos
    const { userData, loading: loadingUser, error: errorUser, refetch: refetchUser, setUserData } = useUserProfileData();
    const { displayRewards, loadingRewards, loadingGrantedRewards, errorRewards, refreshRewards } = useCustomerRewardsData();
    const { allTiers, businessConfig, loading: loadingTierData, error: errorTierData, refetch: refetchTierData } = useCustomerTierData();
    // Estados locales de UI
    const [validatingQr, setValidatingQr] = useState(false);
    const [redeemingRewardId, setRedeemingRewardId] = useState<string | null>(null); // ID de la recompensa/regalo que se est√° canjeando
    const [scannerOpened, { open: openScanner, close: closeScanner }] = useDisclosure(false);
    const [activeTab, setActiveTab] = useState<string | null>('summary');
    // Handlers (sin cambios)
    const handleRefetchAll = useCallback(async () => { await Promise.all([refetchUser(), refreshRewards(), refetchTierData()]); }, [refetchUser, refreshRewards, refetchTierData]);
    const handleValidateQr = useCallback(async (token: string) => { setValidatingQr(true); try { const response = await axiosInstance.post<any>('/points/validate-qr', { qrToken: token }); const apiUser = response.data.user; const pointsEarned = response.data.pointsEarned ?? 0; if (!apiUser) { throw new Error(t('customerDashboard.errorValidatingQrMessage')); } notifications.show({ title: t('common.success'), message: t('customerDashboard.successQrValidation', { points: pointsEarned }), color: 'green', icon: <IconCircleCheck /> }); const currentUserData = userData; setUserData(prev => { if (!prev) return null; let newTierData: UserData['currentTier'] = null; if (apiUser.currentTierId) { const keepOldBenefits = prev.currentTier?.id === apiUser.currentTierId; newTierData = { id: apiUser.currentTierId, name: apiUser.currentTierName || prev.currentTier?.name || '', benefits: keepOldBenefits ? (prev.currentTier?.benefits || []) : [] }; } const newPoints: number = apiUser.points ?? currentUserData?.points ?? 0; const newTotalSpend: number = apiUser.totalSpend ?? currentUserData?.totalSpend ?? 0; const newTotalVisits: number = apiUser.totalVisits ?? currentUserData?.totalVisits ?? 0; return { ...prev, points: newPoints, totalSpend: newTotalSpend, totalVisits: newTotalVisits, currentTier: newTierData }; }); await handleRefetchAll(); } catch (err) { const errorMsg = (err instanceof AxiosError && err.response?.data?.message) ? err.response.data.message : (err instanceof Error ? err.message : t('customerDashboard.errorValidatingQrMessage')); notifications.show({ title: t('customerDashboard.errorValidatingQr'), message: errorMsg, color: 'red', icon: <IconAlertCircle /> }); } finally { setValidatingQr(false); } }, [handleRefetchAll, t, setUserData, userData]);
    const handleRedeemReward = useCallback(async (rewardId: string) => { setRedeemingRewardId(rewardId); try { await axiosInstance.post<any>(`/points/redeem-reward/${rewardId}`); notifications.show({ title: t('customerDashboard.successRedeemRewardTitle'), message: t('customerDashboard.successRedeemRewardMessage'), color: 'teal', icon: <IconGift /> }); await handleRefetchAll(); } catch (err) { const errorMsg = (err instanceof AxiosError && err.response?.data?.message) ? err.response.data.message : (err instanceof Error ? err.message : t('customerDashboard.errorRedeemMessage')); notifications.show({ title: t('customerDashboard.errorRedeemTitle'), message: errorMsg, color: 'red', icon: <IconAlertCircle /> }); } finally { setRedeemingRewardId(null); } }, [handleRefetchAll, t]);
    const handleRedeemGrantedReward = useCallback(async (grantedRewardId: string, rewardName: string) => { setRedeemingRewardId(grantedRewardId); try { await axiosInstance.post(`/customer/granted-rewards/${grantedRewardId}/redeem`); notifications.show({ title: t('customerDashboard.successRedeemGiftTitle'), message: t('customerDashboard.successRedeemGiftMessage', { rewardName }), color: 'green', icon: <IconCircleCheck /> }); await handleRefetchAll(); } catch (err) { const errorMsg = (err instanceof AxiosError && err.response?.data?.message) ? err.response.data.message : (err instanceof Error ? err.message : t('customerDashboard.errorRedeemGiftMessage')); notifications.show({ title: t('customerDashboard.errorRedeemTitle'), message: errorMsg, color: 'red', icon: <IconAlertCircle /> }); } finally { setRedeemingRewardId(null); } }, [handleRefetchAll, t]);

     // Memo tierDisplayData (sin cambios)
     const tierDisplayData = useMemo((): TierDisplayMemoResult => { const initialLoadingState: TierDisplayMemoResult = { progressBarData: null, nextTierName: null, nextTierBenefits: [] }; if (loadingUser || loadingTierData || !userData || !allTiers || !businessConfig || !businessConfig.tierCalculationBasis) { return initialLoadingState; } const sortTiersLocal = (tiers: TierData[]): TierData[] => [...tiers].sort((a, b) => a.level - b.level); const currentMetricValueFunc = (): number => { switch (businessConfig.tierCalculationBasis) { case TierCalculationBasis.SPEND: return userData.totalSpend ?? 0; case TierCalculationBasis.VISITS: return userData.totalVisits ?? 0; case TierCalculationBasis.POINTS_EARNED: return userData.points ?? 0; default: return 0; }}; const currentMetricValue = currentMetricValueFunc(); const sortedTiers = sortTiersLocal(allTiers); const currentTierIndex = sortedTiers.findIndex(t => t.id === userData.currentTier?.id); const currentTier = currentTierIndex !== -1 ? sortedTiers[currentTierIndex] : null; const currentTierMinValue = currentTier?.minValue ?? 0; const nextTier = currentTierIndex !== -1 && currentTierIndex < sortedTiers.length - 1 ? sortedTiers[currentTierIndex + 1] : null; let progressBarResult: ProgressBarDataType = null; let nextTierNameResult: string | null = null; let nextTierBenefitsResult: TierBenefitData[] = []; if (!nextTier) { progressBarResult = { type: 'max_level' as const, currentTierName: currentTier?.name || t('customerDashboard.baseTier') }; } else { nextTierNameResult = nextTier.name; nextTierBenefitsResult = nextTier.benefits ?? []; const nextTierMinValue = nextTier.minValue; const range = Math.max(0.01, nextTierMinValue - currentTierMinValue); const progressInTier = Math.max(0, currentMetricValue - currentTierMinValue); let percentage = (progressInTier / range) * 100; percentage = Math.max(0, Math.min(100, percentage)); let unit = ''; switch (businessConfig.tierCalculationBasis) { case TierCalculationBasis.SPEND: unit = '‚Ç¨'; break; case TierCalculationBasis.VISITS: unit = t('customerDashboard.progressUnitVisits'); break; case TierCalculationBasis.POINTS_EARNED: unit = t('common.points'); break; } const currentValueLabel = `${currentMetricValue.toLocaleString(undefined, { maximumFractionDigits: businessConfig.tierCalculationBasis === TierCalculationBasis.SPEND ? 2 : 0 })}`; const targetValueLabel = `${nextTierMinValue.toLocaleString(undefined, { maximumFractionDigits: businessConfig.tierCalculationBasis === TierCalculationBasis.SPEND ? 2 : 0 })}`; if (nextTierNameResult) { progressBarResult = { type: 'progress' as const, percentage: percentage, currentValueLabel: currentValueLabel, targetValueLabel: targetValueLabel, unit: unit, nextTierName: nextTierNameResult }; } else { progressBarResult = { type: 'max_level' as const, currentTierName: currentTier?.name || t('customerDashboard.baseTier') }; } } return { progressBarData: progressBarResult, nextTierName: nextTierNameResult, nextTierBenefits: nextTierBenefitsResult }; }, [userData, allTiers, businessConfig, loadingUser, loadingTierData, t]);
    // Memo currentTierBenefits (sin cambios)
    const currentTierBenefits = useMemo(() => { return userData?.currentTier?.benefits ?? []; }, [userData?.currentTier]);
    // Estados carga/error (sin cambios)
    const isLoading = loadingUser || loadingTierData || loadingRewards || loadingGrantedRewards;
    const mainError = errorUser || errorTierData || errorRewards;
    if (mainError && !isLoading) { return ( <Container size="lg" py="xl"><Alert icon={<IconAlertCircle size="1rem" />} title={t('common.errorLoadingData')} color="red" radius="md">{mainError}</Alert></Container> ); }

    // Renderizado Principal
    return (
        <Container size="lg" py="xl">
            <LoadingOverlay visible={loadingUser && !userData} overlayProps={{ radius: 'sm', blur: 2 }} />
            {userData && (
                <>
                    <Title order={2} ta="center" mb="xl">{t('customerDashboard.title')}</Title>
                    <Tabs value={activeTab} onChange={setActiveTab} keepMounted={false}>
                        <Tabs.List grow>
                            <Tabs.Tab value="summary" leftSection={<IconLayoutDashboard size={16} />}>{t('customerDashboard.tabSummary')}</Tabs.Tab>
                            <Tabs.Tab value="rewards" leftSection={<IconGift size={16} />}>{t('customerDashboard.tabRewards')}</Tabs.Tab>
                            <Tabs.Tab value="activity" leftSection={<IconHistory size={16} />}>{t('customerDashboard.tabActivity')}</Tabs.Tab>
                            <Tabs.Tab value="offers" leftSection={<IconSpeakerphone size={16} />} disabled>{t('customerDashboard.tabOffers')}</Tabs.Tab>
                            <Tabs.Tab value="profile" leftSection={<IconUserCircle size={16} />} disabled>{t('customerDashboard.tabProfile')}</Tabs.Tab>
                        </Tabs.List>
                        <Space h="xl" />
                        <Tabs.Panel value="summary">
                             {/* --- MODIFICADO: A√±adir props a SummaryTab --- */}
                            <SummaryTab
                                userData={userData}
                                loadingUser={loadingUser}
                                errorUser={errorUser}
                                progressBarData={tierDisplayData.progressBarData}
                                currentTierBenefits={currentTierBenefits}
                                nextTierName={tierDisplayData.nextTierName}
                                nextTierBenefits={tierDisplayData.nextTierBenefits}
                                displayRewards={displayRewards}
                                setActiveTab={setActiveTab}
                                handleValidateQr={handleValidateQr}
                                validatingQr={validatingQr}
                                scannerOpened={scannerOpened}
                                onOpenScanner={openScanner}
                                onCloseScanner={closeScanner}
                                // Nuevas props para canje:
                                userPoints={userData.points}
                                redeemingRewardId={redeemingRewardId}
                                onRedeemGift={handleRedeemGrantedReward}
                                onRedeemPoints={handleRedeemReward}
                            />
                             {/* --- FIN MODIFICACI√ìN --- */}
                        </Tabs.Panel>
                        <Tabs.Panel value="rewards">
                             <RewardsTab
                                 displayRewards={displayRewards}
                                 userPoints={userData.points}
                                 redeemingRewardId={redeemingRewardId}
                                 loadingRewards={loadingRewards} // Pasamos estos loadings aunque RewardList no los use (por ahora)
                                 loadingGrantedRewards={loadingGrantedRewards} // Pasamos estos loadings
                                 errorRewards={errorRewards}
                                 onRedeemPoints={handleRedeemReward}
                                 onRedeemGift={handleRedeemGrantedReward}
                             />
                         </Tabs.Panel>
                         <Tabs.Panel value="activity"><ActivityTab /></Tabs.Panel>
                         <Tabs.Panel value="offers"><OffersTab /></Tabs.Panel>
                         <Tabs.Panel value="profile"><ProfileTab /></Tabs.Panel>
                    </Tabs>
                </>
            )}
            {!userData && !loadingUser && !mainError && ( <Text ta="center" c="dimmed" mt="xl">{t('customerDashboard.noUserDataError', 'No se pudieron cargar los datos del usuario.')}</Text> )}
        </Container>
    );
}

export default CustomerDashboardPage;


// ====== [92] frontend/src/modules/loyalpyme/pages/admin/AdminCustomerManagementPage.module.css ======
/*
.th {
  padding: 0 !important;
}

.control {
  width: 100%;
  padding: var(--mantine-spacing-xs) var(--mantine-spacing-md);
  display: flex;
  justify-content: space-between;
  align-items: center;

  &:hover {
    background-color: light-dark(var(--mantine-color-gray-0), var(--mantine-color-dark-6));
  }

  &:disabled {
    cursor: default;
    &:hover {
       background-color: transparent;
    }
  }
}

.icon {
  width: rem(21px);
  height: rem(21px);
  border-radius: rem(21px);
}

.thead {
  position: sticky;
  top: 0;
  background-color: var(--mantine-color-body);
  transition: box-shadow 150ms ease;
  z-index: 1;

  &::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    border-bottom: rem(1px) solid var(--table-border-color);
  }
}
*/


// ====== [93] frontend/src/modules/loyalpyme/pages/admin/AdminCustomerManagementPage.tsx ======
// frontend/src/pages/admin/AdminCustomerManagementPage.tsx
// Version 2.0.1 (Complete integration of FiltersBar, BulkActionsBar, and adminCustomerService)

import React, { useState, useEffect, useCallback } from 'react';
import {
    Paper, Title, Stack, Loader, Alert, Pagination, Group, Text
} from '@mantine/core';
import {
    IconAlertCircle, IconCheck, IconX
} from '@tabler/icons-react';
import { useDisclosure } from '@mantine/hooks';
import { useModals } from '@mantine/modals';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';

// Nuevos Componentes
import CustomerFiltersBar, { TierOption } from '../../components/admin/CustomerFiltersBar';
import CustomerBulkActionsBar from '../../components/admin/CustomerBulkActionsBar';

// Componentes Modales
import AdjustPointsModal from '../../components/admin/AdjustPointsModal';
import ChangeTierModal from '../../components/admin/ChangeTierModal';
import AssignRewardModal from '../../components/admin/AssignRewardModal';
import CustomerDetailsModal, { CustomerDetails } from '../../components/admin/CustomerDetailsModal';
import BulkAdjustPointsModal from '../../components/admin/BulkAdjustPointsModal';

// Hook y Tipos de Datos
import useAdminCustomersData, {
    Customer,
    UseAdminCustomersDataResult,
    SortColumn,
} from '../../hooks/useAdminCustomersData';
import CustomerTable from '../../components/admin/CustomerTable';

// Nuevo Servicio API
import * as adminCustomerService from '../../services/adminCustomerService';
import axiosInstance from '../../../../shared/services/axiosInstance';// Para fetchTiersForFilter

const AdminCustomerManagementPage: React.FC = () => {
    const { t } = useTranslation();
    const {
        customers, loading, error,
        currentPage, totalPages, totalItems,
        setPage, searchTerm, setSearchTerm, sortStatus, setSortStatus,
        filters, setFilters,
        refetch
    }: UseAdminCustomersDataResult = useAdminCustomersData();
    const modals = useModals();

    const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(null);
    const [adjustModalOpened, { open: openAdjustModal, close: closeAdjustModal }] = useDisclosure(false);
    const [changeTierModalOpened, { open: openChangeTierModal, close: closeChangeTierModal }] = useDisclosure(false);
    const [assignRewardModalOpened, { open: openAssignRewardModal, close: closeAssignRewardModal }] = useDisclosure(false);
    const [detailsModalOpened, { open: openDetailsModal, close: closeDetailsModal }] = useDisclosure(false);
    const [bulkAdjustModalOpened, { open: openBulkAdjustModal, close: closeBulkAdjustModal }] = useDisclosure(false);
    const [selectedCustomerDetails, setSelectedCustomerDetails] = useState<CustomerDetails | null>(null);
    const [loadingDetails, setLoadingDetails] = useState<boolean>(false);
    const [errorDetails, setErrorDetails] = useState<string | null>(null);
    const [togglingFavoriteId, setTogglingFavoriteId] = useState<string | null>(null);
    const [togglingActiveId, setTogglingActiveId] = useState<string | null>(null);
    const [isSavingNotes, setIsSavingNotes] = useState<boolean>(false);
    const [selectedRowIds, setSelectedRowIds] = useState<string[]>([]);
    const [isPerformingBulkAction, setIsPerformingBulkAction] = useState<boolean>(false);
    const [tierOptions, setTierOptions] = useState<TierOption[]>([]);
    const [loadingTiers, setLoadingTiers] = useState<boolean>(true);

    useEffect(() => {
        const fetchTiersForFilter = async () => {
            setLoadingTiers(true);
            try {
                const response = await axiosInstance.get<{ id: string; name: string; level: number }[]>('/tiers');
                const sortedTiers = response.data.sort((a, b) => a.level - b.level);
                const options: TierOption[] = [
                    { value: '', label: t('adminCustomersPage.tierFilterAll') },
                    { value: 'NONE', label: t('adminCustomersPage.tierFilterNone') },
                    ...sortedTiers.map(tier => ({ value: tier.id, label: tier.name }))
                ];
                setTierOptions(options);
            } catch (err) {
                console.error("Error fetching tiers for filter:", err);
                notifications.show({ title: t('common.error'), message: t('adminCustomersPage.tierFilterError'), color: 'red' });
                setTierOptions([{ value: '', label: t('adminCustomersPage.tierFilterError') }]);
            } finally { setLoadingTiers(false); }
        };
        fetchTiersForFilter();
    }, [t]);

    const handleOpenAdjustPoints = useCallback((customer: Customer) => { setSelectedCustomer(customer); openAdjustModal(); }, [openAdjustModal]);
    const handleAdjustSuccess = useCallback(() => { refetch(); closeAdjustModal(); setSelectedCustomer(null); }, [refetch, closeAdjustModal]);
    const handleOpenChangeTier = useCallback((customer: Customer) => { setSelectedCustomer(customer); openChangeTierModal(); }, [openChangeTierModal]);
    const handleChangeTierSuccess = useCallback(() => { refetch(); closeChangeTierModal(); setSelectedCustomer(null); }, [refetch, closeChangeTierModal]);
    const handleOpenAssignReward = useCallback((customer: Customer) => { setSelectedCustomer(customer); openAssignRewardModal(); }, [openAssignRewardModal]);
    const handleAssignRewardSuccess = useCallback(() => { refetch(); closeAssignRewardModal(); setSelectedCustomer(null); }, [refetch, closeAssignRewardModal]);
    const handleCloseDetailsModal = () => { closeDetailsModal(); setSelectedCustomerDetails(null); setLoadingDetails(false); setErrorDetails(null); };

    const handleToggleFavorite = useCallback(async (customerId: string, currentIsFavorite: boolean) => {
        setTogglingFavoriteId(customerId);
        try {
            await adminCustomerService.toggleCustomerFavoriteApi(customerId);
            notifications.show({
                title: t('common.updateSuccess'),
                message: t('adminCustomersPage.bulkActionStatusSuccess', { // Reutilizando clave de acci√≥n masiva para mensaje similar
                    count: 1, // Implica un cliente
                    status: !currentIsFavorite
                        ? t('adminCustomersPage.bulkActionStatusActivated').replace('activado', 'marcado como favorito') // Adaptar
                        : t('adminCustomersPage.bulkActionStatusDeactivated').replace('desactivado', 'desmarcado de favorito') // Adaptar
                }),
                color: 'green', icon: <IconCheck />
            });
            refetch();
        } catch (err: any) {
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.bulkActionStatusError', { // Reutilizando clave
                    action: 'cambiar estado de favorito', // Adaptar
                    error: err.response?.data?.message || err.message
                }),
                color: 'red', icon: <IconX />
            });
        } finally { setTogglingFavoriteId(null); }
    }, [refetch, t]);

    const handleToggleActive = useCallback(async (customer: Customer) => {
        const actionText = customer.isActive ? t('adminCustomersPage.bulkConfirmToggleDeactivate') : t('adminCustomersPage.bulkConfirmToggleActivate');
        const currentStatusText = customer.isActive ? t('adminCustomersPage.bulkActionStatusDeactivated') : t('adminCustomersPage.bulkActionStatusActivated');

        if (!window.confirm(t('adminCustomersPage.bulkConfirmToggleActiveMessage', { action: actionText, count: 1 }))) return;

        setTogglingActiveId(customer.id);
        try {
            await adminCustomerService.toggleCustomerActiveApi(customer.id);
            notifications.show({
                title: t('common.updateSuccess'),
                message: t('adminCustomersPage.bulkActionStatusSuccess', { count: 1, status: currentStatusText }),
                color: 'green', icon: <IconCheck />,
            });
            refetch();
        } catch (err: any) {
            console.error(`Error toggling active status for customer ${customer.id}:`, err);
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.bulkActionStatusError', { action: actionText, error: err.response?.data?.message || err.message }),
                color: 'red', icon: <IconX />,
            });
        } finally { setTogglingActiveId(null); }
    }, [refetch, t]);

    const handleViewDetails = useCallback(async (customer: Customer) => {
        setSelectedCustomerDetails(null); setErrorDetails(null); setLoadingDetails(true); openDetailsModal();
        try {
            const details = await adminCustomerService.getCustomerDetailsApi(customer.id);
            setSelectedCustomerDetails(details);
        } catch (err: any) {
            setErrorDetails(err.response?.data?.message || err.message || t('adminCustomersPage.customerDetailsLoadingError'));
        } finally { setLoadingDetails(false); }
    }, [openDetailsModal, t]);

    const handleSaveNotes = useCallback(async (notes: string | null) => {
        if (!selectedCustomerDetails?.id) { return Promise.reject(new Error("Missing customer ID")); }
        setIsSavingNotes(true);
        try {
            await adminCustomerService.updateCustomerNotesApi(selectedCustomerDetails.id, notes);
            notifications.show({ title: t('common.saveSuccess'), message: t('adminCustomersPage.customerDetailsNotesSaved'), color: 'green', icon: <IconCheck /> });
            const details = await adminCustomerService.getCustomerDetailsApi(selectedCustomerDetails.id);
            setSelectedCustomerDetails(details);
        } catch (err: any) {
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
            notifications.show({ title: t('common.saveError'), message: t('adminCustomersPage.customerDetailsNotesError', { error: apiError }), color: 'red', icon: <IconX /> });
            throw err;
        } finally { setIsSavingNotes(false); }
    }, [selectedCustomerDetails, t]);

    const handleTableSort = useCallback((column: SortColumn) => { setSortStatus({ column, direction: sortStatus.column === column && sortStatus.direction === 'asc' ? 'desc' : 'asc' }); }, [sortStatus, setSortStatus]);
    const handleRowSelectionChange = useCallback((selectedIds: string[]) => { setSelectedRowIds(selectedIds); }, []);

    const handleBulkToggleActive = useCallback(async (targetStatus: boolean) => {
        const action = targetStatus ? t('adminCustomersPage.bulkConfirmToggleActivate') : t('adminCustomersPage.bulkConfirmToggleDeactivate');
        const count = selectedRowIds.length;
        if (count === 0) {
            notifications.show({ title: t('common.info'), message: t('adminCustomersPage.bulkActionNoneSelected'), color: 'yellow' });
            return;
        }
        if (!window.confirm(t('adminCustomersPage.bulkConfirmToggleActiveMessage', { action, count }))) return;

        setIsPerformingBulkAction(true);
        try {
            const response = await adminCustomerService.bulkUpdateCustomerStatusApi(selectedRowIds, targetStatus);
            const statusResult = targetStatus ? t('adminCustomersPage.bulkActionStatusActivated') : t('adminCustomersPage.bulkActionStatusDeactivated');
            notifications.show({ title: t('adminCommon.updateSuccess'), message: t('adminCustomersPage.bulkActionStatusSuccess', { count: response.count, status: statusResult }), color: 'green', icon: <IconCheck /> });
            refetch(); setSelectedRowIds([]);
        } catch (err: any) {
            console.error(`Error during bulk ${action}:`, err);
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
            notifications.show({ title: t('adminCommon.updateError'), message: t('adminCustomersPage.bulkActionStatusError', { action, error: apiError }), color: 'red', icon: <IconX /> });
        } finally { setIsPerformingBulkAction(false); }
    }, [selectedRowIds, refetch, t]);

    const handleBulkDelete = useCallback(() => {
        const count = selectedRowIds.length;
        if (count === 0) {
            notifications.show({ title: t('common.info'), message: t('adminCustomersPage.bulkActionNoneSelected'), color: 'yellow' });
            return;
        }
        modals.openConfirmModal({
            title: t('adminCustomersPage.bulkConfirmDeleteTitle'), centered: true,
            children: ( <Text size="sm">{t('adminCustomersPage.bulkConfirmDeleteMessage', { count })}</Text> ),
            labels: { confirm: t('adminCustomersPage.bulkConfirmDeleteButton'), cancel: t('common.cancel') },
            confirmProps: { color: 'red' }, zIndex: 1001,
            onConfirm: async () => {
                setIsPerformingBulkAction(true);
                try {
                    const response = await adminCustomerService.bulkDeleteCustomersApi(selectedRowIds);
                    notifications.show({ title: t('adminCommon.deleteSuccess'), message: t('adminCustomersPage.bulkActionDeleteSuccess', { count: response.count }), color: 'green', icon: <IconCheck /> });
                    refetch(); setSelectedRowIds([]);
                } catch (err: any) {
                    console.error(`Error during bulk delete:`, err);
                    const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
                    notifications.show({ title: t('adminCommon.deleteError'), message: t('adminCustomersPage.bulkActionDeleteError', { error: apiError }), color: 'red', icon: <IconX /> });
                } finally { setIsPerformingBulkAction(false); }
            },
        });
    }, [selectedRowIds, refetch, modals, t]);

    const handleBulkAdjustPointsSubmit = useCallback(async (values: { amount: number; reason?: string | undefined }) => {
        const { amount, reason } = values; const count = selectedRowIds.length;
        if (count === 0) {
            notifications.show({ title: t('common.error'), message: t('adminCustomersPage.bulkAdjustPointsErrorNoneSelected'), color: 'red' });
            return Promise.reject(new Error("No customers selected"));
        }
        setIsPerformingBulkAction(true); closeBulkAdjustModal();
        try {
            const response = await adminCustomerService.bulkAdjustCustomerPointsApi(selectedRowIds, amount, reason || null);
            const actionResult = amount > 0 ? t('adminCustomersPage.bulkAdjustPointsAdded') : t('adminCustomersPage.bulkAdjustPointsSubtracted');
            notifications.show({ title: t('adminCommon.updateSuccess'), message: t('adminCustomersPage.bulkAdjustPointsSuccess', { points: Math.abs(amount), action: actionResult, count: response.count }), color: 'green', icon: <IconCheck /> });
            refetch(); setSelectedRowIds([]);
        } catch (err: any) {
            console.error(`Error during bulk points adjustment:`, err);
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
            notifications.show({ title: t('adminCommon.updateError'), message: t('adminCustomersPage.bulkAdjustPointsError', { error: apiError }), color: 'red', icon: <IconX /> });
            throw err; // Relanzar para que el modal sepa que fall√≥ y no se cierre si as√≠ est√° programado
        } finally { setIsPerformingBulkAction(false); }
    }, [selectedRowIds, refetch, closeBulkAdjustModal, t]);

    const handleFilterSearchTermChange = (term: string) => setSearchTerm(term);
    const handleFilterActiveChange = (value: string | null) => {
        setFilters({ isActive: value === 'active' ? true : value === 'inactive' ? false : undefined });
    };
    const handleFilterFavoriteChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        setFilters({ isFavorite: event.currentTarget.checked ? true : undefined });
    };
    const handleFilterTierChange = (value: string | null) => {
        setFilters({ tierId: value || undefined });
    };

    const areFiltersActive = filters.isActive !== undefined || filters.isFavorite !== undefined || filters.tierId !== undefined;

    return (
        <>
            <Paper shadow="sm" p="lg" withBorder radius="lg">
                <Stack gap="lg">
                    <Title order={2}>{t('adminCustomersPage.title')}</Title>
                    <CustomerFiltersBar
                        searchTerm={searchTerm}
                        onSearchTermChange={handleFilterSearchTermChange}
                        activeFilterValue={filters.isActive === true ? 'active' : filters.isActive === false ? 'inactive' : ''}
                        onActiveFilterChange={handleFilterActiveChange}
                        isFavoriteFilterChecked={filters.isFavorite === true}
                        onIsFavoriteFilterChange={handleFilterFavoriteChange}
                        tierFilterValue={filters.tierId || ''}
                        onTierFilterChange={handleFilterTierChange}
                        tierOptions={tierOptions}
                        loadingFilters={loadingTiers}
                        disabled={loading || isPerformingBulkAction}
                    />
                    <CustomerBulkActionsBar
                        selectedRowCount={selectedRowIds.length}
                        onBulkDelete={handleBulkDelete}
                        onBulkActivate={() => handleBulkToggleActive(true)}
                        onBulkDeactivate={() => handleBulkToggleActive(false)}
                        onOpenBulkAdjustPoints={openBulkAdjustModal}
                        isPerformingBulkAction={isPerformingBulkAction}
                    />

                    {!loading && !error && (
                        <Group justify="space-between">
                            <Text size="sm" c="dimmed">
                                {t('adminCustomersPage.resultsCount', { count: totalItems })}
                                {searchTerm || areFiltersActive ? ` ${t('adminCustomersPage.resultsCountFiltered')}` : ''}.
                            </Text>
                        </Group>
                    )}
                    {loading && <Group justify="center" p="md"><Loader /></Group>}
                    {error && !loading && <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{error}</Alert>}
                    {!loading && !error && customers.length === 0 && totalItems > 0 && (
                         <Text c="dimmed" ta="center" p="md">{t('adminCustomersPage.noResultsFiltered')}</Text>
                     )}
                    {!loading && !error && totalItems === 0 && (
                         <Text c="dimmed" ta="center" p="md">{searchTerm || areFiltersActive ? t('adminCustomersPage.noResultsFiltered') : t('adminCustomersPage.noResults')}.</Text>
                     )}

                    {!loading && !error && customers.length > 0 && (
                        <CustomerTable
                            customers={customers}
                            sortStatus={sortStatus}
                            togglingFavoriteId={togglingFavoriteId}
                            togglingActiveId={togglingActiveId}
                            selectedRows={selectedRowIds}
                            onSort={handleTableSort}
                            onToggleFavorite={handleToggleFavorite}
                            onOpenAdjustPoints={handleOpenAdjustPoints}
                            onOpenChangeTier={handleOpenChangeTier}
                            onOpenAssignReward={handleOpenAssignReward}
                            onViewDetails={handleViewDetails}
                            onToggleActive={handleToggleActive}
                            onRowSelectionChange={handleRowSelectionChange}
                        />
                    )}
                    {!loading && !error && totalPages > 1 && (
                        <Group justify="center" mt="md">
                            <Pagination total={totalPages} value={currentPage} onChange={setPage} disabled={loading || isPerformingBulkAction}/>
                        </Group>
                    )}
                </Stack>
            </Paper>

            <AdjustPointsModal
                opened={adjustModalOpened}
                onClose={() => { closeAdjustModal(); setSelectedCustomer(null); }}
                customer={selectedCustomer}
                onSuccess={handleAdjustSuccess} // Este onSuccess ahora es solo para refetch y cerrar modal
            />
            <ChangeTierModal
                opened={changeTierModalOpened}
                onClose={() => { closeChangeTierModal(); setSelectedCustomer(null); }}
                customer={selectedCustomer}
                onSuccess={handleChangeTierSuccess} // Similarmente, para refetch y cerrar
            />
            <AssignRewardModal
                opened={assignRewardModalOpened}
                onClose={() => { closeAssignRewardModal(); setSelectedCustomer(null); }}
                customer={selectedCustomer}
                onSuccess={handleAssignRewardSuccess} // Similarmente
            />
            <CustomerDetailsModal
                opened={detailsModalOpened}
                onClose={handleCloseDetailsModal}
                customerDetails={selectedCustomerDetails}
                isLoading={loadingDetails || isSavingNotes}
                error={errorDetails}
                onSaveNotes={handleSaveNotes} // Este ya usa el servicio
            />
            <BulkAdjustPointsModal
                opened={bulkAdjustModalOpened}
                onClose={closeBulkAdjustModal}
                onSubmit={handleBulkAdjustPointsSubmit} // Este ya usa el servicio
                numberOfCustomers={selectedRowIds.length}
            />
        </>
    );
};

export default AdminCustomerManagementPage;


// ====== [94] frontend/src/modules/loyalpyme/pages/admin/AdminGenerateQr.tsx ======
// filename: frontend/src/pages/admin/AdminGenerateQr.tsx
import React from 'react';
import GenerateQrCode from '../../components/GenerateQrCode';
import { Paper, Stack, Title } from '@mantine/core';
import { useTranslation } from 'react-i18next';

const AdminGenerateQr: React.FC = () => {
    const { t } = useTranslation();

    return (
        <Paper shadow="xs" p="lg" withBorder radius="lg">
            <Stack gap="md">
                {/* Usamos la clave del t√≠tulo de la tarjeta de acceso r√°pido que ya ten√≠amos */}
                <Title order={2}>{t('adminOverview.cardQrTitle')}</Title>
                <GenerateQrCode />
            </Stack>
        </Paper>
    );
};

export default AdminGenerateQr;


// ====== [95] frontend/src/modules/loyalpyme/pages/admin/AdminOverview.tsx ======
// frontend/src/pages/admin/AdminOverview.tsx
import { useEffect, useState, FC } from 'react';
import {
    Container, Title, Text, SimpleGrid, Card, Button, Group, Stack,
    Loader, Alert
} from '@mantine/core';
import {
    IconGift, IconStairsUp, IconQrcode, IconUsers, IconSettings,
    IconUserPlus, IconTicket, IconAlertCircle, IconToolsKitchen
} from '@tabler/icons-react';
import { Link } from 'react-router-dom';
import { useTranslation } from 'react-i18next';

import { useAdminOverviewStats } from '../../hooks/useAdminOverviewStats';
import StatCard from '../../components/admin/StatCard';
import { useLayoutUserData } from '../../../../shared/hooks/useLayoutUserData';

const AdminOverview: FC = () => {
    const { t } = useTranslation();
    const { userData: layoutUserData, loadingUser: loadingLayoutUser } = useLayoutUserData();
    const [adminName, setAdminName] = useState<string | null>(null);
    const [businessName, setBusinessName] = useState<string | null>(null);

    const {
        statsData,
        loadingStats,
        errorStats,
        newCustomersTrend,
        pointsIssuedTrend,
        rewardsRedeemedTrend,
    } = useAdminOverviewStats();

    useEffect(() => {
        if (layoutUserData) {
            setAdminName(layoutUserData.name || layoutUserData.email || t('adminCommon.adminTitle'));
            // Como discutimos, /api/profile no devuelve el nombre del negocio directamente en layoutUserData.
            // Si quisieras el nombre real del negocio aqu√≠, necesitar√≠as:
            // 1. Que /api/profile (auth.middleware.ts) a√±ada business.name a req.user
            // 2. O hacer una llamada API separada aqu√≠ para obtener los detalles del layoutUserData.businessId
            // Por ahora, mantenemos el placeholder.
            setBusinessName(t('adminOverview.defaultBusinessName'));
        } else if (!loadingLayoutUser) {
            setAdminName(t('adminCommon.adminTitle'));
            setBusinessName(t('adminOverview.defaultBusinessName'));
        }
    }, [layoutUserData, loadingLayoutUser, t]);

    const routes = {
        rewards: '/admin/dashboard/rewards',
        generateQr: '/admin/dashboard/generate-qr',
        manageTiers: '/admin/dashboard/tiers/manage',
        settingsTiers: '/admin/dashboard/tiers/settings',
        customers: '/admin/dashboard/customers',
        camareroMenuEditor: "/admin/dashboard/camarero/menu-editor", // Ruta actualizada
    };

    const isLoadingPage = loadingLayoutUser || loadingStats;

    const quickAccessCards = [
        {
            titleKey: 'adminOverview.cardRewardsTitle',
            descriptionKey: 'adminOverview.cardRewardsDesc',
            buttonTextKey: 'adminOverview.cardRewardsButton',
            icon: IconGift,
            color: 'blue',
            to: routes.rewards,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true,
        },
        {
            titleKey: 'adminOverview.cardTiersTitle',
            descriptionKey: 'adminOverview.cardTiersDesc',
            buttonTextKey: 'adminOverview.cardTiersButton',
            icon: IconStairsUp,
            color: 'teal',
            to: routes.manageTiers,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true,
        },
        {
            titleKey: 'adminOverview.cardTierSettingsTitle',
            descriptionKey: 'adminOverview.cardTierSettingsDesc',
            buttonTextKey: 'adminOverview.cardTierSettingsButton',
            icon: IconSettings,
            color: 'orange',
            to: routes.settingsTiers,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true,
        },
        {
            titleKey: 'adminOverview.cardQrTitle',
            descriptionKey: 'adminOverview.cardQrDesc',
            buttonTextKey: 'adminOverview.cardQrButton',
            icon: IconQrcode,
            color: 'grape',
            to: routes.generateQr,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true,
        },
        {
            titleKey: 'adminOverview.cardCustomersTitle',
            descriptionKey: 'adminOverview.cardCustomersDesc',
            buttonTextKey: 'adminOverview.cardCustomersButton',
            icon: IconUsers,
            color: 'indigo',
            to: routes.customers,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true || layoutUserData?.isCamareroActive === true,
        },
        // Tarjeta para Gesti√≥n de Men√∫ del M√≥dulo Camarero
        {
            titleKey: 'adminCamarero.manageMenu.title', // Usar clave de t√≠tulo de p√°gina para consistencia
            descriptionKey: 'adminCamarero.cardMenuDesc', // Clave para descripci√≥n de la tarjeta
            buttonTextKey: 'adminCamarero.cardMenuButton', // Clave para texto del bot√≥n
            icon: IconToolsKitchen,
            color: 'lime',
            to: routes.camareroMenuEditor, // Ruta correcta
            showCondition: layoutUserData?.isCamareroActive === true,
        },
    ];

    if (isLoadingPage && !statsData && !layoutUserData) {
        return <Container size="lg" mt="md"><Group justify="center" p="xl"><Loader /></Group></Container>;
    }

    return (
        <Container size="lg" mt="md">
            <Stack gap="xl">
                <Title order={2}>{t('adminOverview.welcome', { name: adminName || t('adminCommon.adminTitle') })}</Title>
                <Text fz="lg">
                    {t('adminOverview.panelIntro')}{' '}
                    <Text span fw={700}>{businessName || '...'}</Text>.
                </Text>
                <Text c="dimmed">{t('adminOverview.panelDescription')}</Text>

                <Title order={3} mt="lg">{t('adminOverview.quickSummaryTitle')}</Title>
                {loadingStats && !statsData && ( <Group justify="center" p="lg"><Loader size="sm" /></Group> )}
                {errorStats && !loadingStats && ( <Alert title={t('common.errorLoadingData')} color="red" icon={<IconAlertCircle size={18} />}>{errorStats}</Alert> )}
                {!loadingStats && !errorStats && statsData && (
                    <SimpleGrid cols={{ base: 1, sm: 2, lg: 4 }}>
                        <StatCard title={t('adminOverview.statActiveCustomers')} value={statsData.totalActiveCustomers} icon={<IconUsers size={24} stroke={1.5} />} color="blue" />
                        <StatCard title={t('adminOverview.statNewCustomers')} value={statsData.newCustomersLast7Days} icon={<IconUserPlus size={24} stroke={1.5} />} color="teal" trendValue={newCustomersTrend.trendValue} trendDirection={newCustomersTrend.trendDirection} />
                        <StatCard title={t('adminOverview.statPointsIssued')} value={statsData.pointsIssuedLast7Days} icon={<IconTicket size={24} stroke={1.5} />} color="grape" trendValue={pointsIssuedTrend.trendValue} trendDirection={pointsIssuedTrend.trendDirection} />
                        <StatCard title={t('adminOverview.statRedemptions')} value={statsData.rewardsRedeemedLast7Days} icon={<IconGift size={24} stroke={1.5} />} color="orange" trendValue={rewardsRedeemedTrend.trendValue} trendDirection={rewardsRedeemedTrend.trendDirection} />
                    </SimpleGrid>
                )}
                {!loadingStats && !errorStats && !statsData && ( <Text c="dimmed" ta="center">{t('adminOverview.noStatsAvailable')}</Text> )}

                <Title order={3} mt="lg">{t('adminOverview.quickAccessTitle')}</Title>
                <SimpleGrid cols={{ base: 1, sm: 2, md: 3 }}>
                    {quickAccessCards.filter(card => card.showCondition).map((card) => (
                        <Card shadow="sm" padding="lg" radius="md" withBorder key={card.to}>
                            <Group justify="space-between" mt="md" mb="xs">
                                <Text fw={500}>{t(card.titleKey)}</Text>
                                <card.icon size={24} stroke={1.5} />
                            </Group>
                            <Text size="sm" c="dimmed">{t(card.descriptionKey)}</Text>
                            <Button variant="light" color={card.color} fullWidth mt="md" radius="md" component={Link} to={card.to}>
                                {t(card.buttonTextKey)}
                            </Button>
                        </Card>
                    ))}
                </SimpleGrid>
                {quickAccessCards.filter(card => card.showCondition).length === 0 && !isLoadingPage && (
                    <Text c="dimmed" ta="center">{t('adminOverview.noModulesActivePrompt')}</Text>
                )}
            </Stack>
        </Container>
    );
};

export default AdminOverview;


// ====== [96] frontend/src/modules/loyalpyme/pages/admin/AdminRewardsManagement.tsx ======
// filename: frontend/src/pages/admin/AdminRewardsManagement.tsx
// Version: 1.4.4 (Fix hydration warnings and Tooltip error)

import React, { useState, useCallback } from 'react';
import {
    Group, Button, Title, Text, Loader, Alert, Paper, Stack,
    Table, Badge, ActionIcon, Tooltip, Modal,
} from '@mantine/core';
import { useDisclosure, useMediaQuery } from '@mantine/hooks';
import { useMantineTheme } from '@mantine/core';
import {
    IconAlertCircle, IconPencil, IconTrash, IconToggleLeft, IconToggleRight,
    IconPlus
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useAdminRewards } from '../../hooks/useAdminRewards';
import type { Reward } from '../../types/customer';
import RewardForm from '../../components/admin/rewards/RewardForm.tsx';

const AdminRewardsManagement: React.FC = () => {
    const { t, i18n } = useTranslation();
    const { rewards, loading, error, actionLoading, fetchRewards, handleToggleActive, handleDeleteReward } = useAdminRewards();
    const [showAddForm, setShowAddForm] = useState<boolean>(false);
    const [editModalOpened, { open: openEditModalHandler, close: closeEditModal }] = useDisclosure(false);
    const [editingReward, setEditingReward] = useState<Reward | null>(null);
    const theme = useMantineTheme();
    const isMobile = useMediaQuery(`(max-width: ${theme.breakpoints.sm})`);

    const handleRewardAdded = useCallback(() => { setShowAddForm(false); fetchRewards(); }, [fetchRewards]);
    const handleOpenEditModal = (reward: Reward) => { setEditingReward(reward); openEditModalHandler(); };
    const handleCloseEditModal = () => { closeEditModal(); setEditingReward(null); };
    const handleRewardUpdated = useCallback(() => { handleCloseEditModal(); fetchRewards(); }, [fetchRewards, handleCloseEditModal]);

    const confirmAndDeleteReward = useCallback((reward: Reward) => {
        const displayName = (i18n.language === 'es' ? reward.name_es : reward.name_en) || reward.name_es || reward.name_en || `ID ${reward.id}`;
        if (window.confirm(t('adminRewardsPage.confirmDeleteMessage', { name: displayName }))) {
            handleDeleteReward(reward.id, displayName);
        }
    }, [handleDeleteReward, t, i18n.language]);


    // --- Renderizado de la Tabla ACTUALIZADO (Limpieza JSX) ---
    const renderRewardsTable = () => {
        const rows = rewards.map((reward) => {
            const iconSize = 14;
            const isLoadingToggle = actionLoading?.type === 'toggle' && actionLoading?.id === reward.id;
            const isLoadingDelete = actionLoading?.type === 'delete' && actionLoading?.id === reward.id;
            const isAnyActionLoading = !!actionLoading;
            const displayName = (i18n.language === 'es' ? reward.name_es : reward.name_en) || reward.name_es || reward.name_en || '(Sin nombre)';

            // Definimos los iconos con Tooltip por separado
            const editIcon = (
                <Tooltip label={t('adminRewardsPage.tooltipEdit')} withArrow position={isMobile ? 'bottom' : 'left'}>
                    <ActionIcon variant="subtle" color="blue" onClick={() => handleOpenEditModal(reward)} disabled={isAnyActionLoading}>
                        <IconPencil size={iconSize} stroke={1.5} />
                    </ActionIcon>
                </Tooltip>
            );
            const toggleIcon = (
                <Tooltip label={reward.isActive ? t('adminRewardsPage.tooltipDeactivate') : t('adminRewardsPage.tooltipActivate')} withArrow position="top">
                    <ActionIcon variant="subtle" color={reward.isActive ? 'orange' : 'teal'} onClick={() => handleToggleActive(reward.id, reward.isActive)} loading={isLoadingToggle} disabled={isAnyActionLoading}>
                        {reward.isActive ? <IconToggleLeft size={iconSize} stroke={1.5} /> : <IconToggleRight size={iconSize} stroke={1.5} />}
                    </ActionIcon>
                </Tooltip>
            );
             const deleteIcon = (
                <Tooltip label={t('adminRewardsPage.tooltipDelete')} withArrow position={isMobile ? 'bottom' : 'right'}>
                    <ActionIcon variant="subtle" color="red" onClick={() => confirmAndDeleteReward(reward)} loading={isLoadingDelete} disabled={isAnyActionLoading}>
                        <IconTrash size={iconSize} stroke={1.5} />
                    </ActionIcon>
                </Tooltip>
             );

            // El <></> que devolv√≠a actionIcons podr√≠a causar problemas con Tooltip.
            // Ahora renderizamos los iconos directamente dentro de Group o Stack.
            return (
                // No dejar espacios extra entre <Table.Tr> y <Table.Td>
                <Table.Tr key={reward.id}>
                    <Table.Td fz={{ base: 'xs', sm: 'sm' }}>{displayName}</Table.Td>
                    <Table.Td fz={{ base: 'xs', sm: 'sm' }}>{reward.pointsCost}</Table.Td>
                    <Table.Td><Badge color={reward.isActive ? 'green' : 'gray'} variant="light" radius="lg" fz={{ base: 'xs', sm: 'sm' }}>{reward.isActive ? t('common.active') : t('common.inactive')}</Badge></Table.Td>
                    <Table.Td>
                        {isMobile ? (
                            <Stack gap={2} align="flex-end">{/* No dejar espacio extra aqu√≠ */}
                                {editIcon}
                                {toggleIcon}
                                {deleteIcon}
                            </Stack>
                        ) : (
                            <Group gap="xs" justify="flex-end" wrap="nowrap">{/* No dejar espacio extra aqu√≠ */}
                                {editIcon}
                                {toggleIcon}
                                {deleteIcon}
                            </Group>
                        )}
                    </Table.Td>
                </Table.Tr> // No dejar espacio extra aqu√≠
            );
        });

        return (
            // No dejar espacios extra entre elementos de tabla
            <Table striped highlightOnHover withTableBorder withColumnBorders verticalSpacing="sm">
                <Table.Thead>
                    <Table.Tr>
                        <Table.Th fz={{ base: 'xs', sm: 'sm' }}>{t('adminRewardsPage.tableHeaderName')}</Table.Th>
                        <Table.Th fz={{ base: 'xs', sm: 'sm' }}>{t('adminRewardsPage.tableHeaderCost')}</Table.Th>
                        <Table.Th fz={{ base: 'xs', sm: 'sm' }}>{t('adminRewardsPage.tableHeaderStatus')}</Table.Th>
                        <Table.Th style={{ textAlign: 'right' }} fz={{ base: 'xs', sm: 'sm' }}>{t('adminRewardsPage.tableHeaderActions')}</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>{rows}</Table.Tbody>
            </Table>
        );
    };
     // --- FIN Renderizado Tabla ---

    // Renderizado condicional (sin cambios)
    const renderRewardsSectionContent = () => { /* ... (sin cambios) ... */ if (loading && rewards.length === 0) return <Group justify="center" p="lg"><Loader /></Group>; if (error && rewards.length === 0) return (<Alert icon={<IconAlertCircle size={16} />} title={t('common.errorLoadingData')} color="red" radius="lg">{error}</Alert>); if (!loading && rewards.length === 0 && !showAddForm) return <Text c="dimmed" ta="center" p="lg">{t('adminRewardsPage.noRewardsYet')}</Text>; if (rewards.length > 0) return renderRewardsTable(); return null; };

    // RENDER PRINCIPAL (sin cambios)
    return (
        <>
            <Paper shadow="xs" p="lg" withBorder radius="lg">
                <Stack gap="md">
                    <Group justify="space-between" align="flex-start"> <Title order={2}>{t('adminRewardsPage.title')}</Title> <Button leftSection={showAddForm ? undefined : <IconPlus size={18} />} onClick={() => setShowAddForm(!showAddForm)} disabled={loading && rewards.length === 0} variant={showAddForm ? "outline" : "filled"} radius="lg" > {showAddForm ? t('adminRewardsPage.cancelAddButton') : t('adminRewardsPage.addButton')} </Button> </Group>
                     {renderRewardsSectionContent()}
                    {showAddForm && ( <Paper withBorder p="md" mt="md" radius="lg"> <RewardForm mode="add" onSubmitSuccess={handleRewardAdded} onCancel={() => setShowAddForm(false)} /> </Paper> )}
                </Stack>
            </Paper>
            <Modal opened={editModalOpened} onClose={handleCloseEditModal} title={t('adminRewardsPage.editFormTitle')} centered radius="lg" size="lg" overlayProps={{ backgroundOpacity: 0.55, blur: 3 }} >
                {editingReward && ( <RewardForm mode="edit" initialData={editingReward} rewardIdToUpdate={editingReward.id} onSubmitSuccess={handleRewardUpdated} onCancel={handleCloseEditModal} /> )}
            </Modal>
        </>
    );
};

export default AdminRewardsManagement;


// ====== [97] frontend/src/modules/loyalpyme/pages/admin/tiers/TierManagementPage.tsx ======
// filename: frontend/src/pages/admin/tiers/TierManagementPage.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
    Paper, Title, Stack, Button, Group, Loader, Alert,
    Text
} from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { notifications } from '@mantine/notifications';
import { IconPlus, IconAlertCircle, IconCheck } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';
import { useTranslation } from 'react-i18next'; // Importar hook

// Importar componentes
import TierTable from '../../../components/admin/tiers/TierTable';
import CreateTierModal from '../../../components/admin/tiers/CreateTierModal';
import DeleteTierModal from '../../../components/admin/tiers/DeleteTierModal';
import EditTierModal from '../../../components/admin/tiers/EditTierModal';
import TierBenefitsModal from '../../../components/admin/tiers/TierBenefitsModal';

// Tipos
enum BenefitType { POINTS_MULTIPLIER = 'POINTS_MULTIPLIER', EXCLUSIVE_REWARD_ACCESS = 'EXCLUSIVE_REWARD_ACCESS', CUSTOM_BENEFIT = 'CUSTOM_BENEFIT' }
interface TierBenefit { id: string; isActive: boolean; type: BenefitType; value: string; description: string | null; }
interface Tier { id: string; name: string; level: number; minValue: number; description: string | null; benefitsDescription: string | null; isActive: boolean; benefits: TierBenefit[]; }


const TierManagementPage: React.FC = () => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    // Estado
    const [tiers, setTiers] = useState<Tier[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [deletingTier, setDeletingTier] = useState<Tier | null>(null);
    const [deleteModalOpened, { open: openDeleteModal, close: closeDeleteModal }] = useDisclosure(false);
    const [createModalOpened, { open: openCreateModal, close: closeCreateModal }] = useDisclosure(false);
    const [editingTier, setEditingTier] = useState<Tier | null>(null);
    const [editModalOpened, { open: openEditModal, close: closeEditModal }] = useDisclosure(false);
    const [viewingBenefitsForTier, setViewingBenefitsForTier] = useState<Tier | null>(null);
    const [benefitsModalOpened, { open: openBenefitsModal, close: closeBenefitsModal }] = useDisclosure(false);

    // L√≥gica de Datos
    const fetchTiers = useCallback(async () => {
        setLoading(true); setError(null);
        try {
            const response = await axiosInstance.get<Tier[]>('/tiers?includeBenefits=true');
            setTiers(response.data);
        } catch (err: any) {
            console.error("Error fetching tiers:", err);
            const message = err.response?.data?.message || t('adminCommon.errorLoadingData'); // Usar t() para error gen√©rico
            setError(message);
            notifications.show({
                title: t('common.errorLoadingData'), // T√≠tulo gen√©rico
                message: message,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
        } finally {
            setLoading(false);
        }
    }, [t]); // A√±adir t como dependencia

    useEffect(() => {
        fetchTiers();
    }, [fetchTiers]);

    // Handlers CRUD
    const handleCreate = () => { openCreateModal(); };
    const handleCreateSuccess = () => { fetchTiers(); }; // Ya no muestra notificaci√≥n, el modal lo hace
    const handleEdit = (tierId: string) => {
        const tierToEdit = tiers.find(t => t.id === tierId);
        if (tierToEdit) {
            setEditingTier(tierToEdit);
            openEditModal();
        } else {
            console.error(`Tier with ID ${tierId} not found for editing.`);
            notifications.show({
                title: t('common.error'), // T√≠tulo gen√©rico
                message: t('adminTiersManagePage.deleteErrorNotFound'), // Mensaje espec√≠fico
                color: 'orange'
            });
        }
    };
    const handleEditSuccess = () => { fetchTiers(); setEditingTier(null); }; // Notificaci√≥n en modal
    const confirmDelete = (tierId: string) => {
        const tierToDelete = tiers.find(t => t.id === tierId);
        if (tierToDelete) {
            setDeletingTier(tierToDelete);
            openDeleteModal(); // El modal DeleteTierModal ahora necesitar√° usar t() internamente
        }
    };
    const handleDelete = async () => {
        if (!deletingTier) return;
        const tierToDeleteId = deletingTier.id;
        const tierToDeleteName = deletingTier.name;
        closeDeleteModal();

        // Usar t() para las notificaciones de borrado
        notifications.show({
            id: `delete-tier-${tierToDeleteId}`,
            title: t('common.deleting', 'Eliminando...'), // Nueva clave
            message: t('adminTiersManagePage.deleteLoadingMessage', { name: tierToDeleteName }),
            loading: true,
            autoClose: false,
            withCloseButton: false,
        });

        try {
            await axiosInstance.delete(`/tiers/tiers/${tierToDeleteId}`);
            notifications.update({
                id: `delete-tier-${tierToDeleteId}`,
                title: t('adminTiersManagePage.deleteSuccessTitle'),
                message: t('adminTiersManagePage.deleteSuccessMessage', { name: tierToDeleteName }),
                color: 'green',
                icon: <IconCheck size={18} />,
                loading: false,
                autoClose: 4000,
            });
            setDeletingTier(null);
            fetchTiers();
        } catch (err: any) {
            console.error(`Error deleting tier ${tierToDeleteId}:`, err);
            const message = err.response?.data?.message || t('adminTiersManagePage.deleteErrorMessage');
            notifications.update({
                id: `delete-tier-${tierToDeleteId}`,
                title: t('adminTiersManagePage.deleteErrorTitle'),
                message: message,
                color: 'red',
                icon: <IconAlertCircle size={18} />,
                loading: false,
                autoClose: 6000,
            });
            setDeletingTier(null);
        }
    };
    const handleManageBenefits = (tier: Tier) => {
        setViewingBenefitsForTier(tier);
        openBenefitsModal(); // El modal TierBenefitsModal necesita usar t() internamente
    };

    // Renderizado
    return (
        <>
            <Paper shadow="sm" p="lg" withBorder radius="lg">
                <Stack gap="lg">
                    <Group justify="space-between">
                        <Title order={2}>{t('adminTiersManagePage.title')}</Title>
                        <Button leftSection={<IconPlus size={18} />} onClick={handleCreate}>
                            {t('adminTiersManagePage.addButton')}
                        </Button>
                    </Group>

                    {loading && <Group justify="center" mt="xl"><Loader /></Group>}
                    {error && !loading &&
                        <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>
                            {error}
                        </Alert>
                    }

                    {!loading && !error && (
                        // TierTable necesita i18n internamente
                        <TierTable
                            tiers={tiers}
                            onEditClick={handleEdit}
                            onDeleteClick={confirmDelete}
                            onManageBenefitsClick={handleManageBenefits}
                        />
                    )}
                    {!loading && !error && tiers.length === 0 && (
                        <Text c="dimmed" ta="center" mt="md">{t('adminTiersManagePage.noTiersDefined')}</Text>
                    )}
                </Stack>
            </Paper>

            {/* Modales (necesitan i18n internamente) */}
            <CreateTierModal
                opened={createModalOpened}
                onClose={closeCreateModal}
                onSuccess={handleCreateSuccess} />
            <DeleteTierModal
                opened={deleteModalOpened}
                onClose={() => { setDeletingTier(null); closeDeleteModal(); }}
                onConfirm={handleDelete}
                tierName={deletingTier?.name} />
            {editingTier && (
                <EditTierModal
                    opened={editModalOpened}
                    onClose={() => { setEditingTier(null); closeEditModal();}}
                    onSuccess={handleEditSuccess}
                    tier={editingTier} />
            )}
            {viewingBenefitsForTier && (
                <TierBenefitsModal
                    opened={benefitsModalOpened}
                    onClose={() => { setViewingBenefitsForTier(null); closeBenefitsModal(); }}
                    tier={viewingBenefitsForTier} />
            )}
        </>
    );
};

export default TierManagementPage;


// ====== [98] frontend/src/modules/loyalpyme/pages/admin/tiers/TierSettingsPage.tsx ======
// filename: frontend/src/pages/admin/tiers/TierSettingsPage.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
    Paper, Title, Stack, Switch, Select, NumberInput, Button, Loader, Alert, Group, LoadingOverlay, Text
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { notifications } from '@mantine/notifications';
import { IconAlertCircle, IconCheck, IconDeviceFloppy } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';
import { useTranslation } from 'react-i18next'; // Importar hook

// Tipos/Enums
enum TierCalculationBasis { SPEND = 'SPEND', VISITS = 'VISITS', POINTS_EARNED = 'POINTS_EARNED' }
enum TierDowngradePolicy { NEVER = 'NEVER', PERIODIC_REVIEW = 'PERIODIC_REVIEW', AFTER_INACTIVITY = 'AFTER_INACTIVITY' }

interface TierConfigData {
    tierSystemEnabled: boolean;
    tierCalculationBasis: TierCalculationBasis | null;
    tierCalculationPeriodMonths: number | null;
    tierDowngradePolicy: TierDowngradePolicy;
    inactivityPeriodMonths: number | null;
}

const TierSettingsPage: React.FC = () => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [isLoading, setIsLoading] = useState<boolean>(true);
    const [isSaving, setIsSaving] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    const form = useForm<TierConfigData>({
        initialValues: {
            tierSystemEnabled: false,
            tierCalculationBasis: null,
            tierCalculationPeriodMonths: null,
            tierDowngradePolicy: TierDowngradePolicy.NEVER,
            inactivityPeriodMonths: null,
        },
        // Validaci√≥n no necesita t() aqu√≠ directamente si los mensajes son gen√©ricos o manejados por Mantine/Zod
        validate: (values) => ({
            // L√≥gica de validaci√≥n se mantiene, los mensajes se pueden mejorar si es necesario
             tierCalculationBasis: (!values.tierSystemEnabled || values.tierCalculationBasis) ? null : t('common.requiredField'), // Ejemplo gen√©rico
             tierCalculationPeriodMonths: (!values.tierSystemEnabled || !values.tierCalculationBasis || values.tierCalculationBasis === TierCalculationBasis.POINTS_EARNED) ? null : (values.tierCalculationPeriodMonths === null || values.tierCalculationPeriodMonths <= 0) ? t('validation.mustBePositive', 'Debe ser > 0') : null, // Clave nueva propuesta
             inactivityPeriodMonths: (!values.tierSystemEnabled || values.tierDowngradePolicy !== TierDowngradePolicy.AFTER_INACTIVITY) ? null : (values.inactivityPeriodMonths === null || values.inactivityPeriodMonths <= 0) ? t('validation.mustBePositive', 'Debe ser > 0') : null, // Clave nueva propuesta
         }),
    });

    // fetchConfig (usar t() en mensajes de error)
    const fetchConfig = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        try {
            const response = await axiosInstance.get<TierConfigData>('/tiers/config');
            const fetchedConfig = {
                tierSystemEnabled: response.data.tierSystemEnabled ?? false,
                tierCalculationBasis: response.data.tierCalculationBasis ?? null,
                tierCalculationPeriodMonths: response.data.tierCalculationPeriodMonths ?? null,
                tierDowngradePolicy: response.data.tierDowngradePolicy ?? TierDowngradePolicy.NEVER,
                inactivityPeriodMonths: response.data.inactivityPeriodMonths ?? null,
            };
            form.setValues(fetchedConfig);
            form.resetDirty(fetchedConfig); // Asegurar que el estado inicial no est√© 'dirty'
            console.log("Config fetched and form set:", fetchedConfig);
        } catch (err: any) {
            console.error("Error fetching tier config:", err);
            const message = err.response?.data?.message || t('adminTiersSettingsPage.errorLoading');
            setError(message);
            notifications.show({ title: t('common.errorLoadingData'), message, color: 'red', icon: <IconAlertCircle size={18} /> });
        } finally {
            setIsLoading(false);
        }
     // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [t]); // A√±adir t como dependencia

    useEffect(() => {
        fetchConfig();
    }, [fetchConfig]);

    // handleSaveChanges (usar t() en mensajes de notificaci√≥n/error)
    const handleSaveChanges = async (values: TierConfigData) => {
        setIsSaving(true);
        setError(null);
        const dataToSend = { /* ... l√≥gica sin cambios ... */
            ...values,
             tierCalculationPeriodMonths: values.tierCalculationPeriodMonths || null,
             inactivityPeriodMonths: values.inactivityPeriodMonths || null,
             tierCalculationBasis: values.tierSystemEnabled ? values.tierCalculationBasis : null,
        };
         if (dataToSend.tierCalculationBasis === TierCalculationBasis.POINTS_EARNED) { dataToSend.tierCalculationPeriodMonths = null; }
         if (dataToSend.tierDowngradePolicy !== TierDowngradePolicy.AFTER_INACTIVITY) { dataToSend.inactivityPeriodMonths = null; }

        console.log("Saving config:", dataToSend);
        try {
            await axiosInstance.put('/tiers/config', dataToSend);
            notifications.show({
                title: t('adminTiersSettingsPage.successSaving'), // Usar t√≠tulo espec√≠fico
                message: t('adminTiersSettingsPage.successSaving'), // Usar mismo texto como mensaje por ahora
                color: 'green',
                icon: <IconCheck size={18} />
            });
            form.setValues(values);
            form.resetDirty(values); // Resetear dirty con los nuevos valores guardados
        } catch (err: any) {
            console.error("Error saving tier config:", err);
            const message = err.response?.data?.message || t('adminTiersSettingsPage.errorSaving');
            setError(message);
            notifications.show({
                title: t('adminCommon.saveError'), // T√≠tulo gen√©rico de error
                message,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
        } finally {
            setIsSaving(false);
        }
    };

    // Opciones para Selects (usando t())
    const basisOptions = Object.values(TierCalculationBasis).map(value => ({
        value,
        label: t(`adminTiersSettingsPage.basisOption_${value}`)
    }));
    const policyOptions = Object.values(TierDowngradePolicy).map(value => ({
        value,
        label: t(`adminTiersSettingsPage.downgradePolicyOption_${value}`)
    }));

    // Renderizado
    if (isLoading) {
        return <Group justify="center" mt="xl"><Loader /></Group>;
    }
    // Usar t() en t√≠tulo del Alert de error
    if (error && !isLoading && form.values.tierCalculationBasis === null && !form.values.tierSystemEnabled) {
        return <Alert title={t('common.errorLoadingData')} color="red" icon={<IconAlertCircle />}>{error}</Alert>;
    }

    return (
        <Paper shadow="sm" p="lg" withBorder radius="lg" style={{ position: 'relative' }}>
            <LoadingOverlay visible={isSaving} zIndex={1000} overlayProps={{ radius: "sm", blur: 2 }} />
            <Title order={2} mb="xl">{t('adminTiersSettingsPage.title')}</Title>
            <Text c="dimmed" size="sm" mb="lg">
                {t('adminTiersSettingsPage.description')}
            </Text>

            <form onSubmit={form.onSubmit(handleSaveChanges)}>
                <Stack gap="lg">
                    {/* Usar t() para labels y descriptions */}
                    <Switch
                        label={t('adminTiersSettingsPage.enableSystemLabel')}
                        description={t('adminTiersSettingsPage.enableSystemDescription')}
                        disabled={isSaving}
                        {...form.getInputProps('tierSystemEnabled', { type: 'checkbox' })}
                    />
                    <Select
                        label={t('adminTiersSettingsPage.basisLabel')}
                        placeholder={!form.values.tierSystemEnabled ? t('adminTiersSettingsPage.basisPlaceholderDisabled') : t('adminTiersSettingsPage.basisPlaceholder')}
                        data={basisOptions}
                        disabled={isSaving || !form.values.tierSystemEnabled}
                        clearable
                        description={t('adminTiersSettingsPage.basisDescription')}
                        {...form.getInputProps('tierCalculationBasis')}
                    />
                    <NumberInput
                        label={t('adminTiersSettingsPage.periodLabel')}
                        placeholder={!form.values.tierCalculationBasis || form.values.tierCalculationBasis === TierCalculationBasis.POINTS_EARNED ? t('adminTiersSettingsPage.periodPlaceholderNA') : t('adminTiersSettingsPage.periodPlaceholder')}
                        description={t('adminTiersSettingsPage.periodDescription')}
                        min={0}
                        step={1}
                        allowDecimal={false}
                        disabled={isSaving || !form.values.tierSystemEnabled || !form.values.tierCalculationBasis || form.values.tierCalculationBasis === TierCalculationBasis.POINTS_EARNED}
                        {...form.getInputProps('tierCalculationPeriodMonths')}
                    />
                    <Select
                        label={t('adminTiersSettingsPage.downgradePolicyLabel')}
                        placeholder={t('adminTiersSettingsPage.downgradePolicyPlaceholder')}
                        data={policyOptions}
                        disabled={isSaving || !form.values.tierSystemEnabled}
                        clearable={false}
                        description={t('adminTiersSettingsPage.downgradePolicyDescription')}
                        {...form.getInputProps('tierDowngradePolicy')}
                    />
                    {form.values.tierDowngradePolicy === TierDowngradePolicy.AFTER_INACTIVITY && (
                        <NumberInput
                            label={t('adminTiersSettingsPage.inactivityLabel')}
                            placeholder={t('adminTiersSettingsPage.inactivityPlaceholder')}
                            description={t('adminTiersSettingsPage.inactivityDescription')}
                            min={1}
                            step={1}
                            allowDecimal={false}
                            disabled={isSaving || !form.values.tierSystemEnabled}
                            required
                            {...form.getInputProps('inactivityPeriodMonths')}
                        />
                    )}

                    {error && (
                        <Alert title={t('common.error')} color="red" icon={<IconAlertCircle size="1rem" />} mt="md" withCloseButton onClose={() => setError(null)}>
                            {error}
                        </Alert>
                    )}

                    <Group justify="flex-end" mt="xl">
                        <Button
                            type="submit"
                            disabled={!form.isDirty() || isSaving}
                            loading={isSaving}
                            leftSection={<IconDeviceFloppy size={18} />}
                        >
                            {t('adminTiersSettingsPage.saveButton')}
                        </Button>
                    </Group>
                </Stack>
            </form>
        </Paper>
    );
};

export default TierSettingsPage;


// ====== [99] frontend/src/modules/loyalpyme/services/adminCustomerService.ts ======
// frontend/src/services/adminCustomerService.ts
import axiosInstance from '../../../shared/services/axiosInstance';
import { CustomerDetails } from '../components/admin/CustomerDetailsModal';
// Customer ya no se importa directamente aqu√≠ si la respuesta de la API es diferente

// ... (otros tipos de Payload sin cambios) ...
interface UpdateNotesPayload { notes: string | null; }
interface AdjustPointsPayload { amount: number; reason: string | null; }
interface ChangeTierPayload { tierId: string | null; }
interface AssignRewardPayload { rewardId: string; }
interface BulkStatusPayload { customerIds: string[]; isActive: boolean; }
interface BulkDeletePayload { customerIds: string[]; }
interface BulkAdjustPointsPayload { customerIds: string[]; amount: number; reason: string | null; }

// --- CORRECCI√ìN EN CustomerActionResponse ---
// Definir la estructura del objeto 'customer' que devuelve la API para estas acciones
interface CustomerUpdatePartial {
    id: string;
    points?: number;          // Hacer opcional si no siempre viene
    currentTierId?: string | null; // Propiedad directa del backend
    tierAchievedAt?: string | null; // Propiedad directa del backend
    isFavorite?: boolean;     // Hacer opcional
    isActive?: boolean;       // Hacer opcional
    // A√±adir cualquier otro campo que la API devuelva en el objeto 'customer'
}

export interface CustomerActionResponse {
    message: string;
    customer: CustomerUpdatePartial; // Usar el nuevo tipo
}
// --- FIN CORRECCI√ìN ---

export interface GrantedRewardIdResponse {
    message: string;
    grantedRewardId: string;
}

export interface BulkOperationResponse {
    message: string;
    count: number;
}

// --- Funciones del Servicio (sin cambios en la l√≥gica, solo usan el tipo corregido) ---

export const getCustomerDetailsApi = async (customerId: string): Promise<CustomerDetails> => {
    const response = await axiosInstance.get<CustomerDetails>(`/admin/customers/${customerId}/details`);
    return response.data;
};

export const updateCustomerNotesApi = async (customerId: string, notes: string | null): Promise<{ message: string }> => {
    const payload: UpdateNotesPayload = { notes };
    const response = await axiosInstance.patch<{ message: string }>(`/admin/customers/${customerId}/notes`, payload);
    return response.data;
};

export const adjustCustomerPointsApi = async (customerId: string, amount: number, reason: string | null): Promise<CustomerActionResponse> => {
    const payload: AdjustPointsPayload = { amount, reason };
    const response = await axiosInstance.post<CustomerActionResponse>(`/admin/customers/${customerId}/adjust-points`, payload);
    return response.data;
};

export const changeCustomerTierApi = async (customerId: string, tierId: string | null): Promise<CustomerActionResponse> => {
    const payload: ChangeTierPayload = { tierId };
    const response = await axiosInstance.put<CustomerActionResponse>(`/admin/customers/${customerId}/tier`, payload);
    return response.data;
};

export const assignRewardToCustomerApi = async (customerId: string, rewardId: string): Promise<GrantedRewardIdResponse> => {
    const payload: AssignRewardPayload = { rewardId };
    const response = await axiosInstance.post<GrantedRewardIdResponse>(`/admin/customers/${customerId}/assign-reward`, payload);
    return response.data;
};

export const toggleCustomerFavoriteApi = async (customerId: string): Promise<CustomerActionResponse> => {
    const response = await axiosInstance.patch<CustomerActionResponse>(`/admin/customers/${customerId}/toggle-favorite`);
    return response.data;
};

export const toggleCustomerActiveApi = async (customerId: string): Promise<CustomerActionResponse> => {
    const response = await axiosInstance.patch<CustomerActionResponse>(`/admin/customers/${customerId}/toggle-active`);
    return response.data;
};

export const bulkUpdateCustomerStatusApi = async (customerIds: string[], isActive: boolean): Promise<BulkOperationResponse> => {
    const payload: BulkStatusPayload = { customerIds, isActive };
    const response = await axiosInstance.patch<BulkOperationResponse>('/admin/customers/bulk-status', payload);
    return response.data;
};

export const bulkDeleteCustomersApi = async (customerIds: string[]): Promise<BulkOperationResponse> => {
    const payload: BulkDeletePayload = { customerIds };
    const response = await axiosInstance.delete<BulkOperationResponse>('/admin/customers/bulk-delete', { data: payload });
    return response.data;
};

export const bulkAdjustCustomerPointsApi = async (customerIds: string[], amount: number, reason: string | null): Promise<BulkOperationResponse> => {
    const payload: BulkAdjustPointsPayload = { customerIds, amount, reason };
    const response = await axiosInstance.post<BulkOperationResponse>('/admin/customers/bulk-adjust-points', payload);
    return response.data;
};


// ====== [100] frontend/src/modules/loyalpyme/services/adminService.ts ======
// filename: frontend/src/services/adminService.ts
// Version: 1.1.1 (Fix character encoding)

import axiosInstance from '../../../shared/services/axiosInstance'; // Usar instancia configurada

/**
 * Interface actualizada que define la estructura de los datos de estad√≠sticas
 * devueltos por el endpoint del backend /api/admin/stats/overview,
 * incluyendo datos del periodo anterior para calcular tendencias.
 */
export interface AdminOverviewStats {
    totalActiveCustomers: number;       // Valor puntual
    newCustomersLast7Days: number;
    newCustomersPrevious7Days: number; // Para tendencia
    pointsIssuedLast7Days: number;
    pointsIssuedPrevious7Days: number; // Para tendencia
    rewardsRedeemedLast7Days: number;   // Nota: Solo cuenta regalos canjeados actualmente
    rewardsRedeemedPrevious7Days: number;// Para tendencia
}

/**
 * Obtiene las estad√≠sticas clave (incluyendo datos previos) para el dashboard
 * del administrador desde la API.
 * @returns Una promesa que resuelve con el objeto AdminOverviewStats actualizado.
 * @throws Lanza un error si la petici√≥n a la API falla.
 */
export const getAdminDashboardStats = async (): Promise<AdminOverviewStats> => {
  console.log('[AdminService] Fetching dashboard overview stats (including previous period)...');
  try {
    // La petici√≥n GET sigue siendo la misma, espera la nueva estructura
    const response = await axiosInstance.get<AdminOverviewStats>('/admin/stats/overview');

    // AxiosInstance ya est√° tipado con la interfaz AdminOverviewStats
    console.log('[AdminService] Stats received (with previous period):', response.data);
    return response.data;

  } catch (error: any) {
    console.error('[AdminService] Error fetching extended dashboard stats:', error);
    const errorMessage = error.response?.data?.message ||
                           error.message ||
                           'Error desconocido al obtener estad√≠sticas extendidas.'; // Corregido: estad√≠sticas, desconocido
    // Relanzamos para que el hook/componente que llama lo maneje
    throw new Error(errorMessage);
  }
};

// End of file: frontend/src/services/adminService.ts


// ====== [101] frontend/src/shared/components/PrivateRoute.tsx ======
// frontend/src/shared/components/PrivateRoute.tsx (CORREGIDO)
import React from 'react';
import { Navigate, Outlet, useLocation } from 'react-router-dom';

// --- RUTA Y NOMBRE CORREGIDOS ---
import { UserRole } from '../types/user.types';
// --- FIN CORRECCI√ìN ---


interface PrivateRouteProps {
  allowedRoles?: UserRole[];
  children?: React.ReactNode;
}

function PrivateRoute({ allowedRoles, children }: PrivateRouteProps) {
  const location = useLocation();

  const token = localStorage.getItem('token');
  if (!token) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  const userJson = localStorage.getItem('user');
  let user = null;
  try {
      if(userJson) user = JSON.parse(userJson);
  } catch (e) {
      console.error("[PrivateRoute] Failed to parse user from localStorage", e);
      localStorage.removeItem('token');
      localStorage.removeItem('user');
      return <Navigate to="/login" state={{ from: location }} replace />;
  }

  if (!user || (allowedRoles && allowedRoles.length > 0 && (!user.role || !allowedRoles.includes(user.role as UserRole)))) {
    const fallbackPath = user?.role === UserRole.BUSINESS_ADMIN ? '/admin/dashboard'
                       : user?.role === UserRole.CUSTOMER_FINAL ? '/customer/dashboard'
                       : user?.role === UserRole.SUPER_ADMIN ? '/superadmin'
                       // --- A√ëADIDO: Redirecci√≥n para roles de staff ---
                       : user?.role === UserRole.WAITER ? '/admin/camarero/pickup'
                       : user?.role === UserRole.KITCHEN_STAFF || user.role === UserRole.BAR_STAFF ? '/admin/kds'
                       // --- FIN A√ëADIDO ---
                       : '/login';
    return <Navigate to={fallbackPath} replace />;
  }

  return <>{children || <Outlet />}</>;
}

export default PrivateRoute;


// ====== [102] frontend/src/shared/components/layout/AdminNavbar.tsx ======
// frontend/src/components/layout/AdminNavbar.tsx
// Version: 1.2.1 (Add debug logs for WAITER role)

import React from 'react';
import { Link } from 'react-router-dom';
import { NavLink } from '@mantine/core';
import {
    IconGauge,
    IconGift,
    IconQrcode,
    IconUsers,
    IconStairsUp,
    IconSettings,
    IconToolsKitchen,
    IconClipboardText,
    IconFileInvoice
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import type { UserData } from '../../../shared/types/user.types';
import { UserRole } from '../../../shared/types/user.types';

interface AdminNavbarProps {
    pathname: string;
    closeNavbar: () => void;
    userData: UserData | null;
}

const AdminNavbar: React.FC<AdminNavbarProps> = ({ pathname, closeNavbar, userData }) => {
    const { t } = useTranslation();

    // ---- DEBUG LOG ----
    // Loguear siempre que userData cambie o el componente se renderice con userData
    if (userData) {
        console.log("[AdminNavbar DEBUG] UserData received in props:", JSON.stringify(userData, null, 2));
        console.log(`[AdminNavbar DEBUG] Current Role: ${userData.role}, IsCamareroActive: ${userData.isCamareroActive}`);

        if (userData.role === UserRole.WAITER) {
            console.log("[AdminNavbar DEBUG - WAITER CONTEXT] Role matches WAITER.");
            const conditionForPickup = userData?.isCamareroActive === true && (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN);
            console.log("[AdminNavbar DEBUG - WAITER CONTEXT] ShowCondition for '/admin/camarero/pickup':", conditionForPickup);

            const conditionForOrders = userData?.isCamareroActive === true && (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN);
            console.log("[AdminNavbar DEBUG - WAITER CONTEXT] ShowCondition for '/admin/camarero/orders':", conditionForOrders);
        }
    } else {
        console.log("[AdminNavbar DEBUG] UserData is null.");
    }
    // ---- FIN DEBUG LOG ----

    const allPossibleNavLinks = [
        {
            to: "/admin/dashboard",
            labelKey: 'adminCommon.dashboard',
            icon: IconGauge,
            showCondition: userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/rewards",
            labelKey: 'adminCommon.rewards',
            icon: IconGift,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/generate-qr",
            labelKey: 'adminCommon.generateQr',
            icon: IconQrcode,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/customers",
            labelKey: 'adminCommon.customers',
            icon: IconUsers,
            showCondition: (userData?.isLoyaltyCoreActive === true || userData?.isCamareroActive === true) && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/tiers/manage",
            labelKey: 'adminCommon.manageTiers',
            icon: IconStairsUp,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/tiers/settings",
            labelKey: 'adminCommon.tierSettings',
            icon: IconSettings,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/camarero/menu-editor",
            labelKey: 'adminCamarero.manageMenu.title',
            icon: IconToolsKitchen,
            showCondition: userData?.isCamareroActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/camarero/pickup",
            labelKey: 'waiterInterface.navLinkPickup',
            icon: IconClipboardText,
            showCondition: userData?.isCamareroActive === true &&
                           (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN)
        },
        {
            to: "/admin/camarero/orders",
            labelKey: 'waiterOrderManagement.navLinkTitle',
            icon: IconFileInvoice,
            showCondition: userData?.isCamareroActive === true &&
                           (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN)
        },
    ];

    const navLinksToShow = allPossibleNavLinks.filter(link => link.showCondition);
    
    // ---- DEBUG LOG ----
    if (userData?.role === UserRole.WAITER) {
      console.log("[AdminNavbar DEBUG - WAITER CONTEXT] Final navLinksToShow for WAITER:", navLinksToShow.map(l => ({ to: l.to, labelKey: l.labelKey })));
    }
    // ---- FIN DEBUG LOG ----


    return (
        <>
            {navLinksToShow.map((link) => (
                <NavLink
                    key={link.to}
                    label={t(link.labelKey)}
                    leftSection={<link.icon size="1rem" stroke={1.5} />}
                    component={Link}
                    to={link.to}
                    active={pathname.startsWith(link.to) && (pathname === link.to || pathname.startsWith(link.to + '/'))}
                    onClick={closeNavbar}
                />
            ))}
        </>
    );
};

export default AdminNavbar;


// ====== [103] frontend/src/shared/components/layout/AppHeader.tsx ======
// frontend/src/components/layout/AppHeader.tsx
// Version: 1.6.2 (Use full UserRole enum for LayoutUserData)

import React from 'react';
import {
    Group, Burger, Skeleton, Button, Menu, UnstyledButton, Box, Text,
    Container
} from '@mantine/core';
import {
    IconUserCircle,
    IconLogout,
    IconChevronDown,
} from '@tabler/icons-react';
import { useDisclosure } from '@mantine/hooks';
import { useTranslation } from 'react-i18next';
import ReactCountryFlag from 'react-country-flag';
import { Link } from 'react-router-dom';

// ---- MODIFICACI√ìN: Importar UserRole ----
import { UserRole } from '../../../shared/types/user.types'; // Aseg√∫rate que la ruta es correcta

// Interfaz LayoutUserData MODIFICADA
interface LayoutUserData {
    id: string;
    name?: string | null;
    email: string;
    role: UserRole; // <--- CAMBIADO A USAR EL ENUM UserRole COMPLETO
}
// ---- FIN MODIFICACI√ìN ----

interface AppHeaderProps {
    userData: LayoutUserData | null; // Ahora espera el enum UserRole
    loadingUser: boolean;
    handleLogout: () => void;
    navbarOpened?: boolean;
    toggleNavbar?: () => void;
    showAdminNavbar?: boolean;
}

// Componente Logo (sin cambios)
const Logo: React.FC<{ homePath: string }> = ({ homePath }) => (
    <Link
        to={homePath}
        style={{ textDecoration: 'none', color: 'inherit', display: 'flex', alignItems: 'center' }}
        aria-label={homePath === "/" || homePath === "/login" ? "Ir a la p√°gina de inicio de sesi√≥n" : "Ir a mi panel principal"}
    >
        <img
            src="/loyalpymelogo.jpg"
            alt="LoyalPyME Logo"
            style={{ height: '40px', width: 'auto', display: 'block' }}
        />
    </Link>
);

const AppHeader: React.FC<AppHeaderProps> = ({
    userData, loadingUser, handleLogout, navbarOpened, toggleNavbar, showAdminNavbar = false,
}) => {
    const { i18n, t } = useTranslation();
    const [mobileMenuOpened, { toggle: toggleMobileMenu, close: closeMobileMenu }] = useDisclosure(false);

    let logoLinkPath = "/";

    if (userData) {
        // La l√≥gica de redirecci√≥n aqu√≠ ya usa el enum UserRole, lo cual es bueno
        if (userData.role === UserRole.CUSTOMER_FINAL) {
            logoLinkPath = "/customer/dashboard";
        } else if (userData.role === UserRole.BUSINESS_ADMIN) {
            logoLinkPath = "/admin/dashboard";
        } else if (userData.role === UserRole.SUPER_ADMIN) {
            logoLinkPath = "/superadmin";
        // ---- A√ëADIR CASOS PARA NUEVOS ROLES DE STAFF SI QUIERES QUE EL LOGO LOS LLEVE A SU P√ÅGINA ----
        } else if (userData.role === UserRole.WAITER) {
            logoLinkPath = "/admin/camarero/pickup"; // O a /admin/camarero/orders
        } else if (userData.role === UserRole.KITCHEN_STAFF || userData.role === UserRole.BAR_STAFF) {
            logoLinkPath = "/admin/kds";
        }
        // ---- FIN A√ëADIR CASOS ----
    }

    const changeLanguage = (lang: string) => { i18n.changeLanguage(lang); closeMobileMenu(); };
    const currentCountryCode = i18n.resolvedLanguage === 'es' ? 'ES' : 'GB';
    const languages = [ { code: 'es', name: 'Espa√±ol', country: 'ES' }, { code: 'en', name: 'English', country: 'GB' }, ];

    const onLogoutClick = () => {
        handleLogout();
        closeMobileMenu();
    };

    const LogoutButtonInternal = () => ( <Button onClick={onLogoutClick} variant="light" color="red" size="sm" leftSection={<IconLogout size={16}/>}>{t('header.logoutButton')}</Button> );

    const LanguageSwitcherDesktop = () => (
         <Menu shadow="md" width={150} trigger="hover" openDelay={100} closeDelay={200}>
            <Menu.Target>
                 <UnstyledButton style={{ display: 'flex', alignItems: 'center', padding: '5px', borderRadius: 'var(--mantine-radius-sm)'}}>
                    <ReactCountryFlag countryCode={currentCountryCode} svg style={{ display: 'block', width: '1.4em', height: '1.4em' }} aria-label={currentCountryCode} />
                    <IconChevronDown size={16} stroke={1.5} style={{ marginLeft: '4px', color: 'var(--mantine-color-dimmed)' }} />
                 </UnstyledButton>
            </Menu.Target>
            <Menu.Dropdown>
                <Menu.Label>{t('header.languageLabel')}</Menu.Label>
                {languages.map((lang) => ( <Menu.Item key={lang.code} leftSection={<ReactCountryFlag countryCode={lang.country} svg style={{ fontSize: '1.1em', display:'block' }} />} onClick={() => changeLanguage(lang.code)} disabled={i18n.resolvedLanguage === lang.code}>{lang.name}</Menu.Item> ))}
            </Menu.Dropdown>
        </Menu>
    );

    return (
        <Box component="header" h="100%">
            <Container size="lg" h="100%" style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                <Group gap="xs">
                    {showAdminNavbar && toggleNavbar && ( <Burger opened={navbarOpened ?? false} onClick={toggleNavbar} hiddenFrom="sm" size="sm"/> )}
                    <Logo homePath={logoLinkPath} />
                </Group>

                {loadingUser ? ( <Skeleton height={30} width={120} /> )
                 : userData ? (
                    <Group gap="sm">
                        <Group visibleFrom="sm" gap="sm">
                            <Text size="sm" truncate>
                                <IconUserCircle size={18} style={{ verticalAlign: 'middle', marginRight: '4px' }} />
                                {t('header.greeting', { name: userData.name || userData.email })}
                            </Text>
                            <LanguageSwitcherDesktop />
                            <LogoutButtonInternal />
                        </Group>
                         <Box hiddenFrom="sm">
                             <Menu shadow="md" width={200} opened={mobileMenuOpened} onChange={toggleMobileMenu} position="bottom-end">
                                <Menu.Target>
                                     <Burger opened={mobileMenuOpened} onClick={toggleMobileMenu} aria-label={t('header.toggleNavigation', 'Toggle navigation')} size="sm"/>
                                </Menu.Target>
                                <Menu.Dropdown>
                                     <Menu.Label>{userData.name || userData.email}</Menu.Label>
                                    <Menu.Divider />
                                    <Menu.Label>{t('header.languageLabel')}</Menu.Label>
                                    {languages.map((lang) => (
                                        <Menu.Item key={lang.code} leftSection={<ReactCountryFlag countryCode={lang.country} svg style={{ fontSize: '1.1em', display:'block' }} />} onClick={() => changeLanguage(lang.code)} disabled={i18n.resolvedLanguage === lang.code}>
                                            {lang.name}
                                         </Menu.Item>
                                    ))}
                                    <Menu.Divider />
                                     <Menu.Item color="red" leftSection={<IconLogout size={14} />} onClick={onLogoutClick}>
                                         {t('header.logoutButton')}
                                     </Menu.Item>
                                </Menu.Dropdown>
                            </Menu>
                         </Box>
                    </Group>
                ) : (
                    <Group>
                        <LanguageSwitcherDesktop />
                    </Group>
                )}
            </Container>
        </Box>
    );
};

export default AppHeader;


// ====== [104] frontend/src/shared/components/layout/MainLayout.tsx ======
// frontend/src/components/layout/MainLayout.tsx
// Version 1.0.1 (Correct logic for showing AdminNavbar for WAITER and other staff roles)

import React from 'react';
import { Outlet, useLocation } from 'react-router-dom';
import { AppShell } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { useLayoutUserData } from '../../hooks/useLayoutUserData';
import AppHeader from './AppHeader';
import AdminNavbar from './AdminNavbar';
import { UserRole } from '../../types/user.types';

const MainLayout: React.FC = () => {
    const { userData, loadingUser, handleLogout } = useLayoutUserData();
    const location = useLocation();
    const [navbarOpened, { toggle: toggleNavbar, close: closeNavbar }] = useDisclosure();

    // ---- L√ìGICA MODIFICADA PARA MOSTRAR AdminNavbar ----
    // Determinar si la ruta actual es una ruta de "admin" en general
    const isAnyAdminRoute = location.pathname.startsWith('/admin/');

    // Definir qu√© roles deben ver la AdminNavbar en las rutas /admin/*
    const rolesThatSeeAdminNavbar: UserRole[] = [
        UserRole.BUSINESS_ADMIN,
        UserRole.WAITER,
        UserRole.KITCHEN_STAFF,
        UserRole.BAR_STAFF
        // SUPER_ADMIN tiene su propia ruta /superadmin y no usa esta navbar
    ];

    // AdminNavbar se muestra si el usuario tiene uno de los roles permitidos Y est√° en una ruta /admin/*
    const showAdminNavbar = userData?.role &&
                            rolesThatSeeAdminNavbar.includes(userData.role) &&
                            isAnyAdminRoute;
    // ---- FIN L√ìGICA MODIFICADA ----


    // Debug log para la condici√≥n de la navbar
    // console.log(`[MainLayout] Path: ${location.pathname}, Role: ${userData?.role}, isAnyAdminRoute: ${isAnyAdminRoute}, showAdminNavbar: ${showAdminNavbar}`);

    return (
        <AppShell
            header={{ height: 60 }}
            navbar={{
                width: 250,
                breakpoint: 'sm',
                // Mostrar/ocultar navbar si showAdminNavbar es true y navbarOpened es true (para m√≥vil)
                collapsed: { mobile: !navbarOpened || !showAdminNavbar, desktop: !showAdminNavbar }
            }}
            padding="md"
        >
            <AppShell.Header>
                <AppHeader
                    userData={userData}
                    loadingUser={loadingUser}
                    handleLogout={handleLogout}
                    navbarOpened={navbarOpened}
                    toggleNavbar={toggleNavbar}
                    // El burger del header debe aparecer si showAdminNavbar es true,
                    // independientemente de si la navbar est√° colapsada o no en desktop.
                    showAdminNavbar={showAdminNavbar}
                />
            </AppShell.Header>

            {/* Mostrar AdminNavbar solo si showAdminNavbar es true */}
            {showAdminNavbar && (
                <AppShell.Navbar p="md">
                    <AdminNavbar
                        pathname={location.pathname}
                        closeNavbar={closeNavbar}
                        userData={userData}
                    />
                </AppShell.Navbar>
            )}

            <AppShell.Main>
                <Outlet />
            </AppShell.Main>
        </AppShell>
    );
};

export default MainLayout;


// ====== [105] frontend/src/shared/components/layout/PublicLayout.tsx ======
// filename: frontend/src/components/layout/PublicLayout.tsx
// Nuevo layout simple para p√°ginas p√∫blicas, solo incluye el Header.

import React from 'react';
import { Outlet } from 'react-router-dom';
import { AppShell } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks'; // Necesario para AppHeader
import { useLayoutUserData } from '../../hooks/useLayoutUserData'; // Necesario para AppHeader
import AppHeader from './AppHeader'; // Importamos el header existente

const PublicLayout: React.FC = () => {
    // Necesitamos obtener los datos y el estado de la navbar para pasarlos al AppHeader
    const { userData, loadingUser, handleLogout } = useLayoutUserData();
    // Aunque no mostramos la navbar aqu√≠, AppHeader necesita el estado y el toggle para el Burger en m√≥vil
    const [navbarOpened, { toggle: toggleNavbar }] = useDisclosure();

    return (
        <AppShell
            header={{ height: 60 }}
            // NO definimos navbar aqu√≠
            padding="md" // Mantenemos padding general
        >
            {/* Cabecera (la misma que en MainLayout) */}
            <AppShell.Header>
                <AppHeader
                    userData={userData}
                    loadingUser={loadingUser}
                    handleLogout={handleLogout}
                    navbarOpened={navbarOpened}
                    toggleNavbar={toggleNavbar}
                    showAdminNavbar={false} // Nunca mostramos navbar admin en layout p√∫blico
                />
            </AppShell.Header>

            {/* Contenido principal de la p√°gina p√∫blica actual */}
            <AppShell.Main>
                <Outlet /> {/* Aqu√≠ se renderiza LoginPage, RegisterPage, etc. */}
            </AppShell.Main>
        </AppShell>
    );
};

export default PublicLayout;

// End of File: frontend/src/components/layout/PublicLayout.tsx


// ====== [106] frontend/src/shared/components/utils/ImageUploadCropper.tsx ======
// frontend/src/components/utils/ImageUploadCropper.tsx
// Version 1.1.0 (Set default crop to 100% width)

import React, { useState, useRef, SyntheticEvent, useEffect } from 'react';
import {
    FileInput, Button, Group, AspectRatio, Image as MantineImage,
    Center, Text, Alert, Box, Stack, LoadingOverlay
} from '@mantine/core';
import {
    IconUpload, IconPhoto, IconX, IconAlertCircle, IconCrop, IconCameraRotate
} from '@tabler/icons-react';
import ReactCrop, {
    centerCrop,
    makeAspectCrop,
    type Crop,
    type PixelCrop,
} from 'react-image-crop';
import 'react-image-crop/dist/ReactCrop.css';
import { canvasPreview, canvasToBlob } from '../utils/canvasPreview';
import { useTranslation } from 'react-i18next';
import axiosInstance from '../../services/axiosInstance';

export interface ImageUploadCropperProps {
    aspectRatio: number;
    minDimension: number;
    outputWidth?: number;
    outputHeight?: number;
    initialImageUrl: string | null;
    onUploadSuccess: (imageUrl: string) => void;
    onUploadError: (errorMessage: string) => void;
    onClearImage: () => void;
    folderName?: string;
    disabled?: boolean;
    selectImageButtonLabel?: string;
    confirmCropButtonLabel?: string;
    removeImageButtonLabel?: string;
    cropInstructionsLabel?: string;
    imagePreviewAltText?: string;
    imageToCropAltText?: string;
}

const DEFAULT_CLOUDINARY_FOLDER = 'loyalpyme/uploads';

const ImageUploadCropper: React.FC<ImageUploadCropperProps> = ({
    aspectRatio,
    minDimension,
    outputWidth,
    outputHeight,
    initialImageUrl,
    onUploadSuccess,
    onUploadError,
    onClearImage,
    folderName = DEFAULT_CLOUDINARY_FOLDER,
    disabled = false,
    selectImageButtonLabel,
    confirmCropButtonLabel,
    removeImageButtonLabel,
    cropInstructionsLabel,
    imagePreviewAltText,
    imageToCropAltText,
}) => {
    const { t } = useTranslation();
    const imgRef = useRef<HTMLImageElement>(null);
    const previewCanvasRef = useRef<HTMLCanvasElement>(null);

    const [currentDisplayUrl, setCurrentDisplayUrl] = useState<string | null>(initialImageUrl);
    const [imgSrcForCropper, setImgSrcForCropper] = useState<string>('');
    const [crop, setCrop] = useState<Crop>();
    const [completedCrop, setCompletedCrop] = useState<PixelCrop>();
    const [isUploading, setIsUploading] = useState<boolean>(false);
    const [internalUploadError, setInternalUploadError] = useState<string | null>(null);
    const [selectedFile, setSelectedFile] = useState<File | null>(null);

    useEffect(() => {
        setCurrentDisplayUrl(initialImageUrl);
        if (initialImageUrl && imgSrcForCropper) {
            setImgSrcForCropper('');
            setSelectedFile(null);
            setCrop(undefined);
            setCompletedCrop(undefined);
        }
    }, [initialImageUrl, imgSrcForCropper]);


    const handleFileSelect = (file: File | null) => {
        setInternalUploadError(null);
        setSelectedFile(file);
        if (file) {
            setCrop(undefined);
            setCompletedCrop(undefined);
            setCurrentDisplayUrl(null);
            const reader = new FileReader();
            reader.addEventListener('load', () => {
                setImgSrcForCropper(reader.result?.toString() || '');
            });
            reader.readAsDataURL(file);
        } else {
            setImgSrcForCropper('');
            if (initialImageUrl) {
                setCurrentDisplayUrl(initialImageUrl);
            }
        }
    };

    const onImageLoad = (e: SyntheticEvent<HTMLImageElement>) => {
        const { naturalWidth, naturalHeight } = e.currentTarget;
        setInternalUploadError(null);

        if (naturalWidth < minDimension || naturalHeight < minDimension) {
            const errorMsg = t('common.errorImageTooSmall', { minSize: minDimension });
            setInternalUploadError(errorMsg);
            onUploadError(errorMsg);
            setImgSrcForCropper('');
            setSelectedFile(null);
            return;
        }

        // --- CAMBIO CLAVE: Cambiar width de 90 a 100 para seleccionar todo por defecto ---
        const newCrop = centerCrop(
            makeAspectCrop(
                {
                    unit: '%',
                    width: 100, // <--- ANTES 90, AHORA 100
                },
                aspectRatio,
                naturalWidth,
                naturalHeight
            ),
            naturalWidth,
            naturalHeight
        );
        // --- FIN CAMBIO CLAVE ---
        
        setCrop(newCrop);
        
        if (naturalWidth && naturalHeight) {
             setCompletedCrop({
                 unit: 'px',
                 x: (newCrop.x / 100) * naturalWidth,
                 y: (newCrop.y / 100) * naturalHeight,
                 width: (newCrop.width / 100) * naturalWidth,
                 height: (newCrop.height / 100) * naturalHeight,
             });
        }
    };

    const handleConfirmCropAndUpload = async () => {
        if (!imgRef.current || !previewCanvasRef.current || !completedCrop || completedCrop.width === 0 || completedCrop.height === 0) {
            const errorMsg = t('adminCamarero.menuCategoryForm.errorInvalidCropOrImage');
            setInternalUploadError(errorMsg);
            onUploadError(errorMsg);
            return;
        }
        setIsUploading(true);
        setInternalUploadError(null);
        try {
            const targetWidth = outputWidth || completedCrop.width;
            const targetHeight = outputHeight || completedCrop.height;

            await canvasPreview(
                imgRef.current,
                previewCanvasRef.current,
                completedCrop,
                1, 0,
                targetWidth,
                targetHeight
            );
            const blob = await canvasToBlob(previewCanvasRef.current);

            if (!blob) { throw new Error(t('adminCamarero.menuCategoryForm.errorCreatingCroppedFile')); }
            const formData = new FormData();
            formData.append('image', blob, selectedFile?.name || `cropped-image-${Date.now()}.png`);
            
            // Usamos la carpeta especificada en las props
            const response = await axiosInstance.post<{ url: string }>('/uploads/image', formData, {
                headers: { 'Content-Type': 'multipart/form-data', 'X-Upload-Folder': folderName }
            });

            if (response.data && response.data.url) {
                onUploadSuccess(response.data.url);
                setCurrentDisplayUrl(response.data.url);
                setImgSrcForCropper(''); setSelectedFile(null); setCrop(undefined); setCompletedCrop(undefined);
            } else { throw new Error(t('adminCamarero.menuCategoryForm.errorApiNoUrl')); }
        } catch (err: any) {
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
            const errorMsg = t('adminCamarero.menuCategoryForm.errorUploadingWithDetail', { error: apiError });
            setInternalUploadError(errorMsg);
            onUploadError(errorMsg);
        } finally { setIsUploading(false); }
    };

    const handleRemoveImage = () => {
        setCurrentDisplayUrl(null);
        setImgSrcForCropper('');
        setSelectedFile(null);
        setCrop(undefined);
        setCompletedCrop(undefined);
        setInternalUploadError(null);
        onClearImage();
    };

    const showCropper = !!imgSrcForCropper;
    const effectiveImagePreviewAlt = imagePreviewAltText || t('component.rewardForm.altImagePreview', { name: 'Imagen' });
    const effectiveImageToCropAlt = imageToCropAltText || t('component.rewardForm.altCropImage');

    return (
        <Stack gap="sm">
            <LoadingOverlay visible={isUploading} overlayProps={{ radius: "sm", blur: 2 }} />
            <Text fw={500} size="sm">{t('component.rewardForm.imageLabel')}</Text>
            {!showCropper && (
                <AspectRatio ratio={aspectRatio} maw={300} mx="auto">
                    <Center bg="gray.1" style={{ borderRadius: 'var(--mantine-radius-md)', border: `1px dashed var(--mantine-color-gray-4)` }}>
                        {currentDisplayUrl ? (
                            <MantineImage src={currentDisplayUrl} alt={effectiveImagePreviewAlt} radius="sm" fit="contain" style={{ maxHeight: '100%', maxWidth: '100%' }} fallbackSrc="/placeholder-image.png" />
                        ) : ( <IconPhoto size={48} color="var(--mantine-color-gray-5)" stroke={1.5} /> )}
                    </Center>
                </AspectRatio>
            )}
            {showCropper && (
                <Box mt="xs" style={{ maxWidth: 500, margin: 'auto' }}>
                    <ReactCrop crop={crop} onChange={(_, percentCrop) => setCrop(percentCrop)} onComplete={(c) => setCompletedCrop(c)} aspect={aspectRatio} minWidth={50} minHeight={50 / aspectRatio} >
                        <img ref={imgRef} src={imgSrcForCropper} style={{ display: 'block', maxHeight: '400px', objectFit: 'contain' }} onLoad={onImageLoad} alt={effectiveImageToCropAlt} />
                    </ReactCrop>
                    {completedCrop && completedCrop.width > 0 && ( <canvas ref={previewCanvasRef} style={{ display: 'none', border: '1px solid black', objectFit: 'contain', width: completedCrop.width, height: completedCrop.height, }} /> )}
                </Box>
            )}
            <Group justify="center" mt="xs" wrap="nowrap">
                <FileInput placeholder={selectImageButtonLabel || t('component.rewardForm.selectImageButton')} accept="image/png,image/jpeg,image/webp,image/gif" onChange={handleFileSelect} leftSection={<IconUpload size={16} />} clearable disabled={disabled || isUploading} style={{ flexGrow: 1, maxWidth: showCropper ? 'calc(50% - 4px)' : '100%' }} value={selectedFile} />
                {showCropper && ( <Button onClick={handleConfirmCropAndUpload} loading={isUploading} disabled={!completedCrop || isUploading || disabled} leftSection={<IconCrop size={16} />} style={{ flexGrow: 1, maxWidth: 'calc(50% - 4px)' }} > {confirmCropButtonLabel || t('component.rewardForm.confirmCropButton')} </Button> )}
            </Group>
            {imgSrcForCropper && ( <Button variant="outline" color="gray" size="xs" mt="xs" onClick={() => { setImgSrcForCropper(''); setSelectedFile(null); setCrop(undefined); setCompletedCrop(undefined); if(initialImageUrl) setCurrentDisplayUrl(initialImageUrl); }} leftSection={<IconCameraRotate size={14}/>} disabled={isUploading || disabled} fullWidth > {t('common.cancel')} {t('common.edit')} / {t('common.selectPlaceholder')} </Button> )}
            {currentDisplayUrl && !showCropper && ( <Button variant="subtle" color="red" size="xs" mt="xs" onClick={handleRemoveImage} leftSection={<IconX size={14} />} disabled={disabled || isUploading} > {removeImageButtonLabel || t('component.rewardForm.removeImageButton')} </Button> )}
            {internalUploadError && ( <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />} mt="sm" withCloseButton onClose={() => setInternalUploadError(null)} > <Text size="sm">{internalUploadError}</Text> </Alert> )}
            {cropInstructionsLabel && showCropper && <Text size="xs" c="dimmed" ta="center" mt="xs">{cropInstructionsLabel}</Text>}
        </Stack>
    );
};
export default ImageUploadCropper;


// ====== [107] frontend/src/shared/components/utils/canvasPreview.ts ======
// frontend/src/utils/canvasPreview.ts
// Version 1.0.2 (Removed unused centerX, centerY for current logic)
import { PixelCrop } from 'react-image-crop';

const TO_RADIANS = Math.PI / 180;

export async function canvasPreview(
  image: HTMLImageElement,
  canvas: HTMLCanvasElement,
  crop: PixelCrop,
  scale = 1,
  rotate = 0,
  outputWidth?: number,
  outputHeight?: number
) {
  const ctx = canvas.getContext('2d');

  if (!ctx) {
    throw new Error('No 2d context');
  }

  const scaleX = image.naturalWidth / image.width;  // Relaci√≥n entre tama√±o natural y tama√±o mostrado
  const scaleY = image.naturalHeight / image.height; // Usado para convertir crop de % a px si fuera el caso

  canvas.width = Math.floor(outputWidth || crop.width);   // Usar outputWidth o el ancho del crop en p√≠xeles
  canvas.height = Math.floor(outputHeight || crop.height); // Usar outputHeight o el alto del crop en p√≠xeles

  ctx.imageSmoothingQuality = 'high';

  const cropXInOriginal = crop.x * scaleX; // Coordenada X del crop en la imagen original
  const cropYInOriginal = crop.y * scaleY; // Coordenada Y del crop en la imagen original
  const cropWidthInOriginal = crop.width * scaleX; // Ancho del crop en la imagen original
  const cropHeightInOriginal = crop.height * scaleY; // Alto del crop en la imagen original

  const rotateRads = rotate * TO_RADIANS;

  ctx.save();
  // Mover el origen del canvas al centro del canvas para la rotaci√≥n/escalado
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.rotate(rotateRads);
  ctx.scale(scale, scale);
  // Mover el origen de nuevo para que (0,0) del drawImage sea la esquina superior izquierda del √°rea de destino
  ctx.translate(-canvas.width / 2, -canvas.height / 2);

  // Dibujar la porci√≥n recortada de la imagen original,
  // y que se ajuste a las dimensiones completas del canvas (que son outputWidth/Height o el tama√±o del crop).
  ctx.drawImage(
    image,
    cropXInOriginal,
    cropYInOriginal,
    cropWidthInOriginal,
    cropHeightInOriginal,
    0, // Dibujar en la esquina (0,0) del canvas (ya transformado)
    0,
    canvas.width,  // Estirar/encoger a todo el ancho del canvas
    canvas.height  // Estirar/encoger a todo el alto del canvas
  );

  ctx.restore();
}

// canvasToBlob (sin cambios)
export function canvasToBlob(
  canvas: HTMLCanvasElement,
  type = 'image/png',
  quality = 0.9
): Promise<Blob | null> {
    return new Promise((resolve) => {
        canvas.toBlob(
            (blob) => { resolve(blob); },
            type,
            quality
        );
    });
}


// ====== [108] frontend/src/shared/hooks/useLayoutUserData.ts ======
// frontend/src/hooks/useLayoutUserData.ts
import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import axiosInstance from '../services/axiosInstance';
import type { UserData } from '../../types/customer';

interface UseLayoutUserDataReturn {
    userData: UserData | null;
    loadingUser: boolean;
    handleLogout: () => void;
}

export const useLayoutUserData = (): UseLayoutUserDataReturn => {
    const navigate = useNavigate();
    const [userData, setUserData] = useState<UserData | null>(null);
    const [loadingUser, setLoadingUser] = useState(true);

    const handleLogout = useCallback(() => {
        console.log("[useLayoutUserData] Executing logout...");
        localStorage.removeItem('token');
        localStorage.removeItem('user'); // Tambi√©n limpiar el usuario al hacer logout
        setUserData(null);
        if (window.location.pathname !== '/login') {
            navigate('/login', { replace: true });
        }
    }, [navigate]);

    useEffect(() => {
        const fetchAndSetUserData = async () => {
            console.log("[useLayoutUserData] Starting user data check/fetch...");
            setLoadingUser(true);
            const token = localStorage.getItem('token');

            if (!token) {
                console.log("[useLayoutUserData] No token found. Ensuring user is null.");
                if (userData !== null) setUserData(null); // Asegurar que userData es null si no hay token
                setLoadingUser(false);
                return;
            }

            // SIEMPRE intentamos obtener de /api/profile si hay token para datos frescos
            console.log("[useLayoutUserData] Token found. Fetching user profile from API...");
            try {
                const response = await axiosInstance.get<UserData>('/profile');
                if (response.data && response.data.id && response.data.email && response.data.role) {
                    setUserData(response.data);
                    localStorage.setItem('user', JSON.stringify(response.data)); // Actualizar localStorage con datos frescos
                    console.log("[useLayoutUserData] User data fetched from API and saved to localStorage:", response.data);
                } else {
                    console.error("[useLayoutUserData] Invalid or incomplete data received from API /profile endpoint. Logging out.");
                    handleLogout(); // Logout si API devuelve datos inv√°lidos/incompletos
                }
            } catch (apiError: any) {
                console.error("[useLayoutUserData] Error fetching user profile from API:", apiError);
                // Si falla /profile (ej. token expirado o inv√°lido), hacemos logout.
                // Esto tambi√©n limpia el localStorage.
                // Podr√≠amos intentar cargar desde localStorage como fallback aqu√≠,
                // pero es m√°s seguro hacer logout si /profile falla con un token existente.
                if (apiError.response?.status === 401 || apiError.response?.status === 403) {
                    console.log("[useLayoutUserData] API /profile returned 401/403, logging out.");
                    handleLogout();
                } else {
                    // Otro error de red, etc. No necesariamente invalida el token.
                    // Podr√≠amos intentar cargar desde localStorage como √∫ltimo recurso.
                    console.warn("[useLayoutUserData] API /profile fetch failed with other error. Attempting to load from localStorage if available.");
                    const storedUserJson = localStorage.getItem('user');
                    if (storedUserJson) {
                        try {
                            const parsed = JSON.parse(storedUserJson) as UserData;
                            if (parsed && parsed.id && parsed.email && parsed.role) {
                                setUserData(parsed);
                                console.log("[useLayoutUserData] Loaded stale data from localStorage due to API error.");
                            } else {
                                handleLogout(); // Stored data is invalid
                            }
                        } catch (e) {
                            handleLogout(); // Error parsing stored data
                        }
                    } else {
                        // No hay nada en localStorage y la API fall√≥, nos rendimos y hacemos logout.
                        handleLogout();
                    }
                }
            } finally {
                setLoadingUser(false);
                console.log("[useLayoutUserData] User data fetch/check process finished.");
            }
        };

        fetchAndSetUserData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [navigate]); // handleLogout no necesita estar aqu√≠ si su referencia no cambia, pero navigate s√≠

    // useEffect para reaccionar a cambios en localStorage (ej: logout en otra pesta√±a)
    useEffect(() => {
        const handleStorageChange = (event: StorageEvent) => {
            if (event.key === 'token' || event.key === 'user') {
                console.log('[useLayoutUserData] localStorage changed in another tab. Re-evaluating auth state.');
                // Forzar una re-evaluaci√≥n. Si 'token' es null, el efecto principal har√° logout.
                // Si 'token' existe pero 'user' cambi√≥ (o se borr√≥), el efecto principal deber√≠a recargar de /profile.
                // Una forma simple de forzarlo es recargar los datos.
                // O, si el token ya no existe, hacer logout.
                const token = localStorage.getItem('token');
                if (!token && userData !== null) { // Si el token se borr√≥ y ten√≠amos datos, hacemos logout
                    handleLogout();
                } else if (token && (!userData || (event.key === 'user' && localStorage.getItem('user') !== JSON.stringify(userData)))) {
                    // Si hay token pero no userData, o si 'user' cambi√≥, podemos forzar una recarga
                    // Esto es m√°s complejo, por ahora, el efecto principal al montar/cambiar navigate deber√≠a ser suficiente
                    // para la mayor√≠a de los casos de carga inicial.
                    // Para una sincronizaci√≥n perfecta entre pesta√±as, se necesitar√≠a una l√≥gica m√°s robusta
                    // o una librer√≠a de gesti√≥n de estado global.
                }
            }
        };

        window.addEventListener('storage', handleStorageChange);
        return () => {
            window.removeEventListener('storage', handleStorageChange);
        };
    }, [userData, handleLogout]);


    return { userData, loadingUser, handleLogout };
};


// ====== [109] frontend/src/shared/services/axiosInstance.ts ======
// filename: frontend/src/services/axiosInstance.ts
// Version: 1.1.1 (Remove meta-comments)

import axios from 'axios';

// Usar ruta relativa para baseURL
// El proxy de Vite redirigir√° /api a http://localhost:3000/api
const API_BASE_URL = '/api'; // Ruta relativa para que funcione el proxy

// Crea una instancia de Axios con la configuraci√≥n base
const axiosInstance = axios.create({
  baseURL: API_BASE_URL,
});

// A√±ade un interceptor de peticiones (request interceptor)
axiosInstance.interceptors.request.use(
  (config) => {
    // Obtener el token de localStorage
    const token = localStorage.getItem('token');
    if (token) {
      // A√±adir la cabecera Authorization si existe el token
      config.headers.set('Authorization', `Bearer ${token}`);
    }
    return config; // Devolver la configuraci√≥n modificada (o la original si no hay token)
  },
  (error) => {
    // Manejar errores que ocurran durante la configuraci√≥n de la petici√≥n
    console.error('Error in request interceptor:', error);
    return Promise.reject(error); // Rechazar la promesa con el error
  }
);

// Opcional: A√±adir interceptor de respuestas aqu√≠ si fuera necesario
/*
axiosInstance.interceptors.response.use(
  (response) => {
    // Cualquier c√≥digo de estado que este dentro del rango de 2xx causa la ejecuci√≥n de esta funci√≥n
    // Haz algo con los datos de la respuesta
    return response;
  },
  (error) => {
    // Cualquier c√≥digo de estado que caiga fuera del rango de 2xx causa la ejecuci√≥n de esta funci√≥n
    // Por ejemplo, manejar errores 401/403 globales aqu√≠
    if (error.response?.status === 401) {
      // Podr√≠amos hacer logout autom√°tico aqu√≠
      console.error("Unauthorized (401) response detected by interceptor.");
      // localStorage.removeItem('token');
      // localStorage.removeItem('user');
      // window.location.href = '/login'; // Redirecci√≥n forzada
    }
    return Promise.reject(error); // Rechazar la promesa con el error
  }
);
*/

// Exporta la instancia configurada para usarla en otros servicios
export default axiosInstance;

// End of File: frontend/src/services/axiosInstance.ts


// ====== [110] frontend/src/shared/services/businessService.ts ======
// filename: frontend/src/services/businessService.ts
// Version: 1.1.1 (Remove meta-comments, fix encoding)

import axios from 'axios'; // Usamos axios base, NO axiosInstance, porque es una ruta p√∫blica

/**
 * Interface para la estructura de datos de cada negocio en la lista p√∫blica.
 * Contiene lo necesario para un desplegable (valor y etiqueta).
 */
export interface BusinessOption {
  id: string;
  name: string;
}

// Usar ruta relativa para que funcione con el proxy de Vite
// El proxy definido en vite.config.ts para '/public' redirigir√° esto
const PUBLIC_BUSINESS_LIST_URL = '/public/businesses/public-list';


/**
 * Obtiene la lista p√∫blica de negocios (ID y Nombre) desde la API.
 * @returns Una promesa que resuelve con un array de objetos BusinessOption.
 * @throws Lanza un error si la petici√≥n a la API falla.
 */
export const getPublicBusinessList = async (): Promise<BusinessOption[]> => {
  console.log('[BusinessService] Fetching public business list...');
  try {
    // La llamada ahora usa la URL relativa
    const response = await axios.get<BusinessOption[]>(PUBLIC_BUSINESS_LIST_URL);

    console.log(`[BusinessService] Received ${response.data?.length ?? 0} businesses.`);
    return response.data || []; // Devolver array vac√≠o si la data es null/undefined

  } catch (error: any) {
    console.error('[BusinessService] Error fetching public business list:', error);
    const errorMessage = error.response?.data?.message ||
                           error.message ||
                           'Error desconocido al obtener la lista de negocios.'; // Corregido: desconocido
    // Relanzar el error para que el componente que llama lo maneje (ej: en RegisterPage)
    throw new Error(errorMessage);
  }
};

// End of file: frontend/src/services/businessService.ts


// ====== [111] frontend/src/shared/types/superadmin.types.ts ======
// frontend/src/types/superadmin.types.ts

// El tipo de dato que la API /superadmin/businesses devuelve para cada negocio
export interface SuperAdminBusiness {
    id: string;
    name: string;
    slug: string;
    isActive: boolean;
    isLoyaltyCoreActive: boolean;
    isCamareroActive: boolean;
    createdAt: string;
    monthlyPrice: string | number | null; // La API puede enviar Decimal como string
    currency: string;
    paymentStatus: 'PAID' | 'PENDING' | 'OVERDUE';
    lastPayment?: { month: number; year: number };
    pendingMonths: number;
}

// El tipo de dato para un registro de pago individual
export interface BusinessPayment {
    id: string;
    paymentDate: string;
    amountPaid: number;
    month: number;
    year: number;
    paymentMethod: string | null;
    notes: string | null;
}


// ====== [112] frontend/src/shared/types/user.types.ts ======
// frontend/src/types/customer.ts
// Version: 1.1.3 (Ensure OrderType is exported)

import React from 'react';

export enum UserRole {
    SUPER_ADMIN = 'SUPER_ADMIN',
    BUSINESS_ADMIN = 'BUSINESS_ADMIN',
    CUSTOMER_FINAL = 'CUSTOMER_FINAL',
    WAITER = 'WAITER',
    KITCHEN_STAFF = 'KITCHEN_STAFF',
    BAR_STAFF = 'BAR_STAFF'
}

export enum OrderItemStatus {
    PENDING_KDS = 'PENDING_KDS', PREPARING = 'PREPARING', READY = 'READY',
    SERVED = 'SERVED', CANCELLED = 'CANCELLED', CANCELLATION_REQUESTED = 'CANCELLATION_REQUESTED',
}

export enum OrderStatus {
    RECEIVED = 'RECEIVED', IN_PROGRESS = 'IN_PROGRESS', PARTIALLY_READY = 'PARTIALLY_READY',
    ALL_ITEMS_READY = 'ALL_ITEMS_READY', COMPLETED = 'COMPLETED', PENDING_PAYMENT = 'PENDING_PAYMENT',
    PAID = 'PAID', CANCELLED = 'CANCELLED', PAYMENT_FAILED = 'PAYMENT_FAILED',
}

// ---- A√ëADIR Y EXPORTAR OrderType SI NO EXISTE ----
export enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKE_AWAY = 'TAKE_AWAY',
  DELIVERY = 'DELIVERY',
}
// ---- FIN A√ëADIR/EXPORTAR OrderType ----


export enum TierCalculationBasis {
    SPEND = 'SPEND',
    VISITS = 'VISITS',
    POINTS_EARNED = 'POINTS_EARNED'
}

export interface CustomerBusinessConfig {
    tierCalculationBasis: TierCalculationBasis | null;
}

export interface TierBenefitData {
  id: string;
  type: string;
  value: string;
  description: string | null;
  isActive?: boolean;
}

export interface TierData {
    id: string;
    name: string;
    level: number;
    minValue: number;
    isActive: boolean;
    benefits?: TierBenefitData[];
}

export interface UserData {
    id: string;
    email: string;
    name?: string | null;
    role: UserRole;
    businessId: string | null;
    isActive: boolean;
    points?: number;
    totalSpend?: number;
    totalVisits?: number;
    currentTier?: {
        id: string;
        name: string;
        benefits: TierBenefitData[];
    } | null;
    businessIsActive?: boolean;
    isLoyaltyCoreActive?: boolean;
    isCamareroActive?: boolean;
    businessName?: string | null;
    businessSlug?: string | null;
    businessLogoUrl?: string | null;
}
export interface Reward {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es?: string | null;
    description_en?: string | null;
    pointsCost: number;
    isActive: boolean;
    businessId?: string;
    imageUrl?: string | null;
    createdAt?: string;
    updatedAt?: string;
}
export interface GrantedReward {
    id: string;
    status: string;
    assignedAt: string;
    reward: Pick<Reward, 'id' | 'name_es' | 'name_en' | 'description_es' | 'description_en' | 'imageUrl'>;
    assignedBy?: { name?: string | null; email: string; } | null;
    business?: { name: string; } | null;
}
export type DisplayReward =
    {
        isGift: false;
        id: string;
        name_es: string | null;
        name_en: string | null;
        description_es?: string | null;
        description_en?: string | null;
        pointsCost: number;
        imageUrl?: string | null;
        grantedRewardId?: undefined;
        assignedByString?: undefined;
        assignedAt?: undefined;
    } |
    {
        isGift: true;
        grantedRewardId: string;
        id: string;
        name_es: string | null;
        name_en: string | null;
        description_es?: string | null;
        description_en?: string | null;
        pointsCost: 0;
        imageUrl?: string | null;
        assignedByString: string;
        assignedAt: string;
    };

export interface UseProfileResult {
    userData: UserData | null;
    loading: boolean;
    error: string | null;
    refetch: () => Promise<void>;
    setUserData: React.Dispatch<React.SetStateAction<UserData | null>>;
}

export interface UseCustomerTierDataResult {
    allTiers: TierData[] | null;
    businessConfig: CustomerBusinessConfig | null;
    loading: boolean;
    error: string | null;
    refetch: () => Promise<void>;
}

export type ActivityType =
    | 'POINTS_EARNED_QR'
    | 'POINTS_REDEEMED_REWARD'
    | 'GIFT_REDEEMED'
    | 'POINTS_ADJUSTED_ADMIN'
    | 'POINTS_EARNED_ORDER_LC'; // Aseg√∫rate que este tambi√©n est√© si lo usas en el frontend

export interface ActivityLogItem {
  id: string;
  type: ActivityType;
  pointsChanged: number | null;
  description: string | null;
  createdAt: string;
}

export interface PaginatedActivityResponse {
  logs: ActivityLogItem[];
  totalPages: number;
  currentPage: number;
  totalItems: number;
}


// ====== [113] frontend/tsconfig.json ======
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



// ====== [114] frontend/vite.config.ts ======
// filename: frontend/vite.config.ts
// Version: 1.1.3 (Use mergeConfig to combine Vite and Vitest configs)

// Importar defineConfig y mergeConfig de Vite
import { defineConfig, mergeConfig } from 'vite';
// Importar defineConfig de Vitest con un alias
import { defineConfig as defineVitestConfig } from 'vitest/config';

import react from '@vitejs/plugin-react';
import mkcert from 'vite-plugin-mkcert';

// Configuraci√≥n espec√≠fica de Vite
const viteConfig = defineConfig({
  plugins: [react(), mkcert()],
  server: {
    host: true,
    port: 5173,
    https: true,
    proxy: {
      '/api': { target: 'http://localhost:3000', changeOrigin: true },
      '/public': { target: 'http://localhost:3000', changeOrigin: true }
    }
  },
  // Aqu√≠ ir√≠an otras opciones espec√≠ficas de Vite si las tuvieras
});

// Configuraci√≥n espec√≠fica de Vitest
const vitestConfig = defineVitestConfig({
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts', // Seguimos necesitando este archivo
    css: true,
  },
  // Aqu√≠ ir√≠an otras opciones espec√≠ficas de Vitest si las tuvieras
});

// Exportar la configuraci√≥n combinada
export default mergeConfig(viteConfig, vitestConfig);

// End of File: frontend/vite.config.ts

