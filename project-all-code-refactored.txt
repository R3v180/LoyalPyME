# √çNDICE DE ARCHIVOS (ESTRUCTURA REFACTORIZADA)

1. DEVELOPMENT_PLAN.md
2. LICENSE.md
3. LOYALPYME_CAMARERO_WORKFLOW.md
4. LOYALPYME_CORE_WORKFLOW.md
5. LOYALPYME_MODULE_INTEGRATION_WORKFLOW.md
6. PROJECT_STATUS.md
7. README.md
8. SETUP_GUIDE.md
9. TROUBLESHOOTING_GUIDE.md
10. backend/nodemon.json
11. backend/package-lock.json
12. backend/package.json
13. backend/prisma/seed.js
14. backend/prisma/seed.ts
15. backend/prisma/seed/_1_business.js
16. backend/prisma/seed/_1_business.ts
17. backend/prisma/seed/_2_tiers.js
18. backend/prisma/seed/_2_tiers.ts
19. backend/prisma/seed/_3_menu.js
20. backend/prisma/seed/_3_menu.ts
21. backend/prisma/seed/_4_users.js
22. backend/prisma/seed/_4_users.ts
23. backend/prisma/seed/_5_activity.js
24. backend/prisma/seed/_5_activity.ts
25. backend/scripts/create-superadmin.js
26. backend/scripts/create-superadmin.ts
27. backend/scripts/hash-customer-password.js
28. backend/scripts/hash-customer-password.ts
29. backend/src/config/swagger.config.ts
30. backend/src/index.ts
31. backend/src/modules/camarero/admin-menu-category.controller.ts
32. backend/src/modules/camarero/admin-menu-category.service.ts
33. backend/src/modules/camarero/admin-menu-item.controller.ts
34. backend/src/modules/camarero/admin-menu-item.service.ts
35. backend/src/modules/camarero/admin-modifier.controller.ts
36. backend/src/modules/camarero/admin-modifier.service.ts
37. backend/src/modules/camarero/camarero.dto.ts
38. backend/src/modules/camarero/kds.controller.ts
39. backend/src/modules/camarero/kds.service.ts
40. backend/src/modules/camarero/public/OrderValidationService.ts
41. backend/src/modules/camarero/public/menu.controller.ts
42. backend/src/modules/camarero/public/menu.service.ts
43. backend/src/modules/camarero/public/order-creation.service.ts
44. backend/src/modules/camarero/public/order-item-processor.service.ts
45. backend/src/modules/camarero/public/order-modification.service.ts
46. backend/src/modules/camarero/public/order-payment.service.ts
47. backend/src/modules/camarero/public/order.controller.ts
48. backend/src/modules/camarero/public/order.dto.ts
49. backend/src/modules/camarero/public/order.service.ts
50. backend/src/modules/camarero/public/order.types.ts
51. backend/src/modules/camarero/waiter.controller.ts
52. backend/src/modules/camarero/waiter.service.ts
53. backend/src/modules/loyalpyme/activity/activity.controller.ts
54. backend/src/modules/loyalpyme/activity/activity.service.ts
55. backend/src/modules/loyalpyme/admin/admin-customer-bulk.controller.ts
56. backend/src/modules/loyalpyme/admin/admin-customer-bulk.service.ts
57. backend/src/modules/loyalpyme/admin/admin-customer-individual.controller.ts
58. backend/src/modules/loyalpyme/admin/admin-customer-individual.service.ts
59. backend/src/modules/loyalpyme/admin/admin-customer-list.controller.ts
60. backend/src/modules/loyalpyme/admin/admin-customer-list.service.ts
61. backend/src/modules/loyalpyme/admin/admin-stats.controller.ts
62. backend/src/modules/loyalpyme/admin/admin-stats.service.ts
63. backend/src/modules/loyalpyme/customer/customer.controller.ts
64. backend/src/modules/loyalpyme/customer/customer.service.ts
65. backend/src/modules/loyalpyme/customer/profile.controller.ts
66. backend/src/modules/loyalpyme/customer/profile.service.ts
67. backend/src/modules/loyalpyme/points/points.controller.ts
68. backend/src/modules/loyalpyme/points/points.service.ts
69. backend/src/modules/loyalpyme/rewards/rewards.controller.ts
70. backend/src/modules/loyalpyme/rewards/rewards.service.ts
71. backend/src/modules/loyalpyme/tiers/__tests__/tier-logic.helpers.test.ts
72. backend/src/modules/loyalpyme/tiers/tier-benefit.controller.ts
73. backend/src/modules/loyalpyme/tiers/tier-benefit.service.ts
74. backend/src/modules/loyalpyme/tiers/tier-config.controller.ts
75. backend/src/modules/loyalpyme/tiers/tier-config.service.ts
76. backend/src/modules/loyalpyme/tiers/tier-crud.controller.ts
77. backend/src/modules/loyalpyme/tiers/tier-logic.helpers.ts
78. backend/src/modules/loyalpyme/tiers/tier-logic.service.ts
79. backend/src/modules/loyalpyme/tiers/tiers.controller.ts
80. backend/src/modules/loyalpyme/tiers/tiers.service.ts
81. backend/src/modules/superadmin/superadmin.controller.ts
82. backend/src/modules/superadmin/superadmin.service.ts
83. backend/src/routes/activity.routes.ts
84. backend/src/routes/admin.routes.ts
85. backend/src/routes/auth.routes.ts
86. backend/src/routes/businesses.routes.ts
87. backend/src/routes/camarero-admin.routes.ts
88. backend/src/routes/camarero-kds.routes.ts
89. backend/src/routes/customer.routes.ts
90. backend/src/routes/index.ts
91. backend/src/routes/points.routes.ts
92. backend/src/routes/protected.routes.ts
93. backend/src/routes/public-menu.routes.ts
94. backend/src/routes/public-order.routes.ts
95. backend/src/routes/rewards.routes.ts
96. backend/src/routes/superadmin.routes.ts
97. backend/src/routes/tiers.routes.ts
98. backend/src/routes/uploads.routes.ts
99. backend/src/routes/waiter.routes.ts
100. backend/src/shared/auth/__tests__/auth.service.test.ts
101. backend/src/shared/auth/auth.controller.ts
102. backend/src/shared/auth/auth.dto.ts
103. backend/src/shared/auth/auth.service.ts
104. backend/src/shared/auth/password-reset.controller.ts
105. backend/src/shared/auth/password-reset.service.ts
106. backend/src/shared/auth/registration.controller.ts
107. backend/src/shared/auth/registration.service.ts
108. backend/src/shared/businesses/businesses.controller.ts
109. backend/src/shared/businesses/businesses.service.ts
110. backend/src/shared/middleware/auth.middleware.ts
111. backend/src/shared/middleware/module.middleware.ts
112. backend/src/shared/middleware/multer.config.ts
113. backend/src/shared/middleware/role.middleware.ts
114. backend/src/shared/services/loyalty-points.service.ts
115. backend/src/shared/services/table.service.ts
116. backend/src/shared/uploads/uploads.controller.ts
117. backend/src/shared/uploads/uploads.service.ts
118. backend/src/shared/utils/cloudinary.config.ts
119. backend/src/shared/utils/validation.ts
120. backend/test-server.js
121. backend/tests/integration/auth.test.ts
122. backend/tests/integration/points.test.ts
123. backend/tests/integration/rewards.test.ts
124. backend/tests/integration/tiers.test.ts
125. backend/tsconfig.json
126. backend/vitest.config.ts
127. frontend/eslint.config.js
128. frontend/index.html
129. frontend/package.json
130. frontend/public/locales/en/translation.json
131. frontend/public/locales/es/translation.json
132. frontend/src/App.tsx
133. frontend/src/i18n.ts
134. frontend/src/index.css
135. frontend/src/main.tsx
136. frontend/src/modules/camarero/components/admin/menu/MenuCategoryFormModal.tsx
137. frontend/src/modules/camarero/components/admin/menu/MenuCategoryManager.tsx
138. frontend/src/modules/camarero/components/admin/menu/MenuItemFormModal.tsx
139. frontend/src/modules/camarero/components/admin/menu/MenuItemManager.tsx
140. frontend/src/modules/camarero/components/admin/menu/ModifierGroupsManagementModal.tsx
141. frontend/src/modules/camarero/components/admin/menu/ModifierOptionsManagementModal.tsx
142. frontend/src/modules/camarero/components/public/menu/CategoryAccordion.tsx
143. frontend/src/modules/camarero/components/public/menu/MenuItemCard.tsx
144. frontend/src/modules/camarero/components/public/menu/ModifierGroupInteractiveRenderer.tsx
145. frontend/src/modules/camarero/components/public/menu/ShoppingCartModal.tsx
146. frontend/src/modules/camarero/components/public/menu/order/OrderBillView.tsx
147. frontend/src/modules/camarero/hooks/useActiveOrderState.ts
148. frontend/src/modules/camarero/hooks/useAdminMenuCategories.ts
149. frontend/src/modules/camarero/hooks/useAdminMenuItems.ts
150. frontend/src/modules/camarero/hooks/useAdminModifierGroups.ts
151. frontend/src/modules/camarero/hooks/useAdminModifierOptions.ts
152. frontend/src/modules/camarero/hooks/useMenuItemConfigurator.ts
153. frontend/src/modules/camarero/hooks/usePublicMenuData.ts
154. frontend/src/modules/camarero/hooks/usePublicOrderCart.ts
155. frontend/src/modules/camarero/hooks/useWaiterPickupItems.ts
156. frontend/src/modules/camarero/pages/OrderStatusPage.tsx
157. frontend/src/modules/camarero/pages/PublicMenuViewPage.tsx
158. frontend/src/modules/camarero/pages/admin/camarero/KitchenDisplayPage.tsx
159. frontend/src/modules/camarero/pages/admin/camarero/MenuManagementPage.tsx
160. frontend/src/modules/camarero/pages/admin/camarero/WaiterOrderManagementPage.tsx
161. frontend/src/modules/camarero/pages/admin/camarero/WaiterPickupPage.tsx
162. frontend/src/modules/camarero/services/kdsService.ts
163. frontend/src/modules/camarero/services/publicOrderApiService.ts
164. frontend/src/modules/camarero/services/waiterService.ts
165. frontend/src/modules/camarero/types/camarero.types.ts
166. frontend/src/modules/camarero/types/menu.types.ts
167. frontend/src/modules/camarero/types/publicOrder.types.ts
168. frontend/src/modules/loyalpyme/components/GenerateQrCode.tsx
169. frontend/src/modules/loyalpyme/components/admin/AdjustPointsModal.tsx
170. frontend/src/modules/loyalpyme/components/admin/AssignRewardModal.tsx
171. frontend/src/modules/loyalpyme/components/admin/BulkAdjustPointsModal.tsx
172. frontend/src/modules/loyalpyme/components/admin/ChangeTierModal.tsx
173. frontend/src/modules/loyalpyme/components/admin/CustomerBulkActionsBar.tsx
174. frontend/src/modules/loyalpyme/components/admin/CustomerDetailsModal.tsx
175. frontend/src/modules/loyalpyme/components/admin/CustomerFiltersBar.tsx
176. frontend/src/modules/loyalpyme/components/admin/CustomerTable.tsx
177. frontend/src/modules/loyalpyme/components/admin/StatCard.module.css
178. frontend/src/modules/loyalpyme/components/admin/StatCard.test.tsx
179. frontend/src/modules/loyalpyme/components/admin/StatCard.tsx
180. frontend/src/modules/loyalpyme/components/admin/rewards/RewardForm.tsx
181. frontend/src/modules/loyalpyme/components/admin/tiers/AddTierBenefitForm.tsx
182. frontend/src/modules/loyalpyme/components/admin/tiers/CreateTierModal.tsx
183. frontend/src/modules/loyalpyme/components/admin/tiers/DeleteTierModal.tsx
184. frontend/src/modules/loyalpyme/components/admin/tiers/EditTierModal.tsx
185. frontend/src/modules/loyalpyme/components/admin/tiers/TierBenefitsModal.tsx
186. frontend/src/modules/loyalpyme/components/admin/tiers/TierForm.tsx
187. frontend/src/modules/loyalpyme/components/admin/tiers/TierTable.tsx
188. frontend/src/modules/loyalpyme/components/customer/ApplyRewardModal.tsx
189. frontend/src/modules/loyalpyme/components/customer/AvailableCouponsList.tsx
190. frontend/src/modules/loyalpyme/components/customer/NextTierPreview.tsx
191. frontend/src/modules/loyalpyme/components/customer/QrValidationSection.tsx
192. frontend/src/modules/loyalpyme/components/customer/RewardList.tsx
193. frontend/src/modules/loyalpyme/components/customer/TierBenefitsDisplay.tsx
194. frontend/src/modules/loyalpyme/components/customer/UserInfoDisplay.tsx
195. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/ActivityTab.tsx
196. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/OffersTab.tsx
197. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/OrderDetailModal.tsx
198. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/ProfileTab.tsx
199. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/PurchaseHistoryTab.tsx
200. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/RewardsTab.tsx
201. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/SummaryTab.tsx
202. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/profile/ProfileInfoForm.tsx
203. frontend/src/modules/loyalpyme/hooks/useAdminCustomersData.ts
204. frontend/src/modules/loyalpyme/hooks/useAdminOverviewStats.ts
205. frontend/src/modules/loyalpyme/hooks/useAdminRewards.ts
206. frontend/src/modules/loyalpyme/hooks/useCustomerActivity.ts
207. frontend/src/modules/loyalpyme/hooks/useCustomerPurchaseHistory.ts
208. frontend/src/modules/loyalpyme/hooks/useCustomerRewardsData.ts
209. frontend/src/modules/loyalpyme/hooks/useCustomerTierData.ts
210. frontend/src/modules/loyalpyme/hooks/useQrScanner.ts
211. frontend/src/modules/loyalpyme/hooks/useUserProfileData.ts
212. frontend/src/modules/loyalpyme/pages/CustomerDashboardPage.tsx
213. frontend/src/modules/loyalpyme/pages/admin/AdminCustomerManagementPage.module.css
214. frontend/src/modules/loyalpyme/pages/admin/AdminCustomerManagementPage.tsx
215. frontend/src/modules/loyalpyme/pages/admin/AdminGenerateQr.tsx
216. frontend/src/modules/loyalpyme/pages/admin/AdminOverview.tsx
217. frontend/src/modules/loyalpyme/pages/admin/AdminRewardsManagement.tsx
218. frontend/src/modules/loyalpyme/pages/admin/tiers/TierManagementPage.tsx
219. frontend/src/modules/loyalpyme/pages/admin/tiers/TierSettingsPage.tsx
220. frontend/src/modules/loyalpyme/services/adminCustomerService.ts
221. frontend/src/modules/loyalpyme/services/adminService.ts
222. frontend/src/modules/loyalpyme/types/history.types.ts
223. frontend/src/modules/superadmin/components/SubscriptionManagementModal.tsx
224. frontend/src/modules/superadmin/pages/SuperAdminPage.tsx
225. frontend/src/modules/superadmin/services/superAdminService.ts
226. frontend/src/pages/ForgotPasswordPage.tsx
227. frontend/src/pages/HomePage.tsx
228. frontend/src/pages/LoginPage.module.css
229. frontend/src/pages/LoginPage.tsx
230. frontend/src/pages/RegisterBusinessPage.tsx
231. frontend/src/pages/RegisterPage.tsx
232. frontend/src/pages/ResetPasswordPage.tsx
233. frontend/src/routes/index.tsx
234. frontend/src/shared/components/PrivateRoute.tsx
235. frontend/src/shared/components/PublicRouteOnly.tsx
236. frontend/src/shared/components/layout/AdminNavbar.tsx
237. frontend/src/shared/components/layout/AppHeader.tsx
238. frontend/src/shared/components/layout/MainLayout.tsx
239. frontend/src/shared/components/layout/PublicLayout.tsx
240. frontend/src/shared/components/utils/ImageUploadCropper.tsx
241. frontend/src/shared/components/utils/canvasPreview.ts
242. frontend/src/shared/hooks/useLayoutUserData.ts
243. frontend/src/shared/services/axiosInstance.ts
244. frontend/src/shared/services/businessService.ts
245. frontend/src/shared/types/enums.ts
246. frontend/src/shared/types/superadmin.types.ts
247. frontend/src/shared/types/user.types.ts
248. frontend/src/test/setup.ts
249. frontend/src/theme.ts
250. frontend/src/vite-env.d.ts
251. frontend/tsconfig.app.json
252. frontend/tsconfig.json
253. frontend/tsconfig.node.json
254. frontend/vite.config.ts


# CONTENIDO DE ARCHIVOS


// ====== [1] DEVELOPMENT_PLAN.md ======
# LoyalPyME - Plan de Desarrollo y Futuras Funcionalidades

**√öltima Actualizaci√≥n:** 26 de Junio de 2025 (Refleja el sistema de recompensas avanzado como COMPLETADO. Mantiene "Dividir la Cuenta" como la prioridad CR√çTICA).

Este documento detalla las tareas pendientes inmediatas, el alcance definido para las pr√≥ximas versiones operativas (con √©nfasis en el M√≥dulo Camarero - LC), la deuda t√©cnica y las ideas para la evoluci√≥n futura. Se busca un m√°ximo detalle para guiar el desarrollo, incluyendo consideraciones de UX, modelos de datos implicados, y flujos de trabajo.

---

## A. TRABAJO RECIENTEMENTE COMPLETADO / EN PROGRESO / CORRECCIONES ‚úÖ

[cite_start]‚≠ê **[COMPLETADO - MVP Base Plataforma] Panel Super Admin y Gesti√≥n de Negocios/M√≥dulos (backend, frontend)** [cite: 3]

[cite_start]‚≠ê **[COMPLETADO - M√≥dulo Camarero - Gesti√≥n de Carta Digital] LC - Backend (Modelos BD y API) y Frontend (UI Admin) para Gesti√≥n Completa de Carta Digital.** [cite: 3]

[cite_start]‚≠ê **[COMPLETADO - M√≥dulo Camarero - Vista Cliente y Flujo de Pedido con Modificadores] LC - Backend y Frontend: Visualizaci√≥n de Carta, Configuraci√≥n de √çtems, Carrito y Env√≠o de Pedido por Cliente Final.** [cite: 3]

[cite_start]‚≠ê **[COMPLETADO - M√≥dulo Camarero - KDS Funcional (Backend API, L√≥gica de Estados y Frontend con Acciones)]** [cite: 3]

[cite_start]‚≠ê **[COMPLETADO - M√≥dulo Camarero - Ciclo de Servicio de Camarero (Entrega de √çtems)]** [cite: 3]

[cite_start]‚≠ê **[COMPLETADO - M√≥dulo Camarero - Ciclo Financiero Completo del Pedido]** [cite: 3]

‚≠ê **[COMPLETADO - Integraci√≥n LCo+LC] Sistema de Recompensas Avanzado y Canje en Carrito**

- **Detalles Alcanzados:**
  - **Modelo de Recompensas Extendido (Backend):** El modelo `Reward` en `schema.prisma` se ha ampliado para incluir `RewardType` (`MENU_ITEM`, `DISCOUNT_ON_ITEM`, `DISCOUNT_ON_TOTAL`), `DiscountType` (`PERCENTAGE`, `FIXED_AMOUNT`), `discountValue`, y `linkedMenuItemId` para vincular recompensas a productos espec√≠ficos de la carta.
  - **Gesti√≥n de Recompensas Din√°micas (Admin):** La interfaz de administraci√≥n de recompensas (`RewardForm.tsx`) ahora es din√°mica. Permite al `BUSINESS_ADMIN` crear los tres tipos de recompensas, mostrando condicionalmente un selector de productos del men√∫ o campos para configurar descuentos. Se ha a√±adido un endpoint (`GET /api/camarero/admin/menu/items/all`) para este prop√≥sito.
  - **Canje Integrado en Carrito (Cliente):** El componente `ShoppingCartModal.tsx` ahora muestra a los clientes logueados una secci√≥n con las recompensas que pueden permitirse. Pueden canjear productos (que se a√±aden al carrito con precio 0 ‚Ç¨) o aplicar descuentos que recalculan el total del pedido.
  - **Procesamiento Transaccional At√≥mico (Backend):** El servicio de creaci√≥n de pedidos se ha refactorizado para aceptar `redeemedRewardId` en los √≠tems y `appliedLcoRewardId` en el pedido general. El backend realiza todas las operaciones (validar y aplicar recompensa, debitar puntos, crear el pedido con los precios correctos y generar el `ActivityLog`) dentro de una √∫nica transacci√≥n de base de datos para garantizar la consistencia de los datos.

---

## B. PRIORIDADES ACTUALES: M√≥dulo "LoyalPyME Camarero" (LC) - Funcionalidades Avanzadas de Cuenta üöÄ

Con el ciclo de vida del pedido y la integraci√≥n de recompensas ya implementados, el objetivo inmediato es a√±adir funcionalidades avanzadas que aporten gran valor a la operativa del restaurante, como la divisi√≥n de cuentas.

**BLOQUE 1: FUNCIONALIDADES AVANZADAS DE GESTI√ìN DE CUENTA**

**B1.1. ‚≠ê [CR√çTICO - PENDIENTE] LC - Dividir la Cuenta (Split Bill)**

- [cite_start]**Objetivo Detallado:** Implementar la capacidad para que un camarero divida la cuenta de un pedido pendiente de pago, ya sea asignando √≠tems espec√≠ficos a diferentes personas/pagos, o dividiendo el total en partes iguales. [cite: 4]
- **Sub-Tareas Detalladas (Backend):**
  1.  **Dise√±o de Datos (`schema.prisma`):**
      - Considerar un nuevo modelo `PartialPayment` o `SubOrder` relacionado con el `Order` principal. [cite_start]Este modelo podr√≠a contener campos como `amount`, `paymentMethod`, `status`, `paidByStaffId`, y una relaci√≥n a los `OrderItem`s que incluye. [cite: 4]
      - [cite_start]El `Order` principal podr√≠a tener un nuevo estado `PARTIALLY_PAID` en su enum `OrderStatus`. [cite: 4]
  2.  **L√≥gica de Servicio (`split-bill.service.ts`):**
      - [cite_start]Crear un nuevo servicio que encapsule la l√≥gica compleja de la divisi√≥n. [cite: 4]
      - [cite_start]M√©todo `splitOrderByItems(orderId, splits: { items: orderItemIds[], paymentDetails: ... }[])`: Recibe un array de "divisiones", cada una con sus √≠tems y detalles de pago. [cite: 4]
      - [cite_start]M√©todo `splitByAmount(orderId, numberOfWays: number)`: Divide `finalAmount` entre el n√∫mero de partes. [cite: 5]
      - [cite_start]Debe validar que la suma de las partes coincida con el total del pedido antes de procesar los pagos. [cite: 5]
  3.  **Controladores y Rutas:**
      - Nuevos endpoints protegidos en `/api/camarero/staff/order/:orderId/split-bill`. [cite_start]Por ejemplo, uno para iniciar la divisi√≥n y otro para procesar cada pago parcial. [cite: 5]
- **Sub-Tareas Detalladas (Frontend - Camarero):**
  1.  **Dise√±o de UI/UX:**
      - [cite_start]En la vista de gesti√≥n de un pedido, un bot√≥n "Dividir Cuenta". [cite: 5]
      - Esto abrir√° un modal o una nueva vista dedicada. [cite_start]La UI debe ser muy clara, mostrando todos los √≠tems del pedido a la izquierda y varias "columnas" o "cestas" a la derecha, representando a cada persona que va a pagar. [cite: 5]
      - El camarero debe poder arrastrar y soltar √≠tems a cada cesta. [cite_start]La UI recalcular√° los subtotales de cada cesta en tiempo real. [cite: 5]
      - [cite_start]Debe haber una opci√≥n para "dividir equitativamente" que distribuya el total autom√°ticamente. [cite: 5]
  2.  **Integraci√≥n con API:**
      - [cite_start]Conectar la nueva UI con los endpoints del backend para procesar cada pago parcial de forma individual. [cite: 5]
      - [cite_start]La vista principal del pedido debe reflejar los pagos parciales realizados y el saldo restante. [cite: 6]

---

## C. FUNDAMENTOS T√âCNICOS ESENCIALES LC (Paralelo y Continuo)

**C1. [ALTA] Testing Backend:**

- **PENDIENTE (Prioridad Alta):**
  - [cite_start]Tests unitarios y de integraci√≥n para la l√≥gica de "Dividir la Cuenta" (`split-bill.service.ts`). [cite: 6]
  - [cite_start]Tests para la API de gesti√≥n de personal y PINs cuando se desarrolle. [cite: 6]

**C2. [CR√çTICA - EN PROGRESO] Validaci√≥n Robusta Backend (Zod o `class-validator`):**

- **PENDIENTE:**
  - [cite_start]Crear y validar DTOs para los nuevos endpoints de "Dividir la Cuenta". [cite: 6]

**C3. [ALTA - PENDIENTE] Seguridad LC:**

- **PENDIENTE:**
  - [cite_start]Implementar l√≥gica de autenticaci√≥n para `StaffPin` si se decide usarla para login r√°pido del camarero. [cite: 6]
  - [cite_start]Planificar c√≥mo se integrar√° el futuro sistema de permisos granulares. [cite: 6]

**C4. [ALTA - EN PROGRESO] Logging y Monitoring B√°sico LC:**

- **PENDIENTE:**
  - [cite_start]A√±adir logs detallados para el nuevo flujo de "Dividir la Cuenta". [cite: 6]

**C5. [MEDIA - PENDIENTE] Internacionalizaci√≥n (i18n) Completa LC:**

- **PENDIENTE:**
  - [cite_start]Traducir todos los textos de las nuevas interfaces (ej. modal de "Dividir la Cuenta"). [cite: 6]

---

## D. FUNCIONALIDADES LOYALPYME CORE (LCo) Y MEJORAS PLATAFORMA

- **D1. [cite_start][MEDIA] LCo - Mejoras UX/UI Panel Cliente** [cite: 7]
- **D2. [cite_start][BAJA/MEDIA] LCo - Gesti√≥n de Notificaciones al Cliente (Email/Push)** [cite: 7]
- **D3. [cite_start][BAJA/MEDIA] LCo - Estad√≠sticas Avanzadas para Admin** [cite: 7]
- **D4. [cite_start][MEDIA] Plataforma - Mejoras UI/UX Panel Admin General** [cite: 7]
- **D5. [cite_start][BAJA/MEDIA] Plataforma - Documentaci√≥n API Swagger/OpenAPI m√°s Detallada** [cite: 7]
- **D6. [cite_start][BAJA] Plataforma - Configuraci√≥n Adicional del Negocio por el Admin** [cite: 7]
- **D8. [cite_start][BAJA] Plataforma - Onboarding y Ayuda (Gu√≠as y Tooltips)** [cite: 7]
- **D9. [cite_start][BAJA/MEDIA] Plataforma - Optimizaci√≥n y Rendimiento General** [cite: 7]

---

## E. DEUDA T√âCNICA Y MEJORAS CONTINUAS (Transversales) üõ†Ô∏è

- **E1. [cite_start][ALTA] Refactorizaci√≥n y Reorganizaci√≥n de C√≥digo Continuo** [cite: 7]
- **E2. [cite_start][MEDIA] Mejorar la Gesti√≥n y Presentaci√≥n de Errores (Backend y Frontend)** [cite: 7]
- **E3. [cite_start][MEDIA] Actualizaci√≥n de Dependencias Peri√≥dica y Gesti√≥n de Vulnerabilidades** [cite: 7]
- **E4. [cite_start][EN PROGRESO - LC] Validaci√≥n Robusta Backend (`class-validator` y `class-transformer`)** [cite: 7]
- **E5. [cite_start][BAJA/MEDIA] Optimizaci√≥n de Consultas a Base de Datos (Continuo)** [cite: 7]
- **E6. [cite_start][MEDIA] Documentaci√≥n Interna del C√≥digo (JSDoc/TSDoc)** [cite: 7]
- **E7. [cite_start][ALTA] Variables de Entorno y Configuraci√≥n Centralizada** [cite: 7]
- **E8. [cite_start][MEDIA] Accesibilidad (a11y) Frontend (Continuo)** [cite: 7]
- **E9. [cite_start][BAJA/MEDIA] CI/CD (Integraci√≥n Continua / Despliegue Continuo) B√°sico** [cite: 7]

---

## F. VISI√ìN FUTURA / M√ìDULOS ADICIONALES üöÄ

- **F1. [cite_start]LC - Funcionalidades Muy Avanzadas de Hosteler√≠a** (Pago Online, **[PRIORIDAD ACTUAL: Divisi√≥n de Cuentas]**, Reservas, Inventario B√°sico, Informes Avanzados) [cite: 7, 8]
- **F2. [cite_start]M√≥dulo Pedidos Online / Take Away / Delivery (Extensi√≥n de LC)** [cite: 8]
- **F3. [cite_start]App M√≥vil Dedicada (PWA Progresiva y/o Nativa)** [cite: 8]
- **F4. [cite_start]Pruebas Automatizadas E2E (End-to-End)** [cite: 8]
- **F5. [cite_start]Monetizaci√≥n Avanzada y Planes de Suscripci√≥n Detallados (Plataforma)** [cite: 8]
- **F6. [cite_start]Personalizaci√≥n y CRM Avanzado (Transversal LCo/LC)** [cite: 8]
- **F7. [cite_start]Gamificaci√≥n Avanzada (LCo)** [cite: 8]
- **F8. [cite_start](VISI√ìN A LARGO PLAZO) M√≥dulo TPV (Terminal Punto de Venta) Integrado** [cite: 8]
- **F9. [cite_start](VISI√ìN A MUY LARGO PLAZO) M√≥dulo Contabilidad / Integraciones Contables** [cite: 8]



// ====== [2] LICENSE.md ======
# LoyalPyME - Software Propietario

Copyright (c) 2024-2025 Olivier Hottelet. Todos los derechos reservados.

Este software y su c√≥digo fuente son propiedad exclusiva de Olivier Hottelet.
Este software es confidencial y se considera un secreto comercial.

Queda estrictamente prohibida la copia, reproducci√≥n, modificaci√≥n, distribuci√≥n,
descompilaci√≥n, ingenier√≠a inversa, creaci√≥n de trabajos derivados, o cualquier
otro uso no autorizado de este software, en su totalidad o en parte, sin el
permiso previo, expl√≠cito y por escrito del propietario de los derechos de autor.

El uso de este software est√° sujeto a los t√©rminos y condiciones establecidos
en el acuerdo de licencia aplicable que se proporcionar√° a los usuarios autorizados.

Para consultas sobre licencias, adquisici√≥n, o cualquier otro asunto relacionado
con este software, por favor contacte a: olivierhottelet1980@gmail.com

---

# LoyalPyME - Proprietary Software

Copyright (c) 2024-2025 Olivier Hottelet. All rights reserved.

This software and its source code are the exclusive property of Olivier Hottelet.
This software is confidential and considered a trade secret.

Copying, reproduction, modification, distribution, decompilation, reverse engineering,
creation of derivative works, or any other unauthorized use of this software,
in whole or in part, is strictly prohibited without the prior, explicit,
and written permission of the copyright owner.

Use of this software is subject to the terms and conditions set forth in the
applicable license agreement to be provided to authorized users.

For licensing inquiries, acquisition, or any other matters related to this software,
please contact: olivierhottelet1980@gmail.com



// ====== [3] LOYALPYME_CAMARERO_WORKFLOW.md ======
# LoyalPyME Camarero: ¬°Tu Experiencia Gastron√≥mica, Digitalizada y Eficiente! üßë‚Äçüç≥üì±‚ú®

**√öltima Actualizaci√≥n:** 26 de Junio de 2025 (Refleja el canje de recompensas LCo integrado en el carrito de pedido como funcionalidad completada y validada.)

Bienvenido a la experiencia moderna de pedir y disfrutar en tu establecimiento favorito con **LoyalPyME Camarero**. Dise√±ado para agilizar el servicio, personalizar tu pedido, mejorar la comunicaci√≥n y ahora, ¬°canjear tus recompensas de fidelidad directamente en tu pedido!

---

## üöÄ I. El Viaje del Cliente Final: Control y Comodidad en Tu Mano

Este flujo describe la experiencia del cliente desde su llegada hasta la finalizaci√≥n y pago de su pedido, incluyendo las interacciones con el personal de cocina/barra (KDS) y de sala (Camarero).

### [cite_start]1. üì≤ Llegada y Escaneo M√°gico del QR de Mesa [cite: 10]

- **Bienvenida:** Al llegar, el cliente encuentra un c√≥digo QR √∫nico en su mesa, provisto por el establecimiento. [cite_start]Este QR contiene el `tableIdentifier` √∫nico de esa mesa. [cite: 10]
- **Escaneo Instant√°neo:** Usando la c√°mara de su smartphone (o una app de lectura de QR), el cliente escanea el c√≥digo. [cite_start]El QR lo redirige a una URL del tipo `https://[tuDominio.com]/m/[businessSlug]/[tableIdentifier]`. [cite: 10]
- [cite_start]**Estado: [COMPLETADO]** [cite: 10]

### [cite_start]2. üßæ Explora la Carta Digital Interactiva (`PublicMenuViewPage.tsx`) [cite: 10]

- [cite_start]**Acceso Inmediato:** Al acceder a la URL, se carga la carta digital del negocio (`businessSlug`), contextualizada para la mesa (`tableIdentifier`). [cite: 11]
- [cite_start]**Verificaci√≥n de Pedido Activo (Fundamental):** [cite: 10]
  - [cite_start]Al cargar la p√°gina, el sistema revisa `localStorage` buscando una entrada con la clave `activeOrderInfo_BUSINESSSLUG_TABLEIDENTIFIER`. [cite: 10]
  - [cite_start]**Si existe un pedido activo (`activeOrderIdForTable`, `activeOrderNumberForTable`):** [cite: 10]
    - [cite_start]La UI muestra un mensaje destacado: "Tienes el pedido #{{orderNumber}} en curso para esta mesa." [cite: 10]
    - [cite_start]**Opciones Clave:** [cite: 11]
      - [cite_start]"Ver Estado del Pedido": Enlaza directamente a `/order-status/:activeOrderId`. [cite: 11]
      - [cite_start]**"[COMPLETADO Y VALIDADO]" A√±adir m√°s √çtems a este Pedido:** La carta se mantiene interactiva, permitiendo al cliente a√±adir nuevos productos al pedido en curso. [cite: 11]
  - [cite_start]**Si NO existe pedido activo:** La p√°gina funciona en modo "crear nuevo pedido", con el carrito vac√≠o. [cite: 11]
- [cite_start]**Navegaci√≥n y Detalle del √çtem (`MenuItemCard.tsx`):** [cite: 11]
  - [cite_start]Categor√≠as del men√∫ presentadas en componentes tipo acorde√≥n (`CategoryAccordion.tsx`). [cite: 11]
  - [cite_start]Cada √≠tem se muestra en una tarjeta (`MenuItemCard.tsx`) con su imagen, nombre (i18n), descripci√≥n (i18n), precio base, lista de al√©rgenos y etiquetas. [cite: 11]
- [cite_start]**Estado: [COMPLETADO Y VALIDADO]** [cite: 11]

### [cite_start]3. üé® Personaliza tu Plato (`MenuItemCard.tsx`, `ModifierGroupInteractiveRenderer.tsx`) [cite: 11]

- [cite_start]Al seleccionar un √≠tem, se abre un modal o secci√≥n para la configuraci√≥n de modificadores. [cite: 11]
- [cite_start]**Selecci√≥n de Modificadores:** [cite: 11]
  - [cite_start]Se presentan los `ModifierGroup`s asociados al √≠tem. [cite: 11]
  - [cite_start]Cada grupo muestra sus `ModifierOption`s seg√∫n el `uiType` (RADIO para selecci√≥n √∫nica, CHECKBOX para m√∫ltiple). [cite: 11]
  - [cite_start]**Validaci√≥n en Tiempo Real Frontend:** Se aplican las reglas `minSelections`, `maxSelections`, y `isRequired`. [cite: 11]
  - [cite_start]**C√°lculo de Precio Din√°mico:** El precio del √≠tem se actualiza instant√°neamente en la UI. [cite: 12]
- [cite_start]**Cantidad y Notas:** El cliente puede ajustar la cantidad del √≠tem y a√±adir instrucciones especiales. [cite: 12]
- [cite_start]**Estado: [COMPLETADO Y VALIDADO]** [cite: 12]

### [cite_start]4. üõí Tu Carrito de Pedido (`ShoppingCartModal.tsx` en `PublicMenuViewPage.tsx`) [cite: 12]

- [cite_start]**Acumulaci√≥n de √çtems:** Los √≠tems configurados se a√±aden al estado local `currentOrderItems` y se persisten en `localStorage`. [cite: 12]
- [cite_start]**Modal del Carrito:** Permite la revisi√≥n detallada del pedido, modificaci√≥n de cantidades, eliminaci√≥n de √≠tems y edici√≥n de notas generales (`orderNotes`). [cite: 12]
- **[NUEVO Y VALIDADO] Canje de Recompensas y Descuentos LCo:**
  - Para los clientes que han iniciado sesi√≥n en el programa de fidelizaci√≥n (LCo), el modal del carrito ahora muestra una secci√≥n de "Mis Recompensas".
  - Desde aqu√≠, el cliente puede ver las recompensas que se puede permitir con sus puntos y aplicarlas directamente:
    - **Canjear Productos Gratis:** Al hacer clic, el producto asociado a la recompensa se a√±ade al carrito con precio 0‚Ç¨ y una insignia distintiva. Su cantidad no puede ser modificada.
    - **Aplicar Descuentos:** Al seleccionar una recompensa de descuento (ej. 10% o 5‚Ç¨ menos), el total del pedido se recalcula instant√°neamente para reflejar el beneficio. Solo se puede aplicar un descuento de este tipo por pedido.
- **Estado: [COMPLETADO Y VALIDADO]**

### [cite_start]5. ‚≠ê Opcional: Identif√≠cate para Beneficios LCo (Integraci√≥n con LoyalPyME Core) [cite: 12]

- [cite_start]**Contexto:** Si el `Business` tiene el m√≥dulo LCo activo. [cite: 12]
- **Flujo:** Si el cliente est√° logueado en su cuenta de LoyalPyME, su `customerId` se obtiene y se asocia al pedido al enviarlo. [cite_start]Este paso es **crucial** para poder ver y canjear las recompensas en el carrito de compra. [cite: 12]
- [cite_start]**Impacto:** Al pagar el pedido, el backend asociar√° los puntos de fidelidad a esta cuenta de cliente. [cite: 12]
- [cite_start]**Estado: [COMPLETADO Y VALIDADO]** [cite: 12]

### [cite_start]6. ‚û°Ô∏è Env√≠a tu Pedido o A√±ade a uno Existente [cite: 12]

- [cite_start]Desde el `ShoppingCartModal`, el cliente pulsa "Enviar Pedido" o "A√±adir al Pedido". [cite: 12]
- **Payload:** Se construye un DTO que incluye el array de `items`, `orderNotes?`, `tableIdentifier`, y `customerId?`.
  - **[NUEVO]** El payload ahora puede incluir `redeemedRewardId` en cada √≠tem (si se canje√≥ como producto gratis) y/o un `appliedLcoRewardId` global (si se aplic√≥ un descuento al total).
- [cite_start]**Endpoint:** La l√≥gica del frontend (`handleOrderSubmission`) decide si llamar a `POST /public/order/:businessSlug` (para crear) o a `POST /public/order/:orderId/items` (para a√±adir). [cite: 13]
- [cite_start]**Backend:** Valida exhaustivamente la petici√≥n (disponibilidad, reglas de modificadores, **validez de las recompensas**), recalcula precios, **debita los puntos del cliente** y crea/actualiza los registros en la base de datos de forma **transaccional y at√≥mica**. [cite: 13]
- [cite_start]**Frontend Post-Env√≠o:** Muestra notificaci√≥n de √©xito, guarda `activeOrderInfo` en `localStorage` (si es nuevo), limpia el carrito y redirige a `/order-status/:orderId`. [cite: 13]
- [cite_start]**Estado: [COMPLETADO Y VALIDADO]** [cite: 13]

### [cite_start]7. ‚è≥ P√°gina de Estado del Pedido (`OrderStatusPage.tsx`) [cite: 13]

- [cite_start]**Acceso y Visualizaci√≥n:** Muestra `orderNumber`, `tableIdentifier`, estado general del `Order` y estado individual de cada `OrderItem`. [cite: 13]
- [cite_start]**Polling Autom√°tico:** Refresca datos llamando a `GET /public/order/:orderId/status` cada ~10 segundos. [cite: 13]
- [cite_start]**L√≥gica de Pedido Finalizado:** Si `orderStatus` es `PAID` o `CANCELLED`, detiene el polling, muestra un mensaje final y permite iniciar un nuevo pedido (limpiando `localStorage`). [cite: 13]
- [cite_start]**Botones de Acci√≥n:** [cite: 13]
  - [cite_start]"Volver al Men√∫": Enlaza de vuelta a la carta para poder a√±adir m√°s √≠tems al pedido activo. [cite: 13]
  - **"[COMPLETADO Y VALIDADO]" Bot√≥n "Pedir la Cuenta":** Se muestra si el pedido est√° en un estado apropiado. [cite_start]Al pulsarlo, llama a `POST /public/order/:orderId/request-bill`, y la UI refleja "Cuenta solicitada..." al actualizarse el estado a `PENDING_PAYMENT`. [cite: 13]
- [cite_start]**Estado: [COMPLETADO Y VALIDADO]** [cite: 14]

---

## üë®‚Äçüç≥ II. [cite_start]Flujo del Personal de Cocina/Barra (KDS - Kitchen Display System) - [COMPLETADO Y VALIDADO] [cite: 14]

[cite_start]El KDS (`KitchenDisplayPage.tsx`) es el panel de control digital para la preparaci√≥n eficiente y coordinada de los pedidos. [cite: 14]

### [cite_start]1. üñ•Ô∏è Acceso y Visualizaci√≥n de Comandas/√çtems [cite: 14]

- [cite_start]El personal se autentica, selecciona su destino KDS ("COCINA", "BARRA") y ve una cola de `OrderItem`s pendientes o en preparaci√≥n, ordenados cronol√≥gicamente. [cite: 14]
- [cite_start]**Estado: [COMPLETADO Y VALIDADO]** [cite: 14]

### [cite_start]2. üîÑ Gesti√≥n del Estado de Preparaci√≥n de √çtems (`PATCH /api/camarero/kds/items/:orderItemId/status`) [cite: 14]

- [cite_start]A trav√©s de botones de acci√≥n, el personal cambia el estado de los √≠tems de `PENDING_KDS` -> `PREPARING` -> `READY`, o los cancela. [cite: 14]
- [cite_start]El backend actualiza el estado general del `Order` (`IN_PROGRESS`, `ALL_ITEMS_READY`, etc.) en consecuencia. [cite: 14]
- [cite_start]**Estado: [COMPLETADO Y VALIDADO]** [cite: 14]

---

## ü§µ III. [cite_start]Flujo del Personal de Sala/Camareros (Interfaz de Camarero) [cite: 14]

[cite_start]Esta secci√≥n detalla la funcionalidad para el rol `WAITER` a trav√©s de las interfaces de servicio. [cite: 14]

### [cite_start]1. üîë Acceso y Vista General (Interfaz Camarero) [cite: 14]

- [cite_start]**Autenticaci√≥n:** Login est√°ndar para `UserRole.WAITER` (email/password). [cite: 14]
- [cite_start]**Panel Principal:** Actualmente compuesto por `WaiterPickupPage.tsx` y `WaiterOrderManagementPage.tsx`. [cite: 14]

### [cite_start]2. üçΩÔ∏è Recogida y Entrega de Pedidos (`WaiterPickupPage.tsx`) [cite: 14]

- [cite_start]El camarero ve una lista de `OrderItem`s que est√°n en estado `READY`. [cite: 14]
- Al entregar un √≠tem, lo marca como "Servido" (`SERVED`). [cite_start]El √≠tem desaparece de la lista. [cite: 15]
- [cite_start]Cuando todos los √≠tems de un pedido est√°n servidos, el `Order.status` general cambia a `COMPLETED`. [cite: 15]
- [cite_start]**Estado: [COMPLETADO Y VALIDADO]** [cite: 15]

### [cite_start]3. üí∏ Gesti√≥n de Cuentas y Pago (`WaiterOrderManagementPage.tsx`) [cite: 15]

- [cite_start]**Visualizar Pedidos para Cobro:** En la lista de pedidos, se destacan aquellos con `Order.status = PENDING_PAYMENT`. [cite: 15]
- [cite_start]**Procesar Pago y Marcar como Pagado:** [cite: 15]
  - [cite_start]El camarero tiene una acci√≥n "Marcar Como Pagada" para un pedido `PENDING_PAYMENT`. [cite: 15]
  - [cite_start]Al usarla, se llama a `POST /api/camarero/staff/order/:orderId/mark-as-paid`. [cite: 15]
  - [cite_start]El backend (`OrderService.markOrderAsPaid`) actualiza `Order.status = PAID`, registra `paidAt` y el `paidByUserId`. [cite: 15]
- [cite_start]**Liberar Mesa e Integraci√≥n LCo:** [cite: 15]
  - **Backend:** Autom√°ticamente, tras marcar como `PAID`, el servicio actualiza el `Table.status` a `AVAILABLE`. [cite_start]Si el pedido ten√≠a un `customerLCoId` y el m√≥dulo LCo est√° activo, se dispara la asignaci√≥n de puntos. [cite: 15]
  - [cite_start]**Frontend:** La UI del camarero y del cliente reflejan el cambio de estado. [cite: 15]
- [cite_start]**Estado: [COMPLETADO Y VALIDADO]** [cite: 15]

---

## üëë IV. [cite_start]Flujo del Administrador del Negocio (LC) - Configuraci√≥n y Supervisi√≥n [cite: 15]

### [cite_start]1. ‚öôÔ∏è Gesti√≥n de Carta Digital [cite: 15]

- [cite_start]CRUD completo de `MenuCategory`, `MenuItem`, `ModifierGroup`, `ModifierOption` funcional. [cite: 15]
- [cite_start]**Estado: [COMPLETADO Y VALIDADO]** [cite: 15]

### [cite_start]2. ü™ë Gesti√≥n de Mesas y Personal [cite: 16]

- [cite_start]Funcionalidades b√°sicas para la gesti√≥n de mesas y personal est√°n implementadas, permitiendo el flujo actual. [cite: 16]
- [cite_start]**Estado: [FUNCIONALIDAD BASE COMPLETADA]** [cite: 16]

---

‚ú® **Beneficios para el Negocio con LoyalPyME Camarero (Visi√≥n Actual):**

- [cite_start]**Eficiencia Operativa:** Reducci√≥n de errores en la toma de comandas, comunicaci√≥n directa y clara con cocina/barra. [cite: 16]
- **Mejora de la Experiencia del Cliente:** Autonom√≠a para pedir, personalizar, seguir el estado del pedido y **canjear sus recompensas al instante**.
- **Aumento del Engagement y la Conversi√≥n:** Al mostrar las recompensas directamente en el carrito, se incentiva al cliente a completar el pedido y a utilizar sus puntos, aumentando la satisfacci√≥n y la percepci√≥n de valor.
- [cite_start]**Optimizaci√≥n de Tiempos:** Agilizaci√≥n del proceso de pedido, preparaci√≥n, servicio y pago. [cite: 16]
- [cite_start]**Incremento Potencial de Ventas:** Facilidad para a√±adir √≠tems a un pedido existente. [cite: 16]
- **Recopilaci√≥n de Datos:** Informaci√≥n valiosa sobre √≠tems populares, tiempos de preparaci√≥n, y ahora tambi√©n, sobre las **recompensas m√°s canjeadas**.
- [cite_start]**Imagen Moderna y Profesional:** Adopci√≥n de tecnolog√≠a para mejorar el servicio. [cite: 16]
- [cite_start]**Integraci√≥n con Fidelizaci√≥n (LCo):** Cada pedido pagado se convierte autom√°ticamente en una oportunidad para fidelizar. [cite: 16]



// ====== [4] LOYALPYME_CORE_WORKFLOW.md ======
# LoyalPyME: Fidelizaci√≥n y Servicio, ¬°Una Alianza Estrat√©gica para tu Negocio! ü§ùüåüüçΩÔ∏è

**√öltima Actualizaci√≥n:** 26 de Junio de 2025 (Refleja el canje integrado de recompensas en el carrito de LC como una funcionalidad completada y validada).

Cuando un negocio decide activar tanto el m√≥dulo de fidelizaci√≥n **LoyalPyME Core (LCo)** para la gesti√≥n de la lealtad de sus clientes, como el m√≥dulo de operativa de servicio **LoyalPyME Camarero (LC)** para digitalizar la experiencia en el local, se desbloquea un potencial extraordinario. La integraci√≥n fluida y pensada entre ambos m√≥dulos crea una experiencia de cliente superior, cohesiva y gratificante, al mismo tiempo que proporciona al negocio herramientas m√°s potentes para la gesti√≥n, el an√°lisis y el crecimiento.

Este documento detalla los puntos de contacto, las sinergias y los flujos de trabajo espec√≠ficos que surgen cuando LCo y LC operan conjuntamente.

---

## ‚ú® I. La Experiencia del Cliente Potenciada: Pedidos que Suman, Beneficios que Impactan

Para un cliente que interact√∫a con un establecimiento que ha activado y sincronizado LoyalPyME Core y LoyalPyME Camarero, el recorrido se enriquece, ofreciendo conveniencia operativa y recompensas por su lealtad de manera integrada.

### 1. üì≤ Acceso a la Carta LC con Identidad LCo (Opcional pero Clave)

- **Punto de Entrada Principal (LC):** El cliente escanea el QR de mesa (`/m/:businessSlug/:tableIdentifier`), explora la carta, personaliza √≠tems y prepara su pedido. Este flujo es gestionado por `PublicMenuViewPage.tsx`.
- **Integraci√≥n Visible de LCo:** En la interfaz de la carta LC, se presentan opciones para "Iniciar Sesi√≥n" (si ya tiene cuenta LCo) o "Registrarse" (para crear una).
- **Objetivo:** Asociar un `customerId` de LCo al `Order` que se cree en LC para habilitar el canje de recompensas y la acumulaci√≥n de puntos.

### 2. üí≥ Proceso de Identificaci√≥n LCo Durante el Flujo de Pedido LC

- **Flujo de Login/Registro:** Al seleccionar "Iniciar Sesi√≥n" o "Registrarse" desde LC, se usan modales para los formularios de LCo, manteniendo al cliente en el contexto del pedido.
- **Sincronizaci√≥n de Sesi√≥n:** Tras una autenticaci√≥n/registro exitoso, el frontend almacena el `customerId` y token JWT de LCo.

### 3. üõçÔ∏è Env√≠o de Pedido LC (Nuevo o Adici√≥n) y Asociaci√≥n al Cliente LCo

- El cliente configura su pedido en la interfaz LC y procede al env√≠o.
- **Payload del Pedido LC:** Si el cliente se identific√≥ con LCo, el `customerId` se incluye en el `CreateOrderPayloadDto`. **Adicionalmente, el payload ahora incluye `redeemedRewardId` en los √≠tems canjeados y/o un `appliedLcoRewardId` global para descuentos sobre el total.**
- **Procesamiento Backend (LC):** El servicio `order-creation.service.ts` asocia el `customerId` al campo `Order.customerLCoId` y procesa las recompensas aplicadas.

### 4. üíØ [COMPLETADO Y VALIDADO] Acumulaci√≥n Autom√°tica de Puntos LCo por Consumo en LC (Post-Pago)

- **Evento Disparador Clave:** La acumulaci√≥n de puntos LCo se produce cuando un `Order` del M√≥dulo Camarero, que tiene un `customerLCoId` asociado, cambia su `OrderStatus` a **`PAID`**.
- **¬øQui√©n marca el pedido como `PAID`?** El **Camarero**, desde su interfaz de gesti√≥n de pedidos (`WaiterOrderManagementPage`), despu√©s de que el cliente haya pagado f√≠sicamente.
- **L√≥gica de Backend para la Integraci√≥n LCo-LC:**
  1.  **Detecci√≥n del Evento:** El `order-payment.service.ts` detecta el cambio de estado a `PAID`.
  2.  **Verificaci√≥n:** Comprueba que `Order.customerLCoId` no es nulo.
  3.  **C√°lculo de Puntos:** Obtiene `Order.finalAmount` y `Business.pointsPerEuro`, y aplica posibles multiplicadores de puntos del `Tier` del cliente.
  4.  **Actualizaci√≥n de Datos en LCo:** De forma robusta, crea un registro en `ActivityLog` (LCo) de tipo `POINTS_EARNED_ORDER_LC`, actualiza los puntos (`User.points`), el gasto total y las visitas del cliente, y dispara la reevaluaci√≥n de su nivel de fidelizaci√≥n.
  - **Notificaci√≥n al Cliente (Futuro):** Se planea enviar un email o notificaci√≥n push informando los puntos ganados.

### 5. üåü [COMPLETADO Y VALIDADO] Canje de Recompensas LCo en el Carrito de Pedido LC

- Esta es una funcionalidad clave ya implementada que se construye sobre la identificaci√≥n del cliente.
- **Visualizaci√≥n y Canje en Carrito (`ShoppingCartModal.tsx`):**
  - Si el cliente est√° identificado con LCo, el modal del carrito muestra una secci√≥n **"Mis Recompensas"** con las ofertas que puede permitirse con sus puntos.
  - **Recompensas de Producto Gratis:** El cliente puede seleccionar una recompensa de tipo "Producto Gratis" (ej. "Caf√© Gratis"). Al hacerlo, ese `MenuItem` se a√±ade al carrito con precio 0 y una marca distintiva de "recompensa".
  - **Recompensas de Descuento:** El cliente puede aplicar una recompensa de tipo "Descuento" (ej. "5‚Ç¨ de descuento"). Al hacerlo, el total del pedido se recalcula instant√°neamente para reflejar el descuento. Solo un descuento de este tipo puede estar activo a la vez.
- **Sincronizaci√≥n Transaccional en Backend:**
  - **Payload Enriquecido:** El pedido enviado desde el frontend incluye los `redeemedRewardId` de los √≠tems gratis y/o el `appliedLcoRewardId` del descuento global.
  - **Validaci√≥n At√≥mica:** El backend (`order-creation.service.ts`) recibe el pedido y, dentro de una √∫nica transacci√≥n, realiza todas las validaciones:
    1.  Verifica que el cliente tiene suficientes puntos.
    2.  Verifica que la recompensa es v√°lida y aplicable.
    3.  Debita los puntos correspondientes de la cuenta del cliente (`User.points`).
    4.  Crea el `Order` y sus `OrderItem`s, aplicando los descuentos y precios correctos.
    5.  Genera un registro en `ActivityLog` para el canje de la recompensa.
  - Esta naturaleza transaccional asegura que no se canjee una recompensa sin crear el pedido correctamente, o viceversa, manteniendo la integridad de los datos.

### 6. üìú [COMPLETADO] Historial de Actividad Unificado (Visi√≥n Cliente en Dashboard LCo)

- El `ActivityLog` del cliente en su dashboard LCo (`ActivityTab.tsx`) es la fuente central de informaci√≥n.
- **Entradas de Integraci√≥n LC+LCo:**
  - `POINTS_EARNED_ORDER_LC`: Detalla los puntos ganados por pedidos en el M√≥dulo Camarero.
  - `REWARD_REDEEMED_IN_LC_ORDER`: Detalla las recompensas LCo canjeadas directamente en los pedidos LC.
  - `POINTS_REDEEMED_REWARD`: Se mantiene para canjes realizados desde el propio dashboard de cliente.

---

## ‚öôÔ∏è II. La Visi√≥n del Negocio (`BUSINESS_ADMIN`): Gesti√≥n Integrada, Datos Enriquecidos y Sinergias

### 1. üîó [PARCIALMENTE COMPLETADO] Configuraci√≥n de la Integraci√≥n LCo <-> LC (Panel Admin)

- **Ubicaci√≥n:** Secci√≥n de "Recompensas" y "Gesti√≥n de Carta" en el panel de admin.
- **Par√°metros Configurables por el `BUSINESS_ADMIN`:**
  - **Acumulaci√≥n de Puntos:**
    - Interruptor: "Habilitar/Deshabilitar Acumulaci√≥n de Puntos LCo desde Pedidos LC" (Funcionalidad Futura).
    - Campo `pointsPerEuro` en la configuraci√≥n del negocio (Ya implementado).
  - **[COMPLETADO] Mapeo de Recompensas LCo:** La integraci√≥n se configura al crear la recompensa. En el `RewardForm.tsx`, si el admin elige el tipo "Producto Gratis", se le presenta un selector con todos los `MenuItem` de su carta (obtenidos de la API de LC), permiti√©ndole vincular la recompensa directamente a un producto.

### 2. üìä [PENDIENTE] Visi√≥n 360¬∫ del Cliente y Reportes Combinados

- **Perfil de Cliente Unificado (Admin LCo - `AdminCustomerManagementPage`):**
  - Al ver un cliente LCo, mostrar una nueva pesta√±a/secci√≥n "Actividad en M√≥dulo Camarero":
    - Resumen: N¬∫ total de pedidos LC, gasto total LC, fecha √∫ltimo pedido LC.
    - (Opcional) Lista de los N √∫ltimos pedidos LC con enlace a sus detalles.
- **Sincronizaci√≥n de M√©tricas Clave LCo:** `User.totalSpend` y `User.totalVisits` (LCo) se actualizan no solo por QR LCo, sino tambi√©n por `Order`s LC pagados y asociados al cliente.
- **Reportes Combinados:** Posibilidad de segmentar y analizar el impacto de LC en la progresi√≥n de niveles de LCo y el impacto de las recompensas LCo en las ventas de LC.

### 3. üì¢ [PENDIENTE] Estrategias de Marketing y Promoci√≥n Cruzada Mejoradas

- **Incentivos Dirigidos:** Crear Recompensas LCo espec√≠ficas (ej. "Doble Puntos en tu primer pedido LC") o Beneficios de Nivel LCo atractivos para usar con LC.
- **Promoci√≥n de LCo dentro de la Experiencia LC:** Mensajes/banners configurables por el admin en `PublicMenuViewPage` para incentivar registro/login en LCo.

### 4. ‚öôÔ∏è Operativa y Sincronizaci√≥n de Estados Clave (Flujo Backend - Consideraciones Importantes)

- **Estado `PAID` en `Order` LC (CRUCIAL):** El mecanismo para marcar un `Order` LC como `PAID` por el camarero es robusto y es el disparador principal para la asignaci√≥n de puntos LCo.
- **[COMPLETADO] Transaccionalidad en Canjes LCo en Pedidos LC:** La l√≥gica de canje de recompensas y d√©bito de puntos durante la creaci√≥n de un pedido LC ya est√° implementada de forma transaccional en `order-creation.service.ts` para asegurar la consistencia de datos entre los m√≥dulos.
- **Consistencia de Datos del Cliente:** Si un cliente actualiza sus datos en LCo, los snapshots en `Order` y `OrderItem` aseguran que los datos hist√≥ricos de pedidos LC se mantienen intactos.

---

**La Sinergia Estrat√©gica:**

La integraci√≥n de **LoyalPyME Camarero (LC)** con **LoyalPyME Core (LCo)** no es solo una suma de funcionalidades, sino una **multiplicaci√≥n de valor**. LC moderniza y agiliza la experiencia de servicio, capturando datos de consumo detallados. LCo utiliza estos datos para construir programas de lealtad que incentivan la recurrencia, aumentan el valor de vida del cliente y fortalecen la relaci√≥n.



// ====== [5] LOYALPYME_MODULE_INTEGRATION_WORKFLOW.md ======
# LoyalPyME: Fidelizaci√≥n y Servicio, ¬°Una Alianza Estrat√©gica para tu Negocio! ü§ùüåüüçΩÔ∏è

**√öltima Actualizaci√≥n:** 28 de Mayo de 2025 (Refleja el rol del camarero en el ciclo de pedido LC y su impacto en el futuro trigger de integraci√≥n con LCo)

Cuando un negocio decide activar tanto el m√≥dulo de fidelizaci√≥n **LoyalPyME Core (LCo)** para la gesti√≥n de la lealtad de sus clientes, como el m√≥dulo de operativa de servicio **LoyalPyME Camarero (LC)** para digitalizar la experiencia en el local, se desbloquea un potencial extraordinario. La integraci√≥n fluida y pensada entre ambos m√≥dulos crea una experiencia de cliente superior, cohesiva y gratificante, al mismo tiempo que proporciona al negocio herramientas m√°s potentes para la gesti√≥n, el an√°lisis y el crecimiento.

Este documento detalla los puntos de contacto, las sinergias y los flujos de trabajo espec√≠ficos que surgen cuando LCo y LC operan conjuntamente, considerando el ciclo completo del pedido en LC, incluyendo la intervenci√≥n del personal (KDS y Camarero).

---

## ‚ú® **I. La Experiencia del Cliente Potenciada: Pedidos que Suman, Beneficios que Impactan**

Para un cliente que interact√∫a con un establecimiento que ha activado y sincronizado LoyalPyME Core y LoyalPyME Camarero, el recorrido se enriquece, ofreciendo conveniencia operativa y recompensas por su lealtad de manera integrada.

### 1. üì≤ **Acceso a la Carta LC con Identidad LCo (Opcional pero Clave para Beneficios Futuros)**

    *   **Punto de Entrada Principal (LC):** El cliente escanea el QR de mesa (`/m/:businessSlug/:tableIdentifier`), explora la carta, personaliza √≠tems y prepara su pedido. Este flujo es gestionado por `PublicMenuViewPage.tsx`.
    *   **Integraci√≥n Visible de LCo (Opcional, configurable por el negocio):**
        *   En la interfaz de la carta LC, se pueden presentar opciones para "Iniciar Sesi√≥n" (si ya tiene cuenta LCo en ese negocio) o "Registrarse" (para crear una nueva cuenta LCo).
        *   **Objetivo:** Asociar un `customerId` de LCo al `Order` que se cree en LC.
        *   **Incentivo:** Mensajes como "¬øYa eres miembro? ¬°Inicia sesi√≥n para que este pedido sume a tus beneficios!" o "Reg√≠strate y este pedido podr√≠a ayudarte a alcanzar tu primer nivel."
    *   _(La UI para esta promoci√≥n de LCo en LC es una mejora futura; la funcionalidad de asociar `customerId` al `Order` si el cliente se loguea por otros medios (ej. desde dashboard LCo y luego va a la carta) ya est√° implementada en el backend de creaci√≥n de `Order` LC)._

### 2. üí≥ **Proceso de Identificaci√≥n LCo Durante el Flujo de Pedido LC**

    *   **Flujo de Login/Registro (Idealmente No Intrusivo):** Si se implementa el punto anterior, al seleccionar "Iniciar Sesi√≥n" o "Registrarse" desde LC, se usar√≠an modales o vistas superpuestas para los formularios de LCo, manteniendo al cliente en el contexto del pedido.
    *   **Sincronizaci√≥n de Sesi√≥n:** Tras una autenticaci√≥n/registro exitoso, el frontend (ej. `PublicMenuViewPage.tsx` o un contexto global) almacena el `customerId` y token JWT de LCo.
    *   El cliente finaliza su pedido LC (o a√±ade √≠tems) como un usuario LCo identificado.
    *   _(La l√≥gica de login/registro de LCo es funcional. Su integraci√≥n visual directa en el flujo de pedido LC es una mejora de UX futura)._

### 3. üõçÔ∏è **Env√≠o de Pedido LC (Nuevo o Adici√≥n) y Asociaci√≥n al Cliente LCo**

    *   El cliente configura su pedido en la interfaz LC y procede al env√≠o.
    *   **Payload del Pedido LC:** Si el cliente se identific√≥ con LCo, el `customerId` se incluye en el `CreateOrderPayloadDto` (o en el DTO de "A√±adir √çtems").
    *   **Procesamiento Backend (LC):** El servicio `public/order.service.ts` asocia este `customerId` al campo `Order.customerLCoId`. Este enlace es fundamental para la integraci√≥n.
    *   _(Esta asociaci√≥n ya est√° implementada en el backend de creaci√≥n de `Order` LC)._

### 4. üíØ **[FUTURO - POST-MVP LC COMPLETO] Acumulaci√≥n Autom√°tica de Puntos LCo por Consumo en LC (Post-Pago)**

    *   **Evento Disparador Clave:** La acumulaci√≥n de puntos LCo se producir√° cuando un `Order` del M√≥dulo Camarero, que tiene un `customerLCoId` asociado, cambie su `OrderStatus` a **`PAID`**.
    *   **¬øQui√©n marca el pedido como `PAID`?**
        1.  **Camarero (Flujo Actual en Desarrollo):** Desde su interfaz de gesti√≥n de mesas/pedidos (a√∫n por implementar), el camarero, despu√©s de que el cliente haya pagado f√≠sicamente (efectivo, tarjeta externa), marcar√° el/los `Order`(s) correspondientes como `PAID`.
        2.  **(Futuro) Sistema de TPV Integrado:** Si se desarrolla un TPV LoyalPyME o se integra con uno existente, el cierre y pago de la cuenta en el TPV actualizar√≠a el `Order.status` a `PAID`.
        3.  **(Futuro Muy Avanzado) Pago Online por Cliente:** Si se implementa pago online directamente en la app/vista web del cliente LC, un pago exitoso a trav√©s de la pasarela cambiar√≠a el `Order.status` a `PAID`.
    *   **L√≥gica de Backend para la Integraci√≥n LCo-LC (a implementar cuando el estado `PAID` sea gestionable):**
        1.  **Detecci√≥n del Evento:** Un listener de eventos de cambio de estado en `Order` o una l√≥gica dentro del servicio que actualiza el `Order.status` a `PAID`.
        2.  **Verificaci√≥n:** Comprobar que `Order.customerLCoId` no es nulo.
        3.  **C√°lculo de Puntos:**
            *   Obtener `Order.finalAmount`.
            *   Consultar `Business.pointsPerEuro` (o `Business.pointsPerEuroCamarero` si se diferencia).
            *   Aplicar multiplicadores de puntos del `Tier` actual del cliente LCo (obtenido de `User.currentTier.benefits`).
            *   Calcular puntos LCo (`Math.floor(...)`).
        4.  **Actualizaci√≥n de Datos en LCo (Transaccional o como efecto secundario robusto):**
            *   Crear registro en `ActivityLog` (LCo): `type: POINTS_EARNED_ORDER_LC`, `pointsChanged: +XX`, `description: "Puntos por pedido LC #P-XXXXXX"`, `relatedOrderId: order.id`.
            *   Actualizar `User.points` (LCo).
            *   Actualizar `User.lastActivityAt` (LCo).
            *   Incrementar `User.totalSpend` y `User.totalVisits` (LCo).
            *   Disparar `updateUserTier(customerLCoId)` para recalcular el nivel del cliente en LCo.
    *   **Notificaci√≥n al Cliente (LCo):** Email o notificaci√≥n push (si hay app) informando los puntos ganados.

### 5. üåü **[FUTURO - POST-MVP LC COMPLETO E INTEGRACI√ìN B√ÅSICA LCo] Aplicaci√≥n de Beneficios de Nivel LCo y Canje de Recompensas LCo en Pedidos LC**

    *   Esta es una funcionalidad avanzada que se construir√° sobre la acumulaci√≥n de puntos.
    *   **Visualizaci√≥n de Beneficios LCo en Interfaz LC (`PublicMenuViewPage.tsx`):**
        *   Si el cliente est√° identificado con LCo, la UI de LC podr√≠a mostrar sutilmente los beneficios de su nivel aplicables a pedidos LC (ej. "¬°Nivel Oro! Disfruta de un 10% de descuento.").
    *   **Aplicaci√≥n de Descuentos de Nivel LCo:**
        *   **Configuraci√≥n LCo:** `TierBenefit` de tipo `PERCENTAGE_DISCOUNT` o `FIXED_AMOUNT_DISCOUNT` marcado como "Aplicable en M√≥dulo Camarero".
        *   **L√≥gica LC (Backend/Frontend):** Al calcular el total del pedido LC, si el cliente tiene un descuento de nivel aplicable, √©ste se resta del `Order.totalAmount`, actualizando `Order.discountAmount` y `Order.finalAmount`. Visible en carrito y confirmaci√≥n.
    *   **Canje de Recompensas LCo (ej. "Producto Gratis", "Descuento X‚Ç¨") en Flujo LC:**
        *   **Configuraci√≥n LCo:** `Reward` marcada como "Canjeable en M√≥dulo Camarero". Mapeo de "Producto Gratis" a `MenuItem.id` de LC.
        *   **Interfaz Cliente LC (`ShoppingCartModal.tsx`):** Secci√≥n "Aplicar Recompensas LoyalPyME" para que el cliente seleccione una recompensa LCo canjeable.
        *   **L√≥gica LC:** Si es producto gratis, se a√±ade al carrito LC con precio 0. Si es descuento, se aplica al total.
        *   **Sincronizaci√≥n Backend:** El pedido LC enviado incluye `appliedLcoRewardId`. El backend de LC se comunica con LCo para marcar la `Reward` como `REDEEMED` y crear el `ActivityLog` en LCo.
    *   _(Tarea D7 en `DEVELOPMENT_PLAN.md`)._

### 6. üìú **[PARCIALMENTE IMPLEMENTADO - SE COMPLETAR√Å CON INTEGRACI√ìN] Historial de Actividad Unificado (Visi√≥n Cliente en Dashboard LCo)**

    *   El `ActivityLog` del cliente en su dashboard LCo (`ActivityTab.tsx`) ser√° la fuente central.
    *   **Actualmente Muestra:** `POINTS_EARNED_QR`, `POINTS_REDEEMED_REWARD` (canje desde dashboard LCo), `GIFT_REDEEMED`, `POINTS_ADJUSTED_ADMIN`.
    *   **Futuras Entradas de Integraci√≥n LC+LCo:**
        *   `POINTS_EARNED_ORDER_LC`: Detallando puntos ganados por pedidos LC.
        *   `REWARD_REDEEMED_IN_LC_ORDER`: Detallando recompensas LCo canjeadas en pedidos LC.

---

## ‚öôÔ∏è **II. La Visi√≥n del Negocio (`BUSINESS_ADMIN`): Gesti√≥n Integrada, Datos Enriquecidos y Sinergias**

### 1. üîó **[PENDIENTE] Configuraci√≥n de la Integraci√≥n LCo <-> LC (Panel Admin)**

    *   **Ubicaci√≥n:** Nueva secci√≥n en el panel de admin "Configuraci√≥n de M√≥dulos" o sub-secciones en LCo/LC.
    *   **Par√°metros Configurables por el `BUSINESS_ADMIN`:**
        *   **Acumulaci√≥n de Puntos:**
            *   Interruptor: "Habilitar/Deshabilitar Acumulaci√≥n de Puntos LCo desde Pedidos LC".
            *   Campo (opcional): "Ratio de Puntos Espec√≠fico para Pedidos LC" (si es diferente de `Business.pointsPerEuro` global).
            *   (Informativo, no editable por admin) "Estado del Pedido LC que Otorga Puntos": Se fijar√° a `PAID`.
        *   **Canje de Recompensas/Beneficios LCo en LC (Avanzado):**
            *   Interruptor: "Habilitar/Deshabilitar Canje de Recompensas/Beneficios LCo en el M√≥dulo Camarero".
            *   **Mapeo de Recompensas LCo:** UI para que el admin marque qu√© `Reward`s de LCo son "Canjeables en M√≥dulo Camarero". Si la recompensa es tipo "Producto Gratis", permitir seleccionar el `MenuItem.id` (o categor√≠a/tag) de LC al que corresponde.
            *   **Configuraci√≥n de Beneficios de Nivel LCo:** UI para que el admin marque qu√© `TierBenefit`s (ej. descuentos porcentuales) son "Aplicables en M√≥dulo Camarero" y si se aplican autom√°ticamente o requieren una acci√≥n del cliente en la UI de LC.

### 2. üìä **[PENDIENTE - POST-MVP LC COMPLETO E INTEGRACI√ìN] Visi√≥n 360¬∫ del Cliente y Reportes Combinados**

    *   **Perfil de Cliente Unificado (Admin LCo - `AdminCustomerManagementPage`):**
        *   Al ver un cliente LCo, mostrar una nueva pesta√±a/secci√≥n "Actividad en M√≥dulo Camarero":
            *   Resumen: N¬∫ total de pedidos LC, gasto total LC, fecha √∫ltimo pedido LC.
            *   (Opcional) Lista de los N √∫ltimos pedidos LC con enlace a sus detalles (si se implementa un panel de admin para ver `Order`s individuales de LC).
    *   **Sincronizaci√≥n de M√©tricas Clave LCo:** `User.totalSpend` y `User.totalVisits` (LCo) se actualizar√°n no solo por QR LCo, sino tambi√©n por `Order`s LC pagados y asociados al cliente.
    *   **Reportes de LCo Enriquecidos:**
        *   Posibilidad de segmentar/filtrar informes LCo (clientes valiosos, actividad de puntos) por origen de la actividad (QR LCo vs. Pedido LC).
        *   An√°lisis del impacto de LC en la progresi√≥n de niveles LCo.
    *   **Reportes de LC con Perspectiva LCo:**
        *   Informes de LC (ventas por √≠tem, ticket medio) podr√≠an incluir: % de ventas de clientes LCo, distribuci√≥n de ventas por nivel LCo, impacto de descuentos/recompensas LCo en totales LC.

### 3. üì¢ **[PENDIENTE - POST-MVP LC COMPLETO E INTEGRACI√ìN] Estrategias de Marketing y Promoci√≥n Cruzada Mejoradas**

    *   **Incentivos Dirigidos:** Crear Recompensas LCo espec√≠ficas (ej. "Doble Puntos en tu primer pedido LC") o Beneficios de Nivel LCo atractivos para usar con LC.
    *   **Promoci√≥n de LCo dentro de la Experiencia LC:** Mensajes/banners configurables por el admin en `PublicMenuViewPage` para incentivar registro/login en LCo.
    *   **Campa√±as Segmentadas:** Usar datos combinados LCo+LC para enviar comunicaciones m√°s efectivas.

### 4. ‚öôÔ∏è **Operativa y Sincronizaci√≥n de Estados Clave (Flujo Backend - Consideraciones Importantes)**

    *   **Estado `PAID` en `Order` LC (CRUCIAL):** El mecanismo para marcar un `Order` LC como `PAID` (sea por camarero, TPV futuro, o pago online futuro) debe ser extremadamente robusto y preciso, ya que es el disparador principal para la integraci√≥n con LCo.
        *   **Actualmente:** Esta funcionalidad depende de la implementaci√≥n de la interfaz de camarero (Bloque B1 del `DEVELOPMENT_PLAN.md`).
    *   **Transaccionalidad en Canjes LCo en Pedidos LC:** Si se implementa el canje de recompensas/beneficios LCo en el flujo LC, la comunicaci√≥n entre los servicios de LC y LCo para marcar la recompensa como canjeada y ajustar datos en LCo debe ser transaccional o, como m√≠nimo, idempotente con mecanismos de reintento/compensaci√≥n para asegurar la consistencia de datos entre m√≥dulos.
    *   **Consistencia de Datos del Cliente:** Si un cliente actualiza sus datos personales en LCo (a trav√©s de la futura `ProfileTab.tsx`), y ese cliente est√° asociado a `Order`s en LC, se debe considerar c√≥mo se refleja esta informaci√≥n si se visualizan datos hist√≥ricos de pedidos LC (los snapshots en `Order` y `OrderItem` son clave para esto).

---

**La Sinergia Estrat√©gica:**

La integraci√≥n de **LoyalPyME Camarero (LC)** con **LoyalPyME Core (LCo)** no es solo una suma de funcionalidades, sino una **multiplicaci√≥n de valor** para el negocio y sus clientes. LC moderniza y agiliza la experiencia de servicio en el local, capturando datos de consumo y comportamiento detallados. LCo utiliza estos datos (y los datos de otras interacciones de fidelizaci√≥n) para construir programas de lealtad personalizados y efectivos que incentivan la recurrencia, aumentan el valor de vida del cliente y fortalecen la relaci√≥n.

Esta combinaci√≥n permitir√° a los negocios:

- **Mejorar la satisfacci√≥n del cliente:** Con un servicio m√°s r√°pido, personalizado, aut√≥nomo y con opciones de recompensa integradas y visibles.
- **Aumentar la frecuencia de visitas y el gasto promedio:** Mediante incentivos de lealtad contextuales (ej. "Gana puntos con este pedido") y la aplicaci√≥n directa de beneficios en el punto de servicio.
- **Obtener una comprensi√≥n 360¬∫ del cliente:** Al unificar datos de servicio en el local (qu√©, cu√°ndo y c√≥mo piden) con datos de su actividad en el programa de fidelizaci√≥n (nivel, puntos, recompensas canjeadas, interacciones con QR).
- **Optimizar la operativa del personal:** El flujo digital reduce la carga de trabajo manual en la toma de pedidos (cliente), comunicaci√≥n con cocina/barra (KDS), y (futuramente) aplicaci√≥n de promociones de lealtad o cobros.
- **Diferenciarse de la competencia:** Ofreciendo una experiencia digital integrada, moderna, eficiente y que premia la fidelidad de forma transparente y atractiva.

El √©xito de esta integraci√≥n reside en una **comunicaci√≥n l√≥gica, robusta y potencialmente transaccional** entre los datos y procesos de ambos m√≥dulos. Esto implica una arquitectura backend bien dise√±ada (servicios cohesivos, posible uso de eventos o colas de mensajes para desacoplar procesos cr√≠ticos como la asignaci√≥n de puntos post-pago) y una presentaci√≥n de una experiencia de usuario cohesiva y sin fricciones en el frontend.



// ====== [6] PROJECT_STATUS.md ======
LoyalPyME - Estado del Proyecto y Decisiones Clave
Versi√≥n Actual: 1.22.0 (LC+LCo: Sistema de Recompensas Avanzado y Canje en Carrito COMPLETADOS Y VALIDADOS)
Fecha de √öltima Actualizaci√≥n: 26 de Junio de 2025

1. Resumen General del Proyecto LoyalPyME üéØ
   Concepto: LoyalPyME es una plataforma web integral, dise√±ada como una soluci√≥n Software as a Service (SaaS) modular, orientada a Peque√±as y Medianas Empresas (PyMEs). Su arquitectura full-stack se basa en tecnolog√≠as modernas:

Frontend: React con TypeScript, utilizando Vite como herramienta de construcci√≥n y Mantine UI para la biblioteca de componentes, asegurando una experiencia de usuario responsive y moderna. La navegaci√≥n se gestiona con React Router DOM y la internacionalizaci√≥n (i18n) con

i18next.

Backend: Node.js con Express.js y TypeScript, interactuando con una base de datos PostgreSQL a trav√©s del ORM Prisma. La autenticaci√≥n se maneja con JSON Web Tokens (JWT).

La plataforma ofrece dos m√≥dulos principales que los negocios pueden activar seg√∫n sus necesidades:

LoyalPyME Core (LCo): Un sistema de fidelizaci√≥n digital robusto y completo. [Funcionalmente Completo y Mejorado].

Caracter√≠sticas Clave LCo: Gesti√≥n integral de clientes (con roles), sistema de acumulaci√≥n de puntos (configurable por negocio), niveles de fidelizaci√≥n (tiers) con beneficios personalizables, y un cat√°logo de recompensas avanzado que permite configurar productos gratis (vinculados a la carta de LC), descuentos flexibles (fijos o porcentuales) y reglas de negocio como l√≠mites de uso o validez.

LoyalPyME Camarero (LC): Un m√≥dulo avanzado, [FLUJO DE PEDIDO Y CANJE DE RECOMPENSAS COMPLETADO], dise√±ado para digitalizar y optimizar la operativa de servicio en el sector de la hosteler√≠a.

Funcionalidades Clave LC Implementadas y Validadas:

Gesti√≥n Completa de Carta Digital (Admin): Interfaz administrativa para crear, editar y organizar la carta, √≠tems y modificadores complejos.

Visualizaci√≥n de Carta y Toma de Pedidos por Cliente (con Modificadores): Interfaz interactiva para explorar la carta, personalizar √≠tems con modificadores y a√±adir a un carrito de compra persistente.

[NUEVO] Canje de Recompensas Integrado: Los clientes logueados pueden ver y aplicar sus recompensas de puntos (productos gratis o descuentos) directamente desde el carrito de compra (ShoppingCartModal.tsx), recalculando el total del pedido en tiempo real.

Gesti√≥n de Pedido Activo por Cliente: La PublicMenuViewPage detecta pedidos activos y adapta la UI, permitiendo a√±adir nuevos √≠tems a un pedido existente.

Visualizaci√≥n del Estado del Pedido por Cliente: La OrderStatusPage muestra el estado del pedido y de cada √≠tem en tiempo real (con polling).

Ciclo KDS (Cocina/Barra): API e Interfaz de KDS funcionales para que el personal vea y actualice el estado de preparaci√≥n de los √≠tems (PENDING_KDS -> PREPARING -> READY).

Ciclo de Servicio del Camarero: API e Interfaz para que el camarero vea los √≠tems listos para recoger (READY) y los marque como SERVED.

Ciclo Financiero Completo: API e Interfaces para que el cliente pida la cuenta y para que el camarero marque el pedido como PAID, lo cual libera la mesa y asigna los puntos de fidelidad LCo correspondientes.

Componentes Tecnol√≥gicos Clave Detallados:

Backend: Node.js, Express.js, TypeScript, Prisma ORM (v6+), PostgreSQL, JWT, bcryptjs, Cloudinary SDK, Multer, Swagger/OpenAPI, node-cron, class-validator y class-transformer.

Frontend: React (v19+), TypeScript, Vite (v5+), Mantine UI (v7+), Axios, React Router DOM (v6+), i18next, react-i18next, html5-qrcode, react-image-crop.

Testing: Vitest.

Licencia: Software Propietario. Copyright (c) 2024-2025 Olivier Hottelet.

√Åreas Funcionales Principales de la Plataforma (Detallado):

Panel Super Admin (/superadmin): Gesti√≥n global de negocios y activaci√≥n/desactivaci√≥n de m√≥dulos.

Panel de Administraci√≥n del Negocio (/admin/dashboard/\*): Interfaz para el rol BUSINESS_ADMIN.

LCo (si isLoyaltyCoreActive): Gesti√≥n de clientes, recompensas avanzadas (con tipos y reglas), niveles/tiers y configuraci√≥n del programa de fidelizaci√≥n.

LC (si isCamareroActive): Gesti√≥n de la carta digital, mesas e interfaz de camarero para recogida de √≠tems.

Interfaz KDS (M√≥dulo LC - /admin/kds): Visualizaci√≥n y gesti√≥n de la preparaci√≥n de comandas.

Portal de Cliente Final (LCo - /customer/dashboard): Dashboard para visualizar puntos, nivel, historial y canjear recompensas.

Interfaces P√∫blicas del M√≥dulo Camarero (LC):

Carta Digital P√∫blica (/m/:businessSlug/:tableIdentifier?): Permite a los clientes explorar el men√∫, personalizar √≠tems, a√±adir al carrito y enviar la comanda.

Visualizaci√≥n Estado del Pedido Cliente (/order-status/:orderId): Muestra el estado del pedido en tiempo real.

2. Estado Actual Detallado (Hitos Completados y En Progreso - v1.22.0) üìù
   Fase 1 (N√∫cleo Operativo LCo): [COMPLETADO]

Autenticaci√≥n completa, gesti√≥n de clientes, sistema de puntos por QR y l√≥gica de tiers autom√°tica.

Fase 2 (Fundamentos Multi-M√≥dulo y Panel Super Admin): [COMPLETADO]

Panel Super Admin, middleware de activaci√≥n de m√≥dulos y payload de perfil de usuario enriquecido.

Fase 3 (M√≥dulo Camarero - Ciclo de Pedido Completo): [COMPLETADO Y VALIDADO]

Fundamentos del backend (modelos y API de gesti√≥n de carta).

Frontend de admin para gesti√≥n de la carta digital.

Flujo completo de creaci√≥n de pedido por parte del cliente, incluyendo la adici√≥n de √≠tems a un pedido existente.

Ciclos completos de KDS y Servicio de Camarero (recogida y entrega).

Ciclo financiero completo (solicitud de cuenta y marcado como pagado).

Fase 4 (Integraci√≥n Avanzada LCo + LC): [COMPLETADO Y VALIDADO]

Modelo de Recompensas Extendido: El modelo Reward en la base de datos se ha ampliado para incluir RewardType, DiscountType, discountValue, linkedMenuItemId y reglas de negocio adicionales.

Gesti√≥n de Recompensas Din√°micas (Admin): Se ha implementado el nuevo formulario (RewardForm.tsx) que permite al BUSINESS_ADMIN crear los tres tipos de recompensas (producto gratis, descuento en √≠tem, descuento total). Se ha a√±adido el endpoint

GET /api/camarero/admin/menu/items/all para poblar el selector de productos.

Canje Integrado en el Carrito (Cliente): El ShoppingCartModal.tsx ahora muestra las recompensas canjeables a los usuarios logueados y permite su aplicaci√≥n directa en el pedido, recalculando el total y a√±adiendo √≠tems gratis con precio 0.

Procesamiento Transaccional (Backend): El servicio order-creation.service.ts ahora maneja un payload enriquecido con redeemedRewardId (para √≠tems) y appliedLcoRewardId (para el total), validando la recompensa y debitando los puntos del cliente de forma at√≥mica junto a la creaci√≥n del pedido.

3. Key Concepts & Design Decisions üîë

Arquitectura Modular y Activaci√≥n por Negocio: La plataforma es multi-tenant, con funcionalidades que se habilitan o deshabilitan a nivel de negocio.

Estructura de Datos Detallada para M√≥dulo Camarero (LC): Uso de snapshots de precios y nombres en OrderItem para garantizar la integridad hist√≥rica de los pedidos.

Flujo de Pedido LC - Cliente (Detallado): Proceso orquestado mediante hooks personalizados (usePublicMenuData, useMenuItemConfigurator, usePublicOrderCart, useActiveOrderState) que gestionan la l√≥gica de forma desacoplada y eficiente.

Flujos As√≠ncronos (KDS y Camarero): La comunicaci√≥n entre el cliente, la cocina y el personal de sala se gestiona de forma as√≠ncrona mediante cambios de estado y polling en las interfaces correspondientes.

Internacionalizaci√≥n (i18n): Estrategia dual con archivos JSON para UI est√°tica y campos duplicados en la BD (ej. name_es, name_en) para contenido din√°mico.

Arquitectura de Backend y Frontend (Refactorizada): Estructura limpia y escalable con rutas centralizadas, middlewares espec√≠ficos y una fuerte dependencia de hooks personalizados en el frontend para encapsular la l√≥gica.

4. Lecciones Aprendidas & Troubleshooting Clave üí°

Sincronizaci√≥n de Tipos: Esencial mantener los tipos de Prisma, backend y frontend sincronizados, especialmente tras migraciones de la base de datos (npx prisma generate).

Deserializaci√≥n de DTOs Anidados: Solucionado el bug cr√≠tico de modificadores usando plainToInstance en el backend para asegurar que class-transformer procese correctamente los payloads complejos.

Manejo de Transacciones Prisma: Clave para operaciones at√≥micas como la creaci√≥n de pedidos con canje de recompensas, garantizando que todas las operaciones (crear pedido, debitar puntos, crear log) se completen o fallen juntas.

Sincronizaci√≥n de Documentaci√≥n: Mantener los archivos .md actualizados con el c√≥digo es un paso obligatorio para evitar confusiones.

5. Pr√≥ximos Pasos Inmediatos / Prioridades ‚è≥üìå
   Con la integraci√≥n del canje de recompensas finalizada, el enfoque principal de desarrollo se mantiene en las funcionalidades avanzadas para el M√≥dulo Camarero.

‚≠ê LC - Dividir la Cuenta (Split Bill): [CR√çTICO - SIGUIENTE BLOQUE FUNDAMENTAL]

Objetivo: Implementar la capacidad para que un camarero divida la cuenta de un pedido pendiente de pago, ya sea por √≠tems o en partes iguales.

Backend: Requerir√° un dise√±o de datos para pagos parciales (ej. nuevo modelo PartialPayment) y un servicio (SplitBillService) que maneje la l√≥gica de divisi√≥n y actualizaci√≥n del estado del pedido.

Frontend (Camarero): Requerir√° una nueva interfaz o modal para que el camarero pueda asignar √≠tems a diferentes "cestas" de pago y procesarlas individualmente.

‚≠ê LC - Gesti√≥n de Personal (PINs y Permisos): [ALTA PRIORIDAD - Despu√©s de Split Bill]

Objetivo: Crear un sistema para que el BUSINESS_ADMIN pueda gestionar a su personal y asignarles PINs para un inicio de sesi√≥n r√°pido en las interfaces de servicio.

‚≠ê LC - Mejoras en la Interfaz de Camarero (TPV): [MEDIA PRIORIDAD]

Objetivo: Unificar y mejorar las vistas del camarero hacia un TPV (Terminal Punto de Venta) m√°s cohesivo.

6. Informaci√≥n Adicional ‚ÑπÔ∏è
   Licencia: Software Propietario. Copyright (c) 2024-2025 Olivier Hottelet. Consulta

LICENSE.md para m√°s detalles.

Flujos de Trabajo Detallados: Para una comprensi√≥n profunda de c√≥mo operan los m√≥dulos y su integraci√≥n, consultar: LOYALPYME_CORE_WORKFLOW.md, LOYALPYME_CAMARERO_WORKFLOW.md y MODULE_INTEGRATION_WORKFLOW.md.



// ====== [7] README.md ======
LoyalPyME üá™üá∏ (v1.22.0)

LoyalPyME es una plataforma web integral y modular, desarrollada con un stack Frontend React (TypeScript, Mantine UI, Vite) y Backend Node.js (TypeScript, Express, Prisma, PostgreSQL), dise√±ada espec√≠ficamente para Peque√±as y Medianas Empresas (PyMEs). La plataforma se estructura en m√≥dulos activables individualmente por cada negocio cliente, permitiendo una soluci√≥n a medida y adaptada a sus necesidades operativas y de marketing.

‚≠ê LoyalPyME Core (LCo) - M√≥dulo de Fidelizaci√≥n [Estable y Funcional]:
Un sistema robusto y completo para la gesti√≥n de programas de lealtad digitales.

Gesti√≥n de Clientes: Administraci√≥n detallada de clientes, incluyendo su historial de puntos, nivel de fidelizaci√≥n y actividad.

Sistema de Puntos: Configuraci√≥n de ratio de puntos por gasto y generaci√≥n de QR para acumulaci√≥n en punto de venta f√≠sico.

Niveles de Fidelizaci√≥n (Tiers): Creaci√≥n de m√∫ltiples niveles con umbrales personalizables (basados en gasto, visitas o puntos) y asignaci√≥n de beneficios exclusivos por nivel.

Cat√°logo de Recompensas Avanzado: Gesti√≥n de un cat√°logo de recompensas din√°micas que pueden ser canjeadas por puntos. Permite configurar

productos gratis (vinculados directamente a la carta del M√≥dulo Camarero), descuentos flexibles (de importe fijo o porcentuales, aplicables a √≠tems o al total del pedido) y reglas de negocio como fechas de validez o l√≠mites de uso.

Panel de Cliente Interactivo: Un dashboard personalizado donde los clientes consultan su saldo, progreso de nivel, canjean beneficios y revisan su historial completo de transacciones.

üöÄ LoyalPyME Camarero (LC) - M√≥dulo de Hosteler√≠a [Ciclo de Pedido y Canje Integrado Validado]:
Un m√≥dulo avanzado enfocado en la digitalizaci√≥n y optimizaci√≥n integral del servicio en el sector hostelero (restaurantes, bares, cafeter√≠as), mejorando la eficiencia operativa y la experiencia del cliente.

Funcionalidad Actual Clave:

Gesti√≥n Completa de Carta Digital: Interfaz administrativa para crear y organizar categor√≠as, productos y modificadores complejos con soporte para m√∫ltiples idiomas e im√°genes.

Flujo de Pedido Digital por Cliente: Los clientes acceden a la carta, personalizan √≠tems con modificadores y realizan su pedido directamente desde el m√≥vil. El sistema gestiona de forma inteligente la creaci√≥n de nuevos pedidos o la adici√≥n de √≠tems a uno ya existente.

Canje de Recompensas Integrado en el Carrito: Los clientes que han iniciado sesi√≥n pueden ver y aplicar sus recompensas de puntos (productos gratis o descuentos) directamente desde el carrito de compra mientras realizan un pedido, viendo el total actualizado en tiempo real.

Sincronizaci√≥n con Cocina (KDS): Las comandas se muestran en tiempo real en una pantalla de cocina (Kitchen Display System), donde el personal actualiza el estado de preparaci√≥n de cada √≠tem.

Ciclo de Servicio y Pago Completo: Una interfaz para camareros permite gestionar la entrega de los platos listos y registrar el pago final de los pedidos. Al marcar un pedido como pagado, se libera la mesa y se asignan autom√°ticamente los puntos de fidelidad (si LCo est√° activo), cerrando el ciclo de servicio y fidelizaci√≥n.

La plataforma LoyalPyME est√° dise√±ada con un enfoque en la

mantenibilidad, escalabilidad y adaptabilidad, buscando ser el socio tecnol√≥gico que impulse la eficiencia operativa y el crecimiento sostenible de las PyMEs.

Visi√≥n y Prop√≥sito ‚ú®
LoyalPyME aspira a ser el

aliado tecnol√≥gico integral de las Peque√±as y Medianas Empresas (PyMEs), proporcionando herramientas digitales sofisticadas pero intuitivas, integradas en una √∫nica plataforma modular que se adapta a las necesidades espec√≠ficas de cada negocio.

Con

LoyalPyME Core (LCo), buscamos empoderar a las empresas para que puedan cultivar relaciones m√°s profundas y duraderas con sus clientes, fomentando la lealtad a trav√©s de programas de recompensas personalizados y gratificantes.

Con el m√≥dulo

LoyalPyME Camarero (LC), nuestra visi√≥n es transformar y modernizar la operativa en el sector de la hosteler√≠a. Queremos que los negocios puedan:

Modernizar su servicio: Ofreciendo una experiencia de pedido digital √°gil y sin fricciones.

Reducir errores manuales y agilizar la comunicaci√≥n interna a trav√©s del KDS.

Mejorar significativamente la experiencia del cliente final, permiti√©ndole pedir y personalizar con total control.

Obtener datos operativos valiosos para la toma de decisiones estrat√©gicas.

La

sinergia entre ambos m√≥dulos permite que un cliente que pide desde la carta digital gane puntos autom√°ticamente al pagar, creando una experiencia integrada que maximiza la fidelizaci√≥n y enriquece los datos del negocio.

(Para un an√°lisis exhaustivo del estado actual del proyecto, incluyendo la versi√≥n actual, los hitos completados en detalle, las decisiones de dise√±o clave y las lecciones aprendidas, consulta nuestro PROJECT_STATUS.md. La hoja de ruta completa, el backlog de funcionalidades futuras para ambos m√≥dulos, y la visi√≥n a largo plazo se encuentran detallados en DEVELOPMENT_PLAN.md).

Caracter√≠sticas Principales Implementadas ‚úÖ
Plataforma Base y Gesti√≥n Multi-M√≥dulo:

Panel Super Admin: Interfaz dedicada (/superadmin) para la administraci√≥n global de negocios y la activaci√≥n/desactivaci√≥n individual de los m√≥dulos LCo y LC para cada uno.

Control de Acceso Basado en M√≥dulos y Roles (RBAC + MBAC): El acceso a las funcionalidades est√° condicionado por el rol del usuario (SUPER_ADMIN, BUSINESS_ADMIN, etc.) y por si el m√≥dulo requerido est√° activo para su negocio.

LoyalPyME Core (LCo) - M√≥dulo de Fidelizaci√≥n [Estable y Funcional]:

Autenticaci√≥n Completa y Segura: Registro de negocios y clientes, login con JWT y reseteo de contrase√±a.

Gesti√≥n Avanzada de Clientes: Panel de admin con listado, filtros, b√∫squeda y acciones individuales y masivas sobre los clientes (ajuste de puntos, cambio de nivel, asignaci√≥n de regalos, etc.).

Sistema de Niveles/Tiers Din√°mico y Configurable: CRUD completo para niveles, sus beneficios y la configuraci√≥n global del sistema de progresi√≥n y descenso.

Gesti√≥n Integral de Recompensas: CRUD para un cat√°logo de recompensas avanzadas (productos gratis, descuentos) con soporte i18n, im√°genes y reglas de negocio.

Panel de Cliente Completo (CustomerDashboardPage.tsx): Un dashboard para que los clientes consulten su estado, canjeen recompensas y revisen su historial de actividad.

M√≥dulo LoyalPyME Camarero (LC) [Ciclo de Pedido y Canje Completo Validado]:

Gesti√≥n de Carta Digital (Admin): CRUD intuitivo para categor√≠as, √≠tems y grupos de modificadores complejos, con soporte i18n e im√°genes.

Flujo de Pedido por Cliente Final:

Visualizaci√≥n y Personalizaci√≥n: El cliente explora la carta, personaliza √≠tems con modificadores y ve el precio din√°micamente.

Carrito de Compra Inteligente (ShoppingCartModal.tsx): Permite revisar el pedido, a√±adir notas y, para usuarios logueados, canjear recompensas de LCo (productos gratis o descuentos) directamente en el pedido.

Env√≠o y Adici√≥n de √çtems: El sistema gestiona inteligentemente la creaci√≥n de nuevos pedidos o la adici√≥n de √≠tems a uno existente.

Visualizaci√≥n del Estado del Pedido (OrderStatusPage.tsx): P√°gina con polling autom√°tico que muestra el estado en tiempo real del pedido y de cada √≠tem.

Kitchen Display System (KDS): Interfaz para cocina/barra que permite visualizar y gestionar el estado de preparaci√≥n de las comandas.

Ciclo de Servicio y Pago Completo (Camarero): Interfaces para que el personal de sala vea los √≠tems listos para recoger (WaiterPickupPage.tsx) y para gestionar y marcar los pedidos como pagados (WaiterOrderManagementPage.tsx), automatizando la asignaci√≥n de puntos LCo.

Estado Actual y Pr√≥ximos Pasos üó∫Ô∏è
La plataforma ha alcanzado la versi√≥n v1.22.0.

LoyalPyME Core (LCo): Estable y completamente funcional, con un sistema de recompensas avanzado.

M√≥dulo Camarero (LC): El ciclo de vida completo de un pedido, incluyendo el canje de recompensas de fidelizaci√≥n, est√° completo y validado.

Arquitectura Multi-M√≥dulo y Panel Super Admin: Implementada y operativa.

El enfoque principal de desarrollo inmediato es a√±adir funcionalidades avanzadas de gesti√≥n al M√≥dulo Camarero (LC):

‚≠ê LC - Dividir la Cuenta (Split Bill):

Objetivo: Permitir al personal de sala dividir una cuenta entre m√∫ltiples clientes.

Posteriormente, se abordar√°n funcionalidades como la gesti√≥n de personal con PINs, mejoras en la interfaz del camarero (TPV) y un sistema de reservas.

Consulta PROJECT_STATUS.md para un an√°lisis detallado.

Revisa

DEVELOPMENT_PLAN.md para la hoja de ruta completa.

Tecnolog√≠as Utilizadas üõ†Ô∏è
Frontend:
React (v19+, Hooks, Context API), TypeScript, Vite (v5+, bundler y servidor de desarrollo HMR), Mantine UI (v7+, biblioteca de componentes y hooks), Axios (cliente HTTP), React Router DOM (v6+, para enrutamiento SPA),

html5-qrcode (para escaneo de c√≥digos QR por el cliente en LCo), react-image-crop (para recorte de im√°genes en interfaces de administraci√≥n), i18next y react-i18next (para internacionalizaci√≥n ES/EN con archivos JSON), zod (para validaci√≥n de formularios, implementaci√≥n progresiva).

Backend:
Node.js (runtime), Express.js (framework web), TypeScript (lenguaje principal), Prisma ORM (v6+, para acceso a base de datos PostgreSQL, gesti√≥n de migraciones y generaci√≥n de cliente tipado), PostgreSQL (sistema de gesti√≥n de base deatos relacional), JSON Web Tokens (JWT) (para autenticaci√≥n stateless),

bcryptjs (para hashing seguro de contrase√±as), Cloudinary SDK (para almacenamiento y gesti√≥n de im√°genes en la nube), Multer (middleware para manejo de subidas de archivos multipart/form-data), Vitest (para testing unitario y de integraci√≥n), Supertest (para testing de API HTTP), Swagger/OpenAPI (swagger-jsdoc, swagger-ui-express) (para documentaci√≥n interactiva de la API RESTful), node-cron (para la ejecuci√≥n de tareas programadas, ej. actualizaci√≥n de tiers en LCo).

Inicio R√°pido (Desarrollo Local) üöÄ
Clonar el Repositorio:

Bash

git clone <URL_DEL_REPOSITORIO_GIT> LoyalPyME
cd LoyalPyME
Configuraci√≥n del Backend (backend/):

Instalar dependencias: yarn install (o npm install).

Configurar Variables de Entorno: Copiar backend/.env.example a backend/.env y rellenar todas las variables.

Base de Datos (PostgreSQL debe estar corriendo):

Crear la base de datos (ej. loyalpymedb).

Desde backend/, ejecutar npx prisma migrate reset.

Ejecutar npx prisma db seed para poblar con datos de demostraci√≥n.

Ejecutar npx ts-node ./scripts/create-superadmin.ts para crear el Super Administrador.

Ejecutar el Backend (desde backend/, en dos terminales separadas):

yarn dev:build (o npx tsc --watch): Compilaci√≥n continua de TypeScript.

yarn dev:run (o npx nodemon dist/index.js): Iniciar servidor Node.js con Nodemon.

Configuraci√≥n del Frontend (frontend/):

Instalar dependencias: yarn install (o npm install).

Ejecutar el Frontend (desde frontend/): yarn dev.

Acceso a las Aplicaciones (URLs por defecto):

Carta P√∫blica: https://localhost:5173/m/restaurante-demo-loyalpyme

Login / Dashboards: https://localhost:5173

Documentaci√≥n API (Swagger): http://localhost:3000/api-docs

¬°Importante! Para instrucciones exhaustivas y detalladas, consulta la gu√≠a SETUP_GUIDE.md. Para soluciones a problemas comunes, revisa la

TROUBLESHOOTING_GUIDE.md.

Contribuciones ü§ù
Este proyecto es software propietario desarrollado por Olivier Hottelet. No se aceptan contribuciones externas directas en este momento. Si se detectan errores o se tienen sugerencias de mejora, pueden ser comunicadas al propietario. Si el repositorio fuera p√∫blico y permitiera la creaci√≥n de "Issues" en la plataforma de hosting de c√≥digo (ej. GitHub, GitLab), esa ser√≠a la v√≠a formal para reportar bugs o proponer nuevas funcionalidades.

Licencia üìú
Este proyecto es software propietario.
Copyright (c) 2024-2025 Olivier Hottelet. Todos los derechos reservados.

El uso, copia, reproducci√≥n, distribuci√≥n, modificaci√≥n, descompilaci√≥n, ingenier√≠a inversa o cualquier otra forma de explotaci√≥n de este software o su c√≥digo fuente, en su totalidad o en parte, est√° estrictamente prohibido sin el permiso previo, expl√≠cito y por escrito del propietario de los derechos de autor. Este software se considera informaci√≥n confidencial y un secreto comercial.

Para m√°s detalles sobre los t√©rminos de la licencia, consulta el archivo

LICENSE.md en el directorio ra√≠z del proyecto.

Contacto üìß
Para consultas sobre el proyecto, licencias, adquisici√≥n, o cualquier otro asunto relacionado:

Olivier Hottelet

olivierhottelet1980@gmail.com



// ====== [8] SETUP_GUIDE.md ======
# LoyalPyME - Gu√≠a Completa de Instalaci√≥n y Ejecuci√≥n Local

**√öltima Actualizaci√≥n:** 09 de Mayo de 2025

Esta gu√≠a describe los pasos necesarios para instalar, configurar y ejecutar el proyecto LoyalPyME en un entorno de desarrollo local. Es crucial seguir los pasos en orden para asegurar una configuraci√≥n correcta.

---

## 1. Prerrequisitos

Antes de empezar, aseg√∫rate de tener instalado lo siguiente en tu sistema:

- **Node.js:** Se recomienda una versi√≥n LTS reciente (v18 o v20+ al momento de escribir esto). Puedes descargarlo desde [nodejs.org](https://nodejs.org/). Node.js incluye npm (Node Package Manager).
- **Yarn (Opcional, pero usado en los ejemplos de scripts):** Gestor de paquetes para Node.js (v1.x recomendada si se usa). Si tienes Node.js/npm, puedes instalarlo con `npm install --global yarn`. Si prefieres usar `npm` para todos los comandos, puedes adaptar los ejemplos (`yarn install` -> `npm install`, `yarn dev` -> `npm run dev`).
- **PostgreSQL:** Sistema de base de datos relacional. Necesitas tener un servidor PostgreSQL instalado y **corriendo** localmente o accesible en tu red.
  - Puedes descargarlo desde [postgresql.org/download](https://www.postgresql.org/download/).
  - Durante la instalaci√≥n, se te pedir√° configurar una contrase√±a para el usuario `postgres` (o el usuario administrador por defecto). An√≥tala.
  - Necesitar√°s crear una base de datos para el proyecto. Usando una herramienta como `psql` (cliente de l√≠nea de comandos de PostgreSQL) o pgAdmin (GUI), puedes crearla con: `CREATE DATABASE loyalpymedb;` (o el nombre que prefieras, pero deber√°s ajustarlo en el `.env`).
- **Git:** Sistema de control de versiones para clonar el repositorio. [git-scm.com/downloads](https://git-scm.com/downloads).
- **`npx`:** Es una herramienta que viene con `npm` (desde la versi√≥n 5.2+). Permite ejecutar paquetes de Node.js sin necesidad de instalarlos globalmente. La usaremos para comandos de Prisma y `ts-node`.
- **(Opcional) NVM (Node Version Manager):** √ötil para gestionar m√∫ltiples versiones de Node.js si trabajas en varios proyectos ([Linux/Mac](https://github.com/nvm-sh/nvm), [Windows](https://github.com/coreybutler/nvm-windows)).
- **(Opcional) Editor de C√≥digo:** Se recomienda VS Code con extensiones para Prisma, TypeScript, ESLint.

---

## 2. Instalaci√≥n del Backend

La configuraci√≥n del backend implica clonar el proyecto, instalar dependencias, configurar el entorno y preparar la base de datos.

1.  **Clonar Repositorio:**
    Si a√∫n no lo tienes, clona el repositorio del proyecto desde su URL y navega a la carpeta ra√≠z del proyecto.

    ```bash
    git clone <URL_DEL_REPOSITORIO_GIT> LoyalPyME
    cd LoyalPyME
    ```

2.  **Navegar a la Carpeta del Backend:**
    Todos los comandos siguientes para el backend se ejecutar√°n desde esta carpeta.

    ```bash
    cd backend
    ```

3.  **Instalar Dependencias del Backend:**
    Esto instalar√° todos los paquetes listados en `package.json` (Express, Prisma, etc.).

    ```bash
    yarn install
    # Alternativamente, si usas npm:
    # npm install
    ```

4.  **Configurar Variables de Entorno (`.env`):**
    Las variables de entorno son cruciales para configurar la conexi√≥n a la base de datos, secretos JWT, y credenciales de servicios externos como Cloudinary.

    - Copia el archivo de ejemplo `.env.example` a un nuevo archivo llamado `.env`:
      ```bash
      cp .env.example .env
      # En Windows, puedes usar: copy .env.example .env
      ```
    - Abre el archivo `.env` reci√©n creado con un editor de texto.
    - **Edita las siguientes variables obligatorias:**
      - `DATABASE_URL`: La cadena de conexi√≥n a tu base de datos PostgreSQL. El formato es: `postgresql://<DB_USER>:<DB_PASSWORD>@<DB_HOST>:<DB_PORT>/<DB_NAME>?schema=public`.
        - Ejemplo para una instalaci√≥n local com√∫n de PostgreSQL (reemplaza `<DB_PASSWORD>` con la contrase√±a que configuraste para tu usuario `postgres`, y `<DB_NAME>` con el nombre de la base de datos que creaste, ej: `loyalpymedb`):
          `postgresql://postgres:tu_contrase√±a_postgres@localhost:5432/loyalpymedb?schema=public`
        - Aseg√∫rate que el usuario de la BD tiene permisos para crear tablas en el schema `public` de esa base de datos.
      - `JWT_SECRET`: Una cadena larga, secreta y aleatoria utilizada para firmar los tokens de autenticaci√≥n (JWT). **¬°No uses el valor de ejemplo en un entorno de producci√≥n!** Puedes generar una con un generador de contrase√±as online.
      - `CLOUDINARY_CLOUD_NAME`: El "Cloud Name" de tu cuenta de Cloudinary (para almacenamiento de im√°genes).
      - `CLOUDINARY_API_KEY`: La "API Key" de tu cuenta de Cloudinary.
      - `CLOUDINARY_API_SECRET`: El "API Secret" de tu cuenta de Cloudinary.
    - **(Opcional) Variables para Tests de Integraci√≥n:** Si planeas ejecutar los tests de integraci√≥n del backend, podr√≠as necesitar definir:
      - `TEST_ADMIN_EMAIL`: Email para el admin en los tests.
      - `TEST_ADMIN_PASSWORD`: Contrase√±a para el admin en los tests.
        _(Nota: Actualmente, los tests podr√≠an tener credenciales hardcodeadas. Idealmente, deber√≠an usar estas variables de entorno.)_
    - **(Opcional) Variables para Creaci√≥n de Super Admin (si se leen desde .env en el script):**
      - `SUPERADMIN_EMAIL`
      - `SUPERADMIN_PASSWORD`
    - Guarda los cambios en el archivo `.env`.

5.  **Preparar la Base de Datos y Cargar Datos Iniciales:**
    Estos pasos inicializar√°n tu base de datos con el esquema definido y datos de prueba.
    - **Paso 5.1: Resetear y Aplicar Migraciones:**
      Este comando es fundamental para el desarrollo. **Eliminar√° todos los datos de tu base de datos `loyalpymedb` (si existe y tiene datos)**, aplicar√° todas las migraciones desde el principio y crear√° las tablas seg√∫n tu archivo `prisma/schema.prisma`. Es la forma m√°s limpia de asegurar que tu BD est√° sincronizada con el schema durante el desarrollo.
      ```bash
      npx prisma migrate reset
      ```
      Prisma te pedir√° confirmaci√≥n. Escribe `y` o `yes` y presiona Enter.
    - **Paso 5.2: Generar Cliente Prisma:**
      Despu√©s de cualquier cambio en el schema (como el que ocurre con `migrate reset` o `migrate dev`), debes regenerar el Cliente Prisma. Esto actualiza los tipos de TypeScript en `node_modules/.prisma/client` para que coincidan con tu schema.
      ```bash
      npx prisma generate
      ```
    - **Paso 5.3: Poblar con Datos de Demostraci√≥n (Seed):**
      Este comando ejecuta el script `prisma/seed.ts`. Este script est√° dise√±ado para crear:
      - Un negocio de demostraci√≥n llamado "Restaurante Demo LoyalPyME".
      - Un usuario administrador (`BUSINESS_ADMIN`) para ese negocio con credenciales: `admin@demo.com` / `password`.
      - Un usuario cliente (`CUSTOMER_FINAL`) para ese negocio con credenciales: `cliente@demo.com` / `password`.
      - Algunos Tiers y Recompensas de ejemplo para el negocio demo.
      - Los m√≥dulos LoyalPyME Core y LoyalPyME Camarero se activan por defecto para este negocio demo.
        Ejecuta:
      ```bash
      npx prisma db seed
      ```
      Deber√≠as ver en la consola los logs del script indicando la creaci√≥n de estos datos.
    - **Paso 5.4: Crear Usuario Super Administrador Global:**
      La plataforma tiene un rol de Super Administrador para gestionar todos los negocios. Este script crea el primer (y posiblemente √∫nico) Super Admin.
      Por defecto (seg√∫n el script `scripts/create-superadmin.ts`), las credenciales son: `superadmin@loyalpyme.com` / `superadminpassword`.
      **¬°Es crucial que cambies la contrase√±a por defecto en el script `create-superadmin.ts` si vas a usar esto en un entorno m√°s all√° de tu m√°quina local!**
      Ejecuta:
      ```bash
      npx ts-node ./scripts/create-superadmin.ts
      ```
      Guarda estas credenciales del Super Admin en un lugar seguro.

---

## 3. Instalaci√≥n del Frontend

1.  **Navegar a la Carpeta del Frontend:**
    Desde la ra√≠z del proyecto (`LoyalPyME/`):

    ```bash
    cd frontend
    ```

    (O `cd ../frontend` si est√°s en la carpeta `backend/`).

2.  **Instalar Dependencias del Frontend:**
    Esto instalar√° React, Mantine, y otras librer√≠as necesarias.
    ```bash
    yarn install
    # Alternativamente, si usas npm:
    # npm install
    ```
    _(No se requiere archivo `.env` en la carpeta `frontend/` por defecto, ya que la URL de la API se configura en `vite.config.ts` para el proxy o se usa directamente en `axiosInstance` si es una URL completa)._

---

## 4. Ejecuci√≥n en Modo Desarrollo

**¬°Aseg√∫rate de que tu servidor PostgreSQL est√© corriendo localmente!**

Se recomienda usar **dos terminales separadas** para el backend para una mejor experiencia de desarrollo.

- **Terminal 1 (Backend - Compilador TypeScript en modo "watch"):**

  - Navega a la carpeta `backend/`.
  - Ejecuta el script `dev:build` de tu `package.json` (o el comando directo):
    ```bash
    yarn dev:build
    # o npx tsc --watch
    ```
  - Esto vigilar√° cambios en tus archivos `.ts` dentro de `src/` y los compilar√° autom√°ticamente a JavaScript en la carpeta `dist/`. D√©jalo corriendo.

- **Terminal 2 (Backend - Servidor Node.js con Nodemon):**

  - Navega a la carpeta `backend/`.
  - Ejecuta el script `dev:run` de tu `package.json` (o el comando directo):
    ```bash
    yarn dev:run
    # o npx nodemon dist/index.js
    ```
  - Esto iniciar√° el servidor Express (`http://localhost:3000` por defecto) usando los archivos compilados en `dist/`. Nodemon reiniciar√° el servidor autom√°ticamente si detecta cambios en `dist/` (causados por `tsc --watch`). D√©jalo corriendo.

- **Terminal 3 (Frontend - Servidor de Desarrollo Vite):**
  - Navega a la carpeta `frontend/`.
  - Ejecuta el script `dev`:
    ```bash
    yarn dev
    # Si necesitas que el frontend sea accesible desde otros dispositivos en tu red local (ej: m√≥vil):
    # yarn dev --host
    ```
  - Esto iniciar√° el servidor de desarrollo de Vite. Por defecto (con `mkcert`), intentar√° usar `https://localhost:5173`. Si no usas HTTPS, ser√° `http://localhost:5173`. La terminal te mostrar√° la URL exacta. D√©jalo corriendo.

---

## 5. Acceso a la Aplicaci√≥n y Paneles

Una vez que todos los servidores est√©n corriendo:

- **Aplicaci√≥n Principal (Login, Registro Cliente, Dashboard Cliente, Panel Admin Negocio):**
  - Abre tu navegador y ve a `https://localhost:5173` (o la URL que te haya dado Vite).
  - **Credenciales del Negocio Demo (creadas por el seed):**
    - Email: `admin@demo.com`
    - Contrase√±a: `password`
  - **Credenciales del Cliente Demo (creadas por el seed):**
    - Email: `cliente@demo.com`
    - Contrase√±a: `password`
- **Panel Super Administrador:**
  - Navega a `https://localhost:5173/superadmin`
  - **Credenciales Super Admin (creadas por el script `create-superadmin.ts`):**
    - Email: `superadmin@loyalpyme.com` (o el que configuraste)
    - Contrase√±a: `superadminpassword` (¬°o la que configuraste!)
- **API Backend Directa:**
  - La API est√° disponible en `http://localhost:3000`.
- **Documentaci√≥n API (Swagger UI):**
  - Accede a `http://localhost:3000/api-docs` en tu navegador para ver y probar los endpoints de la API.

**Acceso desde M√≥vil (Red Local):**
Si ejecutaste el frontend con `yarn dev --host`, Vite te mostrar√° una URL de "Network" (ej: `https://192.168.1.XX:5173`).

1.  Aseg√∫rate que tu PC y tu dispositivo m√≥vil est√°n en la misma red WiFi.
2.  Abre el navegador en tu m√≥vil y escribe esa URL de red.
3.  Si usas HTTPS (recomendado), es probable que el m√≥vil muestre una advertencia de seguridad por el certificado autofirmado de `mkcert`. Deber√°s aceptarla para continuar (generalmente hay una opci√≥n de "Avanzado" o "Continuar de todas formas").
4.  Verifica que tu firewall en la PC permite conexiones entrantes en el puerto `5173` (para Vite) y `3000` (para el backend API) en redes privadas.

---

## 6. Build para Producci√≥n

Para crear las versiones optimizadas para despliegue:

- **Backend:**
  Desde la carpeta `backend/`:
  ```bash
  yarn build
  # o npm run build
  ```
  Esto generar√° la carpeta `dist/` con el c√≥digo JavaScript transpilado.
- **Frontend:**
  Desde la carpeta `frontend/`:
  ```bash
  yarn build
  # o npm run build
  ```
  Esto generar√° la carpeta `dist/` (dentro de `frontend/`) con los assets est√°ticos optimizados.

---

## 7. Ejecuci√≥n en Producci√≥n (Conceptual)

El despliegue a un entorno de producci√≥n es un tema m√°s amplio y depende del proveedor de hosting/plataforma elegido. Conceptualmente, implicar√≠a:

1.  Construir el backend y frontend (ver secci√≥n anterior).
2.  Configurar un servidor de producci√≥n (VPS, PaaS como Render, Heroku, etc.).
3.  Configurar una base de datos PostgreSQL de producci√≥n.
4.  Establecer todas las variables de entorno (`.env`) necesarias en el servidor de producci√≥n (DB_URL, JWT_SECRET, credenciales Cloudinary, etc.).
5.  Subir los archivos de `backend/dist/`, `backend/node_modules/` (solo producci√≥n), y `frontend/dist/`.
6.  Ejecutar las migraciones de Prisma en la base de datos de producci√≥n: `npx prisma migrate deploy`.
7.  Iniciar el servidor Node.js del backend (ej: `node dist/index.js`, idealmente usando un gestor de procesos como PM2).
8.  Configurar un servidor web (como Nginx o Apache) para servir los archivos est√°ticos del frontend y actuar como proxy inverso para las peticiones `/api` hacia el backend Node.js.
9.  Asegurar HTTPS con certificados SSL v√°lidos.

_(El plan de desarrollo menciona una "Estrategia Deployment & CI/CD (Avanzada)" como tarea futura)._

---

## 8. Comandos y Herramientas √ötiles (Ampliados)

Ejecuta estos comandos desde la carpeta correspondiente (`backend/` o `frontend/` seg√∫n aplique).

- **Base de Datos (Backend - Prisma):**

  - `npx prisma studio`: Abre una interfaz gr√°fica en el navegador para ver y editar los datos de tu base de datos. ¬°Muy √∫til para desarrollo!
  - `npx prisma migrate dev`: Aplica migraciones pendientes, crea la BD si no existe (en desarrollo). Te pedir√° un nombre para la nueva migraci√≥n si hay cambios en el schema.
  - `npx prisma migrate reset`: **¬°CUIDADO!** Borra la base de datos y vuelve a aplicar todas las migraciones. √ötil para empezar de cero si las migraciones dan problemas irrecuperables en desarrollo.
  - `npx prisma generate`: Regenera el Cliente Prisma (`@prisma/client`) despu√©s de cambios en `schema.prisma`. **Esencial despu√©s de cualquier migraci√≥n.**
  - `npx prisma format`: Formatea autom√°ticamente tu archivo `schema.prisma` para mantenerlo ordenado.
  - `npx prisma validate`: Comprueba si tu `schema.prisma` es v√°lido sint√°cticamente.
  - `npx prisma db seed`: Ejecuta el script `prisma/seed.ts` para poblar la BD con datos iniciales/demo.

- **Testing (Backend - Vitest):**

  - `yarn test` (o `npm run test`): Ejecuta todos los tests (`*.test.ts`) una vez.
  - `yarn test:watch` (o `npm run test:watch`): Ejecuta los tests y se queda vigilando cambios para volver a ejecutarlos.
  - `yarn test --coverage` (o `npm run test -- --coverage`): Ejecuta los tests y genera un informe de cobertura de c√≥digo.
  - `yarn test <nombre_archivo_o_patron>`: Ejecuta solo tests espec√≠ficos.

- **Testing (Frontend - Vitest):**

  - `yarn test` (o `npm run test`): Ejecuta todos los tests una vez.
  - `yarn test:watch` (o `npm run test:watch`): Ejecuta en modo vigilancia.
  - `yarn test:ui` (o `npm run test:ui`): Abre una interfaz gr√°fica en el navegador para explorar los resultados de los tests de Vitest.
  - `yarn test --coverage` (o `npm run test -- --coverage`): Ejecuta con informe de cobertura.

- **Scripts Personalizados (Backend - ejecutados con `ts-node`):**

  - `npx ts-node ./scripts/create-superadmin.ts`: Crea el usuario Super Administrador global.
  - `npx ts-node ./scripts/hash-customer-password.ts`: (Ejemplo) Script para actualizar hash de contrase√±a de un usuario espec√≠fico. Adaptar seg√∫n necesidad.
    _(Para ejecutar scripts `ts-node`, aseg√∫rate de estar en la carpeta `backend/` y que `ts-node` est√© en `devDependencies`)_.

- **Otros Comandos Frontend:**

  - `yarn lint` (o `npm run lint`): Ejecuta ESLint para comprobar la calidad y estilo del c√≥digo.
  - `yarn preview` (o `npm run preview`): Construye la app para producci√≥n y la sirve localmente para previsualizarla.

- **Herramientas Externas Recomendadas:**
  - **Clientes Gr√°ficos de PostgreSQL:** pgAdmin (oficial), DBeaver (universal), DataGrip (de JetBrains, de pago). Muy √∫tiles para inspeccionar el schema, los datos, y ejecutar SQL directamente.
  - **psql:** Cliente de l√≠nea de comandos para PostgreSQL. Potente para usuarios avanzados.
  - **Postman / Insomnia / Bruno:** Herramientas para probar la API backend directamente enviando peticiones HTTP (GET, POST, etc.) y viendo las respuestas. Esencial para depurar APIs.
  - **Navegador (Herramientas de Desarrollador - F12):** Indispensable para depurar el frontend:
    - **Consola:** Ver logs de JavaScript, errores.
    - **Red (Network):** Inspeccionar peticiones API, sus cabeceras, cuerpos y respuestas.
    - **Elementos (Elements):** Inspeccionar y modificar el DOM y CSS.
    - **Aplicaci√≥n (Application):** Ver y modificar `localStorage`, `sessionStorage`, cookies.
  - **Navegador (Depuraci√≥n Remota M√≥vil):** Si necesitas depurar la vista m√≥vil, los navegadores de escritorio ofrecen herramientas para conectar con el navegador de un dispositivo m√≥vil (o emulador) y ver su consola/inspector. (Ver secci√≥n 5 y `TROUBLESHOOTING_GUIDE.md`).

---

## 9. ¬øProblemas?

Si encuentras problemas durante la instalaci√≥n o ejecuci√≥n, consulta primero la [TROUBLESHOOTING_GUIDE.md](./TROUBLESHOOTING_GUIDE.md) para ver soluciones a errores comunes ya documentados.

---

_(Fin de la Gu√≠a de Setup)_



// ====== [9] TROUBLESHOOTING_GUIDE.md ======
# Gu√≠a R√°pida de Troubleshooting - LoyalPyME

**Fecha de √öltima Actualizaci√≥n:** 09 de Mayo de 2025

---

Esta gu√≠a recopila problemas t√©cnicos significativos o no obvios encontrados durante el desarrollo de LoyalPyME, sus causas y soluciones, para agilizar futuras depuraciones.

---

## Problemas Comunes y Soluciones

**NUEVO: Problemas con el Script de Seed (`npx prisma db seed`)**

**A. `npx prisma db seed` no ejecuta el script `prisma/seed.ts` o no muestra `console.log`s:**

- **S√≠ntomas:** El comando `npx prisma db seed` se completa r√°pidamente sin mostrar los `console.log` del script `seed.ts`, y la base de datos no se puebla. Sin embargo, ejecutar `npx ts-node ./prisma/seed.ts` directamente S√ç funciona y muestra los logs.
- **Causa M√°s Probable:** Prisma CLI (v5+) no est√° encontrando o interpretando correctamente la configuraci√≥n para ejecutar el script de seed TypeScript.
- **Soluci√≥n Cr√≠tica:**
  1.  **Asegurar `package.json` (en `backend/`):** Dentro de tu `backend/package.json`, a√±ade o verifica una secci√≥n `"prisma"` que defina el comando de seed:
      ```json
      {
        // ... otras secciones ...
        "prisma": {
          "seed": "ts-node prisma/seed.ts"
          // La opci√≥n --compiler-options "{\"module\":\"commonjs\"}" puede causar errores TS5023
          // Es mejor confiar en el tsconfig.json del proyecto si est√° configurado para commonjs.
        }
      }
      ```
  2.  Aseg√∫rate de que `ts-node` est√° en tus `devDependencies`.
  3.  Ejecuta `npx prisma db seed` desde la misma carpeta donde est√° el `package.json` que contiene la secci√≥n `"prisma"` (normalmente `backend/`).

**B. Error `TSError: ‚®Ø Unable to compile TypeScript: error TS5023: Unknown compiler option 'X'` al ejecutar `npx prisma db seed`:**

- **S√≠ntomas:** El comando `npx prisma db seed` falla con errores `TS5023` indicando opciones de compilador desconocidas (a menudo n√∫meros o caracteres sueltos).
- **Causa:** El comando definido en `package.json` para el seed (bajo `"prisma": { "seed": "..." }`) tiene una sintaxis incorrecta para pasar argumentos como `--compiler-options` a `ts-node`, usualmente debido a problemas con el escapado de comillas dentro del JSON del `package.json`.
- **Soluci√≥n:** Simplifica el comando de seed en `package.json` a:
  ```json
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  }
  ```
  Aseg√∫rate que tu `backend/tsconfig.json` tiene `"module": "commonjs"` (o el m√≥dulo que est√©s usando para tu backend).

**C. Errores de TypeScript en `seed.ts` (ej: `Property 'X' does not exist on type 'BusinessCreateInput'`) despu√©s de modificar `schema.prisma`:**

- **S√≠ntomas:** El editor o la compilaci√≥n de `ts-node` muestra errores de TypeScript en `seed.ts` indicando que campos reci√©n a√±adidos al schema no existen en los tipos de entrada generados por Prisma (ej: `BusinessCreateInput`).
- **Causa:** El Cliente Prisma (`node_modules/.prisma/client`) no se ha regenerado despu√©s de la √∫ltima migraci√≥n exitosa de `schema.prisma` (`migrate dev` o `migrate reset`).
- **Soluci√≥n Cr√≠tica:** **SIEMPRE** ejecuta `npx prisma generate` en `backend/` despu√©s de cada `npx prisma migrate dev` o `npx prisma migrate reset` exitoso. Si el editor sigue mostrando errores, reinicia el servidor TypeScript de tu editor (ej: en VS Code, Ctrl+Shift+P -> "TypeScript: Restart TS server").

**D. Error `P3018` (Migration failed to apply) con `DETAIL: La llave (businessId)=... no est√° presente en la tabla ¬´Business¬ª` al intentar migrar `schema.prisma` despu√©s de cambios estructurales:**

- **S√≠ntomas:** `npx prisma migrate dev` falla con `P3018` y un error de base de datos sobre violaci√≥n de clave for√°nea (usualmente `ERROR: inserci√≥n o actualizaci√≥n en la tabla ¬´YYY¬ª viola la llave for√°nea ¬´YYY_businessId_fkey¬ª`). Prisma tambi√©n puede advertir sobre `DROP` de tablas no vac√≠as antes de intentar la migraci√≥n.
- **Causa:** Un cambio estructural grande (ej: hacer opcional un campo que era parte de una relaci√≥n obligatoria, cambiar tipos de campos relacionados, etc.) hace que Prisma determine que necesita recrear tablas. Si tienes datos existentes, Prisma intenta aplicar los cambios, pero si los datos se reinsertan en un orden incorrecto (ej: un `Tier` antes que su `Business` asociado si la tabla `Business` fue recreada) o si los datos referenciados se pierden temporalmente durante la migraci√≥n, las restricciones de claves for√°neas pueden fallar.
- **Soluci√≥n (Para Desarrollo donde los datos NO son cr√≠ticos):** La forma m√°s limpia y r√°pida es resetear la base de datos. Esto eliminar√° todos los datos existentes y aplicar√° todas las migraciones desde cero sobre una BD limpia.
  ```bash
  npx prisma migrate reset
  ```
  Confirma la acci√≥n cuando se te pregunte. Luego, no olvides ejecutar `npx prisma generate` y, si tienes un script de seed, `npx prisma db seed`.
- **Soluci√≥n (Para Producci√≥n o datos cr√≠ticos - ¬°CON MUCHO CUIDADO!):** Esto es mucho m√°s complejo. Implica analizar el SQL generado por la migraci√≥n fallida (en `prisma/migrations/.../migration.sql`), entender por qu√© falla, y potencialmente editar ese SQL o realizar operaciones manuales en la BD para preparar los datos ANTES de reintentar la migraci√≥n. A menudo es preferible hacer cambios m√°s peque√±os e incrementales en producci√≥n o tener una estrategia de backup/restore robusta. Consulta la documentaci√≥n de Prisma sobre "Resolving failed migrations".

---

_(Aqu√≠ contin√∫a el resto de tu contenido original de TROUBLESHOOTING_GUIDE.md)_
_(Me aseguro de incluir los puntos que ya ten√≠as)_

---

**1. Backend: Inestabilidad con `yarn dev` (nodemon + ts-node)**

- **S√≠ntomas:** Reinicios inesperados, errores `SyntaxError`, cambios no reflejados.
- **Causa:** Conflictos/inestabilidad de `ts-node-dev`/`nodemon` con m√≥dulos ES/CJS en el entorno.
- **Soluci√≥n Estable:** Usar **dos terminales** en `backend/`:
  1. `npx tsc --watch` (Compilaci√≥n continua)
  2. `npx nodemon dist/index.js` (Ejecuci√≥n con reinicio autom√°tico al cambiar `dist/`)

**2. Backend: Cambios en `.ts` No Se Reflejan / Ruta Nueva da 404 / L√≥gica Antigua se Ejecuta**

- **S√≠ntomas:** Modificas c√≥digo en un archivo `.ts` (ej: un servicio), pero la API sigue comport√°ndose como antes (ej: no guarda un campo nuevo, usa l√≥gica vieja). O creas una ruta nueva y da 404.
- **Causa:** El proceso `node` que ejecuta `nodemon` solo vigila cambios en la carpeta `dist/`. Si no tienes `npx tsc --watch` corriendo o no has ejecutado `yarn build` manualmente despu√©s de guardar el `.ts`, los cambios no se compilan a JavaScript en `dist/`. Adem√°s, si a√±ades una nueva ruta, debes asegurarte de montarla con `app.use()` en `index.ts`.
- **Soluci√≥n Cr√≠tica:** **SIEMPRE** aseg√∫rate de que los cambios en `.ts` se compilen a `dist/` (`tsc --watch` o `yarn build`). Si a√±ades rutas, aseg√∫rate de que `index.ts` las importa y las monta (`app.use(...)`). **Reinicia `nodemon`** despu√©s de cambiar `index.ts`. Si persiste, forzar limpieza: `rm -rf dist && yarn build && npx nodemon dist/index.js`. _(Visto con rutas /api/customer/activity y /api/uploads/image)_

**3. Frontend: Cambios No Se Aplican (Vite HMR)**

- **S√≠ntomas:** Funcionalidad no cambia, estilos viejos, etc., tras guardar archivo.
- **Soluci√≥n:** 1. Verificar terminal `yarn dev` por errores. 2. Refresco forzado navegador (Ctrl+Shift+R). 3. **Reiniciar `yarn dev`** (`Ctrl+C` y `yarn dev --host`), especialmente tras cambios en `vite.config.ts`.

**4. Backend: Errores `TS2305` (`Module '"@prisma/client"' has no exported member 'User', 'Reward', etc.`)**

- **S√≠ntomas:** TypeScript no encuentra **ninguno** de los tipos/enums generados por Prisma al importar desde `@prisma/client`, incluso despu√©s de una migraci√≥n exitosa. Ocurre al compilar (`npx tsc`).
- **Causa:** La generaci√≥n del Cliente Prisma (`node_modules/.prisma/client`) est√° incompleta, corrupta, o no se ejecut√≥/termin√≥ correctamente despu√©s de la √∫ltima migraci√≥n (`prisma migrate`). `tsc` no puede encontrar las definiciones de tipos necesarias.
- **Soluci√≥n Cr√≠tica:** Ejecutar expl√≠citamente **`npx prisma generate`** en `backend/` despu√©s de cada `prisma migrate dev` exitoso. Asegurarse de que `prisma generate` termina sin errores. Reiniciar el servidor TS del editor si es necesario. Si persiste, borrar `node_modules/.prisma/client` manualmente y regenerar.

**5. Backend: Dependencias Circulares (TS)**

- **S√≠ntomas:** Errores de ciclo de importaci√≥n entre archivos.
- **Soluci√≥n:** Mover definiciones (interfaces, tipos) a archivos independientes e importar desde all√≠.

**6. Backend: API no se conecta a Base de Datos (`PrismaClientInitializationError`)**

- **S√≠ntomas:** Endpoints fallan con 500, logs muestran error de conexi√≥n a DB. Frecuente tras reinicios del sistema.
- **Soluci√≥n:** 1. Verificar que servicio PostgreSQL corre. 2. Verificar `DATABASE_URL` en `.env`. 3. Ejecutar `npx prisma migrate dev` si la BD est√° vac√≠a/corrupta (o `npx prisma migrate reset` en desarrollo).

**7. Frontend: Error 401 al llamar a Rutas P√∫blicas Backend desde `axiosInstance`**

- **Estado:** Resuelto (Backend v1.3.0+).
- **Causa Antigua:** Middleware `authenticateToken` aplicado globalmente a `/api`.
- **Soluci√≥n Aplicada:** Middlewares aplicados individualmente a rutas protegidas en `backend/src/index.ts`. Rutas p√∫blicas (`/api/auth/*`, `/public/*`) no llevan middleware global. Usar `axiosInstance` para `/api/*` (incl. `/api/auth`) y `axios` base para `/public/*`.

**8. Frontend: Formulario Mantine parece vac√≠o tras cargar datos**

- **Estado:** Resuelto (en `TierSettingsPage.tsx`).
- **Causa Antigua:** Llamada incorrecta a `form.reset()` despu√©s de `form.setValues()` en la carga.
- **Soluci√≥n Aplicada:** Eliminar `form.reset()` de la funci√≥n de carga inicial. Usar `form.setValues()` y luego `form.reset()` _despu√©s_ de un guardado exitoso para actualizar valores base y limpiar estado 'dirty'.

**9. Mobile: Esc√°ner QR falla (`setPhotoOptions failed`)**

- **Estado:** Resuelto (Obsoleto).
- **Causa Antigua:** Bug/incompatibilidad en `react-qr-reader`.
- **Soluci√≥n Aplicada:** Reemplazo por `html5-qrcode` y uso del hook `useQrScanner`.

**10. Git: Error `Deletion of directory '...' failed` (Windows)**

- **Causa:** Bloqueo de archivo/carpeta por otro programa.
- **Soluci√≥n:** Cerrar programas -> `git merge --abort` / `git reset --hard HEAD` (si necesario) -> `git pull`.

**11. Testing Backend (Vitest): Test file no se descubre**

- **S√≠ntomas:** Tests en archivo `.ts` no se ejecutan.
- **Causa:** Nombre de archivo no termina en `.test.ts` o `.spec.ts`.
- **Soluci√≥n:** Renombrar archivo correctamente.

**12. Testing Backend (Vitest): Mocking de Prisma falla (`Cannot read properties of undefined`, spy not called)**

- **S√≠ntomas:** Tests unitarios de funciones que usan `new PrismaClient()` internamente fallan al intentar mockear Prisma.
- **Causa:** Instancia interna de Prisma ignora mocks globales (`vi.mock`).
- **Soluci√≥n Aplicada:** **Inyecci√≥n de Dependencias**. 1. Refactorizar funci√≥n/helper para aceptar `prismaClient` como argumento. 2. En el test, crear mock simple y pasarlo como argumento.

**13. Testing Backend (Vitest/TS): Errores TS2352/TS2554 persistentes (Mock vs Type)**

- **S√≠ntomas:** `tsc` se queja de incompatibilidad de tipos entre el mock simple pasado por DI y el tipo esperado (`Pick<PrismaClient,...>`) o de n√∫mero incorrecto de argumentos.
- **Causa:** Discrepancia estructural grande entre mock y tipo real, o TS server cache/resoluci√≥n incorrecta de firmas tras refactor.
- **Soluci√≥n Aplicada:** 1. Asegurar archivo fuente (`.ts`) guardado y compilado (`yarn build`). 2. Reiniciar servidor TS en VS Code. 3. Si persiste, usar `// @ts-expect-error` en la l√≠nea anterior a la llamada dentro del archivo `.test.ts`.

**14. Testing Integraci√≥n (Supertest): Error 401 devuelve `text/plain`, no JSON**

- **S√≠ntomas:** Test que espera 401 por falta de token falla por `Content-Type`.
- **Causa:** Middleware `authenticateToken` usa `res.sendStatus(401)` que responde con `text/plain`.
- **Soluci√≥n:** En esos tests espec√≠ficos, eliminar la aserci√≥n `.expect('Content-Type', /json/)`.

**15. Testing Integraci√≥n (Supertest): Test Login 401 (√âxito esperado)**

- **Causa:** Credenciales hardcodeadas en el test no coinciden con las de la BD de prueba.
- **Soluci√≥n:** Verificar/corregir usuario admin de test en BD. Considerar usar variables de entorno para credenciales de test.

**16. Testing Integraci√≥n (Supertest): Setup Falla - Registro Cliente (DNI Inv√°lido)**

- **Causa:** DNI generado aleatoriamente en `beforeAll` no ten√≠a letra de control v√°lida.
- **Soluci√≥n:** A√±adir funci√≥n helper `generateValidDni()` al test setup para crear DNIs v√°lidos.

**17. Testing Integraci√≥n (Supertest): Ruta `PATCH` devuelve HTML/404**

- **Causa:** Olvido de definir la ruta `router.patch(...)` en el archivo `.routes.ts`.
- **Soluci√≥n:** A√±adir la definici√≥n de la ruta PATCH en el router.

**18. Testing Integraci√≥n (Supertest): Error 500 en lugar de 400 (Validaci√≥n) o 409 (Conflicto)**

- **Causa:** Falta validaci√≥n de entrada en controlador; Error P2002 (Unique Constraint) de Prisma no manejado espec√≠ficamente en el `catch` del controlador.
- **Soluci√≥n:** A√±adir validaciones en controlador; A√±adir `if (error instanceof Error && error.message.includes(...))` espec√≠fico para unicidad en `catch` para devolver 409.

**19. Frontend (i18n): Claves (`loginPage.title`, `desc_REDEEMED`) se muestran en lugar de texto traducido**

- **Causa:** Clave no encontrada en el archivo de idioma (`translation.json`) cargado para el idioma actual (ej: `en`). Puede ser por error tipogr√°fico en la clave (c√≥digo vs JSON), error de sintaxis en el archivo JSON que impide su carga completa, o clave no a√±adida a **todos** los archivos de idioma necesarios.
- **Soluci√≥n:** Verificar coincidencia exacta de claves. Validar sintaxis JSON. Asegurar que la clave existe en los archivos de _todos_ los idiomas soportados (`es`, `en`). Usar `debug: true` en `i18n.ts` y revisar consola por `i18next: missingKey ...`.

**20. Frontend: Banderas de Idioma (Emoji Unicode) no se renderizan**

- **Causa:** Falta de soporte de fuente en el sistema/navegador.
- **Soluci√≥n:** Usar una librer√≠a como `react-country-flag` que utiliza SVG.

**21. Frontend: Navbar M√≥vil Admin no se cierra autom√°ticamente**

- **Causa:** Componente Navbar no ten√≠a acceso a funci√≥n `close`.
- **Soluci√≥n:** Pasar `close` (de `useDisclosure`) como prop desde Layout a Navbar y llamarla en `onClick` del enlace.

**22. PowerShell: Sintaxis para `curl` y JSON**

- **Soluci√≥n:** Usar `Invoke-RestMethod` con par√°metros PowerShell (`-Method`, `-Headers @{}`, `-Body ($obj | ConvertTo-Json -Depth N)`).

**23. Backend: Subida de Im√°genes Cloudinary Falla (Error 500 o 401)**

- **S√≠ntomas:** Error 500/401 desde backend al subir, logs indican `Invalid cloud_name` o `Unknown API key`.
- **Causas:** Credenciales (`.env`) incorrectas/mezcladas, backend no reiniciado tras cambiar `.env`, error lectura `.env`, problema cuenta Cloudinary.
- **Soluci√≥n Aplicada:** Crear cuenta Cloudinary nueva, obtener credenciales nuevas, ponerlas correctamente en `.env` (`CLOUDINARY_CLOUD_NAME`, `_API_KEY`, `_API_SECRET`), reiniciar backend.

**24. Backend/Frontend: Campo Nuevo (ej: `imageUrl`, `name_es`) Se Guarda/Recibe Como `null` o Da Error de Tipo**

- **S√≠ntomas:** Campo nuevo no se guarda en BD, o el frontend da error de tipo (ej: `Property 'name_es' does not exist on type 'Reward'`) al intentar usar datos de la API.
- **Causas:**
  - **Backend:** Controlador no extrae/pasa el campo al servicio; Servicio no incluye campo en `prisma.create/update`; Servicio no incluye campo en `select` al leer; `tsc` no recompil√≥ `dist/`.
  - **Frontend:** Tipo/Interfaz (`types/customer.ts`) no actualizado; Hook que obtiene datos no usa/devuelve el tipo actualizado; Componente que muestra datos usa el nombre de campo antiguo.
- **Soluci√≥n:** Verificar/corregir **toda** la cadena: Controlador (extracci√≥n/paso) -> Servicio (guardado) -> Servicio (lectura `select`) -> Backend Compilaci√≥n (`tsc`) -> Frontend Tipo (`types/customer.ts`) -> Frontend Hook (estado/retorno) -> Frontend Componente (acceso a propiedad correcta, ej: `reward.name_es`).

**25. Mobile: Esc√°ner QR (`html5-qrcode`) No Se Inicia / Error "Element ... not found"**

- **S√≠ntomas:** Al abrir modal de esc√°ner en m√≥vil, la c√°mara no inicia, consola muestra `Element with ID '...' not found`.
- **Causa:** Timing: `useEffect` del hook `useQrScanner` intenta inicializar `Html5Qrcode` antes de que el DOM del modal est√© completamente listo.
- **Soluci√≥n/Workaround Aplicado:** En `useQrScanner.ts`, envolver la inicializaci√≥n (`new Html5Qrcode`, `scannerInstance.start`) dentro de un `setTimeout(() => { ... }, 500)`. Limpiar timeout en cleanup. Corregir tipo de `useRef` para timeout a `number | null`.

**26. Backend: Error TS2307 (`Cannot find module '...'`) Persistente**

- **S√≠ntomas:** `npx tsc` sigue fallando al importar un m√≥dulo (ej: `./uploads.service` desde `uploads.controller`) incluso despu√©s de verificar exportaciones y limpiar `dist`.
- **Causa Probable:** Nombre de archivo incorrecto en el disco (ej: `upload.controller.ts` vs `uploads.controller.ts`); Error interno en el archivo que se intenta importar (`uploads.service.ts`) que impide a `tsc` analizarlo; Problema cach√© `tsc`.
- **Soluci√≥n:** Verificar **exactamente** el nombre del archivo en disco y en la importaci√≥n. Revisar el c√≥digo del archivo importado en busca de errores. Forzar recompilaci√≥n limpia (`rm -rf dist && npx tsc`).

**27. Frontend: Error TS2322 (`Type '... | TFunctionDetailedResult' is not assignable to type 'string'/'ReactNode'`) Persistente**

- **S√≠ntomas:** Error de tipo al asignar el resultado de `t()` (de i18next) a una prop que espera `string` o `ReactNode` (ej: `title` en `Timeline.Item`), incluso despu√©s de intentar conversiones (`String()`, template literals).
- **Causa Probable:** Inferencia de tipos compleja de `t()` con interpolaci√≥n; Problema de tipos espec√≠fico de la versi√≥n de Mantine/i18next/TS; Cach√©/Entorno.
- **Soluci√≥n Aplicada:** Usar aserci√≥n de tipo `as string` (`prop={resultado_t as string}`) o variable intermedia tipada expl√≠citamente (`const titulo: string = String(resultado_t); prop={titulo}`). Si persiste, resetear entorno (`rm -rf node_modules yarn.lock && yarn install`).

**28. Frontend: Error Runtime Mantine (`Tooltip component children should be an element or component that accepts ref...`)**

- **S√≠ntomas:** La aplicaci√≥n falla en runtime al renderizar un `Tooltip`.
- **Causa:** El hijo directo del `Tooltip` no es un elemento/componente v√°lido que acepte `ref` (ej: Fragment `<>...</>`, texto suelto, o componente complejo anidado). A veces relacionado con advertencias de hidrataci√≥n por whitespace.
- **Soluci√≥n:** Asegurar que el hijo directo del `Tooltip` sea un √∫nico elemento v√°lido (ej: `<ActionIcon>`, `<Button>`). Si es necesario, envolver el contenido en un `<Box>`. Limpiar espacios en blanco en JSX de tablas (`Table`, `Thead`, `Tr`, etc.).

---

_(Fin de la Gu√≠a)_



// ====== [10] backend/nodemon.json ======
{
    "watch": ["dist"],
    "ext": "js,json",
    "ignore": [
      "src/",
      "node_modules/",
      "prisma/",
      "tests/",
      ".git/",
      "*.test.ts",
      "*.spec.ts"
    ],
"exec": "node dist/src/index.js",
    "delay": "1500ms"
  }


// ====== [11] backend/package-lock.json ======
{
  "name": "backend",
  "version": "1.15.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "backend",
      "version": "1.15.0",
      "license": "SEE LICENSE IN ../LICENSE.md",
      "dependencies": {
        "@nestjs/common": "^11.1.2",
        "@nestjs/core": "^11.1.2",
        "@prisma/client": "^6.6.0",
        "@types/multer": "^1.4.12",
        "@types/node-cron": "^3.0.11",
        "@types/streamifier": "^0.1.2",
        "bcryptjs": "^2.4.3",
        "class-transformer": "^0.5.1",
        "class-validator": "^0.14.2",
        "cloudinary": "^2.6.0",
        "cors": "^2.8.5",
        "date-fns": "^3.6.0",
        "dotenv": "^16.4.5",
        "express": "^4.19.2",
        "jsonwebtoken": "^9.0.2",
        "multer": "^1.4.5-lts.2",
        "node-cron": "^3.0.3",
        "reflect-metadata": "^0.2.2",
        "rxjs": "^7.8.2",
        "streamifier": "^0.1.1",
        "swagger-jsdoc": "^6.2.8",
        "swagger-ui-express": "^5.0.1",
        "uuid": "^10.0.0"
      },
      "devDependencies": {
        "@types/bcryptjs": "^2.4.6",
        "@types/cors": "^2.8.17",
        "@types/date-fns": "^2.6.0",
        "@types/dotenv": "^8.2.0",
        "@types/express": "^4.17.21",
        "@types/jsonwebtoken": "^9.0.6",
        "@types/node": "^20.19.1",
        "@types/supertest": "^6.0.2",
        "@types/swagger-jsdoc": "^6.0.4",
        "@types/swagger-ui-express": "^4.1.8",
        "@types/uuid": "^10.0.0",
        "@vitest/coverage-v8": "^2.0.4",
        "nodemon": "^3.1.4",
        "prisma": "^6.6.0",
        "supertest": "^7.0.0",
        "ts-node": "^10.9.2",
        "ts-node-dev": "^2.0.0",
        "typescript": "^5.5.3",
        "vitest": "^2.0.4"
      }
    },
    "node_modules/@ampproject/remapping": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@apidevtools/json-schema-ref-parser": {
      "version": "9.1.2",
      "resolved": "https://registry.npmjs.org/@apidevtools/json-schema-ref-parser/-/json-schema-ref-parser-9.1.2.tgz",
      "integrity": "sha512-r1w81DpR+KyRWd3f+rk6TNqMgedmAxZP5v5KWlXQWlgMUUtyEJch0DKEci1SorPMiSeM8XPl7MZ3miJ60JIpQg==",
      "license": "MIT",
      "dependencies": {
        "@jsdevtools/ono": "^7.1.3",
        "@types/json-schema": "^7.0.6",
        "call-me-maybe": "^1.0.1",
        "js-yaml": "^4.1.0"
      }
    },
    "node_modules/@apidevtools/openapi-schemas": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/@apidevtools/openapi-schemas/-/openapi-schemas-2.1.0.tgz",
      "integrity": "sha512-Zc1AlqrJlX3SlpupFGpiLi2EbteyP7fXmUOGup6/DnkRgjP9bgMM/ag+n91rsv0U1Gpz0H3VILA/o3bW7Ua6BQ==",
      "license": "MIT",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@apidevtools/swagger-methods": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/@apidevtools/swagger-methods/-/swagger-methods-3.0.2.tgz",
      "integrity": "sha512-QAkD5kK2b1WfjDS/UQn/qQkbwF31uqRjPTrsCs5ZG9BQGAkjwvqGFjjPqAuzac/IYzpPtRzjCP1WrTuAIjMrXg==",
      "license": "MIT"
    },
    "node_modules/@apidevtools/swagger-parser": {
      "version": "10.0.3",
      "resolved": "https://registry.npmjs.org/@apidevtools/swagger-parser/-/swagger-parser-10.0.3.tgz",
      "integrity": "sha512-sNiLY51vZOmSPFZA5TF35KZ2HbgYklQnTSDnkghamzLb3EkNtcQnrBQEj5AOCxHpTtXpqMCRM1CrmV2rG6nw4g==",
      "license": "MIT",
      "dependencies": {
        "@apidevtools/json-schema-ref-parser": "^9.0.6",
        "@apidevtools/openapi-schemas": "^2.0.4",
        "@apidevtools/swagger-methods": "^3.0.2",
        "@jsdevtools/ono": "^7.1.3",
        "call-me-maybe": "^1.0.1",
        "z-schema": "^5.0.1"
      },
      "peerDependencies": {
        "openapi-types": ">=7"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.27.1.tgz",
      "integrity": "sha512-D2hP9eA+Sqx1kBZgzxZh0y1trbuU+JoDkiEwqhQ36nodYqJwyEIhPSdMNd7lOm/4io72luTPWH20Yda0xOuUow==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.27.5",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.27.5.tgz",
      "integrity": "sha512-OsQd175SxWkGlzbny8J3K8TnnDD0N3lrIUtB92xwyRpzaenGZhxDvxN/JgU00U3CDZNj9tPuDJ5H0WS4Nt3vKg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.27.3"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.27.6",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.27.6.tgz",
      "integrity": "sha512-ETyHEk2VHHvl9b9jZP5IHPavHYk57EhanlRRuae9XCpb/j5bDCbPPMOBfCWhnl/7EDJz0jEMCi/RhccCE8r1+Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@bcoe/v8-coverage": {
      "version": "0.2.3",
      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@cspotcode/source-map-support": {
      "version": "0.8.1",
      "resolved": "https://registry.npmjs.org/@cspotcode/source-map-support/-/source-map-support-0.8.1.tgz",
      "integrity": "sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/trace-mapping": "0.3.9"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@cspotcode/source-map-support/node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.9",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.9.tgz",
      "integrity": "sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.0.3",
        "@jridgewell/sourcemap-codec": "^1.4.10"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.21.5.tgz",
      "integrity": "sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@isaacs/cliui": {
      "version": "8.0.2",
      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "string-width": "^5.1.2",
        "string-width-cjs": "npm:string-width@^4.2.0",
        "strip-ansi": "^7.0.1",
        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
        "wrap-ansi": "^8.1.0",
        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
      "version": "6.1.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.1.0.tgz",
      "integrity": "sha512-7HSX4QQb4CspciLpVFwyRe79O3xsIZDDLER21kERQ71oaPodF8jL725AgJMFAYbooIqolJoRLuM81SpeUkpkvA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
      }
    },
    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.0.tgz",
      "integrity": "sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^6.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
      }
    },
    "node_modules/@istanbuljs/schema": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.8",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.8.tgz",
      "integrity": "sha512-imAbBGkb+ebQyxKgzv5Hu2nmROxoDOXHh80evxdoXNOrvAnVx7zimzc1Oo5h9RlfV4vPXaE2iM5pOFbvOCClWA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/set-array": "^1.2.1",
        "@jridgewell/sourcemap-codec": "^1.4.10",
        "@jridgewell/trace-mapping": "^0.3.24"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/set-array": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/@jridgewell/set-array/-/set-array-1.2.1.tgz",
      "integrity": "sha512-R8gLRTZeyp03ymzP/6Lil/28tGeGEzhx1q2k703KGWRAI1VdvPIXdG70VJc2pAMw3NA6JKL5hhFu1sJX0Mnn/A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.0.tgz",
      "integrity": "sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.25",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.25.tgz",
      "integrity": "sha512-vNk6aEwybGtawWmy/PzwnGDOjCkLWSD2wqvjGGAgOAwCGWySYXfYoxt00IJkTF+8Lb57DwOb3Aa0o9CApepiYQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@jsdevtools/ono": {
      "version": "7.1.3",
      "resolved": "https://registry.npmjs.org/@jsdevtools/ono/-/ono-7.1.3.tgz",
      "integrity": "sha512-4JQNk+3mVzK3xh2rqd6RB4J46qUR19azEHBneZyTZM+c456qOrbbM/5xcR8huNCCcbVt7+UmizG6GuUvPvKUYg==",
      "license": "MIT"
    },
    "node_modules/@lukeed/csprng": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@lukeed/csprng/-/csprng-1.1.0.tgz",
      "integrity": "sha512-Z7C/xXCiGWsg0KuKsHTKJxbWhpI3Vs5GwLfOean7MGyVFGqdRgBbAjOCh6u4bbjPc/8MJ2pZmK/0DLdCbivLDA==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@nestjs/common": {
      "version": "11.1.2",
      "resolved": "https://registry.npmjs.org/@nestjs/common/-/common-11.1.2.tgz",
      "integrity": "sha512-cHh4OPH44PjaHM93D1jgE1HO/B7XTZVRDxy/cPuGgyMEA4p2zXO+qqcOgTMC5FYcp7dX9jLeCjXAU0ToFAnODw==",
      "license": "MIT",
      "dependencies": {
        "file-type": "21.0.0",
        "iterare": "1.2.1",
        "load-esm": "1.0.2",
        "tslib": "2.8.1",
        "uid": "2.0.2"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/nest"
      },
      "peerDependencies": {
        "class-transformer": ">=0.4.1",
        "class-validator": ">=0.13.2",
        "reflect-metadata": "^0.1.12 || ^0.2.0",
        "rxjs": "^7.1.0"
      },
      "peerDependenciesMeta": {
        "class-transformer": {
          "optional": true
        },
        "class-validator": {
          "optional": true
        }
      }
    },
    "node_modules/@nestjs/core": {
      "version": "11.1.2",
      "resolved": "https://registry.npmjs.org/@nestjs/core/-/core-11.1.2.tgz",
      "integrity": "sha512-QRuyxwu0BjNfmmmunsw1ylX7RSyfDQHt+xD+tKncdtgiMOOzAu+LA1gB4WoZnw4frQkk+qZbhEbM61cIjOxD3w==",
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "@nuxt/opencollective": "0.4.1",
        "fast-safe-stringify": "2.1.1",
        "iterare": "1.2.1",
        "path-to-regexp": "8.2.0",
        "tslib": "2.8.1",
        "uid": "2.0.2"
      },
      "engines": {
        "node": ">= 20"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/nest"
      },
      "peerDependencies": {
        "@nestjs/common": "^11.0.0",
        "@nestjs/microservices": "^11.0.0",
        "@nestjs/platform-express": "^11.0.0",
        "@nestjs/websockets": "^11.0.0",
        "reflect-metadata": "^0.1.12 || ^0.2.0",
        "rxjs": "^7.1.0"
      },
      "peerDependenciesMeta": {
        "@nestjs/microservices": {
          "optional": true
        },
        "@nestjs/platform-express": {
          "optional": true
        },
        "@nestjs/websockets": {
          "optional": true
        }
      }
    },
    "node_modules/@nestjs/core/node_modules/path-to-regexp": {
      "version": "8.2.0",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.2.0.tgz",
      "integrity": "sha512-TdrF7fW9Rphjq4RjrW0Kp2AW0Ahwu9sRGTkS6bvDi0SCwZlEZYmcfDbEsTz8RVk0EHIS/Vd1bv3JhG+1xZuAyQ==",
      "license": "MIT",
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/@noble/hashes": {
      "version": "1.8.0",
      "resolved": "https://registry.npmjs.org/@noble/hashes/-/hashes-1.8.0.tgz",
      "integrity": "sha512-jCs9ldd7NwzpgXDIf6P3+NrHh9/sD6CQdxHyjQI+h/6rDNo88ypBxxz45UDuZHz9r3tNz7N/VInSVoVdtXEI4A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^14.21.3 || >=16"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      }
    },
    "node_modules/@nuxt/opencollective": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/@nuxt/opencollective/-/opencollective-0.4.1.tgz",
      "integrity": "sha512-GXD3wy50qYbxCJ652bDrDzgMr3NFEkIS374+IgFQKkCvk9yiYcLvX2XDYr7UyQxf4wK0e+yqDYRubZ0DtOxnmQ==",
      "license": "MIT",
      "dependencies": {
        "consola": "^3.2.3"
      },
      "bin": {
        "opencollective": "bin/opencollective.js"
      },
      "engines": {
        "node": "^14.18.0 || >=16.10.0",
        "npm": ">=5.10.0"
      }
    },
    "node_modules/@paralleldrive/cuid2": {
      "version": "2.2.2",
      "resolved": "https://registry.npmjs.org/@paralleldrive/cuid2/-/cuid2-2.2.2.tgz",
      "integrity": "sha512-ZOBkgDwEdoYVlSeRbYYXs0S9MejQofiVYoTbKzy/6GQa39/q5tQU2IX46+shYnUkpEl3wc+J6wRlar7r2EK2xA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@noble/hashes": "^1.1.5"
      }
    },
    "node_modules/@pkgjs/parseargs": {
      "version": "0.11.0",
      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
      "dev": true,
      "license": "MIT",
      "optional": true,
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/@prisma/client": {
      "version": "6.9.0",
      "resolved": "https://registry.npmjs.org/@prisma/client/-/client-6.9.0.tgz",
      "integrity": "sha512-Gg7j1hwy3SgF1KHrh0PZsYvAaykeR0PaxusnLXydehS96voYCGt1U5zVR31NIouYc63hWzidcrir1a7AIyCsNQ==",
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "peerDependencies": {
        "prisma": "*",
        "typescript": ">=5.1.0"
      },
      "peerDependenciesMeta": {
        "prisma": {
          "optional": true
        },
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@prisma/config": {
      "version": "6.9.0",
      "resolved": "https://registry.npmjs.org/@prisma/config/-/config-6.9.0.tgz",
      "integrity": "sha512-Wcfk8/lN3WRJd5w4jmNQkUwhUw0eksaU/+BlAJwPQKW10k0h0LC9PD/6TQFmqKVbHQL0vG2z266r0S1MPzzhbA==",
      "devOptional": true,
      "license": "Apache-2.0",
      "dependencies": {
        "jiti": "2.4.2"
      }
    },
    "node_modules/@prisma/debug": {
      "version": "6.9.0",
      "resolved": "https://registry.npmjs.org/@prisma/debug/-/debug-6.9.0.tgz",
      "integrity": "sha512-bFeur/qi/Q+Mqk4JdQ3R38upSYPebv5aOyD1RKywVD+rAMLtRkmTFn28ZuTtVOnZHEdtxnNOCH+bPIeSGz1+Fg==",
      "devOptional": true,
      "license": "Apache-2.0"
    },
    "node_modules/@prisma/engines": {
      "version": "6.9.0",
      "resolved": "https://registry.npmjs.org/@prisma/engines/-/engines-6.9.0.tgz",
      "integrity": "sha512-im0X0bwDLA0244CDf8fuvnLuCQcBBdAGgr+ByvGfQY9wWl6EA+kRGwVk8ZIpG65rnlOwtaWIr/ZcEU5pNVvq9g==",
      "devOptional": true,
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.9.0",
        "@prisma/engines-version": "6.9.0-10.81e4af48011447c3cc503a190e86995b66d2a28e",
        "@prisma/fetch-engine": "6.9.0",
        "@prisma/get-platform": "6.9.0"
      }
    },
    "node_modules/@prisma/engines-version": {
      "version": "6.9.0-10.81e4af48011447c3cc503a190e86995b66d2a28e",
      "resolved": "https://registry.npmjs.org/@prisma/engines-version/-/engines-version-6.9.0-10.81e4af48011447c3cc503a190e86995b66d2a28e.tgz",
      "integrity": "sha512-Qp9gMoBHgqhKlrvumZWujmuD7q4DV/gooEyPCLtbkc13EZdSz2RsGUJ5mHb3RJgAbk+dm6XenqG7obJEhXcJ6Q==",
      "devOptional": true,
      "license": "Apache-2.0"
    },
    "node_modules/@prisma/fetch-engine": {
      "version": "6.9.0",
      "resolved": "https://registry.npmjs.org/@prisma/fetch-engine/-/fetch-engine-6.9.0.tgz",
      "integrity": "sha512-PMKhJdl4fOdeE3J3NkcWZ+tf3W6rx3ht/rLU8w4SXFRcLhd5+3VcqY4Kslpdm8osca4ej3gTfB3+cSk5pGxgFg==",
      "devOptional": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.9.0",
        "@prisma/engines-version": "6.9.0-10.81e4af48011447c3cc503a190e86995b66d2a28e",
        "@prisma/get-platform": "6.9.0"
      }
    },
    "node_modules/@prisma/get-platform": {
      "version": "6.9.0",
      "resolved": "https://registry.npmjs.org/@prisma/get-platform/-/get-platform-6.9.0.tgz",
      "integrity": "sha512-/B4n+5V1LI/1JQcHp+sUpyRT1bBgZVPHbsC4lt4/19Xp4jvNIVcq5KYNtQDk5e/ukTSjo9PZVAxxy9ieFtlpTQ==",
      "devOptional": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.9.0"
      }
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.41.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.41.1.tgz",
      "integrity": "sha512-Wq2zpapRYLfi4aKxf2Xff0tN+7slj2d4R87WEzqw7ZLsVvO5zwYCIuEGSZYiK41+GlwUo1HiR+GdkLEJnCKTCw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@scarf/scarf": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/@scarf/scarf/-/scarf-1.4.0.tgz",
      "integrity": "sha512-xxeapPiUXdZAE3che6f3xogoJPeZgig6omHEy1rIY5WVsB3H2BHNnZH+gHG6x91SCWyQCzWGsuL2Hh3ClO5/qQ==",
      "hasInstallScript": true,
      "license": "Apache-2.0"
    },
    "node_modules/@tokenizer/inflate": {
      "version": "0.2.7",
      "resolved": "https://registry.npmjs.org/@tokenizer/inflate/-/inflate-0.2.7.tgz",
      "integrity": "sha512-MADQgmZT1eKjp06jpI2yozxaU9uVs4GzzgSL+uEq7bVcJ9V1ZXQkeGNql1fsSI0gMy1vhvNTNbUqrx+pZfJVmg==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.0",
        "fflate": "^0.8.2",
        "token-types": "^6.0.0"
      },
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/Borewit"
      }
    },
    "node_modules/@tokenizer/token": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/@tokenizer/token/-/token-0.3.0.tgz",
      "integrity": "sha512-OvjF+z51L3ov0OyAU0duzsYuvO01PH7x4t6DJx+guahgTnBHkhJdG7soQeTSFLWN3efnHyibZ4Z8l2EuWwJN3A==",
      "license": "MIT"
    },
    "node_modules/@tsconfig/node10": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node10/-/node10-1.0.11.tgz",
      "integrity": "sha512-DcRjDCujK/kCk/cUe8Xz8ZSpm8mS3mNNpta+jGCA6USEDfktlNvm1+IuZ9eTcDbNk41BHwpHHeW+N1lKCz4zOw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node12": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node12/-/node12-1.0.11.tgz",
      "integrity": "sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node14": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@tsconfig/node14/-/node14-1.0.3.tgz",
      "integrity": "sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node16": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/@tsconfig/node16/-/node16-1.0.4.tgz",
      "integrity": "sha512-vxhUy4J8lyeyinH7Azl1pdd43GJhZH/tP2weN8TntQblOY+A0XbT8DJk1/oCPuOOyg/Ja757rG0CgHcWC8OfMA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/bcryptjs": {
      "version": "2.4.6",
      "resolved": "https://registry.npmjs.org/@types/bcryptjs/-/bcryptjs-2.4.6.tgz",
      "integrity": "sha512-9xlo6R2qDs5uixm0bcIqCeMCE6HiQsIyel9KQySStiyqNl2tnj2mP3DX1Nf56MD6KMenNNlBBsy3LJ7gUEQPXQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/body-parser": {
      "version": "1.19.5",
      "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.5.tgz",
      "integrity": "sha512-fB3Zu92ucau0iQ0JMCFQE7b/dv8Ot07NI3KaZIkIUNXq82k4eBAqUaneXfleGY9JWskeS9y+u0nXMyspcuQrCg==",
      "license": "MIT",
      "dependencies": {
        "@types/connect": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/body-parser/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/connect": {
      "version": "3.4.38",
      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.38.tgz",
      "integrity": "sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/connect/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/cookiejar": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/@types/cookiejar/-/cookiejar-2.1.5.tgz",
      "integrity": "sha512-he+DHOWReW0nghN24E1WUqM0efK4kI9oTqDm6XmK8ZPe2djZ90BSNdGnIyCLzCPw7/pogPlGbzI2wHGGmi4O/Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/cors": {
      "version": "2.8.18",
      "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.18.tgz",
      "integrity": "sha512-nX3d0sxJW41CqQvfOzVG1NCTXfFDrDWIghCZncpHeWlVFd81zxB/DLhg7avFg6eHLCRX7ckBmoIIcqa++upvJA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/cors/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/date-fns": {
      "version": "2.6.3",
      "resolved": "https://registry.npmjs.org/@types/date-fns/-/date-fns-2.6.3.tgz",
      "integrity": "sha512-Ke1lw2Ni1t/wMUoLtKFmSNCLozcTBd6vmMqFP4hRzXn6qzkNt97bPAX0x5Y/c15DP43kKvwW1ycStD5+43jVQA==",
      "deprecated": "This is a stub types definition. date-fns provides its own type definitions, so you do not need this installed.",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "date-fns": "*"
      }
    },
    "node_modules/@types/date-fns/node_modules/date-fns": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/date-fns/-/date-fns-4.1.0.tgz",
      "integrity": "sha512-Ukq0owbQXxa/U3EGtsdVBkR1w7KOQ5gIBqdH2hkvknzZPYvBxb/aa6E8L7tmjFtkwZBu3UXBbjIgPo/Ez4xaNg==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/kossnocorp"
      }
    },
    "node_modules/@types/dotenv": {
      "version": "8.2.3",
      "resolved": "https://registry.npmjs.org/@types/dotenv/-/dotenv-8.2.3.tgz",
      "integrity": "sha512-g2FXjlDX/cYuc5CiQvyU/6kkbP1JtmGzh0obW50zD7OKeILVL0NSpPWLXVfqoAGQjom2/SLLx9zHq0KXvD6mbw==",
      "deprecated": "This is a stub types definition. dotenv provides its own type definitions, so you do not need this installed.",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "dotenv": "*"
      }
    },
    "node_modules/@types/estree": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.7.tgz",
      "integrity": "sha512-w28IoSUCJpidD/TGviZwwMJckNESJZXFu7NBZ5YJ4mEUnNraUn9Pm8HSZm/jDF1pDWYKspWE7oVphigUPRakIQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/express": {
      "version": "4.17.22",
      "resolved": "https://registry.npmjs.org/@types/express/-/express-4.17.22.tgz",
      "integrity": "sha512-eZUmSnhRX9YRSkplpz0N+k6NljUUn5l3EWZIKZvYzhvMphEuNiyyy1viH/ejgt66JWgALwC/gtSUAeQKtSwW/w==",
      "license": "MIT",
      "dependencies": {
        "@types/body-parser": "*",
        "@types/express-serve-static-core": "^4.17.33",
        "@types/qs": "*",
        "@types/serve-static": "*"
      }
    },
    "node_modules/@types/express-serve-static-core": {
      "version": "4.19.6",
      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-4.19.6.tgz",
      "integrity": "sha512-N4LZ2xG7DatVqhCZzOGb1Yi5lMbXSZcmdLDe9EzSndPV2HpWYWzRbaerl2n27irrm94EPpprqa8KpskPT085+A==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "*",
        "@types/qs": "*",
        "@types/range-parser": "*",
        "@types/send": "*"
      }
    },
    "node_modules/@types/express-serve-static-core/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/http-errors": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/@types/http-errors/-/http-errors-2.0.4.tgz",
      "integrity": "sha512-D0CFMMtydbJAegzOyHjtiKPLlvnm3iTZyZRSZoLq2mRhDdmLfIWOCYPfQJ4cu2erKghU++QvjcUjp/5h7hESpA==",
      "license": "MIT"
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.15",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
      "license": "MIT"
    },
    "node_modules/@types/jsonwebtoken": {
      "version": "9.0.9",
      "resolved": "https://registry.npmjs.org/@types/jsonwebtoken/-/jsonwebtoken-9.0.9.tgz",
      "integrity": "sha512-uoe+GxEuHbvy12OUQct2X9JenKM3qAscquYymuQN4fMWG9DBQtykrQEFcAbVACF7qaLw9BePSodUL0kquqBJpQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/ms": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/jsonwebtoken/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/methods": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/@types/methods/-/methods-1.1.4.tgz",
      "integrity": "sha512-ymXWVrDiCxTBE3+RIrrP533E70eA+9qu7zdWoHuOmGujkYtzf4HQF96b8nwHLqhuf4ykX61IGRIB38CC6/sImQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/mime": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/@types/mime/-/mime-1.3.5.tgz",
      "integrity": "sha512-/pyBZWSLD2n0dcHE3hq8s8ZvcETHtEuF+3E7XVt0Ig2nvsVQXdghHVcEkIWjy9A0wKfTn97a/PSDYohKIlnP/w==",
      "license": "MIT"
    },
    "node_modules/@types/ms": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/@types/ms/-/ms-2.1.0.tgz",
      "integrity": "sha512-GsCCIZDE/p3i96vtEqx+7dBUGXrc7zeSK3wwPHIaRThS+9OhWIXRqzs4d6k1SVU8g91DrNRWxWUGhp5KXQb2VA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/multer": {
      "version": "1.4.12",
      "resolved": "https://registry.npmjs.org/@types/multer/-/multer-1.4.12.tgz",
      "integrity": "sha512-pQ2hoqvXiJt2FP9WQVLPRO+AmiIm/ZYkavPlIQnx282u4ZrVdztx0pkh3jjpQt0Kz+YI0YhSG264y08UJKoUQg==",
      "license": "MIT",
      "dependencies": {
        "@types/express": "*"
      }
    },
    "node_modules/@types/node": {
      "version": "20.19.1",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-20.19.1.tgz",
      "integrity": "sha512-jJD50LtlD2dodAEO653i3YF04NWak6jN3ky+Ri3Em3mGR39/glWiboM/IePaRbgwSfqM1TpGXfAg8ohn/4dTgA==",
      "dev": true,
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/node-cron": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@types/node-cron/-/node-cron-3.0.11.tgz",
      "integrity": "sha512-0ikrnug3/IyneSHqCBeslAhlK2aBfYek1fGo4bP4QnZPmiqSGRK+Oy7ZMisLWkesffJvQ1cqAcBnJC+8+nxIAg==",
      "license": "MIT"
    },
    "node_modules/@types/qs": {
      "version": "6.14.0",
      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.14.0.tgz",
      "integrity": "sha512-eOunJqu0K1923aExK6y8p6fsihYEn/BYuQ4g0CxAAgFc4b/ZLN4CrsRZ55srTdqoiLzU2B2evC+apEIxprEzkQ==",
      "license": "MIT"
    },
    "node_modules/@types/range-parser": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.7.tgz",
      "integrity": "sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ==",
      "license": "MIT"
    },
    "node_modules/@types/send": {
      "version": "0.17.4",
      "resolved": "https://registry.npmjs.org/@types/send/-/send-0.17.4.tgz",
      "integrity": "sha512-x2EM6TJOybec7c52BX0ZspPodMsQUd5L6PRwOunVyVUhXiBSKf3AezDL8Dgvgt5o0UfKNfuA0eMLr2wLT4AiBA==",
      "license": "MIT",
      "dependencies": {
        "@types/mime": "^1",
        "@types/node": "*"
      }
    },
    "node_modules/@types/send/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/serve-static": {
      "version": "1.15.7",
      "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-1.15.7.tgz",
      "integrity": "sha512-W8Ym+h8nhuRwaKPaDw34QUkwsGi6Rc4yYqvKFo5rm2FUEhCFbzVWrxXUxuKK8TASjWsysJY0nsmNCGhCOIsrOw==",
      "license": "MIT",
      "dependencies": {
        "@types/http-errors": "*",
        "@types/node": "*",
        "@types/send": "*"
      }
    },
    "node_modules/@types/serve-static/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/streamifier": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/@types/streamifier/-/streamifier-0.1.2.tgz",
      "integrity": "sha512-W53GwxY5Tunz3JUoP1YWDidrAadenSZKOBKMRl6RO3yThOFd03w7yx3HypI8ABGuUCGDHCHUml/5e45FWRt1TQ==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/streamifier/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/strip-bom": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@types/strip-bom/-/strip-bom-3.0.0.tgz",
      "integrity": "sha512-xevGOReSYGM7g/kUBZzPqCrR/KYAo+F0yiPc85WFTJa0MSLtyFTVTU6cJu/aV4mid7IffDIWqo69THF2o4JiEQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/strip-json-comments": {
      "version": "0.0.30",
      "resolved": "https://registry.npmjs.org/@types/strip-json-comments/-/strip-json-comments-0.0.30.tgz",
      "integrity": "sha512-7NQmHra/JILCd1QqpSzl8+mJRc8ZHz3uDm8YV1Ks9IhK0epEiTw8aIErbvH9PI+6XbqhyIQy3462nEsn7UVzjQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/superagent": {
      "version": "8.1.9",
      "resolved": "https://registry.npmjs.org/@types/superagent/-/superagent-8.1.9.tgz",
      "integrity": "sha512-pTVjI73witn+9ILmoJdajHGW2jkSaOzhiFYF1Rd3EQ94kymLqB9PjD9ISg7WaALC7+dCHT0FGe9T2LktLq/3GQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/cookiejar": "^2.1.5",
        "@types/methods": "^1.1.4",
        "@types/node": "*",
        "form-data": "^4.0.0"
      }
    },
    "node_modules/@types/superagent/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/supertest": {
      "version": "6.0.3",
      "resolved": "https://registry.npmjs.org/@types/supertest/-/supertest-6.0.3.tgz",
      "integrity": "sha512-8WzXq62EXFhJ7QsH3Ocb/iKQ/Ty9ZVWnVzoTKc9tyyFRRF3a74Tk2+TLFgaFFw364Ere+npzHKEJ6ga2LzIL7w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/methods": "^1.1.4",
        "@types/superagent": "^8.1.0"
      }
    },
    "node_modules/@types/swagger-jsdoc": {
      "version": "6.0.4",
      "resolved": "https://registry.npmjs.org/@types/swagger-jsdoc/-/swagger-jsdoc-6.0.4.tgz",
      "integrity": "sha512-W+Xw5epcOZrF/AooUM/PccNMSAFOKWZA5dasNyMujTwsBkU74njSJBpvCCJhHAJ95XRMzQrrW844Btu0uoetwQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/swagger-ui-express": {
      "version": "4.1.8",
      "resolved": "https://registry.npmjs.org/@types/swagger-ui-express/-/swagger-ui-express-4.1.8.tgz",
      "integrity": "sha512-AhZV8/EIreHFmBV5wAs0gzJUNq9JbbSXgJLQubCC0jtIo6prnI9MIRRxnU4MZX9RB9yXxF1V4R7jtLl/Wcj31g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/express": "*",
        "@types/serve-static": "*"
      }
    },
    "node_modules/@types/uuid": {
      "version": "10.0.0",
      "resolved": "https://registry.npmjs.org/@types/uuid/-/uuid-10.0.0.tgz",
      "integrity": "sha512-7gqG38EyHgyP1S+7+xomFtL+ZNHcKv6DwNaCZmJmo1vgMugyF3TCnXVg4t1uk89mLNwnLtnY3TpOpCOyp1/xHQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/validator": {
      "version": "13.15.1",
      "resolved": "https://registry.npmjs.org/@types/validator/-/validator-13.15.1.tgz",
      "integrity": "sha512-9gG6ogYcoI2mCMLdcO0NYI0AYrbxIjv0MDmy/5Ywo6CpWWrqYayc+mmgxRsCgtcGJm9BSbXkMsmxGah1iGHAAQ==",
      "license": "MIT"
    },
    "node_modules/@vitest/coverage-v8": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@ampproject/remapping": "^2.3.0",
        "@bcoe/v8-coverage": "^0.2.3",
        "debug": "^4.3.7",
        "istanbul-lib-coverage": "^3.2.2",
        "istanbul-lib-report": "^3.0.1",
        "istanbul-lib-source-maps": "^5.0.6",
        "istanbul-reports": "^3.1.7",
        "magic-string": "^0.30.12",
        "magicast": "^0.3.5",
        "std-env": "^3.8.0",
        "test-exclude": "^7.0.1",
        "tinyrainbow": "^1.2.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "@vitest/browser": "2.1.9",
        "vitest": "2.1.9"
      },
      "peerDependenciesMeta": {
        "@vitest/browser": {
          "optional": true
        }
      }
    },
    "node_modules/@vitest/expect": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
      "integrity": "sha512-UJCIkTBenHeKT1TTlKMJWy1laZewsRIzYighyYiJKZreqtdxSos/S1t+ktRMQWu2CKqaarrkeszJx1cgC5tGZw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/spy": "2.1.9",
        "@vitest/utils": "2.1.9",
        "chai": "^5.1.2",
        "tinyrainbow": "^1.2.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/mocker": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/mocker/-/mocker-2.1.9.tgz",
      "integrity": "sha512-tVL6uJgoUdi6icpxmdrn5YNo3g3Dxv+IHJBr0GXHaEdTcw3F+cPKnsXFhli6nO+f/6SDKPHEK1UN+k+TQv0Ehg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/spy": "2.1.9",
        "estree-walker": "^3.0.3",
        "magic-string": "^0.30.12"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "msw": "^2.4.9",
        "vite": "^5.0.0"
      },
      "peerDependenciesMeta": {
        "msw": {
          "optional": true
        },
        "vite": {
          "optional": true
        }
      }
    },
    "node_modules/@vitest/pretty-format": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/pretty-format/-/pretty-format-2.1.9.tgz",
      "integrity": "sha512-KhRIdGV2U9HOUzxfiHmY8IFHTdqtOhIzCpd8WRdJiE7D/HUcZVD0EgQCVjm+Q9gkUXWgBvMmTtZgIG48wq7sOQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tinyrainbow": "^1.2.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/runner": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/runner/-/runner-2.1.9.tgz",
      "integrity": "sha512-ZXSSqTFIrzduD63btIfEyOmNcBmQvgOVsPNPe0jYtESiXkhd8u2erDLnMxmGrDCwHCCHE7hxwRDCT3pt0esT4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/utils": "2.1.9",
        "pathe": "^1.1.2"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/snapshot": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/snapshot/-/snapshot-2.1.9.tgz",
      "integrity": "sha512-oBO82rEjsxLNJincVhLhaxxZdEtV0EFHMK5Kmx5sJ6H9L183dHECjiefOAdnqpIgT5eZwT04PoggUnW88vOBNQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/pretty-format": "2.1.9",
        "magic-string": "^0.30.12",
        "pathe": "^1.1.2"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/spy": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/spy/-/spy-2.1.9.tgz",
      "integrity": "sha512-E1B35FwzXXTs9FHNK6bDszs7mtydNi5MIfUWpceJ8Xbfb1gBMscAnwLbEu+B44ed6W3XjL9/ehLPHR1fkf1KLQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tinyspy": "^3.0.2"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/utils": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/utils/-/utils-2.1.9.tgz",
      "integrity": "sha512-v0psaMSkNJ3A2NMrUEHFRzJtDPFn+/VWZ5WxImB21T9fjucJRmS7xCS3ppEnARb9y11OAzaD+P2Ps+b+BGX5iQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/pretty-format": "2.1.9",
        "loupe": "^3.1.2",
        "tinyrainbow": "^1.2.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/accepts": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
      "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
      "license": "MIT",
      "dependencies": {
        "mime-types": "~2.1.34",
        "negotiator": "0.6.3"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/acorn": {
      "version": "8.14.1",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.14.1.tgz",
      "integrity": "sha512-OvQ/2pUDKmgfCg++xsTX1wGxfTaszcHVcTctW4UJB4hibJx2HXxxO5UmVgyjMa+ZDsiaf5wWLXYpRWMmBI0QHg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-walk": {
      "version": "8.3.4",
      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-8.3.4.tgz",
      "integrity": "sha512-ueEepnujpqee2o5aIYnvHU6C0A42MNdsIDeqy5BydrkuC5R1ZuUFnm27EeFJGoEHJQgn3uleRvmTXaJgfXbt4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "acorn": "^8.11.0"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/append-field": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/append-field/-/append-field-1.0.0.tgz",
      "integrity": "sha512-klpgFSWLW1ZEs8svjfb7g4qWY0YS5imI82dTg+QahUvJ8YqAY0P10Uk8tTyh9ZGuYEZEMaeJYCF5BFuX552hsw==",
      "license": "MIT"
    },
    "node_modules/arg": {
      "version": "4.1.3",
      "resolved": "https://registry.npmjs.org/arg/-/arg-4.1.3.tgz",
      "integrity": "sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "license": "Python-2.0"
    },
    "node_modules/array-flatten": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
      "integrity": "sha512-PCVAQswWemu6UdxsDFFX/+gVeYqKAod3D3UVm91jHwynguOwAvYPhx8nNlM++NqRcK6CxxpUafjmhIdKiHibqg==",
      "license": "MIT"
    },
    "node_modules/asap": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/asap/-/asap-2.0.6.tgz",
      "integrity": "sha512-BSHWgDSAiKs50o2Re8ppvp3seVHXSRM44cdSsT9FfNEUUZLOGWVCsiWaRPWM1Znn+mqZ1OfVZ3z3DWEzSp7hRA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/assertion-error": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/assertion-error/-/assertion-error-2.0.1.tgz",
      "integrity": "sha512-Izi8RQcffqCeNVgFigKli1ssklIbpHnCYc6AknXGYoB6grJqyeby7jv12JUQgmTAnIDnbck1uxksT4dzN3PWBA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "license": "MIT"
    },
    "node_modules/bcryptjs": {
      "version": "2.4.3",
      "resolved": "https://registry.npmjs.org/bcryptjs/-/bcryptjs-2.4.3.tgz",
      "integrity": "sha512-V/Hy/X9Vt7f3BbPJEi8BdVFMByHi+jNXrYkW3huaybV/kQ0KJg0Y6PkEMbn+zeT+i+SiKZ/HMqJGIIt4LZDqNQ==",
      "license": "MIT"
    },
    "node_modules/binary-extensions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
      "integrity": "sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/body-parser": {
      "version": "1.20.3",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.3.tgz",
      "integrity": "sha512-7rAxByjUMqQ3/bHJy7D6OGXvx/MMc4IqBn/X0fcM1QUcAItpZrBEYhWGem+tzXH90c+G01ypMcYJBO9Y30203g==",
      "license": "MIT",
      "dependencies": {
        "bytes": "3.1.2",
        "content-type": "~1.0.5",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "on-finished": "2.4.1",
        "qs": "6.13.0",
        "raw-body": "2.5.2",
        "type-is": "~1.6.18",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/body-parser/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "license": "MIT",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/body-parser/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "license": "MIT"
    },
    "node_modules/brace-expansion": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==",
      "license": "BSD-3-Clause"
    },
    "node_modules/buffer-from": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz",
      "integrity": "sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==",
      "license": "MIT"
    },
    "node_modules/busboy": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/busboy/-/busboy-1.6.0.tgz",
      "integrity": "sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA==",
      "dependencies": {
        "streamsearch": "^1.1.0"
      },
      "engines": {
        "node": ">=10.16.0"
      }
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/cac": {
      "version": "6.7.14",
      "resolved": "https://registry.npmjs.org/cac/-/cac-6.7.14.tgz",
      "integrity": "sha512-b6Ilus+c3RrdDk+JhLKUAQfzzgLEPy6wcXqS7f/xe1EETvsDP6GORG7SFuOs6cID5YkqchW/LXZbX5bc8j7ZcQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/call-me-maybe": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-me-maybe/-/call-me-maybe-1.0.2.tgz",
      "integrity": "sha512-HpX65o1Hnr9HH25ojC1YGs7HCQLq0GCOibSaWER0eNpgJ/Z1MZv2mTc7+xh6WOPxbRVcmgbv4hGU+uSQ/2xFZQ==",
      "license": "MIT"
    },
    "node_modules/chai": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/chai/-/chai-5.2.0.tgz",
      "integrity": "sha512-mCuXncKXk5iCLhfhwTc0izo0gtEmpz5CtG2y8GiOINBlMVS6v8TMRc5TaLWKS6692m9+dVVfzgeVxR5UxWHTYw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "assertion-error": "^2.0.1",
        "check-error": "^2.1.1",
        "deep-eql": "^5.0.1",
        "loupe": "^3.1.0",
        "pathval": "^2.0.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/check-error": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/check-error/-/check-error-2.1.1.tgz",
      "integrity": "sha512-OAlb+T7V4Op9OwdkjmguYRqncdlx5JiofwOAUkmTF+jNdHwzTaTs4sRAGpzLF3oOz5xAyDGrPgeIDFQmDOTiJw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 16"
      }
    },
    "node_modules/chokidar": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.6.0.tgz",
      "integrity": "sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      },
      "engines": {
        "node": ">= 8.10.0"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/class-transformer": {
      "version": "0.5.1",
      "resolved": "https://registry.npmjs.org/class-transformer/-/class-transformer-0.5.1.tgz",
      "integrity": "sha512-SQa1Ws6hUbfC98vKGxZH3KFY0Y1lm5Zm0SY8XX9zbK7FJCyVEac3ATW0RIpwzW+oOfmHE5PMPufDG9hCfoEOMw==",
      "license": "MIT"
    },
    "node_modules/class-validator": {
      "version": "0.14.2",
      "resolved": "https://registry.npmjs.org/class-validator/-/class-validator-0.14.2.tgz",
      "integrity": "sha512-3kMVRF2io8N8pY1IFIXlho9r8IPUUIfHe2hYVtiebvAzU2XeQFXTv+XI4WX+TnXmtwXMDcjngcpkiPM0O9PvLw==",
      "license": "MIT",
      "dependencies": {
        "@types/validator": "^13.11.8",
        "libphonenumber-js": "^1.11.1",
        "validator": "^13.9.0"
      }
    },
    "node_modules/cloudinary": {
      "version": "2.6.1",
      "resolved": "https://registry.npmjs.org/cloudinary/-/cloudinary-2.6.1.tgz",
      "integrity": "sha512-Dt7o3p4VzxYoTi+EqWkVQmGy6WiXIyMcG5Gbr9kPR/EQ+jZa+3FFzlDKfDx1uDsaB1aTR1gYeO6wZqrgLFaByQ==",
      "license": "MIT",
      "dependencies": {
        "lodash": "^4.17.21",
        "q": "^1.5.1"
      },
      "engines": {
        "node": ">=9"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/commander": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/commander/-/commander-6.2.0.tgz",
      "integrity": "sha512-zP4jEKbe8SHzKJYQmq8Y9gYjtO/POJLgIdKgV7B9qNmABVFVc+ctqSX6iXh4mCpJfRBOabiZ2YKPg8ciDw6C+Q==",
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/component-emitter": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/component-emitter/-/component-emitter-1.3.1.tgz",
      "integrity": "sha512-T0+barUSQRTUQASh8bx02dl+DhF54GtIDY13Y3m9oWTklKbb3Wv974meRpeZ3lp1JpLVECWWNHC4vaG2XHXouQ==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "license": "MIT"
    },
    "node_modules/concat-stream": {
      "version": "1.6.2",
      "resolved": "https://registry.npmjs.org/concat-stream/-/concat-stream-1.6.2.tgz",
      "integrity": "sha512-27HBghJxjiZtIk3Ycvn/4kbJk/1uZuJFfuPEns6LaEvpvG1f0hTea8lilrouyo9mVc2GWdcEZ8OLoGmSADlrCw==",
      "engines": [
        "node >= 0.8"
      ],
      "license": "MIT",
      "dependencies": {
        "buffer-from": "^1.0.0",
        "inherits": "^2.0.3",
        "readable-stream": "^2.2.2",
        "typedarray": "^0.0.6"
      }
    },
    "node_modules/consola": {
      "version": "3.4.2",
      "resolved": "https://registry.npmjs.org/consola/-/consola-3.4.2.tgz",
      "integrity": "sha512-5IKcdX0nnYavi6G7TtOhwkYzyjfJlatbjMjuLSfE2kYT5pMDOilZ4OvMhi637CcDICTmz3wARPoyhqyX1Y+XvA==",
      "license": "MIT",
      "engines": {
        "node": "^14.18.0 || >=16.10.0"
      }
    },
    "node_modules/content-disposition": {
      "version": "0.5.4",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.4.tgz",
      "integrity": "sha512-FveZTNuGw04cxlAiWbzi6zTAL/lhehaWbTtgluJh4/E95DqMwTmha3KZN1aAWA8cFIhHzMZUvLevkw5Rqk+tSQ==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "5.2.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.7.1",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.1.tgz",
      "integrity": "sha512-6DnInpx7SJ2AK3+CTUE/ZM0vWTUboZCegxhC2xiIydHR9jNuTAASBrfEpHhiGOZw/nX51bHt6YQl8jsGo4y/0w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.6.tgz",
      "integrity": "sha512-QADzlaHc8icV8I7vbaJXJwod9HWYp8uCqf1xa4OfNu1T7JVxQIrUgOWtHdNDtPiywmFbiS12VjotIXLrKM3orQ==",
      "license": "MIT"
    },
    "node_modules/cookiejar": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/cookiejar/-/cookiejar-2.1.4.tgz",
      "integrity": "sha512-LDx6oHrK+PhzLKJU9j5S7/Y3jM/mUHvD/DeI1WQmJn652iPC5Y4TBzC9l+5OMOXlyTTA+SmVUPm0HQUwpD5Jqw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/core-util-is": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.3.tgz",
      "integrity": "sha512-ZQBvi1DcpJ4GDqanjucZ2Hj3wEO5pZDS89BWbkcrvdxksJorwUDDZamX9ldFkp9aw2lmBDLgkObEA4DWNJ9FYQ==",
      "license": "MIT"
    },
    "node_modules/cors": {
      "version": "2.8.5",
      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
      "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
      "license": "MIT",
      "dependencies": {
        "object-assign": "^4",
        "vary": "^1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/create-require": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/create-require/-/create-require-1.1.1.tgz",
      "integrity": "sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/date-fns": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/date-fns/-/date-fns-3.6.0.tgz",
      "integrity": "sha512-fRHTG8g/Gif+kSh50gaGEdToemgfj74aRX3swtiouboip5JDLAyDE9F11nHMIcvOaXeOC6D7SpNhi7uFyB7Uww==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/kossnocorp"
      }
    },
    "node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/deep-eql": {
      "version": "5.0.2",
      "resolved": "https://registry.npmjs.org/deep-eql/-/deep-eql-5.0.2.tgz",
      "integrity": "sha512-h5k/5U50IJJFpzfL6nO9jaaumfjO/f2NjK/oYB2Djzm4p9L+3T9qWpZqZ2hAbLPuuYq9wrU08WQyBTL5GbPk5Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/destroy": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.2.0.tgz",
      "integrity": "sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/dezalgo": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/dezalgo/-/dezalgo-1.0.4.tgz",
      "integrity": "sha512-rXSP0bf+5n0Qonsb+SVVfNfIsimO4HEtmnIpPHY8Q1UCzKlQrDMfdobr8nJOOsRgWCyMRqeSBQzmWUMq7zvVig==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "asap": "^2.0.0",
        "wrappy": "1"
      }
    },
    "node_modules/diff": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.2.tgz",
      "integrity": "sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.3.1"
      }
    },
    "node_modules/doctrine": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
      "integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
      "license": "Apache-2.0",
      "dependencies": {
        "esutils": "^2.0.2"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/dotenv": {
      "version": "16.5.0",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-16.5.0.tgz",
      "integrity": "sha512-m/C+AwOAr9/W1UOIZUo232ejMNnJAJtYQjUbHoNTBNTJSvqzzDh7vnrei3o3r3m9blf6ZoDkvcw0VmozNRFJxg==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://dotenvx.com"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/dynamic-dedupe": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/dynamic-dedupe/-/dynamic-dedupe-0.3.0.tgz",
      "integrity": "sha512-ssuANeD+z97meYOqd50e04Ze5qp4bPqo8cCkI4TRjZkzAUgIDTrXV1R8QCdINpiI+hw14+rYazvTRdQrz0/rFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "xtend": "^4.0.0"
      }
    },
    "node_modules/eastasianwidth": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
      "license": "MIT"
    },
    "node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/encodeurl": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-module-lexer": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-1.7.0.tgz",
      "integrity": "sha512-jEQoCwk8hyb2AZziIOLhDqpm5+2ww5uIE6lkO/6jcOCusfk6LhMHpXXfBLXTZ7Ydyt0j4VoUQv6uGNYbdW+kBA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/esbuild": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.21.5.tgz",
      "integrity": "sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=12"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.21.5",
        "@esbuild/android-arm": "0.21.5",
        "@esbuild/android-arm64": "0.21.5",
        "@esbuild/android-x64": "0.21.5",
        "@esbuild/darwin-arm64": "0.21.5",
        "@esbuild/darwin-x64": "0.21.5",
        "@esbuild/freebsd-arm64": "0.21.5",
        "@esbuild/freebsd-x64": "0.21.5",
        "@esbuild/linux-arm": "0.21.5",
        "@esbuild/linux-arm64": "0.21.5",
        "@esbuild/linux-ia32": "0.21.5",
        "@esbuild/linux-loong64": "0.21.5",
        "@esbuild/linux-mips64el": "0.21.5",
        "@esbuild/linux-ppc64": "0.21.5",
        "@esbuild/linux-riscv64": "0.21.5",
        "@esbuild/linux-s390x": "0.21.5",
        "@esbuild/linux-x64": "0.21.5",
        "@esbuild/netbsd-x64": "0.21.5",
        "@esbuild/openbsd-x64": "0.21.5",
        "@esbuild/sunos-x64": "0.21.5",
        "@esbuild/win32-arm64": "0.21.5",
        "@esbuild/win32-ia32": "0.21.5",
        "@esbuild/win32-x64": "0.21.5"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
      "license": "MIT"
    },
    "node_modules/estree-walker": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/estree-walker/-/estree-walker-3.0.3.tgz",
      "integrity": "sha512-7RUKfXgSMMkzt6ZuXmqapOurLGPPfgj6l9uRZ7lRGolvk0y2yocc35LdcxKC5PQZdn2DMqioAQ2NoWcrTKmm6g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "^1.0.0"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/expect-type": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/expect-type/-/expect-type-1.2.1.tgz",
      "integrity": "sha512-/kP8CAwxzLVEeFrMm4kMmy4CCDlpipyA7MYLVrdJIkV0fYF0UaigQHRsxHiuY/GEea+bh4KSv3TIlgr+2UL6bw==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/express": {
      "version": "4.21.2",
      "resolved": "https://registry.npmjs.org/express/-/express-4.21.2.tgz",
      "integrity": "sha512-28HqgMZAmih1Czt9ny7qr6ek2qddF4FclbMzwhCREB6OFfH+rXAnuNCwo1/wFvrtbgsQDb4kSbX9de9lFbrXnA==",
      "license": "MIT",
      "dependencies": {
        "accepts": "~1.3.8",
        "array-flatten": "1.1.1",
        "body-parser": "1.20.3",
        "content-disposition": "0.5.4",
        "content-type": "~1.0.4",
        "cookie": "0.7.1",
        "cookie-signature": "1.0.6",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "finalhandler": "1.3.1",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "merge-descriptors": "1.0.3",
        "methods": "~1.1.2",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "path-to-regexp": "0.1.12",
        "proxy-addr": "~2.0.7",
        "qs": "6.13.0",
        "range-parser": "~1.2.1",
        "safe-buffer": "5.2.1",
        "send": "0.19.0",
        "serve-static": "1.16.2",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "type-is": "~1.6.18",
        "utils-merge": "1.0.1",
        "vary": "~1.1.2"
      },
      "engines": {
        "node": ">= 0.10.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/express/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "license": "MIT",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/express/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "license": "MIT"
    },
    "node_modules/fast-safe-stringify": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/fast-safe-stringify/-/fast-safe-stringify-2.1.1.tgz",
      "integrity": "sha512-W+KJc2dmILlPplD/H4K9l9LcAHAfPtP6BY84uVLXQ6Evcz9Lcg33Y2z1IVblT6xdY54PXYVHEv+0Wpq8Io6zkA==",
      "license": "MIT"
    },
    "node_modules/fflate": {
      "version": "0.8.2",
      "resolved": "https://registry.npmjs.org/fflate/-/fflate-0.8.2.tgz",
      "integrity": "sha512-cPJU47OaAoCbg0pBvzsgpTPhmhqI5eJjh/JIu8tPj5q+T7iLvW/JAYUqmE7KOB4R1ZyEhzBaIQpQpardBF5z8A==",
      "license": "MIT"
    },
    "node_modules/file-type": {
      "version": "21.0.0",
      "resolved": "https://registry.npmjs.org/file-type/-/file-type-21.0.0.tgz",
      "integrity": "sha512-ek5xNX2YBYlXhiUXui3D/BXa3LdqPmoLJ7rqEx2bKJ7EAUEfmXgW0Das7Dc6Nr9MvqaOnIqiPV0mZk/r/UpNAg==",
      "license": "MIT",
      "dependencies": {
        "@tokenizer/inflate": "^0.2.7",
        "strtok3": "^10.2.2",
        "token-types": "^6.0.0",
        "uint8array-extras": "^1.4.0"
      },
      "engines": {
        "node": ">=20"
      },
      "funding": {
        "url": "https://github.com/sindresorhus/file-type?sponsor=1"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/finalhandler": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.3.1.tgz",
      "integrity": "sha512-6BN9trH7bp3qvnrRyzsBz+g3lZxTNZTbVO2EV1CS0WIcDbawYVdYvGflME/9QP0h0pYlCDBCTjYa9nZzMDpyxQ==",
      "license": "MIT",
      "dependencies": {
        "debug": "2.6.9",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "statuses": "2.0.1",
        "unpipe": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/finalhandler/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "license": "MIT",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/finalhandler/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "license": "MIT"
    },
    "node_modules/foreground-child": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "cross-spawn": "^7.0.6",
        "signal-exit": "^4.0.1"
      },
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/form-data": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.2.tgz",
      "integrity": "sha512-hGfm/slu0ZabnNt4oaRZ6uREyfCj6P4fT/n6A1rGV+Z0VdGXjfOhVUpkn6qVQONHGIFwmveGXyDs75+nr6FM8w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/formidable": {
      "version": "3.5.4",
      "resolved": "https://registry.npmjs.org/formidable/-/formidable-3.5.4.tgz",
      "integrity": "sha512-YikH+7CUTOtP44ZTnUhR7Ic2UASBPOqmaRkRKxRbywPTe5VxF7RRCck4af9wutiZ/QKM5nME9Bie2fFaPz5Gug==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@paralleldrive/cuid2": "^2.2.2",
        "dezalgo": "^1.0.4",
        "once": "^1.4.0"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "funding": {
        "url": "https://ko-fi.com/tunnckoCore/commissions"
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
      "integrity": "sha512-zJ2mQYM18rEFOudeV4GShTGIQ7RbzA7ozbU9I/XBpm7kqgMywgmylMwXHxZJmkVoYkna9d2pVXVXPdYTP9ej8Q==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==",
      "license": "ISC"
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/glob": {
      "version": "7.1.6",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.1.6.tgz",
      "integrity": "sha512-LwaxwyZ72Lk7vZINtNNrywX0ZuLyStrdDtabefZKAY5ZGJhVtgdznluResxNmPitE0SAO+O26sWTHeKSI2wMBA==",
      "license": "ISC",
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.0.4",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-flag": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
      "integrity": "sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/html-escaper": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
      "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
      "license": "MIT",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/ieee754": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
      "integrity": "sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "BSD-3-Clause"
    },
    "node_modules/ignore-by-default": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/ignore-by-default/-/ignore-by-default-1.0.1.tgz",
      "integrity": "sha512-Ius2VYcGNk7T90CppJqcIkS5ooHUZyIQK+ClZfMfMNFEF9VSE73Fq+906u/CWu92x4gzZMWOwfFYckPObzdEbA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==",
      "license": "ISC",
      "dependencies": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "license": "ISC"
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "binary-extensions": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/isarray": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-1.0.0.tgz",
      "integrity": "sha512-VLghIWNM6ELQzo7zwmcg0NmTVyWKYjvIeM83yjp0wRDTmUnrM678fQbcKBo6n2CJEF0szoG//ytg+TKla89ALQ==",
      "license": "MIT"
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/istanbul-lib-coverage": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/istanbul-lib-report": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "istanbul-lib-coverage": "^3.0.0",
        "make-dir": "^4.0.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-lib-report/node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/istanbul-lib-report/node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/istanbul-lib-source-maps": {
      "version": "5.0.6",
      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "@jridgewell/trace-mapping": "^0.3.23",
        "debug": "^4.1.1",
        "istanbul-lib-coverage": "^3.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-reports": {
      "version": "3.1.7",
      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.1.7.tgz",
      "integrity": "sha512-BewmUXImeuRk2YY0PVbxgKAysvhRPUQE0h5QRM++nVWyubKGV0l8qQ5op8+B2DOmwSe63Jivj0BjkPQVf8fP5g==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "html-escaper": "^2.0.0",
        "istanbul-lib-report": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/iterare": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/iterare/-/iterare-1.2.1.tgz",
      "integrity": "sha512-RKYVTCjAnRthyJes037NX/IiqeidgN1xc3j1RjFfECFp28A1GVwK9nA+i0rJPaHqSZwygLzRnFlzUuHFoWWy+Q==",
      "license": "ISC",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/jackspeak": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "@isaacs/cliui": "^8.0.2"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      },
      "optionalDependencies": {
        "@pkgjs/parseargs": "^0.11.0"
      }
    },
    "node_modules/jiti": {
      "version": "2.4.2",
      "resolved": "https://registry.npmjs.org/jiti/-/jiti-2.4.2.tgz",
      "integrity": "sha512-rg9zJN+G4n2nfJl5MW3BMygZX56zKPNVEYYqq7adpmMh4Jn2QNEwhvQlFy6jPVdcod7txZtKHWnyZiA3a0zP7A==",
      "devOptional": true,
      "license": "MIT",
      "bin": {
        "jiti": "lib/jiti-cli.mjs"
      }
    },
    "node_modules/js-yaml": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
      "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
      "license": "MIT",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/jsonwebtoken": {
      "version": "9.0.2",
      "resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-9.0.2.tgz",
      "integrity": "sha512-PRp66vJ865SSqOlgqS8hujT5U4AOgMfhrwYIuIhfKaoSCZcirrmASQr8CX7cUg+RMih+hgznrjp99o+W4pJLHQ==",
      "license": "MIT",
      "dependencies": {
        "jws": "^3.2.2",
        "lodash.includes": "^4.3.0",
        "lodash.isboolean": "^3.0.3",
        "lodash.isinteger": "^4.0.4",
        "lodash.isnumber": "^3.0.3",
        "lodash.isplainobject": "^4.0.6",
        "lodash.isstring": "^4.0.1",
        "lodash.once": "^4.0.0",
        "ms": "^2.1.1",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      }
    },
    "node_modules/jwa": {
      "version": "1.4.2",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-1.4.2.tgz",
      "integrity": "sha512-eeH5JO+21J78qMvTIDdBXidBd6nG2kZjg5Ohz/1fpa28Z4CcsWUzJ1ZZyFq/3z3N17aZy+ZuBoHljASbL1WfOw==",
      "license": "MIT",
      "dependencies": {
        "buffer-equal-constant-time": "^1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jws": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/jws/-/jws-3.2.2.tgz",
      "integrity": "sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==",
      "license": "MIT",
      "dependencies": {
        "jwa": "^1.4.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/libphonenumber-js": {
      "version": "1.12.9",
      "resolved": "https://registry.npmjs.org/libphonenumber-js/-/libphonenumber-js-1.12.9.tgz",
      "integrity": "sha512-VWwAdNeJgN7jFOD+wN4qx83DTPMVPPAUyx9/TUkBXKLiNkuWWk6anV0439tgdtwaJDrEdqkvdN22iA6J4bUCZg==",
      "license": "MIT"
    },
    "node_modules/load-esm": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/load-esm/-/load-esm-1.0.2.tgz",
      "integrity": "sha512-nVAvWk/jeyrWyXEAs84mpQCYccxRqgKY4OznLuJhJCa0XsPSfdOIr2zvBZEj3IHEHbX97jjscKRRV539bW0Gpw==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/Borewit"
        },
        {
          "type": "buymeacoffee",
          "url": "https://buymeacoffee.com/borewit"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=13.2.0"
      }
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "license": "MIT"
    },
    "node_modules/lodash.get": {
      "version": "4.4.2",
      "resolved": "https://registry.npmjs.org/lodash.get/-/lodash.get-4.4.2.tgz",
      "integrity": "sha512-z+Uw/vLuy6gQe8cfaFWD7p0wVv8fJl3mbzXh33RS+0oW2wvUqiRXiQ69gLWSLpgB5/6sU+r6BlQR0MBILadqTQ==",
      "license": "MIT"
    },
    "node_modules/lodash.includes": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/lodash.includes/-/lodash.includes-4.3.0.tgz",
      "integrity": "sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w==",
      "license": "MIT"
    },
    "node_modules/lodash.isboolean": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isboolean/-/lodash.isboolean-3.0.3.tgz",
      "integrity": "sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg==",
      "license": "MIT"
    },
    "node_modules/lodash.isequal": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/lodash.isequal/-/lodash.isequal-4.5.0.tgz",
      "integrity": "sha512-pDo3lu8Jhfjqls6GkMgpahsF9kCyayhgykjyLMNFTKWrpVdAQtYyB4muAMWozBB4ig/dtWAmsMxLEI8wuz+DYQ==",
      "license": "MIT"
    },
    "node_modules/lodash.isinteger": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/lodash.isinteger/-/lodash.isinteger-4.0.4.tgz",
      "integrity": "sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA==",
      "license": "MIT"
    },
    "node_modules/lodash.isnumber": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isnumber/-/lodash.isnumber-3.0.3.tgz",
      "integrity": "sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw==",
      "license": "MIT"
    },
    "node_modules/lodash.isplainobject": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
      "integrity": "sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==",
      "license": "MIT"
    },
    "node_modules/lodash.isstring": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/lodash.isstring/-/lodash.isstring-4.0.1.tgz",
      "integrity": "sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw==",
      "license": "MIT"
    },
    "node_modules/lodash.mergewith": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.mergewith/-/lodash.mergewith-4.6.2.tgz",
      "integrity": "sha512-GK3g5RPZWTRSeLSpgP8Xhra+pnjBC56q9FZYe1d5RN3TJ35dbkGy3YqBSMbyCrlbi+CM9Z3Jk5yTL7RCsqboyQ==",
      "license": "MIT"
    },
    "node_modules/lodash.once": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/lodash.once/-/lodash.once-4.1.1.tgz",
      "integrity": "sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg==",
      "license": "MIT"
    },
    "node_modules/loupe": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/loupe/-/loupe-3.1.3.tgz",
      "integrity": "sha512-kkIp7XSkP78ZxJEsSxW3712C6teJVoeHHwgo9zJ380de7IYyJ2ISlxojcH2pC5OFLewESmnRi/+XCDIEEVyoug==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lru-cache": {
      "version": "10.4.3",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/magic-string": {
      "version": "0.30.17",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.17.tgz",
      "integrity": "sha512-sNPKHvyjVf7gyjwS4xGTaW/mCnF8wnjtifKBEhxfZ7E/S8tQ0rssrwGNn6q8JH/ohItJfSQp9mBtQYuTlH5QnA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0"
      }
    },
    "node_modules/magicast": {
      "version": "0.3.5",
      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.25.4",
        "@babel/types": "^7.25.4",
        "source-map-js": "^1.2.0"
      }
    },
    "node_modules/make-dir": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "semver": "^7.5.3"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/make-error": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/media-typer": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
      "integrity": "sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/merge-descriptors": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.3.tgz",
      "integrity": "sha512-gaNvAS7TZ897/rVaZ0nMtAyxNyi/pdbjbAwUpFQpN70GqnVfOiXpeUUMKRBmzXaSQ8DdTX4/0ms62r2K+hE6mQ==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/methods": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
      "integrity": "sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/mime/-/mime-1.6.0.tgz",
      "integrity": "sha512-x0Vn8spI+wuJ1O6S7gnbaQg8Pxh4NNHb7KSINmEWKiPE4RKOplvijn+NkmYmmRgP68mc70j2EbeTFRsrswaQeg==",
      "license": "MIT",
      "bin": {
        "mime": "cli.js"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/minimist": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.8.tgz",
      "integrity": "sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/minipass": {
      "version": "7.1.2",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=16 || 14 >=14.17"
      }
    },
    "node_modules/mkdirp": {
      "version": "0.5.6",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.6.tgz",
      "integrity": "sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw==",
      "license": "MIT",
      "dependencies": {
        "minimist": "^1.2.6"
      },
      "bin": {
        "mkdirp": "bin/cmd.js"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/multer": {
      "version": "1.4.5-lts.2",
      "resolved": "https://registry.npmjs.org/multer/-/multer-1.4.5-lts.2.tgz",
      "integrity": "sha512-VzGiVigcG9zUAoCNU+xShztrlr1auZOlurXynNvO9GiWD1/mTBbUljOKY+qMeazBqXgRnjzeEgJI/wyjJUHg9A==",
      "license": "MIT",
      "dependencies": {
        "append-field": "^1.0.0",
        "busboy": "^1.0.0",
        "concat-stream": "^1.5.2",
        "mkdirp": "^0.5.4",
        "object-assign": "^4.1.1",
        "type-is": "^1.6.4",
        "xtend": "^4.0.0"
      },
      "engines": {
        "node": ">= 6.0.0"
      }
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/negotiator": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
      "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/node-cron": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/node-cron/-/node-cron-3.0.3.tgz",
      "integrity": "sha512-dOal67//nohNgYWb+nWmg5dkFdIwDm8EpeGYMekPMrngV3637lqnX0lbUcCtgibHTz6SEz7DAIjKvKDFYCnO1A==",
      "license": "ISC",
      "dependencies": {
        "uuid": "8.3.2"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/node-cron/node_modules/uuid": {
      "version": "8.3.2",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz",
      "integrity": "sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==",
      "license": "MIT",
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/nodemon": {
      "version": "3.1.10",
      "resolved": "https://registry.npmjs.org/nodemon/-/nodemon-3.1.10.tgz",
      "integrity": "sha512-WDjw3pJ0/0jMFmyNDp3gvY2YizjLmmOUQo6DEBY+JgdvW/yQ9mEeSw6H5ythl5Ny2ytb7f9C2nIbjSxMNzbJXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chokidar": "^3.5.2",
        "debug": "^4",
        "ignore-by-default": "^1.0.1",
        "minimatch": "^3.1.2",
        "pstree.remy": "^1.1.8",
        "semver": "^7.5.3",
        "simple-update-notifier": "^2.0.0",
        "supports-color": "^5.5.0",
        "touch": "^3.1.0",
        "undefsafe": "^2.0.5"
      },
      "bin": {
        "nodemon": "bin/nodemon.js"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/nodemon"
      }
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "license": "MIT",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/openapi-types": {
      "version": "12.1.3",
      "resolved": "https://registry.npmjs.org/openapi-types/-/openapi-types-12.1.3.tgz",
      "integrity": "sha512-N4YtSYJqghVu4iek2ZUvcN/0aqH1kRDuNqzcycDxhOUpg7GdvLa2F3DgS6yBNhInhv2r/6I0Flkn7CqL8+nIcw==",
      "peer": true
    },
    "node_modules/package-json-from-dist": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
      "dev": true,
      "license": "BlueOak-1.0.0"
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/path-scurry": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "lru-cache": "^10.2.0",
        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
      },
      "engines": {
        "node": ">=16 || 14 >=14.18"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "0.1.12",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
      "integrity": "sha512-RA1GjUVMnvYFxuqovrEqZoxxW5NUZqbwKtYz/Tt7nXerk0LbLblQmrsgdeOxV5SFHf0UDggjS/bSeOZwt1pmEQ==",
      "license": "MIT"
    },
    "node_modules/pathe": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/pathe/-/pathe-1.1.2.tgz",
      "integrity": "sha512-whLdWMYL2TwI08hn8/ZqAbrVemu0LNaNNJZX73O6qaIdCTfXutsLhMkjdENX0qhsQ9uIimo4/aQOmXkoon2nDQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/pathval": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/pathval/-/pathval-2.0.0.tgz",
      "integrity": "sha512-vE7JKRyES09KiunauX7nd2Q9/L7lhok4smP9RZTDeD4MVs72Dp2qNFVz39Nz5a0FVEW0BJR6C0DYrq6unoziZA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 14.16"
      }
    },
    "node_modules/peek-readable": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/peek-readable/-/peek-readable-7.0.0.tgz",
      "integrity": "sha512-nri2TO5JE3/mRryik9LlHFT53cgHfRK0Lt0BAZQXku/AW3E6XLt2GaY8siWi7dvW/m1z0ecn+J+bpDa9ZN3IsQ==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/Borewit"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/postcss": {
      "version": "8.5.4",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.4.tgz",
      "integrity": "sha512-QSa9EBe+uwlGTFmHsPKokv3B/oEMQZxfqW0QqNCyhpa6mB1afzulwn8hihglqAb2pOw+BJgNlmXQ8la2VeHB7w==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/prisma": {
      "version": "6.9.0",
      "resolved": "https://registry.npmjs.org/prisma/-/prisma-6.9.0.tgz",
      "integrity": "sha512-resJAwMyZREC/I40LF6FZ6rZTnlrlrYrb63oW37Gq+U+9xHwbyMSPJjKtM7VZf3gTO86t/Oyz+YeSXr3CmAY1Q==",
      "devOptional": true,
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/config": "6.9.0",
        "@prisma/engines": "6.9.0"
      },
      "bin": {
        "prisma": "build/index.js"
      },
      "engines": {
        "node": ">=18.18"
      },
      "peerDependencies": {
        "typescript": ">=5.1.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/process-nextick-args": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/process-nextick-args/-/process-nextick-args-2.0.1.tgz",
      "integrity": "sha512-3ouUOpQhtgrbOa17J7+uxOTpITYWaGP7/AhoR3+A+/1e9skrzelGi/dXzEYyvbxubEF6Wn2ypscTKiKJFFn1ag==",
      "license": "MIT"
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "license": "MIT",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/pstree.remy": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/pstree.remy/-/pstree.remy-1.1.8.tgz",
      "integrity": "sha512-77DZwxQmxKnu3aR542U+X8FypNzbfJ+C5XQDk3uWjWxn6151aIMGthWYRXTqT1E5oJvg+ljaa2OJi+VfvCOQ8w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/q": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/q/-/q-1.5.1.tgz",
      "integrity": "sha512-kV/CThkXo6xyFEZUugw/+pIOywXcDbFYgSct5cT3gqlbkBE1SJdwy6UQoZvodiWF/ckQLZyDE/Bu1M6gVu5lVw==",
      "license": "MIT",
      "engines": {
        "node": ">=0.6.0",
        "teleport": ">=0.2.0"
      }
    },
    "node_modules/qs": {
      "version": "6.13.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.13.0.tgz",
      "integrity": "sha512-+38qI9SOr8tfZ4QmJNplMUxqjbe7LKvvZgWdExBOmd+egZTtjLB67Gu0HRX3u/XOq7UU2Nx6nsjvS16Z9uwfpg==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.0.6"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "2.5.2",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.5.2.tgz",
      "integrity": "sha512-8zGqypfENjCIqGhgXToC8aB2r7YrBX+AQAfIPs/Mlk+BtPTztOvTS01NRW/3Eh60J+a48lt8qsCzirQ6loCVfA==",
      "license": "MIT",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/readable-stream": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.8.tgz",
      "integrity": "sha512-8p0AUk4XODgIewSi0l8Epjs+EVnWiK7NoDIEGU0HhE7+ZyY8D1IMY7odu5lRrFXGg71L15KG8QrPmum45RTtdA==",
      "license": "MIT",
      "dependencies": {
        "core-util-is": "~1.0.0",
        "inherits": "~2.0.3",
        "isarray": "~1.0.0",
        "process-nextick-args": "~2.0.0",
        "safe-buffer": "~5.1.1",
        "string_decoder": "~1.1.1",
        "util-deprecate": "~1.0.1"
      }
    },
    "node_modules/readable-stream/node_modules/safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
      "license": "MIT"
    },
    "node_modules/readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/reflect-metadata": {
      "version": "0.2.2",
      "resolved": "https://registry.npmjs.org/reflect-metadata/-/reflect-metadata-0.2.2.tgz",
      "integrity": "sha512-urBwgfrvVP/eAyXx4hluJivBKzuEbSQs9rKWCrCkbSxNv8mxPcUZKeuoF3Uy4mJl3Lwprp6yy5/39VWigZ4K6Q==",
      "license": "Apache-2.0"
    },
    "node_modules/resolve": {
      "version": "1.22.10",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.10.tgz",
      "integrity": "sha512-NPRy+/ncIMeDlTAsuqwKIiferiawhefFJtkNSW0qZJEqMEb+qBt/77B/jGeeek+F0uOeN05CDa6HXbbIgtVX4w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.0",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/rimraf": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.7.1.tgz",
      "integrity": "sha512-uWjbaKIK3T1OSVptzX7Nl6PvQ3qAGtKEtVRjRuazjfL3Bx5eI409VZSqgND+4UNnmzLVdPj9FqFJNPqBZFve4w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "glob": "^7.1.3"
      },
      "bin": {
        "rimraf": "bin.js"
      }
    },
    "node_modules/rimraf/node_modules/glob": {
      "version": "7.2.3",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.1.1",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/rollup": {
      "version": "4.41.1",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.41.1.tgz",
      "integrity": "sha512-cPmwD3FnFv8rKMBc1MxWCwVQFxwf1JEmSX3iQXrRVVG15zerAIXRjMFVWnd5Q5QvgKF7Aj+5ykXFhUl+QGnyOw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.7"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.41.1",
        "@rollup/rollup-android-arm64": "4.41.1",
        "@rollup/rollup-darwin-arm64": "4.41.1",
        "@rollup/rollup-darwin-x64": "4.41.1",
        "@rollup/rollup-freebsd-arm64": "4.41.1",
        "@rollup/rollup-freebsd-x64": "4.41.1",
        "@rollup/rollup-linux-arm-gnueabihf": "4.41.1",
        "@rollup/rollup-linux-arm-musleabihf": "4.41.1",
        "@rollup/rollup-linux-arm64-gnu": "4.41.1",
        "@rollup/rollup-linux-arm64-musl": "4.41.1",
        "@rollup/rollup-linux-loongarch64-gnu": "4.41.1",
        "@rollup/rollup-linux-powerpc64le-gnu": "4.41.1",
        "@rollup/rollup-linux-riscv64-gnu": "4.41.1",
        "@rollup/rollup-linux-riscv64-musl": "4.41.1",
        "@rollup/rollup-linux-s390x-gnu": "4.41.1",
        "@rollup/rollup-linux-x64-gnu": "4.41.1",
        "@rollup/rollup-linux-x64-musl": "4.41.1",
        "@rollup/rollup-win32-arm64-msvc": "4.41.1",
        "@rollup/rollup-win32-ia32-msvc": "4.41.1",
        "@rollup/rollup-win32-x64-msvc": "4.41.1",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/rxjs": {
      "version": "7.8.2",
      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-7.8.2.tgz",
      "integrity": "sha512-dhKf903U/PQZY6boNNtAGdWbG85WAbjT/1xYoZIC7FAY0yWapOBQVsVrDl58W86//e1VpMNBtRV4MaXfdMySFA==",
      "dependencies": {
        "tslib": "^2.1.0"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/send": {
      "version": "0.19.0",
      "resolved": "https://registry.npmjs.org/send/-/send-0.19.0.tgz",
      "integrity": "sha512-dW41u5VfLXu8SJh5bwRmyYUbAoSB3c9uQh6L8h/KtsFREPWpbX1lrljJo186Jc4nmci/sGUZ9a0a0J2zgfq2hw==",
      "license": "MIT",
      "dependencies": {
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "mime": "1.6.0",
        "ms": "2.1.3",
        "on-finished": "2.4.1",
        "range-parser": "~1.2.1",
        "statuses": "2.0.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/send/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "license": "MIT",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/send/node_modules/debug/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "license": "MIT"
    },
    "node_modules/send/node_modules/encodeurl": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
      "integrity": "sha512-TPJXq8JqFaVYm2CWmPvnP2Iyo4ZSM7/QKcSmuMLDObfpH5fi7RUGmd/rTDf+rut/saiDiQEeVTNgAmJEdAOx0w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/serve-static": {
      "version": "1.16.2",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.16.2.tgz",
      "integrity": "sha512-VqpjJZKadQB/PEbEwvFdO43Ax5dFBZ2UECszz8bQ7pi7wt//PWe1P6MN7eCnjsatYtBT6EuiClbjSWP2WrIoTw==",
      "license": "MIT",
      "dependencies": {
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "parseurl": "~1.3.3",
        "send": "0.19.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
      "license": "ISC"
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/siginfo": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/siginfo/-/siginfo-2.0.0.tgz",
      "integrity": "sha512-ybx0WO1/8bSBLEWXZvEd7gMW3Sn3JFlW3TvX1nREbDLRNQNaeNN8WK0meBwPdAaOI7TtRRRJn/Es1zhrrCHu7g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/signal-exit": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/simple-update-notifier": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/simple-update-notifier/-/simple-update-notifier-2.0.0.tgz",
      "integrity": "sha512-a2B9Y0KlNXl9u/vsW6sTIu9vGEpfKu2wRV6l1H3XEas/0gUIzGzBoP/IouTcUQbm9JWZLH3COxyn03TYlFax6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "semver": "^7.5.3"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/source-map": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
      "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/source-map-support": {
      "version": "0.5.21",
      "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.21.tgz",
      "integrity": "sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "buffer-from": "^1.0.0",
        "source-map": "^0.6.0"
      }
    },
    "node_modules/stackback": {
      "version": "0.0.2",
      "resolved": "https://registry.npmjs.org/stackback/-/stackback-0.0.2.tgz",
      "integrity": "sha512-1XMJE5fQo1jGH6Y/7ebnwPOBEkIEnT4QF32d5R1+VXdXveM0IBMJt8zfaxX1P3QhVwrYe+576+jkANtSS2mBbw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/statuses": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
      "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/std-env": {
      "version": "3.9.0",
      "resolved": "https://registry.npmjs.org/std-env/-/std-env-3.9.0.tgz",
      "integrity": "sha512-UGvjygr6F6tpH7o2qyqR6QYpwraIjKSdtzyBdyytFOHmPZY917kwdwLG0RbOjWOnKmnm3PeHjaoLLMie7kPLQw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/streamifier": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/streamifier/-/streamifier-0.1.1.tgz",
      "integrity": "sha512-zDgl+muIlWzXNsXeyUfOk9dChMjlpkq0DRsxujtYPgyJ676yQ8jEm6zzaaWHFDg5BNcLuif0eD2MTyJdZqXpdg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/streamsearch": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/streamsearch/-/streamsearch-1.1.0.tgz",
      "integrity": "sha512-Mcc5wHehp9aXz1ax6bZUyY5afg9u2rv5cqQI3mRrYkGC8rW2hM02jWuwjtL++LS5qinSyhj2QfLyNsuc+VsExg==",
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/string_decoder": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.1.1.tgz",
      "integrity": "sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.1.0"
      }
    },
    "node_modules/string_decoder/node_modules/safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
      "license": "MIT"
    },
    "node_modules/string-width": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eastasianwidth": "^0.2.0",
        "emoji-regex": "^9.2.2",
        "strip-ansi": "^7.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/string-width-cjs": {
      "name": "string-width",
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/string-width/node_modules/ansi-regex": {
      "version": "6.1.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.1.0.tgz",
      "integrity": "sha512-7HSX4QQb4CspciLpVFwyRe79O3xsIZDDLER21kERQ71oaPodF8jL725AgJMFAYbooIqolJoRLuM81SpeUkpkvA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
      }
    },
    "node_modules/string-width/node_modules/emoji-regex": {
      "version": "9.2.2",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/string-width/node_modules/strip-ansi": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.0.tgz",
      "integrity": "sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^6.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
      }
    },
    "node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi-cjs": {
      "name": "strip-ansi",
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-bom": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/strip-bom/-/strip-bom-3.0.0.tgz",
      "integrity": "sha512-vavAMRXOgBVNF6nyEEmL3DBK19iRpDcoIwW+swQ+CbGiu7lju6t+JklA1MHweoWtadgt4ISVUsXLyDq34ddcwA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-2.0.1.tgz",
      "integrity": "sha512-4gB8na07fecVVkOI6Rs4e7T6NOTki5EmL7TUduTs6bu3EdnSycntVJ4re8kgZA+wx9IueI2Y11bfbgwtzuE0KQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/strtok3": {
      "version": "10.2.2",
      "resolved": "https://registry.npmjs.org/strtok3/-/strtok3-10.2.2.tgz",
      "integrity": "sha512-Xt18+h4s7Z8xyZ0tmBoRmzxcop97R4BAh+dXouUDCYn+Em+1P3qpkUfI5ueWLT8ynC5hZ+q4iPEmGG1urvQGBg==",
      "license": "MIT",
      "dependencies": {
        "@tokenizer/token": "^0.3.0",
        "peek-readable": "^7.0.0"
      },
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/Borewit"
      }
    },
    "node_modules/superagent": {
      "version": "10.2.1",
      "resolved": "https://registry.npmjs.org/superagent/-/superagent-10.2.1.tgz",
      "integrity": "sha512-O+PCv11lgTNJUzy49teNAWLjBZfc+A1enOwTpLlH6/rsvKcTwcdTT8m9azGkVqM7HBl5jpyZ7KTPhHweokBcdg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "component-emitter": "^1.3.0",
        "cookiejar": "^2.1.4",
        "debug": "^4.3.4",
        "fast-safe-stringify": "^2.1.1",
        "form-data": "^4.0.0",
        "formidable": "^3.5.4",
        "methods": "^1.1.2",
        "mime": "2.6.0",
        "qs": "^6.11.0"
      },
      "engines": {
        "node": ">=14.18.0"
      }
    },
    "node_modules/superagent/node_modules/mime": {
      "version": "2.6.0",
      "resolved": "https://registry.npmjs.org/mime/-/mime-2.6.0.tgz",
      "integrity": "sha512-USPkMeET31rOMiarsBNIHZKLGgvKc/LrjofAnBlOttf5ajRvqiRA8QsenbcooctK6d6Ts6aqZXBA+XbkKthiQg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "mime": "cli.js"
      },
      "engines": {
        "node": ">=4.0.0"
      }
    },
    "node_modules/superagent/node_modules/qs": {
      "version": "6.14.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.14.0.tgz",
      "integrity": "sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/supertest": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/supertest/-/supertest-7.1.1.tgz",
      "integrity": "sha512-aI59HBTlG9e2wTjxGJV+DygfNLgnWbGdZxiA/sgrnNNikIW8lbDvCtF6RnhZoJ82nU7qv7ZLjrvWqCEm52fAmw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "methods": "^1.1.2",
        "superagent": "^10.2.1"
      },
      "engines": {
        "node": ">=14.18.0"
      }
    },
    "node_modules/supports-color": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
      "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^3.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/swagger-jsdoc": {
      "version": "6.2.8",
      "resolved": "https://registry.npmjs.org/swagger-jsdoc/-/swagger-jsdoc-6.2.8.tgz",
      "integrity": "sha512-VPvil1+JRpmJ55CgAtn8DIcpBs0bL5L3q5bVQvF4tAW/k/9JYSj7dCpaYCAv5rufe0vcCbBRQXGvzpkWjvLklQ==",
      "license": "MIT",
      "dependencies": {
        "commander": "6.2.0",
        "doctrine": "3.0.0",
        "glob": "7.1.6",
        "lodash.mergewith": "^4.6.2",
        "swagger-parser": "^10.0.3",
        "yaml": "2.0.0-1"
      },
      "bin": {
        "swagger-jsdoc": "bin/swagger-jsdoc.js"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/swagger-parser": {
      "version": "10.0.3",
      "resolved": "https://registry.npmjs.org/swagger-parser/-/swagger-parser-10.0.3.tgz",
      "integrity": "sha512-nF7oMeL4KypldrQhac8RyHerJeGPD1p2xDh900GPvc+Nk7nWP6jX2FcC7WmkinMoAmoO774+AFXcWsW8gMWEIg==",
      "license": "MIT",
      "dependencies": {
        "@apidevtools/swagger-parser": "10.0.3"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/swagger-ui-dist": {
      "version": "5.24.0",
      "resolved": "https://registry.npmjs.org/swagger-ui-dist/-/swagger-ui-dist-5.24.0.tgz",
      "integrity": "sha512-okwN8vf14TOgBTUyGgCXEAoHnrwwp/042dC00B3kPu2OAe9zD75BtSbLlgAK1Y5e3csJhs+AdnIxJYZN9uvptg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@scarf/scarf": "=1.4.0"
      }
    },
    "node_modules/swagger-ui-express": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/swagger-ui-express/-/swagger-ui-express-5.0.1.tgz",
      "integrity": "sha512-SrNU3RiBGTLLmFU8GIJdOdanJTl4TOmT27tt3bWWHppqYmAZ6IDuEuBvMU6nZq0zLEe6b/1rACXCgLZqO6ZfrA==",
      "license": "MIT",
      "dependencies": {
        "swagger-ui-dist": ">=5.0.0"
      },
      "engines": {
        "node": ">= v0.10.32"
      },
      "peerDependencies": {
        "express": ">=4.0.0 || >=5.0.0-beta"
      }
    },
    "node_modules/test-exclude": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "@istanbuljs/schema": "^0.1.2",
        "glob": "^10.4.1",
        "minimatch": "^9.0.4"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/test-exclude/node_modules/brace-expansion": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz",
      "integrity": "sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/test-exclude/node_modules/glob": {
      "version": "10.4.5",
      "resolved": "https://registry.npmjs.org/glob/-/glob-10.4.5.tgz",
      "integrity": "sha512-7Bv8RF0k6xjo7d4A/PxYLbUCfb6c+Vpd2/mB2yRDlew7Jb5hEXiCD9ibfO7wpk8i4sevK6DFny9h7EYbM3/sHg==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "foreground-child": "^3.1.0",
        "jackspeak": "^3.1.2",
        "minimatch": "^9.0.4",
        "minipass": "^7.1.2",
        "package-json-from-dist": "^1.0.0",
        "path-scurry": "^1.11.1"
      },
      "bin": {
        "glob": "dist/esm/bin.mjs"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/test-exclude/node_modules/minimatch": {
      "version": "9.0.5",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz",
      "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/tinybench": {
      "version": "2.9.0",
      "resolved": "https://registry.npmjs.org/tinybench/-/tinybench-2.9.0.tgz",
      "integrity": "sha512-0+DUvqWMValLmha6lr4kD8iAMK1HzV0/aKnCtWb9v9641TnP/MFb7Pc2bxoxQjTXAErryXVgUOfv2YqNllqGeg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tinyexec": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/tinyexec/-/tinyexec-0.3.2.tgz",
      "integrity": "sha512-KQQR9yN7R5+OSwaK0XQoj22pwHoTlgYqmUscPYoknOoWCWfj/5/ABTMRi69FrKU5ffPVh5QcFikpWJI/P1ocHA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tinypool": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/tinypool/-/tinypool-1.1.0.tgz",
      "integrity": "sha512-7CotroY9a8DKsKprEy/a14aCCm8jYVmR7aFy4fpkZM8sdpNJbKkixuNjgM50yCmip2ezc8z4N7k3oe2+rfRJCQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      }
    },
    "node_modules/tinyrainbow": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/tinyrainbow/-/tinyrainbow-1.2.0.tgz",
      "integrity": "sha512-weEDEq7Z5eTHPDh4xjX789+fHfF+P8boiFB+0vbWzpbnbsEr/GRaohi/uMKxg8RZMXnl1ItAi/IUHWMsjDV7kQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/tinyspy": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/tinyspy/-/tinyspy-3.0.2.tgz",
      "integrity": "sha512-n1cw8k1k0x4pgA2+9XrOkFydTerNcJ1zWCO5Nn9scWHTD+5tp8dghT2x1uduQePZTZgd3Tupf+x9BxJjeJi77Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/token-types": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/token-types/-/token-types-6.0.0.tgz",
      "integrity": "sha512-lbDrTLVsHhOMljPscd0yitpozq7Ga2M5Cvez5AjGg8GASBjtt6iERCAJ93yommPmz62fb45oFIXHEZ3u9bfJEA==",
      "license": "MIT",
      "dependencies": {
        "@tokenizer/token": "^0.3.0",
        "ieee754": "^1.2.1"
      },
      "engines": {
        "node": ">=14.16"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/Borewit"
      }
    },
    "node_modules/touch": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/touch/-/touch-3.1.1.tgz",
      "integrity": "sha512-r0eojU4bI8MnHr8c5bNo7lJDdI2qXlWWJk6a9EAFG7vbhTjElYhBVS3/miuE0uOuoLdb8Mc/rVfsmm6eo5o9GA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "nodetouch": "bin/nodetouch.js"
      }
    },
    "node_modules/tree-kill": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/tree-kill/-/tree-kill-1.2.2.tgz",
      "integrity": "sha512-L0Orpi8qGpRG//Nd+H90vFB+3iHnue1zSSGmNOOCh1GLJ7rUKVwV2HvijphGQS2UmhUZewS9VgvxYIdgr+fG1A==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "tree-kill": "cli.js"
      }
    },
    "node_modules/ts-node": {
      "version": "10.9.2",
      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-10.9.2.tgz",
      "integrity": "sha512-f0FFpIdcHgn8zcPSbf1dRevwt047YMnaiJM3u2w2RewrB+fob/zePZcrOyQoLMMO7aBIddLcQIEK5dYjkLnGrQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@cspotcode/source-map-support": "^0.8.0",
        "@tsconfig/node10": "^1.0.7",
        "@tsconfig/node12": "^1.0.7",
        "@tsconfig/node14": "^1.0.0",
        "@tsconfig/node16": "^1.0.2",
        "acorn": "^8.4.1",
        "acorn-walk": "^8.1.1",
        "arg": "^4.1.0",
        "create-require": "^1.1.0",
        "diff": "^4.0.1",
        "make-error": "^1.1.1",
        "v8-compile-cache-lib": "^3.0.1",
        "yn": "3.1.1"
      },
      "bin": {
        "ts-node": "dist/bin.js",
        "ts-node-cwd": "dist/bin-cwd.js",
        "ts-node-esm": "dist/bin-esm.js",
        "ts-node-script": "dist/bin-script.js",
        "ts-node-transpile-only": "dist/bin-transpile.js",
        "ts-script": "dist/bin-script-deprecated.js"
      },
      "peerDependencies": {
        "@swc/core": ">=1.2.50",
        "@swc/wasm": ">=1.2.50",
        "@types/node": "*",
        "typescript": ">=2.7"
      },
      "peerDependenciesMeta": {
        "@swc/core": {
          "optional": true
        },
        "@swc/wasm": {
          "optional": true
        }
      }
    },
    "node_modules/ts-node-dev": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ts-node-dev/-/ts-node-dev-2.0.0.tgz",
      "integrity": "sha512-ywMrhCfH6M75yftYvrvNarLEY+SUXtUvU8/0Z6llrHQVBx12GiFk5sStF8UdfE/yfzk9IAq7O5EEbTQsxlBI8w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chokidar": "^3.5.1",
        "dynamic-dedupe": "^0.3.0",
        "minimist": "^1.2.6",
        "mkdirp": "^1.0.4",
        "resolve": "^1.0.0",
        "rimraf": "^2.6.1",
        "source-map-support": "^0.5.12",
        "tree-kill": "^1.2.2",
        "ts-node": "^10.4.0",
        "tsconfig": "^7.0.0"
      },
      "bin": {
        "ts-node-dev": "lib/bin.js",
        "tsnd": "lib/bin.js"
      },
      "engines": {
        "node": ">=0.8.0"
      },
      "peerDependencies": {
        "node-notifier": "*",
        "typescript": "*"
      },
      "peerDependenciesMeta": {
        "node-notifier": {
          "optional": true
        }
      }
    },
    "node_modules/ts-node-dev/node_modules/mkdirp": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-1.0.4.tgz",
      "integrity": "sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "mkdirp": "bin/cmd.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/tsconfig": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/tsconfig/-/tsconfig-7.0.0.tgz",
      "integrity": "sha512-vZXmzPrL+EmC4T/4rVlT2jNVMWCi/O4DIiSj3UHg1OE5kCKbk4mfrXc6dZksLgRM/TZlKnousKH9bbTazUWRRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/strip-bom": "^3.0.0",
        "@types/strip-json-comments": "0.0.30",
        "strip-bom": "^3.0.0",
        "strip-json-comments": "^2.0.0"
      }
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/type-is": {
      "version": "1.6.18",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
      "license": "MIT",
      "dependencies": {
        "media-typer": "0.3.0",
        "mime-types": "~2.1.24"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/typedarray": {
      "version": "0.0.6",
      "resolved": "https://registry.npmjs.org/typedarray/-/typedarray-0.0.6.tgz",
      "integrity": "sha512-/aCDEGatGvZ2BIk+HmLf4ifCJFwvKFNb9/JeZPMulfgFracn9QFcAf5GO8B/mweUjSoblS5In0cWhqpfs/5PQA==",
      "license": "MIT"
    },
    "node_modules/typescript": {
      "version": "5.8.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.8.3.tgz",
      "integrity": "sha512-p1diW6TqL9L07nNxvRMM7hMMw4c5XOo/1ibL4aAIGmSAt9slTE1Xgw5KWuof2uTOvCg9BY7ZRi+GaF+7sfgPeQ==",
      "devOptional": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/uid": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/uid/-/uid-2.0.2.tgz",
      "integrity": "sha512-u3xV3X7uzvi5b1MncmZo3i2Aw222Zk1keqLA1YkHldREkAhAqi65wuPfe7lHx8H/Wzy+8CE7S7uS3jekIM5s8g==",
      "license": "MIT",
      "dependencies": {
        "@lukeed/csprng": "^1.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/uint8array-extras": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/uint8array-extras/-/uint8array-extras-1.4.0.tgz",
      "integrity": "sha512-ZPtzy0hu4cZjv3z5NW9gfKnNLjoz4y6uv4HlelAjDK7sY/xOkKZv9xK/WQpcsBB3jEybChz9DPC2U/+cusjJVQ==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/undefsafe": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/undefsafe/-/undefsafe-2.0.5.tgz",
      "integrity": "sha512-WxONCrssBM8TSPRqN5EmsjVrsv4A8X12J4ArBiiayv3DyyG3ZlIg6yysuuSYdZsVz3TKcTg2fd//Ujd4CHV1iA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ=="
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "license": "MIT"
    },
    "node_modules/utils-merge": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
      "integrity": "sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/uuid": {
      "version": "10.0.0",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-10.0.0.tgz",
      "integrity": "sha512-8XkAphELsDnEGrDxUOHB3RGvXz6TeuYSGEZBOjtTtPm2lwhGBjLgOzLHB63IUWfBpNucQjND6d3AOudO+H3RWQ==",
      "funding": [
        "https://github.com/sponsors/broofa",
        "https://github.com/sponsors/ctavan"
      ],
      "license": "MIT",
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/v8-compile-cache-lib": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/v8-compile-cache-lib/-/v8-compile-cache-lib-3.0.1.tgz",
      "integrity": "sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/validator": {
      "version": "13.15.15",
      "resolved": "https://registry.npmjs.org/validator/-/validator-13.15.15.tgz",
      "integrity": "sha512-BgWVbCI72aIQy937xbawcs+hrVaN/CZ2UwutgaJ36hGqRrLNM+f5LUT/YPRbo8IV/ASeFzXszezV+y2+rq3l8A==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/vite": {
      "version": "5.4.19",
      "resolved": "https://registry.npmjs.org/vite/-/vite-5.4.19.tgz",
      "integrity": "sha512-qO3aKv3HoQC8QKiNSTuUM1l9o/XX3+c+VTgLHbJWHZGeTPVAg2XwazI9UWzoxjIJCGCV2zU60uqMzjeLZuULqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.21.3",
        "postcss": "^8.4.43",
        "rollup": "^4.20.0"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || >=20.0.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.4.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        }
      }
    },
    "node_modules/vite-node": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/vite-node/-/vite-node-2.1.9.tgz",
      "integrity": "sha512-AM9aQ/IPrW/6ENLQg3AGY4K1N2TGZdR5e4gu/MmmR2xR3Ll1+dib+nook92g4TV3PXVyeyxdWwtaCAiUL0hMxA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cac": "^6.7.14",
        "debug": "^4.3.7",
        "es-module-lexer": "^1.5.4",
        "pathe": "^1.1.2",
        "vite": "^5.0.0"
      },
      "bin": {
        "vite-node": "vite-node.mjs"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/vitest": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/vitest/-/vitest-2.1.9.tgz",
      "integrity": "sha512-MSmPM9REYqDGBI8439mA4mWhV5sKmDlBKWIYbA3lRb2PTHACE0mgKwA8yQ2xq9vxDTuk4iPrECBAEW2aoFXY0Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/expect": "2.1.9",
        "@vitest/mocker": "2.1.9",
        "@vitest/pretty-format": "^2.1.9",
        "@vitest/runner": "2.1.9",
        "@vitest/snapshot": "2.1.9",
        "@vitest/spy": "2.1.9",
        "@vitest/utils": "2.1.9",
        "chai": "^5.1.2",
        "debug": "^4.3.7",
        "expect-type": "^1.1.0",
        "magic-string": "^0.30.12",
        "pathe": "^1.1.2",
        "std-env": "^3.8.0",
        "tinybench": "^2.9.0",
        "tinyexec": "^0.3.1",
        "tinypool": "^1.0.1",
        "tinyrainbow": "^1.2.0",
        "vite": "^5.0.0",
        "vite-node": "2.1.9",
        "why-is-node-running": "^2.3.0"
      },
      "bin": {
        "vitest": "vitest.mjs"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "@edge-runtime/vm": "*",
        "@types/node": "^18.0.0 || >=20.0.0",
        "@vitest/browser": "2.1.9",
        "@vitest/ui": "2.1.9",
        "happy-dom": "*",
        "jsdom": "*"
      },
      "peerDependenciesMeta": {
        "@edge-runtime/vm": {
          "optional": true
        },
        "@types/node": {
          "optional": true
        },
        "@vitest/browser": {
          "optional": true
        },
        "@vitest/ui": {
          "optional": true
        },
        "happy-dom": {
          "optional": true
        },
        "jsdom": {
          "optional": true
        }
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/why-is-node-running": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/why-is-node-running/-/why-is-node-running-2.3.0.tgz",
      "integrity": "sha512-hUrmaWBdVDcxvYqnyh09zunKzROWjbZTiNy8dBEjkS7ehEDQibXJ7XvlmtbwuTclUiIyN+CyXQD4Vmko8fNm8w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "siginfo": "^2.0.0",
        "stackback": "0.0.2"
      },
      "bin": {
        "why-is-node-running": "cli.js"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/wrap-ansi": {
      "version": "8.1.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^6.1.0",
        "string-width": "^5.0.1",
        "strip-ansi": "^7.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrap-ansi-cjs": {
      "name": "wrap-ansi",
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/wrap-ansi/node_modules/ansi-regex": {
      "version": "6.1.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.1.0.tgz",
      "integrity": "sha512-7HSX4QQb4CspciLpVFwyRe79O3xsIZDDLER21kERQ71oaPodF8jL725AgJMFAYbooIqolJoRLuM81SpeUkpkvA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
      }
    },
    "node_modules/wrap-ansi/node_modules/ansi-styles": {
      "version": "6.2.1",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.1.tgz",
      "integrity": "sha512-bN798gFfQX+viw3R7yrGWRqnrN2oRkEkUjjl4JNn4E8GxxbjtG3FbrEIIY3l8/hrwUwIeCZvi4QuOTP4MErVug==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/wrap-ansi/node_modules/strip-ansi": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.0.tgz",
      "integrity": "sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^6.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "license": "ISC"
    },
    "node_modules/xtend": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/xtend/-/xtend-4.0.2.tgz",
      "integrity": "sha512-LKYU1iAXJXUgAXn9URjiu+MWhyUXHsvfp7mcuYm9dSUKK0/CjtrUwFAxD82/mCWbtLsGjFIad0wIsod4zrTAEQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4"
      }
    },
    "node_modules/yaml": {
      "version": "2.0.0-1",
      "resolved": "https://registry.npmjs.org/yaml/-/yaml-2.0.0-1.tgz",
      "integrity": "sha512-W7h5dEhywMKenDJh2iX/LABkbFnBxasD27oyXWDS/feDsxiw0dD5ncXdYXgkvAsXIY2MpW/ZKkr9IU30DBdMNQ==",
      "license": "ISC",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/yn": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yn/-/yn-3.1.1.tgz",
      "integrity": "sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/z-schema": {
      "version": "5.0.6",
      "resolved": "https://registry.npmjs.org/z-schema/-/z-schema-5.0.6.tgz",
      "integrity": "sha512-+XR1GhnWklYdfr8YaZv/iu+vY+ux7V5DS5zH1DQf6bO5ufrt/5cgNhVO5qyhsjFXvsqQb/f08DWE9b6uPscyAg==",
      "license": "MIT",
      "dependencies": {
        "lodash.get": "^4.4.2",
        "lodash.isequal": "^4.5.0",
        "validator": "^13.7.0"
      },
      "bin": {
        "z-schema": "bin/z-schema"
      },
      "engines": {
        "node": ">=8.0.0"
      },
      "optionalDependencies": {
        "commander": "^10.0.0"
      }
    },
    "node_modules/z-schema/node_modules/commander": {
      "version": "10.0.1",
      "resolved": "https://registry.npmjs.org/commander/-/commander-10.0.1.tgz",
      "integrity": "sha512-y4Mg2tXshplEbSGzx7amzPwKKOCGuoSRP/CjEdwwk0FOGlUbq6lKuoyDZTNZkmxHdJtp54hdfY/JUrdL7Xfdug==",
      "license": "MIT",
      "optional": true,
      "engines": {
        "node": ">=14"
      }
    }
  }
}



// ====== [12] backend/package.json ======
{
  "name": "backend",
  "version": "1.15.0",
  "main": "dist/index.js",
  "license": "SEE LICENSE IN ../LICENSE.md",
  "scripts": {
    "build": "npx tsc",
    "start": "node dist/index.js",
    "dev:build": "npx tsc --watch",
    "dev:run": "npx nodemon dist/index.js",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "db:seed": "ts-node --compiler-options \"{\\\"module\\\":\\\"commonjs\\\"}\" prisma/seed.ts"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@nestjs/common": "^11.1.2",
    "@nestjs/core": "^11.1.2",
    "@prisma/client": "^6.6.0",
    "@types/multer": "^1.4.12",
    "@types/node-cron": "^3.0.11",
    "@types/streamifier": "^0.1.2",
    "bcryptjs": "^2.4.3",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "cloudinary": "^2.6.0",
    "cors": "^2.8.5",
    "date-fns": "^3.6.0",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.2",
    "node-cron": "^3.0.3",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.2",
    "streamifier": "^0.1.1",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1",
    "uuid": "^10.0.0"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/date-fns": "^2.6.0",
    "@types/dotenv": "^8.2.0",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^24.0.7",
    "@types/supertest": "^6.0.2",
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.8",
    "@types/uuid": "^10.0.0",
    "@vitest/coverage-v8": "^2.0.4",
    "nodemon": "^3.1.4",
    "prisma": "^6.6.0",
    "supertest": "^7.0.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.5.3",
    "vitest": "^2.0.4"
  },
  "resolutions": {
    "@types/express": "^4.17.21",
    "@types/express-serve-static-core": "^4.17.42"
  }
}



// ====== [13] backend/prisma/seed.js ======
"use strict";
// backend/prisma/seed.ts
// ORCHESTRATOR - Calls modular seed files in order.
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("@prisma/client");
const _1_business_1 = require("./seed/_1_business");
const _2_tiers_1 = require("./seed/_2_tiers");
const _3_menu_1 = require("./seed/_3_menu");
const _4_users_1 = require("./seed/_4_users");
const _5_activity_1 = require("./seed/_5_activity");
const prisma = new client_1.PrismaClient();
async function main() {
    console.log(`[SEED ORCHESTRATOR] Starting modular seeding...`);
    // --- The order of execution is critical ---
    // 1. Create the business and staff. These are the foundation.
    const { business, admin, camarero, cocina, barra } = await (0, _1_business_1.seedBusiness)(prisma);
    // 2. Create the loyalty tiers for the business.
    const { bronce, plata, oro, platino } = await (0, _2_tiers_1.seedTiers)(prisma, business.id);
    // 3. Create the digital menu, items, and modifiers.
    const { hamburguesa, tarta, cafe, refresco, puntoCarneGroup, extrasGroup } = await (0, _3_menu_1.seedMenu)(prisma, business.id);
    // 4. Create the customer personas and assign them tiers.
    const { anaOro, carlosPlata, davidNuevo, elenaInactiva, fernandoCero } = await (0, _4_users_1.seedUsers)(prisma, business.id, { bronce, plata, oro });
    // 5. Create the historical activity, linking all previously created entities.
    await (0, _5_activity_1.seedActivity)(prisma, {
        business,
        admin,
        anaOro,
        carlosPlata,
        davidNuevo,
        hamburguesa,
        tarta,
        cafe,
        puntoCarneGroup,
        extrasGroup
    });
    console.log(`[SEED ORCHESTRATOR] Modular seeding finished successfully!`);
}
main()
    .catch(async (e) => {
    console.error("[SEED ORCHESTRATOR] An error occurred during the seeding process:", e);
    await prisma.$disconnect();
    process.exit(1);
})
    .finally(async () => {
    await prisma.$disconnect();
});



// ====== [14] backend/prisma/seed.ts ======
// backend/prisma/seed.ts
// ORCHESTRATOR - Calls modular seed files in order.

import { PrismaClient } from '@prisma/client';
import { seedBusiness } from './seed/_1_business';
import { seedTiers } from './seed/_2_tiers';
import { seedMenu } from './seed/_3_menu';
import { seedUsers } from './seed/_4_users';
import { seedActivity } from './seed/_5_activity';

const prisma = new PrismaClient();

async function main() {
    console.log(`[SEED ORCHESTRATOR] Starting modular seeding...`);

    // --- The order of execution is critical ---
    
    // 1. Create the business and staff. These are the foundation.
    const { business, admin, camarero, cocina, barra } = await seedBusiness(prisma);
    
    // 2. Create the loyalty tiers for the business.
    const { bronce, plata, oro, platino } = await seedTiers(prisma, business.id);
    
    // 3. Create the digital menu, items, and modifiers.
    const { hamburguesa, tarta, cafe, refresco, puntoCarneGroup, extrasGroup } = await seedMenu(prisma, business.id);
    
    // 4. Create the customer personas and assign them tiers.
    const { anaOro, carlosPlata, davidNuevo, elenaInactiva, fernandoCero } = await seedUsers(prisma, business.id, { bronce, plata, oro });

    // 5. Create the historical activity, linking all previously created entities.
    await seedActivity(prisma, {
        business,
        admin,
        anaOro,
        carlosPlata,
        davidNuevo,
        hamburguesa,
        tarta,
        cafe,
        puntoCarneGroup,
        extrasGroup
    });

    console.log(`[SEED ORCHESTRATOR] Modular seeding finished successfully!`);
}

main()
  .catch(async (e) => {
    console.error("[SEED ORCHESTRATOR] An error occurred during the seeding process:", e);
    await prisma.$disconnect();
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


// ====== [15] backend/prisma/seed/_1_business.js ======
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.seedBusiness = seedBusiness;
// backend/prisma/seed/_1_business.ts
const client_1 = require("@prisma/client");
const bcryptjs_1 = __importDefault(require("bcryptjs"));
// Funci√≥n helper para hashear contrase√±as, necesaria para crear usuarios.
async function hashPassword(password) {
    const salt = await bcryptjs_1.default.genSalt(10);
    return bcryptjs_1.default.hash(password, salt);
}
/**
 * Funci√≥n que crea el negocio principal, todos los roles de personal y las mesas.
 * Es la base sobre la que se construir√°n los dem√°s datos.
 * @param prisma - Instancia del PrismaClient.
 * @returns Un objeto con las entidades creadas para que otros scripts las usen.
 */
async function seedBusiness(prisma) {
    console.log('--- Seeding [1]: Business, Staff & Tables ---');
    // 1. CREAR O ACTUALIZAR EL NEGOCIO DEMO
    const business = await prisma.business.upsert({
        where: { slug: 'restaurante-demo-loyalpyme' },
        update: { isLoyaltyCoreActive: true, isCamareroActive: true },
        create: {
            name: 'Restaurante Demo LoyalPyME',
            slug: 'restaurante-demo-loyalpyme',
            pointsPerEuro: 1.0,
            tierSystemEnabled: true,
            tierCalculationBasis: client_1.TierCalculationBasis.SPEND,
            tierCalculationPeriodMonths: 0,
            tierDowngradePolicy: client_1.TierDowngradePolicy.PERIODIC_REVIEW,
            inactivityPeriodMonths: 6,
            isActive: true,
            isLoyaltyCoreActive: true,
            isCamareroActive: true,
            logoUrl: 'https://res.cloudinary.com/dq8e13lmr/image/upload/v1710860730/loyalpyme/assets/default_business_logo_vzg0sa.png',
            brandingColorPrimary: '#228BE6',
            brandingColorSecondary: '#495057',
            qrCodeExpirationMinutes: 30,
            monthlyPrice: 49.99,
            currency: "EUR"
        },
    });
    console.log(`[SEED] Upserted Business: ${business.name}`);
    // 2. CREAR O ACTUALIZAR LOS USUARIOS DE PERSONAL
    const [admin, camarero, cocina, barra] = await prisma.$transaction([
        prisma.user.upsert({
            where: { email: 'admin@demo.com' },
            update: {},
            create: { email: 'admin@demo.com', password: await hashPassword('password'), name: 'Admin Demo', role: client_1.UserRole.BUSINESS_ADMIN, businessId: business.id },
        }),
        prisma.user.upsert({
            where: { email: 'camarero@demo.com' },
            update: {},
            create: { email: 'camarero@demo.com', password: await hashPassword('password'), name: 'Camarero Demo', role: client_1.UserRole.WAITER, businessId: business.id },
        }),
        prisma.user.upsert({
            where: { email: 'cocina@demo.com' },
            update: {},
            create: { email: 'cocina@demo.com', password: await hashPassword('password'), name: 'Cocinero Demo', role: client_1.UserRole.KITCHEN_STAFF, businessId: business.id },
        }),
        prisma.user.upsert({
            where: { email: 'barra@demo.com' },
            update: {},
            create: { email: 'barra@demo.com', password: await hashPassword('password'), name: 'Barman Demo', role: client_1.UserRole.BAR_STAFF, businessId: business.id },
        })
    ]);
    console.log(`[SEED] Upserted Staff Users.`);
    // 3. CREAR MESAS PARA EL RESTAURANTE
    console.log(`[SEED] Creating tables for the business...`);
    const tableIdentifiers = [
        'M1', 'M2', 'M3', 'M4', 'M5', 'M6', // Mesas interiores
        'T1', 'T2', 'T3', 'T4', 'T5', // Terraza
        'B1', 'B2', 'B3', 'B4' // Barra
    ];
    // Borramos las mesas existentes de este negocio para empezar de cero
    await prisma.table.deleteMany({ where: { businessId: business.id } });
    const tableCreationPromises = tableIdentifiers.map(identifier => prisma.table.create({
        data: {
            identifier,
            businessId: business.id,
            status: client_1.TableStatus.AVAILABLE,
            capacity: identifier.startsWith('M') ? 4 : (identifier.startsWith('T') ? 4 : 2) // Capacidad de ejemplo
        }
    }));
    await prisma.$transaction(tableCreationPromises);
    console.log(`[SEED] Created ${tableIdentifiers.length} tables.`);
    // 4. DEVOLVER LOS OBJETOS CREADOS
    return { business, admin, camarero, cocina, barra };
}



// ====== [16] backend/prisma/seed/_1_business.ts ======
// backend/prisma/seed/_1_business.ts
import { PrismaClient, UserRole, TierCalculationBasis, TierDowngradePolicy, TableStatus } from '@prisma/client';
import bcrypt from 'bcryptjs';

// Funci√≥n helper para hashear contrase√±as, necesaria para crear usuarios.
async function hashPassword(password: string) {
  const salt = await bcrypt.genSalt(10);
  return bcrypt.hash(password, salt);
}

/**
 * Funci√≥n que crea el negocio principal, todos los roles de personal y las mesas.
 * Es la base sobre la que se construir√°n los dem√°s datos.
 * @param prisma - Instancia del PrismaClient.
 * @returns Un objeto con las entidades creadas para que otros scripts las usen.
 */
export async function seedBusiness(prisma: PrismaClient) {
  console.log('--- Seeding [1]: Business, Staff & Tables ---');

  // 1. CREAR O ACTUALIZAR EL NEGOCIO DEMO
  const business = await prisma.business.upsert({ 
    where: { slug: 'restaurante-demo-loyalpyme' }, 
    update: { isLoyaltyCoreActive: true, isCamareroActive: true },
    create: { 
      name: 'Restaurante Demo LoyalPyME', 
      slug: 'restaurante-demo-loyalpyme', 
      pointsPerEuro: 1.0, 
      tierSystemEnabled: true, 
      tierCalculationBasis: TierCalculationBasis.SPEND, 
      tierCalculationPeriodMonths: 0,
      tierDowngradePolicy: TierDowngradePolicy.PERIODIC_REVIEW, 
      inactivityPeriodMonths: 6, 
      isActive: true, 
      isLoyaltyCoreActive: true, 
      isCamareroActive: true, 
      logoUrl: 'https://res.cloudinary.com/dq8e13lmr/image/upload/v1710860730/loyalpyme/assets/default_business_logo_vzg0sa.png', 
      brandingColorPrimary: '#228BE6', 
      brandingColorSecondary: '#495057', 
      qrCodeExpirationMinutes: 30, 
      monthlyPrice: 49.99, 
      currency: "EUR"
    }, 
  }); 
  console.log(`[SEED] Upserted Business: ${business.name}`);

  // 2. CREAR O ACTUALIZAR LOS USUARIOS DE PERSONAL
  const [admin, camarero, cocina, barra] = await prisma.$transaction([
    prisma.user.upsert({
      where: { email: 'admin@demo.com' },
      update: {},
      create: { email: 'admin@demo.com', password: await hashPassword('password'), name: 'Admin Demo', role: UserRole.BUSINESS_ADMIN, businessId: business.id },
    }),
    prisma.user.upsert({
      where: { email: 'camarero@demo.com' },
      update: {},
      create: { email: 'camarero@demo.com', password: await hashPassword('password'), name: 'Camarero Demo', role: UserRole.WAITER, businessId: business.id },
    }),
    prisma.user.upsert({
      where: { email: 'cocina@demo.com' },
      update: {},
      create: { email: 'cocina@demo.com', password: await hashPassword('password'), name: 'Cocinero Demo', role: UserRole.KITCHEN_STAFF, businessId: business.id },
    }),
    prisma.user.upsert({
        where: { email: 'barra@demo.com' },
        update: {},
        create: { email: 'barra@demo.com', password: await hashPassword('password'), name: 'Barman Demo', role: UserRole.BAR_STAFF, businessId: business.id },
      })
  ]);
  console.log(`[SEED] Upserted Staff Users.`);
  
  // 3. CREAR MESAS PARA EL RESTAURANTE
  console.log(`[SEED] Creating tables for the business...`);
  const tableIdentifiers = [
    'M1', 'M2', 'M3', 'M4', 'M5', 'M6', // Mesas interiores
    'T1', 'T2', 'T3', 'T4', 'T5',       // Terraza
    'B1', 'B2', 'B3', 'B4'              // Barra
  ];

  // Borramos las mesas existentes de este negocio para empezar de cero
  await prisma.table.deleteMany({ where: { businessId: business.id } });

  const tableCreationPromises = tableIdentifiers.map(identifier => 
    prisma.table.create({
        data: {
            identifier,
            businessId: business.id,
            status: TableStatus.AVAILABLE,
            capacity: identifier.startsWith('M') ? 4 : (identifier.startsWith('T') ? 4 : 2) // Capacidad de ejemplo
        }
    })
  );

  await prisma.$transaction(tableCreationPromises);
  console.log(`[SEED] Created ${tableIdentifiers.length} tables.`);

  // 4. DEVOLVER LOS OBJETOS CREADOS
  return { business, admin, camarero, cocina, barra };
}


// ====== [17] backend/prisma/seed/_2_tiers.js ======
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.seedTiers = seedTiers;
// backend/prisma/seed/_2_tiers.ts
const client_1 = require("@prisma/client");
/**
 * Funci√≥n que crea los niveles de fidelizaci√≥n (Tiers) y les asigna beneficios.
 * Depende de que el negocio ya exista.
 * @param prisma - Instancia del PrismaClient.
 * @param businessId - El ID del negocio al que pertenecer√°n estos tiers.
 * @returns Un objeto con las entidades de Tier creadas.
 */
async function seedTiers(prisma, businessId) {
    console.log('--- Seeding [2]: Tiers & Benefits ---');
    // 1. CREAR LOS NIVELES (TIERS)
    // Usamos una transacci√≥n para crear todos los tiers a la vez. upsert es ideal aqu√≠.
    const [bronce, plata, oro, platino] = await prisma.$transaction([
        prisma.tier.upsert({
            where: { businessId_level: { businessId, level: 1 } },
            update: { name: 'Bronce', minValue: 50 },
            create: { name: 'Bronce', level: 1, minValue: 50, businessId }
        }),
        prisma.tier.upsert({
            where: { businessId_level: { businessId, level: 2 } },
            update: { name: 'Plata', minValue: 200 },
            create: { name: 'Plata', level: 2, minValue: 200, businessId }
        }),
        prisma.tier.upsert({
            where: { businessId_level: { businessId, level: 3 } },
            update: { name: 'Oro', minValue: 500 },
            create: { name: 'Oro', level: 3, minValue: 500, businessId }
        }),
        prisma.tier.upsert({
            where: { businessId_level: { businessId, level: 4 } },
            update: { name: 'Platino', minValue: 1500 },
            create: { name: 'Platino', level: 4, minValue: 1500, businessId }
        }),
    ]);
    console.log(`[SEED] Upserted Tiers: Bronce, Plata, Oro, Platino.`);
    // 2. ASIGNAR BENEFICIOS A LOS NIVELES (con la estrategia de create/catch)
    // Beneficio para el Nivel Oro: Multiplicador de Puntos
    try {
        await prisma.tierBenefit.create({
            data: {
                tierId: oro.id,
                type: client_1.BenefitType.POINTS_MULTIPLIER,
                value: "1.5",
                description: "Gana un 50% m√°s de puntos en todas tus compras."
            }
        });
    }
    catch (error) {
        if (error instanceof client_1.Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            console.log('[SEED] Oro benefit already exists, skipping creation.');
        }
        else {
            throw error; // Relanzar si es un error diferente
        }
    }
    // Beneficio para el Nivel Platino: Beneficio Personalizado (texto)
    try {
        await prisma.tierBenefit.create({
            data: {
                tierId: platino.id,
                type: client_1.BenefitType.CUSTOM_BENEFIT,
                value: "Postre gratis al mes",
                description: "Un postre de la casa por cortes√≠a una vez al mes."
            }
        });
    }
    catch (error) {
        if (error instanceof client_1.Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            console.log('[SEED] Platino benefit already exists, skipping creation.');
        }
        else {
            throw error; // Relanzar si es un error diferente
        }
    }
    console.log(`[SEED] Created or verified specific Benefits for Oro and Platino tiers.`);
    // 3. DEVOLVER LOS OBJETOS CREADOS
    return { bronce, plata, oro, platino };
}



// ====== [18] backend/prisma/seed/_2_tiers.ts ======
// backend/prisma/seed/_2_tiers.ts
import { PrismaClient, BenefitType, Tier, Prisma } from '@prisma/client';

/**
 * Funci√≥n que crea los niveles de fidelizaci√≥n (Tiers) y les asigna beneficios.
 * Depende de que el negocio ya exista.
 * @param prisma - Instancia del PrismaClient.
 * @param businessId - El ID del negocio al que pertenecer√°n estos tiers.
 * @returns Un objeto con las entidades de Tier creadas.
 */
export async function seedTiers(prisma: PrismaClient, businessId: string): Promise<{ bronce: Tier, plata: Tier, oro: Tier, platino: Tier }> {
    console.log('--- Seeding [2]: Tiers & Benefits ---');

    // 1. CREAR LOS NIVELES (TIERS)
    // Usamos una transacci√≥n para crear todos los tiers a la vez. upsert es ideal aqu√≠.
    const [bronce, plata, oro, platino] = await prisma.$transaction([
        prisma.tier.upsert({ 
            where: { businessId_level: { businessId, level: 1 } }, 
            update: { name: 'Bronce', minValue: 50 }, 
            create: { name: 'Bronce', level: 1, minValue: 50, businessId } 
        }),
        prisma.tier.upsert({ 
            where: { businessId_level: { businessId, level: 2 } }, 
            update: { name: 'Plata', minValue: 200 }, 
            create: { name: 'Plata', level: 2, minValue: 200, businessId } 
        }),
        prisma.tier.upsert({ 
            where: { businessId_level: { businessId, level: 3 } }, 
            update: { name: 'Oro', minValue: 500 }, 
            create: { name: 'Oro', level: 3, minValue: 500, businessId } 
        }),
        prisma.tier.upsert({ 
            where: { businessId_level: { businessId, level: 4 } }, 
            update: { name: 'Platino', minValue: 1500 }, 
            create: { name: 'Platino', level: 4, minValue: 1500, businessId } 
        }),
    ]);
    console.log(`[SEED] Upserted Tiers: Bronce, Plata, Oro, Platino.`);

    // 2. ASIGNAR BENEFICIOS A LOS NIVELES (con la estrategia de create/catch)
    
    // Beneficio para el Nivel Oro: Multiplicador de Puntos
    try {
        await prisma.tierBenefit.create({
            data: {
                tierId: oro.id,
                type: BenefitType.POINTS_MULTIPLIER,
                value: "1.5",
                description: "Gana un 50% m√°s de puntos en todas tus compras."
            }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            console.log('[SEED] Oro benefit already exists, skipping creation.');
        } else {
            throw error; // Relanzar si es un error diferente
        }
    }

    // Beneficio para el Nivel Platino: Beneficio Personalizado (texto)
    try {
        await prisma.tierBenefit.create({
            data: {
                tierId: platino.id,
                type: BenefitType.CUSTOM_BENEFIT,
                value: "Postre gratis al mes",
                description: "Un postre de la casa por cortes√≠a una vez al mes."
            }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            console.log('[SEED] Platino benefit already exists, skipping creation.');
        } else {
            throw error; // Relanzar si es un error diferente
        }
    }
    
    console.log(`[SEED] Created or verified specific Benefits for Oro and Platino tiers.`);
    
    // 3. DEVOLVER LOS OBJETOS CREADOS
    return { bronce, plata, oro, platino };
}


// ====== [19] backend/prisma/seed/_3_menu.js ======
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.seedMenu = seedMenu;
// Enum local para tipos de UI de modificadores, para evitar errores de importaci√≥n en el script
var SeedModifierUiType;
(function (SeedModifierUiType) {
    SeedModifierUiType["RADIO"] = "RADIO";
    SeedModifierUiType["CHECKBOX"] = "CHECKBOX";
})(SeedModifierUiType || (SeedModifierUiType = {}));
/**
 * Funci√≥n que crea la carta digital completa, incluyendo categor√≠as, √≠tems y modificadores complejos.
 * @param prisma - Instancia del PrismaClient.
 * @param businessId - El ID del negocio para asociar el men√∫.
 * @returns Un objeto con las entidades de men√∫ clave creadas.
 */
async function seedMenu(prisma, businessId) {
    console.log('--- Seeding [3]: Menu Categories, Items and Modifiers ---');
    // 1. CREAR CATEGOR√çAS
    const categories = {
        entrantes: await prisma.menuCategory.upsert({ where: { businessId_name_es: { businessId, name_es: 'Entrantes para Compartir' } }, update: {}, create: { name_es: 'Entrantes para Compartir', name_en: 'Starters to Share', businessId, position: 1, imageUrl: 'https://images.unsplash.com/photo-1572441713135-c70a27b8a53c?q=80&w=800' } }),
        principales: await prisma.menuCategory.upsert({ where: { businessId_name_es: { businessId, name_es: 'Platos Principales' } }, update: {}, create: { name_es: 'Platos Principales', name_en: 'Main Courses', businessId, position: 2, imageUrl: 'https://images.unsplash.com/photo-1559847844-5315695d9e16?q=80&w=800' } }),
        postres: await prisma.menuCategory.upsert({ where: { businessId_name_es: { businessId, name_es: 'Postres Caseros' } }, update: {}, create: { name_es: 'Postres Caseros', name_en: 'Homemade Desserts', businessId, position: 3, imageUrl: 'https://images.unsplash.com/photo-1551024601-bec78aea704b?q=80&w=800' } }),
        bebidas: await prisma.menuCategory.upsert({ where: { businessId_name_es: { businessId, name_es: 'Bebidas y Refrescos' } }, update: {}, create: { name_es: 'Bebidas y Refrescos', name_en: 'Drinks & Beverages', businessId, position: 4, imageUrl: 'https://images.unsplash.com/photo-1573245929259-693680407254?q=80&w=800' } }),
    };
    console.log(`[SEED] Upserted Menu Categories.`);
    // 2. CREAR √çTEMS DE MEN√ö
    const gazpacho = await prisma.menuItem.upsert({ where: { categoryId_name_es: { categoryId: categories.entrantes.id, name_es: "Gazpacho Andaluz Fresco" } }, update: {}, create: { name_es: "Gazpacho Andaluz Fresco", name_en: "Fresh Andalusian Gazpacho", price: 7.50, kdsDestination: "COCINA", categoryId: categories.entrantes.id, businessId, allergens: ['GLUTEN'], tags: ['VEGAN', 'VEGETARIAN'] } });
    const hamburguesa = await prisma.menuItem.upsert({ where: { categoryId_name_es: { categoryId: categories.principales.id, name_es: "Hamburguesa 'La Jefa'" } }, update: {}, create: { name_es: "Hamburguesa 'La Jefa'", name_en: "'The Boss' Burger", price: 13.50, description_es: "200gr de ternera, pan brioche, lechuga, tomate, cheddar y nuestra salsa especial.", kdsDestination: "COCINA", categoryId: categories.principales.id, businessId, imageUrl: 'https://images.unsplash.com/photo-1568901346375-23c9450c58cd?q=80&w=800' } });
    const salmon = await prisma.menuItem.upsert({ where: { categoryId_name_es: { categoryId: categories.principales.id, name_es: "Salm√≥n Fresco (No Disponible)" } }, update: {}, create: { name_es: "Salm√≥n Fresco (No Disponible)", name_en: "Fresh Salmon (Unavailable)", price: 18.00, kdsDestination: "COCINA", categoryId: categories.principales.id, businessId, isAvailable: false } });
    const tarta = await prisma.menuItem.upsert({ where: { categoryId_name_es: { categoryId: categories.postres.id, name_es: "Tarta de Queso Cremosa" } }, update: {}, create: { name_es: "Tarta de Queso Cremosa", name_en: "Creamy Cheesecake", price: 6.50, kdsDestination: "COCINA", categoryId: categories.postres.id, businessId, imageUrl: 'https://images.unsplash.com/photo-1587314168485-3236d6710814?q=80&w=800' } });
    const cafe = await prisma.menuItem.upsert({ where: { categoryId_name_es: { categoryId: categories.bebidas.id, name_es: "Caf√© Espresso" } }, update: {}, create: { name_es: "Caf√© Espresso", name_en: "Espresso Coffee", price: 1.80, kdsDestination: "BARRA", sku: "COFF-ESP", categoryId: categories.bebidas.id, businessId, imageUrl: 'https://images.unsplash.com/photo-1599399125934-e4a4c62648e2?q=80&w=800' } });
    const refresco = await prisma.menuItem.upsert({ where: { categoryId_name_es: { categoryId: categories.bebidas.id, name_es: "Refresco de Cola" } }, update: {}, create: { name_es: "Refresco de Cola", name_en: "Cola Drink", price: 2.50, kdsDestination: "BARRA", sku: "COKE-330", categoryId: categories.bebidas.id, businessId } });
    console.log(`[SEED] Upserted Menu Items.`);
    // 3. CREAR MODIFICADORES PARA LA HAMBURGUESA
    await prisma.modifierGroup.deleteMany({ where: { menuItemId: hamburguesa.id } }); // Limpiar modificadores viejos para este √≠tem
    // Grupo "Punto de la Carne"
    const puntoCarneGroup = await prisma.modifierGroup.create({ data: { name_es: 'Punto de la Carne', name_en: 'Meat Doneness', uiType: SeedModifierUiType.RADIO, isRequired: true, minSelections: 1, maxSelections: 1, position: 1, menuItemId: hamburguesa.id, businessId } });
    await prisma.modifierOption.createMany({ data: [
            { name_es: 'Poco Hecha', name_en: 'Rare', groupId: puntoCarneGroup.id, position: 1 },
            { name_es: 'Al Punto', name_en: 'Medium', groupId: puntoCarneGroup.id, position: 2, isDefault: true },
            { name_es: 'Muy Hecha', name_en: 'Well-done', groupId: puntoCarneGroup.id, position: 3 }
        ] });
    // Grupo "Extras"
    const extrasGroup = await prisma.modifierGroup.create({ data: { name_es: 'A√±ade Extras', name_en: 'Add Extras', uiType: SeedModifierUiType.CHECKBOX, isRequired: false, minSelections: 0, maxSelections: 3, position: 2, menuItemId: hamburguesa.id, businessId } });
    await prisma.modifierOption.createMany({ data: [
            { name_es: 'Queso Extra', name_en: 'Extra Cheese', priceAdjustment: 1.20, groupId: extrasGroup.id, position: 1 },
            { name_es: 'Bacon Extra', name_en: 'Extra Bacon', priceAdjustment: 1.50, groupId: extrasGroup.id, position: 2 },
            { name_es: 'Huevo Frito', name_en: 'Fried Egg', priceAdjustment: 1.80, groupId: extrasGroup.id, position: 3 }
        ] });
    console.log(`[SEED] Created Modifiers for Hamburger.`);
    return { hamburguesa, tarta, cafe, refresco, puntoCarneGroup, extrasGroup };
}



// ====== [20] backend/prisma/seed/_3_menu.ts ======
// backend/prisma/seed/_3_menu.ts
import { PrismaClient, Prisma } from '@prisma/client';
// --- CORRECCI√ìN: uuidv4 ya no es necesario ---

enum SeedModifierUiType {
    RADIO = 'RADIO',
    CHECKBOX = 'CHECKBOX',
}

export async function seedMenu(prisma: PrismaClient, businessId: string) {
    console.log('--- Seeding [3]: Menu Categories, Items and Modifiers ---');

    // 1. CREAR CATEGOR√çAS (sin cambios)
    const categories = {
      entrantes: await prisma.menuCategory.upsert({ where: { businessId_name_es: { businessId, name_es: 'Entrantes para Compartir' } }, update: {}, create: { name_es: 'Entrantes para Compartir', name_en: 'Starters to Share', businessId, position: 1, imageUrl: 'https://images.unsplash.com/photo-1572441713135-c70a27b8a53c?q=80&w=800' } }),
      principales: await prisma.menuCategory.upsert({ where: { businessId_name_es: { businessId, name_es: 'Platos Principales' } }, update: {}, create: { name_es: 'Platos Principales', name_en: 'Main Courses', businessId, position: 2, imageUrl: 'https://images.unsplash.com/photo-1559847844-5315695d9e16?q=80&w=800' } }),
      postres: await prisma.menuCategory.upsert({ where: { businessId_name_es: { businessId, name_es: 'Postres Caseros' } }, update: {}, create: { name_es: 'Postres Caseros', name_en: 'Homemade Desserts', businessId, position: 3, imageUrl: 'https://images.unsplash.com/photo-1551024601-bec78aea704b?q=80&w=800' } }),
      bebidas: await prisma.menuCategory.upsert({ where: { businessId_name_es: { businessId, name_es: 'Bebidas y Refrescos' } }, update: {}, create: { name_es: 'Bebidas y Refrescos', name_en: 'Drinks & Beverages', businessId, position: 4, imageUrl: 'https://images.unsplash.com/photo-1573245929259-693680407254?q=80&w=800' } }),
    };
    console.log(`[SEED] Upserted Menu Categories.`);

    // 2. CREAR √çTEMS DE MEN√ö (sin cambios, excepto eliminar item de salm√≥n no usado y refresco)
    const hamburguesa = await prisma.menuItem.upsert({ where: { categoryId_name_es: { categoryId: categories.principales.id, name_es: "Hamburguesa 'La Jefa'" } }, update: {}, create: { name_es: "Hamburguesa 'La Jefa'", name_en: "'The Boss' Burger", price: 13.50, description_es: "200gr de ternera, pan brioche, lechuga, tomate, cheddar y nuestra salsa especial.", kdsDestination: "COCINA", categoryId: categories.principales.id, businessId, imageUrl: 'https://images.unsplash.com/photo-1568901346375-23c9450c58cd?q=80&w=800' } });
    const tarta = await prisma.menuItem.upsert({ where: { categoryId_name_es: { categoryId: categories.postres.id, name_es: "Tarta de Queso Cremosa" } }, update: {}, create: { name_es: "Tarta de Queso Cremosa", name_en: "Creamy Cheesecake", price: 6.50, kdsDestination: "COCINA", categoryId: categories.postres.id, businessId, imageUrl: 'https://images.unsplash.com/photo-1587314168485-3236d6710814?q=80&w=800' } });
    const cafe = await prisma.menuItem.upsert({ where: { categoryId_name_es: { categoryId: categories.bebidas.id, name_es: "Caf√© Espresso" } }, update: {}, create: { name_es: "Caf√© Espresso", name_en: "Espresso Coffee", price: 1.80, kdsDestination: "BARRA", sku: "COFF-ESP", categoryId: categories.bebidas.id, businessId, imageUrl: 'https://images.unsplash.com/photo-1599399125934-e4a4c62648e2?q=80&w=800' } });
    const refresco = await prisma.menuItem.upsert({ where: { categoryId_name_es: { categoryId: categories.bebidas.id, name_es: "Refresco de Cola" } }, update: {}, create: { name_es: "Refresco de Cola", name_en: "Cola Drink", price: 2.50, kdsDestination: "BARRA", sku: "COKE-330", categoryId: categories.bebidas.id, businessId } });

    console.log(`[SEED] Upserted Menu Items.`);
    
    // 3. CREAR MODIFICADORES PARA LA HAMBURGUESA
    await prisma.modifierGroup.deleteMany({ where: { menuItemId: hamburguesa.id }}); // Limpiar modificadores viejos para este √≠tem

    // Grupo "Punto de la Carne"
    const puntoCarneGroup = await prisma.modifierGroup.create({ data: { name_es: 'Punto de la Carne', name_en: 'Meat Doneness', uiType: SeedModifierUiType.RADIO, isRequired: true, minSelections: 1, maxSelections: 1, position: 1, menuItemId: hamburguesa.id, businessId } });
    
    // --- CORRECCI√ìN: Eliminado el `id: uuidv4()` de la creaci√≥n de opciones ---
    // Prisma generar√° autom√°ticamente el ID (un CUID) seg√∫n el schema.
    await prisma.modifierOption.createMany({ data: [
            { name_es: 'Poco Hecha', name_en: 'Rare', groupId: puntoCarneGroup.id, position: 1 },
            { name_es: 'Al Punto', name_en: 'Medium', groupId: puntoCarneGroup.id, position: 2, isDefault: true },
            { name_es: 'Muy Hecha', name_en: 'Well-done', groupId: puntoCarneGroup.id, position: 3 }
        ] });

    // Grupo "Extras"
    const extrasGroup = await prisma.modifierGroup.create({ data: { name_es: 'A√±ade Extras', name_en: 'Add Extras', uiType: SeedModifierUiType.CHECKBOX, isRequired: false, minSelections: 0, maxSelections: 3, position: 2, menuItemId: hamburguesa.id, businessId } });
    
    // --- CORRECCI√ìN: Eliminado el `id: uuidv4()` de la creaci√≥n de opciones ---
    await prisma.modifierOption.createMany({ data: [
            { name_es: 'Queso Extra', name_en: 'Extra Cheese', priceAdjustment: 1.20, groupId: extrasGroup.id, position: 1 },
            { name_es: 'Bacon Extra', name_en: 'Extra Bacon', priceAdjustment: 1.50, groupId: extrasGroup.id, position: 2 },
            { name_es: 'Huevo Frito', name_en: 'Fried Egg', priceAdjustment: 1.80, groupId: extrasGroup.id, position: 3 }
        ] });

    console.log(`[SEED] Created Modifiers for Hamburger correctly.`);

    // --- CORRECCI√ìN: He a√±adido `refresco` al objeto devuelto para que coincida con la firma ---
    return { hamburguesa, tarta, cafe, refresco, puntoCarneGroup, extrasGroup };
}


// ====== [21] backend/prisma/seed/_4_users.js ======
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.seedUsers = seedUsers;
// backend/prisma/seed/_4_users.ts
const client_1 = require("@prisma/client");
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const date_fns_1 = require("date-fns");
// Funci√≥n helper para hashear contrase√±as
async function hashPassword(password) {
    const salt = await bcryptjs_1.default.genSalt(10);
    return bcryptjs_1.default.hash(password, salt);
}
/**
 * Funci√≥n que crea los diferentes perfiles de cliente (personas).
 * Depende de que el negocio y los tiers ya existan.
 * @param prisma - Instancia del PrismaClient.
 * @param businessId - El ID del negocio al que pertenecer√°n los clientes.
 * @param tiers - Un objeto que contiene los tiers creados para asignar a los usuarios.
 * @returns Un objeto con las entidades de los clientes creados.
 */
async function seedUsers(prisma, businessId, tiers) {
    console.log('--- Seeding [4]: Customer Personas ---');
    // Usamos una transacci√≥n para crear todos los usuarios de una vez.
    const [anaOro, carlosPlata, davidNuevo, elenaInactiva, fernandoCero, usuarioDesactivado] = await prisma.$transaction([
        // 1. Ana "Oro": Cliente VIP
        prisma.user.upsert({
            where: { email: 'poweruser@demo.com' },
            update: { currentTierId: tiers.oro.id }, // Asegurar que tiene el tier correcto si ya existe
            create: {
                email: 'poweruser@demo.com', password: await hashPassword('password'), name: 'Ana "Oro" Garc√≠a', phone: '+34000000002',
                documentId: '00000002B', documentType: client_1.DocumentType.DNI, role: client_1.UserRole.CUSTOMER_FINAL, businessId,
                points: 2500, totalSpend: 850.50, totalVisits: 28, currentTierId: tiers.oro.id,
                tierAchievedAt: new Date(), lastActivityAt: (0, date_fns_1.subDays)(new Date(), 1)
            }
        }),
        // 2. Carlos "Plata": Cliente regular
        prisma.user.upsert({
            where: { email: 'mid-tier@demo.com' },
            update: { currentTierId: tiers.plata.id },
            create: {
                email: 'mid-tier@demo.com', password: await hashPassword('password'), name: 'Carlos "Plata" Ruiz', phone: '+34000000004',
                documentId: '00000004D', documentType: client_1.DocumentType.DNI, role: client_1.UserRole.CUSTOMER_FINAL, businessId,
                points: 350, totalSpend: 250.00, totalVisits: 8, currentTierId: tiers.plata.id,
                tierAchievedAt: (0, date_fns_1.subDays)(new Date(), 20), lastActivityAt: (0, date_fns_1.subDays)(new Date(), 5)
            }
        }),
        // 3. David "Nuevo": Cliente reciente
        prisma.user.upsert({
            where: { email: 'newuser@demo.com' },
            update: { currentTierId: tiers.bronce.id },
            create: {
                email: 'newuser@demo.com', password: await hashPassword('password'), name: 'David "Nuevo" Lopez', phone: '+34000000003',
                documentId: '00000003C', documentType: client_1.DocumentType.DNI, role: client_1.UserRole.CUSTOMER_FINAL, businessId,
                points: 65, totalSpend: 65.00, totalVisits: 2, currentTierId: tiers.bronce.id,
                tierAchievedAt: (0, date_fns_1.subDays)(new Date(), 3), createdAt: (0, date_fns_1.subDays)(new Date(), 3), lastActivityAt: (0, date_fns_1.subDays)(new Date(), 3)
            }
        }),
        // 4. Elena "Inactiva": Cliente para pruebas de downgrade
        prisma.user.upsert({
            where: { email: 'inactive@demo.com' },
            update: { currentTierId: tiers.bronce.id, lastActivityAt: (0, date_fns_1.subMonths)(new Date(), 7) },
            create: {
                email: 'inactive@demo.com', password: await hashPassword('password'), name: 'Elena "Inactiva" Martinez', phone: '+34000000005',
                documentId: '00000005E', documentType: client_1.DocumentType.DNI, role: client_1.UserRole.CUSTOMER_FINAL, businessId,
                points: 120, totalSpend: 110.00, totalVisits: 3, currentTierId: tiers.bronce.id,
                createdAt: (0, date_fns_1.subMonths)(new Date(), 8), lastActivityAt: (0, date_fns_1.subMonths)(new Date(), 7)
            }
        }),
        // 5. Fernando "Cero": Cliente sin actividad
        prisma.user.upsert({
            where: { email: 'zeropoints@demo.com' },
            update: {},
            create: {
                email: 'zeropoints@demo.com', password: await hashPassword('password'), name: 'Fernando "Cero" Sanchez', phone: '+34000000006',
                documentId: '00000006F', documentType: client_1.DocumentType.DNI, role: client_1.UserRole.CUSTOMER_FINAL, businessId,
                points: 0, totalSpend: 0, totalVisits: 0, createdAt: (0, date_fns_1.subDays)(new Date(), 10)
            }
        }),
        // 6. Usuario Desactivado
        prisma.user.upsert({
            where: { email: 'deactivated@demo.com' },
            update: { isActive: false },
            create: {
                email: 'deactivated@demo.com', password: await hashPassword('password'), name: 'Usuario Desactivado', phone: '+34000000007',
                documentId: '00000007G', documentType: client_1.DocumentType.DNI, role: client_1.UserRole.CUSTOMER_FINAL, businessId,
                points: 50, isActive: false
            }
        })
    ]);
    console.log(`[SEED] Upserted Customer Personas.`);
    return { anaOro, carlosPlata, davidNuevo, elenaInactiva, fernandoCero, usuarioDesactivado };
}



// ====== [22] backend/prisma/seed/_4_users.ts ======
// backend/prisma/seed/_4_users.ts
import { PrismaClient, UserRole, DocumentType, Tier } from '@prisma/client';
import bcrypt from 'bcryptjs';
import { subDays, subMonths } from 'date-fns';

// Funci√≥n helper para hashear contrase√±as
async function hashPassword(password: string) {
  const salt = await bcrypt.genSalt(10);
  return bcrypt.hash(password, salt);
}

// Interfaz para la dependencia de tiers, para que TypeScript sepa qu√© esperar
interface TierDeps {
    bronce: Tier;
    plata: Tier;
    oro: Tier;
}

/**
 * Funci√≥n que crea los diferentes perfiles de cliente (personas).
 * Depende de que el negocio y los tiers ya existan.
 * @param prisma - Instancia del PrismaClient.
 * @param businessId - El ID del negocio al que pertenecer√°n los clientes.
 * @param tiers - Un objeto que contiene los tiers creados para asignar a los usuarios.
 * @returns Un objeto con las entidades de los clientes creados.
 */
export async function seedUsers(prisma: PrismaClient, businessId: string, tiers: TierDeps) {
  console.log('--- Seeding [4]: Customer Personas ---');
  
  // Usamos una transacci√≥n para crear todos los usuarios de una vez.
  const [anaOro, carlosPlata, davidNuevo, elenaInactiva, fernandoCero, usuarioDesactivado] = await prisma.$transaction([
    // 1. Ana "Oro": Cliente VIP
    prisma.user.upsert({ 
        where: { email: 'poweruser@demo.com' }, 
        update: { currentTierId: tiers.oro.id }, // Asegurar que tiene el tier correcto si ya existe
        create: { 
            email: 'poweruser@demo.com', password: await hashPassword('password'), name: 'Ana "Oro" Garc√≠a', phone: '+34000000002', 
            documentId: '00000002B', documentType: DocumentType.DNI, role: UserRole.CUSTOMER_FINAL, businessId, 
            points: 2500, totalSpend: 850.50, totalVisits: 28, currentTierId: tiers.oro.id, 
            tierAchievedAt: new Date(), lastActivityAt: subDays(new Date(), 1) 
        } 
    }),
    
    // 2. Carlos "Plata": Cliente regular
    prisma.user.upsert({ 
        where: { email: 'mid-tier@demo.com' }, 
        update: { currentTierId: tiers.plata.id },
        create: { 
            email: 'mid-tier@demo.com', password: await hashPassword('password'), name: 'Carlos "Plata" Ruiz', phone: '+34000000004', 
            documentId: '00000004D', documentType: DocumentType.DNI, role: UserRole.CUSTOMER_FINAL, businessId, 
            points: 350, totalSpend: 250.00, totalVisits: 8, currentTierId: tiers.plata.id, 
            tierAchievedAt: subDays(new Date(), 20), lastActivityAt: subDays(new Date(), 5) 
        } 
    }),
    
    // 3. David "Nuevo": Cliente reciente
    prisma.user.upsert({ 
        where: { email: 'newuser@demo.com' }, 
        update: { currentTierId: tiers.bronce.id },
        create: { 
            email: 'newuser@demo.com', password: await hashPassword('password'), name: 'David "Nuevo" Lopez', phone: '+34000000003', 
            documentId: '00000003C', documentType: DocumentType.DNI, role: UserRole.CUSTOMER_FINAL, businessId, 
            points: 65, totalSpend: 65.00, totalVisits: 2, currentTierId: tiers.bronce.id, 
            tierAchievedAt: subDays(new Date(), 3), createdAt: subDays(new Date(), 3), lastActivityAt: subDays(new Date(), 3) 
        } 
    }),
    
    // 4. Elena "Inactiva": Cliente para pruebas de downgrade
    prisma.user.upsert({ 
        where: { email: 'inactive@demo.com' }, 
        update: { currentTierId: tiers.bronce.id, lastActivityAt: subMonths(new Date(), 7) },
        create: { 
            email: 'inactive@demo.com', password: await hashPassword('password'), name: 'Elena "Inactiva" Martinez', phone: '+34000000005', 
            documentId: '00000005E', documentType: DocumentType.DNI, role: UserRole.CUSTOMER_FINAL, businessId, 
            points: 120, totalSpend: 110.00, totalVisits: 3, currentTierId: tiers.bronce.id, 
            createdAt: subMonths(new Date(), 8), lastActivityAt: subMonths(new Date(), 7) 
        } 
    }),
    
    // 5. Fernando "Cero": Cliente sin actividad
    prisma.user.upsert({ 
        where: { email: 'zeropoints@demo.com' }, 
        update: {},
        create: { 
            email: 'zeropoints@demo.com', password: await hashPassword('password'), name: 'Fernando "Cero" Sanchez', phone: '+34000000006', 
            documentId: '00000006F', documentType: DocumentType.DNI, role: UserRole.CUSTOMER_FINAL, businessId, 
            points: 0, totalSpend: 0, totalVisits: 0, createdAt: subDays(new Date(), 10) 
        } 
    }),

    // 6. Usuario Desactivado
    prisma.user.upsert({
        where: { email: 'deactivated@demo.com' },
        update: { isActive: false },
        create: {
            email: 'deactivated@demo.com', password: await hashPassword('password'), name: 'Usuario Desactivado', phone: '+34000000007',
            documentId: '00000007G', documentType: DocumentType.DNI, role: UserRole.CUSTOMER_FINAL, businessId,
            points: 50, isActive: false
        }
    })
  ]);

  console.log(`[SEED] Upserted Customer Personas.`);

  return { anaOro, carlosPlata, davidNuevo, elenaInactiva, fernandoCero, usuarioDesactivado };
}


// ====== [23] backend/prisma/seed/_5_activity.js ======
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.seedActivity = seedActivity;
// backend/prisma/seed/_5_activity.ts
const client_1 = require("@prisma/client");
const date_fns_1 = require("date-fns");
const uuid_1 = require("uuid");
/**
 * Funci√≥n que crea el cat√°logo de recompensas y simula actividad hist√≥rica.
 */
async function seedActivity(prisma, deps) {
    const { business, admin, anaOro, carlosPlata, davidNuevo, hamburguesa, tarta, cafe, puntoCarneGroup, extrasGroup } = deps;
    console.log('--- Seeding [5]: Rewards, History & Transactions ---');
    // 1. CREAR CAT√ÅLOGO DE RECOMPENSAS
    const rewards = {
        tartaGratis: await prisma.reward.upsert({ where: { unique_reward_name_es_business: { businessId: business.id, name_es: "Tarta de Queso Gratis (de la Carta)" } }, update: {}, create: { name_es: "Tarta de Queso Gratis (de la Carta)", name_en: "Free Cheesecake (from Menu)", pointsCost: 80, type: client_1.RewardType.MENU_ITEM, linkedMenuItemId: tarta.id, businessId: business.id, imageUrl: tarta.imageUrl } }),
        gorra: await prisma.reward.upsert({ where: { unique_reward_name_es_business: { businessId: business.id, name_es: "Gorra Exclusiva LoyalPyME" } }, update: {}, create: { name_es: "Gorra Exclusiva LoyalPyME", name_en: "Exclusive LoyalPyME Cap", pointsCost: 250, type: client_1.RewardType.GENERIC_FREE_PRODUCT, kdsDestination: "BARRA", businessId: business.id } }),
        descuentoTotal: await prisma.reward.upsert({ where: { unique_reward_name_es_business: { businessId: business.id, name_es: "5‚Ç¨ de Descuento en tu Cuenta" } }, update: {}, create: { name_es: "5‚Ç¨ de Descuento en tu Cuenta", name_en: "5‚Ç¨ Off Your Bill", pointsCost: 100, type: client_1.RewardType.DISCOUNT_ON_TOTAL, discountType: client_1.DiscountType.FIXED_AMOUNT, discountValue: new client_1.Prisma.Decimal(5.00), businessId: business.id } }),
        descuentoBurger: await prisma.reward.upsert({ where: { unique_reward_name_es_business: { businessId: business.id, name_es: "50% Dto. en Hamburguesa 'La Jefa'" } }, update: {}, create: { name_es: "50% Dto. en Hamburguesa 'La Jefa'", name_en: "50% Off 'The Boss' Burger", pointsCost: 120, type: client_1.RewardType.DISCOUNT_ON_ITEM, discountType: client_1.DiscountType.PERCENTAGE, discountValue: new client_1.Prisma.Decimal(50), linkedMenuItemId: hamburguesa.id, businessId: business.id } }),
    };
    console.log(`[SEED] Upserted Rewards Catalog.`);
    // 2. CREAR HISTORIAL DE ACTIVIDAD
    const qr1 = await prisma.qrCode.create({ data: { token: (0, uuid_1.v4)(), businessId: business.id, amount: 25.50, ticketNumber: "T-HIST-001", expiresAt: new Date(), status: client_1.QrCodeStatus.COMPLETED, userId: davidNuevo.id, pointsEarned: 25, completedAt: (0, date_fns_1.subDays)(new Date(), 3) } });
    await prisma.activityLog.create({ data: { userId: davidNuevo.id, businessId: business.id, type: client_1.ActivityType.POINTS_EARNED_QR, pointsChanged: 25, description: "T-HIST-001", relatedQrId: qr1.id } });
    // Pedido Activo para probar flujo de camarero
    const mesa5 = await prisma.table.findFirst({ where: { identifier: 'M5', businessId: business.id } });
    if (mesa5) {
        await prisma.order.create({ data: {
                orderNumber: `LIVE-${(0, date_fns_1.formatISO)(new Date(), { representation: 'date' })}-01`,
                status: client_1.OrderStatus.COMPLETED,
                businessId: business.id,
                customerLCoId: anaOro.id,
                tableId: mesa5.id,
                totalAmount: 18.30,
                finalAmount: 18.30,
                items: {
                    create: [
                        { menuItemId: cafe.id, quantity: 1, totalItemPrice: 1.80, priceAtPurchase: 1.80, status: client_1.OrderItemStatus.SERVED },
                        { menuItemId: tarta.id, quantity: 1, totalItemPrice: 6.50, priceAtPurchase: 6.50, status: client_1.OrderItemStatus.SERVED }
                    ]
                }
            } });
        await prisma.table.update({ where: { id: mesa5.id }, data: { status: client_1.TableStatus.OCCUPIED } });
        console.log(`[SEED] Created an ACTIVE (unpaid) order on Table M5.`);
    }
    const opAlPunto = await prisma.modifierOption.findFirst({ where: { groupId: puntoCarneGroup.id, name_es: 'Al Punto' } });
    const opBacon = await prisma.modifierOption.findFirst({ where: { groupId: extrasGroup.id, name_es: 'Bacon Extra' } });
    if (opAlPunto && opBacon) {
        const priceWithModifiers = new client_1.Prisma.Decimal(hamburguesa.price).add(opBacon.priceAdjustment);
        const orderItemDataWithMods = {
            menuItemId: hamburguesa.id, quantity: 1, priceAtPurchase: priceWithModifiers, totalItemPrice: priceWithModifiers,
            status: client_1.OrderItemStatus.SERVED, itemNameSnapshot: hamburguesa.name_es,
            selectedModifiers: { createMany: { data: [
                        { modifierOptionId: opAlPunto.id, optionNameSnapshot: opAlPunto.name_es, optionPriceAdjustmentSnapshot: opAlPunto.priceAdjustment },
                        { modifierOptionId: opBacon.id, optionNameSnapshot: opBacon.name_es, optionPriceAdjustmentSnapshot: opBacon.priceAdjustment }
                    ] } }
        };
        await prisma.order.create({
            data: {
                orderNumber: `HIST-${(0, date_fns_1.formatISO)((0, date_fns_1.subDays)(new Date(), 1), { representation: 'date' })}-01`,
                status: client_1.OrderStatus.PAID, businessId: business.id, customerLCoId: anaOro.id,
                createdAt: (0, date_fns_1.subDays)(new Date(), 1), paidAt: (0, date_fns_1.subDays)(new Date(), 1),
                totalAmount: priceWithModifiers, finalAmount: priceWithModifiers,
                items: { create: [orderItemDataWithMods] }
            }
        });
    }
    await prisma.order.create({ data: {
            orderNumber: `HIST-${(0, date_fns_1.formatISO)((0, date_fns_1.subDays)(new Date(), 5), { representation: 'date' })}-02`, status: client_1.OrderStatus.PAID, businessId: business.id,
            customerLCoId: carlosPlata.id, createdAt: (0, date_fns_1.subDays)(new Date(), 5), paidAt: (0, date_fns_1.subDays)(new Date(), 5),
            totalAmount: 8.30, discountAmount: 5.00, finalAmount: 3.30, appliedLcoRewardId: rewards.descuentoTotal.id,
            items: { create: [
                    { menuItemId: tarta.id, quantity: 1, totalItemPrice: 6.50, priceAtPurchase: 6.50, status: client_1.OrderItemStatus.SERVED, itemNameSnapshot: tarta.name_es },
                    { menuItemId: cafe.id, quantity: 1, totalItemPrice: 1.80, priceAtPurchase: 1.80, status: client_1.OrderItemStatus.SERVED, itemNameSnapshot: cafe.name_es }
                ] }
        } });
    await prisma.order.create({ data: {
            orderNumber: `HIST-${(0, date_fns_1.formatISO)((0, date_fns_1.subDays)(new Date(), 8), { representation: 'date' })}-03`, status: client_1.OrderStatus.PAID, businessId: business.id,
            customerLCoId: davidNuevo.id, createdAt: (0, date_fns_1.subDays)(new Date(), 8), paidAt: (0, date_fns_1.subDays)(new Date(), 8),
            totalAmount: 1.80, finalAmount: 1.80,
            items: { create: [
                    { menuItemId: cafe.id, quantity: 1, totalItemPrice: 1.80, priceAtPurchase: 1.80, status: client_1.OrderItemStatus.SERVED, itemNameSnapshot: cafe.name_es },
                    { menuItemId: tarta.id, redeemedRewardId: rewards.tartaGratis.id, quantity: 1, totalItemPrice: 0, priceAtPurchase: 0, status: client_1.OrderItemStatus.SERVED, itemNameSnapshot: `GRATIS: ${tarta.name_es}` }
                ] }
        } });
    console.log(`[SEED] Created historical paid orders.`);
    // 3. CREAR REGALOS Y CUPONES (GRANTED REWARDS)
    await prisma.grantedReward.create({ data: { userId: anaOro.id, rewardId: rewards.tartaGratis.id, businessId: business.id, assignedById: admin.id, status: client_1.GrantedRewardStatus.PENDING, expiresAt: (0, date_fns_1.addDays)(new Date(), 30) } });
    if (rewards.gorra) {
        const grantedReward = await prisma.grantedReward.create({ data: { userId: carlosPlata.id, rewardId: rewards.gorra.id, businessId: business.id, status: client_1.GrantedRewardStatus.AVAILABLE, redeemedAt: new Date() } });
        await prisma.activityLog.create({ data: { userId: carlosPlata.id, businessId: business.id, type: client_1.ActivityType.REWARD_ACQUIRED, pointsChanged: -rewards.gorra.pointsCost, description: `Has obtenido la recompensa: '${rewards.gorra.name_es}'`, relatedRewardId: rewards.gorra.id, relatedGrantedRewardId: grantedReward.id } });
    }
    console.log(`[SEED] Created pending gift and available coupon.`);
}



// ====== [24] backend/prisma/seed/_5_activity.ts ======
// backend/prisma/seed/_5_activity.ts
import { 
    PrismaClient, Prisma, RewardType, DiscountType, ActivityType, GrantedRewardStatus, 
    QrCodeStatus, OrderStatus, OrderItemStatus, Business, User, MenuItem, ModifierGroup, TableStatus 
} from '@prisma/client';
import { subDays, formatISO, addDays } from 'date-fns';
import { v4 as uuidv4 } from 'uuid';

// Interfaz para las dependencias que necesita este script
interface SeedActivityDeps {
    business: Business;
    admin: User;
    anaOro: User;
    carlosPlata: User;
    davidNuevo: User;
    hamburguesa: MenuItem;
    tarta: MenuItem;
    cafe: MenuItem;
    puntoCarneGroup: ModifierGroup;
    extrasGroup: ModifierGroup;
}

/**
 * Funci√≥n que crea el cat√°logo de recompensas y simula actividad hist√≥rica.
 */
export async function seedActivity(prisma: PrismaClient, deps: SeedActivityDeps) {
    const { business, admin, anaOro, carlosPlata, davidNuevo, hamburguesa, tarta, cafe, puntoCarneGroup, extrasGroup } = deps;
    
    console.log('--- Seeding [5]: Rewards, History & Transactions ---');

    // 1. CREAR CAT√ÅLOGO DE RECOMPENSAS
    const rewards = {
      tartaGratis: await prisma.reward.upsert({ where: { unique_reward_name_es_business: { businessId: business.id, name_es: "Tarta de Queso Gratis (de la Carta)" } }, update: {}, create: { name_es: "Tarta de Queso Gratis (de la Carta)", name_en: "Free Cheesecake (from Menu)", pointsCost: 80, type: RewardType.MENU_ITEM, linkedMenuItemId: tarta.id, businessId: business.id, imageUrl: tarta.imageUrl } }),
      gorra: await prisma.reward.upsert({ where: { unique_reward_name_es_business: { businessId: business.id, name_es: "Gorra Exclusiva LoyalPyME" } }, update: {}, create: { name_es: "Gorra Exclusiva LoyalPyME", name_en: "Exclusive LoyalPyME Cap", pointsCost: 250, type: RewardType.GENERIC_FREE_PRODUCT, kdsDestination: "BARRA", businessId: business.id } }),
      descuentoTotal: await prisma.reward.upsert({ where: { unique_reward_name_es_business: { businessId: business.id, name_es: "5‚Ç¨ de Descuento en tu Cuenta" } }, update: {}, create: { name_es: "5‚Ç¨ de Descuento en tu Cuenta", name_en: "5‚Ç¨ Off Your Bill", pointsCost: 100, type: RewardType.DISCOUNT_ON_TOTAL, discountType: DiscountType.FIXED_AMOUNT, discountValue: new Prisma.Decimal(5.00), businessId: business.id } }),
      descuentoBurger: await prisma.reward.upsert({ where: { unique_reward_name_es_business: { businessId: business.id, name_es: "50% Dto. en Hamburguesa 'La Jefa'" } }, update: {}, create: { name_es: "50% Dto. en Hamburguesa 'La Jefa'", name_en: "50% Off 'The Boss' Burger", pointsCost: 120, type: RewardType.DISCOUNT_ON_ITEM, discountType: DiscountType.PERCENTAGE, discountValue: new Prisma.Decimal(50), linkedMenuItemId: hamburguesa.id, businessId: business.id } }),
    };
    console.log(`[SEED] Upserted Rewards Catalog.`);

    // 2. CREAR HISTORIAL DE ACTIVIDAD
    
    const qr1 = await prisma.qrCode.create({ data: { token: uuidv4(), businessId: business.id, amount: 25.50, ticketNumber: "T-HIST-001", expiresAt: new Date(), status: QrCodeStatus.COMPLETED, userId: davidNuevo.id, pointsEarned: 25, completedAt: subDays(new Date(), 3) } });
    await prisma.activityLog.create({ data: { userId: davidNuevo.id, businessId: business.id, type: ActivityType.POINTS_EARNED_QR, pointsChanged: 25, description: "T-HIST-001", relatedQrId: qr1.id } });

    // Pedido Activo para probar flujo de camarero
    const mesa5 = await prisma.table.findFirst({where: {identifier: 'M5', businessId: business.id }});
    if(mesa5) {
        await prisma.order.create({ data: {
            orderNumber: `LIVE-${formatISO(new Date(), { representation: 'date' })}-01`,
            status: OrderStatus.COMPLETED,
            businessId: business.id,
            customerLCoId: anaOro.id,
            tableId: mesa5.id,
            totalAmount: 18.30,
            finalAmount: 18.30,
            items: { 
                create: [
                    { menuItemId: cafe.id, quantity: 1, totalItemPrice: 1.80, priceAtPurchase: 1.80, status: OrderItemStatus.SERVED },
                    { menuItemId: tarta.id, quantity: 1, totalItemPrice: 6.50, priceAtPurchase: 6.50, status: OrderItemStatus.SERVED } 
                ] 
            }
        }});
        await prisma.table.update({where: {id: mesa5.id}, data: { status: TableStatus.OCCUPIED }});
        console.log(`[SEED] Created an ACTIVE (unpaid) order on Table M5.`);
    }

    const opAlPunto = await prisma.modifierOption.findFirst({ where: { groupId: puntoCarneGroup.id, name_es: 'Al Punto' } });
    const opBacon = await prisma.modifierOption.findFirst({ where: { groupId: extrasGroup.id, name_es: 'Bacon Extra' } });
    
    if (opAlPunto && opBacon) {
      const priceWithModifiers = new Prisma.Decimal(hamburguesa.price).add(opBacon.priceAdjustment);
      const orderItemDataWithMods = {
          menuItemId: hamburguesa.id, quantity: 1, priceAtPurchase: priceWithModifiers, totalItemPrice: priceWithModifiers, 
          status: OrderItemStatus.SERVED, itemNameSnapshot: hamburguesa.name_es, 
          selectedModifiers: { createMany: { data: [
              { modifierOptionId: opAlPunto.id, optionNameSnapshot: opAlPunto.name_es, optionPriceAdjustmentSnapshot: opAlPunto.priceAdjustment }, 
              { modifierOptionId: opBacon.id, optionNameSnapshot: opBacon.name_es, optionPriceAdjustmentSnapshot: opBacon.priceAdjustment }
          ]}}
      };
      await prisma.order.create({
          data: {
              orderNumber: `HIST-${formatISO(subDays(new Date(), 1), { representation: 'date' })}-01`,
              status: OrderStatus.PAID, businessId: business.id, customerLCoId: anaOro.id, 
              createdAt: subDays(new Date(), 1), paidAt: subDays(new Date(), 1),
              totalAmount: priceWithModifiers, finalAmount: priceWithModifiers,
              items: { create: [orderItemDataWithMods] }
          }
      });
    }

    await prisma.order.create({ data: {
        orderNumber: `HIST-${formatISO(subDays(new Date(), 5), { representation: 'date' })}-02`, status: OrderStatus.PAID, businessId: business.id, 
        customerLCoId: carlosPlata.id, createdAt: subDays(new Date(), 5), paidAt: subDays(new Date(), 5), 
        totalAmount: 8.30, discountAmount: 5.00, finalAmount: 3.30, appliedLcoRewardId: rewards.descuentoTotal.id,
        items: { create: [
            { menuItemId: tarta.id, quantity: 1, totalItemPrice: 6.50, priceAtPurchase: 6.50, status: OrderItemStatus.SERVED, itemNameSnapshot: tarta.name_es },
            { menuItemId: cafe.id, quantity: 1, totalItemPrice: 1.80, priceAtPurchase: 1.80, status: OrderItemStatus.SERVED, itemNameSnapshot: cafe.name_es }
        ]}
    }});
    
    await prisma.order.create({ data: { 
        orderNumber: `HIST-${formatISO(subDays(new Date(), 8), { representation: 'date' })}-03`, status: OrderStatus.PAID, businessId: business.id, 
        customerLCoId: davidNuevo.id, createdAt: subDays(new Date(), 8), paidAt: subDays(new Date(), 8), 
        totalAmount: 1.80, finalAmount: 1.80, 
        items: { create: [ 
            { menuItemId: cafe.id, quantity: 1, totalItemPrice: 1.80, priceAtPurchase: 1.80, status: OrderItemStatus.SERVED, itemNameSnapshot: cafe.name_es },
            { menuItemId: tarta.id, redeemedRewardId: rewards.tartaGratis.id, quantity: 1, totalItemPrice: 0, priceAtPurchase: 0, status: OrderItemStatus.SERVED, itemNameSnapshot: `GRATIS: ${tarta.name_es}` }
        ]}
    }});
    console.log(`[SEED] Created historical paid orders.`);

    // 3. CREAR REGALOS Y CUPONES (GRANTED REWARDS)
    await prisma.grantedReward.create({ data: { userId: anaOro.id, rewardId: rewards.tartaGratis.id, businessId: business.id, assignedById: admin.id, status: GrantedRewardStatus.PENDING, expiresAt: addDays(new Date(), 30) } });
    if (rewards.gorra) {
        const grantedReward = await prisma.grantedReward.create({ data: { userId: carlosPlata.id, rewardId: rewards.gorra.id, businessId: business.id, status: GrantedRewardStatus.AVAILABLE, redeemedAt: new Date() } });
        await prisma.activityLog.create({ data: { userId: carlosPlata.id, businessId: business.id, type: ActivityType.REWARD_ACQUIRED, pointsChanged: -rewards.gorra.pointsCost, description: `Has obtenido la recompensa: '${rewards.gorra.name_es}'`, relatedRewardId: rewards.gorra.id, relatedGrantedRewardId: grantedReward.id } });
    }
    console.log(`[SEED] Created pending gift and available coupon.`);
}


// ====== [25] backend/scripts/create-superadmin.js ======
"use strict";
// backend/scripts/create-superadmin.ts
/// <reference types="node" />
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("@prisma/client");
const bcryptjs_1 = __importDefault(require("bcryptjs"));
const dotenv_1 = __importDefault(require("dotenv"));
dotenv_1.default.config({ path: '../.env' });
const prisma = new client_1.PrismaClient();
async function hashPassword(password) {
    const salt = await bcryptjs_1.default.genSalt(10);
    return bcryptjs_1.default.hash(password, salt);
}
async function createOrUpdateSuperAdmin() {
    console.log('[SUPERADMIN_SCRIPT] Iniciando creaci√≥n/actualizaci√≥n de Super Admin...');
    const superAdminEmail = 'superadmin@loyalpyme.com';
    const superAdminPassword = 'superadminpassword'; // Aseg√∫rate de que esta es la contrase√±a que quieres usar
    const superAdminName = 'Super Admin';
    try {
        const existingSuperAdmin = await prisma.user.findUnique({
            where: { email: superAdminEmail },
        });
        const hashedPassword = await hashPassword(superAdminPassword); // Hasheamos la contrase√±a deseada
        if (existingSuperAdmin) {
            console.log(`[SUPERADMIN_SCRIPT] El Super Admin con email ${superAdminEmail} ya existe. Actualizando su contrase√±a y rol si es necesario...`);
            await prisma.user.update({
                where: { email: superAdminEmail },
                data: {
                    password: hashedPassword,
                    role: client_1.UserRole.SUPER_ADMIN, // Asegurar que el rol es SUPER_ADMIN
                    isActive: true, // Asegurar que est√° activo
                    name: superAdminName // Actualizar nombre por si acaso
                    // No tocamos businessId, debe seguir siendo null
                },
            });
            console.log(`[SUPERADMIN_SCRIPT] Datos del Super Admin actualizados (contrase√±a, rol, estado activo, nombre).`);
        }
        else {
            // Si no existe, crearlo
            const newSuperAdmin = await prisma.user.create({
                data: {
                    email: superAdminEmail,
                    password: hashedPassword,
                    name: superAdminName,
                    role: client_1.UserRole.SUPER_ADMIN,
                    isActive: true,
                },
            });
            console.log(`[SUPERADMIN_SCRIPT] Super Admin creado exitosamente:`);
            console.log(`  ID: ${newSuperAdmin.id}`);
            console.log(`  Email: ${newSuperAdmin.email}`);
        }
        console.log(`  IMPORTANTE: La contrase√±a para ${superAdminEmail} est√° establecida a '${superAdminPassword}'. ¬°Gu√°rdala de forma segura!`);
    }
    catch (error) {
        console.error('[SUPERADMIN_SCRIPT] Error creando/actualizando el Super Admin:', error);
    }
    finally {
        await prisma.$disconnect();
        console.log('[SUPERADMIN_SCRIPT] Prisma client desconectado.');
    }
}
createOrUpdateSuperAdmin();



// ====== [26] backend/scripts/create-superadmin.ts ======
// backend/scripts/create-superadmin.ts
/// <reference types="node" />

import { PrismaClient, UserRole } from '@prisma/client';
import bcrypt from 'bcryptjs';
import dotenv from 'dotenv';

dotenv.config({ path: '../.env' });

const prisma = new PrismaClient();

async function hashPassword(password: string): Promise<string> {
  const salt = await bcrypt.genSalt(10);
  return bcrypt.hash(password, salt);
}

async function createOrUpdateSuperAdmin() { // Nombre de funci√≥n cambiado para reflejar la acci√≥n
  console.log('[SUPERADMIN_SCRIPT] Iniciando creaci√≥n/actualizaci√≥n de Super Admin...');

  const superAdminEmail = 'superadmin@loyalpyme.com';
  const superAdminPassword = 'superadminpassword'; // Aseg√∫rate de que esta es la contrase√±a que quieres usar
  const superAdminName = 'Super Admin';

  try {
    const existingSuperAdmin = await prisma.user.findUnique({
      where: { email: superAdminEmail },
    });

    const hashedPassword = await hashPassword(superAdminPassword); // Hasheamos la contrase√±a deseada

    if (existingSuperAdmin) {
      console.log(`[SUPERADMIN_SCRIPT] El Super Admin con email ${superAdminEmail} ya existe. Actualizando su contrase√±a y rol si es necesario...`);
      await prisma.user.update({
        where: { email: superAdminEmail },
        data: {
            password: hashedPassword,
            role: UserRole.SUPER_ADMIN, // Asegurar que el rol es SUPER_ADMIN
            isActive: true,             // Asegurar que est√° activo
            name: superAdminName        // Actualizar nombre por si acaso
            // No tocamos businessId, debe seguir siendo null
        },
      });
      console.log(`[SUPERADMIN_SCRIPT] Datos del Super Admin actualizados (contrase√±a, rol, estado activo, nombre).`);
    } else {
      // Si no existe, crearlo
      const newSuperAdmin = await prisma.user.create({
        data: {
          email: superAdminEmail,
          password: hashedPassword,
          name: superAdminName,
          role: UserRole.SUPER_ADMIN,
          isActive: true,
        },
      });
      console.log(`[SUPERADMIN_SCRIPT] Super Admin creado exitosamente:`);
      console.log(`  ID: ${newSuperAdmin.id}`);
      console.log(`  Email: ${newSuperAdmin.email}`);
    }
    console.log(`  IMPORTANTE: La contrase√±a para ${superAdminEmail} est√° establecida a '${superAdminPassword}'. ¬°Gu√°rdala de forma segura!`);

  } catch (error) {
    console.error('[SUPERADMIN_SCRIPT] Error creando/actualizando el Super Admin:', error);
  } finally {
    await prisma.$disconnect();
    console.log('[SUPERADMIN_SCRIPT] Prisma client desconectado.');
  }
}

createOrUpdateSuperAdmin();


// ====== [27] backend/scripts/hash-customer-password.js ======
"use strict";
// File: backend/scripts/hash-customer-password.ts
// MODIFIED: To target admin user and set correct password for tests
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("@prisma/client");
// Importamos la funcion hashPassword de nuestro servicio de autenticacion
const auth_service_1 = require("../src/auth/auth.service");
// Asegurarse de que las variables de entorno, incluida DATABASE_URL, esten cargadas
const dotenv_1 = __importDefault(require("dotenv"));
dotenv_1.default.config({ path: '.env' }); // Carga desde backend/.env
const prisma = new client_1.PrismaClient();
async function main() {
    // --- CONFIGURACION (MODIFICADA) ---
    const userEmailToUpdate = 'admin@cafeelsol.com'; // <-- Email del admin para los tests
    const plainPasswordToHash = 'superpasswordseguro'; // <-- Contrase√±a que usan los tests
    // --- FIN CONFIGURACION ---
    // --- LOGICA DEL SCRIPT ---
    try {
        console.log(`[SCRIPT] Iniciando hash y actualizacion de contrase√±a para: ${userEmailToUpdate}`);
        // 1. Buscar el usuario por email
        const user = await prisma.user.findUnique({
            where: { email: userEmailToUpdate },
            select: { id: true, email: true, password: true } // Seleccionar campos para verificacion
        });
        if (!user) {
            console.error(`[SCRIPT] ERROR: Usuario no encontrado con el email: ${userEmailToUpdate}`);
            console.error(`[SCRIPT] Aseg√∫rate de haber registrado el negocio con este email primero.`);
            return; // Salir si el usuario no existe
        }
        console.log(`[SCRIPT] Usuario encontrado. ID: ${user.id}`);
        // 2. Hashear la contrase√±a plana
        console.log(`[SCRIPT] Hasheando la contrase√±a plana '${plainPasswordToHash}'...`);
        const hashedPassword = await (0, auth_service_1.hashPassword)(plainPasswordToHash);
        console.log(`[SCRIPT] Contrase√±a hasheada (hash): ${hashedPassword.substring(0, 10)}...`);
        // 3. Actualizar el usuario en la base de datos con la contrase√±a hasheada
        console.log(`[SCRIPT] Actualizando usuario en la base de datos...`);
        const updatedUser = await prisma.user.update({
            where: { id: user.id }, // Actualizar por ID para mayor seguridad
            data: { password: hashedPassword },
            select: { id: true, email: true } // Seleccionar campos para confirmar actualizacion
        });
        console.log(`[SCRIPT] Usuario ${updatedUser.email} (${updatedUser.id}) actualizado exitosamente con contrase√±a hasheada.`);
    }
    catch (error) {
        console.error(`[SCRIPT] ERROR durante la ejecucion del script:`, error instanceof Error ? error.message : error);
    }
    finally {
        // Asegurar la desconexion de Prisma Client al finalizar el script
        await prisma.$disconnect();
        console.log('[SCRIPT] Prisma client desconectado.');
    }
}
// Ejecutar la funcion principal del script
main();



// ====== [28] backend/scripts/hash-customer-password.ts ======
// backend/scripts/hash-customer-password.ts
import { PrismaClient } from '@prisma/client';
// --- RUTA CORREGIDA ---
import { hashPassword } from '../src/shared/auth/auth.service';

import dotenv from 'dotenv';
dotenv.config({ path: '.env' }); 

const prisma = new PrismaClient();

async function main() {
  const userEmailToUpdate = 'admin@cafeelsol.com';
  const plainPasswordToHash = 'superpasswordseguro';

  try {
    console.log(`[SCRIPT] Iniciando hash y actualizacion de contrase√±a para: ${userEmailToUpdate}`);
    const user = await prisma.user.findUnique({ where: { email: userEmailToUpdate } });
    if (!user) {
      console.error(`[SCRIPT] ERROR: Usuario no encontrado con el email: ${userEmailToUpdate}`);
      return;
    }
    const hashedPassword = await hashPassword(plainPasswordToHash);
    await prisma.user.update({ where: { id: user.id }, data: { password: hashedPassword } });
    console.log(`[SCRIPT] Usuario ${userEmailToUpdate} actualizado exitosamente.`);
  } catch (error: any) {
    console.error(`[SCRIPT] ERROR:`, error.message);
  } finally {
    await prisma.$disconnect();
  }
}

main();


// ====== [29] backend/src/config/swagger.config.ts ======
// backend/src/config/swagger.config.ts (CORREGIDO v1.2.0)
import {
    Prisma,
    UserRole,
    TierCalculationBasis,
    TierDowngradePolicy,
    BenefitType,
    OrderItemStatus,
    OrderStatus,
    ActivityType,
    DocumentType
} from '@prisma/client';

const port = process.env.PORT || 3000;

export const swaggerOptions = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'LoyalPyME API',
      version: '1.17.0',
      description: 'API REST para la plataforma de fidelizaci√≥n LoyalPyME. Permite gestionar clientes, puntos, niveles, recompensas, historial, subidas de archivos, autenticaci√≥n, funcionalidades de Super Administrador, administraci√≥n del M√≥dulo Camarero (gesti√≥n de carta, KDS, interfaz de camarero), y visualizaci√≥n de men√∫ p√∫blico y creaci√≥n de pedidos.',
      contact: { name: 'Olivier Hottelet', email: 'olivierhottelet1980@gmail.com' },
      license: { name: 'Software Propietario. Copyright (c) 2024-2025 Olivier Hottelet', url: 'LICENSE.MD' }
    },
    servers: [
        { url: `http://localhost:${port}/api`, description: 'Servidor de Desarrollo Local (API Protegida)', },
        { url: `http://localhost:${port}/public`, description: 'Servidor de Desarrollo Local (API P√∫blica)', },
    ],
    components: {
        securitySchemes: { bearerAuth: { type: 'http', scheme: 'bearer', bearerFormat: 'JWT', } },
        schemas: {
             ActivityLogItem: { type: 'object', properties: { id: { type: 'string', format: 'uuid', readOnly: true }, type: { type: 'string', enum: Object.values(ActivityType), readOnly: true }, pointsChanged: { type: 'integer', nullable: true, readOnly: true, description: 'Cambio en puntos (+/-), null si no aplica.' }, description: { type: 'string', nullable: true, readOnly: true, description: 'Descripci√≥n del evento.' }, createdAt: { type: 'string', format: 'date-time', readOnly: true, description: 'Fecha y hora del evento.' } } },
             PaginatedActivityResponse: { type: 'object', properties: { logs: { type: 'array', items: { '$ref': '#/components/schemas/ActivityLogItem' } }, totalPages: { type: 'integer', example: 5 }, currentPage: { type: 'integer', example: 1 }, totalItems: { type: 'integer', example: 73 } } },
             LoginCredentials: { type: 'object', required: ['email', 'password'], properties: { email: { type: 'string', format: 'email'}, password: { type: 'string', format: 'password'} }, example: { email: 'user@example.com', password: 'password123' } },
             RegisterUserDto: { type: 'object', required: ['email', 'password', 'phone', 'documentId', 'documentType', 'businessId', 'role'], properties: { email: { type: 'string', format: 'email'}, password: { type: 'string', format: 'password', minLength: 6 }, name: { type: 'string', nullable: true }, phone: { type: 'string', example: '+34612345678' }, documentId: { type: 'string'}, documentType: { type: 'string', enum: Object.values(DocumentType) }, businessId: { type: 'string', format: 'uuid'}, role: { type: 'string', enum: [UserRole.CUSTOMER_FINAL]} } },
             RegisterBusinessDto: { type: 'object', required: ['businessName', 'adminEmail', 'adminPassword'], properties: { businessName: { type: 'string', minLength: 2 }, adminEmail: { type: 'string', format: 'email'}, adminPassword: { type: 'string', format: 'password', minLength: 6 }, adminName: { type: 'string', nullable: true } } },
             ForgotPasswordDto: { type: 'object', required: ['email'], properties: { email: { type: 'string', format: 'email'} } },
             ResetPasswordDto: { type: 'object', required: ['password'], properties: { password: { type: 'string', format: 'password', minLength: 6 } } },
             UserResponse: { type: 'object', properties: { id: { type: 'string', format: 'uuid'}, email: { type: 'string', format: 'email'}, name: { type: 'string', nullable: true }, role: { type: 'string', enum: Object.values(UserRole) }, businessId: { type: 'string', format: 'uuid', nullable: true}, points: { type: 'integer'}, createdAt: { type: 'string', format: 'date-time'}, isActive: { type: 'boolean'}, isFavorite: { type: 'boolean', nullable: true }, currentTierId: { type: 'string', format: 'uuid', nullable: true }, tierAchievedAt: { type: 'string', format: 'date-time', nullable: true } } },
             LoginResponse: { type: 'object', properties: { token: { type: 'string'}, user: { '$ref': '#/components/schemas/UserResponse' } } },
             SuccessMessage: { type: 'object', properties: { message: { type: 'string'} }, example: { message: 'Operaci√≥n completada con √©xito.'} },
             ErrorResponse: { type: 'object', properties: { message: { type: 'string'}, error: { type: 'string', nullable: true } }, example: { message: 'Error de validaci√≥n.', error: 'El campo email es inv√°lido.'} },
             RewardBase: { type: 'object', properties: { id: { type: 'string', format: 'uuid', readOnly: true }, name_es: { type: 'string', nullable: true}, name_en: { type: 'string', nullable: true}, description_es: { type: 'string', nullable: true }, description_en: { type: 'string', nullable: true }, pointsCost: { type: 'integer', format: 'int32', minimum: 0 }, isActive: { type: 'boolean'}, businessId: { type: 'string', format: 'uuid', readOnly: true }, createdAt: { type: 'string', format: 'date-time', readOnly: true }, updatedAt: { type: 'string', format: 'date-time', readOnly: true }, imageUrl: { type: 'string', format: 'url', nullable: true } } },
             CreateRewardDto: { type: 'object', required: ['name_es', 'name_en', 'pointsCost'], properties: { name_es: { type: 'string', example: 'Caf√© Gratis' }, name_en: { type: 'string', example: 'Free Coffee' }, description_es: { type: 'string', nullable: true, example: 'Un caf√© espresso o americano.' }, description_en: { type: 'string', nullable: true, example: 'One espresso or americano coffee.' }, pointsCost: { type: 'integer', format: 'int32', minimum: 0, example: 100 }, imageUrl: { type: 'string', format: 'url', nullable: true } } },
             UpdateRewardDto: { type: 'object', properties: { name_es: { type: 'string'}, name_en: { type: 'string'}, description_es: { type: 'string', nullable: true }, description_en: { type: 'string', nullable: true }, pointsCost: { type: 'integer', format: 'int32', minimum: 0 }, isActive: { type: 'boolean'}, imageUrl: { type: 'string', format: 'url', nullable: true } } },
             RewardListResponse: { type: 'array', items: { '$ref': '#/components/schemas/RewardBase' } },
             DeletedRewardResponse: { type: 'object', properties: { message: { type: 'string'}, deletedReward: { '$ref': '#/components/schemas/RewardBase' } } },
             GenerateQrDto: { type: 'object', required: ['amount', 'ticketNumber'], properties: { amount: { type: 'number', format: 'float', minimum: 0.01 }, ticketNumber: { type: 'string'} } },
             QrDataResponse: { type: 'object', properties: { qrToken: { type: 'string', format: 'uuid'}, amount: { type: 'number', format: 'float'} } },
             ValidateQrDto: { type: 'object', required: ['qrToken'], properties: { qrToken: { type: 'string', format: 'uuid'} } },
             PointsEarnedResponse: { type: 'object', properties: { message: { type: 'string'}, pointsEarned: { type: 'integer'}, user: { '$ref': '#/components/schemas/UserResponse' } }, example: { message: '...', pointsEarned: 7, user: { } } },
             RedeemRewardResult: { type: 'object', properties: { message: { type: 'string'}, newPointsBalance: { type: 'integer'} }, example: { message: '...', newPointsBalance: 930 } },
             RewardInfoForGift: { type: 'object', properties: { id: { type: 'string', format: 'uuid', readOnly: true }, name_es: { type: 'string', nullable: true, readOnly: true }, name_en: { type: 'string', nullable: true, readOnly: true }, description_es: { type: 'string', nullable: true, readOnly: true }, description_en: { type: 'string', nullable: true, readOnly: true }, imageUrl: { type: 'string', format: 'url', nullable: true, readOnly: true } } },
             AssignerInfo: { type: 'object', properties: { name: { type: 'string', nullable: true, readOnly: true }, email: { type: 'string', format: 'email', readOnly: true } } },
             BusinessInfoForGift: { type: 'object', properties: { name: { type: 'string', readOnly: true } } },
             GrantedReward: { type: 'object', properties: { id: { type: 'string', format: 'uuid', readOnly: true }, status: { type: 'string', enum: ['PENDING', 'REDEEMED', 'EXPIRED'], readOnly: true }, assignedAt: { type: 'string', format: 'date-time', readOnly: true }, redeemedAt: { type: 'string', format: 'date-time', nullable: true, readOnly: true }, reward: { '$ref': '#/components/schemas/RewardInfoForGift' }, assignedBy: { '$ref': '#/components/schemas/AssignerInfo', nullable: true }, business: { '$ref': '#/components/schemas/BusinessInfoForGift', nullable: true } } },
             GrantedRewardListResponse: { type: 'array', items: { '$ref': '#/components/schemas/GrantedReward' } },
             RedeemedGiftResponse: { type: 'object', properties: { message: { type: 'string'}, grantedRewardId: { type: 'string', format: 'uuid'}, rewardId: { type: 'string', format: 'uuid'}, redeemedAt: { type: 'string', format: 'date-time'} } },
             TierBenefitBase: { type: 'object', properties: { id: { type: 'string', format: 'uuid', readOnly: true }, type: { type: 'string', enum: Object.values(BenefitType) }, value: { type: 'string'}, description: { type: 'string', nullable: true }, isActive: { type: 'boolean'} } },
             TierWithBenefits: { type: 'object', properties: { id: { type: 'string', format: 'uuid', readOnly: true }, name: { type: 'string'}, level: { type: 'integer'}, minValue: { type: 'number'}, description: { type: 'string', nullable: true }, benefitsDescription: { type: 'string', nullable: true }, isActive: { type: 'boolean'}, benefits: { type: 'array', items: { '$ref': '#/components/schemas/TierBenefitBase' } } } },
             TierListResponse: { type: 'array', items: { '$ref': '#/components/schemas/TierWithBenefits' } },
             TierConfigResponse: { type: 'object', properties: { tierSystemEnabled: { type: 'boolean' }, tierCalculationBasis: { type: 'string', enum: Object.values(TierCalculationBasis), nullable: true }, tierCalculationPeriodMonths: { type: 'integer', nullable: true, minimum: 0 }, tierDowngradePolicy: { type: 'string', enum: Object.values(TierDowngradePolicy) }, inactivityPeriodMonths: { type: 'integer', nullable: true, minimum: 1 } } },
             TierConfigUpdateDto: { type: 'object', properties: { tierSystemEnabled: { type: 'boolean'}, tierCalculationBasis: { type: 'string', enum: Object.values(TierCalculationBasis), nullable: true }, tierCalculationPeriodMonths: { type: 'integer', nullable: true, minimum: 0 }, tierDowngradePolicy: { type: 'string', enum: Object.values(TierDowngradePolicy) }, inactivityPeriodMonths: { type: 'integer', nullable: true, minimum: 1 } } },
             TierBase: { type: 'object', properties: { id: { type: 'string', format: 'uuid', readOnly: true }, name: { type: 'string'}, level: { type: 'integer', minimum: 0 }, minValue: { type: 'number', minimum: 0 }, description: { type: 'string', nullable: true }, benefitsDescription: { type: 'string', nullable: true }, isActive: { type: 'boolean'}, businessId: { type: 'string', format: 'uuid', readOnly: true }, createdAt: { type: 'string', format: 'date-time', readOnly: true }, updatedAt: { type: 'string', format: 'date-time', readOnly: true } } },
             CreateTierDto: { type: 'object', required: ['name', 'level', 'minValue'], properties: { name: { type: 'string'}, level: { type: 'integer', minimum: 0 }, minValue: { type: 'number', minimum: 0 }, description: { type: 'string', nullable: true }, benefitsDescription: { type: 'string', nullable: true }, isActive: { type: 'boolean', default: true } } },
             UpdateTierDto: { type: 'object', properties: { name: { type: 'string'}, level: { type: 'integer', minimum: 0 }, minValue: { type: 'number', minimum: 0 }, description: { type: 'string', nullable: true }, benefitsDescription: { type: 'string', nullable: true }, isActive: { type: 'boolean'} } },
             AdminTierListResponse: { type: 'array', items: { '$ref': '#/components/schemas/TierWithBenefits' } },
             DeletedTierResponse: { type: 'object', properties: { message: { type: 'string'}, deletedTier: { '$ref': '#/components/schemas/TierBase' } } },
             TierBenefitListResponse: { type: 'array', items: { '$ref': '#/components/schemas/TierBenefitBase' } },
             CreateTierBenefitDto: { type: 'object', required: ['type', 'value'], properties: { type: { type: 'string', enum: Object.values(BenefitType) }, value: { type: 'string'}, description: { type: 'string', nullable: true }, isActive: { type: 'boolean', default: true } } },
             UpdateTierBenefitDto: { type: 'object', properties: { type: { type: 'string', enum: Object.values(BenefitType) }, value: { type: 'string'}, description: { type: 'string', nullable: true }, isActive: { type: 'boolean'} } },
             DeletedTierBenefitResponse: { type: 'object', properties: { message: { type: 'string'}, deletedBenefit: { '$ref': '#/components/schemas/TierBenefitBase' } } },
             AdminStatsOverviewResponse: { type: 'object', properties: { totalActiveCustomers: { type: 'integer'}, newCustomersLast7Days: { type: 'integer'}, newCustomersPrevious7Days: { type: 'integer'}, pointsIssuedLast7Days: { type: 'integer'}, pointsIssuedPrevious7Days: { type: 'integer'}, rewardsRedeemedLast7Days: { type: 'integer'}, rewardsRedeemedPrevious7Days: { type: 'integer'} } },
             CustomerListItem: { type: 'object', properties: { id: { type: 'string', format: 'uuid' }, name: { type: 'string', nullable: true }, email: { type: 'string', format: 'email' }, points: { type: 'integer' }, createdAt: { type: 'string', format: 'date-time' }, isActive: { type: 'boolean' }, isFavorite: { type: 'boolean', nullable: true }, currentTier: { type: 'object', nullable: true, properties: { id: { type: 'string', format: 'uuid' }, name: { type: 'string' }, level: { type: 'integer' } } } } },
             AdminCustomerListResponse: { type: 'object', properties: { items: { type: 'array', items: { '$ref': '#/components/schemas/CustomerListItem' } }, totalPages: { type: 'integer' }, currentPage: { type: 'integer' }, totalItems: { type: 'integer' } } },
             CustomerDetailsResponse: { allOf: [ { '$ref': '#/components/schemas/UserResponse' }, { type: 'object', properties: { adminNotes: { type: 'string', nullable: true } } } ] },
             UpdateCustomerNotesDto: { type: 'object', properties: { notes: { type: 'string', nullable: true } } },
             AdjustPointsDto: { type: 'object', required: ['amount'], properties: { amount: { type: 'number', not: { const: 0 } }, reason: { type: 'string', nullable: true } } },
             ChangeCustomerTierDto: { type: 'object', properties: { tierId: { type: 'string', format: 'uuid', nullable: true } } },
             AssignRewardDto: { type: 'object', required: ['rewardId'], properties: { rewardId: { type: 'string', format: 'uuid' } } },
             CustomerActionResponse: { type: 'object', properties: { message: { type: 'string' }, customer: { type: 'object', properties: { id: { type: 'string', format: 'uuid' }, points: { type: 'integer' }, currentTierId: { type: 'string', format: 'uuid', nullable: true }, tierAchievedAt: { type: 'string', format: 'date-time', nullable: true }, isFavorite: { type: 'boolean' }, isActive: { type: 'boolean' } }, additionalProperties: false } } },
             GrantedRewardIdResponse: { type: 'object', properties: { message: { type: 'string' }, grantedRewardId: { type: 'string', format: 'uuid' } } },
             BulkCustomerIdListDto: { type: 'object', required: ['customerIds'], properties: { customerIds: { type: 'array', items: { type: 'string', format: 'uuid' }, minItems: 1 } } },
             BulkStatusUpdateDto: { type: 'object', required: ['customerIds', 'isActive'], properties: { customerIds: { type: 'array', items: { type: 'string', format: 'uuid' }, minItems: 1 }, isActive: { type: 'boolean'} } },
             BulkPointsAdjustDto: { type: 'object', required: ['customerIds', 'amount'], properties: { customerIds: { type: 'array', items: { type: 'string', format: 'uuid' }, minItems: 1 }, amount: { type: 'number', not: { const: 0 } }, reason: { type: 'string', nullable: true } } },
             BulkOperationResponse: { type: 'object', properties: { message: { type: 'string' }, count: { type: 'integer'} } },
             ImageUploadResponse: { type: 'object', properties: { url: { type: 'string', format: 'url', description: 'URL de la imagen subida a Cloudinary.' } } },
             // DTOs para Camarero Staff
             ReadyPickupItemDto: { 
                type: 'object',
                properties: {
                    orderItemId: { type: 'string', format: 'uuid', description: "ID del OrderItem" },
                    orderId: { type: 'string', format: 'uuid', description: "ID del Order al que pertenece" },
                    orderNumber: { type: 'string', description: "N√∫mero legible del Order" },
                    orderCreatedAt: { type: 'string', format: 'date-time', description: "Fecha de creaci√≥n del Order" },
                    tableIdentifier: { type: 'string', nullable: true, description: "Identificador de la mesa" },
                    itemNameSnapshot_es: { type: 'string', nullable: true, description: "Nombre del √≠tem en espa√±ol (snapshot)" },
                    itemNameSnapshot_en: { type: 'string', nullable: true, description: "Nombre del √≠tem en ingl√©s (snapshot)" },
                    quantity: { type: 'integer', description: "Cantidad del √≠tem" },
                    itemNotes: { type: 'string', nullable: true, description: "Notas espec√≠ficas del OrderItem" },
                    kdsDestination: { type: 'string', nullable: true, description: "Destino KDS (COCINA, BARRA)" },
                    selectedModifiers: {
                        type: 'array',
                        items: {
                            type: 'object',
                            properties: {
                                optionName_es: { type: 'string', nullable: true },
                                optionName_en: { type: 'string', nullable: true },
                            }
                        }
                    },
                    currentOrderItemStatus: { type: 'string', enum: Object.values(OrderItemStatus) }
                }
             },
             MarkOrderItemServedPayloadDto: { 
                type: 'object',
                required: ['newStatus'],
                properties: {
                    newStatus: { type: 'string', enum: [OrderItemStatus.SERVED], description: 'Debe ser "SERVED"' }
                }
             },
             OrderItemStatusUpdateResponseDto: { 
                type: 'object',
                properties: {
                    message: { type: 'string' },
                    orderItemId: { type: 'string', format: 'uuid' },
                    newStatus: { type: 'string', enum: Object.values(OrderItemStatus) },
                    orderStatus: { type: 'string', enum: Object.values(OrderStatus), nullable: true }
                }
             }
         }
    },
    security: [{ bearerAuth: [] }],
  },
  apis: [
    './src/shared/auth/*.ts',
    './src/modules/loyalpyme/admin/*.ts',
    './src/modules/loyalpyme/rewards/*.ts',
    './src/modules/loyalpyme/points/*.ts',
    './src/modules/loyalpyme/customer/*.ts',
    './src/modules/loyalpyme/tiers/*.ts',
    './src/modules/camarero/*.ts', // Se asume que los controladores est√°n aqu√≠
    './src/modules/camarero/public/*.ts',
    './src/modules/superadmin/*.ts',
    './src/shared/uploads/*.ts',
    './src/routes/*.ts'
  ],
};


// ====== [30] backend/src/index.ts ======
// backend/src/index.ts (CORREGIDO v1.8.1)
import express, { Express, Request, Response, NextFunction, RequestHandler } from 'express';
import dotenv from 'dotenv';
import 'reflect-metadata';
import cors from 'cors';
import { Prisma, PrismaClient } from '@prisma/client';
import cron from 'node-cron';
import swaggerJsdoc from 'swagger-jsdoc';
import swaggerUi from 'swagger-ui-express';

import { swaggerOptions } from './config/swagger.config';
import { apiRouter, publicRouter } from './routes';

// --- RUTA CORREGIDA ---
import { processTierUpdatesAndDowngrades } from './modules/loyalpyme/tiers/tier-logic.service';

dotenv.config();

const prisma = new PrismaClient();
const app: Express = express();
const port = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());
app.use((req, res, next) => {
  if (process.env.NODE_ENV !== 'test' && !process.env.VITEST) {
      const method = req.method;
      const url = req.originalUrl;
      const ip = req.ip || req.connection.remoteAddress;
      const timestamp = new Date().toISOString();
      let bodyLog = '';
      if (req.body && Object.keys(req.body).length > 0 && !req.is('multipart/form-data')) {
         try { bodyLog = JSON.stringify(req.body); if (bodyLog.length > 500) bodyLog = bodyLog.substring(0, 497) + '...'; } catch { bodyLog = '[Unloggable Body]'; }
      }
      console.log(`[REQ LOG - ${timestamp}] ${method} ${url} - From: ${ip} ${bodyLog ? '- Body: '+bodyLog : ''}`);
  }
  next();
});

const swaggerSpec = swaggerJsdoc(swaggerOptions);
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec) as RequestHandler);

app.use('/api', apiRouter);
app.use('/public', publicRouter);

app.get('/', (req: Request, res: Response) => { res.send('Welcome to LoyalPyME API! Docs available at /api-docs'); });

app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
    console.error('[GLOBAL ERROR HANDLER]', err.stack);
    if (err instanceof Prisma.PrismaClientKnownRequestError) {
        if (err.code === 'P2002') { return res.status(409).json({ message: 'Conflicto de unicidad.', error: `Ya existe un registro con uno de los valores √∫nicos proporcionados. (${(err.meta?.target as string[])?.join(', ')})`, code: err.code }); }
        if (err.code === 'P2025') { return res.status(404).json({ message: 'Registro no encontrado.', error: (err.meta?.cause as string) || 'El registro necesario para la operaci√≥n no existe.', code: err.code });}
        return res.status(400).json({ message: 'Error de base de datos.', error: err.message, code: err.code });
    }
    if (err instanceof Prisma.PrismaClientValidationError) {
         return res.status(400).json({ message: 'Error de validaci√≥n de datos Prisma.', error: 'Los datos proporcionados no cumplen con el formato esperado por la base de datos.'});
    }
    const statusCode = (err as any).status || 500;
    const errorMessage = statusCode === 500 && process.env.NODE_ENV === 'production' ? 'Ocurri√≥ un error interno en el servidor.' : err.message || 'Error desconocido.';
    res.status(statusCode).json({ message: statusCode === 500 ? 'Error Interno del Servidor' : 'Error en la Petici√≥n', error: errorMessage });
});

if (process.env.NODE_ENV !== 'test' && !process.env.VITEST) {
    const cronSchedule = process.env.TIER_UPDATE_CRON_SCHEDULE || '0 3 * * *';
    console.log(`Scheduling Tier update/downgrade job with schedule: [${cronSchedule}]`);
    cron.schedule(cronSchedule, () => {
        const startTime = Date.now();
        console.log(`[CRON ${new Date().toISOString()}] Starting Tier update/downgrade job...`);
        processTierUpdatesAndDowngrades()
            .then(() => {
                 const duration = (Date.now() - startTime) / 1000;
                 console.log(`[CRON ${new Date().toISOString()}] Tier update/downgrade job finished successfully in ${duration.toFixed(2)}s.`);
            })
            // --- TIPO 'any' A√ëADIDO ---
            .catch((cronErr: any) => console.error(`[CRON ${new Date().toISOString()}] Tier update/downgrade job failed:`, cronErr));
    });
    console.log(`‚úÖ Tier update/downgrade job registered.`);
} else {
     console.log("‚ÑπÔ∏è Cron job scheduling skipped in test/Vitest environment.");
}

if (!process.env.VITEST) {
     app.listen(port, () => {
         console.log(`\nüöÄ [server]: Server is running at http://localhost:${port}`);
         console.log(`üìö [docs]: API Docs available at http://localhost:${port}/api-docs`);
     });
}

export default app;


// ====== [31] backend/src/modules/camarero/admin-menu-category.controller.ts ======
// backend/src/modules/camarero/admin-menu-category.controller.ts (CORREGIDO)
import { Request, Response, NextFunction } from 'express';
// --- RUTA CORREGIDA ---
import * as menuCategoryAdminService from './admin-menu-category.service';
// --- FIN RUTA CORREGIDA ---

// --- Handlers del Controlador (Sin cambios en la l√≥gica interna) ---
export const createMenuCategoryHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }

    const { name_es, name_en, description_es, description_en, imageUrl, position, isActive } = req.body;

    if (!name_es || typeof name_es !== 'string' || name_es.trim() === '') {
        return res.status(400).json({ message: "El campo 'name_es' (nombre en espa√±ol) es obligatorio." });
    }
    if (name_en !== undefined && name_en !== null && typeof name_en !== 'string') {
        return res.status(400).json({ message: "El campo 'name_en' debe ser un texto o nulo." });
    }
    if (position !== undefined && typeof position !== 'number') {
        return res.status(400).json({ message: "El campo 'position' debe ser un n√∫mero si se proporciona." });
    }
    if (isActive !== undefined && typeof isActive !== 'boolean') {
        return res.status(400).json({ message: "El campo 'isActive' debe ser un booleano si se proporciona." });
    }

    try {
        const categoryData: menuCategoryAdminService.CreateMenuCategoryData = {
            name_es: name_es.trim(),
            name_en: name_en?.trim() || null,
            description_es: description_es?.trim() || null,
            description_en: description_en?.trim() || null,
            imageUrl: imageUrl || null,
            position: typeof position === 'number' ? position : 0,
            isActive: typeof isActive === 'boolean' ? isActive : true,
        };
        const newCategory = await menuCategoryAdminService.createMenuCategory(businessId, categoryData);
        res.status(201).json(newCategory);
    } catch (error: any) {
        if (error.message && error.message.includes('Ya existe una categor√≠a con el nombre')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};

export const getMenuCategoriesHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }
    try {
        const categories = await menuCategoryAdminService.getMenuCategoriesByBusiness(businessId);
        res.status(200).json(categories);
    } catch (error) {
        next(error);
    }
};

export const getMenuCategoryByIdHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }
    try {
        const category = await menuCategoryAdminService.getMenuCategoryById(categoryId, businessId);
        if (!category) {
            return res.status(404).json({ message: "Categor√≠a de men√∫ no encontrada o no pertenece a este negocio." });
        }
        res.status(200).json(category);
    } catch (error) {
        next(error);
    }
};

export const updateMenuCategoryHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }

    const { name_es, name_en, description_es, description_en, imageUrl, position, isActive } = req.body;
    if (Object.keys(req.body).length === 0) {
        return res.status(400).json({ message: "Se requiere al menos un campo para actualizar." });
    }
    if (name_es !== undefined && (typeof name_es !== 'string' || name_es.trim() === '')) {
        return res.status(400).json({ message: "Si se proporciona 'name_es', no puede estar vac√≠o." });
    }
    if (name_en !== undefined && name_en !== null && typeof name_en !== 'string') {
        return res.status(400).json({ message: "Si se proporciona 'name_en', debe ser un texto o nulo." });
    }
    if (position !== undefined && typeof position !== 'number') {
        return res.status(400).json({ message: "Si se proporciona 'position', debe ser un n√∫mero." });
    }
    if (isActive !== undefined && typeof isActive !== 'boolean') {
        return res.status(400).json({ message: "Si se proporciona 'isActive', debe ser un booleano." });
    }
    
    try {
        const updateData: menuCategoryAdminService.UpdateMenuCategoryData = {};
        if (name_es !== undefined) updateData.name_es = name_es.trim();
        if (name_en !== undefined) updateData.name_en = name_en === null ? null : name_en?.trim() || null;
        if (description_es !== undefined) updateData.description_es = description_es === null ? null : description_es?.trim() || null;
        if (description_en !== undefined) updateData.description_en = description_en === null ? null : description_en?.trim() || null;
        if (imageUrl !== undefined) updateData.imageUrl = imageUrl === null ? null : imageUrl || null;
        if (position !== undefined) updateData.position = position;
        if (isActive !== undefined) updateData.isActive = isActive;

        const updatedCategory = await menuCategoryAdminService.updateMenuCategory(categoryId, businessId, updateData);
        res.status(200).json(updatedCategory);
    } catch (error: any) {
        if (error.message && error.message.includes('no encontrada')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('Error de unicidad')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};

export const deleteMenuCategoryHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }
    try {
        const deletedCategory = await menuCategoryAdminService.deleteMenuCategory(categoryId, businessId);
        res.status(200).json({ message: "Categor√≠a de men√∫ eliminada con √©xito.", id: deletedCategory.id });
    } catch (error: any) {
         if (error.message && error.message.includes('no encontrada')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('contiene √≠tems que est√°n actualmente en uso')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};


// ====== [32] backend/src/modules/camarero/admin-menu-category.service.ts ======
// backend/src/camarero/admin-menu-category.service.ts
import { PrismaClient, MenuCategory, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

// Tipo para los datos de creaci√≥n (excluye businessId ya que se pasa como argumento)
export type CreateMenuCategoryData = Omit<Prisma.MenuCategoryCreateInput, 'business' | 'items'>;

// Tipo para los datos de actualizaci√≥n (parcial y excluye relaciones)
export type UpdateMenuCategoryData = Partial<Omit<Prisma.MenuCategoryUpdateInput, 'business' | 'items'>>;


/**
 * Crea una nueva categor√≠a de men√∫ para un negocio espec√≠fico.
 */
export const createMenuCategory = async (
    businessId: string,
    data: CreateMenuCategoryData
): Promise<MenuCategory> => {
    console.log(`[MC_SVC] Creating menu category for business ${businessId}:`, data.name_es);
    try {
        const newCategory = await prisma.menuCategory.create({
            data: {
                ...data,
                business: {
                    connect: { id: businessId }
                }
            }
        });
        return newCategory;
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            // P2002 es error de constraint √∫nico (ej: nombre de categor√≠a ya existe para ese negocio)
            console.warn(`[MC_SVC] Unique constraint violation for business ${businessId}, name: ${data.name_es}`, error.meta);
            throw new Error(`Ya existe una categor√≠a con el nombre '${data.name_es}' en este negocio.`);
        }
        console.error(`[MC_SVC] Error creating menu category for business ${businessId}:`, error);
        throw new Error("Error de base de datos al crear la categor√≠a de men√∫.");
    }
};

/**
 * Obtiene todas las categor√≠as de men√∫ para un negocio, ordenadas por posici√≥n.
 */
export const getMenuCategoriesByBusiness = async (businessId: string): Promise<MenuCategory[]> => {
    console.log(`[MC_SVC] Fetching menu categories for business ${businessId}`);
    try {
        return await prisma.menuCategory.findMany({
            where: { businessId },
            orderBy: { position: 'asc' },
            // Podr√≠amos incluir √≠tems si fuera necesario para alguna vista: include: { items: true }
        });
    } catch (error) {
        console.error(`[MC_SVC] Error fetching menu categories for business ${businessId}:`, error);
        throw new Error("Error al obtener las categor√≠as de men√∫.");
    }
};

/**
 * Obtiene una categor√≠a de men√∫ espec√≠fica por su ID, verificando que pertenezca al negocio.
 */
export const getMenuCategoryById = async (categoryId: string, businessId: string): Promise<MenuCategory | null> => {
    console.log(`[MC_SVC] Fetching menu category ${categoryId} for business ${businessId}`);
    try {
        return await prisma.menuCategory.findFirst({
            where: {
                id: categoryId,
                businessId: businessId
            },
            // include: { items: true } // Opcional: incluir √≠tems al obtener una categor√≠a espec√≠fica
        });
    } catch (error) {
        console.error(`[MC_SVC] Error fetching menu category ${categoryId}:`, error);
        throw new Error("Error al obtener la categor√≠a de men√∫ por ID.");
    }
};

/**
 * Actualiza una categor√≠a de men√∫ existente.
 */
export const updateMenuCategory = async (
    categoryId: string,
    businessId: string,
    data: UpdateMenuCategoryData
): Promise<MenuCategory> => {
    console.log(`[MC_SVC] Updating menu category ${categoryId} for business ${businessId}:`, data);
    try {
        // Verificar que la categor√≠a existe y pertenece al negocio antes de actualizar
        const existingCategory = await prisma.menuCategory.findFirst({
            where: { id: categoryId, businessId: businessId },
            select: { id: true } // Solo necesitamos saber si existe
        });
        if (!existingCategory) {
            throw new Error(`Categor√≠a de men√∫ con ID ${categoryId} no encontrada o no pertenece a este negocio.`);
        }

        return await prisma.menuCategory.update({
            where: { id: categoryId },
            data: data
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            console.warn(`[MC_SVC] Unique constraint violation on update for category ${categoryId}, business ${businessId}:`, error.meta);
            // El mensaje de error podr√≠a ser m√°s espec√≠fico si sabemos qu√© campo caus√≥ el P2002
            throw new Error(`Error de unicidad al actualizar la categor√≠a (ej: el nuevo nombre ya existe).`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            // Este error significa que el registro a actualizar (where: { id: categoryId }) no se encontr√≥.
            // Ya lo manejamos con la verificaci√≥n previa, pero es bueno tenerlo por si acaso.
            throw new Error(`Categor√≠a de men√∫ con ID ${categoryId} no encontrada al intentar actualizar.`);
        }
        if (error instanceof Error && error.message.startsWith('Categor√≠a de men√∫ con ID')) {
            throw error; // Relanzar el error espec√≠fico de "no encontrado"
        }
        console.error(`[MC_SVC] Error updating menu category ${categoryId}:`, error);
        throw new Error("Error de base de datos al actualizar la categor√≠a de men√∫.");
    }
};

/**
 * Elimina una categor√≠a de men√∫.
 * Prisma se encargar√° de eliminar los MenuItems asociados debido a `onDelete: Cascade`.
 */
export const deleteMenuCategory = async (categoryId: string, businessId: string): Promise<MenuCategory> => {
    console.log(`[MC_SVC] Deleting menu category ${categoryId} for business ${businessId}`);
    try {
        // Verificar que la categor√≠a existe y pertenece al negocio antes de eliminar
        const existingCategory = await prisma.menuCategory.findFirst({
            where: { id: categoryId, businessId: businessId },
            select: { id: true }
        });
        if (!existingCategory) {
            throw new Error(`Categor√≠a de men√∫ con ID ${categoryId} no encontrada o no pertenece a este negocio.`);
        }

        // Opcional: Verificar si la categor√≠a tiene √≠tems que a su vez est√°n en pedidos activos si onDelete:Restrict se usara
        // En nuestro caso, MenuCategory -> MenuItem tiene onDelete: Cascade, as√≠ que borrar la categor√≠a borrar√° sus √≠tems.
        // Y MenuItem -> OrderItem tiene onDelete: Restrict, lo que PREVENDR√çA borrar un MenuItem si est√° en un pedido.
        // Esto significa que si una categor√≠a tiene √≠tems que est√°n en pedidos, la eliminaci√≥n de la categor√≠a (que intenta borrar los √≠tems) fallar√°
        // debido a la restricci√≥n en MenuItem. Esto es probablemente el comportamiento deseado.

        return await prisma.menuCategory.delete({
            where: { id: categoryId }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Categor√≠a de men√∫ con ID ${categoryId} no encontrada al intentar eliminar.`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') {
            // Error de Foreign key constraint failed on the field: `MenuItem_categoryId_fkey (index)` (o similar)
            // Esto ocurrir√≠a si intentamos borrar una categor√≠a cuyos √≠tems est√°n en uso (ej: en OrderItem) y la relaci√≥n MenuItem->OrderItem es Restrict.
            console.warn(`[MC_SVC] Failed to delete category ${categoryId} due to foreign key constraint (likely items in use).`);
            throw new Error(`No se puede eliminar la categor√≠a porque contiene √≠tems que est√°n actualmente en uso (ej: en pedidos). Elimine o desvincule esos √≠tems primero.`);
        }
        if (error instanceof Error && error.message.startsWith('Categor√≠a de men√∫ con ID')) {
            throw error; // Relanzar el error espec√≠fico de "no encontrado"
        }
        console.error(`[MC_SVC] Error deleting menu category ${categoryId}:`, error);
        throw new Error("Error de base de datos al eliminar la categor√≠a de men√∫.");
    }
};


// ====== [33] backend/src/modules/camarero/admin-menu-item.controller.ts ======
// backend/src/modules/camarero/admin-menu-item.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as menuItemAdminService from './admin-menu-item.service';
import { Prisma } from '@prisma/client'; // Para tipos de error

// --- Handlers del Controlador ---

// POST /api/camarero/admin/menu/categories/:categoryId/items
export const createMenuItemHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!categoryId) return res.status(400).json({ message: "Se requiere ID de la categor√≠a." });

    const {
        name_es, name_en, description_es, description_en, price, imageUrl,
        allergens, tags, isAvailable, position, preparationTime, calories, kdsDestination, sku
    } = req.body;

    if (!name_es || typeof name_es !== 'string' || name_es.trim() === '') {
        return res.status(400).json({ message: "El campo 'name_es' (nombre en espa√±ol) es obligatorio." });
    }
    if (price === undefined || typeof price !== 'number' || price < 0) {
        return res.status(400).json({ message: "El campo 'price' es obligatorio y debe ser un n√∫mero positivo." });
    }

    try {
        const menuItemData: Omit<menuItemAdminService.CreateMenuItemData, 'businessId' | 'categoryId'> = {
            name_es: name_es.trim(),
            name_en: name_en?.trim() || null,
            description_es: description_es?.trim() || null,
            description_en: description_en?.trim() || null,
            price: new Prisma.Decimal(price),
            imageUrl: imageUrl || null,
            allergens: Array.isArray(allergens) ? allergens.filter(a => typeof a === 'string') : [],
            tags: Array.isArray(tags) ? tags.filter(t => typeof t === 'string') : [],
            isAvailable: typeof isAvailable === 'boolean' ? isAvailable : true,
            position: typeof position === 'number' ? position : 0,
            preparationTime: typeof preparationTime === 'number' ? preparationTime : null,
            calories: typeof calories === 'number' ? calories : null,
            kdsDestination: kdsDestination || null,
            sku: sku?.trim() || null
        };
        const newItem = await menuItemAdminService.createMenuItem(businessId, categoryId, menuItemData);
        res.status(201).json(newItem);
    } catch (error: any) {
        if (error.message && (error.message.includes('Ya existe un √≠tem') || error.message.includes('Conflicto de unicidad'))) {
            return res.status(409).json({ message: error.message });
        }
        if (error.message && error.message.startsWith('Categor√≠a con ID')) {
            return res.status(400).json({ message: error.message });
        }
        next(error);
    }
};

// GET /api/camarero/admin/menu/categories/:categoryId/items
export const getMenuItemsByCategoryHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;
    const { isAvailable } = req.query;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!categoryId) return res.status(400).json({ message: "Se requiere ID de la categor√≠a." });

    try {
        const filter: { isAvailable?: boolean } = {};
        if (isAvailable !== undefined) {
            filter.isAvailable = String(isAvailable).toLowerCase() === 'true';
        }
        const items = await menuItemAdminService.getMenuItemsByCategory(categoryId, businessId, filter);
        res.status(200).json(items);
    } catch (error: any) {
        if (error.message && error.message.startsWith('Categor√≠a con ID')) {
            return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

// GET /api/camarero/admin/menu/items/:itemId
export const getMenuItemByIdHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    try {
        const item = await menuItemAdminService.getMenuItemById(itemId, businessId);
        if (!item) {
            return res.status(404).json({ message: "√çtem de men√∫ no encontrado o no pertenece a este negocio." });
        }
        res.status(200).json(item);
    } catch (error) {
        next(error);
    }
};

// PUT o PATCH /api/camarero/admin/menu/items/:itemId
export const updateMenuItemHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    const updateDataFromRequest = req.body;
    if (Object.keys(updateDataFromRequest).length === 0) {
        return res.status(400).json({ message: "Se requiere al menos un campo para actualizar." });
    }

    try {
        const serviceUpdateData: menuItemAdminService.UpdateMenuItemData = {};

        if (updateDataFromRequest.name_es !== undefined) serviceUpdateData.name_es = String(updateDataFromRequest.name_es).trim();
        if (updateDataFromRequest.name_en !== undefined) serviceUpdateData.name_en = updateDataFromRequest.name_en === null ? null : String(updateDataFromRequest.name_en).trim() || null;
        if (updateDataFromRequest.description_es !== undefined) serviceUpdateData.description_es = updateDataFromRequest.description_es === null ? null : String(updateDataFromRequest.description_es).trim() || null;
        if (updateDataFromRequest.description_en !== undefined) serviceUpdateData.description_en = updateDataFromRequest.description_en === null ? null : String(updateDataFromRequest.description_en).trim() || null;
        if (updateDataFromRequest.imageUrl !== undefined) serviceUpdateData.imageUrl = updateDataFromRequest.imageUrl === null ? null : String(updateDataFromRequest.imageUrl) || null;
        if (updateDataFromRequest.kdsDestination !== undefined) serviceUpdateData.kdsDestination = updateDataFromRequest.kdsDestination === null ? null : String(updateDataFromRequest.kdsDestination).trim() || null;
        if (updateDataFromRequest.sku !== undefined) serviceUpdateData.sku = updateDataFromRequest.sku === null ? null : String(updateDataFromRequest.sku).trim() || null;
        
        if (updateDataFromRequest.price !== undefined) {
            const priceNum = parseFloat(updateDataFromRequest.price);
            if (isNaN(priceNum) || priceNum < 0) return res.status(400).json({ message: "El precio debe ser un n√∫mero positivo." });
            serviceUpdateData.price = new Prisma.Decimal(priceNum);
        }
        if (updateDataFromRequest.position !== undefined) {
            const posNum = parseInt(updateDataFromRequest.position, 10);
            if (isNaN(posNum)) return res.status(400).json({ message: "La posici√≥n debe ser un n√∫mero." });
            serviceUpdateData.position = posNum;
        }
        if (updateDataFromRequest.preparationTime !== undefined) {
            serviceUpdateData.preparationTime = updateDataFromRequest.preparationTime === null ? null : parseInt(updateDataFromRequest.preparationTime, 10);
            if (serviceUpdateData.preparationTime !== null && isNaN(serviceUpdateData.preparationTime)) return res.status(400).json({ message: "El tiempo de preparaci√≥n debe ser un n√∫mero o nulo." });
        }
        if (updateDataFromRequest.calories !== undefined) {
            serviceUpdateData.calories = updateDataFromRequest.calories === null ? null : parseInt(updateDataFromRequest.calories, 10);
            if (serviceUpdateData.calories !== null && isNaN(serviceUpdateData.calories)) return res.status(400).json({ message: "Las calor√≠as deben ser un n√∫mero o nulo." });
        }

        if (updateDataFromRequest.isAvailable !== undefined) {
            if (typeof updateDataFromRequest.isAvailable !== 'boolean') return res.status(400).json({ message: "isAvailable debe ser booleano." });
            serviceUpdateData.isAvailable = updateDataFromRequest.isAvailable;
        }

        if (updateDataFromRequest.allergens !== undefined) {
            if (!Array.isArray(updateDataFromRequest.allergens) || !updateDataFromRequest.allergens.every((s: any) => typeof s === 'string')) return res.status(400).json({ message: "Los al√©rgenos deben ser un array de strings." });
            serviceUpdateData.allergens = updateDataFromRequest.allergens;
        }
        if (updateDataFromRequest.tags !== undefined) {
            if (!Array.isArray(updateDataFromRequest.tags) || !updateDataFromRequest.tags.every((s: any) => typeof s === 'string')) return res.status(400).json({ message: "Las etiquetas deben ser un array de strings." });
            serviceUpdateData.tags = updateDataFromRequest.tags;
        }
        
        if (updateDataFromRequest.categoryId !== undefined) {
            if (typeof updateDataFromRequest.categoryId !== 'string' || updateDataFromRequest.categoryId.trim() === '') return res.status(400).json({ message: "categoryId debe ser un string v√°lido si se proporciona." });
            serviceUpdateData.categoryId = updateDataFromRequest.categoryId.trim();
        }

        if (Object.keys(serviceUpdateData).length === 0) {
            return res.status(400).json({ message: "No se proporcionaron datos v√°lidos para actualizar." });
        }

        const updatedItem = await menuItemAdminService.updateMenuItem(itemId, businessId, serviceUpdateData);
        res.status(200).json(updatedItem);
    } catch (error: any) {
        if (error.message && (error.message.includes('no encontrado') || error.message.includes('no pertenece'))) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && (error.message.includes('Ya existe un √≠tem') || error.message.includes('Conflicto de unicidad'))) {
            return res.status(409).json({ message: error.message });
        }
         if (error.message && error.message.startsWith('La nueva categor√≠a de destino')) {
            return res.status(400).json({ message: error.message });
        }
        next(error);
    }
};

// DELETE /api/camarero/admin/menu/items/:itemId
export const deleteMenuItemHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    try {
        const deletedItem = await menuItemAdminService.deleteMenuItem(itemId, businessId);
        res.status(200).json({ message: "√çtem de men√∫ eliminado con √©xito.", id: deletedItem.id });
    } catch (error: any) {
         if (error.message && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('est√° en uso')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};

// --- NUEVO HANDLER A√ëADIDO ---
/**
 * GET /api/camarero/admin/menu/items/all
 * Obtiene una lista simplificada de todos los items de un negocio.
 * √ötil para selectores en el panel de administraci√≥n (ej. al crear recompensas).
 */
export const getAllMenuItemsForBusinessHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }

    try {
        const items = await menuItemAdminService.getAllMenuItemsForBusiness(businessId);
        res.status(200).json(items);
    } catch (error) {
        next(error);
    }
};


// ====== [34] backend/src/modules/camarero/admin-menu-item.service.ts ======
// backend/src/modules/camarero/admin-menu-item.service.ts
import { PrismaClient, MenuItem, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

export type CreateMenuItemData = Omit<
    Prisma.MenuItemCreateInput,
    'business' | 'category' | 'modifierGroups' | 'orderItems' | 'rewardsLinkingToThis'
> & { categoryId: string };

export type UpdateMenuItemData = Partial<
    Omit<Prisma.MenuItemUncheckedUpdateInput, 'id' | 'businessId' | 'createdAt' | 'updatedAt' | 'modifierGroups' | 'orderItems' | 'category' | 'rewardsLinkingToThis'>
>;

export const createMenuItem = async (
    businessId: string,
    categoryId: string,
    data: Omit<CreateMenuItemData, 'businessId' | 'categoryId'>
): Promise<MenuItem> => {
    console.log(`[MI_SVC] Creating menu item for business ${businessId}, category ${categoryId}:`, data.name_es);
    try {
        const categoryExists = await prisma.menuCategory.findFirst({
            where: { id: categoryId, businessId: businessId },
            select: { id: true }
        });
        if (!categoryExists) {
            throw new Error(`Categor√≠a con ID ${categoryId} no encontrada o no pertenece al negocio ${businessId}.`);
        }

        const skuValue = data.sku ? (typeof data.sku === 'string' ? data.sku.trim() : data.sku) : null;

        const newItem = await prisma.menuItem.create({
            data: {
                ...data,
                sku: skuValue || null,
                business: { connect: { id: businessId } },
                category: { connect: { id: categoryId } },
            }
        });
        return newItem;
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            console.warn(`[MI_SVC] Unique constraint violation for item:`, data.name_es, error.meta);
            const target = error.meta?.target as string[];
            if (target?.includes('name_es') && target?.includes('categoryId')) {
                 throw new Error(`Ya existe un √≠tem con el nombre '${data.name_es}' en esta categor√≠a.`);
            }
            if (target?.includes('sku') && target?.includes('businessId')) {
                 throw new Error(`Ya existe un √≠tem con el SKU '${data.sku || ''}' en este negocio.`);
            }
            throw new Error(`Conflicto de unicidad al crear el √≠tem de men√∫.`);
        }
        if (error instanceof Error && error.message.startsWith('Categor√≠a con ID')) {
            throw error;
        }
        console.error(`[MI_SVC] Error creating menu item for business ${businessId}:`, error);
        throw new Error("Error de base de datos al crear el √≠tem de men√∫.");
    }
};

export const getMenuItemsByCategory = async (
    categoryId: string,
    businessId: string,
    filter?: { isAvailable?: boolean }
): Promise<MenuItem[]> => {
    console.log(`[MI_SVC] Fetching menu items for category ${categoryId}, business ${businessId}, filter:`, filter);
    try {
        const categoryExists = await prisma.menuCategory.findFirst({
            where: { id: categoryId, businessId: businessId },
            select: { id: true }
        });
        if (!categoryExists) {
            throw new Error(`Categor√≠a con ID ${categoryId} no encontrada o no pertenece al negocio ${businessId}.`);
        }

        const whereClause: Prisma.MenuItemWhereInput = { categoryId };
        if (filter?.isAvailable !== undefined) {
            whereClause.isAvailable = filter.isAvailable;
        }

        return await prisma.menuItem.findMany({
            where: whereClause,
            orderBy: { position: 'asc' },
        });
    } catch (error) {
        if (error instanceof Error && error.message.startsWith('Categor√≠a con ID')) {
            throw error;
        }
        console.error(`[MI_SVC] Error fetching menu items for category ${categoryId}:`, error);
        throw new Error("Error al obtener los √≠tems de men√∫.");
    }
};

export const getMenuItemById = async (menuItemId: string, businessId: string): Promise<MenuItem | null> => {
    console.log(`[MI_SVC] Fetching menu item ${menuItemId} for business ${businessId}`);
    try {
        return await prisma.menuItem.findFirst({
            where: {
                id: menuItemId,
                businessId: businessId
            },
        });
    } catch (error) {
        console.error(`[MI_SVC] Error fetching menu item ${menuItemId}:`, error);
        throw new Error("Error al obtener el √≠tem de men√∫ por ID.");
    }
};

export const updateMenuItem = async (
    menuItemId: string,
    businessId: string,
    data: UpdateMenuItemData
): Promise<MenuItem> => {
    console.log(`[MI_SVC] Updating menu item ${menuItemId} for business ${businessId}:`, data);
    try {
        const existingItem = await prisma.menuItem.findFirst({
            where: { id: menuItemId, businessId: businessId },
            select: { id: true, categoryId: true }
        });
        if (!existingItem) {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado o no pertenece a este negocio.`);
        }

        const updatePayload: Prisma.MenuItemUpdateInput = { ...data } as Prisma.MenuItemUpdateInput;

        if (data.sku !== undefined) {
            if (typeof data.sku === 'string') {
                updatePayload.sku = data.sku.trim() || null;
            } else {
                updatePayload.sku = null;
            }
        }
        
        if (data.categoryId && typeof data.categoryId === 'string' && data.categoryId !== existingItem.categoryId) {
            const newCategory = await prisma.menuCategory.findFirst({
                where: { id: data.categoryId, businessId: businessId },
                select: { id: true }
            });
            if (!newCategory) {
                throw new Error(`La nueva categor√≠a de destino (ID: ${data.categoryId}) no es v√°lida o no pertenece a este negocio.`);
            }
        }

        return await prisma.menuItem.update({
            where: { id: menuItemId },
            data: updatePayload,
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            console.warn(`[MI_SVC] Unique constraint violation on update for item ${menuItemId}:`, error.meta);
            const target = error.meta?.target as string[];
            if (target?.includes('name_es') && target?.includes('categoryId')) {
                 throw new Error(`Ya existe un √≠tem con el nuevo nombre en la categor√≠a especificada.`);
            }
            if (target?.includes('sku') && target?.includes('businessId')) {
                 throw new Error(`Ya existe un √≠tem con el nuevo SKU en este negocio.`);
            }
            throw new Error(`Conflicto de unicidad al actualizar el √≠tem de men√∫.`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado al intentar actualizar.`);
        }
        if (error instanceof Error && (error.message.startsWith('√çtem de men√∫ con ID') || error.message.startsWith('La nueva categor√≠a'))) {
            throw error;
        }
        console.error(`[MI_SVC] Error updating menu item ${menuItemId}:`, error);
        throw new Error("Error de base de datos al actualizar el √≠tem de men√∫.");
    }
};

export const deleteMenuItem = async (menuItemId: string, businessId: string): Promise<MenuItem> => {
    console.log(`[MI_SVC] Deleting menu item ${menuItemId} for business ${businessId}`);
    try {
        const existingItem = await prisma.menuItem.findFirst({
            where: { id: menuItemId, businessId: businessId },
            select: { id: true }
        });
        if (!existingItem) {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado o no pertenece a este negocio.`);
        }

        return await prisma.menuItem.delete({
            where: { id: menuItemId }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado al intentar eliminar.`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') {
             console.warn(`[MI_SVC] Failed to delete menu item ${menuItemId} due to foreign key constraint (P2003).`);
            throw new Error(`No se puede eliminar el √≠tem de men√∫ porque est√° en uso (ej: en pedidos existentes). Considere desactivarlo en su lugar.`);
        }
        if (error instanceof Error && error.message.startsWith('√çtem de men√∫ con ID')) {
            throw error;
        }
        console.error(`[MI_SVC] Error deleting menu item ${menuItemId}:`, error);
        throw new Error("Error de base de datos al eliminar el √≠tem de men√∫.");
    }
};

// --- NUEVA FUNCI√ìN A√ëADIDA ---
/**
 * Obtiene todos los MenuItem disponibles para un negocio, ordenados por categor√≠a y posici√≥n.
 * Ideal para rellenar selectores en el panel de administraci√≥n.
 * @param businessId El ID del negocio.
 * @returns Una lista de objetos MenuItem.
 */
export const getAllMenuItemsForBusiness = async (businessId: string): Promise<MenuItem[]> => {
    console.log(`[MI_SVC] Fetching ALL menu items for business ${businessId}`);
    try {
        return await prisma.menuItem.findMany({
            where: {
                businessId: businessId,
                isAvailable: true // Solo traer √≠tems que el cliente puede ver/pedir
            },
            orderBy: [
                { category: { position: 'asc' } }, // Ordenar por la posici√≥n de la categor√≠a
                { position: 'asc' }                // Luego por la posici√≥n del √≠tem dentro de la categor√≠a
            ],
        });
    } catch (error) {
        console.error(`[MI_SVC] Error fetching all menu items for business ${businessId}:`, error);
        throw new Error("Error al obtener todos los √≠tems de men√∫.");
    }
};


// ====== [35] backend/src/modules/camarero/admin-modifier.controller.ts ======
// backend/src/camarero/admin-modifier.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as modifierAdminService from './admin-modifier.service';
import { Prisma } from '@prisma/client'; // Para tipos de error

// === Handlers para ModifierGroup ===

// POST /api/camarero/admin/menu/items/:itemId/modifier-groups
export const createModifierGroupHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    const { name_es, name_en, uiType, minSelections, maxSelections, position, isRequired } = req.body;

    // Validaci√≥n b√°sica (mejorar con Zod)
    if (!name_es || typeof name_es !== 'string' || name_es.trim() === '') {
        return res.status(400).json({ message: "El campo 'name_es' (nombre en espa√±ol) es obligatorio para el grupo." });
    }
    // A√±adir m√°s validaciones para uiType, minSelections, maxSelections, etc.

    try {
        const groupData: Omit<modifierAdminService.CreateModifierGroupData, 'businessId' | 'menuItemId'> = {
            name_es: name_es.trim(),
            name_en: name_en?.trim() || null,
            uiType: uiType || "RADIO", // Valor por defecto si no se provee
            minSelections: typeof minSelections === 'number' ? minSelections : 0,
            maxSelections: typeof maxSelections === 'number' ? maxSelections : 1,
            position: typeof position === 'number' ? position : 0,
            isRequired: typeof isRequired === 'boolean' ? isRequired : false,
        };
        const newGroup = await modifierAdminService.createModifierGroup(businessId, itemId, groupData);
        res.status(201).json(newGroup);
    } catch (error: any) {
        if (error.message && (error.message.includes('Ya existe un grupo') || error.message.startsWith('√çtem de men√∫ con ID'))) {
            return res.status(error.message.startsWith('√çtem de men√∫ con ID') ? 404 : 409).json({ message: error.message });
        }
        next(error);
    }
};

// GET /api/camarero/admin/menu/items/:itemId/modifier-groups
export const getModifierGroupsByMenuItemHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    try {
        const groups = await modifierAdminService.getModifierGroupsByMenuItem(itemId, businessId);
        res.status(200).json(groups);
    } catch (error: any) {
        if (error.message && error.message.startsWith('√çtem de men√∫ con ID')) {
            return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

// PUT o PATCH /api/camarero/admin/modifier-groups/:modifierGroupId
export const updateModifierGroupHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { modifierGroupId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierGroupId) return res.status(400).json({ message: "Se requiere ID del grupo de modificadores." });

    const updateDataFromRequest = req.body;
    if (Object.keys(updateDataFromRequest).length === 0) {
        return res.status(400).json({ message: "Se requiere al menos un campo para actualizar." });
    }
    // Aqu√≠ ir√≠an validaciones m√°s detalladas para los campos de updateDataFromRequest

    try {
        // No es necesario construir el objeto 'serviceUpdateData' aqu√≠ si el tipo del servicio es suficientemente permisivo
        // y los nombres de campo coinciden. El servicio se encarga de la l√≥gica.
        const updatedGroup = await modifierAdminService.updateModifierGroup(modifierGroupId, businessId, updateDataFromRequest);
        res.status(200).json(updatedGroup);
    } catch (error: any) {
        if (error.message && error.message.startsWith('Grupo de modificadores con ID')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('Error de unicidad')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};

// DELETE /api/camarero/admin/modifier-groups/:modifierGroupId
export const deleteModifierGroupHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { modifierGroupId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierGroupId) return res.status(400).json({ message: "Se requiere ID del grupo de modificadores." });

    try {
        const deletedGroup = await modifierAdminService.deleteModifierGroup(modifierGroupId, businessId);
        res.status(200).json({ message: "Grupo de modificadores eliminado con √©xito.", id: deletedGroup.id });
    } catch (error: any) {
        if (error.message && error.message.startsWith('Grupo de modificadores con ID')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('opciones est√° en uso')) { // Mensaje del servicio para P2003
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};


// === Handlers para ModifierOption ===

// POST /api/camarero/admin/modifier-groups/:modifierGroupId/options
export const createModifierOptionHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Para verificar pertenencia del grupo padre
    const { modifierGroupId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierGroupId) return res.status(400).json({ message: "Se requiere ID del grupo de modificadores." });

    const { name_es, name_en, priceAdjustment, position, isDefault, isAvailable } = req.body;

    if (!name_es || typeof name_es !== 'string' || name_es.trim() === '') {
        return res.status(400).json({ message: "El campo 'name_es' es obligatorio para la opci√≥n." });
    }
    // A√±adir m√°s validaciones (priceAdjustment debe ser n√∫mero, etc.)

    try {
        const optionData: Omit<modifierAdminService.CreateModifierOptionData, 'groupId'> = {
            name_es: name_es.trim(),
            name_en: name_en?.trim() || null,
            priceAdjustment: priceAdjustment === undefined ? 0 : new Prisma.Decimal(priceAdjustment),
            position: typeof position === 'number' ? position : 0,
            isDefault: typeof isDefault === 'boolean' ? isDefault : false,
            isAvailable: typeof isAvailable === 'boolean' ? isAvailable : true,
        };
        const newOption = await modifierAdminService.createModifierOption(modifierGroupId, businessId, optionData);
        res.status(201).json(newOption);
    } catch (error: any) {
        if (error.message && (error.message.includes('Ya existe una opci√≥n') || error.message.startsWith('Grupo de modificadores con ID'))) {
            return res.status(error.message.startsWith('Grupo de modificadores con ID') ? 404 : 409).json({ message: error.message });
        }
        next(error);
    }
};

// GET /api/camarero/admin/modifier-groups/:modifierGroupId/options
export const getModifierOptionsByGroupHandler = async (req: Request, res: Response, next: NextFunction) => {
    // businessId no es estrictamente necesario aqu√≠ si el servicio conf√≠a en que modifierGroupId es v√°lido
    // pero se podr√≠a a√±adir una capa extra de verificaci√≥n si se desea.
    const { modifierGroupId } = req.params;
    if (!modifierGroupId) return res.status(400).json({ message: "Se requiere ID del grupo de modificadores." });

    try {
        // El servicio getModifierOptionsByGroup podr√≠a necesitar businessId si queremos verificar que el grupo
        // realmente pertenece al negocio del admin autenticado, ANTES de buscar las opciones.
        // Por ahora, el servicio actual no lo requiere, pero es una consideraci√≥n de seguridad/l√≥gica.
        const options = await modifierAdminService.getModifierOptionsByGroup(modifierGroupId);
        res.status(200).json(options);
    } catch (error) {
        next(error);
    }
};

// PUT o PATCH /api/camarero/admin/modifier-options/:modifierOptionId
export const updateModifierOptionHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Para verificar pertenencia
    const { modifierOptionId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierOptionId) return res.status(400).json({ message: "Se requiere ID de la opci√≥n de modificador." });

    const updateDataFromRequest = req.body;
    if (Object.keys(updateDataFromRequest).length === 0) {
        return res.status(400).json({ message: "Se requiere al menos un campo para actualizar." });
    }
    // Aqu√≠ ir√≠an validaciones m√°s detalladas

    try {
        const serviceUpdateData: modifierAdminService.UpdateModifierOptionData = { ...updateDataFromRequest };
        if (updateDataFromRequest.priceAdjustment !== undefined) {
            serviceUpdateData.priceAdjustment = new Prisma.Decimal(updateDataFromRequest.priceAdjustment);
        }
        // ... procesar otros campos si necesitan conversi√≥n o validaci√≥n espec√≠fica ...

        const updatedOption = await modifierAdminService.updateModifierOption(modifierOptionId, businessId, serviceUpdateData);
        res.status(200).json(updatedOption);
    } catch (error: any) {
        if (error.message && error.message.startsWith('Opci√≥n de modificador con ID')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('Error de unicidad')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};

// DELETE /api/camarero/admin/modifier-options/:modifierOptionId
export const deleteModifierOptionHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Para verificar pertenencia
    const { modifierOptionId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierOptionId) return res.status(400).json({ message: "Se requiere ID de la opci√≥n de modificador." });

    try {
        const deletedOption = await modifierAdminService.deleteModifierOption(modifierOptionId, businessId);
        res.status(200).json({ message: "Opci√≥n de modificador eliminada con √©xito.", id: deletedOption.id });
    } catch (error: any) {
        if (error.message && error.message.startsWith('Opci√≥n de modificador con ID')) {
            return res.status(404).json({ message: error.message });
        }
         if (error.message && error.message.includes('est√° en uso')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};


// ====== [36] backend/src/modules/camarero/admin-modifier.service.ts ======
// backend/src/camarero/admin-modifier.service.ts
import { PrismaClient, ModifierGroup, ModifierOption, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

// --- TIPOS PARA ModifierGroup ---
export type CreateModifierGroupData = Omit<Prisma.ModifierGroupCreateInput, 'menuItem' | 'business' | 'options'>;
export type UpdateModifierGroupData = Partial<Omit<Prisma.ModifierGroupUpdateInput, 'menuItem' | 'business' | 'options'>>;

// --- TIPOS PARA ModifierOption ---
export type CreateModifierOptionData = Omit<Prisma.ModifierOptionCreateInput, 'group' | 'orderItems'>;
export type UpdateModifierOptionData = Partial<Omit<Prisma.ModifierOptionUpdateInput, 'group' | 'orderItems'>>;

// === L√ìGICA PARA ModifierGroup ===

/**
 * Crea un nuevo grupo de modificadores para un √≠tem de men√∫ espec√≠fico.
 */
export const createModifierGroup = async (
    businessId: string,
    menuItemId: string,
    data: Omit<CreateModifierGroupData, 'businessId' | 'menuItemId'>
): Promise<ModifierGroup> => {
    console.log(`[MOD_SVC] Creating modifier group for menuItem ${menuItemId}, business ${businessId}:`, data.name_es);
    try {
        // Verificar que el MenuItem pertenece al businessId
        const menuItemExists = await prisma.menuItem.findFirst({
            where: { id: menuItemId, businessId: businessId },
            select: { id: true }
        });
        if (!menuItemExists) {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado o no pertenece al negocio ${businessId}.`);
        }

        return await prisma.modifierGroup.create({
            data: {
                ...data,
                menuItem: { connect: { id: menuItemId } },
                business: { connect: { id: businessId } } // Conectar tambi√©n al negocio
            }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            throw new Error(`Ya existe un grupo de modificadores con el nombre '${data.name_es}' para este √≠tem de men√∫.`);
        }
        if (error instanceof Error && error.message.startsWith('√çtem de men√∫ con ID')) throw error;
        console.error(`[MOD_SVC] Error creating modifier group for menuItem ${menuItemId}:`, error);
        throw new Error("Error de base de datos al crear el grupo de modificadores.");
    }
};

/**
 * Obtiene todos los grupos de modificadores para un √≠tem de men√∫.
 */
export const getModifierGroupsByMenuItem = async (menuItemId: string, businessId: string): Promise<ModifierGroup[]> => {
    console.log(`[MOD_SVC] Fetching modifier groups for menuItem ${menuItemId}, business ${businessId}`);
    try {
        // Verificar que el MenuItem pertenece al businessId (opcional, pero buena pr√°ctica)
        const menuItemExists = await prisma.menuItem.count({ where: { id: menuItemId, businessId: businessId }});
        if (menuItemExists === 0) {
             throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado o no pertenece al negocio ${businessId}.`);
        }

        return await prisma.modifierGroup.findMany({
            where: { menuItemId: menuItemId },
            orderBy: { position: 'asc' },
            include: { options: { orderBy: { position: 'asc' } } } // Incluir opciones ordenadas
        });
    } catch (error) {
        if (error instanceof Error && error.message.startsWith('√çtem de men√∫ con ID')) throw error;
        console.error(`[MOD_SVC] Error fetching modifier groups for menuItem ${menuItemId}:`, error);
        throw new Error("Error al obtener los grupos de modificadores.");
    }
};

/**
 * Actualiza un grupo de modificadores existente.
 */
export const updateModifierGroup = async (
    modifierGroupId: string,
    businessId: string, // Para verificar pertenencia
    data: UpdateModifierGroupData
): Promise<ModifierGroup> => {
    console.log(`[MOD_SVC] Updating modifier group ${modifierGroupId} for business ${businessId}:`, data);
    try {
        const existingGroup = await prisma.modifierGroup.findFirst({
            where: { id: modifierGroupId, businessId: businessId }, // Asegurar que el grupo pertenece al negocio
            select: { id: true }
        });
        if (!existingGroup) {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado o no pertenece a este negocio.`);
        }
        return await prisma.modifierGroup.update({
            where: { id: modifierGroupId },
            data: data
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            throw new Error(`Error de unicidad al actualizar el grupo de modificadores (ej: el nuevo nombre ya existe para el √≠tem).`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado.`);
        }
        if (error instanceof Error && error.message.startsWith('Grupo de modificadores con ID')) throw error;
        console.error(`[MOD_SVC] Error updating modifier group ${modifierGroupId}:`, error);
        throw new Error("Error de base de datos al actualizar el grupo de modificadores.");
    }
};

/**
 * Elimina un grupo de modificadores (y sus opciones en cascada).
 */
export const deleteModifierGroup = async (modifierGroupId: string, businessId: string): Promise<ModifierGroup> => {
    console.log(`[MOD_SVC] Deleting modifier group ${modifierGroupId} for business ${businessId}`);
    try {
        const existingGroup = await prisma.modifierGroup.findFirst({
            where: { id: modifierGroupId, businessId: businessId },
            select: { id: true }
        });
        if (!existingGroup) {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado o no pertenece a este negocio.`);
        }
        // Prisma maneja el borrado en cascada de ModifierOption debido a la relaci√≥n
        return await prisma.modifierGroup.delete({
            where: { id: modifierGroupId }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado.`);
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') {
            throw new Error(`No se puede eliminar el grupo de modificadores porque una de sus opciones est√° en uso (ej: en pedidos).`);
        }
        if (error instanceof Error && error.message.startsWith('Grupo de modificadores con ID')) throw error;
        console.error(`[MOD_SVC] Error deleting modifier group ${modifierGroupId}:`, error);
        throw new Error("Error de base de datos al eliminar el grupo de modificadores.");
    }
};


// === L√ìGICA PARA ModifierOption ===

/**
 * Crea una nueva opci√≥n de modificador para un grupo espec√≠fico.
 */
export const createModifierOption = async (
    modifierGroupId: string,
    businessId: string, // Para verificar que el grupo padre pertenece al negocio
    data: Omit<CreateModifierOptionData, 'groupId'>
): Promise<ModifierOption> => {
    console.log(`[MOD_SVC] Creating modifier option for group ${modifierGroupId}, business ${businessId}:`, data.name_es);
    try {
        // Verificar que el ModifierGroup padre pertenece al businessId
        const groupExists = await prisma.modifierGroup.findFirst({
            where: { id: modifierGroupId, businessId: businessId },
            select: { id: true }
        });
        if (!groupExists) {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado o no pertenece al negocio ${businessId}.`);
        }

        return await prisma.modifierOption.create({
            data: {
                ...data,
                group: { connect: { id: modifierGroupId } }
            }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            throw new Error(`Ya existe una opci√≥n con el nombre '${data.name_es}' en este grupo de modificadores.`);
        }
        if (error instanceof Error && error.message.startsWith('Grupo de modificadores con ID')) throw error;
        console.error(`[MOD_SVC] Error creating modifier option for group ${modifierGroupId}:`, error);
        throw new Error("Error de base de datos al crear la opci√≥n de modificador.");
    }
};

/**
 * Obtiene todas las opciones para un grupo de modificadores espec√≠fico.
 * (La verificaci√≥n de pertenencia del grupo al negocio ya se har√≠a al obtener/validar el grupo)
 */
export const getModifierOptionsByGroup = async (modifierGroupId: string): Promise<ModifierOption[]> => {
    console.log(`[MOD_SVC] Fetching modifier options for group ${modifierGroupId}`);
    try {
        return await prisma.modifierOption.findMany({
            where: { groupId: modifierGroupId },
            orderBy: { position: 'asc' }
        });
    } catch (error) {
        console.error(`[MOD_SVC] Error fetching modifier options for group ${modifierGroupId}:`, error);
        throw new Error("Error al obtener las opciones de modificadores.");
    }
};

/**
 * Actualiza una opci√≥n de modificador existente.
 */
export const updateModifierOption = async (
    modifierOptionId: string,
    businessId: string, // Para verificar que la opci√≥n pertenece a un grupo de ese negocio
    data: UpdateModifierOptionData
): Promise<ModifierOption> => {
    console.log(`[MOD_SVC] Updating modifier option ${modifierOptionId} for business ${businessId}:`, data);
    try {
        // Verificar que la opci√≥n pertenece a un grupo del negocio
        const existingOption = await prisma.modifierOption.findFirst({
            where: {
                id: modifierOptionId,
                group: { businessId: businessId } // Verificar a trav√©s de la relaci√≥n con el grupo
            },
            select: { id: true }
        });
        if (!existingOption) {
            throw new Error(`Opci√≥n de modificador con ID ${modifierOptionId} no encontrada o no pertenece a este negocio.`);
        }

        return await prisma.modifierOption.update({
            where: { id: modifierOptionId },
            data: data
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            throw new Error(`Error de unicidad al actualizar la opci√≥n (ej: el nuevo nombre ya existe en el grupo).`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Opci√≥n de modificador con ID ${modifierOptionId} no encontrada.`);
        }
        if (error instanceof Error && error.message.startsWith('Opci√≥n de modificador con ID')) throw error;
        console.error(`[MOD_SVC] Error updating modifier option ${modifierOptionId}:`, error);
        throw new Error("Error de base de datos al actualizar la opci√≥n de modificador.");
    }
};

/**
 * Elimina una opci√≥n de modificador.
 */
export const deleteModifierOption = async (modifierOptionId: string, businessId: string): Promise<ModifierOption> => {
    console.log(`[MOD_SVC] Deleting modifier option ${modifierOptionId} for business ${businessId}`);
    try {
        const existingOption = await prisma.modifierOption.findFirst({
            where: {
                id: modifierOptionId,
                group: { businessId: businessId }
            },
            select: { id: true }
        });
        if (!existingOption) {
            throw new Error(`Opci√≥n de modificador con ID ${modifierOptionId} no encontrada o no pertenece a este negocio.`);
        }
        // Prisma maneja el borrado en cascada si esta opci√≥n estuviera en OrderItemModifierOption
        // debido a la relaci√≥n en ese modelo de uni√≥n.
        return await prisma.modifierOption.delete({
            where: { id: modifierOptionId }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Opci√≥n de modificador con ID ${modifierOptionId} no encontrada.`);
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') {
            // Foreign key constraint failed on the field: `OrderItemModifierOption_modifierOptionId_fkey (index)`
            throw new Error(`No se puede eliminar la opci√≥n porque est√° en uso (ej: en pedidos existentes).`);
        }
        if (error instanceof Error && error.message.startsWith('Opci√≥n de modificador con ID')) throw error;
        console.error(`[MOD_SVC] Error deleting modifier option ${modifierOptionId}:`, error);
        throw new Error("Error de base de datos al eliminar la opci√≥n de modificador.");
    }
};


// ====== [37] backend/src/modules/camarero/camarero.dto.ts ======
// backend/src/camarero/camarero.dto.ts
// Version: 1.2.0 (Add WaiterOrderListItemDto)

import { OrderItemStatus, OrderStatus, OrderType } from '@prisma/client'; // A√±adido OrderType

/**
 * DTO para la informaci√≥n de un modificador seleccionado que se muestra al camarero
 * como parte de un √≠tem listo para recoger.
 */
export interface WaiterSelectedModifierDto {
  optionName_es: string | null;
  optionName_en: string | null;
}

/**
 * DTO para cada √≠tem de pedido que est√° listo para ser recogido y servido por el personal de camareros.
 * Esta es la estructura de datos que el endpoint GET /api/camarero/staff/ready-for-pickup devolver√°.
 */
export interface ReadyPickupItemDto {
  orderItemId: string;
  orderId: string;
  orderNumber: string;
  orderCreatedAt: Date;
  tableIdentifier: string | null;
  itemNameSnapshot_es: string | null;
  itemNameSnapshot_en: string | null;
  quantity: number;
  itemNotes: string | null;
  kdsDestination: string | null;
  selectedModifiers: WaiterSelectedModifierDto[];
  currentOrderItemStatus: OrderItemStatus;
}

/**
 * DTO para el payload del endpoint que permite al camarero marcar un OrderItem como SERVED.
 * Usado en: PATCH /api/camarero/staff/order-items/:orderItemId/status
 */
export interface MarkOrderItemServedPayloadDto {
  newStatus: typeof OrderItemStatus.SERVED;
}

/**
 * DTO para la respuesta est√°ndar al actualizar el estado de un OrderItem
 * desde la interfaz de camarero o KDS.
 */
export interface OrderItemStatusUpdateResponseDto {
  message: string;
  orderItemId: string;
  newStatus: OrderItemStatus;
  orderStatus?: OrderStatus;
}

/**
 * DTO para el payload del endpoint que permite al personal solicitar la cuenta.
 * Usado en: POST /api/camarero/staff/order/:orderId/request-bill
 */
export interface RequestBillPayloadDto {
  paymentPreference?: string;
}

/**
 * DTO para el payload del endpoint que permite al camarero marcar un pedido como PAGADO.
 * Usado en: POST /api/camarero/staff/order/:orderId/mark-as-paid
 */
export interface MarkOrderAsPaidPayloadDto {
  method?: string;
  notes?: string;
}

// ---- NUEVO DTO ----
/**
 * DTO para representar un √≠tem en la lista de pedidos para la interfaz del camarero.
 * Usado en: GET /api/camarero/staff/orders
 */
export interface WaiterOrderListItemDto {
  orderId: string;
  orderNumber: string;
  tableIdentifier: string | null;
  status: OrderStatus;
  finalAmount: number; // O string si prefieres manejarlo como string en el frontend inicialmente
  itemCount: number; // N√∫mero total de √≠tems (no cancelados) en el pedido
  customerName?: string | null; // Nombre del cliente LCo si est√° asociado
  createdAt: Date; // Fecha de creaci√≥n del pedido
  isBillRequested?: boolean; // Para saber si la cuenta ya fue solicitada
  orderType?: OrderType | null; // Tipo de pedido
}
// ---- FIN NUEVO DTO ----


// ====== [38] backend/src/modules/camarero/kds.controller.ts ======
// backend/src/camarero/kds.controller.ts
import { Request, Response, NextFunction } from 'express';
import { OrderItemStatus } from '@prisma/client'; // Para validar el enum
import * as kdsService from './kds.service';

/**
 * Handler para GET /api/camarero/kds/items
 * Obtiene los √≠tems de pedido para una destino KDS espec√≠fico.
 */
export const getItemsForKdsHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Asumimos que authenticateToken ya lo a√±adi√≥
    const { destination, status } = req.query;

    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado en la sesi√≥n del usuario." });
    }
    if (!destination || typeof destination !== 'string' || destination.trim() === '') {
        return res.status(400).json({ message: "El par√°metro 'destination' (destino KDS) es obligatorio." });
    }

    let statusFilter: OrderItemStatus[] | undefined = undefined;
    if (status) {
        if (typeof status === 'string') {
            const singleStatus = status.toUpperCase() as OrderItemStatus;
            if (Object.values(OrderItemStatus).includes(singleStatus)) {
                statusFilter = [singleStatus];
            } else {
                return res.status(400).json({ message: `Valor de 'status' inv√°lido: ${status}` });
            }
        } else if (Array.isArray(status)) {
            statusFilter = [];
            for (const s of status) {
                if (typeof s === 'string') {
                    const singleStatus = s.toUpperCase() as OrderItemStatus;
                     if (Object.values(OrderItemStatus).includes(singleStatus)) {
                        statusFilter.push(singleStatus);
                    } else {
                        return res.status(400).json({ message: `Valor de 'status' inv√°lido en el array: ${s}` });
                    }
                } else {
                     return res.status(400).json({ message: "Todos los valores de 'status' en el array deben ser strings." });
                }
            }
            if (statusFilter.length === 0) statusFilter = undefined; // Si el array queda vac√≠o, no filtrar
        } else {
            return res.status(400).json({ message: "El par√°metro 'status' debe ser un string o un array de strings." });
        }
    }
    
    console.log(`[KDS CTRL] Request for KDS items. Business: ${businessId}, Dest: ${destination}, Status: ${statusFilter?.join(',') || 'Default'}`);

    try {
        const items = await kdsService.getItemsForKds(businessId, destination.trim().toUpperCase(), statusFilter);
        res.status(200).json(items);
    } catch (error) {
        console.error(`[KDS CTRL] Error getting items for KDS (Dest: ${destination}):`, error);
        next(error); // Pasar al manejador de errores global
    }
};

/**
 * Handler para PATCH /api/camarero/kds/items/:orderItemId/status
 * Actualiza el estado de un OrderItem espec√≠fico.
 */
export const updateOrderItemStatusHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Asumimos que authenticateToken ya lo a√±adi√≥
    const { orderItemId } = req.params;
    const { newStatus } = req.body; // Esperamos { "newStatus": "PREPARING" } por ejemplo

    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado en la sesi√≥n del usuario." });
    }
    if (!orderItemId) {
        return res.status(400).json({ message: "Falta el ID del √≠tem de pedido (orderItemId) en la URL." });
    }
    if (!newStatus || typeof newStatus !== 'string') {
        return res.status(400).json({ message: "Falta el campo 'newStatus' o no es un string en el cuerpo de la petici√≥n." });
    }

    const validatedNewStatus = newStatus.toUpperCase() as OrderItemStatus;
    if (!Object.values(OrderItemStatus).includes(validatedNewStatus)) {
        return res.status(400).json({ message: `El valor de 'newStatus' ('${newStatus}') no es un estado v√°lido.` });
    }
    
    console.log(`[KDS CTRL] Request to update OrderItem ${orderItemId} to status ${validatedNewStatus} for business ${businessId}`);

    try {
        const updatedItem = await kdsService.updateOrderItemStatus(orderItemId, validatedNewStatus, businessId);
        res.status(200).json(updatedItem);
    } catch (error: any) { // Especificar 'any' o un tipo m√°s espec√≠fico
        console.error(`[KDS CTRL] Error updating status for OrderItem ${orderItemId} to ${validatedNewStatus}:`, error);
        // El servicio ya puede lanzar errores con mensajes espec√≠ficos (ej: transici√≥n no permitida, √≠tem no encontrado)
        // Si el mensaje es espec√≠fico del servicio y queremos mostrarlo, lo pasamos tal cual.
        if (error.message) {
            // Podr√≠amos mapear ciertos mensajes de error a c√≥digos de estado HTTP espec√≠ficos
            if (error.message.includes('no encontrado')) {
                return res.status(404).json({ message: error.message });
            }
            if (error.message.includes('no permitida')) {
                return res.status(400).json({ message: error.message }); // Bad Request por l√≥gica de negocio
            }
        }
        next(error); // Pasar otros errores al manejador global
    }
};


// ====== [39] backend/src/modules/camarero/kds.service.ts ======
// backend/src/camarero/kds.service.ts
// Version: 1.1.1 (Corrected enums based on TS errors, refined Order.status logic - FULL FILE)

import { PrismaClient, Prisma, OrderItem, OrderItemStatus, OrderStatus } from '@prisma/client';

const prisma = new PrismaClient();

// Tipo para la informaci√≥n que necesita el KDS para cada OrderItem
export interface KdsOrderItemData {
    id: string; // OrderItem ID
    quantity: number;
    status: OrderItemStatus; // Usar√° los enums del cliente: PENDING_KDS, PREPARING, READY, etc.
    notes: string | null;
    kdsDestination: string | null;
    menuItemName_es: string | null;
    menuItemName_en: string | null;
    selectedModifiers: {
        optionName_es: string | null;
        optionName_en: string | null;
    }[];
    orderInfo: {
        id: string; // Order ID
        orderNumber: string;
        createdAt: Date;
        tableIdentifier: string | null;
    };
    preparationTime?: number | null;
    preparedAt?: Date | null;
    servedAt?: Date | null;
}


/**
 * Obtiene los √≠tems de pedido para una destino KDS espec√≠fico.
 * @param businessId - ID del negocio.
 * @param kdsDestination - El destino KDS (ej. "COCINA", "BARRA").
 * @param filterStatus - Array opcional de OrderItemStatus para filtrar.
 * @returns Array de KdsOrderItemData.
 */
export const getItemsForKds = async (
    businessId: string,
    kdsDestination: string,
    filterStatus?: OrderItemStatus[]
): Promise<KdsOrderItemData[]> => {
    console.log(`[KDS SVC] Fetching items for KDS. Business: ${businessId}, Destination: ${kdsDestination}, StatusFilter: ${filterStatus?.join(',')}`);

    // Usamos los estados de Prisma que el entorno espera: PENDING_KDS, PREPARING
    const statusFilterToUse = filterStatus && filterStatus.length > 0
        ? filterStatus
        : [OrderItemStatus.PENDING_KDS, OrderItemStatus.PREPARING];

    try {
        const orderItems = await prisma.orderItem.findMany({
            where: {
                order: {
                    businessId: businessId,
                    // Pedidos que est√°n listos para cocina/KDS: RECEIVED, IN_PROGRESS, PARTIALLY_READY, ALL_ITEMS_READY
                    // Excluimos PENDING_PAYMENT, PAID, COMPLETED, CANCELLED, PAYMENT_FAILED
                    status: {
                        in: [
                            OrderStatus.RECEIVED,
                            OrderStatus.IN_PROGRESS,
                            OrderStatus.PARTIALLY_READY,
                            OrderStatus.ALL_ITEMS_READY
                        ],
                    }
                },
                kdsDestination: kdsDestination,
                status: {
                    in: statusFilterToUse,
                },
            },
            include: {
                menuItem: {
                    select: {
                        name_es: true,
                        name_en: true,
                        preparationTime: true,
                    }
                },
                selectedModifiers: {
                    include: {
                        modifierOption: {
                            select: {
                                name_es: true,
                                name_en: true,
                            }
                        }
                    }
                },
                order: {
                    select: {
                        id: true,
                        orderNumber: true,
                        createdAt: true,
                        table: {
                            select: {
                                identifier: true,
                            }
                        }
                    }
                }
            },
            orderBy: {
                order: {
                    createdAt: 'asc',
                }
            }
        });

        const kdsItems: KdsOrderItemData[] = orderItems.map(item => ({
            id: item.id,
            quantity: item.quantity,
            status: item.status,
            notes: item.notes,
            kdsDestination: item.kdsDestination,
            menuItemName_es: item.menuItem?.name_es || item.itemNameSnapshot,
            menuItemName_en: item.menuItem?.name_en || null,
            selectedModifiers: item.selectedModifiers.map(sm => ({
                optionName_es: sm.modifierOption?.name_es || sm.optionNameSnapshot,
                optionName_en: sm.modifierOption?.name_en || null,
            })),
            orderInfo: {
                id: item.order.id,
                orderNumber: item.order.orderNumber,
                createdAt: item.order.createdAt,
                tableIdentifier: item.order.table?.identifier || null,
            },
            preparationTime: item.menuItem?.preparationTime,
            preparedAt: item.preparedAt,
            servedAt: item.servedAt,
        }));

        console.log(`[KDS SVC] Found ${kdsItems.length} items for KDS Destination '${kdsDestination}'.`);
        return kdsItems;

    } catch (error) {
        console.error(`[KDS SVC] Error fetching items for KDS (Destination: ${kdsDestination}):`, error);
        if (error instanceof Error) {
            throw new Error(`Error al obtener los √≠tems para el KDS: ${error.message}`);
        }
        throw new Error('Error al obtener los √≠tems para el KDS desde la base de datos.');
    }
};


/**
 * Actualiza el estado de un OrderItem espec√≠fico.
 * Tambi√©n maneja la l√≥gica para actualizar el estado del Order general.
 * @param orderItemId - ID del OrderItem a actualizar.
 * @param newOrderItemStatus - El nuevo OrderItemStatus (debe ser uno de los definidos en el Prisma del entorno).
 * @param businessId - ID del negocio (para verificaci√≥n de pertenencia).
 * @returns El OrderItem actualizado con sus relaciones (order, menuItem, selectedModifiers).
 */
export const updateOrderItemStatus = async (
    orderItemId: string,
    newOrderItemStatus: OrderItemStatus, // Usamos el enum del entorno
    businessId: string
): Promise<OrderItem> => {
    console.log(`[KDS SVC] Attempting to update OrderItem ${orderItemId} to ${newOrderItemStatus} for business ${businessId}`);

    // Transiciones permitidas usando los enums del entorno
    const allowedTransitions: Partial<Record<OrderItemStatus, OrderItemStatus[]>> = {
        [OrderItemStatus.PENDING_KDS]: [OrderItemStatus.PREPARING, OrderItemStatus.CANCELLED, OrderItemStatus.CANCELLATION_REQUESTED],
        [OrderItemStatus.PREPARING]:   [OrderItemStatus.READY, OrderItemStatus.PENDING_KDS, OrderItemStatus.CANCELLED, OrderItemStatus.CANCELLATION_REQUESTED],
        [OrderItemStatus.READY]:       [OrderItemStatus.SERVED, OrderItemStatus.PREPARING], // SERVED lo har√≠a un camarero, KDS lo pasa a READY, quiz√° puede volver a PREPARING
        [OrderItemStatus.CANCELLATION_REQUESTED]: [OrderItemStatus.CANCELLED, OrderItemStatus.PENDING_KDS, OrderItemStatus.PREPARING], // Si se rechaza la cancelaci√≥n
        // SERVED y CANCELLED son finales desde KDS
    };

    const finalUpdatedOrderItem = await prisma.$transaction(async (tx) => {
        let currentOrderItem = await tx.orderItem.findFirst({
            where: { id: orderItemId, order: { businessId: businessId } },
            include: { order: { select: { id: true, status: true } } }
        });

        if (!currentOrderItem) {
            throw new Error(`√çtem de pedido con ID ${orderItemId} no encontrado o no pertenece a este negocio.`);
        }
        if (!currentOrderItem.order?.id) {
             throw new Error(`Error interno: El √≠tem de pedido ${orderItemId} no est√° asociado a un pedido.`);
        }

        const currentOrderItemStatusValue = currentOrderItem.status;

        if (currentOrderItemStatusValue !== newOrderItemStatus) {
            if (allowedTransitions[currentOrderItemStatusValue] && !allowedTransitions[currentOrderItemStatusValue]?.includes(newOrderItemStatus)) {
                throw new Error(`Transici√≥n de estado no permitida para el √≠tem de '${currentOrderItemStatusValue}' a '${newOrderItemStatus}'.`);
            }

            const dataToUpdateForOrderItem: Prisma.OrderItemUpdateInput = { status: newOrderItemStatus };
            let newPreparedAtDate: Date | null = currentOrderItem.preparedAt;
            let newServedAtDate: Date | null = currentOrderItem.servedAt;

            if (newOrderItemStatus === OrderItemStatus.PREPARING && !currentOrderItem.preparedAt) {
                newPreparedAtDate = new Date();
                dataToUpdateForOrderItem.preparedAt = newPreparedAtDate;
            } else if (newOrderItemStatus === OrderItemStatus.READY && !currentOrderItem.preparedAt) {
                newPreparedAtDate = new Date();
                dataToUpdateForOrderItem.preparedAt = newPreparedAtDate;
            } else if (newOrderItemStatus === OrderItemStatus.SERVED && !currentOrderItem.servedAt) {
                newServedAtDate = new Date();
                dataToUpdateForOrderItem.servedAt = newServedAtDate;
                if (!currentOrderItem.preparedAt) { // Si se sirve directamente (ej. bebidas)
                    newPreparedAtDate = new Date();
                    dataToUpdateForOrderItem.preparedAt = newPreparedAtDate;
                }
            }

            await tx.orderItem.update({
                where: { id: orderItemId },
                data: dataToUpdateForOrderItem,
            });
            console.log(`[KDS SVC] OrderItem ${orderItemId} status updated to ${newOrderItemStatus} in DB.`);

            currentOrderItem.status = newOrderItemStatus;
            currentOrderItem.preparedAt = newPreparedAtDate;
            currentOrderItem.servedAt = newServedAtDate;

        } else {
            console.log(`[KDS SVC] OrderItem ${orderItemId} ya est√° en estado ${newOrderItemStatus}. No se requiere actualizaci√≥n de √≠tem.`);
        }

        // --- L√ìGICA DE ACTUALIZACI√ìN DEL ESTADO DEL PEDIDO (Order.status) CON ENUMS DEL ENTORNO ---
        const orderId = currentOrderItem.order.id;
        const currentOrderStatusInDb = currentOrderItem.order.status;

        const allItemsOfThisOrder = await tx.orderItem.findMany({
            where: { orderId: orderId },
            select: { status: true, id: true }
        });

        console.log(`[KDS SVC - OrderStatusLogic] For Order ${orderId} - Current Order Status in DB: ${currentOrderStatusInDb}`);
        console.log(`[KDS SVC - OrderStatusLogic] All items for order ${orderId} (after potential item update):`, allItemsOfThisOrder.map(i => ({id: i.id, status: i.status})));

        // Filtrar √≠tems que no est√°n CANCELLED. CANCELLATION_REQUESTED se trata como activo hasta que se confirma.
        const activeItems = allItemsOfThisOrder.filter(item =>
            item.status !== OrderItemStatus.CANCELLED
        );

        let determinedNewOrderStatus: OrderStatus = currentOrderStatusInDb;

        if (allItemsOfThisOrder.length === 0) {
            console.log(`[KDS SVC - OrderStatusLogic] No items found for order ${orderId}. Status remains ${determinedNewOrderStatus}`);
        } else if (activeItems.length === 0) {
            // Todos los √≠tems originales fueron CANCELLED
            determinedNewOrderStatus = OrderStatus.CANCELLED;
            console.log(`[KDS SVC - OrderStatusLogic] All items are CANCELLED. New OrderStatus -> ${determinedNewOrderStatus}`);
        } else {
            const allServed = activeItems.every(item => item.status === OrderItemStatus.SERVED);
            const allReadyOrServed = activeItems.every(item => item.status === OrderItemStatus.READY || item.status === OrderItemStatus.SERVED);
            const anyReady = activeItems.some(item => item.status === OrderItemStatus.READY);
            const anyPreparing = activeItems.some(item => item.status === OrderItemStatus.PREPARING);
            // const allPendingKds = activeItems.every(item => item.status === OrderItemStatus.PENDING_KDS);

            if (allServed) {
                // Si todos los √≠tems activos est√°n servidos, el pedido se considera completado.
                // La transici√≥n a PAID se manejar√≠a en otro flujo (POS o similar).
                determinedNewOrderStatus = OrderStatus.COMPLETED;
                console.log(`[KDS SVC - OrderStatusLogic] All active items SERVED. New OrderStatus -> ${determinedNewOrderStatus}`);
            } else if (allReadyOrServed) {
                // Si todos los √≠tems activos est√°n listos (READY) o ya servidos (pero no todos servidos)
                determinedNewOrderStatus = OrderStatus.ALL_ITEMS_READY;
                console.log(`[KDS SVC - OrderStatusLogic] All active items READY or SERVED. New OrderStatus -> ${determinedNewOrderStatus}`);
            } else if (anyReady) {
                // Si algunos √≠tems est√°n listos (READY), pero no todos (y no todos servidos)
                // Y el pedido estaba en progreso o reci√©n recibido.
                if (currentOrderStatusInDb === OrderStatus.IN_PROGRESS || currentOrderStatusInDb === OrderStatus.RECEIVED || currentOrderStatusInDb === OrderStatus.PARTIALLY_READY) {
                    determinedNewOrderStatus = OrderStatus.PARTIALLY_READY;
                    console.log(`[KDS SVC - OrderStatusLogic] Some items READY. Order status was ${currentOrderStatusInDb}. New OrderStatus -> ${determinedNewOrderStatus}`);
                } else {
                    console.log(`[KDS SVC - OrderStatusLogic] Some items READY, but current order status ${currentOrderStatusInDb} prevents auto-move to PARTIALLY_READY. Status remains ${determinedNewOrderStatus}`);
                }
            } else if (anyPreparing) {
                 // Si alg√∫n √≠tem se est√° preparando
                if (currentOrderStatusInDb === OrderStatus.RECEIVED || currentOrderStatusInDb === OrderStatus.IN_PROGRESS || currentOrderStatusInDb === OrderStatus.PARTIALLY_READY ) {
                    determinedNewOrderStatus = OrderStatus.IN_PROGRESS;
                    console.log(`[KDS SVC - OrderStatusLogic] Some items PREPARING. Order status was ${currentOrderStatusInDb}. New OrderStatus -> ${determinedNewOrderStatus}`);
                } else {
                    console.log(`[KDS SVC - OrderStatusLogic] Some items PREPARING, but current order status ${currentOrderStatusInDb} prevents auto-move to IN_PROGRESS. Status remains ${determinedNewOrderStatus}`);
                }
            }
            // No es necesario un 'else if (allPendingKds)' porque si el pedido est√° RECEIVED y todos los √≠tems est√°n PENDING_KDS, el estado no deber√≠a cambiar.
            // Si estaba IN_PROGRESS y todos vuelven a PENDING_KDS (raro), podr√≠a volver a RECEIVED o quedarse IN_PROGRESS seg√∫n la pol√≠tica.
            // Por ahora, si no se cumplen las condiciones anteriores, se mantiene el 'determinedNewOrderStatus'
            else {
                console.log(`[KDS SVC - OrderStatusLogic] No specific aggregate condition met for active items to change OrderStatus from ${currentOrderStatusInDb}.`);
                 // Si el estado actual es RECEIVED y hay alg√∫n item que no sea PENDING_KDS (ej. PREPARING, READY), deber√≠a pasar a IN_PROGRESS o PARTIALLY_READY
                if (currentOrderStatusInDb === OrderStatus.RECEIVED && activeItems.some(it => it.status !== OrderItemStatus.PENDING_KDS) ) {
                    if (activeItems.some(it => it.status === OrderItemStatus.READY)) {
                        determinedNewOrderStatus = OrderStatus.PARTIALLY_READY;
                         console.log(`[KDS SVC - OrderStatusLogic] Order was RECEIVED, now has READY items. New OrderStatus -> ${determinedNewOrderStatus}`);
                    } else if (activeItems.some(it => it.status === OrderItemStatus.PREPARING)) {
                        determinedNewOrderStatus = OrderStatus.IN_PROGRESS;
                        console.log(`[KDS SVC - OrderStatusLogic] Order was RECEIVED, now has PREPARING items. New OrderStatus -> ${determinedNewOrderStatus}`);
                    }
                }
            }
        }

        if (currentOrderStatusInDb !== determinedNewOrderStatus) {
            // Asegurar que el determinedNewOrderStatus es uno de los valores v√°lidos del enum OrderStatus
            if (Object.values(OrderStatus).includes(determinedNewOrderStatus)) {
                 await tx.order.update({
                    where: { id: orderId },
                    data: { status: determinedNewOrderStatus }
                });
                console.log(`[KDS SVC - DB UPDATE] Order ${orderId} status was ${currentOrderStatusInDb}, NOW UPDATED to ${determinedNewOrderStatus}.`);
            } else {
                 // Esto no deber√≠a ocurrir si la l√≥gica es correcta y solo asigna valores del enum
                 console.error(`[KDS SVC - INVALID STATUS] Attempted to set invalid OrderStatus '${determinedNewOrderStatus}'. Order status REMAINS ${currentOrderStatusInDb}.`);
            }
        } else {
            console.log(`[KDS SVC - NO DB UPDATE] Order ${orderId} status REMAINS ${currentOrderStatusInDb}. (Determined new status was also: ${determinedNewOrderStatus})`);
        }
        // --- FIN L√ìGICA DE ACTUALIZACI√ìN DEL ESTADO DEL PEDIDO ---

        const finalOrderItemResult = await tx.orderItem.findUniqueOrThrow({
            where: { id: orderItemId },
            include: {
                order: true,
                menuItem: true,
                selectedModifiers: { include: { modifierOption: true }}
            }
        });
        return finalOrderItemResult;
    });
    return finalUpdatedOrderItem;
};


// ====== [40] backend/src/modules/camarero/public/OrderValidationService.ts ======
// backend/src/public/order-item-processor.service.ts
import {
    PrismaClient,
    Prisma,
    MenuItem,
    ModifierGroup,
    OrderItemStatus, // Necesario para el estado inicial del OrderItem
} from '@prisma/client';
import {
    BadRequestException,
    InternalServerErrorException,
    Logger,
    NotFoundException,
} from '@nestjs/common';

// Tipos importados de los DTOs internos (o definidos aqu√≠ si es preferible)
interface SelectedModifierOptionInternalDto {
    modifierOptionId: string;
}

interface OrderItemInternalDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: SelectedModifierOptionInternalDto[] | null;
}

// Tipos para la estructura de datos que este servicio devolver√°
// Esto es lo que se necesita para crear un OrderItem en la BD
export interface ProcessedOrderItemData {
    menuItemId: string;
    quantity: number;
    priceAtPurchase: Prisma.Decimal;
    totalItemPrice: Prisma.Decimal;
    notes?: string | null;
    kdsDestination: string | null;
    itemNameSnapshot: string; // Asumiendo que el snapshot se toma aqu√≠
    itemDescriptionSnapshot: string | null; // Asumiendo que el snapshot se toma aqu√≠
    status: OrderItemStatus; // Estado inicial
    // Datos para crear los OrderItemModifierOption asociados
    modifierOptionsToCreate: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[];
}

// Tipos internos para el manejo de modificadores (similares a los que ten√≠as)
interface SelectedModifierOptionShape {
    id: string;
    name_es: string | null;
    priceAdjustment: Prisma.Decimal;
    isAvailable: boolean;
    groupId: string; // Clave para la l√≥gica de validaci√≥n de grupos
}

type ModifierGroupWithSelectedOptions = ModifierGroup & {
    options: SelectedModifierOptionShape[];
};

// Prisma.validator para obtener MenuItem con sus modificadores y opciones activas
const menuItemWithFullModifiersArgs = Prisma.validator<Prisma.MenuItemDefaultArgs>()({
    include: {
        modifierGroups: {
            orderBy: { position: 'asc' }, // Importante para la l√≥gica de validaci√≥n si el orden importa
            include: {
                options: {
                    where: { isAvailable: true }, // Solo opciones disponibles
                    orderBy: { position: 'asc' },
                    select: { // Seleccionar solo lo necesario
                        id: true,
                        name_es: true, // Para snapshots
                        // name_en: true, // Si tuvieras i18n para snapshots
                        priceAdjustment: true,
                        isAvailable: true, // Aunque ya filtramos, es bueno tenerlo
                        groupId: true,
                    },
                },
            },
        },
    },
});
type MenuItemWithFullModifiers = Prisma.MenuItemGetPayload<typeof menuItemWithFullModifiersArgs>;


export class OrderItemProcessorService {
    private readonly logger = new Logger(OrderItemProcessorService.name);

    /**
     * Procesa una lista de √≠tems de un DTO, valida su contenido (incluyendo modificadores)
     * y calcula los precios.
     *
     * @param tx - Cliente Prisma de la transacci√≥n actual.
     * @param businessId - ID del negocio al que deben pertenecer los √≠tems.
     * @param itemsDto - Array de √≠tems tal como vienen en el payload de la orden.
     * @returns Un array de ProcessedOrderItemData, listos para ser usados en la creaci√≥n de OrderItems.
     */
    async processOrderItems(
        tx: Prisma.TransactionClient,
        businessId: string,
        itemsDto: OrderItemInternalDto[]
    ): Promise<ProcessedOrderItemData[]> {
        this.logger.log(`[OrderItemProcessor] Processing ${itemsDto.length} items for business ${businessId}`);
        const processedItems: ProcessedOrderItemData[] = [];

        for (const itemDto of itemsDto) {
            const menuItem = await this.fetchAndValidateMenuItem(tx, itemDto.menuItemId, businessId);

            const {
                itemPriceWithModifiers,
                modifierOptionsToCreateForDb,
            } = this.processModifiersForItem(menuItem, itemDto.selectedModifierOptions || []);

            const priceAtPurchase = menuItem.price.add(itemPriceWithModifiers);
            const totalItemPrice = priceAtPurchase.mul(itemDto.quantity);

            processedItems.push({
                menuItemId: menuItem.id,
                quantity: itemDto.quantity,
                priceAtPurchase,
                totalItemPrice,
                notes: itemDto.notes,
                kdsDestination: menuItem.kdsDestination,
                itemNameSnapshot: menuItem.name_es || '√çtem sin nombre ES', // Tomar snapshot del nombre
                itemDescriptionSnapshot: menuItem.description_es, // Tomar snapshot de la descripci√≥n
                status: OrderItemStatus.PENDING_KDS, // Estado inicial por defecto
                modifierOptionsToCreate: modifierOptionsToCreateForDb,
            });
        }
        this.logger.log(`[OrderItemProcessor] Finished processing ${processedItems.length} items.`);
        return processedItems;
    }

    /**
     * Obtiene y valida un MenuItem.
     */
    private async fetchAndValidateMenuItem(
        tx: Prisma.TransactionClient,
        menuItemId: string,
        businessId: string
    ): Promise<MenuItemWithFullModifiers> {
        const menuItem = await tx.menuItem.findUnique({
            where: { id: menuItemId },
            ...menuItemWithFullModifiersArgs,
        });

        if (!menuItem) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItemId}' not found.`);
            throw new NotFoundException(`√çtem de men√∫ con ID '${menuItemId}' no encontrado.`);
        }
        if (menuItem.businessId !== businessId) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItemId}' does not belong to business '${businessId}'.`);
            throw new BadRequestException(`√çtem de men√∫ con ID '${menuItemId}' no pertenece a este negocio.`);
        }
        if (!menuItem.isAvailable) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItem.name_es}' is not available.`);
            throw new BadRequestException(`El √≠tem '${menuItem.name_es || menuItemId}' no est√° disponible actualmente.`);
        }
        return menuItem;
    }

    /**
     * Procesa los modificadores seleccionados para un √≠tem de men√∫,
     * calcula el ajuste total de precio y valida las selecciones.
     */
    private processModifiersForItem(
        menuItem: MenuItemWithFullModifiers,
        selectedOptionsDto: SelectedModifierOptionInternalDto[]
    ): {
        itemPriceWithModifiers: Prisma.Decimal; // Es el total de los priceAdjustments
        modifierOptionsToCreateForDb: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[];
    } {
        let totalModifierPriceAdjustment = new Prisma.Decimal(0);
        const modifierOptionsToCreateForDb: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[] = [];
        const typedModifierGroups = menuItem.modifierGroups as ModifierGroupWithSelectedOptions[];

        // Mapear las opciones seleccionadas por el cliente a sus datos completos de la BD
        // y agruparlas por su modifierGroupId para f√°cil validaci√≥n.
        const selectedOptionsDataByGroup: Record<string, SelectedModifierOptionShape[]> = {};

        for (const selectedOptDto of selectedOptionsDto) {
            let foundOption: SelectedModifierOptionShape | undefined;
            let foundInGroup: ModifierGroupWithSelectedOptions | undefined;

            for (const group of typedModifierGroups) {
                const option = group.options.find(opt => opt.id === selectedOptDto.modifierOptionId);
                if (option) {
                    foundOption = option;
                    foundInGroup = group;
                    break;
                }
            }

            if (!foundOption || !foundInGroup) {
                this.logger.warn(`[OrderItemProcessor] Invalid or unavailable modifierOptionId '${selectedOptDto.modifierOptionId}' for MenuItem '${menuItem.id}'.`);
                throw new BadRequestException(`Opci√≥n de modificador con ID '${selectedOptDto.modifierOptionId}' no es v√°lida o no est√° disponible para el √≠tem '${menuItem.name_es}'.`);
            }
            
            if (!foundOption.groupId) { // Esto no deber√≠a pasar si el schema es correcto
                 this.logger.error(`[OrderItemProcessor] Critical: ModifierOption '${foundOption.id}' has no groupId.`);
                 throw new InternalServerErrorException(`Error de configuraci√≥n: Opci√≥n de modificador '${foundOption.id}' no tiene grupo.`);
            }

            if (!selectedOptionsDataByGroup[foundOption.groupId]) {
                selectedOptionsDataByGroup[foundOption.groupId] = [];
            }
            selectedOptionsDataByGroup[foundOption.groupId].push(foundOption);

            totalModifierPriceAdjustment = totalModifierPriceAdjustment.add(foundOption.priceAdjustment);
            modifierOptionsToCreateForDb.push({
                modifierOptionId: foundOption.id,
                optionNameSnapshot: foundOption.name_es || 'Opci√≥n sin nombre ES', // Snapshot
                optionPriceAdjustmentSnapshot: foundOption.priceAdjustment,
            });
        }

        // Validar cada grupo de modificadores del MenuItem contra las selecciones hechas
        for (const group of typedModifierGroups) {
            const selectionsInThisGroup = selectedOptionsDataByGroup[group.id] || [];
            const selectedCount = selectionsInThisGroup.length;

            if (group.isRequired && selectedCount < group.minSelections) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for group '${group.name_es}': required min ${group.minSelections}, got ${selectedCount}.`);
                throw new BadRequestException(`Para el √≠tem '${menuItem.name_es}', el grupo de modificadores '${group.name_es}' requiere al menos ${group.minSelections} selecci√≥n(es).`);
            }
            if (selectedCount > group.maxSelections) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for group '${group.name_es}': allowed max ${group.maxSelections}, got ${selectedCount}.`);
                throw new BadRequestException(`Para el √≠tem '${menuItem.name_es}', el grupo de modificadores '${group.name_es}' permite como m√°ximo ${group.maxSelections} selecci√≥n(es).`);
            }
            // Adicionalmente, si es RADIO, solo debe haber una selecci√≥n
            if (group.uiType === 'RADIO' && selectedCount > 1) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for RADIO group '${group.name_es}': got ${selectedCount} selections.`);
                throw new BadRequestException(`El grupo de modificadores '${group.name_es}' (tipo RADIO) solo permite una selecci√≥n.`);
            }
        }

        return {
            itemPriceWithModifiers: totalModifierPriceAdjustment,
            modifierOptionsToCreateForDb,
        };
    }
}


// ====== [41] backend/src/modules/camarero/public/menu.controller.ts ======
// backend/src/public/menu.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as publicMenuService from './menu.service'; // Asumimos que el servicio se llamar√° menu.service.ts en la misma carpeta

export const getPublicDigitalMenuHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessSlug } = req.params;

    if (!businessSlug || typeof businessSlug !== 'string' || businessSlug.trim() === '') {
        return res.status(400).json({ message: 'Se requiere el slug del negocio en la URL.' });
    }

    console.log(`[PublicMenu CTRL] Requesting public menu for business slug: ${businessSlug}`);

    try {
        const menuData = await publicMenuService.getPublicDigitalMenuBySlug(businessSlug.trim());

        if (!menuData) {
            // El servicio devolver√° null si el negocio no existe o el m√≥dulo camarero no est√° activo
            return res.status(404).json({ message: 'Men√∫ no encontrado o no disponible para este negocio.' });
        }

        res.status(200).json(menuData);
    } catch (error) {
        // Loguear el error en el backend para diagn√≥stico
        console.error(`[PublicMenu CTRL] Error fetching public menu for slug ${businessSlug}:`, error);
        // Pasar el error al manejador de errores global de Express
        // El manejador global puede decidir enviar una respuesta 500 gen√©rica
        // o manejar errores espec√≠ficos si los lanzamos desde el servicio.
        next(error);
    }
};


// ====== [42] backend/src/modules/camarero/public/menu.service.ts ======
// backend/src/modules/camarero/public/menu.service.ts (MODIFICADO Y COMPLETO)
import { PrismaClient, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

// Definici√≥n local de ModifierUiType
const ModifierUiTypeEnum = {
    RADIO: 'RADIO',
    CHECKBOX: 'CHECKBOX',
} as const;
type LocalModifierUiType = typeof ModifierUiTypeEnum[keyof typeof ModifierUiTypeEnum];


// --- Definici√≥n de Tipos de Salida ---
interface PublicMenuCategoryItemModifierOption {
    id: string;
    name_es: string | null;
    name_en: string | null;
    priceAdjustment: Prisma.Decimal;
    position: number;
    isDefault: boolean;
}

interface PublicMenuCategoryItemModifierGroup {
    id: string;
    name_es: string | null;
    name_en: string | null;
    uiType: LocalModifierUiType;
    minSelections: number;
    maxSelections: number;
    isRequired: boolean;
    position: number;
    options: PublicMenuCategoryItemModifierOption[];
}

interface PublicMenuCategoryItem {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    price: Prisma.Decimal;
    imageUrl: string | null;
    allergens: string[];
    tags: string[];
    position: number;
    modifierGroups: PublicMenuCategoryItemModifierGroup[];
}

interface PublicMenuCategory {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    imageUrl: string | null;
    position: number;
    items: PublicMenuCategoryItem[];
}

// --- CAMBIO: A√±adido `isCamareroActive` a la interfaz ---
interface PublicDigitalMenu {
    businessName: string;
    businessSlug: string;
    businessLogoUrl: string | null;
    isLoyaltyCoreActive: boolean;
    isCamareroActive: boolean; // <--- CAMPO A√ëADIDO
    categories: PublicMenuCategory[];
}
// --- Fin Definici√≥n de Tipos de Salida ---


export const getPublicDigitalMenuBySlug = async (businessSlug: string): Promise<PublicDigitalMenu | null> => {
    console.log(`[PublicMenu SVC] Fetching public data for business slug: ${businessSlug}`);

    try {
        // --- CAMBIO: La consulta ahora pide siempre el men√∫, pero la l√≥gica lo usar√° o no ---
        const businessWithMenu = await prisma.business.findUnique({
            where: { slug: businessSlug },
            select: {
                id: true,
                name: true,
                slug: true,
                logoUrl: true,
                isCamareroActive: true,
                isActive: true,
                isLoyaltyCoreActive: true, // <-- CAMPO YA INCLUIDO
                menuCategories: {
                    where: { isActive: true },
                    orderBy: { position: 'asc' },
                    select: {
                        id: true,
                        name_es: true,
                        name_en: true,
                        description_es: true,
                        description_en: true,
                        imageUrl: true,
                        position: true,
                        items: {
                            where: { isAvailable: true },
                            orderBy: { position: 'asc' },
                            select: {
                                id: true, name_es: true, name_en: true,
                                description_es: true, description_en: true,
                                price: true, imageUrl: true, allergens: true, tags: true,
                                position: true,
                                modifierGroups: {
                                    orderBy: { position: 'asc' },
                                    select: {
                                        id: true, name_es: true, name_en: true,
                                        uiType: true, minSelections: true, maxSelections: true,
                                        isRequired: true, position: true,
                                        options: {
                                            where: { isAvailable: true },
                                            orderBy: { position: 'asc' },
                                            select: {
                                                id: true, name_es: true, name_en: true,
                                                priceAdjustment: true, position: true, isDefault: true,
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        });

        if (!businessWithMenu || !businessWithMenu.isActive) {
            console.log(`[PublicMenu SVC] Business not found or is inactive for slug: ${businessSlug}`);
            return null;
        }
        
        // --- CAMBIO PRINCIPAL EN LA L√ìGICA DE RETORNO ---
        // Ya no devolvemos 'null' si isCamareroActive es false.
        // Construimos el objeto de respuesta y solo procesamos las categor√≠as si es necesario.

        let categoriesTyped: PublicMenuCategory[] = [];

        if (businessWithMenu.isCamareroActive) {
            // Si el m√≥dulo Camarero est√° activo, procesamos las categor√≠as como antes.
            type CategoryFromPrisma = typeof businessWithMenu.menuCategories[0];
            type ItemFromPrisma = CategoryFromPrisma['items'][0];
            type GroupFromPrisma = ItemFromPrisma['modifierGroups'][0];
            type OptionFromPrisma = GroupFromPrisma['options'][0];

            const mapCategory = (category: CategoryFromPrisma): PublicMenuCategory => ({
                id: category.id,
                name_es: category.name_es, name_en: category.name_en,
                description_es: category.description_es, description_en: category.description_en,
                imageUrl: category.imageUrl, position: category.position,
                items: category.items.map(mapItem),
            });

            const mapItem = (item: ItemFromPrisma): PublicMenuCategoryItem => ({
                id: item.id,
                name_es: item.name_es, name_en: item.name_en,
                description_es: item.description_es, description_en: item.description_en,
                price: item.price, imageUrl: item.imageUrl,
                allergens: item.allergens, tags: item.tags,
                position: item.position,
                modifierGroups: item.modifierGroups.map(mapGroup),
            });

            const mapGroup = (group: GroupFromPrisma): PublicMenuCategoryItemModifierGroup => ({
                id: group.id,
                name_es: group.name_es, name_en: group.name_en,
                uiType: group.uiType as LocalModifierUiType,
                minSelections: group.minSelections, maxSelections: group.maxSelections,
                isRequired: group.isRequired, position: group.position,
                options: group.options.map(mapOption),
            });

            const mapOption = (option: OptionFromPrisma): PublicMenuCategoryItemModifierOption => ({
                id: option.id,
                name_es: option.name_es, name_en: option.name_en,
                priceAdjustment: option.priceAdjustment,
                position: option.position, isDefault: option.isDefault,
            });

            categoriesTyped = businessWithMenu.menuCategories.map(mapCategory);
        }
        
        const menuToReturn: PublicDigitalMenu = {
            businessName: businessWithMenu.name,
            businessSlug: businessWithMenu.slug,
            businessLogoUrl: businessWithMenu.logoUrl,
            isLoyaltyCoreActive: businessWithMenu.isLoyaltyCoreActive,
            isCamareroActive: businessWithMenu.isCamareroActive, // <-- A√±adido al objeto final
            categories: categoriesTyped, // Ser√° un array vac√≠o si Camarero est√° inactivo
        };
        // --- FIN DEL CAMBIO ---

        return menuToReturn;

    } catch (error) {
        console.error(`[PublicMenu SVC] Error fetching public menu for slug ${businessSlug}:`, error);
        throw new Error('Error al obtener los datos del men√∫ desde la base de datos.');
    }
};


// ====== [43] backend/src/modules/camarero/public/order-creation.service.ts ======
// backend/src/modules/camarero/public/order-creation.service.ts
// VERSI√ìN 2.5.4 - CORRECCI√ìN DEFINITIVA DE L√ìGICA DE DESCUENTOS Y CUPONES (con logs EXTENSOS para depuraci√≥n)

import {
    PrismaClient, Prisma, Order, OrderStatus, TableStatus, RewardType, DiscountType, Reward,
} from '@prisma/client';
import {
    Injectable, Logger, NotFoundException, BadRequestException,
} from '@nestjs/common';

import { OrderItemProcessorService } from './order-item-processor.service';
import { TableService } from '../../../shared/services/table.service';
import { CreateOrderPayloadInternalDto } from './order.types';

@Injectable()
export class OrderCreationService {
    private readonly logger = new Logger(OrderCreationService.name);
    private readonly orderItemProcessorService: OrderItemProcessorService;
    private readonly tableService: TableService;
    private prisma: PrismaClient;

    constructor() {
        this.prisma = new PrismaClient();
        this.orderItemProcessorService = new OrderItemProcessorService();
        this.tableService = new TableService();
    }

    async createNewOrder(
        businessSlug: string,
        payload: CreateOrderPayloadInternalDto,
        requestingCustomerId?: string | null
    ): Promise<Order> {
        this.logger.log(`[OrderCreationService] Iniciando creaci√≥n de pedido para slug '${businessSlug}'.`);
        
        const businessContext = await this.validateBusinessForOrdering(businessSlug);
        const businessId = businessContext.id;
        const finalCustomerId = payload.customerId || requestingCustomerId;

        return this.prisma.$transaction(async (tx) => {
            this.logger.log(`[TX] Transacci√≥n de creaci√≥n de pedido iniciada para negocio ${businessId}.`);

            const processedItems = await this.orderItemProcessorService.processOrderItems(
                tx, businessId, payload.items
            );
            if (processedItems.length === 0) throw new BadRequestException('El pedido debe contener al menos un √≠tem v√°lido.');

            const subtotal = processedItems.reduce((sum, item) => sum.add(item.totalItemPrice), new Prisma.Decimal(0));
            this.logger.log(`[TX] Subtotal de √≠tems procesados: ${subtotal.toFixed(2)}.`);

            let discountAmount = new Prisma.Decimal(0);
            
            // Declarar variables en un √°mbito m√°s amplio
            let actualAppliedReward: Reward | null = null; // Recompensa REAL aplicada (del cat√°logo o v√≠a cup√≥n)
            let grantedRewardUsed: { id: string, userId: string, reward: Reward, status: string } | null = null; // Info del GrantedReward si se us√≥ un cup√≥n
            let totalPointsToDebit = 0; // Se inicializa aqu√≠ para que est√© disponible globalmente en el scope de la transacci√≥n

            // L√≥gica de recompensas y cupones
            if (finalCustomerId) {
                this.logger.log(`[TX] Cliente final identificado: ${finalCustomerId}. Procesando recompensas.`);
                const customer = await tx.user.findUnique({ where: { id: finalCustomerId }});
                if (!customer) throw new BadRequestException('El cliente asociado al pedido no existe.');
                
                // 1. Contabilizar puntos de √≠tems gratis y validar que las recompensas existen
                for (const item of processedItems) {
                    if (item.redeemedRewardId) {
                        const reward = await tx.reward.findUnique({ where: { id: item.redeemedRewardId }});
                        if (!reward || !reward.isActive || reward.type !== RewardType.MENU_ITEM) {
                            throw new BadRequestException(`La recompensa para '${item.itemNameSnapshot}' no es v√°lida o no est√° activa.`);
                        }
                        totalPointsToDebit += reward.pointsCost;
                        this.logger.log(`[TX] √çtem de recompensa (producto gratis) encontrado: '${item.itemNameSnapshot}' (ID recompensa: ${reward.id}). Puntos a debitar por este √≠tem: ${reward.pointsCost}. Total acumulado: ${totalPointsToDebit}.`);
                    }
                }

                // 2. Procesar el descuento aplicado al total (puede ser un GrantedReward o un Reward directo)
                if (payload.appliedLcoRewardId) {
                    this.logger.log(`[TX] appliedLcoRewardId en payload: ${payload.appliedLcoRewardId}.`);
                    
                    // Primero, intentar buscar si es un GrantedReward (cup√≥n ya adquirido)
                    grantedRewardUsed = await tx.grantedReward.findUnique({
                        where: { id: payload.appliedLcoRewardId },
                        include: { reward: true }
                    });

                    if (grantedRewardUsed) {
                        // Es un cup√≥n (GrantedReward)
                        this.logger.log(`[TX] ¬°GrantedReward encontrado!: ID: ${grantedRewardUsed.id}, Estatus: ${grantedRewardUsed.status}, Recompensa asociada: '${grantedRewardUsed.reward?.name_es}'.`);
                        
                        if (grantedRewardUsed.userId !== customer.id) {
                            throw new BadRequestException('Este cup√≥n no pertenece al cliente.');
                        }
                        if (grantedRewardUsed.status !== 'AVAILABLE') {
                            throw new BadRequestException(`Este cup√≥n no est√° disponible para ser usado (estatus: ${grantedRewardUsed.status}) o ya ha sido aplicado.`);
                        }
                        if (!grantedRewardUsed.reward || !grantedRewardUsed.reward.isActive || 
                            (grantedRewardUsed.reward.type !== RewardType.DISCOUNT_ON_ITEM && grantedRewardUsed.reward.type !== RewardType.DISCOUNT_ON_TOTAL)) {
                            throw new BadRequestException('La recompensa de descuento asociada a este cup√≥n no es v√°lida o no est√° activa.');
                        }
                        actualAppliedReward = grantedRewardUsed.reward; // Obtenemos la recompensa real del cup√≥n
                        this.logger.log(`[TX] Recompensa REAL para descuento (v√≠a GrantedReward): '${actualAppliedReward.name_es}'.`);

                    } else {
                        // Si no es un GrantedReward, intentar buscarlo como un Reward directo (canjeando puntos ahora)
                        this.logger.log(`[TX] No se encontr√≥ GrantedReward para ID: ${payload.appliedLcoRewardId}. Buscando como Reward directo.`);
                        const rewardDirect = await tx.reward.findUnique({ where: { id: payload.appliedLcoRewardId } });
                        if (!rewardDirect || !rewardDirect.isActive ||
                            (rewardDirect.type !== RewardType.DISCOUNT_ON_ITEM && rewardDirect.type !== RewardType.DISCOUNT_ON_TOTAL)) {
                            throw new BadRequestException('La recompensa de descuento seleccionada no es v√°lida o no est√° activa.');
                        }
                        actualAppliedReward = rewardDirect; // Es una recompensa del cat√°logo canjeada directamente
                        totalPointsToDebit += rewardDirect.pointsCost; // Debitar puntos por este canje
                        this.logger.log(`[TX] Recompensa REAL para descuento (v√≠a canje directo): '${actualAppliedReward.name_es}'. Puntos a debitar: ${rewardDirect.pointsCost}. Total acumulado: ${totalPointsToDebit}.`);
                    }
                } else {
                    this.logger.log(`[TX] No appliedLcoRewardId en payload. No se aplicar√°n descuentos generales.`);
                }

                // AHORA CALCULAMOS EL DESCUENTO FINAL BASADO EN `actualAppliedReward`
                if (actualAppliedReward) {
                    this.logger.log(`[TX] Proceso de c√°lculo de 'discountAmount' iniciado. Recompensa: '${actualAppliedReward.name_es}', Tipo: ${actualAppliedReward.type}, Tipo Descuento: ${actualAppliedReward.discountType}, Valor Descuento: ${actualAppliedReward.discountValue}.`);

                    let baseAmountForDiscount: Prisma.Decimal;

                    if (actualAppliedReward.type === RewardType.DISCOUNT_ON_ITEM) {
                        this.logger.log(`[TX] Tipo de recompensa es DISCOUNT_ON_ITEM.`);
                        if (actualAppliedReward.linkedMenuItemId) {
                            // DISCOUNT_ON_ITEM con producto vinculado: aplicar solo a ese √≠tem
                            baseAmountForDiscount = processedItems
                                .filter(item => item.menuItemId === actualAppliedReward!.linkedMenuItemId)
                                .reduce((sum, item) => sum.add(item.totalItemPrice), new Prisma.Decimal(0));
                            
                            this.logger.log(`[TX] linkedMenuItemId '${actualAppliedReward.linkedMenuItemId}' encontrado. Base de descuento (√≠tems espec√≠ficos): ${baseAmountForDiscount.toFixed(2)}.`);
                            if (baseAmountForDiscount.isZero()) {
                                this.logger.warn(`[TX] Descuento en √≠tem '${actualAppliedReward.name_es}' aplicado, pero el √≠tem vinculado NO EST√Å en el carrito. Descuento resultante: 0.`);
                            }
                        } else {
                            // DISCOUNT_ON_ITEM sin producto vinculado: aplicar al subtotal completo
                            this.logger.warn(`[TX] DISCOUNT_ON_ITEM '${actualAppliedReward.name_es}' sin linkedMenuItemId. Se aplicar√° sobre el subtotal completo: ${subtotal.toFixed(2)}.`);
                            baseAmountForDiscount = subtotal;
                        }
                    } else if (actualAppliedReward.type === RewardType.DISCOUNT_ON_TOTAL) {
                        // DISCOUNT_ON_TOTAL: aplicar al subtotal completo
                        this.logger.log(`[TX] Tipo de recompensa es DISCOUNT_ON_TOTAL. Base de descuento: ${subtotal.toFixed(2)}.`);
                        baseAmountForDiscount = subtotal;
                    } else {
                        this.logger.error(`[TX] ERROR: Tipo de recompensa inesperado para c√°lculo de descuento: ${actualAppliedReward.type}.`);
                        throw new BadRequestException('Tipo de recompensa no v√°lido para c√°lculo de descuento.');
                    }

                    if (actualAppliedReward.discountType === DiscountType.FIXED_AMOUNT && actualAppliedReward.discountValue !== null && actualAppliedReward.discountValue !== undefined) {
                        const fixedValue = new Prisma.Decimal(actualAppliedReward.discountValue);
                        discountAmount = Prisma.Decimal.min(baseAmountForDiscount, fixedValue);
                        this.logger.log(`[TX] Descuento de IMPORTE FIJO: Valor: ${fixedValue.toFixed(2)}. Descuento aplicado: ${discountAmount.toFixed(2)}.`);
                    } else if (actualAppliedReward.discountType === DiscountType.PERCENTAGE && actualAppliedReward.discountValue !== null && actualAppliedReward.discountValue !== undefined) {
                        const percentage = new Prisma.Decimal(actualAppliedReward.discountValue).div(100);
                        discountAmount = baseAmountForDiscount.mul(percentage);
                        this.logger.log(`[TX] Descuento de PORCENTAJE: Valor: ${actualAppliedReward.discountValue}%. Descuento aplicado: ${discountAmount.toFixed(2)}.`);
                    } else {
                        this.logger.error(`[TX] ERROR: Configuraci√≥n de tipo/valor de descuento inv√°lida para recompensa ${actualAppliedReward.id}.`);
                        throw new BadRequestException('Configuraci√≥n de descuento de recompensa inv√°lida.');
                    }
                    this.logger.log(`[TX] 'discountAmount' final calculado ANTES de aplicar al total del pedido: ${discountAmount.toFixed(2)}.`);
                } else {
                    this.logger.log(`[TX] No 'actualAppliedReward' determinado, 'discountAmount' permanece en 0.`);
                }

                // Debitar puntos finales (si los hay)
                if (totalPointsToDebit > 0) { 
                    if (customer.points < totalPointsToDebit) {
                        throw new BadRequestException(`Puntos insuficientes. Necesitas ${totalPointsToDebit} y tienes ${customer.points}.`);
                    }
                    await tx.user.update({
                        where: { id: customer.id },
                        data: { points: { decrement: totalPointsToDebit } }
                    });
                    this.logger.log(`[TX] Puntos debitados: ${totalPointsToDebit} del cliente ${customer.id}.`);
                }

            } else if (payload.appliedLcoRewardId || processedItems.some(i => i.redeemedRewardId)) {
                // Si se intentan usar recompensas (√≠tems gratis o descuento) pero no hay customerId
                this.logger.warn(`[TX] Intento de usar recompensas sin customerId identificado o m√≥dulo LCo activo para el negocio.`);
                throw new BadRequestException('Debes iniciar sesi√≥n para usar recompensas o el m√≥dulo de fidelizaci√≥n no est√° activo para este negocio.');
            }

            const finalAmount = subtotal.sub(discountAmount).isNegative() ? new Prisma.Decimal(0) : subtotal.sub(discountAmount);
            this.logger.log(`[TX] Subtotal: ${subtotal.toFixed(2)}, Descuento: ${discountAmount.toFixed(2)}, Monto final: ${finalAmount.toFixed(2)}.`);

            const orderNumber = await this._generateOrderNumber(tx, businessId);

            // Determinar el ID de la recompensa base a vincular al pedido (si aplica)
            let finalRewardIdToLink: string | undefined = undefined;
            if (actualAppliedReward) { // Usamos actualAppliedReward aqu√≠
                finalRewardIdToLink = actualAppliedReward.id;
                this.logger.log(`[TX] Reward ID a vincular al pedido: ${finalRewardIdToLink}.`);
            }

            const orderCreateData: Prisma.OrderCreateInput = {
                business: { connect: { id: businessId } },
                orderNumber,
                notes: payload.orderNotes,
                totalAmount: subtotal,
                discountAmount: discountAmount.toFixed(2), // Almacenar como string de 2 decimales
                finalAmount,
                status: OrderStatus.RECEIVED,
                source: finalCustomerId ? 'CUSTOMER_APP' : 'CUSTOMER_APP_ANONYMOUS',
                orderType: payload.tableIdentifier ? 'DINE_IN' : 'TAKE_AWAY', // O DELIVERY
                items: {
                    create: processedItems.map(pItem => ({
                        menuItemId: pItem.menuItemId, quantity: pItem.quantity,
                        priceAtPurchase: pItem.priceAtPurchase, totalItemPrice: pItem.totalItemPrice,
                        notes: pItem.notes, kdsDestination: pItem.kdsDestination,
                        itemNameSnapshot: pItem.itemNameSnapshot, itemDescriptionSnapshot: pItem.itemDescriptionSnapshot,
                        status: pItem.status, redeemedRewardId: pItem.redeemedRewardId,
                        ...(pItem.modifierOptionsToCreate.length > 0 && {
                            selectedModifiers: { createMany: { data: pItem.modifierOptionsToCreate } },
                        }),
                    })),
                },
                appliedLcoReward: finalRewardIdToLink ? { connect: { id: finalRewardIdToLink } } : undefined,
            };

            if (payload.tableIdentifier) {
                const table = await this.tableService.findTableByIdentifier(tx, businessId, payload.tableIdentifier);
                if (!table) throw new BadRequestException(`Mesa con identificador '${payload.tableIdentifier}' no encontrada.`);
                orderCreateData.table = { connect: { id: table.id } };
                await this.tableService.updateTableStatus(tx, table.id, TableStatus.OCCUPIED);
                this.logger.log(`[TX] Mesa ${payload.tableIdentifier} marcada como OCCUPIED.`);
            }
            if (finalCustomerId) {
                orderCreateData.customerLCo = { connect: { id: finalCustomerId } };
            }
            
            const newOrder = await tx.order.create({
                data: orderCreateData,
                include: { items: { include: { selectedModifiers: true } }, table: true },
            });
            this.logger.log(`[TX] Pedido ${newOrder.id} (N√∫mero: ${newOrder.orderNumber}) creado exitosamente.`);

            // CREACI√ìN DEL ActivityLog aqu√≠, despu√©s de que newOrder tenga su ID
            if (finalCustomerId && actualAppliedReward && (actualAppliedReward.type === RewardType.DISCOUNT_ON_ITEM || actualAppliedReward.type === RewardType.DISCOUNT_ON_TOTAL)) {
                this.logger.log(`[TX] Creando ActivityLog para descuento aplicado en pedido ${newOrder.id}.`);
                await tx.activityLog.create({
                    data: {
                        userId: finalCustomerId,
                        businessId: businessId,
                        type: 'REWARD_APPLIED_TO_ORDER', // Tipo espec√≠fico para descuentos aplicados en pedidos
                        pointsChanged: actualAppliedReward.pointsCost > 0 ? -actualAppliedReward.pointsCost : null, // Solo si se debitaron puntos por el canje directo
                        description: `Descuento: '${actualAppliedReward.name_es || actualAppliedReward.name_en}' en pedido #${newOrder.orderNumber}`,
                        relatedRewardId: actualAppliedReward.id,
                        relatedGrantedRewardId: grantedRewardUsed?.id || null, // V√≠nculo al GrantedReward si existi√≥
                        relatedOrderId: newOrder.id, // Ahora s√≠ podemos vincular el Order ID
                    }
                });
                this.logger.log(`[TX] ActivityLog creado para descuento aplicado. User: ${finalCustomerId}, Order: ${newOrder.id}.`);
            }
            
            // Si la recompensa aplicada era un GrantedReward, marcarlo como APPLIED y vincularlo al pedido
            if (grantedRewardUsed) {
                this.logger.log(`[TX] Marcando GrantedReward ${grantedRewardUsed.id} como 'APPLIED' y vincul√°ndolo al pedido ${newOrder.id}.`);
                await tx.grantedReward.update({
                    where: { id: grantedRewardUsed.id },
                    data: { status: 'APPLIED', appliedToOrderId: newOrder.id } // V√≠nculo al newOrder.id
                });
                this.logger.log(`[TX] GrantedReward ${grantedRewardUsed.id} marcado como APPLIED.`);
            }

            return newOrder;
        });
    }
    
    private async validateBusinessForOrdering(businessSlug: string) {
        const business = await this.prisma.business.findUnique({
            where: { slug: businessSlug },
            select: { id: true, isActive: true, isCamareroActive: true },
        });
        if (!business) throw new NotFoundException(`Negocio con slug '${businessSlug}' no encontrado.`);
        if (!business.isActive) throw new BadRequestException(`El negocio '${businessSlug}' no est√° activo.`);
        if (!business.isCamareroActive) throw new BadRequestException(`El m√≥dulo de pedidos no est√° activo para '${businessSlug}'.`);
        return business;
    }

    private async _generateOrderNumber(tx: Prisma.TransactionClient, businessId: string): Promise<string> {
        const orderCount = await tx.order.count({ where: { businessId: businessId } });
        const datePrefix = new Date().toISOString().slice(0, 10).replace(/-/g, '');
        return `P-${datePrefix}-${String(orderCount + 1).padStart(5, '0')}`;
    }
}


// ====== [44] backend/src/modules/camarero/public/order-item-processor.service.ts ======
// backend/src/modules/camarero/public/order-item-processor.service.ts
import {
    Prisma,
    MenuItem,
    ModifierGroup,
    OrderItemStatus,
} from '@prisma/client';
import {
    BadRequestException,
    InternalServerErrorException,
    Logger,
    NotFoundException,
} from '@nestjs/common';

// Importamos los tipos desde el archivo central
import { ProcessedOrderItemData, OrderItemInternalDto, SelectedModifierOptionInternalDto } from './order.types';

// Tipos internos para el manejo de modificadores
interface SelectedModifierOptionShape {
    id: string;
    name_es: string | null;
    priceAdjustment: Prisma.Decimal;
    isAvailable: boolean;
    groupId: string;
}

type ModifierGroupWithSelectedOptions = ModifierGroup & {
    options: SelectedModifierOptionShape[];
};

// Prisma.validator para obtener MenuItem con sus modificadores y opciones activas
const menuItemWithFullModifiersArgs = Prisma.validator<Prisma.MenuItemDefaultArgs>()({
    include: {
        modifierGroups: {
            orderBy: { position: 'asc' },
            include: {
                options: {
                    where: { isAvailable: true },
                    orderBy: { position: 'asc' },
                    select: {
                        id: true,
                        name_es: true,
                        priceAdjustment: true,
                        isAvailable: true,
                        groupId: true,
                    },
                },
            },
        },
    },
});
type MenuItemWithFullModifiers = Prisma.MenuItemGetPayload<typeof menuItemWithFullModifiersArgs>;


export class OrderItemProcessorService {
    private readonly logger = new Logger(OrderItemProcessorService.name);

    /**
     * Procesa una lista de √≠tems de un DTO, valida su contenido, calcula precios,
     * y maneja √≠tems canjeados como recompensa.
     *
     * @param tx - Cliente Prisma de la transacci√≥n actual.
     * @param businessId - ID del negocio.
     * @param itemsDto - Array de √≠tems del payload de la orden.
     * @returns Un array de ProcessedOrderItemData listos para crear OrderItems.
     */
    async processOrderItems(
        tx: Prisma.TransactionClient,
        businessId: string,
        itemsDto: OrderItemInternalDto[]
    ): Promise<ProcessedOrderItemData[]> {
        this.logger.log(`[OrderItemProcessor] Processing ${itemsDto.length} items for business ${businessId}`);
        const processedItems: ProcessedOrderItemData[] = [];

        for (const itemDto of itemsDto) {
            const menuItem = await this.fetchAndValidateMenuItem(tx, itemDto.menuItemId, businessId);

            // --- CORRECCI√ìN PRINCIPAL ---
            // Si el √≠tem viene con un ID de recompensa, lo procesamos como un √≠tem gratuito.
            if (itemDto.redeemedRewardId) {
                this.logger.log(`[OrderItemProcessor] Item '${menuItem.name_es}' is a redeemed reward (ID: ${itemDto.redeemedRewardId}). Setting price to 0.`);
                
                processedItems.push({
                    menuItemId: menuItem.id,
                    quantity: 1, // Los √≠tems de recompensa son siempre de cantidad 1
                    priceAtPurchase: new Prisma.Decimal(0),
                    totalItemPrice: new Prisma.Decimal(0),
                    notes: itemDto.notes,
                    kdsDestination: menuItem.kdsDestination,
                    itemNameSnapshot: `[RECOMPENSA] ${menuItem.name_es || '√çtem sin nombre'}`,
                    itemDescriptionSnapshot: menuItem.description_es,
                    status: OrderItemStatus.PENDING_KDS,
                    modifierOptionsToCreate: [], // Los √≠tems de recompensa no procesan modificadores
                    redeemedRewardId: itemDto.redeemedRewardId, // Pasamos el ID para guardarlo en la BD
                });

                // Saltamos al siguiente √≠tem del bucle, ya que este ya est√° procesado.
                continue;
            }
            // --- FIN DE LA CORRECCI√ìN ---

            // Si no es un √≠tem de recompensa, se procesa normalmente.
            const {
                itemPriceWithModifiers,
                modifierOptionsToCreateForDb,
            } = this.processModifiersForItem(menuItem, itemDto.selectedModifierOptions || []);

            const priceAtPurchase = menuItem.price.add(itemPriceWithModifiers);
            const totalItemPrice = priceAtPurchase.mul(itemDto.quantity);

            processedItems.push({
                menuItemId: menuItem.id,
                quantity: itemDto.quantity,
                priceAtPurchase,
                totalItemPrice,
                notes: itemDto.notes,
                kdsDestination: menuItem.kdsDestination,
                itemNameSnapshot: menuItem.name_es || '√çtem sin nombre',
                itemDescriptionSnapshot: menuItem.description_es,
                status: OrderItemStatus.PENDING_KDS,
                modifierOptionsToCreate: modifierOptionsToCreateForDb,
                redeemedRewardId: null // Aseguramos que sea null si no es recompensa
            });
        }
        this.logger.log(`[OrderItemProcessor] Finished processing ${processedItems.length} items.`);
        return processedItems;
    }

    /**
     * Obtiene y valida un MenuItem.
     */
    private async fetchAndValidateMenuItem(
        tx: Prisma.TransactionClient,
        menuItemId: string,
        businessId: string
    ): Promise<MenuItemWithFullModifiers> {
        const menuItem = await tx.menuItem.findUnique({
            where: { id: menuItemId },
            ...menuItemWithFullModifiersArgs,
        });

        if (!menuItem) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItemId}' not found.`);
            throw new NotFoundException(`√çtem de men√∫ con ID '${menuItemId}' no encontrado.`);
        }
        if (menuItem.businessId !== businessId) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItemId}' does not belong to business '${businessId}'.`);
            throw new BadRequestException(`√çtem de men√∫ con ID '${menuItem.name_es || menuItemId}' no pertenece a este negocio.`);
        }
        if (!menuItem.isAvailable) {
            this.logger.warn(`[OrderItemProcessor] MenuItem '${menuItem.name_es || menuItemId}' is not available.`);
            throw new BadRequestException(`El √≠tem '${menuItem.name_es || menuItemId}' no est√° disponible actualmente.`);
        }
        return menuItem;
    }

    /**
     * Procesa los modificadores seleccionados para un √≠tem de men√∫.
     */
    private processModifiersForItem(
        menuItem: MenuItemWithFullModifiers,
        selectedOptionsDto: SelectedModifierOptionInternalDto[]
    ): {
        itemPriceWithModifiers: Prisma.Decimal;
        modifierOptionsToCreateForDb: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[];
    } {
        let totalModifierPriceAdjustment = new Prisma.Decimal(0);
        const modifierOptionsToCreateForDb: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[] = [];
        const typedModifierGroups = menuItem.modifierGroups as ModifierGroupWithSelectedOptions[];

        const selectedOptionsDataByGroup: Record<string, SelectedModifierOptionShape[]> = {};

        for (const selectedOptDto of selectedOptionsDto) {
            let foundOption: SelectedModifierOptionShape | undefined;

            for (const group of typedModifierGroups) {
                const option = group.options.find(opt => opt.id === selectedOptDto.modifierOptionId);
                if (option) {
                    foundOption = option;
                    break;
                }
            }

            if (!foundOption) {
                this.logger.warn(`[OrderItemProcessor] Invalid or unavailable modifierOptionId '${selectedOptDto.modifierOptionId}' for MenuItem '${menuItem.id}'.`);
                throw new BadRequestException(`Opci√≥n de modificador con ID '${selectedOptDto.modifierOptionId}' no es v√°lida o no est√° disponible para el √≠tem '${menuItem.name_es}'.`);
            }
            
            if (!foundOption.groupId) {
                 this.logger.error(`[OrderItemProcessor] Critical: ModifierOption '${foundOption.id}' has no groupId.`);
                 throw new InternalServerErrorException(`Error de configuraci√≥n: Opci√≥n de modificador '${foundOption.id}' no tiene grupo.`);
            }

            if (!selectedOptionsDataByGroup[foundOption.groupId]) {
                selectedOptionsDataByGroup[foundOption.groupId] = [];
            }
            selectedOptionsDataByGroup[foundOption.groupId].push(foundOption);

            totalModifierPriceAdjustment = totalModifierPriceAdjustment.add(foundOption.priceAdjustment);
            modifierOptionsToCreateForDb.push({
                modifierOptionId: foundOption.id,
                optionNameSnapshot: foundOption.name_es || 'Opci√≥n sin nombre',
                optionPriceAdjustmentSnapshot: foundOption.priceAdjustment,
            });
        }

        for (const group of typedModifierGroups) {
            const selectionsInThisGroup = selectedOptionsDataByGroup[group.id] || [];
            const selectedCount = selectionsInThisGroup.length;

            if (group.isRequired && selectedCount < group.minSelections) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for group '${group.name_es}': required min ${group.minSelections}, got ${selectedCount}.`);
                throw new BadRequestException(`Para el √≠tem '${menuItem.name_es}', el grupo de modificadores '${group.name_es}' requiere al menos ${group.minSelections} selecci√≥n(es).`);
            }
            if (selectedCount > group.maxSelections) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for group '${group.name_es}': allowed max ${group.maxSelections}, got ${selectedCount}.`);
                throw new BadRequestException(`Para el √≠tem '${menuItem.name_es}', el grupo de modificadores '${group.name_es}' permite como m√°ximo ${group.maxSelections} selecci√≥n(es).`);
            }
            if (group.uiType === 'RADIO' && selectedCount > 1) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for RADIO group '${group.name_es}': got ${selectedCount} selections.`);
                throw new BadRequestException(`El grupo de modificadores '${group.name_es}' (tipo RADIO) solo permite una selecci√≥n.`);
            }
        }

        return {
            itemPriceWithModifiers: totalModifierPriceAdjustment,
            modifierOptionsToCreateForDb,
        };
    }
}


// ====== [45] backend/src/modules/camarero/public/order-modification.service.ts ======
// backend/src/modules/camarero/public/order-modification.service.ts
import {
    PrismaClient,
    Prisma,
    Order,
    OrderStatus,
    TableStatus,
} from '@prisma/client';
import {
    Injectable,
    Logger,
    NotFoundException,
    BadRequestException,
} from '@nestjs/common';

// --- CORRECCI√ìN: Importar ProcessedOrderItemData desde order.types.ts ---
import { OrderItemProcessorService } from './order-item-processor.service';
import { ProcessedOrderItemData } from './order.types'; // <-- Se importa desde aqu√≠
import { TableService } from '../../../shared/services/table.service';

// Importar los tipos necesarios desde el archivo centralizado
import {
    FrontendAddItemsToOrderDto,
    FrontendAddItemsOrderItemDto,
    OrderItemInternalDto,
} from './order.types';

// Interfaz BusinessContextForOrder (sin cambios)
interface BusinessContextForOrder {
    id: string;
    isActive: boolean;
    isCamareroActive: boolean;
}

@Injectable()
export class OrderModificationService {
    private readonly logger = new Logger(OrderModificationService.name);
    private readonly orderItemProcessorService: OrderItemProcessorService;
    private readonly tableService: TableService;
    private prisma: PrismaClient;

    constructor() {
        this.prisma = new PrismaClient();
        this.orderItemProcessorService = new OrderItemProcessorService();
        this.tableService = new TableService();
        this.logger.log("OrderModificationService instantiated");
    }

    async addItemsToExistingOrder(
        orderId: string,
        addItemsDto: FrontendAddItemsToOrderDto,
        businessSlug: string,
        _requestingCustomerId?: string | null
    ): Promise<Order> {
        this.logger.log(`[OrderModificationService] Attempting to add ${addItemsDto.items.length} items to order '${orderId}' for business slug '${businessSlug}'.`);

        const businessContext = await this._validateBusinessForOrdering(businessSlug);
        const businessId = businessContext.id;

        return this.prisma.$transaction(async (tx) => {
            this.logger.log(`[OrderModificationService TX] Transaction started for adding items to order '${orderId}'.`);

            const order = await tx.order.findUnique({
                where: { id: orderId },
                select: { id: true, status: true, businessId: true, totalAmount: true, finalAmount: true, notes: true, isBillRequested: true }
            });

            if (!order) {
                this.logger.warn(`[OrderModificationService TX] Order with ID '${orderId}' not found.`);
                throw new NotFoundException(`Pedido con ID '${orderId}' no encontrado.`);
            }
            if (order.businessId !== businessId) {
                this.logger.warn(`[OrderModificationService TX] Order '${orderId}' (business: ${order.businessId}) does not belong to specified business '${businessId}'.`);
                throw new BadRequestException(`El pedido no pertenece al negocio especificado.`);
            }

            const validStatusToAddItems: OrderStatus[] = [
                OrderStatus.RECEIVED, OrderStatus.IN_PROGRESS,
                OrderStatus.PARTIALLY_READY, OrderStatus.ALL_ITEMS_READY,
                OrderStatus.COMPLETED, OrderStatus.PENDING_PAYMENT,
            ];
            if (!validStatusToAddItems.includes(order.status)) {
                this.logger.warn(`[OrderModificationService TX] Cannot add items to order '${orderId}' in status '${order.status}'.`);
                throw new BadRequestException(`No se pueden a√±adir √≠tems a un pedido en estado '${order.status}'.`);
            }

            const itemsToProcessDto: OrderItemInternalDto[] = addItemsDto.items.map((item: FrontendAddItemsOrderItemDto) => ({
                menuItemId: item.menuItemId,
                quantity: item.quantity,
                notes: item.notes,
                selectedModifierOptions: item.selectedModifierOptions?.map(
                    (sm: { modifierOptionId: string }) => ({
                        modifierOptionId: sm.modifierOptionId
                    })
                ) || [],
            }));
            
            const processedNewItems: ProcessedOrderItemData[] =
                await this.orderItemProcessorService.processOrderItems(
                    tx,
                    businessId,
                    itemsToProcessDto
                );

            if (processedNewItems.length === 0 && addItemsDto.items.length === 0) {
                this.logger.warn(`[OrderModificationService TX] No new items provided in the payload to add to order '${orderId}'.`);
                throw new BadRequestException('No se proporcionaron √≠tems para a√±adir al pedido.');
            }

            const additionalAmount = processedNewItems.reduce(
                (sum, item) => sum.add(item.totalItemPrice),
                new Prisma.Decimal(0)
            );
            const newTotalAmount = new Prisma.Decimal(order.totalAmount).add(additionalAmount);
            const newFinalAmount = new Prisma.Decimal(order.finalAmount || order.totalAmount).add(additionalAmount);
            this.logger.log(`[OrderModificationService TX] Additional amount for order '${orderId}': ${additionalAmount}. New total: ${newTotalAmount}`);

            let updatedOrderNotes = order.notes;
            if (addItemsDto.customerNotes && addItemsDto.customerNotes.trim() !== '') {
                const additionNotePrefix = "Adici√≥n de √≠tems:";
                updatedOrderNotes = order.notes
                    ? `${order.notes}\n---\n${additionNotePrefix} ${addItemsDto.customerNotes.trim()}`
                    : `${additionNotePrefix} ${addItemsDto.customerNotes.trim()}`;
            }

            let newOrderStatus = order.status;
            let resetBillRequested = false;
            if (
                (order.status === OrderStatus.COMPLETED ||
                 order.status === OrderStatus.ALL_ITEMS_READY ||
                 order.status === OrderStatus.PENDING_PAYMENT) &&
                processedNewItems.length > 0
            ) {
                newOrderStatus = OrderStatus.IN_PROGRESS;
                this.logger.log(`[OrderModificationService TX] Order '${orderId}' was '${order.status}', new items added. Changing status to '${newOrderStatus}'.`);
                if (order.status === OrderStatus.PENDING_PAYMENT && order.isBillRequested) {
                    resetBillRequested = true;
                    this.logger.log(`[OrderModificationService TX] Bill was requested for order '${orderId}', resetting flag.`);
                }
            }

            const orderUpdateData: Prisma.OrderUpdateInput = {
                items: {
                    create: processedNewItems.map(pItem => ({
                        menuItemId: pItem.menuItemId,
                        quantity: pItem.quantity,
                        priceAtPurchase: pItem.priceAtPurchase,
                        totalItemPrice: pItem.totalItemPrice,
                        notes: pItem.notes,
                        kdsDestination: pItem.kdsDestination,
                        itemNameSnapshot: pItem.itemNameSnapshot,
                        itemDescriptionSnapshot: pItem.itemDescriptionSnapshot,
                        status: pItem.status,
                        ...(pItem.modifierOptionsToCreate.length > 0 && {
                            selectedModifiers: { createMany: { data: pItem.modifierOptionsToCreate } },
                        }),
                    })),
                },
                totalAmount: newTotalAmount,
                finalAmount: newFinalAmount,
                notes: updatedOrderNotes,
                status: newOrderStatus,
            };

            if (resetBillRequested) {
                orderUpdateData.isBillRequested = false;
            }

            const updatedOrder = await tx.order.update({
                where: { id: orderId },
                data: orderUpdateData,
                include: { items: { include: { selectedModifiers: true } }, table: true },
            });

            this.logger.log(`[OrderModificationService TX] Items successfully added to order '${orderId}'. New total: ${updatedOrder.totalAmount}. New status: ${updatedOrder.status}`);
            return updatedOrder;
        });
    }

    private async _validateBusinessForOrdering(businessSlug: string) {
        const business = await this.prisma.business.findUnique({
            where: { slug: businessSlug },
            select: { id: true, isActive: true, isCamareroActive: true },
        });

        if (!business) {
            this.logger.warn(`[OrderModificationService] Business with slug '${businessSlug}' not found.`);
            throw new NotFoundException(`Negocio con slug '${businessSlug}' no encontrado.`);
        }
        if (!business.isActive) {
            this.logger.warn(`[OrderModificationService] Business '${businessSlug}' is not active.`);
            throw new BadRequestException(`El negocio '${businessSlug}' no est√° activo y no puede procesar pedidos.`);
        }
        if (!business.isCamareroActive) {
            this.logger.warn(`[OrderModificationService] Camarero module not active for business '${businessSlug}'.`);
            throw new BadRequestException(`El m√≥dulo de pedidos (Camarero) no est√° activo para el negocio '${businessSlug}'.`);
        }
        this.logger.log(`[OrderModificationService] Business '${businessSlug}' validated for ordering. ID: ${business.id}`);
        return business;
    }
}


// ====== [46] backend/src/modules/camarero/public/order-payment.service.ts ======
// backend/src/modules/camarero/public/order-payment.service.ts
import {
    PrismaClient,
    Prisma,
    Order,
    OrderStatus,
    TableStatus,
    User,
    Business,
    ActivityType,
    TierBenefit,
    GrantedRewardStatus,
} from '@prisma/client';
import {
    Injectable,
    Logger,
    NotFoundException,
    BadRequestException,
    ForbiddenException,
    InternalServerErrorException,
} from '@nestjs/common';

import { TableService } from '../../../shared/services/table.service';
import { LoyaltyPointsService } from '../../../shared/services/loyalty-points.service';
import { updateUserTier } from '../../../modules/loyalpyme/tiers/tier-logic.service';

type OrderForLoyalty = Pick<Order, 'id' | 'orderNumber' | 'finalAmount' | 'totalAmount' | 'customerLCoId' | 'businessId'>;
type CustomerForLoyalty = User & {
    currentTier?: ({ benefits: Pick<TierBenefit, 'type' | 'value' | 'isActive'>[] } & { id: string; name: string }) | null;
};
type BusinessForLoyalty = Pick<Business, 'id' | 'pointsPerEuro' | 'isLoyaltyCoreActive'>;

@Injectable()
export class OrderPaymentService {
    private readonly logger = new Logger(OrderPaymentService.name);
    private readonly tableService: TableService;
    private readonly loyaltyPointsService: LoyaltyPointsService;
    private prisma: PrismaClient;

    constructor() {
        this.prisma = new PrismaClient();
        this.tableService = new TableService();
        this.loyaltyPointsService = new LoyaltyPointsService();
        this.logger.log("OrderPaymentService instantiated");
    }

    async requestBillForClient(
        orderId: string,
        paymentPreference?: string | null
    ): Promise<Order> {
        this.logger.log(`[OrderPaymentService] Client requesting bill for order '${orderId}'. Preference: ${paymentPreference || 'N/A'}`);
        return this.prisma.$transaction(async (tx) => {
            const order = await tx.order.findUnique({
                where: { id: orderId },
                select: { id: true, status: true, businessId: true, tableId: true, orderNumber: true },
            });
            if (!order) {
                this.logger.warn(`[OrderPaymentService TX] Order '${orderId}' not found for client bill request.`);
                throw new NotFoundException(`Pedido con ID '${orderId}' no encontrado.`);
            }
            const allowedStates: OrderStatus[] = [
                OrderStatus.RECEIVED, OrderStatus.IN_PROGRESS,
                OrderStatus.PARTIALLY_READY, OrderStatus.ALL_ITEMS_READY,
                OrderStatus.COMPLETED,
            ];
            if (!allowedStates.includes(order.status)) {
                this.logger.warn(`[OrderPaymentService TX] Cannot request bill for order '${orderId}' in status '${order.status}'.`);
                throw new BadRequestException(`No se puede solicitar la cuenta para un pedido en estado '${order.status}'.`);
            }
            const updateData: Prisma.OrderUpdateInput = {
                status: OrderStatus.PENDING_PAYMENT,
                isBillRequested: true,
            };
            if (paymentPreference !== undefined) {
                updateData.paymentMethodPreference = paymentPreference;
            }
            const updatedOrder = await tx.order.update({
                where: { id: orderId },
                data: updateData,
            });
            this.logger.log(`[OrderPaymentService TX] Order '${orderId}' status set to PENDING_PAYMENT by client request.`);
            if (order.tableId && order.businessId) {
                try {
                    await this.tableService.updateTableStatus(tx, order.tableId, TableStatus.PENDING_PAYMENT_TABLE);
                    this.logger.log(`[OrderPaymentService TX] Table ID '${order.tableId}' status updated to PENDING_PAYMENT_TABLE.`);
                } catch (tableError) {
                    this.logger.error(`[OrderPaymentService TX] Failed to update table status for table '${order.tableId}' during client bill request. Continuing. Error:`, tableError);
                }
            }
            return updatedOrder;
        });
    }

    async markOrderAsPaid(
        orderId: string,
        paidByStaffId: string,
        businessId: string,
        paymentDetails?: { method?: string; notes?: string }
    ): Promise<Order> {
        this.logger.log(`[OrderPaymentService] Staff '${paidByStaffId}' attempting to mark order '${orderId}' as PAID for business '${businessId}'. Payment method: ${paymentDetails?.method || 'N/A'}`);
        return this.prisma.$transaction(async (tx) => {
            const order = await tx.order.findUnique({
                where: { id: orderId },
                include: {
                    business: { select: { id: true, isLoyaltyCoreActive: true, pointsPerEuro: true } },
                    table: { select: { id: true, status: true } },
                    customerLCo: {
                        include: {
                            currentTier: {
                                include: {
                                    benefits: { where: { isActive: true, type: 'POINTS_MULTIPLIER' } }
                                }
                            }
                        }
                    }
                }
            });
            if (!order) {
                this.logger.warn(`[OrderPaymentService TX] Order '${orderId}' not found.`);
                throw new NotFoundException(`Pedido con ID '${orderId}' no encontrado.`);
            }
            if (order.businessId !== businessId) {
                this.logger.warn(`[OrderPaymentService TX] Order '${orderId}' (business: ${order.businessId}) does not belong to staff's business '${businessId}'.`);
                throw new ForbiddenException("El pedido no pertenece al negocio del personal.");
            }
            if (order.status !== OrderStatus.PENDING_PAYMENT && order.status !== OrderStatus.COMPLETED) {
                this.logger.warn(`[OrderPaymentService TX] Cannot mark order '${orderId}' as PAID. Current status: '${order.status}'.`);
                throw new BadRequestException(`Solo se pueden marcar como pagados pedidos en estado 'PENDING_PAYMENT' o 'COMPLETED'. Estado actual: ${order.status}`);
            }
            const updatedOrder = await tx.order.update({
                where: { id: orderId },
                data: {
                    status: OrderStatus.PAID,
                    paidAt: new Date(),
                    paidByUserId: paidByStaffId,
                    paymentMethodUsed: paymentDetails?.method,
                },
            });
            this.logger.log(`[OrderPaymentService TX] Order '${orderId}' status updated to PAID.`);
            if (order.tableId && order.table && order.table.status !== TableStatus.AVAILABLE) {
                await this.tableService.updateTableStatus(tx, order.tableId, TableStatus.AVAILABLE);
                this.logger.log(`[OrderPaymentService TX] Table ID '${order.tableId}' status updated to AVAILABLE.`);
            }
            if (order.customerLCoId && order.business?.isLoyaltyCoreActive && order.customerLCo) {
                const loyaltyResult = await this.loyaltyPointsService.awardPointsForLcOrder(
                    tx,
                    order as OrderForLoyalty,
                    order.customerLCo as CustomerForLoyalty,
                    order.business as BusinessForLoyalty
                );
                if (loyaltyResult) {
                    this.logger.log(`[OrderPaymentService TX] Loyalty points awarded: ${loyaltyResult.pointsAwarded} for order '${orderId}'.`);
                } else {
                    this.logger.warn(`[OrderPaymentService TX] Loyalty points awarding process for order '${orderId}' returned null (possibly skipped or failed internally).`);
                }
            } else {
                if (order.customerLCoId) {
                    this.logger.log(`[OrderPaymentService TX] LCo module not active for business '${order.businessId}' or customer data missing. Skipping LCo points for order '${order.id}'.`);
                }
            }
            return updatedOrder;
        });
    }

    async applyRewardToOrder(
        orderId: string,
        grantedRewardId: string,
        customerId: string
    ): Promise<Order> {
        this.logger.log(`[OrderPaymentService] Customer ${customerId} applying coupon ${grantedRewardId} to order ${orderId}`);

        return this.prisma.$transaction(async (tx) => {
            const coupon = await tx.grantedReward.findUnique({
                where: { id: grantedRewardId },
                include: { reward: true },
            });

            if (!coupon) throw new NotFoundException(`El cup√≥n con ID ${grantedRewardId} no existe.`);
            if (coupon.userId !== customerId) throw new ForbiddenException('Este cup√≥n no pertenece al usuario actual.');
            if (coupon.status !== GrantedRewardStatus.AVAILABLE) throw new BadRequestException(`Este cup√≥n no est√° disponible para ser usado (Estado: ${coupon.status}).`);
            if (!coupon.reward) throw new InternalServerErrorException('El cup√≥n no tiene una recompensa asociada.');

            const order = await tx.order.findUnique({ where: { id: orderId } });

            if (!order) throw new NotFoundException(`El pedido con ID ${orderId} no fue encontrado.`);
            if (order.customerLCoId !== customerId) throw new ForbiddenException('Este pedido no pertenece al usuario actual.');
            if (order.status !== OrderStatus.PENDING_PAYMENT) throw new BadRequestException(`Solo se pueden aplicar recompensas a pedidos pendientes de pago.`);
            if (order.appliedLcoRewardId) throw new BadRequestException('Ya se ha aplicado otra recompensa a este pedido.');

            const { discountType, discountValue } = coupon.reward;
            let discountAmount = new Prisma.Decimal(0);

            if (discountType === 'FIXED_AMOUNT' && discountValue) {
                discountAmount = new Prisma.Decimal(discountValue);
            } else if (discountType === 'PERCENTAGE' && discountValue) {
                const percentage = new Prisma.Decimal(discountValue).div(100);
                discountAmount = new Prisma.Decimal(order.totalAmount).mul(percentage);
            }

            if (discountAmount.isZero()) throw new BadRequestException('El valor de la recompensa es cero y no se puede aplicar.');
            
            // --- CORRECCI√ìN DEFINITIVA ---
            const finalAmountDecimal = new Prisma.Decimal(order.finalAmount ?? 0);
            const newFinalAmount = Prisma.Decimal.max(0, finalAmountDecimal.sub(discountAmount));
            const currentDiscount = new Prisma.Decimal(order.discountAmount ?? 0);
            
            const updatedOrder = await tx.order.update({
                where: { id: orderId },
                data: {
                    finalAmount: newFinalAmount,
                    discountAmount: currentDiscount.add(discountAmount),
                    appliedLcoRewardId: coupon.rewardId,
                },
            });
            // --- FIN DE LA CORRECCI√ìN ---

            this.logger.log(`[OrderPaymentService TX] Order ${orderId} updated. New finalAmount: ${newFinalAmount}`);

            await tx.grantedReward.update({
                where: { id: grantedRewardId },
                data: { status: GrantedRewardStatus.APPLIED, appliedToOrderId: orderId },
            });
            this.logger.log(`[OrderPaymentService TX] Coupon ${grantedRewardId} status updated to APPLIED.`);
            
            await tx.activityLog.create({
                data: {
                    userId: customerId,
                    businessId: order.businessId,
                    type: ActivityType.REWARD_APPLIED_TO_ORDER,
                    description: `Has usado '${coupon.reward.name_es}' en el pedido #${order.orderNumber}`,
                    relatedRewardId: coupon.rewardId,
                    relatedOrderId: orderId,
                    relatedGrantedRewardId: grantedRewardId
                }
            });
             this.logger.log(`[OrderPaymentService TX] Activity log created for reward application.`);

            return updatedOrder;
        });
    }
}


// ====== [47] backend/src/modules/camarero/public/order.controller.ts ======
// backend/src/modules/camarero/public/order.controller.ts
import { Request as ExpressRequest, Response as ExpressResponse, NextFunction } from 'express';
import { Order } from '@prisma/client';
import { plainToInstance } from 'class-transformer';
import { validate } from 'class-validator';

// Importaciones de DTOs y Tipos (no cambian)
import { CreateOrderDto, AddItemsToOrderDto, RequestBillClientPayloadDto, ApplyRewardDto } from './order.dto';
import { CreateOrderPayloadInternalDto, PublicOrderStatusInfo } from './order.types';

// Importaciones de Servicios (no cambian)
import { OrderService } from './order.service';
import { OrderCreationService } from './order-creation.service';
import { OrderModificationService } from './order-modification.service';
import { OrderPaymentService } from './order-payment.service';

// Instancias de servicios (no cambian)
const orderServiceInstance = new OrderService();
const orderCreationServiceInstance = new OrderCreationService();
const orderModificationServiceInstance = new OrderModificationService();
const orderPaymentServiceInstance = new OrderPaymentService();

// --- Handlers de Express (La parte que realmente se est√° usando) ---

export const createPublicOrderHandler = async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
    try {
        const businessSlug = req.params.businessSlug;
        if (!businessSlug) {
            return res.status(400).json({ message: 'Business slug es requerido en la ruta.' });
        }
        
        // 1. Convertir el cuerpo de la petici√≥n a una instancia de nuestro DTO
        const createOrderDto = plainToInstance(CreateOrderDto, req.body);
        
        // 2. Validar la instancia del DTO
        const validationErrors = await validate(createOrderDto, { whitelist: true, forbidNonWhitelisted: true });
        if (validationErrors.length > 0) {
            // --- MEJORA: Devolver un error m√°s detallado ---
            console.error('[OrderCtrl createPublic] DTO validation errors:', JSON.stringify(validationErrors, null, 2));
            // Formateamos los errores para que sean m√°s √∫tiles en el frontend
            const formattedErrors = validationErrors.map(err => ({
                property: err.property,
                constraints: err.constraints,
                children: err.children?.map(child => ({ // Mostrar errores anidados
                    property: child.property,
                    constraints: child.constraints,
                }))
            })).flat();
            return res.status(400).json({ message: 'Error de validaci√≥n en los datos del pedido.', errors: formattedErrors });
            // --- FIN MEJORA ---
        }

        // 3. Mapear al payload interno del servicio
        const requestingCustomerId = (req as any).user?.id || createOrderDto.customerId;
        const servicePayload: CreateOrderPayloadInternalDto = {
            tableIdentifier: createOrderDto.tableIdentifier,
            orderNotes: createOrderDto.customerNotes,
            customerId: requestingCustomerId,
            items: createOrderDto.items.map(item => ({
                menuItemId: item.menuItemId,
                quantity: item.quantity,
                notes: item.notes,
                selectedModifierOptions: item.selectedModifierOptions?.map(mod => ({ modifierOptionId: mod.modifierOptionId })) || [],
                redeemedRewardId: item.redeemedRewardId,
            })),
            appliedLcoRewardId: createOrderDto.appliedLcoRewardId
        };

        // 4. Llamar al servicio
        const newOrder: Order = await orderCreationServiceInstance.createNewOrder(
            businessSlug,
            servicePayload,
            requestingCustomerId
        );
        res.status(201).json(newOrder);

    } catch (error) {
        next(error); // Pasar a manejador de errores global
    }
};

// ... El resto de los handlers siguen una estructura similar y se benefician de las correcciones en DTOs y servicios.
// No requieren cambios funcionales directos, as√≠ que los mantengo como estaban.

export const addItemsToExistingOrderHandler = async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
    try {
        const { orderId } = req.params;
        const businessSlugFromHeader = req.headers['x-loyalpyme-business-slug'] as string;

        if (!orderId) return res.status(400).json({ message: 'Order ID es requerido.' });
        if (!businessSlugFromHeader) return res.status(400).json({ message: 'Contexto de Business Slug (x-loyalpyme-business-slug header) es requerido.' });
        
        const addItemsToOrderDto = plainToInstance(AddItemsToOrderDto, req.body);
        const validationErrors = await validate(addItemsToOrderDto, { whitelist: true, forbidNonWhitelisted: true });
        if (validationErrors.length > 0) {
            console.error('[OrderCtrl addItems] DTO validation errors:', JSON.stringify(validationErrors, null, 2));
            const formattedErrors = validationErrors.map(err => ({ property: err.property, constraints: err.constraints }));
            return res.status(400).json({ message: 'Error de validaci√≥n al a√±adir √≠tems.', errors: formattedErrors });
        }

        const updatedOrder: Order = await orderModificationServiceInstance.addItemsToExistingOrder(
            orderId,
            addItemsToOrderDto,
            businessSlugFromHeader,
            (req as any).user?.id
        );
        res.status(200).json(updatedOrder);
    } catch (error) {
        next(error);
    }
};

export const getPublicOrderStatusHandler = async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
    try {
        const { orderId } = req.params;
        if (!orderId) {
            return res.status(400).json({ message: 'Order ID es requerido.' });
        }
        const statusInfo: PublicOrderStatusInfo | null = await orderServiceInstance.getOrderStatus(orderId);
        if (!statusInfo) {
            return res.status(404).json({ message: `Pedido con ID ${orderId} no encontrado.` });
        }
        res.status(200).json(statusInfo);
    } catch (error) {
        next(error);
    }
};

export const requestBillByClientHandler = async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
    try {
        const { orderId } = req.params;
        if (!orderId) {
            return res.status(400).json({ message: "Falta el ID del pedido (orderId) en la URL." });
        }
        
        const requestBillDto = plainToInstance(RequestBillClientPayloadDto, req.body || {});
        const validationErrors = await validate(requestBillDto);
        if (validationErrors.length > 0) {
            return res.status(400).json({ message: 'Datos inv√°lidos para solicitar la cuenta.', errors: validationErrors });
        }

        const updatedOrder: Order = await orderPaymentServiceInstance.requestBillForClient(orderId, requestBillDto.paymentPreference);
        res.status(200).json({
            message: `Cuenta solicitada para el pedido #${updatedOrder.orderNumber}. Estado: ${updatedOrder.status}.`,
            order: { id: updatedOrder.id, orderNumber: updatedOrder.orderNumber, status: updatedOrder.status, isBillRequested: updatedOrder.isBillRequested }
        });
    } catch (error) {
        next(error);
    }
};

export const applyRewardHandler = async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
    try {
        const { orderId } = req.params;
        const customerId = (req as any).user?.id;
        if (!customerId) {
            return res.status(401).json({ message: 'Se requiere autenticaci√≥n de cliente para aplicar una recompensa.' });
        }

        const applyRewardDto = plainToInstance(ApplyRewardDto, req.body);
        const validationErrors = await validate(applyRewardDto);
        if (validationErrors.length > 0) {
            return res.status(400).json({ message: 'Datos para aplicar recompensa son inv√°lidos.', errors: validationErrors });
        }

        const updatedOrder = await orderPaymentServiceInstance.applyRewardToOrder(orderId, applyRewardDto.grantedRewardId, customerId);
        res.status(200).json({ message: 'Recompensa aplicada con √©xito.', order: updatedOrder });
    } catch (error) {
        next(error);
    }
};


// ====== [48] backend/src/modules/camarero/public/order.dto.ts ======
// backend/src/modules/camarero/public/order.dto.ts
import { Type } from 'class-transformer';
import {
  IsArray,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
  IsUUID,
  Min,
  ValidateNested,
} from 'class-validator';

// DTO para cada opci√≥n de modificador seleccionada
export class SelectedOrderModifierOptionDto {
  // --- CORRECCI√ìN FINAL ---
  // Cambiado de @IsUUID a @IsString porque el ID de ModifierOption en Prisma es un cuid(), no un uuid().
  @IsString({ message: 'El ID de la opci√≥n de modificador debe ser un string v√°lido.'})
  @IsNotEmpty({ message: 'El ID de la opci√≥n de modificador no puede estar vac√≠o.'})
  modifierOptionId!: string;
}

// DTO para cada √≠tem de pedido en la creaci√≥n
export class CreateOrderItemDto {
  @IsUUID('4', { message: 'El ID del art√≠culo del men√∫ debe ser un UUID v√°lido.' })
  @IsNotEmpty({ message: 'El ID del art√≠culo del men√∫ no puede estar vac√≠o.' })
  menuItemId!: string;

  @IsNumber({}, { message: 'La cantidad debe ser un n√∫mero.' })
  @Min(1, { message: 'La cantidad debe ser como m√≠nimo 1.' })
  quantity!: number;

  @IsOptional()
  @IsString()
  notes?: string;

  @IsOptional()
  @IsArray({ message: 'Los modificadores seleccionados deben ser un array.' })
  @ValidateNested({ each: true })
  @Type(() => SelectedOrderModifierOptionDto)
  selectedModifierOptions?: SelectedOrderModifierOptionDto[];

  @IsOptional()
  @IsString()
  redeemedRewardId?: string | null;
}

// DTO principal para crear un pedido
export class CreateOrderDto {
  @IsOptional()
  @IsString()
  businessId?: string; // Aunque no se usa directamente, lo mantenemos por si acaso

  @IsString({ message: 'El identificador de mesa debe ser texto.' })
  @IsOptional()
  tableIdentifier?: string;

  @IsArray({ message: 'Los √≠tems deben ser un array.' })
  @ValidateNested({ each: true, message: 'Cada √≠tem debe ser v√°lido.' })
  @Type(() => CreateOrderItemDto)
  items!: CreateOrderItemDto[];

  @IsString({ message: 'Las notas del cliente deben ser texto.' })
  @IsOptional()
  customerNotes?: string;

  @IsString()
  @IsOptional()
  customerId?: string;
  
  @IsOptional()
  @IsString() // El ID de la recompensa es un CUID (string)
  appliedLcoRewardId?: string | null;
}

// DTOs para A√ëADIR √≠tems a un pedido existente
export class AddItemsOrderItemDto {
    @IsUUID('4', { message: 'El ID del art√≠culo del men√∫ debe ser un UUID v√°lido.' })
    @IsNotEmpty({ message: 'El ID del art√≠culo del men√∫ no puede estar vac√≠o.' })
    menuItemId!: string;

    @IsNumber({}, { message: 'La cantidad debe ser un n√∫mero.' })
    @Min(1, { message: 'La cantidad debe ser como m√≠nimo 1.' })
    quantity!: number;

    @IsOptional()
    @IsString()
    notes?: string;
    
    @IsOptional()
    @IsArray({ message: 'Los modificadores seleccionados deben ser un array.' })
    @ValidateNested({ each: true })
    @Type(() => SelectedOrderModifierOptionDto)
    selectedModifierOptions?: SelectedOrderModifierOptionDto[];

    @IsOptional()
    @IsString()
    redeemedRewardId?: string | null;
}

export class AddItemsToOrderDto {
    @IsArray({ message: 'Los √≠tems deben ser un array.' })
    @ValidateNested({ each: true, message: 'Cada √≠tem debe ser v√°lido.' })
    @Type(() => AddItemsOrderItemDto)
    items!: AddItemsOrderItemDto[];

    @IsString({ message: 'Las notas del cliente deben ser texto.' })
    @IsOptional()
    customerNotes?: string;

    @IsOptional()
    @IsString()
    appliedLcoRewardId?: string | null;
}

// DTO para solicitar la cuenta
export class RequestBillClientPayloadDto {
  @IsOptional()
  @IsString({ message: 'La preferencia de pago debe ser texto.' })
  paymentPreference?: string;
}

// DTO para aplicar una recompensa a un pedido.
export class ApplyRewardDto {
    @IsString()
    @IsNotEmpty({ message: 'Se requiere el ID del cup√≥n (grantedRewardId).' })
    grantedRewardId!: string;
}


// ====== [49] backend/src/modules/camarero/public/order.service.ts ======
// backend/src/modules/camarero/public/order.service.ts
// Versi√≥n 2.2.0 - Aligned with corrected order.types.ts

import {
    Injectable,
    Logger,
} from '@nestjs/common';
import {
    PrismaClient,
    Order,
    Prisma,
} from '@prisma/client';

// Importar los servicios que hacen el trabajo pesado
import { OrderCreationService } from './order-creation.service';
import { OrderModificationService } from './order-modification.service';
import { OrderPaymentService } from './order-payment.service';

// Importar los tipos necesarios desde el archivo centralizado
import {
    CreateOrderPayloadInternalDto,
    PublicOrderStatusInfo,
    FrontendAddItemsToOrderDto,
} from './order.types';

@Injectable()
export class OrderService {
    private readonly logger = new Logger(OrderService.name);

    private readonly orderCreationService: OrderCreationService;
    private readonly orderModificationService: OrderModificationService;
    private readonly orderPaymentService: OrderPaymentService;
    private readonly prisma: PrismaClient;

    constructor() {
        this.orderCreationService = new OrderCreationService();
        this.orderModificationService = new OrderModificationService();
        this.orderPaymentService = new OrderPaymentService();
        this.prisma = new PrismaClient();
        this.logger.log("OrderService (Public Orchestrator) instantiated");
    }

    // --- M√âTODOS DE ORQUESTACI√ìN (sin cambios) ---
    async createOrder(businessSlug: string, payload: CreateOrderPayloadInternalDto, requestingCustomerId?: string | null): Promise<Order> {
        this.logger.log(`[OrderService -> Create] Orchestrating new order for business slug '${businessSlug}'.`);
        return this.orderCreationService.createNewOrder(businessSlug, payload, requestingCustomerId);
    }
    async addItemsToOrder(orderId: string, addItemsDto: FrontendAddItemsToOrderDto, businessSlug: string, requestingCustomerId?: string | null): Promise<Order> {
        this.logger.log(`[OrderService -> AddItems] Orchestrating add items to order '${orderId}' for business slug '${businessSlug}'.`);
        return this.orderModificationService.addItemsToExistingOrder(orderId, addItemsDto, businessSlug, requestingCustomerId);
    }
    async requestBillForClient(orderId: string, paymentPreference?: string | null): Promise<Order> {
        this.logger.log(`[OrderService -> RequestBillClient] Orchestrating client bill request for order '${orderId}'.`);
        return this.orderPaymentService.requestBillForClient(orderId, paymentPreference);
    }
    async markOrderAsPaid(orderId: string, paidByStaffId: string, businessId: string, paymentDetails?: { method?: string; notes?: string }): Promise<Order> {
        this.logger.log(`[OrderService -> MarkPaid] Orchestrating mark order '${orderId}' as PAID by staff '${paidByStaffId}'.`);
        return this.orderPaymentService.markOrderAsPaid(orderId, paidByStaffId, businessId, paymentDetails);
    }
    // --- FIN M√âTODOS DE ORQUESTACI√ìN ---

    /**
     * Obtiene la informaci√≥n p√∫blica del estado de un pedido, convirtiendo los datos
     * al formato esperado por la interfaz `PublicOrderStatusInfo`.
     */
    async getOrderStatus(orderId: string): Promise<PublicOrderStatusInfo | null> {
        this.logger.log(`[OrderService -> GetStatus] Fetching public status for order '${orderId}'.`);
        try {
            const order = await this.prisma.order.findUnique({
                where: { id: orderId },
                select: {
                    id: true, orderNumber: true, status: true, notes: true, createdAt: true,
                    isBillRequested: true, totalAmount: true, discountAmount: true, finalAmount: true,
                    table: { select: { identifier: true } },
                    items: {
                        where: { status: { not: 'CANCELLED' } },
                        select: {
                            id: true,
                            // --- CORRECCI√ìN 1: Seleccionar el campo `itemNameSnapshot` ---
                            itemNameSnapshot: true,
                            quantity: true, status: true, priceAtPurchase: true, totalItemPrice: true,
                            selectedModifiers: {
                                select: {
                                    optionNameSnapshot: true,
                                    optionPriceAdjustmentSnapshot: true,
                                },
                            },
                        },
                        orderBy: { createdAt: 'asc' },
                    },
                },
            });

            if (!order) {
                this.logger.warn(`[OrderService getOrderStatus] Pedido con ID ${orderId} no encontrado.`);
                return null;
            }

            // --- CORRECCI√ìN 2: Mapeo expl√≠cito y conversi√≥n de tipos ---
            const responseData: PublicOrderStatusInfo = {
                orderId: order.id,
                orderNumber: order.orderNumber,
                orderStatus: order.status,
                items: order.items.map(item => ({
                    id: item.id,
                    // Asignar el snapshot al campo correcto de la interfaz
                    itemNameSnapshot: item.itemNameSnapshot,
                    quantity: item.quantity,
                    status: item.status,
                    // Convertir de Decimal a number
                    priceAtPurchase: item.priceAtPurchase.toNumber(),
                    totalItemPrice: item.totalItemPrice.toNumber(),
                    selectedModifiers: item.selectedModifiers.map(mod => ({
                        optionNameSnapshot: mod.optionNameSnapshot,
                        // Convertir Decimal | null a number, usando 0 como fallback
                        optionPriceAdjustmentSnapshot: mod.optionPriceAdjustmentSnapshot?.toNumber() ?? 0
                    }))
                })),
                tableIdentifier: order.table?.identifier,
                orderNotes: order.notes,
                createdAt: order.createdAt,
                isBillRequested: order.isBillRequested,
                // Convertir Decimal a number
                totalAmount: order.totalAmount.toNumber(),
                discountAmount: order.discountAmount?.toNumber() ?? null,
                // Usar fallback si finalAmount es null y luego convertir a number
                finalAmount: (order.finalAmount ?? order.totalAmount).toNumber(),
            };

            return responseData;

        } catch (error) {
            this.logger.error(`[OrderService -> GetStatus] Error fetching status for order '${orderId}':`, error);
            throw error;
        }
    }
}


// ====== [50] backend/src/modules/camarero/public/order.types.ts ======
// backend/src/modules/camarero/public/order.types.ts
import { OrderStatus, OrderItemStatus, Prisma } from '@prisma/client';

// --- DTOs y Tipos para la L√≥gica Interna (Sin cambios) ---

export interface SelectedModifierOptionInternalDto {
    modifierOptionId: string;
}
export interface OrderItemInternalDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: SelectedModifierOptionInternalDto[] | null;
    redeemedRewardId?: string | null;
}
export interface CreateOrderPayloadInternalDto {
    tableIdentifier?: string | null;
    customerId?: string | null;
    orderNotes?: string | null;
    items: OrderItemInternalDto[];
    appliedLcoRewardId?: string | null;
}
export interface ProcessedOrderItemData {
    menuItemId: string;
    quantity: number;
    priceAtPurchase: Prisma.Decimal;
    totalItemPrice: Prisma.Decimal;
    notes?: string | null;
    kdsDestination: string | null;
    itemNameSnapshot: string;
    itemDescriptionSnapshot: string | null;
    status: OrderItemStatus;
    modifierOptionsToCreate: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[];
    redeemedRewardId?: string | null;
}


// --- Estructuras para la Respuesta P√∫blica del Estado del Pedido (CORREGIDAS) ---

export interface PublicModifierStatusInfo {
    optionNameSnapshot: string | null;
    // --- CORRECCI√ìN: Permitir que sea null y usar `number` para el frontend ---
    optionPriceAdjustmentSnapshot: number; 
}

export interface PublicOrderItemStatusInfo {
    id: string;
    // --- CORRECCI√ìN: Cambiar a `itemNameSnapshot` para que coincida con la consulta ---
    itemNameSnapshot: string | null; 
    quantity: number;
    status: OrderItemStatus;
    // --- CORRECCI√ìN: Usar `number` para que el JSON sea consistente ---
    priceAtPurchase: number;
    totalItemPrice: number;
    selectedModifiers: PublicModifierStatusInfo[];
}

export interface PublicOrderStatusInfo {
    orderId: string;
    orderNumber: string;
    orderStatus: OrderStatus;
    items: PublicOrderItemStatusInfo[];
    tableIdentifier?: string | null;
    orderNotes?: string | null;
    createdAt: Date; // Usar Date, JSON.stringify lo convertir√° a string ISO
    isBillRequested?: boolean;
    // --- CORRECCI√ìN: Usar `number` para el JSON ---
    totalAmount: number;
    discountAmount: number | null;
    finalAmount: number; // El frontend espera un n√∫mero
}


// --- DTOs que representan los payloads esperados desde el Frontend/Controlador (Sin cambios) ---

export interface FrontendSelectedOrderModifierOptionDto {
    modifierOptionId: string;
}

export interface FrontendCreateOrderItemDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: FrontendSelectedOrderModifierOptionDto[] | null;
    redeemedRewardId?: string | null;
}

export interface FrontendCreateOrderDto {
    tableIdentifier?: string | null;
    customerNotes?: string | null;
    customerId?: string | null;
    items: FrontendCreateOrderItemDto[];
    appliedLcoRewardId?: string | null;
}

// --- Tipos para A√ëADIR items (corregidos para claridad) ---
export interface FrontendAddItemsOrderItemDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: Array<{ modifierOptionId: string }>;
    redeemedRewardId?: string | null;
}

export interface FrontendAddItemsToOrderDto {
    items: FrontendAddItemsOrderItemDto[];
    customerNotes?: string;
    appliedLcoRewardId?: string | null;
}
// --- Fin tipos para a√±adir ---


export interface FrontendRequestBillClientPayloadDto {
  paymentPreference?: string | null;
}

export interface FrontendRequestBillStaffPayloadDto {
  paymentPreference?: string | null;
}

export interface FrontendMarkOrderAsPaidPayloadDto {
  method?: string;
  notes?: string | null;
}


// ====== [51] backend/src/modules/camarero/waiter.controller.ts ======
// backend/src/camarero/waiter.controller.ts
// Version 1.3.1 (Adjusted for waiter.service v1.3.0 and simplified markAsPaid response)

import { Request, Response, NextFunction } from 'express';
import { OrderItemStatus, Order, OrderStatus, Prisma, OrderItem } from '@prisma/client';

// Importar el servicio de camarero existente
import * as waiterService from './waiter.service'; // Asume que waiter.service.ts est√° en la misma carpeta
// Importar el OrderPaymentService para marcar como pagado
import { OrderPaymentService } from './public/order-payment.service';

// DTOs y tipos
import {
    MarkOrderItemServedPayloadDto,
    OrderItemStatusUpdateResponseDto,
} from './camarero.dto';
import { FrontendMarkOrderAsPaidPayloadDto, FrontendRequestBillStaffPayloadDto } from './public/order.types';

// Instanciar OrderPaymentService
const orderPaymentServiceInstance = new OrderPaymentService();

/**
 * Handler para GET /api/camarero/staff/ready-for-pickup
 */
export const getReadyForPickupItemsHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    if (!businessId) {
        console.error("[WaiterCtrl] Critical: businessId missing from req.user in getReadyForPickupItemsHandler.");
        return res.status(403).json({ message: "Identificador de negocio no encontrado en la sesi√≥n del usuario." });
    }
    console.log(`[WaiterCtrl] Request for ready-for-pickup items for business: ${businessId}`);
    try {
        const items = await waiterService.getReadyForPickupItems(businessId);
        res.status(200).json(items);
    } catch (error) {
        console.error(`[WaiterCtrl] Error getting ready-for-pickup items for business ${businessId}:`, error);
        next(error);
    }
};

/**
 * Handler para PATCH /api/camarero/staff/order-items/:orderItemId/status
 * Marca un OrderItem como SERVED.
 */
export const markOrderItemServedHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const waiterUserId = req.user?.id;
    const { orderItemId } = req.params;
    const payload: MarkOrderItemServedPayloadDto = req.body;

    if (!businessId || !waiterUserId) {
        console.error("[WaiterCtrl] Critical: businessId or waiterUserId missing for markOrderItemServedHandler.");
        return res.status(403).json({ message: "Informaci√≥n de autenticaci√≥n de personal incompleta." });
    }
    if (!orderItemId) {
        return res.status(400).json({ message: "Falta el ID del √≠tem de pedido (orderItemId) en la URL." });
    }
    if (!payload || payload.newStatus !== OrderItemStatus.SERVED) {
        return res.status(400).json({ message: "Payload inv√°lido. Se esperaba que 'newStatus' sea 'SERVED'." });
    }

    console.log(`[WaiterCtrl] Request to mark OrderItem ${orderItemId} as SERVED by waiter ${waiterUserId} for business ${businessId}.`);

    try {
        // Asumimos que waiterService.markOrderItemAsServed ahora devuelve { updatedOrderItem, finalOrderStatus }
        const result = await waiterService.markOrderItemAsServed(
            orderItemId,
            businessId,
            waiterUserId
        );

        const responseDto: OrderItemStatusUpdateResponseDto = {
            message: `√çtem '${result.updatedOrderItem.itemNameSnapshot || orderItemId}' marcado como ${OrderItemStatus.SERVED}.`,
            orderItemId: result.updatedOrderItem.id,
            newStatus: result.updatedOrderItem.status,
            orderStatus: result.finalOrderStatus, // Usar el estado del pedido devuelto por el servicio
        };
        res.status(200).json(responseDto);

    } catch (error: any) {
        console.error(`[WaiterCtrl] Error marking OrderItem ${orderItemId} as SERVED:`, error);
        if (error.message) {
            if (error.message.includes('no encontrado') || (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025')) {
                return res.status(404).json({ message: error.message });
            }
            if (error.message.includes('no est√° en estado \'READY\'') || error.message.includes('Transici√≥n de estado no permitida')) {
                return res.status(409).json({ message: `Conflicto de estado: ${error.message}` });
            }
        }
        next(error);
    }
};

/**
 * Handler para POST /api/camarero/staff/order/:orderId/request-bill
 */
export const requestBillByStaffHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const staffUserId = req.user?.id;
    const { orderId } = req.params;
    const payload: FrontendRequestBillStaffPayloadDto = req.body;

    if (!businessId || !staffUserId) {
        console.error("[WaiterCtrl] Critical: businessId or staffUserId missing for requestBillByStaffHandler.");
        return res.status(403).json({ message: "Informaci√≥n de autenticaci√≥n de personal incompleta." });
    }
    if (!orderId) {
        return res.status(400).json({ message: "Falta el ID del pedido (orderId) en la URL." });
    }

    console.log(`[WaiterCtrl] Staff ${staffUserId} requesting bill for order ${orderId}. Preference: ${payload.paymentPreference || 'N/A'}`);
    try {
        const paymentPreferenceForService = payload.paymentPreference ?? undefined;

        // Podr√≠amos decidir que waiterService.requestBillByStaff llame internamente a OrderPaymentService
        // o hacer la llamada a OrderPaymentService aqu√≠ directamente.
        // Por consistencia con markOrderAsPaid, si el servicio de pago centraliza, lo llamar√≠amos aqu√≠.
        // Por ahora, seguimos con la estructura donde WaiterService lo maneja.
        const updatedOrder: Order = await waiterService.requestBillByStaff(
            orderId,
            staffUserId,
            businessId,
            paymentPreferenceForService
        );
        res.status(200).json({
            message: `Cuenta solicitada para el pedido #${updatedOrder.orderNumber}. Estado: ${updatedOrder.status}.`,
            order: {
                id: updatedOrder.id,
                orderNumber: updatedOrder.orderNumber,
                status: updatedOrder.status,
                isBillRequested: updatedOrder.isBillRequested,
                paymentMethodPreference: updatedOrder.paymentMethodPreference,
            }
        });
    } catch (error: any) {
        console.error(`[WaiterCtrl] Error requesting bill for order ${orderId} by staff ${staffUserId}:`, error);
        if (error.message) {
            if (error.message.includes('no encontrado') || (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025')) {
                return res.status(404).json({ message: error.message });
            }
            if (error.message.includes('No se puede solicitar la cuenta') || error.message.includes('estado inv√°lido')) {
                return res.status(400).json({ message: error.message });
            }
            if (error.message.includes('no pertenece al negocio')) {
                return res.status(403).json({ message: error.message });
            }
        }
        next(error);
    }
};

/**
 * Handler para POST /api/camarero/staff/order/:orderId/mark-as-paid
 */
export const markOrderAsPaidHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const staffUserId = req.user?.id;
    const { orderId } = req.params;
    const payloadFromFrontend: FrontendMarkOrderAsPaidPayloadDto = req.body;

    if (!businessId || !staffUserId) {
        console.error("[WaiterCtrl] Critical: businessId or staffUserId missing for markOrderAsPaidHandler.");
        return res.status(403).json({ message: "Informaci√≥n de autenticaci√≥n de personal incompleta." });
    }
    if (!orderId) {
        return res.status(400).json({ message: "Falta el ID del pedido (orderId) en la URL." });
    }

    const paymentDetailsForService: { method?: string; notes?: string } = {
        method: payloadFromFrontend.method,
        notes: payloadFromFrontend.notes ?? undefined,
    };

    console.log(`[WaiterCtrl] Staff ${staffUserId} marking order ${orderId} as PAID. Payment Details: ${JSON.stringify(paymentDetailsForService)}`);

    try {
        const updatedOrder: Order = await orderPaymentServiceInstance.markOrderAsPaid(
            orderId,
            staffUserId,
            businessId,
            paymentDetailsForService
        );

        // Respuesta simplificada. El frontend puede hacer un refetch de la lista de pedidos
        // o del estado de la mesa si necesita la info actualizada inmediatamente.
        res.status(200).json({
            message: `Pedido #${updatedOrder.orderNumber || orderId} marcado como PAGADO.`,
            order: { // Devolver la informaci√≥n esencial del pedido actualizado
                id: updatedOrder.id,
                orderNumber: updatedOrder.orderNumber,
                status: updatedOrder.status,
                paidAt: updatedOrder.paidAt,
                paymentMethodUsed: updatedOrder.paymentMethodUsed,
                tableId: updatedOrder.tableId, // Enviar tableId para que el frontend sepa si debe refetchear mesas
            }
        });

    } catch (error: any) {
        console.error(`[WaiterCtrl] Error marking order ${orderId} as PAID by staff ${staffUserId}:`, error);
        // El tipo de error de NestJS (error.name) podr√≠a no estar disponible si no se est√° ejecutando en un contexto NestJS puro
        // Usaremos instanceof para los errores de Prisma y mensajes para el resto
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             return res.status(404).json({ message: 'Pedido no encontrado.' });
        }
        if (error.message?.includes('no encontrado')) {
             return res.status(404).json({ message: error.message });
        }
        if (error.message?.includes('Solo se pueden marcar como pagados') || error.message?.includes('estado inv√°lido')) {
            return res.status(400).json({ message: error.message });
        }
        if (error.message?.includes('no pertenece al negocio')) {
            return res.status(403).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para GET /api/camarero/staff/orders
 */
export const getStaffOrdersHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    if (!businessId) {
        console.error("[WaiterCtrl] Critical: businessId missing from req.user in getStaffOrdersHandler.");
        return res.status(403).json({ message: "Identificador de negocio no encontrado en la sesi√≥n del usuario." });
    }
    const statusQuery = req.query.status as string | string[] | undefined;
    let statusFilter: OrderStatus[] | undefined = undefined;
    if (statusQuery) {
        const statuses = Array.isArray(statusQuery) ? statusQuery : (typeof statusQuery === 'string' ? statusQuery.split(',') : []);
        statusFilter = statuses
            .map(s => s.trim().toUpperCase() as OrderStatus)
            .filter(s => Object.values(OrderStatus).includes(s));
        if (statusFilter.length === 0) {
            statusFilter = undefined;
        }
    }
    console.log(`[WaiterCtrl] Request for staff orders for business: ${businessId}. Filters: ${JSON.stringify({ status: statusFilter })}`);
    try {
        const orders = await waiterService.getOrdersForStaff(businessId, { status: statusFilter });
        res.status(200).json(orders);
    } catch (error: any) {
        console.error(`[WaiterCtrl] Error fetching staff orders for business ${businessId}:`, error);
        next(error);
    }
};


// ====== [52] backend/src/modules/camarero/waiter.service.ts ======
// backend/src/camarero/waiter.service.ts
// Version 1.3.1 (Corrected orderBy clause in getOrdersForStaff)

import {
    PrismaClient,
    OrderItem,
    OrderItemStatus,
    OrderStatus,
    Prisma,
    TableStatus,
    Order,
    OrderType,
    User, // Asegurarse de importar User si se usa en tipos
} from '@prisma/client';
import {
    ReadyPickupItemDto,
    WaiterSelectedModifierDto,
    WaiterOrderListItemDto
} from './camarero.dto';
import {
    NotFoundException,
    BadRequestException,
    ForbiddenException,
    Logger,
    InternalServerErrorException,
} from '@nestjs/common';

const prisma = new PrismaClient(); // Instancia de Prisma para este servicio
const logger = new Logger('WaiterService'); // Logger para este servicio

/**
 * Obtiene la lista de √≠tems de pedido que est√°n listos para ser recogidos por el personal de sala.
 * @param businessId - ID del negocio.
 * @returns Un array de ReadyPickupItemDto.
 */
export const getReadyForPickupItems = async (businessId: string): Promise<ReadyPickupItemDto[]> => {
    logger.log(`[WaiterService] Fetching items ready for pickup for business: ${businessId}`);
    try {
        const orderItemsFromDb = await prisma.orderItem.findMany({
            where: {
                status: OrderItemStatus.READY,
                order: {
                    businessId: businessId,
                    status: {
                        in: [
                            OrderStatus.IN_PROGRESS,
                            OrderStatus.PARTIALLY_READY,
                            OrderStatus.ALL_ITEMS_READY,
                        ],
                    },
                },
            },
            include: {
                order: {
                    include: {
                        table: { select: { identifier: true } },
                    },
                },
                selectedModifiers: {
                    select: {
                        optionNameSnapshot: true,
                        modifierOption: {
                            select: { name_en: true, name_es: true }
                        }
                    },
                },
            },
            orderBy: [
                { order: { createdAt: 'asc' } },
                { createdAt: 'asc' }
            ]
        });

        const readyItemsDto: ReadyPickupItemDto[] = orderItemsFromDb.map(item => {
            const selectedModifiersDto: WaiterSelectedModifierDto[] = item.selectedModifiers.map(sm => {
                return {
                    optionName_es: sm.optionNameSnapshot || sm.modifierOption?.name_es || null,
                    optionName_en: sm.modifierOption?.name_en || null,
                };
            });

            return {
                orderItemId: item.id,
                orderId: item.orderId,
                orderNumber: item.order.orderNumber,
                orderCreatedAt: item.order.createdAt,
                tableIdentifier: item.order.table?.identifier || null,
                itemNameSnapshot_es: item.itemNameSnapshot,
                itemNameSnapshot_en: null, // Ajustar si tienes snapshot_en
                quantity: item.quantity,
                itemNotes: item.notes,
                kdsDestination: item.kdsDestination,
                selectedModifiers: selectedModifiersDto,
                currentOrderItemStatus: item.status,
            };
        });

        logger.log(`[WaiterService] Found ${readyItemsDto.length} items ready for pickup for business ${businessId}.`);
        return readyItemsDto;

    } catch (error) {
        logger.error(`[WaiterService] Error fetching 'ready for pickup' items for business ${businessId}:`, error);
        throw new InternalServerErrorException('Error al obtener los √≠tems listos para servir desde la base de datos.');
    }
};

export interface MarkServedResult {
    updatedOrderItem: OrderItem;
    finalOrderStatus: OrderStatus;
}

export const markOrderItemAsServed = async (
    orderItemId: string,
    businessId: string,
    waiterUserId?: string
): Promise<MarkServedResult> => {
    logger.log(`[WaiterService] Attempting to mark OrderItem ${orderItemId} as SERVED by waiter ${waiterUserId || 'unknown'} for business ${businessId}.`);

    return prisma.$transaction(async (tx) => {
        const orderItem = await tx.orderItem.findFirst({
            where: {
                id: orderItemId,
                order: { businessId: businessId }
            },
            include: {
                order: {
                    select: { id: true, status: true }
                }
            }
        });

        if (!orderItem) {
            logger.warn(`[WaiterService TX] OrderItem '${orderItemId}' not found or not in business '${businessId}'.`);
            throw new NotFoundException(`√çtem de pedido con ID ${orderItemId} no encontrado o no pertenece a este negocio.`);
        }
        if (!orderItem.order) {
            logger.error(`[WaiterService TX] Critical: OrderItem '${orderItemId}' has no associated order.`);
            throw new InternalServerErrorException(`Error interno: El √≠tem de pedido ${orderItemId} no est√° asociado a ning√∫n pedido.`);
        }

        if (orderItem.status !== OrderItemStatus.READY) {
            logger.warn(`[WaiterService TX] OrderItem '${orderItemId}' is in status '${orderItem.status}', not 'READY'. Cannot mark as served.`);
            throw new BadRequestException(`El √≠tem de pedido '${orderItem.itemNameSnapshot || orderItemId}' no est√° en estado 'READY'. Estado actual: ${orderItem.status}. No se puede marcar como servido.`);
        }

        const dataToUpdateOrderItem: Prisma.OrderItemUpdateArgs['data'] = {
            status: OrderItemStatus.SERVED,
            servedAt: new Date(),
        };
        if (waiterUserId) {
            dataToUpdateOrderItem.servedById = waiterUserId;
        }

        const updatedOrderItem = await tx.orderItem.update({
            where: { id: orderItemId },
            data: dataToUpdateOrderItem,
        });
        logger.log(`[WaiterService TX] OrderItem ${orderItemId} marked as SERVED in DB.`);

        const orderId = orderItem.order.id;
        const allItemsInThisOrder = await tx.orderItem.findMany({
            where: { orderId: orderId },
            select: { status: true }
        });

        const activeItems = allItemsInThisOrder.filter(item => item.status !== OrderItemStatus.CANCELLED);
        let newOrderStatusForParent: OrderStatus = orderItem.order.status;

        if (activeItems.length > 0 && activeItems.every(item => item.status === OrderItemStatus.SERVED)) {
            if (
                orderItem.order.status !== OrderStatus.PAID &&
                orderItem.order.status !== OrderStatus.CANCELLED &&
                orderItem.order.status !== OrderStatus.COMPLETED
            ) {
                newOrderStatusForParent = OrderStatus.COMPLETED;
                await tx.order.update({
                    where: { id: orderId },
                    data: { status: newOrderStatusForParent }
                });
                logger.log(`[WaiterService TX] Order ${orderId} status updated to COMPLETED as all active items are SERVED.`);
            } else {
                 logger.log(`[WaiterService TX] Order ${orderId} already in final/completed state (${orderItem.order.status}). Not changing to COMPLETED.`);
            }
        } else if (activeItems.length === 0 && allItemsInThisOrder.length > 0) {
             if (orderItem.order.status !== OrderStatus.CANCELLED && orderItem.order.status !== OrderStatus.PAID) {
                newOrderStatusForParent = OrderStatus.CANCELLED;
                await tx.order.update({
                    where: { id: orderId },
                    data: { status: newOrderStatusForParent }
                });
                logger.log(`[WaiterService TX] Order ${orderId} status updated to CANCELLED as all items were cancelled.`);
            }
        } else {
            logger.log(`[WaiterService TX] Order ${orderId} still has items not SERVED or no active items. Order status remains ${newOrderStatusForParent}.`);
        }
        return { updatedOrderItem, finalOrderStatus: newOrderStatusForParent };
    });
};

export const requestBillByStaff = async (
    orderId: string,
    staffUserId: string,
    businessId: string,
    paymentPreference?: string | undefined
): Promise<Order> => {
    logger.log(`[WaiterService] Staff ${staffUserId} requesting bill for order ${orderId} in business ${businessId}. Preference: ${paymentPreference || 'N/A'}`);

    return prisma.$transaction(async (tx) => {
        const order = await tx.order.findUnique({
            where: { id: orderId },
            select: { id: true, status: true, businessId: true, tableId: true, orderNumber: true }
        });

        if (!order) {
            throw new NotFoundException(`Pedido con ID ${orderId} no encontrado.`);
        }
        if (order.businessId !== businessId) {
            throw new ForbiddenException("El pedido no pertenece al negocio del personal.");
        }

        const allowedStates: OrderStatus[] = [
            OrderStatus.RECEIVED, OrderStatus.IN_PROGRESS, OrderStatus.PARTIALLY_READY,
            OrderStatus.ALL_ITEMS_READY, OrderStatus.COMPLETED,
        ];
        if (!allowedStates.includes(order.status)) {
            throw new BadRequestException(`No se puede solicitar la cuenta para un pedido en estado '${order.status}'.`);
        }

        const updateData: Prisma.OrderUpdateInput = {
            status: OrderStatus.PENDING_PAYMENT,
            isBillRequested: true,
            ...(paymentPreference !== undefined && { paymentMethodPreference: paymentPreference }),
        };

        const updatedOrder = await tx.order.update({ where: { id: orderId }, data: updateData });
        logger.log(`[WaiterService TX] Bill requested by staff ${staffUserId} for order ${orderId}. Status set to PENDING_PAYMENT.`);

        if (order.tableId) {
            try {
                await tx.table.update({
                    where: { id: order.tableId },
                    data: { status: TableStatus.PENDING_PAYMENT_TABLE }
                });
                logger.log(`[WaiterService TX] Table ID '${order.tableId}' status updated to PENDING_PAYMENT_TABLE.`);
            } catch (tableError) {
                logger.error(`[WaiterService TX] Failed to update table status for table '${order.tableId}' on staff bill request. Continuing. Error:`, tableError);
            }
        }
        return updatedOrder;
    });
};

export const getOrdersForStaff = async (
    businessId: string,
    filters?: { status?: OrderStatus[] }
): Promise<WaiterOrderListItemDto[]> => {
    logger.log(`[WaiterService] Fetching orders for staff UI. Business: ${businessId}, Filters: ${JSON.stringify(filters)}`);

    const whereClause: Prisma.OrderWhereInput = {
        businessId: businessId,
    };

    if (filters?.status && filters.status.length > 0) {
        whereClause.status = { in: filters.status };
    } else {
        whereClause.status = {
            in: [
                OrderStatus.PENDING_PAYMENT, OrderStatus.COMPLETED,
                OrderStatus.ALL_ITEMS_READY, OrderStatus.PARTIALLY_READY,
                OrderStatus.IN_PROGRESS, OrderStatus.RECEIVED
            ]
        };
    }

    try {
        const ordersFromDb = await prisma.order.findMany({
            where: whereClause,
            select: {
                id: true,
                orderNumber: true,
                table: { select: { identifier: true } },
                status: true,
                finalAmount: true,
                totalAmount: true,
                items: {
                    where: { status: { not: OrderItemStatus.CANCELLED } },
                    select: { quantity: true }
                },
                customerLCo: { select: { name: true, email: true } },
                createdAt: true,
                isBillRequested: true,
                orderType: true,
            },
            // --- CORRECCI√ìN APLICADA ---
            orderBy: [
                { status: 'asc' },    // Primer criterio de ordenaci√≥n
                { createdAt: 'asc' }  // Segundo criterio de ordenaci√≥n
            ]
            // --- FIN CORRECCI√ìN ---
        });

        const orderListItems: WaiterOrderListItemDto[] = ordersFromDb.map(order => {
            const itemCount = order.items.reduce((sum, item) => sum + item.quantity, 0);
            let customerDisplayName: string | null = null;
            if (order.customerLCo) {
                customerDisplayName = order.customerLCo.name || order.customerLCo.email;
            }

            return {
                orderId: order.id,
                orderNumber: order.orderNumber,
                tableIdentifier: order.table?.identifier || null,
                status: order.status,
                finalAmount: (order.finalAmount ?? order.totalAmount).toNumber(),
                itemCount: itemCount,
                customerName: customerDisplayName,
                createdAt: order.createdAt,
                isBillRequested: order.isBillRequested,
                orderType: order.orderType as OrderType | null, // Casteo al enum local si es necesario
            };
        });

        logger.log(`[WaiterService] Found ${orderListItems.length} orders for staff UI for business ${businessId}.`);
        return orderListItems;

    } catch (error) {
        logger.error(`[WaiterService] Error fetching orders for staff UI (Business: ${businessId}):`, error);
        if (error instanceof Prisma.PrismaClientValidationError) {
            logger.error("[WaiterService] Prisma Client Validation Error details:", error.message);
            throw new InternalServerErrorException(`Error de validaci√≥n de Prisma al obtener pedidos: ${error.message}`);
        }
        throw new InternalServerErrorException('Error al obtener la lista de pedidos para el personal.');
    }
};

// (No se necesita exportar `prisma` si el controlador no lo usa directamente)


// ====== [53] backend/src/modules/loyalpyme/activity/activity.controller.ts ======
// filename: backend/src/activity/activity.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as activityService from './activity.service'; // Importar el servicio

/**
 * Handler para obtener el historial de actividad paginado del cliente autenticado.
 * GET / (montado bajo /api/customer/activity)
 */
export const getCustomerActivityHandler = async (req: Request, res: Response, next: NextFunction) => {
    // El userId viene de req.user a√±adido por authenticateToken
    const userId = req.user?.id;

    if (!userId) {
        // Esto no deber√≠a ocurrir si el middleware funciona, pero es una guarda
        return res.status(401).json({ message: 'Usuario no autenticado.' });
    }

    // Obtener par√°metros de paginaci√≥n de la query string, con valores por defecto
    const pageQuery = req.query.page as string | undefined;
    const limitQuery = req.query.limit as string | undefined;

    const page = parseInt(pageQuery || '1', 10);
    const limit = parseInt(limitQuery || '15', 10); // Default 15 items por p√°gina

    // Validar que sean n√∫meros v√°lidos
    if (isNaN(page) || page < 1) {
        return res.status(400).json({ message: 'Par√°metro "page" inv√°lido. Debe ser un n√∫mero mayor o igual a 1.' });
    }
    if (isNaN(limit) || limit < 1 || limit > 100) { // Limitar el m√°ximo por petici√≥n
        return res.status(400).json({ message: 'Par√°metro "limit" inv√°lido. Debe ser un n√∫mero entre 1 y 100.' });
    }

    console.log(`[Activity CTRL] Request received for user ${userId} activity. Page: ${page}, Limit: ${limit}`);

    try {
        const paginatedResult = await activityService.getCustomerActivityLog(userId, page, limit);
        res.status(200).json(paginatedResult);
    } catch (error) {
        // Pasar el error al manejador global de errores
        next(error);
    }
};


// ====== [54] backend/src/modules/loyalpyme/activity/activity.service.ts ======
// filename: backend/src/activity/activity.service.ts
import { PrismaClient, ActivityLog, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

// Tipo para la respuesta paginada
export interface PaginatedActivityLog {
    logs: Pick<ActivityLog, 'id' | 'type' | 'pointsChanged' | 'description' | 'createdAt'>[]; // Devolvemos solo campos necesarios
    totalPages: number;
    currentPage: number;
    totalItems: number;
}

/**
 * Obtiene el historial de actividad paginado para un usuario espec√≠fico.
 * @param userId ID del usuario.
 * @param page N√∫mero de p√°gina solicitada.
 * @param limit N√∫mero de items por p√°gina.
 * @returns Objeto con los logs paginados y metadatos de paginaci√≥n.
 */
export const getCustomerActivityLog = async (
    userId: string,
    page: number,
    limit: number
): Promise<PaginatedActivityLog> => {
    console.log(`[Activity SVC] Fetching activity log for user ${userId}, Page: ${page}, Limit: ${limit}`);

    const skip = (page - 1) * limit;

    try {
        // Usar transacci√≥n para obtener count y logs en una sola llamada a DB
        const [totalItems, logs] = await prisma.$transaction([
            prisma.activityLog.count({
                where: { userId: userId },
            }),
            prisma.activityLog.findMany({
                where: { userId: userId },
                select: { // Seleccionar solo los campos que necesita el frontend
                    id: true,
                    type: true,
                    pointsChanged: true,
                    description: true,
                    createdAt: true,
                },
                orderBy: {
                    createdAt: 'desc', // M√°s recientes primero
                },
                skip: skip,
                take: limit,
            }),
        ]);

        const totalPages = Math.ceil(totalItems / limit);
        console.log(`[Activity SVC] Found ${logs.length} logs on page ${page}. Total items: ${totalItems}, Total pages: ${totalPages}`);

        return {
            logs,
            totalPages,
            currentPage: page,
            totalItems,
        };

    } catch (error) {
        console.error(`[Activity SVC] Error fetching activity log for user ${userId}:`, error);
        // Podr√≠amos relanzar un error m√°s espec√≠fico si quisi√©ramos
        throw new Error('Error al obtener el historial de actividad desde la base de datos.');
    }
};


// ====== [55] backend/src/modules/loyalpyme/admin/admin-customer-bulk.controller.ts ======
// filename: backend/src/admin/admin-customer-bulk.controller.ts
// Version: 1.0.0 (Handlers extracted from admin-customer.controller, @ts-ignore removed, cleaned)

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client'; // Para tipos de error

// Importar solo los servicios necesarios para acciones masivas
import {
    bulkUpdateStatusForCustomers,
    bulkDeleteCustomers,
    bulkAdjustPointsForCustomers
} from './admin-customer-bulk.service'; // Ajustado a la nueva ubicaci√≥n del servicio

/**
 * Handler para actualizar estado activo/inactivo masivo.
 * PATCH /api/admin/customers/bulk-status
 */
export const bulkUpdateCustomerStatusHandler = async (req: Request, res: Response, next: NextFunction) => {
    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_BULK_CTRL] Critical: User or businessId missing in bulkUpdateCustomerStatusHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    const { customerIds, isActive } = req.body;
    console.log(`[ADM_CUST_BULK_CTRL] Request for bulk status update to ${isActive} for customers [${customerIds?.join(', ')}] by admin from business ${adminBusinessId}`);

    // Validaciones
    if (!adminBusinessId) { return res.status(403).json({ message: "Informaci√≥n de administrador no disponible." }); } // Doble check por si acaso
    if (!Array.isArray(customerIds) || customerIds.length === 0) { return res.status(400).json({ message: "Se requiere un array 'customerIds' con al menos un ID de cliente." }); }
    if (typeof isActive !== 'boolean') { return res.status(400).json({ message: "Se requiere el campo 'isActive' (true o false) para indicar el estado deseado." }); }
    if (!customerIds.every(id => typeof id === 'string')) { return res.status(400).json({ message: "Todos los elementos en 'customerIds' deben ser strings." }); }

    try {
        const result = await bulkUpdateStatusForCustomers(customerIds, adminBusinessId, isActive);
        res.status(200).json({ message: `Estado actualizado a ${isActive ? 'Activo' : 'Inactivo'} para ${result.count} cliente(s).`, count: result.count }); // Corregido: cliente(s)
    } catch (error) {
        console.error(`[ADM_CUST_BULK_CTRL] Failed bulk status update for customers [${customerIds.join(', ')}]:`, error);
        next(error);
    }
};

/**
 * Handler para eliminar m√∫ltiples clientes.
 * DELETE /api/admin/customers/bulk-delete
 */
export const bulkDeleteCustomersHandler = async (req: Request, res: Response, next: NextFunction) => {
     // --- FIX: Comprobaci√≥n expl√≠cita ---
     if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_BULK_CTRL] Critical: User or businessId missing in bulkDeleteCustomersHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    const { customerIds } = req.body; // Los IDs vienen en el body para DELETE masivo
    console.log(`[ADM_CUST_BULK_CTRL] Request for bulk delete for customers [${customerIds?.join(', ')}] by admin from business ${adminBusinessId}`);

    // Validaciones
    if (!adminBusinessId) { return res.status(403).json({ message: "Informaci√≥n de administrador no disponible." }); }
    if (!Array.isArray(customerIds) || customerIds.length === 0) { return res.status(400).json({ message: "Se requiere un array 'customerIds' con al menos un ID de cliente." }); }
    if (!customerIds.every(id => typeof id === 'string')) { return res.status(400).json({ message: "Todos los elementos en 'customerIds' deben ser strings." }); }

    try {
        const result = await bulkDeleteCustomers(customerIds, adminBusinessId);
        res.status(200).json({ message: `${result.count} cliente(s) eliminados correctamente.`, count: result.count }); // Corregido: cliente(s), correctamente
    } catch (error) {
        console.error(`[ADM_CUST_BULK_CTRL] Failed bulk delete for customers [${customerIds.join(', ')}]:`, error);
        // Si el servicio lanza un error espec√≠fico por FK, el manejador global lo capturar√°
        // pero podr√≠amos querer manejarlo aqu√≠ si el frontend necesita un c√≥digo de estado espec√≠fico (ej: 409 Conflict)
        if (error instanceof Error && error.message.includes('datos asociados')) {
             return res.status(409).json({ message: error.message }); // 409 Conflict
        }
        next(error);
    }
};

/**
 * Handler para ajustar los puntos de m√∫ltiples clientes.
 * POST /api/admin/customers/bulk-adjust-points
 */
export const bulkAdjustPointsHandler = async (req: Request, res: Response, next: NextFunction) => {
    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId) { // No necesitamos user.id aqu√≠ en el controller
        console.error("[ADM_CUST_BULK_CTRL] Critical: User or businessId missing in bulkAdjustPointsHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // const adminUserId = req.user.id; // Lo obtenemos pero no lo usamos activamente aqu√≠
    // --- FIN FIX ---

    const { customerIds, amount, reason } = req.body;
    // Log con menos info sensible
    console.log(`[ADM_CUST_BULK_CTRL] Request for bulk points adjustment by ${amount} for ${customerIds?.length} customers from business ${adminBusinessId}. Reason: ${reason || 'N/A'}`);

    // Validaciones
    if (!adminBusinessId) { return res.status(403).json({ message: "Informaci√≥n de administrador no disponible." }); }
    if (!Array.isArray(customerIds) || customerIds.length === 0) { return res.status(400).json({ message: "Se requiere un array 'customerIds' con al menos un ID de cliente." }); }
    if (typeof amount !== 'number' || amount === 0) { return res.status(400).json({ message: "La cantidad ('amount') debe ser un n√∫mero distinto de cero." }); }
    if (reason !== undefined && reason !== null && typeof reason !== 'string') { return res.status(400).json({ message: "La raz√≥n ('reason') debe ser un texto o nula/omitida." }); } // Corregido: raz√≥n
    if (!customerIds.every(id => typeof id === 'string')) { return res.status(400).json({ message: "Todos los elementos en 'customerIds' deben ser strings." }); }

    try {
        const result = await bulkAdjustPointsForCustomers( customerIds, adminBusinessId, amount, reason || null );
        const actionText = amount > 0 ? 'a√±adidos' : 'restados'; // Corregido: √±
        res.status(200).json({
            message: `${Math.abs(amount)} puntos ${actionText} correctamente para ${result.count} cliente(s).`, // Corregido: √±, cliente(s)
            count: result.count
        });
    } catch (error) {
        console.error(`[ADM_CUST_BULK_CTRL] Failed bulk points adjustment for customers [${customerIds?.join(', ')}]:`, error);
        next(error);
    }
};

// End of File: backend/src/admin/admin-customer-bulk.controller.ts


// ====== [56] backend/src/modules/loyalpyme/admin/admin-customer-bulk.service.ts ======
// filename: backend/src/admin/admin-customer-bulk.service.ts
// Version: 1.1.1 (Store reason or null in ActivityLog description for bulk adjustments)

import {
    PrismaClient, Prisma, UserRole,
    ActivityType // Aseg√∫rate que est√© importado
} from '@prisma/client';

const prisma = new PrismaClient();

// Tipos (sin cambios)
interface BatchPayload { count: number; }

// bulkUpdateStatusForCustomers (sin cambios)
export const bulkUpdateStatusForCustomers = async ( customerIds: string[], adminBusinessId: string, isActive: boolean ): Promise<BatchPayload> => {
    const action = isActive ? 'Activating' : 'Deactivating'; console.log(`[ADM_CUST_BULK_SVC] ${action} ${customerIds.length} customers for business ${adminBusinessId}`); try { const result = await prisma.user.updateMany({ where: { id: { in: customerIds, }, businessId: adminBusinessId, role: UserRole.CUSTOMER_FINAL }, data: { isActive: isActive }, }); console.log(`[ADM_CUST_BULK_SVC] Bulk status update successful. ${result.count} customers updated to isActive=${isActive}.`); return result; } catch (error) { console.error(`[ADM_CUST_BULK_SVC] Error during bulk status update for customers [${customerIds.join(', ')}] of business ${adminBusinessId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { throw new Error(`Error de base de datos durante la actualizaci√≥n masiva: ${error.message}`); } throw new Error('Error inesperado durante la actualizaci√≥n masiva de estado.'); }
};

// bulkDeleteCustomers (sin cambios)
export const bulkDeleteCustomers = async ( customerIds: string[], adminBusinessId: string ): Promise<BatchPayload> => {
    console.log(`[ADM_CUST_BULK_SVC] Deleting ${customerIds.length} customers for business ${adminBusinessId}`); try { const result = await prisma.user.deleteMany({ where: { id: { in: customerIds, }, businessId: adminBusinessId, role: UserRole.CUSTOMER_FINAL }, }); console.log(`[ADM_CUST_BULK_SVC] Bulk delete successful. ${result.count} customers deleted.`); return result; } catch (error) { console.error(`[ADM_CUST_BULK_SVC] Error during bulk delete for customers [${customerIds.join(', ')}] of business ${adminBusinessId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2003') { throw new Error(`No se pudieron eliminar todos los clientes porque tienen datos asociados (registros de puntos, regalos, etc.). C√≥digo: ${error.code}`); } throw new Error(`Error de base de datos durante el borrado masivo: ${error.message} (C√≥digo: ${error.code})`); } throw new Error('Error inesperado durante el borrado masivo de clientes.'); }
};


// --- bulkAdjustPointsForCustomers MODIFICADO ---
/**
 * Ajusta puntos masivamente y crea logs individuales guardando la raz√≥n (o null).
 */
export const bulkAdjustPointsForCustomers = async (
    customerIds: string[],
    adminBusinessId: string,
    amount: number,
    reason: string | null // La raz√≥n viene como argumento
): Promise<BatchPayload> => {
    const action = amount > 0 ? 'Adding' : 'Subtracting';
    console.log(`[ADM_CUST_BULK_SVC] ${action} ${Math.abs(amount)} points for ${customerIds.length} customers. Business: ${adminBusinessId}. Reason: ${reason || 'N/A'}`);

    if (amount === 0) { console.warn(`[ADM_CUST_BULK_SVC] Attempted bulk adjust points with amount 0. No action taken.`); return { count: 0 }; }

    const whereClause: Prisma.UserWhereInput = { id: { in: customerIds }, businessId: adminBusinessId, role: UserRole.CUSTOMER_FINAL };
    let updateResult: BatchPayload;

    try {
        // 1. Ejecutar la actualizaci√≥n masiva
        updateResult = await prisma.user.updateMany({ where: whereClause, data: { points: { increment: amount } }, });
        console.log(`[ADM_CUST_BULK_SVC] Bulk points update successful. ${updateResult.count} customers updated.`);
    } catch (error) {
        console.error(`[ADM_CUST_BULK_SVC] Error during bulk points update for customers [${customerIds.join(', ')}] of business ${adminBusinessId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { throw new Error(`Error de base de datos durante el ajuste masivo de puntos: ${error.message}`); } throw new Error('Error inesperado durante el ajuste masivo de puntos.');
    }

    // 2. Si se actualiz√≥ algo, intentar crear logs
    if (updateResult.count > 0) {
        try {
            // 2.1 Obtener IDs afectados
            const affectedUsers = await prisma.user.findMany({ where: whereClause, select: { id: true } });
            console.log(`[ADM_CUST_BULK_SVC] Found ${affectedUsers.length} affected user IDs to log.`);

            // 2.2 Crear datos para los logs (MODIFICACI√ìN en description)
            const logsToCreate: Prisma.ActivityLogCreateManyInput[] = affectedUsers.map(user => ({
                userId: user.id,
                businessId: adminBusinessId,
                type: ActivityType.POINTS_ADJUSTED_ADMIN,
                pointsChanged: amount,
                description: reason || null, // <-- GUARDA LA RAZ√ìN O NULL
                // No hay IDs relacionados
            }));

            // 2.3 Crear los logs
            if (logsToCreate.length > 0) {
                const logResult = await prisma.activityLog.createMany({ data: logsToCreate, skipDuplicates: true, });
                console.log(`[ADM_CUST_BULK_SVC] Successfully created ${logResult.count} activity logs for bulk adjustment.`);
            }
        } catch (logError) {
            console.error(`[ADM_CUST_BULK_SVC] WARNING: Failed to create some or all activity logs for bulk adjustment for business ${adminBusinessId}. Error:`, logError);
        }
    }

    // 3. Devolver resultado del updateMany
    return updateResult;
};
// --- FIN bulkAdjustPointsForCustomers ---

// End of File: backend/src/admin/admin-customer-bulk.service.ts


// ====== [57] backend/src/modules/loyalpyme/admin/admin-customer-individual.controller.ts ======
// filename: backend/src/admin/admin-customer-individual.controller.ts
// Version: 1.0.0 (Handlers extracted from admin-customer.controller, @ts-ignore removed, cleaned)

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client'; // Para tipos de error

// Importar solo los servicios necesarios para acciones individuales
import {
    getCustomerDetailsById,
    updateAdminNotesForCustomer,
    adjustPointsForCustomer,
    changeCustomerTier,
    assignRewardToCustomer,
    toggleFavoriteStatus,
    toggleActiveStatusForCustomer
} from './admin-customer-individual.service'; // Ajustado a la nueva ubicaci√≥n del servicio

/**
 * Handler para obtener los detalles completos de un cliente espec√≠fico.
 */
export const getCustomerDetailsHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;

    // --- FIX: Comprobaci√≥n expl√≠cita de req.user y req.user.businessId ---
    if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in getCustomerDetailsHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    console.log(`[ADM_CUST_IND_CTRL] Request to get details for customer ${customerId} by admin from business ${adminBusinessId}`);
    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }

    try {
        const customerDetails = await getCustomerDetailsById(customerId, adminBusinessId);
        if (!customerDetails) { return res.status(404).json({ message: "Cliente no encontrado o no pertenece a este negocio." }); }
        res.status(200).json(customerDetails);
    } catch (error) {
        console.error(`[ADM_CUST_IND_CTRL] Failed to get details for customer ${customerId}:`, error);
        // Pasar error al manejador global, excepto 404
        if (error instanceof Error && (error.message.includes('no encontrado') || error.message.includes('no pertenece'))) {
            return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para actualizar las notas de administrador de un cliente.
 */
export const updateCustomerNotesHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;
    const { notes } = req.body;

    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in updateCustomerNotesHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    console.log(`[ADM_CUST_IND_CTRL] Request to update notes for customer ${customerId} by admin from business ${adminBusinessId}`);
    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }
    // Permitir enviar 'notes' como null expl√≠citamente
    if (notes === undefined) { return res.status(400).json({ message: "Falta el campo 'notes' en el cuerpo de la petici√≥n (puede ser null)." }); }
    if (notes !== null && typeof notes !== 'string') { return res.status(400).json({ message: "El campo 'notes' debe ser un texto o nulo." }); }

    try {
        const updatedCustomer = await updateAdminNotesForCustomer(customerId, adminBusinessId, notes);
        res.status(200).json({ message: `Notas actualizadas correctamente para ${updatedCustomer.email}.` }); // Corregido: correctamente
    } catch (error) {
        console.error(`[ADM_CUST_IND_CTRL] Failed to update notes for customer ${customerId}:`, error);
         if (error instanceof Error && (error.message.includes('no encontrado') || error.message.includes('no pertenece'))) {
             return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para ajustar puntos.
 */
export const adjustCustomerPoints = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;
    const { amount, reason } = req.body;

    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId || !req.user.id) { // Necesitamos id y businessId
        console.error("[ADM_CUST_IND_CTRL] Critical: User, businessId or userId missing in adjustCustomerPoints.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminUserId = req.user.id; // Se usaba impl√≠citamente antes, ahora expl√≠cito
    const adminBusinessId = req.user.businessId;
     // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }
    if (typeof amount !== 'number' || amount === 0) { return res.status(400).json({ message: "La cantidad ('amount') debe ser un n√∫mero distinto de cero." }); }

    try {
        const updatedCustomer = await adjustPointsForCustomer( customerId, adminBusinessId, amount, reason );
        res.status(200).json({ message: `Puntos ajustados correctamente para ${updatedCustomer.email}.`, customer: { id: updatedCustomer.id, points: updatedCustomer.points } }); // Corregido: correctamente
    }
    catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to adjust points for customer ${customerId}:`, error); next(error); }
};

/**
 * Handler para cambiar tier.
 */
export const changeCustomerTierHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;
    const { tierId } = req.body;

     // --- FIX: Comprobaci√≥n expl√≠cita ---
     if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in changeCustomerTierHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }
    if (tierId === undefined) { return res.status(400).json({ message: "Falta el ID del nivel ('tierId') en el cuerpo de la petici√≥n (puede ser nulo)." }); }
    if (tierId !== null && typeof tierId !== 'string') { return res.status(400).json({ message: "El ID del nivel ('tierId') debe ser un texto o nulo." }); }

    try {
        const updatedCustomer = await changeCustomerTier( customerId, adminBusinessId, tierId );
        res.status(200).json({ message: `Nivel cambiado correctamente para ${updatedCustomer.email}.`, customer: { id: updatedCustomer.id, currentTierId: updatedCustomer.currentTierId, tierAchievedAt: updatedCustomer.tierAchievedAt } }); // Corregido: correctamente
    }
    catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to change tier for customer ${customerId} to ${tierId}:`, error); next(error); }
};

/**
 * Handler para asignar recompensa.
 */
export const assignRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;
    const { rewardId } = req.body;

    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId || !req.user.id) { // Necesitamos id y businessId
        console.error("[ADM_CUST_IND_CTRL] Critical: User, businessId or userId missing in assignRewardHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminUserId = req.user.id;
    const adminBusinessId = req.user.businessId;
     // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }
    if (!rewardId || typeof rewardId !== 'string') { return res.status(400).json({ message: "Falta el ID de la recompensa ('rewardId') o no es v√°lido." }); // Corregido: v√°lido
    }

    try {
        const grantedReward = await assignRewardToCustomer( customerId, adminBusinessId, rewardId, adminUserId );
        res.status(201).json({ message: `Recompensa asignada correctamente al cliente.`, grantedRewardId: grantedReward.id }); // Corregido: correctamente
    }
    catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to assign reward ${rewardId} to customer ${customerId}:`, error); next(error); }
};

/**
 * Handler para toggle favorito.
 */
export const toggleFavoriteHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;

    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in toggleFavoriteHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }

    try {
        const updatedCustomer = await toggleFavoriteStatus( customerId, adminBusinessId );
        res.status(200).json({ message: `Estado de favorito cambiado para ${updatedCustomer.email}. Nuevo estado: ${updatedCustomer.isFavorite}`, customer: { id: updatedCustomer.id, isFavorite: updatedCustomer.isFavorite } });
    }
    catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to toggle favorite status for customer ${customerId}:`, error); next(error); }
};

/**
 * Handler para toggle activo.
 */
export const toggleActiveStatusHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;

     // --- FIX: Comprobaci√≥n expl√≠cita ---
     if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in toggleActiveStatusHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }

    try {
        const updatedCustomer = await toggleActiveStatusForCustomer(customerId, adminBusinessId);
        res.status(200).json({ message: `Estado cambiado para ${updatedCustomer.email}. Nuevo estado: ${updatedCustomer.isActive ? 'Activo' : 'Inactivo'}`, customer: { id: updatedCustomer.id, isActive: updatedCustomer.isActive } });
    } catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to toggle active status for customer ${customerId}:`, error); next(error); }
};


// End of File: backend/src/admin/admin-customer-individual.controller.ts


// ====== [58] backend/src/modules/loyalpyme/admin/admin-customer-individual.service.ts ======
// filename: backend/src/admin/admin-customer-individual.service.ts
// Version: 1.2.0 (Use i18n reward fields name_es/name_en)

import {
    PrismaClient, Prisma, UserRole, User, GrantedReward,
    ActivityType, Reward // <-- Reward debe estar aqu√≠ aunque usemos Pick
} from '@prisma/client';
const prisma = new PrismaClient();

// Tipos y Selectores (sin cambios)
const customerDetailsSelector = Prisma.validator<Prisma.UserSelect>()({ id: true, email: true, name: true, points: true, createdAt: true, isActive: true, isFavorite: true, tierAchievedAt: true, adminNotes: true, businessId: true, role: true, currentTier: { select: { id: true, name: true, level: true, description: true } } });
export type CustomerDetails = Prisma.UserGetPayload<{ select: typeof customerDetailsSelector }>;
type FavoriteStatusUpdate = Pick<User, 'id' | 'email' | 'isFavorite'>;
type ActiveStatusUpdate = Pick<User, 'id' | 'email' | 'isActive'>;
type NotesUpdate = Pick<User, 'id' | 'email' | 'adminNotes'>;

// getCustomerDetailsById (sin cambios)
export const getCustomerDetailsById = async (customerId: string, adminBusinessId: string): Promise<CustomerDetails | null> => {
     console.log(`[ADM_CUST_IND_SVC] Getting details for customer ${customerId} by admin from business ${adminBusinessId}`); try { const customerDetails = await prisma.user.findUnique({ where: { id: customerId, businessId: adminBusinessId, role: UserRole.CUSTOMER_FINAL }, select: customerDetailsSelector }); if (!customerDetails) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } console.log(`[ADM_CUST_IND_SVC] Details found for customer ${customerId}`); return customerDetails; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error getting details for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { throw new Error(`Error de base de datos al obtener detalles del cliente: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al obtener los detalles del cliente.'); }
};

// updateAdminNotesForCustomer (sin cambios)
export const updateAdminNotesForCustomer = async ( customerId: string, adminBusinessId: string, notes: string | null ): Promise<NotesUpdate> => {
     console.log(`[ADM_CUST_IND_SVC] Updating admin notes for customer ${customerId} by admin from business ${adminBusinessId}`); try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { adminNotes: notes }, select: { id: true, email: true, adminNotes: true } }); console.log(`[ADM_CUST_IND_SVC] Admin notes updated successfully for customer ${customer.email} (${customerId})`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error updating admin notes for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error(`No se encontr√≥ el cliente especificado al intentar actualizar las notas.`); } throw new Error(`Error de base de datos al actualizar las notas: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al actualizar las notas del administrador.'); }
};

// adjustPointsForCustomer (sin cambios respecto a versi√≥n anterior)
export const adjustPointsForCustomer = async ( customerId: string, adminBusinessId: string, amount: number, reason?: string | null ): Promise<User> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to adjust points for customer ${customerId} by ${amount}. Reason: ${reason || 'N/A'}. Admin Business: ${adminBusinessId}`); if (amount === 0) { throw new Error("La cantidad de puntos a ajustar no puede ser cero."); } try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId }, select: { businessId: true, id: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado.`); } if (customer.businessId !== adminBusinessId) { throw new Error("No tienes permiso para modificar este cliente."); } const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { points: { increment: amount } } }); console.log(`[ADM_CUST_IND_SVC - TX] Points adjusted successfully for customer ${userAfterUpdate.email} (${customerId}). New balance potentially: ${userAfterUpdate.points}`); await tx.activityLog.create({ data: { userId: customerId, businessId: adminBusinessId, type: ActivityType.POINTS_ADJUSTED_ADMIN, pointsChanged: amount, description: reason || null } }); console.log(`[ADM_CUST_IND_SVC - TX] ActivityLog created for admin points adjustment for user ${customerId}.`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error adjusting points for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error(`No se encontr√≥ el cliente especificado para actualizar.`); } throw new Error(`Error de base de datos al ajustar puntos: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al ajustar los puntos.'); }
};

// changeCustomerTier (sin cambios)
export const changeCustomerTier = async ( customerId: string, adminBusinessId: string, tierId: string | null ): Promise<User> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to change tier for customer ${customerId} to tier ${tierId ?? 'NULL'}. Admin Business: ${adminBusinessId}`); try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } if (tierId !== null) { const tierExists = await tx.tier.findUnique({ where: { id: tierId, businessId: adminBusinessId }, select: { id: true } }); if (!tierExists) { throw new Error(`El nivel seleccionado (ID: ${tierId}) no es v√°lido o no pertenece a tu negocio.`); } } const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { currentTierId: tierId, tierAchievedAt: tierId ? new Date() : null } }); console.log(`[ADM_CUST_IND_SVC] Tier changed successfully for customer ${userAfterUpdate.email} (${customerId}) to ${tierId ?? 'NULL'}`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error changing tier for customer ${customerId} to ${tierId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { throw new Error(`Error de base de datos al cambiar nivel: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al cambiar el nivel del cliente.'); }
};

// --- assignRewardToCustomer MODIFICADO ---
/**
 * Asigna una recompensa como "regalo" a un cliente.
 */
export const assignRewardToCustomer = async (
    customerId: string,
    adminBusinessId: string,
    rewardId: string,
    adminUserId: string
): Promise<GrantedReward> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to assign reward ${rewardId} to customer ${customerId} by admin ${adminUserId} from business ${adminBusinessId}`);
     try {
        const grantedReward = await prisma.$transaction(async (tx) => {
            const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, email: true } });
            if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); }

            // --- MODIFICADO: Seleccionar name_es y name_en en lugar de name ---
            const reward = await tx.reward.findUnique({
                where: { id: rewardId, businessId: adminBusinessId },
                select: {
                    id: true,
                    isActive: true,
                    name_es: true, // Seleccionar nombre ES
                    name_en: true  // Seleccionar nombre EN
                }
            });
            // --- FIN MODIFICADO ---

            if (!reward) { throw new Error(`Recompensa con ID ${rewardId} no encontrada o no pertenece a tu negocio.`); }
            if (!reward.isActive) {
                // --- MODIFICADO: Usar name_es o name_en en el mensaje de error ---
                const rewardDisplayName = reward.name_es || reward.name_en || `ID ${rewardId}`;
                throw new Error(`La recompensa "${rewardDisplayName}" no est√° activa y no puede ser asignada.`);
                 // --- FIN MODIFICADO ---
            }

            const newGrantedReward = await tx.grantedReward.create({
                data: { userId: customerId, rewardId: rewardId, businessId: adminBusinessId, assignedById: adminUserId, status: 'PENDING', }
            });

            // --- MODIFICADO: Usar name_es o name_en en el log ---
            const rewardLogName = reward.name_es || reward.name_en || `ID ${rewardId}`;
            console.log(`[ADM_CUST_IND_SVC - TX] Reward ${rewardLogName} (${rewardId}) assigned successfully to customer ${customer.email} (${customerId}). GrantedReward ID: ${newGrantedReward.id}`);
            // --- FIN MODIFICADO ---

            return newGrantedReward;
        });
        return grantedReward;
    } catch (error) {
        console.error(`[ADM_CUST_IND_SVC] Error assigning reward ${rewardId} to customer ${customerId}:`, error);
        // --- MODIFICADO: Usar Prisma.PrismaClientKnownRequestError para chequear error ---
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            // No necesitamos chequear P2002 aqu√≠ espec√≠ficamente, un error gen√©rico est√° bien
            throw new Error(`Error de base de datos al asignar recompensa: ${error.message}`);
        }
        // --- FIN MODIFICADO ---
        if (error instanceof Error) { throw error; }
        throw new Error('Error inesperado al asignar la recompensa.');
    }
};
// --- FIN assignRewardToCustomer ---

// toggleFavoriteStatus (sin cambios)
export const toggleFavoriteStatus = async ( customerId: string, adminBusinessId: string ): Promise<FavoriteStatusUpdate> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to toggle favorite status for customer ${customerId} by admin from business ${adminBusinessId}`); try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, isFavorite: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } const newFavoriteStatus = !customer.isFavorite; const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { isFavorite: newFavoriteStatus }, select: { id: true, email: true, isFavorite: true } }); console.log(`[ADM_CUST_IND_SVC] Favorite status for customer ${customer.email} (${customerId}) toggled to ${newFavoriteStatus}`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error toggling favorite status for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error(`No se encontr√≥ el cliente especificado al intentar actualizar.`); } throw new Error(`Error de base de datos al cambiar estado de favorito: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al cambiar el estado de favorito.'); }
};

// toggleActiveStatusForCustomer (sin cambios)
export const toggleActiveStatusForCustomer = async ( customerId: string, adminBusinessId: string ): Promise<ActiveStatusUpdate> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to toggle active status for customer ${customerId} by admin from business ${adminBusinessId}`); try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, isActive: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } const newActiveStatus = !customer.isActive; const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { isActive: newActiveStatus }, select: { id: true, email: true, isActive: true } }); console.log(`[ADM_CUST_IND_SVC] Active status for customer ${customer.email} (${customerId}) toggled to ${newActiveStatus}`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error toggling active status for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error(`No se encontr√≥ el cliente especificado al intentar actualizar.`); } throw new Error(`Error de base de datos al cambiar estado activo: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al cambiar el estado activo del cliente.'); }
};

// End of File: backend/src/admin/admin-customer-individual.service.ts


// ====== [59] backend/src/modules/loyalpyme/admin/admin-customer-list.controller.ts ======
// filename: backend/src/admin/admin-customer-list.controller.ts
// Version: 1.0.0 (Handler extracted from admin-customer.controller, @ts-ignore removed)

import { Request, Response, NextFunction } from 'express';

// Importar s√≥lo el servicio necesario
import { getCustomersForBusiness } from './admin-customer-list.service'; // Ajustado a la nueva ubicaci√≥n del servicio

// Tipos locales para este controlador (podr√≠an moverse a un DTO o types si se complejizan)
type SortDirection = 'asc' | 'desc';
interface ControllerGetCustomersOptions {
    page?: number;
    limit?: number;
    sortBy?: string;
    sortDir?: SortDirection;
    filters?: {
        search?: string;
        isFavorite?: boolean;
        isActive?: boolean;
        tierId?: string;
    }
}

/**
 * Handler para que el Admin obtenga la lista PAGINADA, FILTRADA y ORDENADA de clientes.
 * GET /api/admin/customers
 */
export const getAdminCustomers = async (req: Request, res: Response, next: NextFunction) => {
    console.log('[ADM_CUST_LIST_CTRL] Entering getAdminCustomers handler...');

    // --- FIX: Comprobaci√≥n expl√≠cita de req.user y req.user.businessId ---
    if (!req.user || !req.user.businessId) {
        // Este error no deber√≠a ocurrir si authenticateToken funciona, pero es una guarda segura.
        console.error("[ADM_CUST_LIST_CTRL] Critical: User or businessId missing after authenticateToken.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId; // Ahora podemos acceder de forma segura
    console.log(`[ADM_CUST_LIST_CTRL] Admin businessId: ${adminBusinessId}`);
    // --- FIN FIX ---

    // Leer par√°metros de query (sin cambios)
    const page = parseInt(req.query.page as string || '1', 10);
    const limit = parseInt(req.query.limit as string || '10', 10);
    const sortBy = req.query.sortBy as string || 'createdAt';
    const sortDirInput = req.query.sortDir as string;
    const sortDir: SortDirection = sortDirInput === 'asc' ? 'asc' : 'desc';
    const search = req.query.search as string | undefined;
    const isActiveParam = req.query.isActive as string | undefined;
    const isFavoriteParam = req.query.isFavorite as string | undefined;
    const tierIdParam = req.query.tierId as string | undefined;

    // Construir objeto de filtros (sin cambios)
    const filters: ControllerGetCustomersOptions['filters'] = {};
    if (search?.trim()) filters.search = search.trim();
    if (isActiveParam !== undefined) filters.isActive = isActiveParam === 'true';
    if (isFavoriteParam !== undefined) filters.isFavorite = isFavoriteParam === 'true';
    if (tierIdParam?.trim()) filters.tierId = tierIdParam.trim();

    // Construir objeto de opciones (sin cambios)
    const options: ControllerGetCustomersOptions = {
        page: isNaN(page) || page < 1 ? 1 : page,
        limit: isNaN(limit) || limit < 1 ? 10 : limit,
        sortBy: sortBy,
        sortDir: sortDir,
        filters: filters
    };

    console.log(`[ADM_CUST_LIST_CTRL] Parsed options being sent to service:`, options);

    try {
        // Llamar al servicio (sin cambios)
        const result = await getCustomersForBusiness(adminBusinessId, options);
        console.log(`[ADM_CUST_LIST_CTRL] Service call returned. Result has ${result?.items?.length ?? 'N/A'} items. Total items: ${result?.totalItems ?? 'N/A'}`);
        res.status(200).json(result);
    } catch (error) {
        console.error("[ADM_CUST_LIST_CTRL] *** ERROR caught in getAdminCustomers handler:", error);
        next(error); // Pasar al manejador de errores global
    }
};

// End of File: backend/src/admin/admin-customer-list.controller.ts


// ====== [60] backend/src/modules/loyalpyme/admin/admin-customer-list.service.ts ======
// filename: backend/src/admin/admin-customer-list.service.ts
// Version: 1.0.0 (Extracted from admin-customer.service.ts and cleaned)

import { PrismaClient, Prisma, UserRole } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos y Selectores (Copiados del original, necesarios para esta funci√≥n) ---
interface GetCustomersOptions {
    page?: number;
    limit?: number;
    sortBy?: string;
    sortDir?: 'asc' | 'desc';
    filters?: {
        search?: string;
        isFavorite?: boolean;
        isActive?: boolean;
        tierId?: string;
    }
}

const customerListItemSelector = Prisma.validator<Prisma.UserSelect>()({
    id: true, name: true, email: true, points: true, createdAt: true, isActive: true, isFavorite: true,
    currentTier: { select: { name: true, id: true, level: true } }
});
type CustomerListItem = Prisma.UserGetPayload<{ select: typeof customerListItemSelector }>;
// --- Fin Tipos y Selectores ---


/**
 * Obtiene una lista paginada, filtrada y ordenada de clientes para un negocio espec√≠fico.
 */
export const getCustomersForBusiness = async (
    businessId: string,
    options: GetCustomersOptions = {}
): Promise<{ items: CustomerListItem[], totalPages: number, currentPage: number, totalItems: number }> => {
    const { page = 1, limit = 10, sortBy = 'createdAt', sortDir = 'desc', filters = {} } = options;
    // Log inicial con todos los par√°metros (√∫til para debug)
    console.log(`[ADM_CUST_LIST_SVC] getCustomersForBusiness - Fetching: businessId=${businessId}, Page=${page}, Limit=${limit}, SortBy=${sortBy}, SortDir=${sortDir}, Filters=`, filters);
    const allowedSortByFields = ['name', 'email', 'points', 'createdAt', 'isActive', 'isFavorite', 'currentTier.level'];
    const safeSortBy = allowedSortByFields.includes(sortBy) ? sortBy : 'createdAt';
    const safeSortDir = sortDir === 'asc' ? 'asc' : 'desc';
    const skip = (page - 1) * limit;

    try {
        // Construcci√≥n de whereClause con todos los filtros
        const whereClause: Prisma.UserWhereInput = {
            businessId: businessId,
            role: UserRole.CUSTOMER_FINAL
        };

        // Filtro de B√∫squeda (Name/Email)
        if (filters.search && filters.search.trim() !== '') {
            const searchTerm = filters.search.trim();
            whereClause.OR = [
                { name: { contains: searchTerm, mode: 'insensitive' } },
                { email: { contains: searchTerm, mode: 'insensitive' } }
            ];
        }

        // Filtro Favorito (isFavorite)
        if (filters.isFavorite !== undefined) {
            whereClause.isFavorite = filters.isFavorite;
        }

        // Filtro Estado (isActive)
        if (filters.isActive !== undefined) {
            whereClause.isActive = filters.isActive;
        }

        // Filtro Nivel (tierId)
        if (filters.tierId && filters.tierId.trim() !== '') {
             if (filters.tierId === 'NONE') { // Manejar expl√≠citamente "Sin Nivel"
                whereClause.currentTierId = null;
             } else {
                whereClause.currentTierId = filters.tierId;
             }
        }

        // Ordenaci√≥n (OrderBy)
        let orderByClause: Prisma.UserOrderByWithRelationInput | Prisma.UserOrderByWithRelationInput[];
        if (safeSortBy === 'currentTier.level') {
            orderByClause = { currentTier: { level: safeSortDir } };
        } else {
            orderByClause = { [safeSortBy]: safeSortDir };
        }

        const selectClause = customerListItemSelector;
        // Log de cl√°usulas finales (√∫til para debug)
        console.log('[ADM_CUST_LIST_SVC] getCustomersForBusiness - Final Clauses:', { where: whereClause, orderBy: orderByClause });

        // Ejecutar Consultas (COUNT y FINDMANY) en transacci√≥n
        const [totalItems, customers] = await prisma.$transaction([
            prisma.user.count({ where: whereClause }),
            prisma.user.findMany({
                where: whereClause,
                select: selectClause,
                orderBy: orderByClause,
                skip: skip,
                take: limit,
            })
        ]);

        console.log(`[ADM_CUST_LIST_SVC] getCustomersForBusiness - Found ${customers.length} customers on page ${page}. Total items matching filters: ${totalItems}`);
        const totalPages = Math.ceil(totalItems / limit);
        console.log(`[ADM_CUST_LIST_SVC] getCustomersForBusiness - Calculation done. Total pages: ${totalPages}`);

        return { items: customers, totalPages: totalPages, currentPage: page, totalItems: totalItems };

    } catch (error) {
        console.error(`[ADM_CUST_LIST_SVC] *** ERROR in getCustomersForBusiness for business ${businessId}:`, error);
        console.error(`[ADM_CUST_LIST_SVC] Options causing error:`, options);
        throw new Error('Error al obtener la lista de clientes desde la base de datos.');
    }
};

// End of File: backend/src/admin/admin-customer-list.service.ts


// ====== [61] backend/src/modules/loyalpyme/admin/admin-stats.controller.ts ======
// filename: backend/src/admin/admin-stats.controller.ts
// Version: 1.0.0

import { Request, Response, NextFunction } from 'express';
// Importamos la funci√≥n del servicio que acabamos de crear
import { getOverviewStats, AdminOverviewStatsData } from './admin-stats.service';

/**
 * Handler para obtener las estad√≠sticas del overview para el dashboard del admin.
 * GET /api/admin/stats/overview
 */
export const handleGetOverviewStats = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  // El middleware 'authenticateToken' ya deber√≠a haber a√±adido req.user
  // El middleware 'checkRole' ya deber√≠a haber verificado que es BUSINESS_ADMIN
  const businessId = req.user?.businessId;

  console.log(`[AdminStatsController] Solicitud de overview stats para businessId: ${businessId}`);

  // Comprobaci√≥n de seguridad adicional (aunque el middleware deber√≠a cubrirlo)
  if (!businessId) {
    console.warn('[AdminStatsController] No se encontr√≥ businessId en req.user. Acceso denegado.');
    // Usamos 403 Forbidden ya que el rol es correcto pero falta asociaci√≥n clave
    res.status(403).json({ message: 'El usuario administrador no est√° asociado a ning√∫n negocio.' });
    return; 
  }

  try {
    // Llamamos a la funci√≥n del servicio para obtener los datos
    const stats: AdminOverviewStatsData = await getOverviewStats(businessId);

    // Enviamos la respuesta exitosa con los datos
    res.status(200).json(stats);
    console.log(`[AdminStatsController] Stats enviadas correctamente para businessId: ${businessId}`);

  } catch (error) {
    // Si el servicio lanza un error, lo pasamos al manejador de errores global
    console.error(`[AdminStatsController] Error al obtener stats para business ${businessId}:`, error);
    next(error); // Pasamos el error al siguiente middleware (manejador de errores global)
  }
};

// Podr√≠an a√±adirse aqu√≠ m√°s handlers para otras estad√≠sticas si fueran necesarias.

// End of file: backend/src/admin/admin-stats.controller.ts


// ====== [62] backend/src/modules/loyalpyme/admin/admin-stats.service.ts ======
// backend/src/modules/loyalpyme/admin/admin-stats.service.ts
// Version: 1.3.0 (Use correct APPLIED status enum for redeemed rewards count)

import { PrismaClient, UserRole, QrCodeStatus, Prisma, ActivityType, GrantedRewardStatus } from '@prisma/client'; // <-- GrantedRewardStatus A√ëADIDO
import { startOfDay, endOfDay, subDays } from 'date-fns';

const prisma = new PrismaClient();

export interface AdminOverviewStatsData {
    totalActiveCustomers: number;
    newCustomersLast7Days: number;
    newCustomersPrevious7Days: number;
    pointsIssuedLast7Days: number;
    pointsIssuedPrevious7Days: number;
    rewardsRedeemedLast7Days: number;
    rewardsRedeemedPrevious7Days: number;
}

// Helper Functions
async function _getTotalActiveCustomers(businessId: string): Promise<number> {
    return prisma.user.count({
        where: { businessId, isActive: true, role: UserRole.CUSTOMER_FINAL }
    });
}

async function _getNewCustomersCount(businessId: string, startDate: Date, endDate: Date): Promise<number> {
    return prisma.user.count({
        where: { businessId, role: UserRole.CUSTOMER_FINAL, createdAt: { gte: startDate, lte: endDate } }
    });
}

async function _getPointsIssuedSum(businessId: string, startDate: Date, endDate: Date): Promise<number> {
    const result = await prisma.qrCode.aggregate({
        _sum: { pointsEarned: true },
        where: { businessId, status: QrCodeStatus.COMPLETED, completedAt: { gte: startDate, lte: endDate } }
    });
    return result._sum.pointsEarned ?? 0;
}

async function _getRewardsRedeemedCount(businessId: string, startDate: Date, endDate: Date): Promise<number> {
    let giftedAndAppliedCount = 0;
    let pointsRedeemedCount = 0;

    try {
        // Contar cupones que han sido APLICADOS a un pedido
        giftedAndAppliedCount = await prisma.grantedReward.count({
            // --- CORRECCI√ìN AQU√ç ---
            where: { businessId, status: GrantedRewardStatus.APPLIED, redeemedAt: { gte: startDate, lte: endDate } }
        });
    } catch (error) {
        console.error(`[AdminStatsService] Error counting applied/gifted rewards:`, error);
    }

    try {
        // Contar recompensas del flujo antiguo (canje directo por puntos)
        pointsRedeemedCount = await prisma.activityLog.count({
            where: {
                businessId,
                type: ActivityType.POINTS_REDEEMED_REWARD,
                createdAt: { gte: startDate, lte: endDate }
            }
        });
    } catch (error) {
        console.error(`[AdminStatsService] Error counting points redeemed rewards:`, error);
    }
    
    const startDateStr = startDate ? startDate.toISOString() : 'N/A';
    const endDateStr = endDate ? endDate.toISOString() : 'N/A';
    console.log(`[AdminStatsService DEBUG] Period: ${startDateStr} to ${endDateStr}. Applied/Gifted count: ${giftedAndAppliedCount}, Direct Points redeemed: ${pointsRedeemedCount}`);
    
    return giftedAndAppliedCount + pointsRedeemedCount;
}


export const getOverviewStats = async (businessId: string): Promise<AdminOverviewStatsData> => {
    console.log(`[AdminStatsService] Calculating overview stats for businessId: ${businessId}`);

    try {
        const now = new Date();
        const startOfLast7Days = startOfDay(subDays(now, 6));
        const endOfLast7Days = endOfDay(now);
        const startOfPrevious7Days = startOfDay(subDays(now, 13));
        const endOfPrevious7Days = endOfDay(subDays(now, 7));

        console.log(`[AdminStatsService DEBUG] Date Ranges - Last 7: ${startOfLast7Days.toISOString()} - ${endOfLast7Days.toISOString()}`);
        console.log(`[AdminStatsService DEBUG] Date Ranges - Prev 7: ${startOfPrevious7Days.toISOString()} - ${endOfPrevious7Days.toISOString()}`);

        const [
            totalActiveCustomers,
            newCustomersLast7Days,
            pointsIssuedLast7Days,
            rewardsRedeemedLast7Days,
            newCustomersPrevious7Days,
            pointsIssuedPrevious7Days,
            rewardsRedeemedPrevious7Days,
        ] = await Promise.all([
            _getTotalActiveCustomers(businessId),
            _getNewCustomersCount(businessId, startOfLast7Days, endOfLast7Days),
            _getPointsIssuedSum(businessId, startOfLast7Days, endOfLast7Days),
            _getRewardsRedeemedCount(businessId, startOfLast7Days, endOfLast7Days),
            _getNewCustomersCount(businessId, startOfPrevious7Days, endOfPrevious7Days),
            _getPointsIssuedSum(businessId, startOfPrevious7Days, endOfPrevious7Days),
            _getRewardsRedeemedCount(businessId, startOfPrevious7Days, endOfPrevious7Days),
        ]);

        const result = {
            totalActiveCustomers,
            newCustomersLast7Days,
            newCustomersPrevious7Days,
            pointsIssuedLast7Days,
            pointsIssuedPrevious7Days,
            rewardsRedeemedLast7Days,
            rewardsRedeemedPrevious7Days,
        };

        console.log(`[AdminStatsService] Stats calculated successfully for ${businessId}:`, result);
        return result;

    } catch (error) {
        console.error(`[AdminStatsService] CRITICAL Error calculating overview stats for business ${businessId}:`, error);
        throw new Error('Error cr√≠tico al obtener las estad√≠sticas del dashboard.');
    }
};


// ====== [63] backend/src/modules/loyalpyme/customer/customer.controller.ts ======
// backend/src/modules/loyalpyme/customer/customer.controller.ts
// VERSI√ìN 3.0.0 - CORRECCI√ìN DE HANDLER PARA DEVOLVER TODOS LOS GRANTED REWARDS

import { Request, Response, NextFunction } from 'express';

// Importar funciones del servicio de cliente
import {
    findActiveRewardsForCustomer,
    // La importaci√≥n de getPendingGrantedRewards se elimina
    getAllGrantedRewardsForUser, // <-- Se importa la nueva funci√≥n
    redeemGrantedReward,
    getCustomerFacingBusinessConfig,
    getAvailableCouponsForUser,
    getCustomerOrders
} from './customer.service';

import * as TierService from '../tiers/tiers.service';


/**
 * Handler para que el cliente obtenga las recompensas activas de su negocio.
 * GET /api/customer/rewards
 */
export const getCustomerRewardsHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId || !req.user.id) {
        console.error('[CUST_CTRL] Error: User context (id or businessId) missing from request.');
        return res.status(401).json({ message: 'Informaci√≥n de usuario o negocio no encontrada en la sesi√≥n.' });
    }
    const businessId = req.user.businessId;
    const userId = req.user.id;
    console.log(`[CUST_CTRL] User ${userId} requesting rewards for business ${businessId}`);
    try {
        const rewards = await findActiveRewardsForCustomer(businessId);
        res.status(200).json(rewards);
    } catch (error) {
        console.error(`[CUST_CTRL] Error fetching rewards for business ${businessId}:`, error);
        next(error);
    }
};

/**
 * Handler para que el cliente obtenga TODOS sus granted rewards (regalos pendientes, cupones disponibles, etc.).
 * GET /api/customer/granted-rewards
 */
export const getGrantedRewardsHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.id) {
        console.error('[CUST_CTRL] Error: userId missing from req.user for granted rewards request.');
        return res.status(401).json({ message: 'Informaci√≥n de usuario no encontrada en la sesi√≥n.' });
    }
    const userId = req.user.id;
    const userEmail = req.user.email;
    // Log actualizado para reflejar que se piden TODOS
    console.log(`[CUST_CTRL] User ${userId} (${userEmail || 'N/A'}) requesting ALL granted rewards.`);
    try {
        // --- CORRECCI√ìN CLAVE: Llamar a la nueva funci√≥n del servicio ---
        const grantedRewards = await getAllGrantedRewardsForUser(userId);
        res.status(200).json(grantedRewards);
    }
    catch (error) {
        console.error(`[CUST_CTRL] Failed to fetch all granted rewards for user ${userId}:`, error);
        next(error);
    }
};

/**
 * Handler para que el cliente canjee un regalo espec√≠fico.
 * POST /api/customer/granted-rewards/:grantedRewardId/redeem
 */
export const redeemGrantedRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.id) {
        console.error('[CUST_CTRL] Error: userId missing from req.user for redeem request.');
        return res.status(401).json({ message: 'Informaci√≥n de usuario no encontrada en la sesi√≥n.' });
    }
    const userId = req.user.id;
    const { grantedRewardId } = req.params;
    console.log(`[CUST_CTRL] User ${userId} attempting to redeem granted reward ID: ${grantedRewardId}`);
    if (!grantedRewardId) { return res.status(400).json({ message: 'Falta el ID del regalo otorgado en la URL.' }); }
    try {
        const redeemedGrant = await redeemGrantedReward(userId, grantedRewardId);
        res.status(200).json({ message: 'Regalo canjeado con √©xito.', grantedRewardId: redeemedGrant.id, rewardId: redeemedGrant.rewardId, redeemedAt: redeemedGrant.redeemedAt });
    }
    catch (error: any) {
        console.error(`[CUST_CTRL] Failed to redeem granted reward ${grantedRewardId} for user ${userId}:`, error);
        if (error instanceof Error && (error.message.includes('no te pertenece') || error.message.includes('no encontrado'))) {
            return res.status(403).json({ message: error.message });
        }
        if (error instanceof Error && error.message.includes('ya fue canjeado')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para que el cliente obtenga los Tiers disponibles en su programa.
 * GET /api/customer/tiers
 */
export const getCustomerTiersHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId || !req.user.id) {
        console.error('[CUST_CTRL] Error: User context (id or businessId) missing in getCustomerTiersHandler.');
        return res.status(401).json({ message: 'Informaci√≥n de usuario o negocio no encontrada en la sesi√≥n.' });
    }
    const businessId = req.user.businessId;
    const userId = req.user.id;
    console.log(`[CUST_CTRL] User ${userId} requesting available tiers for business ${businessId}.`);
    try {
        const tiers = await TierService.findTiersByBusiness(businessId, true);
        res.status(200).json(tiers);
    } catch (error: any) {
        console.error(`[CUST_CTRL] Error getting tiers for customer of business ${businessId}:`, error);
        next(error);
    }
};

/**
 * Handler para que el cliente obtenga la configuraci√≥n relevante de su negocio.
 * GET /api/customer/business-config
 */
export const getCustomerBusinessConfigHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) {
        console.error('[CUST_CTRL] Error: businessId missing from req.user for business-config request.');
        return res.status(401).json({ message: 'Informaci√≥n de negocio no encontrada en la sesi√≥n.' });
    }
    const businessId = req.user.businessId;
    const userId = req.user.id; 

    console.log(`[CUST_CTRL] User ${userId} requesting business config for business ${businessId}.`);

    try {
        const config = await getCustomerFacingBusinessConfig(businessId);

        if (!config) {
            console.warn(`[CUST_CTRL] Business config not found for businessId: ${businessId}`);
            return res.status(404).json({ message: 'No se encontr√≥ la configuraci√≥n para el negocio asociado.' });
        }

        res.status(200).json(config);

    } catch (error) {
        console.error(`[CUST_CTRL] Error getting business config for user ${userId}, business ${businessId}:`, error);
        next(error);
    }
};

/**
 * Handler para que el cliente obtenga sus cupones disponibles (GrantedRewards con estado AVAILABLE).
 * GET /api/customer/available-coupons
 */
export const getAvailableCouponsHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.id) {
        return res.status(401).json({ message: 'Informaci√≥n de usuario no encontrada en la sesi√≥n.' });
    }
    const userId = req.user.id;
    console.log(`[CUST_CTRL] User ${userId} requesting their available coupons.`);

    try {
        const availableCoupons = await getAvailableCouponsForUser(userId);
        res.status(200).json(availableCoupons);
    } catch (error) {
        console.error(`[CUST_CTRL] Error fetching available coupons for user ${userId}:`, error);
        next(error);
    }
};

/**
 * Handler para obtener el historial de pedidos pagados del cliente, con paginaci√≥n.
 * GET /api/customer/orders
 */
export const getCustomerOrdersHandler = async (req: Request, res: Response, next: NextFunction) => {
    const userId = req.user?.id;
    if (!userId) {
        return res.status(401).json({ message: 'Usuario no autenticado.' });
    }

    const pageQuery = req.query.page as string | undefined;
    const limitQuery = req.query.limit as string | undefined;
    
    const page = parseInt(pageQuery || '1', 10);
    const limit = parseInt(limitQuery || '10', 10);

    if (isNaN(page) || page < 1) {
        return res.status(400).json({ message: 'El par√°metro "page" debe ser un n√∫mero positivo.' });
    }
    if (isNaN(limit) || limit < 1 || limit > 50) {
        return res.status(400).json({ message: 'El par√°metro "limit" debe ser un n√∫mero entre 1 y 50.' });
    }

    console.log(`[CUST_CTRL] Request for orders history for user ${userId}. Page: ${page}, Limit: ${limit}`);
    
    try {
        const paginatedResult = await getCustomerOrders(userId, page, limit);
        res.status(200).json(paginatedResult);
    } catch (error) {
        next(error);
    }
};


// ====== [64] backend/src/modules/loyalpyme/customer/customer.service.ts ======
// backend/src/modules/loyalpyme/customer/customer.service.ts
// VERSI√ìN 3.1.1 - COMPLETA Y CORREGIDA

import {
    PrismaClient,
    Reward,
    Prisma,
    User,
    GrantedReward,
    Business,
    ActivityType,
    GrantedRewardStatus,
    Order,
    OrderStatus,
} from '@prisma/client';

const prisma = new PrismaClient();

export type OrderHistoryItem = Pick<Order, 'id' | 'orderNumber' | 'finalAmount' | 'paidAt'> & {
    items: Array<{
        itemNameSnapshot: string | null;
        quantity: number;
        totalItemPrice: Prisma.Decimal;
        priceAtPurchase: Prisma.Decimal;
        redeemedRewardId: string | null;
        selectedModifiers: Array<{
            optionNameSnapshot: string | null;
            optionPriceAdjustmentSnapshot: Prisma.Decimal;
        }>;
    }>;
};

export interface PaginatedOrdersResponse {
    orders: OrderHistoryItem[];
    totalPages: number;
    currentPage: number;
    totalItems: number;
}

export type CustomerBusinessConfig = Pick<Business, 'tierCalculationBasis'> | null;

export const findActiveRewardsForCustomer = async (businessId: string): Promise<Reward[]> => {
    console.log(`[CUST_SVC] Finding active rewards for customer view for business: ${businessId}`);
    try {
        const rewards = await prisma.reward.findMany({
            where: {
                businessId: businessId,
                isActive: true,
            },
            orderBy: {
                pointsCost: 'asc',
            },
        });
        console.log(`[CUST_SVC] Found ${rewards.length} active rewards for business ${businessId}`);
        return rewards;
    } catch (error) {
        console.error(`[CUST_SVC] Error fetching active rewards for business ${businessId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            throw new Error(`Error de base de datos al buscar recompensas: ${error.message}`);
        }
        throw new Error('Error inesperado al buscar recompensas activas.');
    }
};

/**
 * Obtiene TODOS los GrantedReward (regalos pendientes, cupones disponibles, etc.) de un usuario.
 * @param userId - El ID del usuario.
 * @returns Una lista de todos los `GrantedReward` del usuario.
 */
export const getAllGrantedRewardsForUser = async (userId: string): Promise<GrantedReward[]> => {
    console.log(`[CUST_SVC] Fetching ALL granted rewards for user ${userId}`);
    try {
        const grantedRewards = await prisma.grantedReward.findMany({
            where: {
                userId: userId,
                // Se elimina el filtro de estado para devolver TODOS
            },
            include: {
                reward: {
                    select: {
                        id: true,
                        name_es: true,
                        name_en: true,
                        description_es: true,
                        description_en: true,
                        imageUrl: true,
                        type: true,
                        discountType: true,
                    }
                },
                assignedBy: { select: { name: true, email: true } },
                business: { select: { name: true } }
            },
            orderBy: { assignedAt: 'desc' }
        });
        console.log(`[CUST_SVC] Found ${grantedRewards.length} total granted rewards for user ${userId}`);
        return grantedRewards;
    } catch (error) {
        console.error(`[CUST_SVC] Error fetching all granted rewards for user ${userId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
             throw new Error(`Error de base de datos al buscar recompensas otorgadas: ${error.message}`);
        }
        throw new Error('Error inesperado al buscar recompensas otorgadas.');
    }
};

export const redeemGrantedReward = async (userId: string, grantedRewardId: string): Promise<GrantedReward> => {
    console.log(`[CUST_SVC] User ${userId} attempting to redeem granted reward ${grantedRewardId}`);
    try {
        const updatedGrantedReward = await prisma.$transaction(async (tx) => {
            const grantedReward = await tx.grantedReward.findUnique({
                where: { id: grantedRewardId },
                include: {
                    reward: {
                        select: {
                            id: true,
                            name_es: true,
                            name_en: true
                        }
                    },
                    business: { select: { id: true } }
                }
            });

            if (!grantedReward) { throw new Error(`Regalo con ID ${grantedRewardId} no encontrado.`); }
            if (!grantedReward.business?.id) { console.error(`[CUST_SVC] Critical: GrantedReward ${grantedRewardId} missing business relation!`); throw new Error(`Error interno: El regalo no est√° asociado a un negocio.`); }
            if (!grantedReward.reward?.id) { console.error(`[CUST_SVC] Critical: GrantedReward ${grantedRewardId} missing reward relation!`); throw new Error(`Error interno: El regalo no est√° asociado a una recompensa.`); }
            if (grantedReward.userId !== userId) { console.warn(`[CUST_SVC] Unauthorized attempt by user ${userId} to redeem granted reward ${grantedRewardId} belonging to user ${grantedReward.userId}`); throw new Error("Este regalo no te pertenece."); }
            
            if (grantedReward.status !== 'PENDING') {
                const rewardDisplayName = grantedReward.reward.name_es || grantedReward.reward.name_en || `ID ${grantedReward.reward.id}`;
                throw new Error(`Este regalo (${rewardDisplayName}) ya fue canjeado o no es v√°lido (Estado: ${grantedReward.status}).`);
            }

            const redeemed = await tx.grantedReward.update({
                where: { id: grantedRewardId, userId: userId, status: 'PENDING' },
                data: { status: GrantedRewardStatus.APPLIED, redeemedAt: new Date() }
            });

            const logDescription = grantedReward.reward.name_es || grantedReward.reward.name_en || null;
            await tx.activityLog.create({
                data: {
                    userId: userId,
                    businessId: grantedReward.business.id,
                    type: ActivityType.GIFT_REDEEMED,
                    pointsChanged: null,
                    description: logDescription,
                    relatedGrantedRewardId: grantedRewardId
                }
            });

            console.log(`[CUST_SVC] Granted reward ${grantedRewardId} (${redeemed.rewardId}) successfully redeemed by user ${userId}. Activity logged.`);
            return redeemed;
        });
        return updatedGrantedReward;
    } catch (error) {
        console.error(`[CUST_SVC] Error redeeming granted reward ${grantedRewardId} for user ${userId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error("El regalo no se encontr√≥ o ya no estaba pendiente al intentar canjearlo."); } throw new Error(`Error de base de datos al canjear el regalo: ${error.message}`); }
        if (error instanceof Error) { throw error; }
        throw new Error('Error inesperado al canjear el regalo.');
    }
};

export const getCustomerFacingBusinessConfig = async (businessId: string): Promise<CustomerBusinessConfig> => {
    console.log(`[CUST_SVC] Fetching customer-facing config for business: ${businessId}`);
    try {
        const config = await prisma.business.findUnique({
            where: { id: businessId },
            select: { tierCalculationBasis: true }
        });
        if (!config) {
            console.warn(`[CUST_SVC] Business not found when fetching config: ${businessId}`);
            return null;
        }
        return { tierCalculationBasis: config.tierCalculationBasis ?? null };
    } catch (error) {
        console.error(`[CUST_SVC] Error fetching customer-facing config for business ${businessId}:`, error);
        throw new Error('Error al obtener la configuraci√≥n del negocio.');
    }
};

export const getAvailableCouponsForUser = async (userId: string): Promise<GrantedReward[]> => {
    console.log(`[CUST_SVC] Fetching available coupons (GrantedRewards) for user ${userId}`);
    try {
        const coupons = await prisma.grantedReward.findMany({
            where: {
                userId: userId,
                status: GrantedRewardStatus.AVAILABLE,
            },
            include: {
                reward: true 
            },
            orderBy: {
                assignedAt: 'desc'
            }
        });
        return coupons;
    } catch (error) {
        console.error(`[CUST_SVC] Error fetching available coupons for user ${userId}:`, error);
        throw new Error('Error al obtener los cupones disponibles.');
    }
};

export const getCustomerOrders = async (userId: string, page: number, limit: number): Promise<PaginatedOrdersResponse> => {
    console.log(`[CUST_SVC] Fetching order history for user ${userId}, Page: ${page}, Limit: ${limit}`);
    const skip = (page - 1) * limit;
    const whereClause: Prisma.OrderWhereInput = {
        customerLCoId: userId,
        status: OrderStatus.PAID,
    };
    try {
        const [totalItems, orders] = await prisma.$transaction([
            prisma.order.count({ where: whereClause }),
            prisma.order.findMany({
                where: whereClause,
                select: {
                    id: true,
                    orderNumber: true,
                    finalAmount: true,
                    paidAt: true,
                    items: {
                        where: { status: { not: 'CANCELLED' } },
                        select: {
                            itemNameSnapshot: true,
                            quantity: true,
                            totalItemPrice: true,
                            priceAtPurchase: true,
                            redeemedRewardId: true,
                            selectedModifiers: {
                                select: {
                                    optionNameSnapshot: true,
                                    optionPriceAdjustmentSnapshot: true,
                                }
                            }
                        }
                    }
                },
                orderBy: { paidAt: 'desc' },
                skip: skip,
                take: limit,
            })
        ]);
        const totalPages = Math.ceil(totalItems / limit);
        console.log(`[CUST_SVC] Found ${orders.length} orders for user ${userId} on page ${page}. Total: ${totalItems}`);
        return {
            orders: orders as OrderHistoryItem[],
            totalPages,
            currentPage: page,
            totalItems,
        };
    } catch (error) {
        console.error(`[CUST_SVC] Error fetching order history for user ${userId}:`, error);
        throw new Error('Error al obtener el historial de pedidos desde la base de datos.');
    }
};


// ====== [65] backend/src/modules/loyalpyme/customer/profile.controller.ts ======
// backend/src/modules/loyalpyme/customer/profile.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as profileService from './profile.service';
import { uploadImageToCloudinary } from '../../../shared/uploads/uploads.service';

interface UpdateProfileDto {
    name?: string;
    phone?: string;
}

interface ChangePasswordDto {
    currentPassword?: string;
    newPassword?: string;
}

export const getProfileHandler = (req: Request, res: Response) => {
    if (!req.user) {
        return res.status(401).json({ message: 'Usuario no autenticado.' });
    }
    res.status(200).json(req.user);
};

export const updateProfileHandler = async (req: Request, res: Response, next: NextFunction) => {
    const userId = req.user?.id;
    if (!userId) {
        return res.status(401).json({ message: 'Usuario no autenticado.' });
    }

    // --- CORRECCI√ìN PRINCIPAL: Leer campos de texto desde req.body ---
    // Cuando se usa multer, los campos de texto del FormData est√°n en req.body
    const { name, phone }: UpdateProfileDto = req.body;
    let imageUrl: string | undefined = undefined;

    try {
        if (req.file && req.file.buffer) {
            console.log(`[PROFILE_CTRL] Imagen de perfil recibida para user ${userId}. Subiendo a Cloudinary...`);
            const folderName = `loyalpyme/avatars/${process.env.NODE_ENV || 'development'}`;
            imageUrl = await uploadImageToCloudinary(req.file.buffer, folderName);
            console.log(`[PROFILE_CTRL] Imagen subida exitosamente. URL: ${imageUrl}`);
        }

        // Construir el objeto de datos a actualizar
        const updateData: { name?: string; phone?: string; imageUrl?: string } = {};
        
        // --- CORRECCI√ìN: Usar los valores le√≠dos de req.body ---
        if (name !== undefined) updateData.name = name;
        if (phone !== undefined) updateData.phone = phone;
        // --- FIN CORRECCI√ìN ---
        
        if (imageUrl !== undefined) updateData.imageUrl = imageUrl;
        
        if (Object.keys(updateData).length === 0) {
            return res.status(400).json({ message: 'No se proporcionaron datos para actualizar.' });
        }

        // Llamar al servicio para actualizar la BD
        const updatedUser = await profileService.updateUserProfile(userId, updateData);

        res.status(200).json(updatedUser);

    } catch (error) {
        next(error);
    }
};

export const changePasswordHandler = async (req: Request, res: Response, next: NextFunction) => {
    const userId = req.user?.id;
    if (!userId) {
        return res.status(401).json({ message: 'Usuario no autenticado.' });
    }

    const { currentPassword, newPassword }: ChangePasswordDto = req.body;

    if (!currentPassword || !newPassword) {
        return res.status(400).json({ message: 'Se requieren la contrase√±a actual y la nueva contrase√±a.' });
    }
    if (newPassword.length < 6) {
        return res.status(400).json({ message: 'La nueva contrase√±a debe tener al menos 6 caracteres.' });
    }
    if (currentPassword === newPassword) {
        return res.status(400).json({ message: 'La nueva contrase√±a no puede ser igual a la actual.' });
    }

    try {
        await profileService.changeUserPassword(userId, currentPassword, newPassword);
        res.status(200).json({ message: 'Contrase√±a actualizada correctamente.' });
    } catch (error) {
        next(error);
    }
};


// ====== [66] backend/src/modules/loyalpyme/customer/profile.service.ts ======
// backend/src/modules/loyalpyme/customer/profile.service.ts
import { PrismaClient, Prisma, User } from '@prisma/client';
import { hashPassword, comparePassword } from '../../../shared/auth/auth.service';
import { isValidPhoneNumber } from '../../../shared/utils/validation';

const prisma = new PrismaClient();

// Tipo para los datos que se pueden actualizar en el perfil
interface ProfileUpdateData {
    name?: string;
    phone?: string;
    imageUrl?: string;
}

/**
 * Actualiza los datos del perfil de un usuario en la base de datos.
 * Realiza validaciones de unicidad si es necesario.
 * @param userId - El ID del usuario a actualizar.
 * @param data - Los datos a actualizar.
 * @returns El objeto User actualizado (sin campos sensibles).
 */
export const updateUserProfile = async (
    userId: string,
    data: ProfileUpdateData
): Promise<Omit<User, 'password' | 'resetPasswordToken' | 'resetPasswordExpires'>> => {
    
    // --- CORRECCI√ìN 1: L√≥gica de validaci√≥n movida aqu√≠, al servicio ---
    if (data.phone) {
        if (!isValidPhoneNumber(data.phone)) {
            throw new Error('El formato del n√∫mero de tel√©fono no es v√°lido.');
        }
        const existingUserWithPhone = await prisma.user.findFirst({
            where: { 
                phone: data.phone,
                id: { not: userId } // Asegurarse de que no es el propio usuario
            },
        });
        if (existingUserWithPhone) {
            throw new Error('El n√∫mero de tel√©fono ya est√° en uso por otra cuenta.');
        }
    }
    // --- FIN CORRECCI√ìN 1 ---
    
    try {
        // --- CORRECCI√ìN 2: Asegurarse de que 'data' se pasa directamente ---
        // El objeto 'data' ya contiene los campos correctos ('name', 'phone', 'imageUrl')
        // que coinciden con el modelo de Prisma, por lo que se puede pasar directamente.
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: data, // <-- ESTA ES LA CORRECCI√ìN CLAVE
            select: {
                id: true, email: true, name: true, phone: true, documentId: true, documentType: true,
                role: true, points: true, totalSpend: true, totalVisits: true,
                currentTierId: true, isFavorite: true, isActive: true, imageUrl: true,
                createdAt: true, updatedAt: true, lastActivityAt: true, tierAchievedAt: true,
                businessId: true, adminNotes: true,
            }
        });
        console.log(`[PROFILE_SVC] Perfil del usuario ${userId} actualizado correctamente en la BD.`);
        return updatedUser;

    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            if (error.code === 'P2002') { // Error de unicidad
                const target = (error.meta?.target as string[]) || [];
                if (target.includes('phone')) {
                     throw new Error('El n√∫mero de tel√©fono ya est√° registrado.');
                }
                throw new Error('Error de conflicto: Los datos proporcionados ya est√°n en uso.');
            }
            if (error.code === 'P2025') { // Registro no encontrado
                 throw new Error(`Usuario con ID ${userId} no encontrado para actualizar.`);
            }
        }
        console.error(`[PROFILE_SVC] Error al actualizar el perfil del usuario ${userId}:`, error);
        throw new Error('Error de base de datos al actualizar el perfil.');
    }
};


/**
 * Cambia la contrase√±a de un usuario.
 * @param userId - El ID del usuario.
 * @param currentPassword - La contrase√±a actual para verificaci√≥n.
 * @param newPassword - La nueva contrase√±a a establecer.
 */
export const changeUserPassword = async (
    userId: string,
    currentPassword: string,
    newPassword: string
): Promise<void> => {
    
    const user = await prisma.user.findUnique({ where: { id: userId } });
    if (!user) {
        throw new Error('Usuario no encontrado.');
    }

    const isMatch = await comparePassword(currentPassword, user.password);
    if (!isMatch) {
        throw new Error('La contrase√±a actual es incorrecta.');
    }

    const hashedNewPassword = await hashPassword(newPassword);

    await prisma.user.update({
        where: { id: userId },
        data: { password: hashedNewPassword },
    });

    console.log(`[PROFILE_SVC] Contrase√±a del usuario ${userId} actualizada correctamente.`);
};


// ====== [67] backend/src/modules/loyalpyme/points/points.controller.ts ======
// filename: backend/src/points/points.controller.ts
// Version: 1.3.0 (Handle updated return value from validateQrCode service)

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client';
// --- MODIFICACI√ìN: Importar tambi√©n ValidateQrResult ---
import { generateQrCodeData, validateQrCode, redeemReward, ValidateQrResult } from './points.service';
// --- FIN MODIFICACI√ìN ---

// DTOs (sin cambios)
export interface GenerateQrDto {
    amount: number;
    ticketNumber: string;
}
export interface ValidateQrDto {
    qrToken: string;
}

/**
 * Handles the request to generate QR code data for a points transaction.
 * POST /api/points/generate-qr
 */
export const generateQrHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId || !req.user.role) {
        console.error("[POINTS CTRL] Critical: User context missing in generateQrHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const businessId = req.user.businessId;
    const role = req.user.role;

    if (role !== 'BUSINESS_ADMIN') {
        return res.status(403).json({ message: 'Acceso denegado. Solo administradores pueden generar c√≥digos QR.' });
    }

    const { amount, ticketNumber }: GenerateQrDto = req.body;
    if (amount === undefined || typeof amount !== 'number' || amount <= 0) {
         return res.status(400).json({ message: 'Transaction amount must be a positive number.' });
    }
    if (!ticketNumber || typeof ticketNumber !== 'string' || ticketNumber.trim() === '') {
         return res.status(400).json({ message: 'Ticket number is required.' });
    }

    try {
        const qrData = await generateQrCodeData(businessId, amount, ticketNumber.trim());
        res.status(201).json(qrData);
    } catch (error: unknown) {
        if (error instanceof Error) {
             return res.status(400).json({ message: error.message });
        }
        console.error('Server error in generateQrHandler (unexpected):', error);
        next(new Error('Error del servidor al generar c√≥digo QR.'));
    }
};


/**
 * Handles the request to validate a QR token and assign points to the customer.
 * POST /api/points/validate-qr
 */
export const validateQrHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.id || !req.user.role) {
        console.error("[POINTS CTRL] Critical: User context missing in validateQrHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const customerUserId = req.user.id;
    const role = req.user.role;

    if (role !== 'CUSTOMER_FINAL') {
         console.warn(`User ${customerUserId} with role ${role} attempted to validate QR.`);
         return res.status(403).json({ message: 'Acceso denegado. Solo cuentas de cliente pueden validar c√≥digos QR.' });
    }

    const { qrToken }: ValidateQrDto = req.body;
    if (!qrToken) {
         return res.status(400).json({ message: 'Se requiere el token QR.' });
    }

    try {
        // --- MODIFICACI√ìN: Capturar el objeto ValidateQrResult completo ---
        const result: ValidateQrResult = await validateQrCode(qrToken, customerUserId);
        // --- FIN MODIFICACI√ìN ---

        // --- MODIFICACI√ìN: Devolver el objeto updatedUser en la respuesta ---
        res.status(200).json({
            message: 'C√≥digo QR validado con √©xito. Puntos asignados.',
            pointsEarned: result.pointsEarned,
            user: result.updatedUser // Devolver los datos actualizados del usuario
        });
        // --- FIN MODIFICACI√ìN ---

    } catch (error: unknown) {
         if (error instanceof Error) {
             console.error('Error in validateQrHandler (service error):', error.message);
             return res.status(400).json({ message: error.message });
         }
         console.error('Server error in validateQrHandler (unexpected):', error);
         next(new Error('Ocurri√≥ un error interno durante la validaci√≥n del QR.'));
    }
};


/**
 * Handles the request to redeem a specific reward using customer points.
 * POST /api/points/redeem-reward/:rewardId
 */
export const redeemRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.id || !req.user.role) {
       console.error("[POINTS CTRL] Critical: User context missing in redeemRewardHandler.");
       return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
   }
   const userId = req.user.id;
   const role = req.user.role;
    const rewardId = req.params.rewardId;

    console.log(`[REDEEM CTRL] Handling request for user ${userId}, reward ${rewardId}`);

    if (role !== 'CUSTOMER_FINAL') {
        console.warn(`[REDEEM CTRL] Access denied for user ${userId || 'unknown'} with role ${role}.`);
        return res.status(403).json({ message: 'Acceso denegado. Solo cuentas de cliente autenticadas pueden canjear recompensas.' });
    }
    if (!rewardId) {
        console.error('[REDEEM CTRL] Reward ID missing from request parameters.');
        return res.status(400).json({ message: 'Se requiere el ID de la recompensa.' });
    }

    try {
        console.log(`[REDEEM CTRL] Calling redeemReward service for user ${userId} and reward ${rewardId}...`);
        const result = await redeemReward(userId, rewardId);
        console.log(`[REDEEM CTRL] Service call successful for user ${userId}, reward ${rewardId}.`);
        res.status(200).json(result);
    } catch (error: unknown) {
        console.error(`[REDEEM CTRL - ERROR] Error redeeming reward for user ${userId}, reward ${rewardId}:`, error);
        if (error instanceof Error) {
            return res.status(400).json({ message: error.message });
        }
        next(new Error('Error interno del servidor durante el canje de recompensa.'));
    }
};

// End of File: backend/src/points/points.controller.ts


// ====== [68] backend/src/modules/loyalpyme/points/points.service.ts ======
// backend/src/points/points.service.ts
import {
    PrismaClient,
    User,
    Reward,
    QrCode,
    Business, // Aseg√∫rate que Business est√° importado si lo usas directamente en tipos
    QrCodeStatus,
    UserRole,
    Prisma,
    TierBenefit,
    TierCalculationBasis,
    // Tier, // Tier no se usa directamente en este archivo
    // TierDowngradePolicy, // No se usa directamente
    ActivityType
} from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import { addMinutes, isAfter } from 'date-fns';
import { updateUserTier } from '../tiers/tier-logic.service';

const prisma = new PrismaClient();
const QR_EXPIRATION_MINUTES = 30; // O lee de config si es din√°mico por negocio

// Tipos y Interfaces
interface RedeemResult {
    message: string;
    newPointsBalance: number;
}

// Tipo para el resultado de QR validado, incluyendo datos del usuario actualizados
export interface ValidateQrResult {
    pointsEarned: number;
    updatedUser: { // Estructura devuelta al frontend
        id: string;
        points: number;
        totalSpend: number; // Asegurar que este campo se actualiza y devuelve
        totalVisits: number; // Asegurar que este campo se actualiza y devuelve
        currentTierId: string | null;
        currentTierName: string | null; // Nombre del tier
    };
}


// Tipos internos para helpers
type ValidQrCode = QrCode & {
    business: Pick<Business, 'id' | 'pointsPerEuro' | 'tierSystemEnabled' | 'tierCalculationBasis'>; // Ajustado
    ticketNumber: string; // Asegurar que no sea null
};

type ValidCustomer = User & {
    currentTier: ({ benefits: TierBenefit[] } & { id: string; name: string }) | null;
    businessId: string; // <--- Aseguramos que aqu√≠ businessId NO es null
};


// ==============================================
// HELPER FUNCTIONS for validateQrCode (Internal)
// ==============================================

const _findAndValidateQrCodeRecord = async (qrToken: string, now: Date): Promise<ValidQrCode> => {
    const qrCode = await prisma.qrCode.findUnique({
        where: { token: qrToken },
        include: {
            business: { // Seleccionar solo lo necesario de business
                select: { id: true, pointsPerEuro: true, tierSystemEnabled: true, tierCalculationBasis: true }
            }
        }
    });

    if (!qrCode) { throw new Error('C√≥digo QR inv√°lido.'); }
    if (qrCode.status !== QrCodeStatus.PENDING) {
        if (qrCode.status === QrCodeStatus.COMPLETED) throw new Error('El c√≥digo QR ya ha sido utilizado.');
        if (qrCode.status === QrCodeStatus.EXPIRED) throw new Error('El c√≥digo QR ha expirado.');
        throw new Error('El c√≥digo QR no est√° disponible para canjear.');
    }
    if (isAfter(now, qrCode.expiresAt)) {
        try {
            await prisma.qrCode.update({ where: { id: qrCode.id }, data: { status: QrCodeStatus.EXPIRED } });
            console.log(`[Points SVC Helper] QR code ${qrToken} marked as EXPIRED.`);
        } catch (updateError) {
            console.error(`[Points SVC Helper] Failed to update QR status to EXPIRED for token ${qrToken}:`, updateError);
        }
        throw new Error('El c√≥digo QR ha expirado.');
    }
    if (!qrCode.business) {
        console.error(`[Points SVC Helper] QR code ${qrCode.id} has no associated business!`);
        throw new Error('Error interno: El QR no est√° asociado a un negocio.');
    }
    if (qrCode.ticketNumber === null) { // Aunque el schema lo hace no-nulo, una verificaci√≥n extra no da√±a
        console.error(`[Points SVC Helper] QR code ${qrCode.id} has null ticketNumber!`);
        throw new Error('Error interno: Falta n√∫mero de ticket en QR.');
    }
    return qrCode as ValidQrCode; // Casteo seguro despu√©s de las validaciones
};

const _findAndValidateCustomerForQr = async (userId: string, qrCodeBusinessId: string): Promise<ValidCustomer> => {
    const customer = await prisma.user.findUnique({
        where: { id: userId },
        include: { currentTier: { include: { benefits: { where: { isActive: true } } } } }
    });

    if (!customer || customer.role !== UserRole.CUSTOMER_FINAL) {
        throw new Error('Solo las cuentas de cliente pueden canjear c√≥digos QR.');
    }
    if (!customer.businessId) { // <--- A√ëADIDA ESTA VALIDACI√ìN
        console.error(`[Points SVC Helper] Customer ${userId} has no businessId! This should not happen for CUSTOMER_FINAL.`);
        throw new Error('Error interno: El cliente no est√° asociado a ning√∫n negocio.');
    }
    if (customer.businessId !== qrCodeBusinessId) {
        throw new Error('El c√≥digo QR no es v√°lido para el negocio de este cliente.');
    }
    return customer as ValidCustomer; // Casteo seguro
};

const _calculatePointsEarned = (qrAmount: number, businessConfig: ValidQrCode['business'], customer: ValidCustomer): number => {
    let effectivePoints = qrAmount * (businessConfig.pointsPerEuro ?? 1); // Usar 1 si pointsPerEuro es null/undefined
    const multiplierBenefit = customer.currentTier?.benefits.find(b => b.type === 'POINTS_MULTIPLIER');
    if (multiplierBenefit) {
        const multiplier = parseFloat(multiplierBenefit.value);
        if (!isNaN(multiplier) && multiplier > 0) {
            effectivePoints *= multiplier;
            console.log(`[Points SVC Helper] Applied tier multiplier ${multiplier} for user ${customer.id}`);
        } else {
            console.warn(`[Points SVC Helper] Invalid multiplier value '${multiplierBenefit.value}' for tier ${customer.currentTier?.id}`);
        }
    }
    const calculatedPoints = Math.floor(effectivePoints);
    return calculatedPoints < 0 ? 0 : calculatedPoints; // Asegurar que no sean negativos
};

const _performQrValidationTransaction = async (
    tx: Prisma.TransactionClient,
    qrCode: ValidQrCode,
    customerId: string, // Este es el ID del usuario que valid√≥
    customerBusinessId: string, // <--- A√ëADIDO: El businessId del cliente que valid√≥
    pointsEarned: number,
    now: Date
): Promise<void> => {
    await tx.user.update({
        where: { id: customerId },
        data: {
            points: { increment: pointsEarned },
            lastActivityAt: now,
            totalVisits: { increment: 1 },
            totalSpend: { increment: qrCode.amount },
        },
    });
    await tx.qrCode.update({
        where: { id: qrCode.id },
        data: {
            status: QrCodeStatus.COMPLETED,
            completedAt: now,
            userId: customerId,
            pointsEarned: pointsEarned
        },
    });

    // --- CORRECCI√ìN EN ActivityLog ---
    await tx.activityLog.create({
        data: {
            userId: customerId,
            // businessId de la actividad debe ser el del negocio del cliente,
            // que ya validamos que es el mismo que el del QR.
            businessId: customerBusinessId, // <--- USAR EL businessId DEL CLIENTE
            type: ActivityType.POINTS_EARNED_QR,
            pointsChanged: pointsEarned,
            description: qrCode.ticketNumber, // ticketNumber ahora es string
            relatedQrId: qrCode.id,
        }
    });
    // --- FIN CORRECCI√ìN ---
    console.log(`[Points SVC Helper TX] User, QR, and ActivityLog updated for QR ${qrCode.id}`);
};


// ==================================
// Funciones de Servicio Exportadas
// ==================================

export const generateQrCodeData = async (businessId: string, amount: number, ticketNumber: string): Promise<{ qrToken: string; amount: number }> => {
    if (amount <= 0 || typeof amount !== 'number') {
        throw new Error('El importe de la transacci√≥n debe ser un n√∫mero positivo.');
    }
    const token = uuidv4();
    const expiresAt = addMinutes(new Date(), QR_EXPIRATION_MINUTES); // Considerar usar qrCodeExpirationMinutes del Business
    try {
        const qrCode = await prisma.qrCode.create({
            data: { token, businessId, amount, ticketNumber, expiresAt, status: QrCodeStatus.PENDING },
            select: { token: true, amount: true }
        });
        console.log(`[Points SVC] QR Code generated for business ${businessId} with token ${token} for amount ${amount}, ticket: ${ticketNumber}.`);
        return { qrToken: qrCode.token, amount: qrCode.amount };
    } catch (error: unknown) {
        console.error('[Points SVC] Error generating QR code data:', error);
        throw new Error('No se pudieron generar los datos del c√≥digo QR.');
    }
};


export const validateQrCode = async (qrToken: string, customerUserId: string): Promise<ValidateQrResult> => {
    const now = new Date();
    console.log(`[Points SVC] Validating QR token starting with ${qrToken.substring(0, 5)}... for user ${customerUserId}`);
    try {
        const qrCode = await _findAndValidateQrCodeRecord(qrToken, now);
        const customer = await _findAndValidateCustomerForQr(customerUserId, qrCode.businessId); // customer.businessId aqu√≠ NO es null
        const calculatedPointsEarned = _calculatePointsEarned(qrCode.amount, qrCode.business, customer);

        await prisma.$transaction(async (tx) => {
            // Pasamos customer.businessId (que sabemos que no es null)
            await _performQrValidationTransaction(
                tx,
                qrCode,
                customerUserId,
                customer.businessId, // <--- PASAR EL businessId del cliente
                calculatedPointsEarned,
                now
            );
        });
        console.log(`[Points SVC] Transaction successful for QR ${qrCode.id} and user ${customerUserId}.`);

        // L√≥gica de actualizaci√≥n de Tier (sin cambios)
        if (qrCode.business.tierSystemEnabled) {
            console.log(`[Points SVC] Triggering tier update for user ${customerUserId} (async)`);
            updateUserTier(customerUserId).catch(err => {
                console.error(`[Points SVC] Background tier update failed for user ${customerUserId}:`, err);
            });
        }

        // Esperar un poco para que la actualizaci√≥n de tier se refleje si es s√≠ncrona (no es el caso ideal)
        // O mejor, el updateUserTier deber√≠a devolver el usuario actualizado o refetchear aqu√≠.
        // Por ahora, un peque√±o delay puede ayudar en algunos casos de prueba, pero no es robusto.
        // await new Promise(resolve => setTimeout(resolve, 150)); // Considerar quitar esto

        const updatedUserData = await prisma.user.findUniqueOrThrow({
            where: { id: customerUserId },
            select: {
                id: true,
                points: true,
                totalSpend: true,
                totalVisits: true,
                currentTierId: true,
                currentTier: { select: { name: true } }
            }
        });
        console.log(`[Points SVC] Fetched latest user data post-validation for ${customerUserId}: TierId=${updatedUserData.currentTierId}`);

        return {
            pointsEarned: calculatedPointsEarned,
            updatedUser: {
                id: updatedUserData.id,
                points: updatedUserData.points,
                totalSpend: updatedUserData.totalSpend ?? 0,
                totalVisits: updatedUserData.totalVisits ?? 0,
                currentTierId: updatedUserData.currentTierId,
                currentTierName: updatedUserData.currentTier?.name ?? null
            }
        };
    } catch (error: unknown) {
        // ... (manejo de errores sin cambios) ...
        if (error instanceof Error && (
            error.message.startsWith('C√≥digo QR inv√°lido') ||
            error.message.includes('ya ha sido utilizado') ||
            error.message.includes('ha expirado') ||
            error.message.includes('no est√° disponible para canjear') ||
            error.message.includes('Solo las cuentas de cliente') ||
            error.message.includes('no es v√°lido para el negocio')
        )) {
            console.warn(`[Points SVC] Validation failed for token ${qrToken}: ${error.message}`);
            throw error; // Relanzar el error espec√≠fico para el controlador
        }
        console.error(`[Points SVC] Unexpected error validating token ${qrToken}:`, error);
        throw new Error('Ocurri√≥ un error interno del servidor durante la validaci√≥n del QR.');
    }
};


export const redeemReward = async (customerUserId: string, rewardId: string): Promise<RedeemResult> => {
    console.log(`[Points SVC] Redeeming standard reward ${rewardId} for user ${customerUserId}`);
    try {
        const user = await prisma.user.findUniqueOrThrow({
            where: { id: customerUserId },
            select: { id: true, points: true, businessId: true, role: true }
        });

        if (!user.businessId) { // <--- CHEQUEO IMPORTANTE
            console.error(`[Points SVC] Customer ${customerUserId} attempting to redeem reward but has no businessId.`);
            throw new Error("El usuario cliente no est√° asociado a ning√∫n negocio.");
        }

        const reward = await prisma.reward.findUniqueOrThrow({
            where: { id: rewardId },
            select: {
                id: true, name_es: true, name_en: true,
                pointsCost: true, isActive: true, businessId: true
            }
        });

        if (user.role !== UserRole.CUSTOMER_FINAL) { throw new Error('Rol de usuario inv√°lido para canjear recompensas.'); }
        if (user.businessId !== reward.businessId) { throw new Error('La recompensa no pertenece al negocio del cliente.'); }
        if (!reward.isActive) { throw new Error('Esta recompensa est√° actualmente inactiva.'); }

        const rewardDisplayName = reward.name_es || reward.name_en || `ID ${rewardId}`;
        if (user.points < reward.pointsCost) {
            throw new Error(`Puntos insuficientes para canjear "${rewardDisplayName}". Necesarios: ${reward.pointsCost}, Disponibles: ${user.points}`);
        }

        const updatedUser = await prisma.$transaction(async (tx) => {
            const resultUser = await tx.user.update({
                where: { id: customerUserId },
                data: { points: { decrement: reward.pointsCost } },
                select: { id: true, points: true }
            });

            // --- CORRECCI√ìN EN ActivityLog ---
            await tx.activityLog.create({
                data: {
                    userId: customerUserId,
                    businessId: user.businessId!, // Usamos '!' porque ya validamos que no es null
                    type: ActivityType.POINTS_REDEEMED_REWARD,
                    pointsChanged: -reward.pointsCost,
                    description: reward.name_es || reward.name_en,
                    relatedRewardId: rewardId
                }
            });
            // --- FIN CORRECCI√ìN ---

            console.log(`[Points SVC - TX SUCCESS] User ${resultUser.id} redeemed reward '${rewardDisplayName}' (${reward.id}) for ${reward.pointsCost} points. Activity logged. New balance: ${resultUser.points}.`);
            return resultUser;
        });

        return {
            message: `¬°Recompensa '${rewardDisplayName}' canjeada con √©xito!`,
            newPointsBalance: updatedUser.points
        };
    } catch (error: unknown) {
        // ... (manejo de errores sin cambios) ...
        console.error(`[Points SVC - ERROR] Failed to redeem reward for user ${customerUserId}, reward ${rewardId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error('No se encontr√≥ el usuario o la recompensa especificada.');
        }
        if (error instanceof Error) { throw error; } // Relanzar errores espec√≠ficos ya lanzados
        throw new Error('Ocurri√≥ un error inesperado durante el canje de la recompensa.');
    }
};


// ====== [69] backend/src/modules/loyalpyme/rewards/rewards.controller.ts ======
// frontend/src/modules/loyalpyme/rewards/rewards.controller.ts
// Version 3.0.0 - REMOVED handlers for obsolete redeem/coupon flow.

import { Request, Response, NextFunction } from 'express';
import { RewardType, DiscountType } from '@prisma/client';

// --- SERVICE IMPORTS UPDATED ---
// Import only the CRUD services that are still in use.
import {
    createReward,
    findRewardsByBusiness,
    findRewardById,
    updateReward,
    deleteReward,
} from './rewards.service';

// --- DTOs (No change) ---
export interface CreateRewardDto {
    name_es: string;
    name_en: string;
    description_es?: string | null;
    description_en?: string | null;
    pointsCost: number;
    imageUrl?: string | null;
    type: RewardType;
    discountType?: DiscountType | null;
    discountValue?: number;
    linkedMenuItemId?: string | null;
    kdsDestination?: string | null;
}

export type UpdateRewardDto = Partial<CreateRewardDto & { isActive?: boolean }>;

// --- CRUD HANDLERS (Remain for Admin Panel) ---

/**
 * Handles creation of a new reward.
 * POST /api/rewards
 */
export const createRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) {
        return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." });
    }
    
    const rewardData: CreateRewardDto = req.body;

    try {
        const newReward = await createReward({
            ...rewardData,
            businessId: req.user.businessId,
        });
        res.status(201).json(newReward);
    } catch (error) {
        console.error('[REWARDS CTRL] Error creating reward:', error);
        if (error instanceof Error) {
            if (error.message.includes('unicidad') || error.message.includes('ya existe')) {
                return res.status(409).json({ message: error.message });
            }
            return res.status(500).json({ message: error.message });
        }
        next(new Error('Error del servidor al crear la recompensa.'));
    }
};

/**
 * Handles fetching all rewards for the authenticated business.
 * GET /api/rewards
 */
export const getRewardsHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.businessId) { return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." }); }
    const businessId = req.user.businessId;
    try {
        const rewards = await findRewardsByBusiness(businessId);
        res.status(200).json(rewards);
    } catch (error) {
        console.error('[REWARDS CTRL] Error fetching rewards:', error);
        next(new Error('Error del servidor al obtener recompensas.'));
    }
};

/**
 * Handles fetching a single reward by ID.
 * GET /api/rewards/:id
 */
export const getRewardByIdHandler = async (req: Request, res: Response, next: NextFunction) => {
   if (!req.user || !req.user.businessId) { return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." }); }
    const businessId = req.user.businessId;
    const rewardId = req.params.id;
    if (!rewardId) { return res.status(400).json({ message: 'Se requiere el ID de la recompensa en la URL.' }); }
    try {
        const reward = await findRewardById(rewardId, businessId);
        if (!reward) { return res.status(404).json({ message: 'Recompensa no encontrada o no pertenece a tu negocio.' }); }
        res.status(200).json(reward);
    } catch (error) {
        console.error('[REWARDS CTRL] Error fetching reward by ID:', error);
        next(new Error('Error del servidor al obtener la recompensa por ID.'));
    }
};

/**
 * Handles updating an existing reward (handles PUT and PATCH).
 * PUT/PATCH /api/rewards/:id
 */
export const updateRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.businessId) { return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." }); }
    const businessId = req.user.businessId;
    const rewardId = req.params.id;
    const updateData: UpdateRewardDto = req.body;

    if (!rewardId) { return res.status(400).json({ message: 'Se requiere el ID de la recompensa en la URL.' }); }
    if (Object.keys(updateData).length === 0) { return res.status(400).json({ message: 'Se requieren datos de actualizaci√≥n.' }); }

    try {
        const updatedReward = await updateReward(rewardId, businessId, updateData);
        res.status(200).json(updatedReward);
    } catch (error) {
        console.error('[REWARDS CTRL] Error updating reward:', error);
        if (error instanceof Error) {
            if (error.message.includes('no encontrada')) { return res.status(404).json({ message: error.message }); }
            if (error.message.includes('unicidad')) { return res.status(409).json({ message: error.message }); }
            return res.status(500).json({ message: error.message });
        }
        next(new Error('Error del servidor al actualizar la recompensa.'));
    }
};

/**
 * Handles deletion of an existing reward. DELETE /api/rewards/:id
 */
export const deleteRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) { return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." }); }
    const businessId = req.user.businessId;
    const rewardId = req.params.id;
    if (!rewardId) { return res.status(400).json({ message: 'Se requiere el ID de la recompensa en la URL.' }); }
    try {
        const deletedReward = await deleteReward(rewardId, businessId);
        res.status(200).json({ message: 'Recompensa eliminada con √©xito.', deletedReward });
    } catch (error) {
        console.error('[REWARDS CTRL] Error deleting reward:', error);
        if (error instanceof Error) {
            if (error.message.includes('no encontrada')) { return res.status(404).json({ message: error.message }); }
            if (error.message.includes('siendo utilizada')) { return res.status(409).json({ message: error.message }); }
            return res.status(500).json({ message: error.message });
        }
        next(new Error('Error del servidor al eliminar la recompensa.'));
    }
};


// --- HANDLERS OBSOLETOS (ELIMINADOS) ---

// La funci√≥n `redeemRewardForLaterHandler` ha sido eliminada.
// La funci√≥n `getAvailableRewardsHandler` ha sido eliminada.


// ====== [70] backend/src/modules/loyalpyme/rewards/rewards.service.ts ======
// backend/src/modules/loyalpyme/rewards/rewards.service.ts
// VERSI√ìN 3.0.0 - Eliminados los servicios de canje obsoletos (redeemRewardForLater, getAvailableRewardsForUser)

import { PrismaClient, Reward, Prisma, RewardType, DiscountType } from '@prisma/client';

const prisma = new PrismaClient();

// --- TIPOS DE DATOS ---
// Estos tipos se mantienen para el CRUD de recompensas desde el panel de admin.
interface CreateRewardData {
    name_es: string;
    name_en: string;
    description_es?: string | null;
    description_en?: string | null;
    pointsCost: number;
    businessId: string;
    imageUrl?: string | null;
    type: RewardType;
    discountType?: DiscountType | null;
    discountValue?: number | string | null;
    linkedMenuItemId?: string | null;
    kdsDestination?: string | null;
}

type UpdateRewardData = Partial<CreateRewardData & { isActive?: boolean }>;

// --- SERVICIOS CRUD (SE MANTIENEN PARA EL PANEL DE ADMIN) ---

export const createReward = async (rewardData: CreateRewardData): Promise<Reward> => {
    console.log(`[Rewards SVC] Creating reward for business ${rewardData.businessId}: ${rewardData.name_es}`);
    try {
        const newReward = await prisma.reward.create({
            data: {
                ...rewardData,
                // Prisma espera Decimal, por lo que convertimos el valor del descuento
                discountValue: rewardData.discountValue ? new Prisma.Decimal(rewardData.discountValue.toString()) : undefined,
            },
        });
        return newReward;
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            throw new Error(`Ya existe una recompensa con este nombre para el negocio.`);
        }
        console.error(`[Rewards SVC] Unexpected error creating reward:`, error);
        throw new Error('Error al crear la recompensa.');
    }
};

export const findRewardsByBusiness = async (businessId: string): Promise<Reward[]> => {
    console.log(`[Rewards SVC] Finding ALL rewards for business ${businessId}`);
    try {
        return await prisma.reward.findMany({
            where: { businessId: businessId },
            orderBy: [{ pointsCost: 'asc' }, { name_es: 'asc' }]
        });
    } catch (error) {
        console.error(`[Rewards SVC] Error finding rewards for business ${businessId}:`, error);
        throw new Error('Error al buscar las recompensas.');
    }
};

export const findRewardById = async (id: string, businessId: string): Promise<Reward | null> => {
    console.log(`[Rewards SVC] Finding reward by ID ${id} for business ${businessId}`);
    try {
        return await prisma.reward.findFirst({ where: { id, businessId } });
    } catch (error) {
        console.error(`[Rewards SVC] Error finding reward by ID ${id}:`, error);
        throw new Error('Error al buscar la recompensa por ID.');
    }
};

export const updateReward = async (id: string, businessId: string, updateData: UpdateRewardData): Promise<Reward> => {
    console.log(`[Rewards SVC] Updating reward ID ${id} for business ${businessId}`);
    const existingReward = await findRewardById(id, businessId);
    if (!existingReward) {
        throw new Error(`Recompensa con ID ${id} no encontrada o no pertenece al negocio.`);
    }
    try {
        const dataToUpdate: Prisma.RewardUpdateInput = { ...updateData };
        if (updateData.discountValue !== undefined && updateData.discountValue !== null) {
            dataToUpdate.discountValue = new Prisma.Decimal(updateData.discountValue.toString());
        }
        return await prisma.reward.update({
            where: { id },
            data: dataToUpdate,
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            throw new Error(`Conflicto de unicidad al actualizar la recompensa (el nombre ya existe).`);
        }
        console.error(`[Rewards SVC] Unexpected error updating reward ${id}:`, error);
        throw new Error('Error inesperado al actualizar la recompensa.');
    }
};

export const deleteReward = async (id: string, businessId: string): Promise<Reward> => {
    console.log(`[Rewards SVC] Deleting reward ID ${id} for business ${businessId}`);
    const existingReward = await findRewardById(id, businessId);
    if (!existingReward) {
        throw new Error(`Recompensa no encontrada.`);
    }
    // Verificar si est√° en uso en GrantedRewards
    const relatedGrantsCount = await prisma.grantedReward.count({ where: { rewardId: id } });
    if (relatedGrantsCount > 0) {
        throw new Error(`No se puede eliminar la recompensa "${existingReward.name_es}" porque est√° siendo utilizada en regalos o cupones ya asignados.`);
    }
    // Verificar si est√° en uso en Orders
    const relatedOrdersCount = await prisma.order.count({ where: { appliedLcoRewardId: id }});
    if (relatedOrdersCount > 0) {
        throw new Error(`No se puede eliminar la recompensa "${existingReward.name_es}" porque est√° siendo utilizada en pedidos hist√≥ricos.`);
    }

    try {
        return await prisma.reward.delete({ where: { id } });
    } catch (error) {
        console.error(`[Rewards SVC] Error deleting reward ${id}:`, error);
        throw new Error('Error inesperado al eliminar la recompensa.');
    }
};

// --- SERVICIOS DE CANJE OBSOLETOS (ELIMINADOS) ---
// La funci√≥n `redeemRewardForLater` ha sido eliminada.
// La funci√≥n `getAvailableRewardsForUser` ha sido eliminada.


// ====== [71] backend/src/modules/loyalpyme/tiers/__tests__/tier-logic.helpers.test.ts ======
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { determineTargetTier, calculateUserMetric } from '../tier-logic.helpers';
import { PrismaClient, TierCalculationBasis, QrCodeStatus } from '@prisma/client';

// Mock simple
const prismaMock = {
  qrCode: {
    aggregate: vi.fn(),
    count: vi.fn(),
  },
};


type ActiveTierInfo = {
  id: string;
  name: string;
  level: number;
  minValue: number;
};

describe('Tier Logic Helpers', () => {

  describe('determineTargetTier', () => {
    // ... (tests sin cambios) ...
    const mockActiveTiers: ActiveTierInfo[] = [
        { id: 'tier-oro', name: 'Oro', level: 3, minValue: 1000 },
        { id: 'tier-plata', name: 'Plata', level: 2, minValue: 500 },
        { id: 'tier-bronce', name: 'Bronce', level: 1, minValue: 100 },
      ];
      it('should return null if metric value is below the lowest tier threshold', () => {
        const metricValue = 50;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBeNull();
      });
      it('should return the lowest tier ID if metric value matches its threshold', () => {
        const metricValue = 100;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBe('tier-bronce');
      });
      it('should return the correct tier ID if metric value is between thresholds', () => {
        const metricValue = 650;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBe('tier-plata');
      });
      it('should return the highest tier ID if metric value meets its threshold', () => {
        const metricValue = 1000;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBe('tier-oro');
      });
      it('should return the highest tier ID if metric value exceeds the highest threshold', () => {
        const metricValue = 5000;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBe('tier-oro');
      });
      it('should return null if the list of active tiers is empty', () => {
        const metricValue = 500;
        const emptyTiers: ActiveTierInfo[] = [];
        const targetTierId = determineTargetTier(metricValue, emptyTiers);
        expect(targetTierId).toBeNull();
      });
       it('should handle tiers with minValue 0 correctly', () => {
         const tiersWithZero: ActiveTierInfo[] = [
           { id: 'tier-plata', name: 'Plata', level: 1, minValue: 100 },
           { id: 'tier-basico', name: 'Basico', level: 0, minValue: 0 },
         ];
         const metricValue = 50;
         const targetTierId = determineTargetTier(metricValue, tiersWithZero);
         expect(targetTierId).toBe('tier-basico');
       });
       it('should return the base tier ID if metric value is 0 and a tier starts at 0', () => {
         const tiersWithZero: ActiveTierInfo[] = [
             { id: 'tier-plata', name: 'Plata', level: 1, minValue: 100 },
             { id: 'tier-basico', name: 'Basico', level: 0, minValue: 0 },
           ];
         const metricValue = 0;
         const targetTierId = determineTargetTier(metricValue, tiersWithZero);
         expect(targetTierId).toBe('tier-basico');
       });
  });

  describe('calculateUserMetric', () => {
    const userId = 'test-user-id';
    const testStartDate = new Date('2024-01-01T00:00:00.000Z');

    beforeEach(() => {
      vi.resetAllMocks();
    });

    it('should calculate metric based on SPEND correctly', async () => {
      prismaMock.qrCode.aggregate.mockResolvedValue({ _sum: { amount: 150.75, pointsEarned: null } });
      // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
      // @ts-expect-error: prismaMock is intentionally simplified for this test
      const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.SPEND, undefined);
      // --- FIN CAMBIO ---
      expect(prismaMock.qrCode.aggregate).toHaveBeenCalledWith(expect.objectContaining({
        _sum: { amount: true },
        where: { userId: userId, status: QrCodeStatus.COMPLETED }
      }));
      expect(metric).toBe(150.75);
    });

    it('should calculate metric based on VISITS correctly', async () => {
      prismaMock.qrCode.count.mockResolvedValue(12);
       // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
       // @ts-expect-error: prismaMock is intentionally simplified for this test
      const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.VISITS, undefined);
       // --- FIN CAMBIO ---
      expect(prismaMock.qrCode.count).toHaveBeenCalledWith(expect.objectContaining({
        where: { userId: userId, status: QrCodeStatus.COMPLETED }
      }));
      expect(metric).toBe(12);
    });

    it('should calculate metric based on POINTS_EARNED correctly', async () => {
      prismaMock.qrCode.aggregate.mockResolvedValue({ _sum: { amount: null, pointsEarned: 5430 } });
       // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
       // @ts-expect-error: prismaMock is intentionally simplified for this test
      const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.POINTS_EARNED, undefined);
       // --- FIN CAMBIO ---
      expect(prismaMock.qrCode.aggregate).toHaveBeenCalledWith(expect.objectContaining({
        _sum: { pointsEarned: true },
        where: { userId: userId, status: QrCodeStatus.COMPLETED }
      }));
      expect(metric).toBe(5430);
    });

    it('should calculate metric based on SPEND with a start date', async () => {
      prismaMock.qrCode.aggregate.mockResolvedValue({ _sum: { amount: 99.50, pointsEarned: null } });
       // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
       // @ts-expect-error: prismaMock is intentionally simplified for this test
      const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.SPEND, testStartDate);
       // --- FIN CAMBIO ---
      expect(prismaMock.qrCode.aggregate).toHaveBeenCalledWith(expect.objectContaining({
        _sum: { amount: true },
        where: { userId: userId, status: QrCodeStatus.COMPLETED, completedAt: { gte: testStartDate } }
      }));
      expect(metric).toBe(99.50);
    });

     it('should return 0 if aggregation sum is null', async () => {
       prismaMock.qrCode.aggregate.mockResolvedValue({ _sum: { amount: null, pointsEarned: null } });
        // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
        // @ts-expect-error: prismaMock is intentionally simplified for this test
       const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.SPEND, undefined);
       // --- FIN CAMBIO ---
       expect(prismaMock.qrCode.aggregate).toHaveBeenCalled();
       expect(metric).toBe(0);
     });

     it('should return 0 if count is 0', async () => {
        prismaMock.qrCode.count.mockResolvedValue(0);
         // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
         // @ts-expect-error: prismaMock is intentionally simplified for this test
        const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.VISITS, undefined);
         // --- FIN CAMBIO ---
        expect(prismaMock.qrCode.count).toHaveBeenCalled();
        expect(metric).toBe(0);
      });

     it('should handle Prisma errors gracefully and return 0', async () => {
        prismaMock.qrCode.aggregate.mockRejectedValue(new Error("Database connection failed"));
         // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
         // @ts-expect-error: prismaMock is intentionally simplified for this test
        const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.SPEND, undefined);
         // --- FIN CAMBIO ---
        expect(prismaMock.qrCode.aggregate).toHaveBeenCalled();
        expect(metric).toBe(0);
      });
  });
});

// End of File: backend/src/tiers/__tests__/tier-logic.helpers.test.ts


// ====== [72] backend/src/modules/loyalpyme/tiers/tier-benefit.controller.ts ======
// filename: backend/src/tiers/tier-benefit.controller.ts
// Version: 1.0.1 (Fix encoding, remove @ts-ignore)

import { Request, Response, NextFunction } from 'express'; // Add NextFunction
import { Prisma } from '@prisma/client';
import * as TierBenefitService from './tier-benefit.service';
import * as TierService from './tiers.service';

// --- Handlers para CRUD de TierBenefits (Admin) ---

/**
 * Handler para crear un nuevo beneficio para un Tier espec√≠fico.
 * POST /api/tiers/tiers/:tierId/benefits
 */
export const createTierBenefitHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    // --- FIX: Check req.user ---
    if (!req.user || !req.user.businessId) {
        console.error("[TIER_BENEFIT_CTRL] Critical: User context missing in createTierBenefitHandler.");
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    // --- FIN FIX ---

    const { tierId } = req.params;
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier en la URL.' });

    const benefitData = req.body;
    console.log(`[TIER_BENEFIT_CTRL] Creating benefit for tier ${tierId}`);

     // Validaci√≥n b√°sica (mejorar con DTOs/Zod)
     if (!benefitData.type || !benefitData.value) {
         return res.status(400).json({ message: 'Tipo y valor son requeridos para el beneficio.' });
     }
     // TODO: Validaci√≥n m√°s profunda de 'type' y 'value' seg√∫n el tipo

    try {
        // Verificar que el Tier pertenece al negocio antes de crear el beneficio
        // Esta verificaci√≥n podr√≠a hacerse tambi√©n en el servicio, pero hacerla aqu√≠ es una capa extra.
        const tier = await TierService.findTierById(tierId, businessId);
        if (!tier) {
             return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }

        // Crear el beneficio asociado a ese tierId usando el servicio de beneficios
        const { type, value, description, isActive } = benefitData;
        const newBenefit = await TierBenefitService.createTierBenefit(tierId, { type, value, description, isActive });
        console.log(`[TIER_BENEFIT_CTRL] Benefit created successfully: ${newBenefit.id}`);
        res.status(201).json(newBenefit);
    } catch (error: any) {
         console.error(`[TIER_BENEFIT_CTRL] Error creating benefit for tier ${tierId}:`, error);
         // Manejar error P2025 del servicio si el tierId no existe al hacer connect (ya cubierto por el check previo)
        // Devolver 500 para errores inesperados
        next(new Error('Error interno al crear el beneficio.')); // Pasar a manejador global
    }
};

/**
 * Handler para obtener todos los beneficios de un Tier espec√≠fico.
 * GET /api/tiers/tiers/:tierId/benefits
 */
export const getTierBenefitsHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    // --- FIX: Check req.user ---
     if (!req.user || !req.user.businessId) {
        console.error("[TIER_BENEFIT_CTRL] Critical: User context missing in getTierBenefitsHandler.");
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    // --- FIN FIX ---

    const { tierId } = req.params;
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
     console.log(`[TIER_BENEFIT_CTRL] Getting benefits for tier ${tierId}`);

    try {
        // Opcional: Verificar que el Tier pertenece al negocio (buena pr√°ctica)
        const tier = await TierService.findTierById(tierId, businessId);
        if (!tier) {
             return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }

        // Obtener los beneficios usando el servicio de beneficios
        const benefits = await TierBenefitService.findBenefitsByTier(tierId);
        res.status(200).json(benefits);
    } catch (error: any) {
        console.error(`[TIER_BENEFIT_CTRL] Error getting benefits for tier ${tierId}:`, error);
        next(new Error('Error interno al obtener los beneficios.')); // Pasar a manejador global
    }
};

/**
 * Handler para actualizar un beneficio de Tier existente.
 * PUT /api/tiers/benefits/:benefitId
 */
export const updateTierBenefitHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    const { benefitId } = req.params;
     if (!benefitId) return res.status(400).json({ message: 'Se requiere ID del Beneficio.' });

    const updateData = req.body;
     console.log(`[TIER_BENEFIT_CTRL] Updating benefit ${benefitId}`);
    // Validaci√≥n b√°sica
    if (Object.keys(updateData).length === 0) { return res.status(400).json({ message: 'Se requieren datos para actualizar.' }); }
    // TODO: Validar updateData con DTO/Zod si es necesario

    // Opcional: Verificar que el beneficio pertenece a un tier del negocio logueado (m√°s complejo, podr√≠a hacerse en el servicio)
    // const businessId = req.user?.businessId; // Necesitar√≠a check de req.user
    // const canAccess = await checkBenefitBelongsToBusiness(benefitId, businessId); // Funci√≥n hipot√©tica
    // if (!canAccess) return res.status(403).json({ message: 'Acceso denegado a este beneficio.' });

    try {
        const updatedBenefit = await TierBenefitService.updateTierBenefit(benefitId, updateData);
         console.log(`[TIER_BENEFIT_CTRL] Benefit ${benefitId} updated successfully.`);
        res.status(200).json(updatedBenefit);
    } catch (error: any) {
        console.error(`[TIER_BENEFIT_CTRL] Error updating benefit ${benefitId}:`, error);
        if (error instanceof Error && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message }); // Espec√≠fico 404
        }
        next(new Error('Error interno al actualizar el beneficio.')); // Pasar a manejador global
    }
};

/**
 * Handler para eliminar un beneficio de Tier existente.
 * DELETE /api/tiers/benefits/:benefitId
 */
export const deleteTierBenefitHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    const { benefitId } = req.params;
    if (!benefitId) return res.status(400).json({ message: 'Se requiere ID del Beneficio.' });
     console.log(`[TIER_BENEFIT_CTRL] Deleting benefit ${benefitId}`);

    // Opcional: Verificar pertenencia al negocio logueado antes de borrar (requiere check de req.user)
    try {
        const deletedBenefit = await TierBenefitService.deleteTierBenefit(benefitId);
         console.log(`[TIER_BENEFIT_CTRL] Benefit ${benefitId} deleted successfully.`);
        res.status(200).json({ message: 'Beneficio eliminado correctamente.', deletedBenefit }); // o res.sendStatus(204) // Corregido: correctamente
    } catch (error: any) {
        console.error(`[TIER_BENEFIT_CTRL] Error deleting benefit ${benefitId}:`, error);
        if (error instanceof Error && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message }); // Espec√≠fico 404
        }
        next(new Error('Error interno al eliminar el beneficio.')); // Pasar a manejador global
    }
};

// End of File: backend/src/tiers/tier-benefit.controller.ts


// ====== [73] backend/src/modules/loyalpyme/tiers/tier-benefit.service.ts ======
// filename: backend/src/tiers/tier-benefit.service.ts
// Version: 1.0.1 (Fix character encoding)

import { PrismaClient, TierBenefit, Prisma } from '@prisma/client';
// Importar el enum BenefitType si se necesita para validaciones o l√≥gica futura
import { BenefitType } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Crea un nuevo beneficio y lo asocia a un Tier existente.
 * @param tierId - ID del Tier al que pertenece el beneficio.
 * @param benefitData - Datos del nuevo beneficio (type, value, etc.).
 * @returns El TierBenefit creado.
 */
export const createTierBenefit = async (
    tierId: string,
    benefitData: Omit<Prisma.TierBenefitCreateInput, 'tier'>
): Promise<TierBenefit> => {
    console.log(`[TierBenefit SVC] Creating benefit for tier ${tierId}:`, benefitData);
    // Se podr√≠a a√±adir verificaci√≥n de que el tierId pertenece al businessId correcto si fuera necesario
    try {
        const newBenefit = await prisma.tierBenefit.create({
            data: {
                ...benefitData,
                tier: { // Conectar al Tier padre
                    connect: { id: tierId }
                }
            }
        });
        console.log(`[TierBenefit SVC] Benefit created successfully with ID: ${newBenefit.id}`);
        return newBenefit;
    } catch (error) {
        console.error(`[TierBenefit SVC] Error creating benefit for tier ${tierId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             // Este error ocurre si el tierId no existe al intentar conectar
             throw new Error(`No se encontr√≥ el Nivel (Tier) con ID ${tierId} para asociar el beneficio.`); // Corregido: encontr√≥
         }
        throw new Error('Error al crear el beneficio del nivel.');
    }
};

/**
 * Encuentra todos los beneficios asociados a un Tier espec√≠fico.
 * @param tierId - ID del Tier.
 * @returns Lista de TierBenefits.
 */
export const findBenefitsByTier = async (tierId: string): Promise<TierBenefit[]> => {
    console.log(`[TierBenefit SVC] Finding benefits for tier: ${tierId}`);
    try {
        const benefits = await prisma.tierBenefit.findMany({
            where: { tierId: tierId },
             orderBy: { createdAt: 'asc' } // Opcional: ordenar
        });
        return benefits;
    } catch (error) {
        console.error(`[TierBenefit SVC] Error finding benefits for tier ${tierId}:`, error);
        throw new Error('Error al buscar los beneficios del nivel.');
    }
};

/**
 * Actualiza un beneficio de Tier existente.
 * @param benefitId - ID del beneficio a actualizar.
 * @param updateData - Datos a actualizar.
 * @returns El TierBenefit actualizado.
 * @throws Error si el beneficio no se encuentra.
 */
export const updateTierBenefit = async (
    benefitId: string,
    updateData: Partial<Omit<Prisma.TierBenefitUpdateInput, 'tier'>>
): Promise<TierBenefit> => {
    console.log(`[TierBenefit SVC] Updating benefit ID: ${benefitId}`, updateData);
    try {
        // Usamos update directamente, Prisma lanzar√° P2025 si no lo encuentra
        const updatedBenefit = await prisma.tierBenefit.update({
            where: { id: benefitId },
            data: updateData,
        });
        console.log(`[TierBenefit SVC] Benefit ${benefitId} updated successfully.`);
        return updatedBenefit;
    } catch (error) {
        console.error(`[TierBenefit SVC] Error updating benefit ${benefitId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             throw new Error(`Beneficio con ID ${benefitId} no encontrado.`); // Corregido: encontr√≥
         }
        throw new Error('Error al actualizar el beneficio del nivel.');
    }
};

/**
 * Elimina un beneficio de Tier existente.
 * @param benefitId - ID del beneficio a eliminar.
 * @returns El TierBenefit eliminado.
 * @throws Error si el beneficio no se encuentra.
 */
export const deleteTierBenefit = async (benefitId: string): Promise<TierBenefit> => {
    console.log(`[TierBenefit SVC] Deleting benefit ID: ${benefitId}`);
    try {
         // Usamos delete directamente
        const deletedBenefit = await prisma.tierBenefit.delete({
            where: { id: benefitId },
        });
        console.log(`[TierBenefit SVC] Benefit ${benefitId} deleted successfully.`);
        return deletedBenefit;
    } catch (error) {
         console.error(`[TierBenefit SVC] Error deleting benefit ${benefitId}:`, error);
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             throw new Error(`Beneficio con ID ${benefitId} no encontrado.`); // Corregido: encontr√≥
         }
         throw new Error('Error al eliminar el beneficio del nivel.');
       }
};

// End of File: backend/src/tiers/tier-benefit.service.ts


// ====== [74] backend/src/modules/loyalpyme/tiers/tier-config.controller.ts ======
// filename: backend/src/tiers/tier-config.controller.ts
// Version: 1.0.1 (Fix encoding, remove @ts-ignore)

import { Request, Response, NextFunction } from 'express'; // Add NextFunction
import * as TierConfigService from './tier-config.service';

// --- Handlers para Configuraci√≥n de Tiers del Negocio (Admin) ---

/**
 * Handler para obtener la configuraci√≥n de Tiers del negocio.
 * GET /api/tiers/config
 */
export const getBusinessTierConfigHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    // --- FIX: Check req.user ---
    if (!req.user || !req.user.businessId) {
        console.error("[TIER_CONF_CTRL] Critical: User context missing in getBusinessTierConfigHandler.");
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    // --- FIN FIX ---

    console.log(`[TIER_CONF_CTRL] Getting tier config for business ${businessId}`);
    try {
        const config = await TierConfigService.getBusinessTierConfig(businessId);
        if (!config) {
            // Si el servicio devuelve null (negocio no encontrado, aunque no deber√≠a pasar si el token es v√°lido)
            return res.status(404).json({ message: 'Configuraci√≥n de Tiers no encontrada para este negocio.' }); // Corregido: Configuraci√≥n
        }
        res.status(200).json(config);
    } catch (error: any) {
        console.error(`[TIER_CONF_CTRL] Error getting tier config for business ${businessId}:`, error);
        // Pasar al manejador global
        next(new Error('Error interno al obtener la configuraci√≥n de Tiers.')); // Corregido: configuraci√≥n
    }
};

/**
 * Handler para actualizar la configuraci√≥n de Tiers del negocio.
 * PUT /api/tiers/config
 */
export const updateBusinessTierConfigHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    // --- FIX: Check req.user ---
     if (!req.user || !req.user.businessId) {
        console.error("[TIER_CONF_CTRL] Critical: User context missing in updateBusinessTierConfigHandler.");
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    // --- FIN FIX ---

    const configData = req.body; // Datos a actualizar
    console.log(`[TIER_CONF_CTRL] Updating tier config for business ${businessId}:`, configData);

    // TODO: Validaci√≥n m√°s robusta con DTOs/Zod aqu√≠ si es necesario.
    // Validaciones b√°sicas como ejemplo:
    if (configData.tierSystemEnabled !== undefined && typeof configData.tierSystemEnabled !== 'boolean') {
        return res.status(400).json({ message: 'tierSystemEnabled debe ser booleano.' });
    }
    // A√±adir m√°s validaciones si se requiere...

    try {
        const updatedBusiness = await TierConfigService.updateBusinessTierConfig(businessId, configData);
        // El servicio devuelve Business, lo devolvemos entero.
        console.log(`[TIER_CONF_CTRL] Tier config updated successfully for business ${businessId}`);
        res.status(200).json(updatedBusiness);
    } catch (error: any) {
        console.error(`[TIER_CONF_CTRL] Error updating tier config for business ${businessId}:`, error);
         // Manejar error de 'Negocio no encontrado' del servicio
        if (error instanceof Error && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        // Pasar otros errores al manejador global
        next(new Error('Error interno al actualizar la configuraci√≥n de Tiers.')); // Corregido: configuraci√≥n
    }
};

// End of File: backend/src/tiers/tier-config.controller.ts


// ====== [75] backend/src/modules/loyalpyme/tiers/tier-config.service.ts ======
// filename: backend/src/tiers/tier-config.service.ts
// Version: 1.0.1 (Fix character encoding)

import { PrismaClient, Business, Prisma } from '@prisma/client';
// Importar los Enums relevantes si se usan en los tipos de datos
import { TierCalculationBasis, TierDowngradePolicy } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Obtiene la configuraci√≥n del sistema de Tiers para un negocio espec√≠fico.
 * @param businessId - ID del negocio.
 * @returns Un objeto con la configuraci√≥n de Tiers o null si el negocio no se encuentra.
 */
export const getBusinessTierConfig = async (businessId: string): Promise<Pick<Business, 'tierSystemEnabled' | 'tierCalculationBasis' | 'tierCalculationPeriodMonths' | 'tierDowngradePolicy' | 'inactivityPeriodMonths'> | null> => {
    console.log(`[TierConfig SVC] Getting tier config for business: ${businessId}`);
    try {
        const business = await prisma.business.findUnique({
            where: { id: businessId },
            // Seleccionar solo los campos de configuraci√≥n de Tiers
            select: {
                tierSystemEnabled: true,
                tierCalculationBasis: true,
                tierCalculationPeriodMonths: true,
                tierDowngradePolicy: true,
                inactivityPeriodMonths: true,
            }
        });
        // findUnique devuelve null si no lo encuentra, lo cual es correcto aqu√≠.
        return business;
    } catch (error) {
        console.error(`[TierConfig SVC] Error fetching tier config for business ${businessId}:`, error);
        // Lanzamos un error gen√©rico para que lo maneje el controlador
        throw new Error('Error al obtener la configuraci√≥n de tiers del negocio.'); // Corregido: configuraci√≥n, gen√©rico
    }
};

/**
 * Actualiza la configuraci√≥n del sistema de Tiers para un negocio.
 * @param businessId - ID del negocio.
 * @param configData - Datos de configuraci√≥n a actualizar.
 * @returns El objeto Business completo actualizado (o solo los campos de config si se prefiere).
 */
export const updateBusinessTierConfig = async (
    businessId: string,
    // Tipado para aceptar un subconjunto de los campos de configuraci√≥n
    configData: Partial<Pick<Business, 'tierSystemEnabled' | 'tierCalculationBasis' | 'tierCalculationPeriodMonths' | 'tierDowngradePolicy' | 'inactivityPeriodMonths'>>
): Promise<Business> => { // Devuelve Business completo por defecto
    console.log(`[TierConfig SVC] Updating tier config for business: ${businessId}`, configData);
    try {
        // Usamos update, que arrojar√° error si businessId no existe // Corregido: arrojar√°
        const updatedBusiness = await prisma.business.update({
            where: { id: businessId },
            data: configData, // Prisma solo actualiza los campos presentes en configData
        });
        console.log(`[TierConfig SVC] Tier config updated successfully for business ${businessId}.`);
        return updatedBusiness;
    } catch (error) {
        console.error(`[TierConfig SVC] Error updating tier config for business ${businessId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            // Error espec√≠fico si el businessId no existe
             throw new Error(`Negocio con ID ${businessId} no encontrado.`); // Corregido: espec√≠fico
         }
        // Otros posibles errores (ej: tipo de dato incorrecto para enums si no se valida antes)
        throw new Error('Error al actualizar la configuraci√≥n de tiers del negocio.'); // Corregido: configuraci√≥n
    }
};

// End of File: backend/src/tiers/tier-config.service.ts


// ====== [76] backend/src/modules/loyalpyme/tiers/tier-crud.controller.ts ======
// filename: backend/src/tiers/tier-crud.controller.ts
// Version: 1.1.1 (Fix validation checks and P2002->409 mapping)

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client';
import * as TierService from './tiers.service';

// --- Handlers para CRUD de Tiers (Admin) ---

export const createTierHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) {
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    const tierData = req.body;
    console.log(`[TIER_CRUD_CTRL] Attempting to create tier for business ${businessId}`);

    // --- VALIDACI√ìN REFORZADA ---
    if (!tierData.name || typeof tierData.name !== 'string' || tierData.name.trim() === '') {
        return res.status(400).json({ message: 'El campo "name" es obligatorio y debe ser un texto.' });
    }
    // Comprobar que level sea n√∫mero, entero y >= 0 EXPL√çCITAMENTE
    if (tierData.level === undefined || typeof tierData.level !== 'number' || !Number.isInteger(tierData.level) || tierData.level < 0) {
         return res.status(400).json({ message: 'El campo "level" es obligatorio y debe ser un n√∫mero entero igual o mayor que 0.' });
     }
     // Comprobar que minValue sea n√∫mero y >= 0 EXPL√çCITAMENTE
    if (tierData.minValue === undefined || typeof tierData.minValue !== 'number' || tierData.minValue < 0) {
        return res.status(400).json({ message: 'El campo "minValue" es obligatorio y debe ser un n√∫mero igual o mayor que 0.' });
    }
     if (tierData.isActive !== undefined && typeof tierData.isActive !== 'boolean') {
        return res.status(400).json({ message: 'El campo "isActive" debe ser un valor booleano (true/false) si se proporciona.' });
    }
    // --- FIN VALIDACI√ìN ---

    try {
        const { name, level, minValue, description, benefitsDescription, isActive } = tierData;
        const newTier = await TierService.createTier(businessId, {
            name: name.trim(), level, minValue,
            description: description?.trim() || null,
            benefitsDescription: benefitsDescription?.trim() || null,
            isActive
        });
        console.log(`[TIER_CRUD_CTRL] Tier created successfully: ${newTier.id}`);
        res.status(201).json(newTier);
    } catch (error: any) {
        console.error(`[TIER_CRUD_CTRL] Error creating tier for business ${businessId}:`, error);
        // --- CAPTURA ESPEC√çFICA PARA 409 ---
        // El servicio lanza un Error con un mensaje espec√≠fico para P2002
        if (error instanceof Error && (error.message.includes('Ya existe un Tier con el nivel') || error.message.includes('Ya existe un Tier con el nombre'))) {
             return res.status(409).json({ message: error.message }); // Devolver 409
        }
        // --- FIN CAPTURA 409 ---
        next(error); // Otros errores a 500
    }
};

// getBusinessTiersHandler (sin cambios)
export const getBusinessTiersHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) { return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' }); }
    const businessId = req.user.businessId;
    const includeBenefits = req.query.includeBenefits === 'true';
    try {
        const tiers = await TierService.findTiersByBusiness(businessId, includeBenefits);
        res.status(200).json(tiers);
    } catch (error: any) { next(error); }
};

// getTierByIdHandler (sin cambios)
export const getTierByIdHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) { return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' }); }
    const businessId = req.user.businessId;
    const { tierId } = req.params;
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
    const includeBenefits = req.query.includeBenefits === 'true';
    try {
        const tier = await TierService.findTierById(tierId, businessId, includeBenefits);
        if (!tier) { return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' }); }
        res.status(200).json(tier);
    } catch (error: any) { next(error); }
};

// updateTierHandler (con validaci√≥n a√±adida)
export const updateTierHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.businessId) { return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' }); }
     const businessId = req.user.businessId;
     const { tierId } = req.params;
     if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
     const updateData = req.body;

     // --- VALIDACI√ìN ---
     if (Object.keys(updateData).length === 0) { return res.status(400).json({ message: 'Se requieren datos para actualizar.' }); }
     if (updateData.name !== undefined && (typeof updateData.name !== 'string' || updateData.name.trim() === '')) { return res.status(400).json({ message: 'Si se proporciona "name", no puede estar vac√≠o.' }); }
     if (updateData.level !== undefined && (typeof updateData.level !== 'number' || !Number.isInteger(updateData.level) || updateData.level < 0)) { return res.status(400).json({ message: 'Si se proporciona "level", debe ser un n√∫mero entero igual o mayor que 0.' }); }
     if (updateData.minValue !== undefined && (typeof updateData.minValue !== 'number' || updateData.minValue < 0)) { return res.status(400).json({ message: 'Si se proporciona "minValue", debe ser un n√∫mero igual o mayor que 0.' }); }
     if (updateData.isActive !== undefined && typeof updateData.isActive !== 'boolean') { return res.status(400).json({ message: 'Si se proporciona "isActive", debe ser un valor booleano.' }); }
     // --- FIN VALIDACI√ìN ---

     try {
         const cleanUpdateData: Prisma.TierUpdateInput = {}; // Usar tipo Prisma aqu√≠
         if (updateData.name !== undefined) cleanUpdateData.name = updateData.name.trim();
         if (updateData.level !== undefined) cleanUpdateData.level = updateData.level;
         if (updateData.minValue !== undefined) cleanUpdateData.minValue = updateData.minValue;
         if (updateData.description !== undefined) cleanUpdateData.description = updateData.description?.trim() || null;
         if (updateData.benefitsDescription !== undefined) cleanUpdateData.benefitsDescription = updateData.benefitsDescription?.trim() || null;
         if (updateData.isActive !== undefined) cleanUpdateData.isActive = updateData.isActive;

         const updatedTier = await TierService.updateTier(tierId, businessId, cleanUpdateData);
         console.log(`[TIER_CRUD_CTRL] Tier ${tierId} updated successfully.`);
         res.status(200).json(updatedTier);
     } catch (error: any) {
         console.error(`[TIER_CRUD_CTRL] Error updating tier ${tierId} for business ${businessId}:`, error);
         // --- CAPTURA ESPEC√çFICA 404 y 409 ---
         if (error instanceof Error && error.message.includes('no encontrado')) { return res.status(404).json({ message: error.message }); }
         if (error instanceof Error && (error.message.includes('Ya existe un Tier con el nivel') || error.message.includes('Ya existe un Tier con el nombre'))) { return res.status(409).json({ message: error.message }); }
         // --- FIN CAPTURA ---
         next(error);
     }
};

// deleteTierHandler (con manejo de 409 a√±adido)
export const deleteTierHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.businessId) { return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' }); }
     const businessId = req.user.businessId;
     const { tierId } = req.params;
     if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
     console.log(`[TIER_CRUD_CTRL] Deleting tier ${tierId} for business ${businessId}`);
     try {
         const deletedTier = await TierService.deleteTier(tierId, businessId);
         console.log(`[TIER_CRUD_CTRL] Tier ${tierId} deleted successfully.`);
         res.status(200).json({ message: 'Tier eliminado correctamente.', deletedTier });
     } catch (error: any) {
         console.error(`[TIER_CRUD_CTRL] Error deleting tier ${tierId} for business ${businessId}:`, error);
         // --- CAPTURA ESPEC√çFICA 404 y 409 ---
         if (error instanceof Error && error.message.includes('no encontrado')) { return res.status(404).json({ message: error.message }); }
         if (error instanceof Error && error.message.includes('usuarios asignados')) { return res.status(409).json({ message: error.message }); }
         // --- FIN CAPTURA ---
         next(error);
     }
};

// End of File: backend/src/tiers/tier-crud.controller.ts


// ====== [77] backend/src/modules/loyalpyme/tiers/tier-logic.helpers.ts ======
// filename: backend/src/tiers/tier-logic.helpers.ts
// Version: 1.3.2 (Add null check for calculationBasis in calculateTierForReview)

import { PrismaClient, User, Prisma, QrCodeStatus, Tier, TierCalculationBasis, TierDowngradePolicy } from '@prisma/client';
import { subMonths, isBefore } from 'date-fns';

type ActiveTierInfo = Pick<Tier, 'id' | 'name' | 'level' | 'minValue'>;

export async function calculateUserMetric(
    prismaClient: Pick<PrismaClient, 'qrCode'>,
    userId: string,
    basis: TierCalculationBasis, // Sigue siendo no nulo aqu√≠
    startDate: Date | undefined
): Promise<number> {
    console.log(`[TierLogic Helper DI] Calculating metric for user ${userId}. Basis=${basis}, StartDate=${startDate?.toISOString() ?? 'Lifetime'}`);
    const whereBase: Prisma.QrCodeWhereInput = { userId: userId, status: QrCodeStatus.COMPLETED, };
    if (startDate) {
        whereBase.completedAt = { gte: startDate };
    }
    let userMetricValue = 0;
    try {
        switch (basis) {
            case TierCalculationBasis.SPEND:
                const spendResult = await prismaClient.qrCode.aggregate({ _sum: { amount: true }, where: whereBase, });
                userMetricValue = spendResult._sum.amount ?? 0;
                break;
            case TierCalculationBasis.VISITS:
                const visitCount = await prismaClient.qrCode.count({ where: whereBase, });
                userMetricValue = visitCount;
                break;
            case TierCalculationBasis.POINTS_EARNED:
                const pointsResult = await prismaClient.qrCode.aggregate({ _sum: { pointsEarned: true }, where: whereBase, });
                userMetricValue = pointsResult._sum.pointsEarned ?? 0;
                break;
        }
    } catch (error) {
        console.error(`[TierLogic Helper DI] Error calculating metric ${basis} for user ${userId}:`, error);
        userMetricValue = 0;
    }
    console.log(`[TierLogic Helper DI] User ${userId} - Metric Result (${basis}) = ${userMetricValue}`);
    return userMetricValue;
}

export function determineTargetTier(metricValue: number, activeTiers: ActiveTierInfo[]): string | null {
    // (Sin cambios)
    let targetTierId: string | null = null;
    for (const tier of activeTiers) {
        if (metricValue >= tier.minValue) {
            targetTierId = tier.id;
            break;
        }
    }
    return targetTierId;
}

export async function calculateTierForReview(
    prismaClient: PrismaClient,
    userId: string
): Promise<{ userId: string, currentTierId: string | null, targetTierId: string | null } | null> {
    console.log(`[Tier JOB Helper DI] Calculating target tier for user ${userId}`);
    try {
        const user = await prismaClient.user.findUnique({
             where: { id: userId },
             include: { /* ... include business ... */
                business: {
                    select: {
                        id: true, tierSystemEnabled: true, tierCalculationBasis: true,
                        tierCalculationPeriodMonths: true,
                        tiers: { where: { isActive: true }, orderBy: { level: 'desc' }, select: { id: true, name: true, level: true, minValue: true } }
                    }
                },
             }
        });

         if (!user || !user.business) { return null; }

        // --- NUEVO: Comprobaci√≥n de null ---
        if (!user.business.tierSystemEnabled || !user.business.tierCalculationBasis || !user.business.tiers || user.business.tiers.length === 0) {
            console.log(`[Tier JOB Helper DI] Skipping review calc for user ${userId} due to missing config or no active tiers.`);
            return null;
        }
        // --- FIN NUEVO ---


        const config = user.business;
        const activeTiers: ActiveTierInfo[] = config.tiers;
        const calculationBasis = config.tierCalculationBasis; // Sabemos que no es null aqu√≠
        const periodMonths = config.tierCalculationPeriodMonths;
        const now = new Date();
        let startDate: Date | undefined = (periodMonths && periodMonths > 0) ? subMonths(now, periodMonths) : undefined;

        // --- CAMBIO: A√±adir '!' para asegurar a TS que calculationBasis no es null ---
        const userMetricValue = await calculateUserMetric(prismaClient, userId, calculationBasis!, startDate);
        // --- FIN CAMBIO ---
        const targetTierId = determineTargetTier(userMetricValue, activeTiers);

        return { userId: user.id, currentTierId: user.currentTierId, targetTierId: targetTierId };
    } catch (error) {
        console.error(`[Tier JOB Helper DI] Error calculating tier for review for user ${userId}:`, error);
        return null;
    }
}

export async function handleInactivityCheckUser(
    prismaClient: PrismaClient,
    user: Pick<User, 'id' | 'lastActivityAt' | 'currentTierId'>,
    inactivityPeriodMonths: number,
    now: Date
): Promise<boolean> {
    // (Sin cambios)
     if (user.currentTierId === null) { return false; }
    if (!user.lastActivityAt) { console.log(`[Tier JOB Helper DI] User ${user.id} has no lastActivityAt date.`); return false; }
    const inactivityLimitDate = subMonths(now, inactivityPeriodMonths);
    if (isBefore(user.lastActivityAt, inactivityLimitDate)) {
        console.log(`[Tier JOB Helper DI] Downgrading user ${user.id} due to inactivity.`);
        try {
            await prismaClient.user.update({ where: { id: user.id }, data: { currentTierId: null, tierAchievedAt: null } });
            return true;
        } catch (error) {
            console.error(`[Tier JOB Helper DI] Failed to downgrade user ${user.id} due to inactivity:`, error);
            return false;
        }
    }
    return false;
}

// End of File: backend/src/tiers/tier-logic.helpers.ts


// ====== [78] backend/src/modules/loyalpyme/tiers/tier-logic.service.ts ======
// filename: backend/src/tiers/tier-logic.service.ts
// Version: 2.2.1 (Pass prisma instance to helpers)

import { PrismaClient, User, Prisma, Tier, TierCalculationBasis, TierDowngradePolicy } from '@prisma/client';
import { subMonths } from 'date-fns';
import {
    calculateUserMetric,
    determineTargetTier,
    calculateTierForReview,
    handleInactivityCheckUser
} from './tier-logic.helpers';

// Instancia de Prisma para este servicio
const prisma = new PrismaClient();

type ActiveTierInfo = Pick<Tier, 'id' | 'name' | 'level' | 'minValue'>;


/**
 * Calcula y actualiza el Tier de un usuario basado en la configuraci√≥n del negocio.
 */
export const updateUserTier = async (userId: string): Promise<void> => {
    console.log(`[TierLogic SVC] Checking/Updating tier for user: ${userId}`);
    try {
        const user = await prisma.user.findUniqueOrThrow({
             where: { id: userId },
             include: {
                 business: {
                     select: {
                         id: true, tierSystemEnabled: true, tierCalculationBasis: true,
                         tierCalculationPeriodMonths: true,
                         tiers: { where: { isActive: true }, orderBy: { level: 'desc' }, select: { id: true, name: true, level: true, minValue: true } }
                     }
                 },
             }
        });
        if (!user.business || !user.business.tierSystemEnabled || !user.business.tierCalculationBasis || !user.business.tiers || user.business.tiers.length === 0) {
            console.log(`[TierLogic SVC] Skipping tier update for user ${userId} due to missing config or disabled system.`);
            return;
        }

        const config = user.business;
        const activeTiers: ActiveTierInfo[] = config.tiers;
        const calculationBasis = config.tierCalculationBasis; // Sabemos que no es null
        const periodMonths = config.tierCalculationPeriodMonths;
        const now = new Date();
        let startDate: Date | undefined = (periodMonths && periodMonths > 0) ? subMonths(now, periodMonths) : undefined;

        // --- CORRECCI√ìN: Pasar 'prisma' a calculateUserMetric ---
        const userMetricValue = await calculateUserMetric(prisma, userId, calculationBasis!, startDate);
        // --- FIN CORRECCI√ìN ---
        const targetTierId = determineTargetTier(userMetricValue, activeTiers);

        if (user.currentTierId !== targetTierId) {
            console.log(`[TierLogic SVC] Updating user ${userId} tier from ${user.currentTierId || 'None'} to ${targetTierId || 'None'}`);
            await prisma.user.update({
                where: { id: userId },
                data: {
                    currentTierId: targetTierId,
                    tierAchievedAt: targetTierId ? now : null,
                 },
            });
        } else {
            console.log(`[TierLogic SVC] User ${userId} remains in tier ${user.currentTierId || 'None'}. No update needed.`);
        }
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             console.error(`[TierLogic SVC] User ${userId} not found during tier update check.`);
         } else {
             console.error(`[TierLogic SVC] Error updating tier for user ${userId}:`, error);
         }
    }
};

/**
 * Procesa las actualizaciones y posibles descensos de nivel para todos los usuarios aplicables.
 */
export const processTierUpdatesAndDowngrades = async (): Promise<void> => {
    const jobStartTime = new Date();
    console.log(`[Tier JOB ${jobStartTime.toISOString()}] Starting scheduled tier update/downgrade process...`);
    let businessesProcessed = 0;
    let usersProcessed = 0;
    let usersDowngradedInactivity = 0;
    let usersCheckedPeriodic = 0;
    let usersUpdatedPeriodic = 0;

    try {
        const businessesToProcess = await prisma.business.findMany({
            where: {
                tierSystemEnabled: true,
                 tierDowngradePolicy: { not: TierDowngradePolicy.NEVER }
            },
            select: { id: true, tierDowngradePolicy: true, tierCalculationPeriodMonths: true, inactivityPeriodMonths: true }
        });
        if (businessesToProcess.length === 0) {
            console.log(`[Tier JOB ${jobStartTime.toISOString()}] No businesses with active downgrade policies. Finishing.`);
            return;
        }
        console.log(`[Tier JOB ${jobStartTime.toISOString()}] Found ${businessesToProcess.length} businesses to process.`);
        businessesProcessed = businessesToProcess.length;
        const now = new Date();

        for (const business of businessesToProcess) {
            console.log(`[Tier JOB] Processing business ${business.id} with policy ${business.tierDowngradePolicy}`);
            const users = await prisma.user.findMany({
                where: { businessId: business.id, isActive: true, role: 'CUSTOMER_FINAL' },
                select: { id: true, lastActivityAt: true, currentTierId: true }
            });
            if (users.length === 0) {
                console.log(`[Tier JOB] No active customer users for business ${business.id}. Skipping.`);
                continue;
            }

            for (const user of users) {
                usersProcessed++;
                try {
                    if (business.tierDowngradePolicy === TierDowngradePolicy.PERIODIC_REVIEW) {
                        usersCheckedPeriodic++;
                        // --- CORRECCI√ìN: Pasar 'prisma' a calculateTierForReview ---
                        const reviewResult = await calculateTierForReview(prisma, user.id);
                        // --- FIN CORRECCI√ìN ---
                        if (reviewResult && reviewResult.currentTierId !== reviewResult.targetTierId) {
                            console.log(`[Tier JOB] Updating user ${user.id} tier from ${reviewResult.currentTierId || 'None'} to ${reviewResult.targetTierId || 'None'} based on periodic review.`);
                            await prisma.user.update({
                                where: { id: user.id },
                                data: {
                                     currentTierId: reviewResult.targetTierId,
                                     tierAchievedAt: reviewResult.targetTierId ? now : null
                                }
                            });
                            usersUpdatedPeriodic++;
                        } else if (reviewResult) {
                            // console.log(`[Tier JOB] User ${user.id} tier remains unchanged after periodic review.`);
                        }
                    } else if (business.tierDowngradePolicy === TierDowngradePolicy.AFTER_INACTIVITY && business.inactivityPeriodMonths) {
                        // --- CORRECCI√ìN: Pasar 'prisma' a handleInactivityCheckUser ---
                        const downgraded = await handleInactivityCheckUser(prisma, user, business.inactivityPeriodMonths, now);
                        // --- FIN CORRECCI√ìN ---
                        if (downgraded) usersDowngradedInactivity++;
                    }
                } catch (userProcessingError) {
                    console.error(`[Tier JOB] Unexpected error processing user ${user.id} for business ${business.id}:`, userProcessingError);
                }
            } // Fin loop usuarios
        } // Fin loop negocios
    } catch (error) {
        console.error(`[Tier JOB ${jobStartTime.toISOString()}] Critical error during scheduled processing:`, error);
    } finally {
        const jobEndTime = new Date();
        const duration = (jobEndTime.getTime() - jobStartTime.getTime()) / 1000;
        console.log(`[Tier JOB ${jobStartTime.toISOString()}] Finished processing. Duration: ${duration}s. Businesses: ${businessesProcessed}, Total Users Processed: ${usersProcessed}, Users Checked (Periodic): ${usersCheckedPeriodic}, Updated (Periodic): ${usersUpdatedPeriodic}, Downgraded (Inactivity): ${usersDowngradedInactivity}.`);
    }
};

// End of File: backend/src/tiers/tier-logic.service.ts


// ====== [79] backend/src/modules/loyalpyme/tiers/tiers.controller.ts ======
// File: backend/src/tiers/tiers.controller.ts
// Version: 1.0.0 (Initial controller structure with handlers)

import { Request, Response } from 'express';
import { Prisma } from '@prisma/client'; // Para tipos de error y DTOs

// Importar funciones de los diferentes servicios de Tiers
import * as TierConfigService from './tier-config.service';
import * as TierService from './tiers.service';
import * as TierBenefitService from './tier-benefit.service';
// Todav√≠a no importamos nada de tier-logic.service, ya que updateUserTier se llama internamente o por jobs

// --- Handlers para Configuraci√≥n de Tiers del Negocio (Admin) ---

export const getBusinessTierConfigHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId; // Asumimos que authenticateToken y checkRole(ADMIN) ya pasaron
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });

    try {
        const config = await TierConfigService.getBusinessTierConfig(businessId);
        if (!config) {
            // No es necesariamente un error, podr√≠a ser que el negocio no existe (aunque el token s√≠)
            // O simplemente devolvemos un objeto por defecto si queremos que siempre exista config?
            // Por ahora, devolvemos 404 si no hay negocio o config impl√≠citamente.
             return res.status(404).json({ message: 'Configuraci√≥n de Tiers no encontrada para este negocio.' });
        }
        res.status(200).json(config);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error getting tier config for business ${businessId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener la configuraci√≥n de Tiers.' });
    }
};

export const updateBusinessTierConfigHandler = async (req: Request, res: Response) => {
     const businessId = req.user?.businessId;
     if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });

     // TODO: Validar req.body con un DTO (ej: usando class-validator si se a√±ade)
     const configData = req.body; // Asumimos que el body contiene los campos a actualizar

     // Validaci√≥n b√°sica (mejorar con DTOs)
     if (typeof configData.tierSystemEnabled !== 'boolean' && configData.tierSystemEnabled !== undefined) {
         return res.status(400).json({ message: 'tierSystemEnabled debe ser booleano.' });
     }
     // A√±adir m√°s validaciones para enums, periodos, etc.

     try {
         const updatedBusiness = await TierConfigService.updateBusinessTierConfig(businessId, configData);
         // Devolvemos solo la parte de config actualizada para consistencia con GET? O todo el Business?
         // Devolvemos todo por ahora.
         res.status(200).json(updatedBusiness);
     } catch (error: any) {
         console.error(`[Tiers CTRL] Error updating tier config for business ${businessId}:`, error);
         res.status(500).json({ message: error.message || 'Error interno al actualizar la configuraci√≥n de Tiers.' });
     }
};


// --- Handlers para CRUD de Tiers (Admin) ---

export const createTierHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });

    // TODO: Validar req.body con DTO
    const tierData = req.body;

    // Validaci√≥n b√°sica (mejorar con DTOs)
     if (!tierData.name || typeof tierData.level !== 'number' || typeof tierData.minValue !== 'number') {
         return res.status(400).json({ message: 'Nombre, nivel y valor m√≠nimo son requeridos para el Tier.' });
     }

    try {
        // Pasamos solo los datos relevantes al servicio, excluyendo relaciones/ids
        const { name, level, minValue, description, benefitsDescription, isActive } = tierData;
        const newTier = await TierService.createTier(businessId, { name, level, minValue, description, benefitsDescription, isActive });
        res.status(201).json(newTier);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error creating tier for business ${businessId}:`, error);
        // Devolver 409 si es error de unicidad
        if (error.message.includes('unicidad')) {
            return res.status(409).json({ message: error.message });
        }
        res.status(500).json({ message: error.message || 'Error interno al crear el Tier.' });
    }
};

export const getBusinessTiersHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    const includeBenefits = req.query.includeBenefits === 'true'; // Opci√≥n para incluir beneficios

    try {
        const tiers = await TierService.findTiersByBusiness(businessId, includeBenefits);
        res.status(200).json(tiers);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error getting tiers for business ${businessId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener los Tiers.' });
    }
};

export const getTierByIdHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    const { tierId } = req.params;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
    const includeBenefits = req.query.includeBenefits === 'true';

    try {
        const tier = await TierService.findTierById(tierId, businessId, includeBenefits);
        if (!tier) {
            return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }
        res.status(200).json(tier);
    } catch (error: any) {
         console.error(`[Tiers CTRL] Error getting tier ${tierId} for business ${businessId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener el Tier.' });
    }
};

export const updateTierHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    const { tierId } = req.params;
     if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
     if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });

     // TODO: Validar req.body con DTO
     const updateData = req.body;
      // Validaci√≥n b√°sica
      if (Object.keys(updateData).length === 0) {
         return res.status(400).json({ message: 'Se requieren datos para actualizar.' });
      }

     try {
         const updatedTier = await TierService.updateTier(tierId, businessId, updateData);
         res.status(200).json(updatedTier);
     } catch (error: any) {
         console.error(`[Tiers CTRL] Error updating tier ${tierId} for business ${businessId}:`, error);
         if (error.message.includes('no encontrado')) {
             return res.status(404).json({ message: error.message });
         }
         if (error.message.includes('unicidad')) {
             return res.status(409).json({ message: error.message });
         }
         res.status(500).json({ message: error.message || 'Error interno al actualizar el Tier.' });
     }
};

export const deleteTierHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    const { tierId } = req.params;
     if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
     if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });

     try {
         const deletedTier = await TierService.deleteTier(tierId, businessId);
         res.status(200).json({ message: 'Tier eliminado correctamente.', deletedTier }); // o res.sendStatus(204)
     } catch (error: any) {
         console.error(`[Tiers CTRL] Error deleting tier ${tierId} for business ${businessId}:`, error);
         if (error.message.includes('no encontrado') || error.message.includes('usuarios asignados')) {
             // 404 si no existe, 409 (Conflicto) si tiene usuarios
             const statusCode = error.message.includes('usuarios asignados') ? 409 : 404;
             return res.status(statusCode).json({ message: error.message });
         }
         res.status(500).json({ message: error.message || 'Error interno al eliminar el Tier.' });
     }
};

// --- Handlers para CRUD de TierBenefits (Admin) ---

export const createTierBenefitHandler = async (req: Request, res: Response) => {
    // Necesitamos el ID del Tier al que a√±adir el beneficio (vendr√° en la URL)
    const businessId = req.user?.businessId; // Para verificar pertenencia del Tier
    const { tierId } = req.params;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier en la URL.' });

    // TODO: Validar req.body con DTO
    const benefitData = req.body;
     // Validaci√≥n b√°sica
     if (!benefitData.type || !benefitData.value) {
         return res.status(400).json({ message: 'Tipo y valor son requeridos para el beneficio.' });
     }
     // A√±adir validaci√≥n de enum BenefitType

    try {
        // Verificar que el Tier pertenece al negocio antes de crear el beneficio
        const tier = await TierService.findTierById(tierId, businessId);
        if (!tier) {
             return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }
        // Crear el beneficio asociado a ese tierId
        const { type, value, description, isActive } = benefitData;
        const newBenefit = await TierBenefitService.createTierBenefit(tierId, { type, value, description, isActive });
        res.status(201).json(newBenefit);
    } catch (error: any) {
         console.error(`[Tiers CTRL] Error creating benefit for tier ${tierId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al crear el beneficio.' });
    }
};

export const getTierBenefitsHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId; // Para verificar pertenencia del Tier
    const { tierId } = req.params;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });

    try {
        // Opcional: Verificar que el Tier pertenece al negocio
        const tier = await TierService.findTierById(tierId, businessId);
        if (!tier) {
             return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }
        // Obtener los beneficios
        const benefits = await TierBenefitService.findBenefitsByTier(tierId);
        res.status(200).json(benefits);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error getting benefits for tier ${tierId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener los beneficios.' });
    }
};

export const updateTierBenefitHandler = async (req: Request, res: Response) => {
    const { benefitId } = req.params; // Solo necesitamos el ID del beneficio
     if (!benefitId) return res.status(400).json({ message: 'Se requiere ID del Beneficio.' });
    // TODO: Validar req.body con DTO
    const updateData = req.body;
    if (Object.keys(updateData).length === 0) { return res.status(400).json({ message: 'Se requieren datos para actualizar.' }); }

    // Opcional: Verificar que el beneficio pertenece a un tier del negocio logueado (m√°s complejo)
    // const businessId = req.user?.businessId;
    // const benefit = await prisma.tierBenefit.findUnique({ where: {id: benefitId}, include: { tier: { select: { businessId: true }}}})
    // if (!benefit || benefit.tier.businessId !== businessId) return res.status(404)...

    try {
        const updatedBenefit = await TierBenefitService.updateTierBenefit(benefitId, updateData);
        res.status(200).json(updatedBenefit);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error updating benefit ${benefitId}:`, error);
        if (error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        res.status(500).json({ message: error.message || 'Error interno al actualizar el beneficio.' });
    }
};

export const deleteTierBenefitHandler = async (req: Request, res: Response) => {
    const { benefitId } = req.params;
    if (!benefitId) return res.status(400).json({ message: 'Se requiere ID del Beneficio.' });

    // Opcional: Verificar pertenencia al negocio logueado
    try {
        const deletedBenefit = await TierBenefitService.deleteTierBenefit(benefitId);
        res.status(200).json({ message: 'Beneficio eliminado correctamente.', deletedBenefit }); // o res.sendStatus(204)
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error deleting benefit ${benefitId}:`, error);
        if (error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        res.status(500).json({ message: error.message || 'Error interno al eliminar el beneficio.' });
    }
};


// --- Handlers para Clientes ---

export const getCustomerTiersHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId; // Cliente final autenticado
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token del cliente.' });

    try {
         // Reutilizamos la funci√≥n del servicio de Tiers para obtenerlos
         // Podr√≠amos querer incluir beneficios aqu√≠ tambi√©n para mostrarlos al cliente
        const tiers = await TierService.findTiersByBusiness(businessId, true); // includeBenefits = true
        res.status(200).json(tiers);
    } catch (error: any) {
         console.error(`[Tiers CTRL] Error getting tiers for customer of business ${businessId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener los niveles del programa.' });
    }
};


// End of File: backend/src/tiers/tiers.controller.ts


// ====== [80] backend/src/modules/loyalpyme/tiers/tiers.service.ts ======
// filename: backend/src/tiers/tiers.service.ts
// Version: 1.0.1 (Add debug log)

import { PrismaClient, Tier, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Crea un nuevo Tier para un negocio.
 * @param businessId - ID del negocio.
 * @param tierData - Datos del nuevo Tier.
 * @returns El Tier creado.
 */
export const createTier = async (
    businessId: string,
    tierData: Omit<Prisma.TierCreateInput, 'business' | 'users' | 'benefits'>
): Promise<Tier> => {
    console.log(`[Tier SVC] Creating tier for business ${businessId}:`, tierData);
    try {
        const newTier = await prisma.tier.create({
             data: {
                 ...tierData,
                 business: {
                     connect: { id: businessId }
                 }
             },
        });
        console.log(`[Tier SVC] Tier created successfully with ID: ${newTier.id}`);
        return newTier;
     } catch (error) {
         console.error(`[Tier SVC] Error creating tier for business ${businessId}:`, error);
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             const target = error.meta?.target as string[];
             if (target?.includes('level')) {
                 throw new Error(`Ya existe un Tier con el nivel '${tierData.level}' para este negocio.`);
             } else if (target?.includes('name')) {
                 throw new Error(`Ya existe un Tier con el nombre '${tierData.name}' para este negocio.`);
             }
             throw new Error('Conflicto de unicidad al crear el Tier (nivel o nombre ya existen).');
         }
         throw new Error('Error al crear el nivel de fidelizaci√≥n.');
     }
};

/**
 * Encuentra todos los Tiers de un negocio espec√≠fico, opcionalmente incluyendo sus beneficios.
 * @param businessId ID del negocio.
 * @param includeBenefits Si es true, incluye los beneficios asociados.
 * @returns Lista de Tiers.
 */
export const findTiersByBusiness = async (businessId: string, includeBenefits: boolean = false): Promise<Tier[]> => {
    console.log(`[Tier SVC] Finding tiers for business: ${businessId}, includeBenefits: ${includeBenefits}`);
    try {
        const tiers = await prisma.tier.findMany({
            where: { businessId: businessId },
            orderBy: { level: 'asc' },
            include: {
                benefits: includeBenefits,
            }
        });
        // --- NUEVO LOG ---
        console.log(`[Tier SVC] Prisma findMany finished. Found ${tiers.length} tiers.`);
        // ---------------
        return tiers;
    } catch (error) {
        // --- NUEVO LOG ---
        console.error(`[Tier SVC] *** ERROR within findTiersByBusiness try/catch for business ${businessId}:`, error);
        // ---------------
         console.error(`[Tier SVC] Error finding tiers for business ${businessId}:`, error); // Mantener log original tambi√©n
         throw new Error('Error al buscar los niveles de fidelizaci√≥n.');
    }
};

/**
 * Encuentra un Tier espec√≠fico por su ID, asegurando que pertenece al negocio dado.
 * @param tierId ID del Tier.
 * @param businessId ID del negocio propietario.
 * @param includeBenefits Si es true, incluye los beneficios asociados.
 * @returns El Tier encontrado o null.
 */
export const findTierById = async (tierId: string, businessId: string, includeBenefits: boolean = false): Promise<Tier | null> => {
     console.log(`[Tier SVC] Finding tier by ID: ${tierId} for business: ${businessId}, includeBenefits: ${includeBenefits}`);
     try {
         const tier = await prisma.tier.findFirst({
             where: {
                 id: tierId,
                 businessId: businessId
             },
             include: {
                 benefits: includeBenefits,
             }
         });
         return tier;
     } catch (error) {
         console.error(`[Tier SVC] Error finding tier ${tierId}:`, error);
         throw new Error('Error al buscar el nivel de fidelizaci√≥n por ID.');
     }
};

/**
 * Actualiza un Tier existente.
 * @param tierId ID del Tier a actualizar.
 * @param businessId ID del negocio propietario (para verificaci√≥n).
 * @param updateData Datos a actualizar.
 * @returns El Tier actualizado.
 * @throws Error si el Tier no se encuentra o no pertenece al negocio.
 */
export const updateTier = async (
    tierId: string,
    businessId: string,
    updateData: Partial<Omit<Prisma.TierUpdateInput, 'business' | 'users' | 'benefits'>>
): Promise<Tier> => {
    console.log(`[Tier SVC] Updating tier ID: ${tierId} for business: ${businessId}`, updateData);
    try {
        const existingTier = await prisma.tier.findFirst({
            where: { id: tierId, businessId: businessId },
            select: { id: true }
        });
        if (!existingTier) {
            throw new Error(`Nivel (Tier) con ID ${tierId} no encontrado o no pertenece a este negocio.`);
        }
        const updatedTier = await prisma.tier.update({
            where: { id: tierId },
            data: updateData,
        });
        console.log(`[Tier SVC] Tier ${tierId} updated successfully.`);
        return updatedTier;
    } catch (error) {
        console.error(`[Tier SVC] Error updating tier ${tierId}:`, error);
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             throw new Error('Conflicto de unicidad al actualizar el Tier (nivel o nombre ya existen).');
         }
        if (error instanceof Error && error.message.startsWith('Nivel (Tier) con ID')) {
             throw error;
         }
        throw new Error('Error al actualizar el nivel de fidelizaci√≥n.');
    }
};

/**
 * Elimina un Tier existente.
 * @param tierId ID del Tier a eliminar.
 * @param businessId ID del negocio propietario (para verificaci√≥n).
 * @returns El Tier eliminado.
 * @throws Error si el Tier no se encuentra o no pertenece al negocio, o si tiene usuarios asignados.
 */
export const deleteTier = async (tierId: string, businessId: string): Promise<Tier> => {
    console.log(`[Tier SVC] Deleting tier ID: ${tierId} for business: ${businessId}`);
    try {
        const existingTier = await prisma.tier.findFirst({
            where: { id: tierId, businessId: businessId },
             select: { id: true, _count: { select: { users: true } } }
        });
        if (!existingTier) {
            throw new Error(`Nivel (Tier) con ID ${tierId} no encontrado o no pertenece a este negocio.`);
        }
        if (existingTier._count.users > 0) {
             console.warn(`[Tiers SVC] Attempted to delete tier ${tierId} which has ${existingTier._count.users} users assigned.`);
             throw new Error(`No se puede eliminar el Nivel ${tierId} porque tiene usuarios asignados. Reas√≠gnelos primero.`);
         }
        const deletedTier = await prisma.tier.delete({
            where: { id: tierId },
        });
        console.log(`[Tier SVC] Tier ${tierId} deleted successfully.`);
        return deletedTier;
     } catch (error) {
         console.error(`[Tier SVC] Error deleting tier ${tierId}:`, error);
        if (error instanceof Error && (error.message.startsWith('Nivel (Tier) con ID') || error.message.includes('usuarios asignados'))) {
             throw error;
         }
        throw new Error('Error al eliminar el nivel de fidelizaci√≥n.');
     }
};

// End of File: backend/src/tiers/tiers.service.ts


// ====== [81] backend/src/modules/superadmin/superadmin.controller.ts ======
// backend/src/superadmin/superadmin.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as superAdminService from './superadmin.service';

/**
 * Handler para obtener la lista de todos los negocios con su estado de suscripci√≥n.
 */
export const getAllBusinessesHandler = async (req: Request, res: Response, next: NextFunction) => {
    try {
        const businesses = await superAdminService.getAllBusinesses();
        res.status(200).json(businesses);
    } catch (error) {
        console.error("[SA_CTRL] Error in getAllBusinessesHandler:", error);
        next(error);
    }
};

/**
 * Handler para cambiar el estado general (activo/inactivo) de un negocio.
 */
export const toggleBusinessStatusHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessId } = req.params;
    const { isActive } = req.body;
    const adminId = req.user?.id;

    if (typeof isActive !== 'boolean') {
        return res.status(400).json({ message: 'El campo "isActive" es requerido y debe ser un booleano.' });
    }
    if (!adminId) {
        return res.status(403).json({ message: 'No se pudo identificar al administrador.' });
    }

    try {
        const updatedBusiness = await superAdminService.toggleBusinessStatus(businessId, isActive, adminId);
        res.status(200).json(updatedBusiness);
    } catch (error: any) {
        console.error(`[SA_CTRL] Error in toggleBusinessStatusHandler for business ${businessId}:`, error);
        if (error.message && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para activar/desactivar el m√≥dulo LoyaltyCore para un negocio.
 */
export const toggleLoyaltyCoreModuleHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessId } = req.params;
    const { isActive } = req.body;
    const adminId = req.user?.id;

    if (typeof isActive !== 'boolean') {
        return res.status(400).json({ message: 'El campo "isActive" es requerido y debe ser un booleano para el m√≥dulo.' });
    }
    if (!adminId) {
        return res.status(403).json({ message: 'No se pudo identificar al administrador.' });
    }

    try {
        const updatedBusiness = await superAdminService.toggleModule(businessId, 'isLoyaltyCoreActive', isActive, adminId);
        res.status(200).json(updatedBusiness);
    } catch (error: any) {
        console.error(`[SA_CTRL] Error in toggleLoyaltyCoreModuleHandler for business ${businessId}:`, error);
        if (error.message && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para activar/desactivar el m√≥dulo Camarero para un negocio.
 */
export const toggleCamareroModuleHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessId } = req.params;
    const { isActive } = req.body;
    const adminId = req.user?.id;

    if (typeof isActive !== 'boolean') {
        return res.status(400).json({ message: 'El campo "isActive" es requerido y debe ser un booleano para el m√≥dulo.' });
    }
    if (!adminId) {
        return res.status(403).json({ message: 'No se pudo identificar al administrador.' });
    }

    try {
        const updatedBusiness = await superAdminService.toggleModule(businessId, 'isCamareroActive', isActive, adminId);
        res.status(200).json(updatedBusiness);
    } catch (error: any) {
        console.error(`[SA_CTRL] Error in toggleCamareroModuleHandler for business ${businessId}:`, error);
        if (error.message && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para actualizar el precio de la suscripci√≥n de un negocio.
 */
export const setSubscriptionPriceHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessId } = req.params;
    const { price, currency } = req.body;
    const adminId = req.user?.id;

    if (typeof price !== 'number' || price < 0) {
        return res.status(400).json({ message: 'El campo "price" es requerido y debe ser un n√∫mero no negativo.' });
    }
    if (!currency || typeof currency !== 'string' || currency.length !== 3) {
        return res.status(400).json({ message: 'El campo "currency" es requerido y debe ser un c√≥digo de 3 letras.' });
    }
    if (!adminId) {
        return res.status(403).json({ message: 'No se pudo identificar al administrador.' });
    }

    try {
        const updatedBusiness = await superAdminService.setBusinessSubscriptionPrice(businessId, price, currency, adminId);
        res.status(200).json(updatedBusiness);
    } catch (error) {
        next(error);
    }
};

/**
 * Handler para registrar un pago manual.
 */
export const recordPaymentHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessId } = req.params;
    const paymentData = req.body;
    const adminId = req.user?.id;

    if (!adminId) return res.status(403).json({ message: 'No se pudo identificar al administrador.' });
    if (!paymentData || typeof paymentData.amountPaid !== 'number' || typeof paymentData.month !== 'number' || typeof paymentData.year !== 'number') {
        return res.status(400).json({ message: "Los campos 'amountPaid', 'month' y 'year' son requeridos y deben ser n√∫meros." });
    }

    try {
        const newPayment = await superAdminService.recordManualPayment(businessId, adminId, paymentData);
        res.status(201).json(newPayment);
    } catch (error) {
        next(error);
    }
};

/**
 * Handler para obtener el historial de pagos de un negocio.
 */
export const getPaymentHistoryHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessId } = req.params;
    try {
        const payments = await superAdminService.getBusinessPaymentHistory(businessId);
        res.status(200).json(payments);
    } catch (error) {
        next(error);
    }
};

// --- NUEVO HANDLER A√ëADIDO ---
/**
 * Handler para obtener los periodos de pago pendientes de un negocio.
 */
export const getPendingPeriodsHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessId } = req.params;
    try {
        const pendingPeriods = await superAdminService.getPendingPaymentPeriods(businessId);
        res.status(200).json(pendingPeriods);
    } catch (error) {
        next(error);
    }
};

/**
 * Handler para suplantar la identidad de un BUSINESS_ADMIN.
 */
export const impersonationHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { userId: targetUserId } = req.params;
    const adminId = req.user?.id;

    if (!adminId) return res.status(403).json({ message: 'No se pudo identificar al administrador.' });
    if (!targetUserId) return res.status(400).json({ message: "Se requiere el ID del usuario a suplantar." });

    try {
        const token = await superAdminService.getImpersonationToken(targetUserId, adminId);
        res.status(200).json({ token });
    } catch (error) {
        next(error);
    }
};


// ====== [82] backend/src/modules/superadmin/superadmin.service.ts ======
// backend/src/superadmin/superadmin.service.ts
import { PrismaClient, Business, Prisma, SuperAdminActionType, BusinessPayment, UserRole } from '@prisma/client';
import { differenceInCalendarMonths, getMonth, getYear, format } from 'date-fns';
import { es } from 'date-fns/locale';
import jwt from 'jsonwebtoken';

const prisma = new PrismaClient();
const JWT_SECRET = process.env.JWT_SECRET as string;

// --- TIPOS ---

export type SuperAdminBusinessListItem = Pick<
    Business,
    'id' | 'name' | 'slug' | 'isActive' | 'isLoyaltyCoreActive' | 'isCamareroActive' | 'createdAt' | 'monthlyPrice' | 'currency'
> & {
    paymentStatus: 'PAID' | 'PENDING' | 'OVERDUE' | 'NOT_CONFIGURED';
    lastPayment?: { month: number, year: number };
    pendingMonths: number;
};

type ModuleFieldInBusiness = 'isLoyaltyCoreActive' | 'isCamareroActive';


// --- SERVICIOS PRINCIPALES ---

/**
 * Obtiene todos los negocios y calcula su estado de suscripci√≥n.
 */
export const getAllBusinesses = async (): Promise<SuperAdminBusinessListItem[]> => {
    console.log("[SuperAdminService] Fetching all businesses for Super Admin panel...");
    try {
        const businesses = await prisma.business.findMany({
            orderBy: { name: 'asc' },
            include: {
                payments: {
                    orderBy: [{ year: 'desc' }, { month: 'desc' }],
                }
            }
        });

        const now = new Date();
        return businesses.map(business => {
            const lastPaymentRecord = business.payments[0];
            const lastPayment = lastPaymentRecord ? { month: lastPaymentRecord.month, year: lastPaymentRecord.year } : null;
            
            const monthsSinceCreation = differenceInCalendarMonths(now, business.createdAt);
            const paidMonthsCount = business.payments.length;
            const pendingMonths = Math.max(0, monthsSinceCreation - paidMonthsCount);
            
            let paymentStatus: 'PAID' | 'PENDING' | 'OVERDUE' | 'NOT_CONFIGURED' = 'PAID';

            if (!business.monthlyPrice || business.monthlyPrice.toNumber() === 0) {
                paymentStatus = 'NOT_CONFIGURED';
            } else if (pendingMonths > 1) {
                paymentStatus = 'OVERDUE';
            } else if (pendingMonths === 1) {
                paymentStatus = 'PENDING';
            }

            return {
                id: business.id,
                name: business.name,
                slug: business.slug,
                isActive: business.isActive,
                isLoyaltyCoreActive: business.isLoyaltyCoreActive,
                isCamareroActive: business.isCamareroActive,
                createdAt: business.createdAt,
                monthlyPrice: business.monthlyPrice,
                currency: business.currency,
                paymentStatus: paymentStatus,
                lastPayment: lastPayment || undefined,
                pendingMonths: pendingMonths,
            };
        });

    } catch (error) {
        console.error("[SuperAdminService] Error fetching all businesses:", error);
        throw new Error("Error al obtener la lista de negocios desde la base de datos.");
    }
};

/**
 * Cambia el estado 'isActive' general de un negocio y crea un log de auditor√≠a.
 */
export const toggleBusinessStatus = async (businessId: string, isActive: boolean, adminId: string): Promise<Business> => {
    console.log(`[SuperAdminService] Toggling general isActive status for business ${businessId} to ${isActive} by admin ${adminId}`);
    try {
        const business = await prisma.business.findUnique({ where: { id: businessId } });
        if (!business) {
            throw new Error(`Negocio con ID ${businessId} no encontrado.`);
        }
        
        const updatedBusiness = await prisma.business.update({
            where: { id: businessId },
            data: { isActive },
        });

        await createAuditLog({
            adminUserId: adminId,
            actionType: SuperAdminActionType.BUSINESS_STATUS_TOGGLED,
            targetBusinessId: businessId,
            details: { oldValue: business.isActive, newValue: isActive }
        });

        return updatedBusiness;
    } catch (error) {
        handleServiceError(error, `Error toggling status for business ${businessId}`);
        throw error;
    }
};

/**
 * Cambia el estado de un m√≥dulo espec√≠fico y crea un log de auditor√≠a.
 */
export const toggleModule = async (
    businessId: string,
    moduleField: ModuleFieldInBusiness,
    isActiveModule: boolean,
    adminId: string
): Promise<Business> => {
    console.log(`[SuperAdminService] Toggling module '${moduleField}' for business ${businessId} to ${isActiveModule} by admin ${adminId}`);
    try {
        const business = await prisma.business.findUnique({ where: { id: businessId } });
        if (!business) {
            throw new Error(`Negocio con ID ${businessId} no encontrado.`);
        }

        const dataToUpdate: Prisma.BusinessUpdateInput = { [moduleField]: isActiveModule };
        const updatedBusiness = await prisma.business.update({
            where: { id: businessId },
            data: dataToUpdate,
        });

        await createAuditLog({
            adminUserId: adminId,
            actionType: moduleField === 'isLoyaltyCoreActive' ? SuperAdminActionType.MODULE_LOYALTY_TOGGLED : SuperAdminActionType.MODULE_CAMARERO_TOGGLED,
            targetBusinessId: businessId,
            details: { oldValue: business[moduleField], newValue: isActiveModule, module: moduleField }
        });

        return updatedBusiness;
    } catch (error) {
        handleServiceError(error, `Error toggling module ${moduleField} for business ${businessId}`);
        throw error;
    }
};

/**
 * Establece o actualiza el precio de la suscripci√≥n mensual para un negocio.
 */
export const setBusinessSubscriptionPrice = async (businessId: string, price: number, currency: string, adminId: string): Promise<Business> => {
  console.log(`[SuperAdminService] Setting subscription price for business ${businessId} to ${price} ${currency} by admin ${adminId}`);
  try {
    const business = await prisma.business.findUnique({ where: { id: businessId } });
    if (!business) throw new Error(`Negocio con ID ${businessId} no encontrado.`);

    const updatedBusiness = await prisma.business.update({
      where: { id: businessId },
      data: { monthlyPrice: price, currency: currency },
    });

    await createAuditLog({
        adminUserId: adminId,
        actionType: SuperAdminActionType.SUBSCRIPTION_PRICE_UPDATED,
        targetBusinessId: businessId,
        details: { 
            oldPrice: business.monthlyPrice?.toNumber() ?? null,
            newPrice: price, 
            currency: currency 
        }
    });

    return updatedBusiness;
  } catch (error) {
    handleServiceError(error, `Error setting price for business ${businessId}`);
    throw error;
  }
};

/**
 * Registra un nuevo pago manual para un negocio.
 */
export const recordManualPayment = async (businessId: string, adminId: string, paymentData: { amountPaid: number; month: number; year: number; notes?: string; paymentMethod?: string }): Promise<BusinessPayment> => {
    console.log(`[SuperAdminService] Recording manual payment for business ${businessId} by admin ${adminId}`, paymentData);
    try {
        const business = await prisma.business.findUnique({ where: { id: businessId }, select: { id: true }});
        if (!business) throw new Error(`Negocio con ID ${businessId} no encontrado para registrar pago.`);

        const newPayment = await prisma.businessPayment.create({
            data: {
                businessId: businessId,
                recordedByAdminId: adminId,
                amountPaid: paymentData.amountPaid,
                month: paymentData.month,
                year: paymentData.year,
                notes: paymentData.notes,
                paymentMethod: paymentData.paymentMethod
            }
        });

        await createAuditLog({
            adminUserId: adminId,
            actionType: SuperAdminActionType.MANUAL_PAYMENT_RECORDED,
            targetBusinessId: businessId,
            details: { 
                paymentId: newPayment.id, 
                amount: newPayment.amountPaid.toNumber(),
                period: `${paymentData.month}/${paymentData.year}` 
            }
        });

        return newPayment;
    } catch (error) {
        handleServiceError(error, `Error recording payment for business ${businessId}`);
        throw error;
    }
};

/**
 * Obtiene el historial de pagos de un negocio.
 */
export const getBusinessPaymentHistory = async (businessId: string): Promise<BusinessPayment[]> => {
    console.log(`[SuperAdminService] Fetching payment history for business ${businessId}`);
    try {
        return await prisma.businessPayment.findMany({
            where: { businessId: businessId },
            orderBy: [{ year: 'desc' }, { month: 'desc' }],
        });
    } catch (error) {
        handleServiceError(error, `Error fetching payment history for business ${businessId}`);
        throw error;
    }
};

/**
 * Calcula y devuelve los periodos (mes/a√±o) pendientes de pago para un negocio.
 */
export const getPendingPaymentPeriods = async (businessId: string): Promise<{ year: number; month: number; label: string; }[]> => {
    console.log(`[SuperAdminService] Calculating pending payment periods for business ${businessId}`);
    try {
        const business = await prisma.business.findUnique({
            where: { id: businessId },
            select: { createdAt: true, payments: true }
        });
        if (!business) {
            throw new Error(`Negocio con ID ${businessId} no encontrado.`);
        }

        const paidPeriods = new Set(business.payments.map(p => `${p.year}-${p.month}`));
        const pendingPeriods: { year: number; month: number; label: string; }[] = [];
        
        let currentDate = business.createdAt;
        const now = new Date();

        while (currentDate <= now) {
            const year = getYear(currentDate);
            const month = getMonth(currentDate) + 1; // getMonth es 0-indexado
            const periodKey = `${year}-${month}`;

            if (!paidPeriods.has(periodKey)) {
                pendingPeriods.push({
                    year: year,
                    month: month,
                    label: format(currentDate, 'MMMM yyyy', { locale: es }) // Formato "junio 2025"
                });
            }
            
            // Avanzar al siguiente mes
            currentDate = new Date(year, month, 1); // El mes ya est√° 1-indexado, as√≠ que `month` es el siguiente mes
        }

        return pendingPeriods;
    } catch (error) {
        handleServiceError(error, `Error calculating pending periods for business ${businessId}`);
        throw error;
    }
};


/**
 * Genera un token de suplantaci√≥n para un BUSINESS_ADMIN.
 */
export const getImpersonationToken = async (targetUserId: string, adminId: string): Promise<string> => {
    console.log(`[SuperAdminService] Admin ${adminId} requesting impersonation token for user ${targetUserId}`);
    try {
        const targetUser = await prisma.user.findUnique({ where: { id: targetUserId }});

        if (!targetUser || targetUser.role !== UserRole.BUSINESS_ADMIN) {
            throw new Error('El usuario a suplantar no existe o no es un administrador de negocio.');
        }

        const payload = {
            userId: targetUser.id,
            role: targetUser.role,
            businessId: targetUser.businessId,
            impersonated_by: adminId 
        };
        const token = jwt.sign(payload, JWT_SECRET, { expiresIn: '1h' }); 

        await createAuditLog({
            adminUserId: adminId,
            actionType: SuperAdminActionType.IMPERSONATION_STARTED,
            targetBusinessId: targetUser.businessId,
            details: { targetUserId: targetUser.id, targetUserEmail: targetUser.email }
        });

        return token;
    } catch (error) {
        handleServiceError(error, `Error generating impersonation token for user ${targetUserId}`);
        throw error;
    }
};


// --- FUNCIONES HELPERS ---

/**
 * Helper para crear una entrada en el log de auditor√≠a del Super Admin.
 */
async function createAuditLog(data: {
    adminUserId: string;
    actionType: SuperAdminActionType;
    targetBusinessId?: string | null;
    details?: Prisma.JsonValue;
}) {
    try {
        const createData: Prisma.SuperAdminActivityLogCreateInput = {
            actionType: data.actionType,
            details: data.details || Prisma.JsonNull,
            adminUser: {
                connect: { id: data.adminUserId }
            }
        };

        if (data.targetBusinessId) {
            createData.targetBusiness = {
                connect: { id: data.targetBusinessId }
            };
        }

        await prisma.superAdminActivityLog.create({ data: createData });

    } catch (auditError) {
        console.error(`[SuperAdminService] CRITICAL: FAILED TO CREATE AUDIT LOG!`, auditError, `Original Action Data:`, data);
    }
}

/**
 * Helper para manejar y loguear errores de Prisma de forma consistente.
 */
function handleServiceError(error: unknown, contextMessage: string) {
    console.error(`[SuperAdminService] ${contextMessage}:`, error);
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') {
            throw new Error(`El registro solicitado no fue encontrado.`);
        }
        if (error.code === 'P2002') {
            throw new Error(`Error de unicidad: Ya existe un registro con estos datos (${(error.meta?.target as string[])?.join(', ')}).`);
        }
    }
}


// ====== [83] backend/src/routes/activity.routes.ts ======
// backend/src/routes/activity.routes.ts (CORREGIDO)
import { Router } from 'express';
// --- RUTA CORREGIDA ---
import { getCustomerActivityHandler } from '../modules/loyalpyme/activity/activity.controller';
// --- FIN RUTA CORREGIDA ---

const activityRouter = Router();

// GET / - Obtiene el historial paginado del cliente
activityRouter.get('/', getCustomerActivityHandler);

export default activityRouter;


// ====== [84] backend/src/routes/admin.routes.ts ======
// backend/src/routes/admin.routes.ts (CORREGIDO)

import { Router } from 'express';
// UserRole no es necesario aqu√≠ si checkRole no se usa directamente
// import { UserRole } from '@prisma/client';

// --- RUTAS DE MIDDLEWARE CORREGIDAS ---
import { checkRole } from '../shared/middleware/role.middleware';
import upload from '../shared/middleware/multer.config';

// --- RUTAS DE CONTROLADORES CORREGIDAS ---
import { getAdminCustomers } from '../modules/loyalpyme/admin/admin-customer-list.controller';
import {
    getCustomerDetailsHandler,
    updateCustomerNotesHandler,
    adjustCustomerPoints,
    changeCustomerTierHandler,
    assignRewardHandler,
    toggleFavoriteHandler,
    toggleActiveStatusHandler
} from '../modules/loyalpyme/admin/admin-customer-individual.controller';
import {
    bulkUpdateCustomerStatusHandler,
    bulkDeleteCustomersHandler,
    bulkAdjustPointsHandler
} from '../modules/loyalpyme/admin/admin-customer-bulk.controller';
import { handleGetOverviewStats } from '../modules/loyalpyme/admin/admin-stats.controller';
import { handleImageUpload } from '../shared/uploads/uploads.controller';


const router = Router();

// NOTA: El middleware checkRole([UserRole.BUSINESS_ADMIN]) se aplica en /src/routes/index.ts
// antes de montar este router, por lo que no es necesario volver a aplicarlo aqu√≠.

// Ruta para Estad√≠sticas
router.get('/stats/overview', handleGetOverviewStats);

// --- Rutas espec√≠ficas de Admin relacionadas con Clientes (sin cambios en la l√≥gica) ---
router.get('/customers', getAdminCustomers);
router.get('/customers/:customerId/details', getCustomerDetailsHandler);
router.patch('/customers/:customerId/notes', updateCustomerNotesHandler);
router.post('/customers/:customerId/adjust-points', adjustCustomerPoints);
router.put('/customers/:customerId/tier', changeCustomerTierHandler);
router.post('/customers/:customerId/assign-reward', assignRewardHandler);
router.patch('/customers/:customerId/toggle-favorite', toggleFavoriteHandler);
router.patch('/customers/:customerId/toggle-active', toggleActiveStatusHandler);
router.patch('/customers/bulk-status', bulkUpdateCustomerStatusHandler);
router.delete('/customers/bulk-delete', bulkDeleteCustomersHandler);
router.post('/customers/bulk-adjust-points', bulkAdjustPointsHandler);

// Ruta para subida de imagen de recompensa
router.post(
    '/upload/reward-image',
    upload.single('imageFile'),
    handleImageUpload
);

export default router;


// ====== [85] backend/src/routes/auth.routes.ts ======
// backend/src/routes/auth.routes.ts (CORREGIDO)

import { Router } from 'express';

// --- RUTAS CORREGIDAS ---
import { login } from '../shared/auth/auth.controller';
import { register, registerBusinessHandler } from '../shared/auth/registration.controller';
import { forgotPasswordHandler, resetPasswordHandler } from '../shared/auth/password-reset.controller';
// --- FIN RUTAS CORREGIDAS ---

const router = Router();

// --- Rutas de autenticaci√≥n (sin cambios en la l√≥gica) ---
router.post('/register', register);
router.post('/register-business', registerBusinessHandler);
router.post('/login', login);
router.post('/forgot-password', forgotPasswordHandler);
router.post('/reset-password/:token', resetPasswordHandler);

export default router;


// ====== [86] backend/src/routes/businesses.routes.ts ======
// backend/src/routes/businesses.routes.ts (CORREGIDO)

import { Router } from 'express';
// --- RUTA CORREGIDA ---
import { handleGetPublicBusinesses } from '../shared/businesses/businesses.controller';
// --- FIN RUTA CORREGIDA ---

const businessRouter = Router();

businessRouter.get(
    '/public-list',
    handleGetPublicBusinesses
);

export default businessRouter;


// ====== [87] backend/src/routes/camarero-admin.routes.ts ======
// backend/src/routes/camarero-admin.routes.ts
import { Router } from 'express';
import { authenticateToken } from '../shared/middleware/auth.middleware';
import { checkRole } from '../shared/middleware/role.middleware';
import { UserRole } from '@prisma/client';
import { checkModuleActive } from '../shared/middleware/module.middleware';

// Controladores
import {
    createMenuCategoryHandler,
    getMenuCategoriesHandler,
    getMenuCategoryByIdHandler,
    updateMenuCategoryHandler,
    deleteMenuCategoryHandler
} from '../modules/camarero/admin-menu-category.controller';

import {
    createMenuItemHandler,
    getMenuItemsByCategoryHandler,
    getMenuItemByIdHandler,
    updateMenuItemHandler,
    deleteMenuItemHandler,
    getAllMenuItemsForBusinessHandler // <-- IMPORTACI√ìN A√ëADIDA
} from '../modules/camarero/admin-menu-item.controller';

import {
    createModifierGroupHandler,
    getModifierGroupsByMenuItemHandler,
    updateModifierGroupHandler,
    deleteModifierGroupHandler,
    createModifierOptionHandler,
    getModifierOptionsByGroupHandler,
    updateModifierOptionHandler,
    deleteModifierOptionHandler
} from '../modules/camarero/admin-modifier.controller';

const camareroAdminRouter = Router();

// Middlewares aplicados a TODAS las rutas definidas en este router:
camareroAdminRouter.use(authenticateToken);
camareroAdminRouter.use(checkRole([UserRole.BUSINESS_ADMIN]));
camareroAdminRouter.use(checkModuleActive('CAMARERO'));

// --- RUTAS PARA GESTI√ìN DE CATEGOR√çAS DEL MEN√ö ---
const categoriesBase = '/menu/categories';
camareroAdminRouter.post(categoriesBase, createMenuCategoryHandler);
camareroAdminRouter.get(categoriesBase, getMenuCategoriesHandler);
camareroAdminRouter.get(`${categoriesBase}/:categoryId`, getMenuCategoryByIdHandler);
camareroAdminRouter.put(`${categoriesBase}/:categoryId`, updateMenuCategoryHandler);
camareroAdminRouter.patch(`${categoriesBase}/:categoryId`, updateMenuCategoryHandler);
camareroAdminRouter.delete(`${categoriesBase}/:categoryId`, deleteMenuCategoryHandler);

// --- RUTAS PARA GESTI√ìN DE √çTEMS DEL MEN√ö ---
const itemsBaseRelative = '/items';
const itemsBaseAbsolute = '/menu/items';

camareroAdminRouter.post(`${categoriesBase}/:categoryId${itemsBaseRelative}`, createMenuItemHandler);
camareroAdminRouter.get(`${categoriesBase}/:categoryId${itemsBaseRelative}`, getMenuItemsByCategoryHandler);

// --- RUTA NUEVA A√ëADIDA ---
// Obtiene TODOS los items del negocio para los selectores del admin.
// Debe ir ANTES de la ruta /:itemId para que "all" no se interprete como un ID.
camareroAdminRouter.get(`${itemsBaseAbsolute}/all`, getAllMenuItemsForBusinessHandler);
// --- FIN RUTA NUEVA ---

camareroAdminRouter.get(`${itemsBaseAbsolute}/:itemId`, getMenuItemByIdHandler);
camareroAdminRouter.put(`${itemsBaseAbsolute}/:itemId`, updateMenuItemHandler);
camareroAdminRouter.patch(`${itemsBaseAbsolute}/:itemId`, updateMenuItemHandler);
camareroAdminRouter.delete(`${itemsBaseAbsolute}/:itemId`, deleteMenuItemHandler);

// --- RUTAS PARA GESTI√ìN DE MODIFICADORES ---
const modifierGroupsBaseRelative = '/modifier-groups';
const modifierGroupsBaseAbsolute = '/modifier-groups';
const modifierOptionsBaseRelative = '/options';
const modifierOptionsBaseAbsolute = '/modifier-options';

camareroAdminRouter.post(`${itemsBaseAbsolute}/:itemId${modifierGroupsBaseRelative}`, createModifierGroupHandler);
camareroAdminRouter.get(`${itemsBaseAbsolute}/:itemId${modifierGroupsBaseRelative}`, getModifierGroupsByMenuItemHandler);
camareroAdminRouter.put(`${modifierGroupsBaseAbsolute}/:modifierGroupId`, updateModifierGroupHandler);
camareroAdminRouter.patch(`${modifierGroupsBaseAbsolute}/:modifierGroupId`, updateModifierGroupHandler);
camareroAdminRouter.delete(`${modifierGroupsBaseAbsolute}/:modifierGroupId`, deleteModifierGroupHandler);
camareroAdminRouter.post(`${modifierGroupsBaseAbsolute}/:modifierGroupId${modifierOptionsBaseRelative}`, createModifierOptionHandler);
camareroAdminRouter.get(`${modifierGroupsBaseAbsolute}/:modifierGroupId${modifierOptionsBaseRelative}`, getModifierOptionsByGroupHandler);
camareroAdminRouter.put(`${modifierOptionsBaseAbsolute}/:modifierOptionId`, updateModifierOptionHandler);
camareroAdminRouter.patch(`${modifierOptionsBaseAbsolute}/:modifierOptionId`, updateModifierOptionHandler);
camareroAdminRouter.delete(`${modifierOptionsBaseAbsolute}/:modifierOptionId`, deleteModifierOptionHandler);

camareroAdminRouter.get('/', (req, res) => {
    res.json({ message: `[CAMARERO ADMIN] Panel de administraci√≥n del m√≥dulo Camarero para businessId: ${req.user?.businessId}` });
});

export default camareroAdminRouter;


// ====== [88] backend/src/routes/camarero-kds.routes.ts ======
// backend/src/routes/camarero-kds.routes.ts (CORREGIDO)
import { Router } from 'express';
// --- RUTAS CORREGIDAS ---
import { authenticateToken } from '../shared/middleware/auth.middleware';
import { checkRole } from '../shared/middleware/role.middleware';
import { checkModuleActive } from '../shared/middleware/module.middleware';
import { UserRole } from '@prisma/client';

import {
    getItemsForKdsHandler,
    updateOrderItemStatusHandler
} from '../modules/camarero/kds.controller';
// --- FIN RUTAS CORREGIDAS ---


const camareroKdsRouter = Router();

// Middlewares
camareroKdsRouter.use(authenticateToken);
camareroKdsRouter.use(checkModuleActive('CAMARERO'));
camareroKdsRouter.use(checkRole([
    UserRole.KITCHEN_STAFF,
    UserRole.BAR_STAFF,
    UserRole.BUSINESS_ADMIN
]));

// Rutas KDS
camareroKdsRouter.get('/items', getItemsForKdsHandler);
camareroKdsRouter.patch('/items/:orderItemId/status', updateOrderItemStatusHandler);

// Placeholder
camareroKdsRouter.get('/', (req, res) => {
    res.json({
        message: `[KDS API] Endpoints KDS para el negocio: ${req.user?.businessId}. Roles del usuario: ${req.user?.role}`
    });
});

export default camareroKdsRouter;


// ====== [89] backend/src/routes/customer.routes.ts ======
// backend/src/routes/customer.routes.ts
// VERSI√ìN 2.4.1 - CORRECCI√ìN DE HANDLER PARA granted-rewards

import { Router } from 'express';
import { UserRole } from '@prisma/client';

import { checkRole } from '../shared/middleware/role.middleware';
import { checkModuleActive } from '../shared/middleware/module.middleware';

import {
    getCustomerRewardsHandler,
    getGrantedRewardsHandler, // <-- Se usa el nuevo handler
    redeemGrantedRewardHandler,
    getCustomerTiersHandler,
    getCustomerBusinessConfigHandler,
    getAvailableCouponsHandler,
    getCustomerOrdersHandler
} from '../modules/loyalpyme/customer/customer.controller';

import activityRouter from './activity.routes';

const router = Router();
const loyaltyCoreRequired = checkModuleActive('LOYALTY_CORE');

// --- RUTA CORREGIDA ---
// Ahora esta ruta llama al handler que devuelve TODOS los GrantedRewards.
router.get('/granted-rewards', checkRole([UserRole.CUSTOMER_FINAL]), loyaltyCoreRequired, getGrantedRewardsHandler);
// --- FIN RUTA CORREGIDA ---

// El resto de rutas se mantienen igual
router.get('/rewards', checkRole([UserRole.CUSTOMER_FINAL]), loyaltyCoreRequired, getCustomerRewardsHandler);
router.post('/granted-rewards/:grantedRewardId/redeem', checkRole([UserRole.CUSTOMER_FINAL]), loyaltyCoreRequired, redeemGrantedRewardHandler);
router.get('/available-coupons', checkRole([UserRole.CUSTOMER_FINAL]), loyaltyCoreRequired, getAvailableCouponsHandler);
router.get('/tiers', checkRole([UserRole.CUSTOMER_FINAL]), loyaltyCoreRequired, getCustomerTiersHandler);
router.get('/business-config', checkRole([UserRole.CUSTOMER_FINAL]), loyaltyCoreRequired, getCustomerBusinessConfigHandler);
router.get('/orders', checkRole([UserRole.CUSTOMER_FINAL]), loyaltyCoreRequired, getCustomerOrdersHandler);
router.use('/activity', checkRole([UserRole.CUSTOMER_FINAL]), loyaltyCoreRequired, activityRouter);


export default router;


// ====== [90] backend/src/routes/index.ts ======
// backend/src/routes/index.ts
// VERSI√ìN CORREGIDA - ELIMINA EL MIDDLEWARE DE ROL GLOBAL PARA /rewards

import { Router } from 'express';
import { UserRole } from '@prisma/client';

// Middlewares
import { authenticateToken } from '../shared/middleware/auth.middleware';
import { checkRole } from '../shared/middleware/role.middleware';

// Routers
import authRouter from './auth.routes';
import protectedRouter from './protected.routes';
import rewardsRouter from './rewards.routes'; // Importa el router que ya corregimos
import pointsRouter from './points.routes';
import customerRouter from './customer.routes';
import tierRouter from './tiers.routes';
import adminRouter from './admin.routes';
import uploadsRouter from './uploads.routes';
import superAdminRouter from './superadmin.routes';
import camareroAdminRouter from './camarero-admin.routes';
import camareroKdsRouter from './camarero-kds.routes';
import waiterRouter from './waiter.routes';
import businessRouter from './businesses.routes';
import publicMenuRouter from './public-menu.routes';
import publicOrderRouter from './public-order.routes';

// Router para las rutas /api
const apiRouter = Router();

// Rutas con su propia l√≥gica de autenticaci√≥n o semi-p√∫blicas
apiRouter.use('/auth', authRouter);
apiRouter.use('/superadmin', superAdminRouter);

// Rutas de Camarero
apiRouter.use('/camarero/admin', camareroAdminRouter);
apiRouter.use('/camarero/kds', camareroKdsRouter);
apiRouter.use('/camarero/staff', waiterRouter);

// Aplicar autenticaci√≥n general A PARTIR DE AQU√ç
apiRouter.use(authenticateToken);

// --- CORRECCI√ìN CLAVE AQU√ç ---
// Montamos /rewards SIN el middleware checkRole. La l√≥gica de roles
// ya est√° dentro de rewards.routes.ts para cada ruta espec√≠fica.
apiRouter.use('/rewards', rewardsRouter);
// --- FIN DE LA CORRECCI√ìN ---

// Rutas protegidas que s√≠ tienen un rol com√∫n
apiRouter.use('/profile', protectedRouter); // No necesita rol, solo autenticaci√≥n
apiRouter.use('/points', pointsRouter); // La l√≥gica de rol est√° dentro
apiRouter.use('/customer', checkRole([UserRole.CUSTOMER_FINAL]), customerRouter);
apiRouter.use('/tiers', checkRole([UserRole.BUSINESS_ADMIN]), tierRouter);
apiRouter.use('/admin', checkRole([UserRole.BUSINESS_ADMIN]), adminRouter);
apiRouter.use('/uploads', checkRole([UserRole.BUSINESS_ADMIN, UserRole.SUPER_ADMIN]), uploadsRouter);

// Router para las rutas /public (sin cambios)
const publicRouterApi = Router();
publicRouterApi.use('/businesses', businessRouter);
publicRouterApi.use('/menu', publicMenuRouter);
publicRouterApi.use('/order', publicOrderRouter);

export { apiRouter, publicRouterApi as publicRouter };


// ====== [91] backend/src/routes/points.routes.ts ======
// backend/src/routes/points.routes.ts (CORREGIDO)
import { Router } from 'express';
import { UserRole } from '@prisma/client';
// --- RUTAS CORREGIDAS ---
import { checkRole } from '../shared/middleware/role.middleware';
import { generateQrHandler, validateQrHandler, redeemRewardHandler } from '../modules/loyalpyme/points/points.controller';
// --- FIN RUTAS CORREGIDAS ---

const router = Router();

// Rutas para la gesti√≥n de puntos y QR con Roles
router.post('/generate-qr', checkRole([UserRole.BUSINESS_ADMIN]), generateQrHandler);
router.post('/validate-qr', checkRole([UserRole.CUSTOMER_FINAL]), validateQrHandler);
router.post('/redeem-reward/:rewardId', checkRole([UserRole.CUSTOMER_FINAL]), redeemRewardHandler);

export default router;


// ====== [92] backend/src/routes/protected.routes.ts ======
// backend/src/routes/protected.routes.ts
import { Router } from 'express';

// Se importan los handlers del controlador de perfil
import {
    getProfileHandler,
    updateProfileHandler,
    changePasswordHandler
} from '../modules/loyalpyme/customer/profile.controller';

// --- CORRECCI√ìN: Importar el middleware de multer ---
import uploadImageMemory from '../shared/middleware/multer.config';

const router = Router();

// El middleware de autenticaci√≥n ya se aplica antes de montar este router

// GET /api/profile (sin cambios)
router.get('/', getProfileHandler);

// --- CORRECCI√ìN: Aplicar el middleware de multer a la ruta PUT ---
// Ahora, esta ruta aceptar√° un campo de formulario llamado 'profileImage'
router.put(
    '/',
    uploadImageMemory.single('profileImage'), // 'profileImage' debe coincidir con el nombre del campo en el FormData del frontend
    updateProfileHandler
);
// --- FIN DE LA CORRECCI√ìN ---

// POST /api/profile/change-password (sin cambios)
router.post('/change-password', changePasswordHandler);

export default router;


// ====== [93] backend/src/routes/public-menu.routes.ts ======
// backend/src/routes/public-menu.routes.ts (CORREGIDO)
import { Router } from 'express';
// --- RUTA CORREGIDA ---
import { getPublicDigitalMenuHandler } from '../modules/camarero/public/menu.controller';
// --- FIN RUTA CORREGIDA ---

const publicMenuRouter = Router();

publicMenuRouter.get(
    '/business/:businessSlug',
    getPublicDigitalMenuHandler
);

export default publicMenuRouter;


// ====== [94] backend/src/routes/public-order.routes.ts ======
// backend/src/routes/public-order.routes.ts
import { Router } from 'express';
import {
    createPublicOrderHandler,
    getPublicOrderStatusHandler,
    addItemsToExistingOrderHandler,
    requestBillByClientHandler,
    applyRewardHandler // <-- Este import ahora funcionar√°
} from '../modules/camarero/public/order.controller';

const publicOrderRouter = Router();

// Ruta para crear un pedido
publicOrderRouter.post(
    '/:businessSlug',
    createPublicOrderHandler
);

// Ruta para obtener el estado del pedido
publicOrderRouter.get(
    '/:orderId/status',
    getPublicOrderStatusHandler
);

// Ruta para a√±adir √≠tems a un pedido existente
publicOrderRouter.post(
    '/:orderId/items',
    addItemsToExistingOrderHandler
);

// Ruta para que el cliente solicite la cuenta
publicOrderRouter.post(
    '/:orderId/request-bill',
    requestBillByClientHandler
);

// Ruta para aplicar una recompensa (cup√≥n) a un pedido
publicOrderRouter.patch(
    '/:orderId/apply-reward',
    applyRewardHandler
);

export default publicOrderRouter;


// ====== [95] backend/src/routes/rewards.routes.ts ======
// backend/src/routes/rewards.routes.ts
// VERSI√ìN 4.0.0 - SIMPLIFIED: Only includes CRUD endpoints for Admin panel.

import { Router } from 'express';
import { UserRole } from '@prisma/client';
import { checkRole } from '../shared/middleware/role.middleware';
import { checkModuleActive } from '../shared/middleware/module.middleware';
import {
    createRewardHandler,
    getRewardsHandler,
    getRewardByIdHandler,
    updateRewardHandler,
    deleteRewardHandler,
} from '../modules/loyalpyme/rewards/rewards.controller';


const router = Router();
const loyaltyCoreRequired = checkModuleActive('LOYALTY_CORE');

// --- Rutas para que el BUSINESS_ADMIN gestione el cat√°logo de recompensas ---
// Estas rutas requieren que el usuario est√© autenticado, sea BUSINESS_ADMIN y tenga el m√≥dulo de lealtad activo.
// Estos middlewares se aplican en el router principal (index.ts) antes de llegar aqu√≠.

router.post('/', checkRole([UserRole.BUSINESS_ADMIN]), loyaltyCoreRequired, createRewardHandler);
router.get('/', checkRole([UserRole.BUSINESS_ADMIN]), loyaltyCoreRequired, getRewardsHandler);
router.get('/:id', checkRole([UserRole.BUSINESS_ADMIN]), loyaltyCoreRequired, getRewardByIdHandler);
router.put('/:id', checkRole([UserRole.BUSINESS_ADMIN]), loyaltyCoreRequired, updateRewardHandler);
router.patch('/:id', checkRole([UserRole.BUSINESS_ADMIN]), loyaltyCoreRequired, updateRewardHandler);
router.delete('/:id', checkRole([UserRole.BUSINESS_ADMIN]), loyaltyCoreRequired, deleteRewardHandler);

// --- RUTAS OBSOLETAS ELIMINADAS ---
// La ruta POST /:id/redeem que era para los clientes ya no existe en este archivo.
// La l√≥gica de canje ahora est√° 100% contenida dentro de la creaci√≥n del pedido.

export default router;


// ====== [96] backend/src/routes/superadmin.routes.ts ======
// backend/src/routes/superadmin.routes.ts (CORREGIDO)
import { Router } from 'express';
import { UserRole } from '@prisma/client';
// --- RUTAS CORREGIDAS ---
import { authenticateToken } from '../shared/middleware/auth.middleware';
import { checkRole } from '../shared/middleware/role.middleware';
import {
    getAllBusinessesHandler,
    toggleBusinessStatusHandler,
    toggleLoyaltyCoreModuleHandler,
    toggleCamareroModuleHandler,
    setSubscriptionPriceHandler,
    recordPaymentHandler,
    getPaymentHistoryHandler,
    impersonationHandler,
    getPendingPeriodsHandler
} from '../modules/superadmin/superadmin.controller';
// --- FIN RUTAS CORREGIDAS ---


const router = Router();

// Middleware para todas las rutas de superadmin
router.use(authenticateToken);
router.use(checkRole([UserRole.SUPER_ADMIN]));

// Rutas de Superadmin (sin cambios en la l√≥gica)
router.get('/businesses', getAllBusinessesHandler);
router.patch('/businesses/:businessId/status', toggleBusinessStatusHandler);
router.patch('/businesses/:businessId/module-loyaltycore', toggleLoyaltyCoreModuleHandler);
router.patch('/businesses/:businessId/module-camarero', toggleCamareroModuleHandler);
router.put('/businesses/:businessId/subscription', setSubscriptionPriceHandler);
router.post('/businesses/:businessId/payments', recordPaymentHandler);
router.get('/businesses/:businessId/payments', getPaymentHistoryHandler);
router.get('/businesses/:businessId/pending-payments', getPendingPeriodsHandler);
router.post('/impersonate/:userId', impersonationHandler);

export default router;


// ====== [97] backend/src/routes/tiers.routes.ts ======
// backend/src/routes/tiers.routes.ts (CORREGIDO)
import { Router } from 'express';
import { UserRole } from '@prisma/client';
// --- RUTAS CORREGIDAS ---
import { checkRole } from '../shared/middleware/role.middleware';
import { checkModuleActive } from '../shared/middleware/module.middleware';
import { getBusinessTierConfigHandler, updateBusinessTierConfigHandler } from '../modules/loyalpyme/tiers/tier-config.controller';
import { createTierHandler, getBusinessTiersHandler, getTierByIdHandler, updateTierHandler, deleteTierHandler } from '../modules/loyalpyme/tiers/tier-crud.controller';
import { createTierBenefitHandler, getTierBenefitsHandler, updateTierBenefitHandler, deleteTierBenefitHandler } from '../modules/loyalpyme/tiers/tier-benefit.controller';
// --- FIN RUTAS CORREGIDAS ---

const tierRouter = Router();
const adminOnly = checkRole([UserRole.BUSINESS_ADMIN]);
const loyaltyCoreRequired = checkModuleActive('LOYALTY_CORE');

// Rutas de Configuraci√≥n
tierRouter.get('/config', adminOnly, loyaltyCoreRequired, getBusinessTierConfigHandler);
tierRouter.put('/config', adminOnly, loyaltyCoreRequired, updateBusinessTierConfigHandler);

// Rutas para Tiers CRUD
tierRouter.post('/tiers', adminOnly, loyaltyCoreRequired, createTierHandler);
tierRouter.get('/', adminOnly, loyaltyCoreRequired, getBusinessTiersHandler);
tierRouter.get('/tiers/:tierId', adminOnly, loyaltyCoreRequired, getTierByIdHandler);
tierRouter.put('/tiers/:tierId', adminOnly, loyaltyCoreRequired, updateTierHandler);
tierRouter.patch('/tiers/:tierId', adminOnly, loyaltyCoreRequired, updateTierHandler);
tierRouter.delete('/tiers/:tierId', adminOnly, loyaltyCoreRequired, deleteTierHandler);

// Rutas para Beneficios
tierRouter.post('/tiers/:tierId/benefits', adminOnly, loyaltyCoreRequired, createTierBenefitHandler);
tierRouter.get('/tiers/:tierId/benefits', adminOnly, loyaltyCoreRequired, getTierBenefitsHandler);
tierRouter.put('/benefits/:benefitId', adminOnly, loyaltyCoreRequired, updateTierBenefitHandler);
tierRouter.delete('/benefits/:benefitId', adminOnly, loyaltyCoreRequired, deleteTierBenefitHandler);

export default tierRouter;


// ====== [98] backend/src/routes/uploads.routes.ts ======
// backend/src/routes/uploads.routes.ts (CORREGIDO)
import { Router } from 'express';
// --- RUTAS CORREGIDAS ---
import { handleImageUpload } from '../shared/uploads/uploads.controller';
import uploadImageMemory from '../shared/middleware/multer.config';
// --- FIN RUTAS CORREGIDAS ---

const uploadsRouter = Router();

// Ruta para subir im√°genes
uploadsRouter.post(
    '/image',
    uploadImageMemory.single('image'),
    handleImageUpload
);

export default uploadsRouter;


// ====== [99] backend/src/routes/waiter.routes.ts ======
// backend/src/routes/waiter.routes.ts (CORREGIDO)
import { Router } from 'express';
import { UserRole } from '@prisma/client';
// --- RUTAS CORREGIDAS ---
import { authenticateToken } from '../shared/middleware/auth.middleware';
import { checkRole } from '../shared/middleware/role.middleware';
import { checkModuleActive } from '../shared/middleware/module.middleware';

import {
    getReadyForPickupItemsHandler,
    markOrderItemServedHandler,
    requestBillByStaffHandler,
    markOrderAsPaidHandler,
    getStaffOrdersHandler
} from '../modules/camarero/waiter.controller';
// --- FIN RUTAS CORREGIDAS ---

const waiterRouter = Router();

// Middlewares
waiterRouter.use(authenticateToken);
waiterRouter.use(checkModuleActive('CAMARERO'));
waiterRouter.use(checkRole([UserRole.WAITER, UserRole.BUSINESS_ADMIN]));

// Rutas (sin cambios en la l√≥gica)
waiterRouter.get('/ready-for-pickup', getReadyForPickupItemsHandler);
waiterRouter.patch('/order-items/:orderItemId/status', markOrderItemServedHandler);
waiterRouter.post('/order/:orderId/request-bill', requestBillByStaffHandler);
waiterRouter.post('/order/:orderId/mark-as-paid', markOrderAsPaidHandler);
waiterRouter.get('/orders', getStaffOrdersHandler);

export default waiterRouter;


// ====== [100] backend/src/shared/auth/__tests__/auth.service.test.ts ======
import { describe, it, expect } from 'vitest';
import { hashPassword, comparePassword } from '../auth.service'; // Ajusta ruta si auth.service no est√° en el nivel superior

describe('Auth Service Helpers', () => {
  it('should hash a password correctly', async () => {
    const plainPassword = 'password123';
    const hashedPassword = await hashPassword(plainPassword);

    expect(hashedPassword).toBeTypeOf('string');
    expect(hashedPassword).not.toBe(plainPassword);
    expect(hashedPassword.length).toBeGreaterThan(50);
  });

  it('should compare a correct password successfully', async () => {
    const plainPassword = 'password123';
    const hashedPassword = await hashPassword(plainPassword);
    const isMatch = await comparePassword(plainPassword, hashedPassword);

    expect(isMatch).toBe(true);
  });

  it('should fail comparing an incorrect password', async () => {
    const plainPassword = 'password123';
    const wrongPassword = 'password456';
    const hashedPassword = await hashPassword(plainPassword);
    const isMatch = await comparePassword(wrongPassword, hashedPassword);

    expect(isMatch).toBe(false);
  });
});


// ====== [101] backend/src/shared/auth/auth.controller.ts ======
// filename: backend/src/auth/auth.controller.ts
// Version: 2.1.0 (Refactored: Only contains login handler, cleaned)

import { Request, Response } from 'express';
import { User } from '@prisma/client'; // Needed for type casting if generateToken expects User

// Importar solo utilidades necesarias para login desde auth.service
import { comparePassword, generateToken, findUserByEmail } from './auth.service';

/**
 * Handles user login. POST /api/auth/login
 */
export const login = async (req: Request, res: Response) => {
    const { email, password } = req.body;
    // console.log(`[AUTH CTRL] Attempting login for email: ${email}`); // Log reducido

    if (!email || !password) {
        // console.log('[AUTH CTRL] Login failed: Email or password missing.'); // Log reducido
        return res.status(400).json({ message: 'Se requieren email y contrase√±a.' }); // Corregido: contrase√±a
    }

    try {
        // console.log(`[AUTH CTRL] Finding user by email: ${email}`); // Log reducido
        const user = await findUserByEmail(email);
        if (!user || !user.isActive) {
            // console.log(`[AUTH CTRL] User not found or inactive for email: ${email}. Sending 401.`); // Log reducido
            // Devolvemos 401 Unauthorized para ambos casos (no encontrado o inactivo) por seguridad
            return res.status(401).json({ message: 'Credenciales inv√°lidas o usuario inactivo.' }); // Corregido: inv√°lidas
        }

        // console.log(`[AUTH CTRL] User found: ${user.id}. Comparing password...`); // Log reducido
        const passwordMatch = await comparePassword(password, user.password);
        if (!passwordMatch) {
            // console.log(`[AUTH CTRL] Password mismatch for user ${user.id}. Sending 401.`); // Log reducido
            return res.status(401).json({ message: 'Credenciales inv√°lidas.' }); // Corregido: inv√°lidas
        }

        // console.log(`[AUTH CTRL] Password matches for user ${user.id}. Generating token...`); // Log reducido
        const token = generateToken(user); // generateToken necesita id, role, businessId

        // Excluimos campos sensibles de la respuesta. Ahora quitamos las variables no usadas directamente.
        const {
            password: _password, // Renombrar para evitar conflicto y marcar como no usado
            documentId: _documentId,
            resetPasswordToken: _resetPasswordToken,
            resetPasswordExpires: _resetPasswordExpires,
            ...userWithoutSensitiveData // El resto de campos del usuario
        } = user;

        console.log(`[AUTH CTRL] Login successful for user ${user.id}. Sending 200.`);
        res.status(200).json({ user: userWithoutSensitiveData, token });

    } catch (error) {
        console.error('[AUTH CTRL] Error during login:', error); // Mantener log de error
        res.status(500).json({ message: 'Error del servidor durante el inicio de sesi√≥n.' }); // Corregido: sesi√≥n
    }
};

// Las funciones register, registerBusinessHandler, forgotPasswordHandler, resetPasswordHandler han sido movidas.

// End of File: backend/src/auth/auth.controller.ts


// ====== [102] backend/src/shared/auth/auth.dto.ts ======
// filename: backend/src/auth/auth.dto.ts
// --- INICIO DEL C√ìDIGO COMPLETO ---
// File: backend/src/auth/auth.dto.ts
// Version: 1.2.0 (Add RegisterBusinessDto)

import { UserRole, DocumentType } from '@prisma/client';

// DTO para Registro de Cliente (existente)
export interface RegisterUserDto {
  email: string;
  password: string;
  name?: string;
  phone: string; // Tel√©fono del cliente
  documentId: string; // Documento del cliente
  documentType: DocumentType; // Tipo doc cliente
  businessId: string; // ID del negocio al que se une
  role: UserRole; // Debe ser CUSTOMER_FINAL
}

// DTO para solicitar reseteo (existente)
export interface ForgotPasswordDto {
    email: string;
}

// DTO para realizar el reseteo (existente)
export interface ResetPasswordDto {
    password: string; // La nueva contrase√±a
    // El token vendr√° por la URL (req.params)
}

// --- NUEVO: DTO para registrar un Negocio y su Admin ---
export interface RegisterBusinessDto {
    businessName: string;   // Nombre del nuevo negocio
    adminEmail: string;     // Email para el usuario administrador inicial
    adminPassword: string;  // Contrase√±a para ese administrador
    adminName?: string;      // Nombre opcional para el administrador
    // No necesitamos m√°s datos por ahora para el MVP (slug se generar√°, etc.)
    // No pasamos role porque siempre ser√° BUSINESS_ADMIN
    // No pasamos businessId porque se va a crear uno nuevo
}
// --- FIN NUEVO ---


// End of File: backend/src/auth/auth.dto.ts
// --- FIN DEL C√ìDIGO COMPLETO ---


// ====== [103] backend/src/shared/auth/auth.service.ts ======
// filename: backend/src/auth/auth.service.ts
// Version: 2.1.0 (Add conditional logging for test environment)

import { PrismaClient, User } from '@prisma/client';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

const prisma = new PrismaClient();
const JWT_SECRET = process.env.JWT_SECRET as string;

// Validaci√≥n de JWT_SECRET
if (!JWT_SECRET) {
    console.error('FATAL ERROR: JWT_SECRET is not defined in auth.service.');
    // process.exit(1); // Considerar salir
}

// --- Funciones de Utilidad B√°sicas ---

/**
 * Hashea una contrase√±a usando bcrypt.
 */
export const hashPassword = async (password: string): Promise<string> => {
    const salt = await bcrypt.genSalt(10);
    return bcrypt.hash(password, salt);
};

/**
 * Compara una contrase√±a en texto plano con una hasheada.
 */
export const comparePassword = async (plainPassword: string, hashedPassword: string): Promise<boolean> => {
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - comparePassword] Comparing provided password with hash ${hashedPassword ? hashedPassword.substring(0,10) : 'N/A'}...`);
    }
    // --- FIN LOG DE DEBUG ---
    const isMatch = await bcrypt.compare(plainPassword, hashedPassword);
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - comparePassword] Result: ${isMatch}`);
    }
    // --- FIN LOG DE DEBUG ---
    return isMatch;
};

/**
 * Genera un token JWT para un usuario.
 */
export const generateToken = (user: Pick<User, 'id' | 'role' | 'businessId'>): string => {
    const payload = {
        userId: user.id,
        role: user.role,
        businessId: user.businessId
    };
    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: '7d' }); // 7 d√≠as de expiraci√≥n
    return token;
};

/**
 * Encuentra un usuario por su direcci√≥n de email.
 */
export const findUserByEmail = async (email: string): Promise<User | null> => {
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - findUserByEmail] Searching for email: ${email}`);
    }
    // --- FIN LOG DE DEBUG ---
    const user = await prisma.user.findUnique({ where: { email } });
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - findUserByEmail] User found: ${user ? `{ id: ${user.id}, email: ${user.email}, isActive: ${user.isActive} }` : 'null'}`);
    }
    // --- FIN LOG DE DEBUG ---
    return user;
};

// --- Funciones movidas a otros servicios ---
// createUser -> registration.service.ts
// handleForgotPassword, handleResetPassword -> password-reset.service.ts
// createBusinessAndAdmin, generateSlug -> registration.service.ts

// End of File: backend/src/auth/auth.service.ts


// ====== [104] backend/src/shared/auth/password-reset.controller.ts ======
// filename: backend/src/auth/password-reset.controller.ts
// Version: 1.0.3 (Remove Swagger annotations)

import { Request, Response } from 'express';
// DTOs necesarios para reseteo
import { ForgotPasswordDto, ResetPasswordDto } from './auth.dto';

// Servicios necesarios
import { hashPassword } from './auth.service';
import { handleForgotPassword, handleResetPassword } from './password-reset.service';

// SIN ANOTACI√ìN @openapi
export const forgotPasswordHandler = async (req: Request, res: Response) => {
    const { email }: ForgotPasswordDto = req.body;

    if (!email) {
        return res.status(400).json({ message: 'Se requiere el email.' });
    }
    try {
        await handleForgotPassword(email);
        res.status(200).json({ message: 'Si existe una cuenta con ese email, se ha enviado un enlace para restablecer la contrase√±a.' });
    } catch (error: any) {
        console.error('[PWD_RESET CTRL] Error in forgotPasswordHandler:', error.message);
        res.status(200).json({ message: 'Si existe una cuenta con ese email, se ha enviado un enlace para restablecer la contrase√±a.' });
    }
};

// SIN ANOTACI√ìN @openapi
export const resetPasswordHandler = async (req: Request, res: Response) => {
    const { token } = req.params;
    const { password: newPassword }: ResetPasswordDto = req.body;

    if (!token) {
        return res.status(400).json({ message: 'Falta el token de reseteo.' });
    }
    if (!newPassword) {
        return res.status(400).json({ message: 'Se requiere la nueva contrase√±a.' });
    }
    if (newPassword.length < 6) {
        return res.status(400).json({ message: 'La nueva contrase√±a debe tener al menos 6 caracteres.' });
    }

    try {
        const hashedNewPassword = await hashPassword(newPassword);
        await handleResetPassword(token, hashedNewPassword);

        res.status(200).json({ message: 'Contrase√±a restablecida con √©xito.' });
    } catch (error: any) {
        console.error(`[PWD_RESET CTRL] Error in resetPasswordHandler for token ${token ? token.substring(0,5)+'...' : 'undefined'}:`, error.message);
        res.status(400).json({ message: error.message || 'No se pudo restablecer la contrase√±a.' });
    }
};

// End of File: backend/src/auth/password-reset.controller.ts


// ====== [105] backend/src/shared/auth/password-reset.service.ts ======
// filename: backend/src/auth/password-reset.service.ts
// Version: 1.0.1 (Fix encoding, remove insecure log, cleanup comments)

import { PrismaClient, User } from '@prisma/client';
// bcrypt ya no se usa directamente aqu√≠ si usamos comparePassword desde auth.service
import crypto from 'crypto';

// Importar utilidades necesarias desde el servicio principal de auth
// ASUNCI√ìN: Estas funciones permanecer√°n o ser√°n exportadas desde auth.service.ts
import { hashPassword, comparePassword, findUserByEmail } from './auth.service';

const prisma = new PrismaClient();

// Constante de expiraci√≥n (espec√≠fica de este flujo)
const RESET_TOKEN_EXPIRATION_MS = 60 * 60 * 1000; // 1 hour

// --- Funciones para Reseteo de Contrase√±a ---

export const handleForgotPassword = async (email: string): Promise<void> => {
    console.log(`[PWD_RESET SVC] Handling forgot password for: ${email}`);
    const user = await findUserByEmail(email); // Usa la utilidad importada
    if (!user) {
        console.log(`[PWD_RESET SVC] User not found for forgot password: ${email}. Responding generically.`);
        return; // Salir silenciosamente
    }

    const resetToken = crypto.randomBytes(32).toString('hex');
    // console.log(`[PWD_RESET SVC] Generated PLAIN reset token for ${email}: ${resetToken}`); // <-- LOG INSEGURO ELIMINADO
    const hashedResetToken = await hashPassword(resetToken);
    const expires = new Date(Date.now() + RESET_TOKEN_EXPIRATION_MS);

    try {
        await prisma.user.update({
            where: { email: email },
            data: {
                resetPasswordToken: hashedResetToken,
                resetPasswordExpires: expires,
            },
        });
        console.log(`[PWD_RESET SVC] Hashed reset token stored successfully for user ${user.id}`);
        // Aqu√≠ ir√≠a la l√≥gica real de env√≠o de email con el 'resetToken' (el original, NO el hasheado)
        // Ejemplo: await sendPasswordResetEmail(user.email, resetToken);
        // Por ahora, el token plano solo se logueaba (y ya hemos quitado eso)
    } catch (error) {
        console.error(`[PWD_RESET SVC] Failed to store reset token for user ${user.id}:`, error);
        // Considerar si relanzar o manejar el error de forma diferente
    }
};

export const handleResetPassword = async (token: string, hashedNewPassword: string): Promise<void> => {
    console.log(`[PWD_RESET SVC] Handling reset password with token starting: ${token.substring(0, 5)}...`);

    const potentialUsers = await prisma.user.findMany({
        where: {
            resetPasswordToken: { not: null },
            resetPasswordExpires: { gt: new Date() } // Buscar solo tokens no expirados
        }
    });

    if (!potentialUsers || potentialUsers.length === 0) {
        console.log('[PWD_RESET SVC] No users found with potentially valid (non-null, non-expired) reset tokens.');
        throw new Error('Token inv√°lido o expirado.'); // Error gen√©rico
    }
    console.log(`[PWD_RESET SVC] Found ${potentialUsers.length} users with active tokens. Verifying provided token...`);

    // Comparar token plano proporcionado con los hashes guardados
    let userToUpdate: User | null = null;
    for (const user of potentialUsers) {
        if (user.resetPasswordToken) {
            const isTokenMatch = await comparePassword(token, user.resetPasswordToken);
            if (isTokenMatch) {
                console.log(`[PWD_RESET SVC] Token match found for user ID: ${user.id}`);
                userToUpdate = user;
                break; // Encontramos el usuario, salimos del bucle
            }
        }
    }

    if (!userToUpdate) {
        // Si recorrimos todos los usuarios con token activo y ninguno coincidi√≥
        console.log(`[PWD_RESET SVC] No user matched the provided token among active ones.`);
        throw new Error('Token inv√°lido o expirado.'); // Mismo error gen√©rico
    }

    // Actualizar contrase√±a y limpiar campos de reseteo
    try {
        await prisma.user.update({
            where: { id: userToUpdate.id },
            data: {
                password: hashedNewPassword,
                resetPasswordToken: null, // Limpiar token
                resetPasswordExpires: null, // Limpiar expiraci√≥n
            },
        });
        console.log(`[PWD_RESET SVC] Password reset successful for user ${userToUpdate.id}`);
    } catch (error) {
        console.error(`[PWD_RESET SVC] Failed to update password for user ${userToUpdate.id}:`, error);
        throw new Error('Error al actualizar la contrase√±a.'); // Error m√°s espec√≠fico para el frontend
    }
};

// End of File: backend/src/auth/password-reset.service.ts


// ====== [106] backend/src/shared/auth/registration.controller.ts ======
// filename: backend/src/auth/registration.controller.ts
// Version: 1.0.2 (Remove Swagger annotations)

import { Request, Response } from 'express';
import { Prisma, DocumentType, User } from '@prisma/client';

// DTOs necesarios para registro
import { RegisterUserDto, RegisterBusinessDto } from './auth.dto';
// Utils de Validaci√≥n
import { isValidDni, isValidNie, isValidPhoneNumber } from '../utils/validation';

// Servicios necesarios
import { findUserByEmail, generateToken } from './auth.service';
import { createUser, createBusinessAndAdmin } from './registration.service';

// SIN ANOTACI√ìN @openapi
export const register = async (req: Request, res: Response) => {
    const { email, password, name, phone, documentId, documentType, businessId, role }: RegisterUserDto = req.body;

    if (!email || !password || !phone || !documentId || !documentType || !businessId || !role || role !== 'CUSTOMER_FINAL') {
        return res.status(400).json({ message: 'Faltan campos obligatorios o rol inv√°lido para registro de cliente.' });
    }

    try {
        const existingUser = await findUserByEmail(email);
        if (existingUser) {
            return res.status(409).json({ message: 'El email ya est√° registrado.' });
        }

        if (!isValidPhoneNumber(phone)) {
             return res.status(400).json({ message: 'Formato de tel√©fono inv√°lido.' });
        }
        let isDocumentValid = false;
        const upperDocumentId = documentId.toUpperCase();
        switch (documentType) {
            case DocumentType.DNI: isDocumentValid = isValidDni(upperDocumentId); break;
            case DocumentType.NIE: isDocumentValid = isValidNie(upperDocumentId); break;
            case DocumentType.PASSPORT: isDocumentValid = upperDocumentId.trim().length > 3; break;
            case DocumentType.OTHER: isDocumentValid = upperDocumentId.trim().length > 0; break;
            default: return res.status(400).json({ message: 'Tipo de documento inv√°lido.' });
        }
        if (!isDocumentValid) { return res.status(400).json({ message: `Formato de ${documentType} inv√°lido.` }); }

        const userDataForService: RegisterUserDto = {
             email, password, name, phone,
             documentId: upperDocumentId, // Enviar normalizado
             documentType, businessId, role
        };
        const newUser = await createUser(userDataForService);

        const {
            password: _password,
            documentId: _documentId,
            resetPasswordToken: _resetToken,
            resetPasswordExpires: _resetExpires,
            ...userWithoutSensitiveData
        } = newUser;
        console.log(`[REG CTRL] Customer registration successful for user ${newUser.id}. Sending 201.`);
        res.status(201).json({ user: userWithoutSensitiveData });
    } catch (error) {
        if (error instanceof Error && (error.message.includes('tel√©fono') || error.message.includes('documento') || error.message.includes('Business with ID') || error.message.includes('ya est√° registrado'))) {
             return res.status(409).json({ message: error.message });
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            const target = (error.meta?.target as string[])?.join(', ');
            console.error(`[REG CTRL] Registration failed: Unique constraint DB error on ${target}.`);
            return res.status(409).json({ message: `Error de unicidad en ${target}` });
        }
        console.error('[REG CTRL] Error during customer registration:', error);
        res.status(500).json({ message: 'Error del servidor durante el registro.' });
    }
};


// SIN ANOTACI√ìN @openapi
export const registerBusinessHandler = async (req: Request, res: Response) => {
    const { businessName, adminEmail, adminPassword, adminName }: RegisterBusinessDto = req.body;
    console.log(`[REG CTRL] Attempting business registration for: ${businessName} / ${adminEmail}`);

    if (!businessName || !adminEmail || !adminPassword) {
        return res.status(400).json({ message: 'Nombre del negocio, email del administrador y contrase√±a son requeridos.' });
    }
    if (businessName.trim().length < 2) {
        return res.status(400).json({ message: 'El nombre del negocio debe tener al menos 2 caracteres.' });
    }
    if (adminPassword.length < 6) {
        return res.status(400).json({ message: 'La contrase√±a debe tener al menos 6 caracteres.' });
    }

    try {
        const newAdminUser = await createBusinessAndAdmin({
            businessName: businessName.trim(),
            adminEmail,
            adminPassword,
            adminName: adminName?.trim()
        });
        const token = generateToken(newAdminUser as User);

        console.log(`[REG CTRL] Business registration successful for ${newAdminUser.email}. Sending 201.`);
        res.status(201).json({
            user: newAdminUser,
            token: token
        });
    } catch (error: any) {
        console.error('[REG CTRL] Error during business registration:', error);
        if (error instanceof Error) {
             if (error.message.includes('El email proporcionado ya est√° registrado') ||
                 error.message.includes('Ya existe un negocio con un nombre similar')) {
                 return res.status(409).json({ message: error.message });
             }
              if (error.message.includes('nombre del negocio') || error.message.includes('Error de base de datos')) {
                   return res.status(400).json({ message: error.message });
              }
        }
        res.status(500).json({ message: error.message || 'Error del servidor durante el registro del negocio.' });
    }
};

// End of File: backend/src/auth/registration.controller.ts


// ====== [107] backend/src/shared/auth/registration.service.ts ======
// backend/src/shared/auth/registration.service.ts (CORREGIDO)
import { PrismaClient, User, UserRole, DocumentType, Prisma, Business } from '@prisma/client';
import { RegisterUserDto, RegisterBusinessDto } from './auth.dto';
import { hashPassword, findUserByEmail } from './auth.service';

// --- RUTA CORREGIDA ---
import { updateUserTier } from '../../modules/loyalpyme/tiers/tier-logic.service';
// --- FIN RUTA CORREGIDA ---

const prisma = new PrismaClient();

export const createUser = async (userData: RegisterUserDto): Promise<User> => {
    console.log(`[REG SVC] Creating CUSTOMER user: ${userData.email}`);
    const businessExists = await prisma.business.findUnique({ where: { id: userData.businessId } });
    if (!businessExists) {
        throw new Error(`Business with ID ${userData.businessId} not found.`);
    }
    if (userData.phone) {
        const existingPhone = await prisma.user.findUnique({ where: { phone: userData.phone }, select: { id: true } });
        if (existingPhone) throw new Error('El tel√©fono ya est√° registrado.');
    } else {
        throw new Error('El tel√©fono es un campo obligatorio para clientes.');
    }
    if (userData.documentId) {
        const existingDocument = await prisma.user.findUnique({ where: { documentId: userData.documentId }, select: { id: true } });
        if (existingDocument) throw new Error('El documento de identidad ya est√° registrado.');
    } else {
        throw new Error('El documento de identidad es un campo obligatorio para clientes.');
    }
    console.log(`[REG SVC] Uniqueness checks passed for ${userData.email}. Hashing password...`);

    const hashedPassword = await hashPassword(userData.password);
    let newUser: User | null = null;

    try {
        newUser = await prisma.user.create({
            data: {
                email: userData.email,
                password: hashedPassword,
                name: userData.name,
                phone: userData.phone,
                documentId: userData.documentId,
                documentType: userData.documentType,
                role: UserRole.CUSTOMER_FINAL,
                business: {
                    connect: { id: userData.businessId }
                }
            },
        });
        console.log(`[REG SVC] Customer user created successfully with ID: ${newUser.id}`);

        try {
             console.log(`[REG SVC] Attempting initial tier assignment for new user: ${newUser.id}`);
             await updateUserTier(newUser.id);
             console.log(`[REG SVC] Initial tier assignment process completed for user: ${newUser.id}`);
        } catch (tierError: any) {
            console.error(`[REG SVC] WARNING: Failed to assign initial tier for user ${newUser.id}. Tier can be updated later. Error:`, tierError);
        }

        return newUser;

    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            const target = (error.meta?.target as string[])?.join(', ');
            console.error(`[REG SVC] Customer creation failed: Unique constraint DB error on ${target}.`);
            if (target?.includes('email')) throw new Error('El email ya est√° registrado.');
            if (target?.includes('phone')) throw new Error('El tel√©fono ya est√° registrado.');
            if (target?.includes('documentId')) throw new Error('El documento de identidad ya est√° registrado.');
            throw new Error(`Conflicto de unicidad en ${target}.`);
        }
        console.error(`[REG SVC] Unexpected error creating customer ${userData.email}:`, error);
        throw new Error('Error inesperado al crear el usuario cliente.');
    }
};

const generateSlug = (name: string): string => {
    return name
        .toLowerCase()
        .trim()
        .replace(/[^\w\s-]/g, '')
        .replace(/[\s_-]+/g, '-')
        .replace(/^-+|-+$/g, '');
};

export const createBusinessAndAdmin = async (
    data: RegisterBusinessDto
): Promise<Omit<User, 'password'>> => {
    console.log('[REG SVC] Attempting to create business and admin:', data.businessName, data.adminEmail);

    const existingUser = await findUserByEmail(data.adminEmail);
    if (existingUser) {
        console.warn(`[REG SVC] Admin email ${data.adminEmail} already exists.`);
        throw new Error('El email proporcionado ya est√° registrado.');
    }

    const slug = generateSlug(data.businessName);
    if (!slug) {
        console.error(`[REG SVC] Could not generate slug from business name: ${data.businessName}`);
        throw new Error('El nombre del negocio proporcionado no es v√°lido para generar un identificador.');
    }
    const existingBusiness = await prisma.business.findUnique({
        where: { slug: slug },
        select: { id: true }
    });
    if (existingBusiness) {
        console.warn(`[REG SVC] Business slug ${slug} already exists.`);
        throw new Error(`Ya existe un negocio con un nombre similar ('${slug}'). Por favor, elige otro nombre.`);
    }

    const hashedPassword = await hashPassword(data.adminPassword);

    try {
        console.log(`[REG SVC] Starting transaction to create business '${data.businessName}' (slug: ${slug}) and admin '${data.adminEmail}'`);
        const newUser = await prisma.$transaction(async (tx) => {
            const newBusiness = await tx.business.create({
                data: {
                    name: data.businessName,
                    slug: slug,
                },
                select: { id: true }
            });
            console.log(`[REG SVC - TX] Business created with ID: ${newBusiness.id}`);

            const adminUser = await tx.user.create({
                data: {
                    email: data.adminEmail,
                    password: hashedPassword,
                    name: data.adminName,
                    role: UserRole.BUSINESS_ADMIN,
                    businessId: newBusiness.id,
                }
            });
            console.log(`[REG SVC - TX] Admin user created with ID: ${adminUser.id} for business ${newBusiness.id}`);
            return adminUser;
        });

        const { password, ...userWithoutPassword } = newUser;
        console.log(`[REG SVC] Business and admin creation successful for ${data.adminEmail}.`);
        return userWithoutPassword;

    } catch (error) {
        console.error('[REG SVC] Error during business/admin creation transaction:', error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             const target = (error.meta?.target as string[])?.join(', ');
             console.error(`[REG SVC] Unique constraint failed on: ${target}`);
             throw new Error(`Error de base de datos: Conflicto de unicidad en ${target}.`);
        }
        throw new Error('No se pudo completar el registro del negocio. Error interno del servidor.');
    }
};


// ====== [108] backend/src/shared/businesses/businesses.controller.ts ======
// filename: backend/src/businesses/businesses.controller.ts
// Version: 1.0.0

import { Request, Response, NextFunction } from 'express';
// Importamos la funci√≥n del servicio que acabamos de crear
import { findPublicBusinesses, PublicBusinessInfo } from './businesses.service'; // Usamos ruta relativa './'

/**
 * Handler para obtener la lista p√∫blica de negocios (ID y Nombre).
 * GET /api/businesses/public-list (o la ruta que definamos)
 * No requiere autenticaci√≥n.
 */
export const handleGetPublicBusinesses = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  console.log('[BusinessController] Solicitud de lista p√∫blica de negocios...');

  try {
    // Llamamos a la funci√≥n del servicio para obtener los datos
    const businesses: PublicBusinessInfo[] = await findPublicBusinesses();

    // Enviamos la respuesta exitosa con la lista de negocios
    res.status(200).json(businesses);
    console.log('[BusinessController] Lista p√∫blica de negocios enviada.');

  } catch (error) {
    // Si el servicio lanza un error, lo pasamos al manejador de errores global
    console.error('[BusinessController] Error al obtener lista p√∫blica de negocios:', error);
    next(error);
  }
};

// Aqu√≠ podr√≠an ir otros handlers del controlador relacionados con Business en el futuro
// (ej: getBusinessDetails, updateBusinessSettings - que s√≠ requerir√≠an autenticaci√≥n/rol)

// End of file: backend/src/businesses/businesses.controller.ts


// ====== [109] backend/src/shared/businesses/businesses.service.ts ======
// filename: backend/src/businesses/businesses.service.ts
// Version: 1.0.2 (Remove obsolete comments)

import { PrismaClient, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Define la estructura de datos devuelta para la lista p√∫blica de negocios.
 */
export interface PublicBusinessInfo {
  id: string;
  name: string;
}

/**
 * Busca y devuelve una lista de negocios (solo ID y Nombre) para mostrar p√∫blicamente.
 * Por ahora, devuelve todos los negocios ordenados por nombre.
 * En el futuro, se podr√≠a filtrar por negocios activos o verificados si fuera necesario.
 *
 * @returns Una promesa que resuelve con un array de objetos PublicBusinessInfo.
 * @throws Error si ocurre un problema al consultar la base de datos.
 */
export const findPublicBusinesses = async (): Promise<PublicBusinessInfo[]> => {
  console.log('[BusinessService] Buscando lista p√∫blica de negocios...');
  try {
    const businesses = await prisma.business.findMany({
      select: {
        id: true,
        name: true,
      },
      orderBy: {
        name: 'asc',
      },
    });
    console.log(`[BusinessService] Encontrados ${businesses.length} negocios.`);
    return businesses;
  } catch (error) {
    console.error('[BusinessService] Error al buscar negocios p√∫blicos:', error);
    throw new Error('No se pudo obtener la lista de negocios.');
  }
};

// End of file: backend/src/businesses/businesses.service.ts


// ====== [110] backend/src/shared/middleware/auth.middleware.ts ======
// backend/src/shared/middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { PrismaClient, UserRole, Prisma } from '@prisma/client';

const prisma = new PrismaClient();
const JWT_SECRET = process.env.JWT_SECRET as string;

if (!JWT_SECRET) {
    console.error('FATAL ERROR: JWT_SECRET is not defined in auth.middleware.');
}

// --- CORRECCI√ìN 1: Actualizar la interfaz global de Express.Request ---
// A√±adimos phone y imageUrl para que TypeScript los reconozca en req.user
declare global {
    namespace Express {
        interface Request {
            user?: {
                id: string;
                email: string;
                role: UserRole;
                businessId: string | null;
                isActive: boolean;
                name?: string | null;
                phone?: string | null;      // <-- A√ëADIDO
                imageUrl?: string | null;   // <-- A√ëADIDO
                points?: number;
                totalSpend?: number;
                totalVisits?: number;
                currentTier?: { id: string; name: string; benefits: any[]; } | null;
                
                businessIsActive?: boolean;
                isLoyaltyCoreActive?: boolean;
                isCamareroActive?: boolean;
                businessName?: string | null;
                businessSlug?: string | null;
                businessLogoUrl?: string | null;
            };
        }
    }
}

export const authenticateToken = async (req: Request, res: Response, next: NextFunction) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (token == null) {
        return res.sendStatus(401);
    }

    jwt.verify(token, JWT_SECRET, async (err: any, payload: any) => {
        if (err || !payload || !payload.userId || !payload.role) {
            return res.sendStatus(403);
        }

        try {
            // --- CORRECCI√ìN 2: Modificar la selecci√≥n de campos de Prisma ---
            const userProfileSelect: Prisma.UserSelect = {
                id: true,
                email: true,
                role: true,
                businessId: true,
                isActive: true,
                name: true,
                phone: true,      // <-- A√ëADIDO
                imageUrl: true,   // <-- A√ëADIDO
            };
            // --- FIN CORRECCI√ìN 2 ---

            if (payload.businessId) {
                userProfileSelect.business = {
                    select: {
                        isActive: true,
                        isLoyaltyCoreActive: true,
                        isCamareroActive: true,
                        name: true,
                        slug: true,
                        logoUrl: true,
                    }
                };
            }

            if (payload.role === UserRole.CUSTOMER_FINAL && payload.businessId) {
                userProfileSelect.points = true;
                userProfileSelect.totalSpend = true;
                userProfileSelect.totalVisits = true;
                userProfileSelect.currentTier = {
                    select: {
                        id: true,
                        name: true,
                        benefits: {
                            where: { isActive: true },
                            select: { id: true, type: true, value: true, description: true }
                        }
                    }
                };
            } else if (payload.role !== UserRole.SUPER_ADMIN && !payload.businessId) {
                 return res.sendStatus(403);
            }

            const userFromDb = await prisma.user.findUnique({
                where: { id: payload.userId },
                select: userProfileSelect
            });

            if (!userFromDb || !userFromDb.isActive) {
                return res.sendStatus(403);
            }

            // @ts-ignore - Prisma genera el tipo `business` si se incluy√≥ en el select
            const businessDataFromDb = userFromDb.business;

            if (userFromDb.role !== UserRole.SUPER_ADMIN && businessDataFromDb && !businessDataFromDb.isActive) {
                return res.sendStatus(403);
            }
            
            // --- CORRECCI√ìN 3: Construir el objeto req.user con los nuevos campos ---
            // Como los campos son ahora parte del tipo, ya no necesitamos castear a 'any'.
            const reqUserObject: Express.Request['user'] = {
                id: userFromDb.id,
                email: userFromDb.email,
                role: userFromDb.role,
                businessId: userFromDb.businessId,
                isActive: userFromDb.isActive,
                name: userFromDb.name,
                phone: userFromDb.phone,
                imageUrl: userFromDb.imageUrl,
            };
            // --- FIN CORRECCI√ìN 3 ---

            if (userFromDb.role === UserRole.CUSTOMER_FINAL) {
                // @ts-ignore
                reqUserObject.points = userFromDb.points;
                // @ts-ignore
                reqUserObject.totalSpend = userFromDb.totalSpend;
                // @ts-ignore
                reqUserObject.totalVisits = userFromDb.totalVisits;
                // @ts-ignore
                reqUserObject.currentTier = userFromDb.currentTier ?? null;
            }

            if (businessDataFromDb) {
                reqUserObject.businessIsActive = businessDataFromDb.isActive;
                reqUserObject.isLoyaltyCoreActive = businessDataFromDb.isLoyaltyCoreActive;
                reqUserObject.isCamareroActive = businessDataFromDb.isCamareroActive;
                reqUserObject.businessName = businessDataFromDb.name;
                reqUserObject.businessSlug = businessDataFromDb.slug;
                reqUserObject.businessLogoUrl = businessDataFromDb.logoUrl;
            } else if (userFromDb.role !== UserRole.SUPER_ADMIN && payload.businessId) {
                console.warn(`[AUTH MIDDLEWARE] Business data for businessId ${payload.businessId} was expected but not found for user ${userFromDb.id}. Module flags and business details will be undefined.`);
            }
            
            req.user = reqUserObject;
            
            console.log(`[AUTH MIDDLEWARE] User ${req.user.id} (Role: ${req.user.role}, BizId: ${req.user.businessId || 'N/A'}, Phone: ${req.user.phone || 'N/A'}) authenticated.`);

            next();
        } catch (dbError) {
            console.error('[AUTH MIDDLEWARE] Database error during user/business fetch:', dbError);
            delete req.user;
            res.status(500).json({ message: 'Server error during authentication process.' });
        }
    });
};


// ====== [111] backend/src/shared/middleware/module.middleware.ts ======
// backend/src/middleware/module.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Definimos los c√≥digos de m√≥dulo que usaremos.
// Podr√≠as expandir esto o usar un Enum de Prisma si los m√≥dulos se vuelven m√°s complejos.
export type ModuleCode = 'LOYALTY_CORE' | 'CAMARERO';

/**
 * Middleware factory para verificar si un m√≥dulo espec√≠fico est√° activo para el negocio
 * del usuario autenticado.
 *
 * @param moduleCode El c√≥digo del m√≥dulo a verificar.
 * @returns Una funci√≥n middleware de Express.
 */
export const checkModuleActive = (moduleCode: ModuleCode) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    // Asumimos que authenticateToken ya se ejecut√≥ y req.user y req.user.businessId existen.
    // El rol ya deber√≠a haber sido verificado por checkRole si es necesario para la ruta.
    if (!req.user || !req.user.businessId) {
      console.warn('[ModuleMiddleware] User or businessId missing from request. Is authenticateToken running first?');
      return res.status(403).json({ message: 'Acceso denegado. No se pudo identificar el negocio para la verificaci√≥n del m√≥dulo.' });
    }

    const businessId = req.user.businessId;

    try {
      const business = await prisma.business.findUnique({
        where: { id: businessId },
        select: {
          isLoyaltyCoreActive: true,
          isCamareroActive: true,
          // Podr√≠amos seleccionar tambi√©n business.isActive aqu√≠ si quisi√©ramos
          // que un m√≥dulo no funcione si el negocio entero est√° inactivo,
          // pero eso se puede manejar en checkRole o un middleware de estado de negocio.
        }
      });

      if (!business) {
        // Esto ser√≠a raro si el token es v√°lido y tiene un businessId.
        console.warn(`[ModuleMiddleware] Business with ID ${businessId} not found during module check.`);
        return res.status(404).json({ message: 'Negocio asociado no encontrado.' });
      }

      let moduleIsCurrentlyActive = false;
      if (moduleCode === 'LOYALTY_CORE') {
        moduleIsCurrentlyActive = business.isLoyaltyCoreActive;
      } else if (moduleCode === 'CAMARERO') {
        moduleIsCurrentlyActive = business.isCamareroActive;
      } else {
        // C√≥digo de m√≥dulo desconocido, por seguridad denegar.
        console.error(`[ModuleMiddleware] Unknown moduleCode specified: ${moduleCode}`);
        return res.status(500).json({ message: 'Error interno: C√≥digo de m√≥dulo no reconocido.' });
      }

      if (moduleIsCurrentlyActive) {
        next(); // El m√≥dulo est√° activo, continuar.
      } else {
        console.log(`[ModuleMiddleware] Access denied. Module '${moduleCode}' is not active for business ${businessId}.`);
        return res.status(403).json({ message: `Acceso denegado. El m√≥dulo ${moduleCode} no est√° activo para este negocio.` });
      }
    } catch (error) {
      console.error(`[ModuleMiddleware] Error checking module '${moduleCode}' for business ${businessId}:`, error);
      return res.status(500).json({ message: 'Error interno al verificar el estado del m√≥dulo.' });
    }
  };
};


// ====== [112] backend/src/shared/middleware/multer.config.ts ======
// filename: backend/src/middleware/multer.config.ts
// Version: 1.0.0 (Initial Multer configuration for image uploads)

import multer, { FileFilterCallback } from 'multer';
import { Request } from 'express';

// Tipos de archivo permitidos (MIME types)
const ALLOWED_MIMETYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
// L√≠mite de tama√±o (ej. 5MB)
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5 MB in bytes

// Configuraci√≥n de almacenamiento en memoria
const storage = multer.memoryStorage();

// Funci√≥n de filtro de archivos
const fileFilter = (
    req: Request,
    file: Express.Multer.File,
    cb: FileFilterCallback
) => {
    console.log(`[Multer Filter] Checking file: ${file.originalname}, MIME type: ${file.mimetype}`);
    if (ALLOWED_MIMETYPES.includes(file.mimetype)) {
        // Aceptar el archivo
        console.log(`[Multer Filter] File type ${file.mimetype} accepted.`);
        cb(null, true);
    } else {
        // Rechazar el archivo
        console.warn(`[Multer Filter] File type ${file.mimetype} rejected.`);
        // Pasamos un error para que pueda ser manejado por el controlador/manejador de errores
        cb(new Error('Tipo de archivo no permitido. Solo se aceptan im√°genes (jpeg, png, webp, gif).'));
        // Alternativa: cb(null, false); // Simplemente rechaza sin error expl√≠cito
    }
};

// Crear la instancia de Multer configurada
const upload = multer({
    storage: storage,
    fileFilter: fileFilter,
    limits: {
        fileSize: MAX_FILE_SIZE, // L√≠mite de 5MB
    },
});

// Exportar la instancia configurada (espec√≠ficamente para manejar un solo archivo llamado 'image')
// Usaremos upload.single('imageField') en la ruta. El nombre 'imageField' debe coincidir
// con el nombre del campo que env√≠a el frontend en el FormData.
// Exportamos la instancia base para usarla en la ruta.
export default upload;

// End of File: backend/src/middleware/multer.config.ts


// ====== [113] backend/src/shared/middleware/role.middleware.ts ======
// filename: backend/src/middleware/role.middleware.ts
// Version: 1.0.1 (Remove verbose log and inline comments)

import { Request, Response, NextFunction } from 'express';
import { UserRole } from '@prisma/client';

/**
 * Middleware factory para verificar si el rol del usuario autenticado
 * est√° incluido en la lista de roles permitidos.
 *
 * @param allowedRoles Un array de UserRole permitidos para la ruta.
 * @returns Una funci√≥n middleware de Express.
 */
export const checkRole = (allowedRoles: UserRole[]) => {
    return (req: Request, res: Response, next: NextFunction) => {
        // Verifica que authenticateToken haya adjuntado un usuario con rol
        if (!req.user || !req.user.role) {
            console.warn('[Role Middleware] User or user role not found on request. Is authenticateToken running first?');
            return res.status(403).json({ message: 'Acceso denegado: Autenticaci√≥n requerida o rol no disponible.' });
        }

        const userRole = req.user.role;
        // console.log(`[Role Middleware] Checking role: User has '${userRole}', Allowed: [${allowedRoles.join(', ')}] for route ${req.originalUrl}`); // Log eliminado por verbosidad

        // Comprueba si el rol est√° permitido
        if (allowedRoles.includes(userRole)) {
            next(); // Rol permitido, continuar
        } else {
            // Rol no permitido
            console.warn(`[Role Middleware] Access Forbidden for role '${userRole}' on route ${req.originalUrl}. Allowed: [${allowedRoles.join(', ')}]`);
            res.status(403).json({ message: 'Acceso denegado: Permisos insuficientes.' });
        }
    };
};

// End of File: backend/src/middleware/role.middleware.ts


// ====== [114] backend/src/shared/services/loyalty-points.service.ts ======
// backend/src/shared/services/loyalty-points.service.ts (CORREGIDO)
import {
    PrismaClient,
    Prisma,
    Order,
    User,
    Business,
    ActivityType,
    TierBenefit,
} from '@prisma/client';
import { Logger, InternalServerErrorException } from '@nestjs/common';
// --- RUTA CORREGIDA ---
import { updateUserTier } from '../../modules/loyalpyme/tiers/tier-logic.service';
// --- FIN RUTA CORREGIDA ---

type OrderForLoyalty = Pick<Order, 'id' | 'orderNumber' | 'finalAmount' | 'totalAmount' | 'customerLCoId' | 'businessId'>;
type CustomerForLoyalty = User & {
    currentTier?: ({ benefits: Pick<TierBenefit, 'type' | 'value' | 'isActive'>[] } & { id: string; name: string }) | null;
};
type BusinessForLoyalty = Pick<Business, 'id' | 'pointsPerEuro' | 'isLoyaltyCoreActive'>;


export class LoyaltyPointsService {
    private readonly logger = new Logger(LoyaltyPointsService.name);

    async awardPointsForLcOrder(
        tx: Prisma.TransactionClient,
        order: OrderForLoyalty,
        customer: CustomerForLoyalty,
        business: BusinessForLoyalty
    ): Promise<{ pointsAwarded: number } | null> {
        if (!order.customerLCoId) {
            this.logger.warn(`[LoyaltyPointsService] Order ${order.id} has no customerLCoId. No points to award.`);
            return null;
        }
        if (!business.isLoyaltyCoreActive) {
            this.logger.log(`[LoyaltyPointsService] LoyaltyCore module is not active for business ${business.id}. Skipping points for order ${order.id}.`);
            return null;
        }
        if (customer.id !== order.customerLCoId) {
             this.logger.error(`[LoyaltyPointsService] Mismatch: Order customerLCoId ${order.customerLCoId} vs provided customer ID ${customer.id}. Aborting points.`);
             throw new InternalServerErrorException("Discrepancia en IDs de cliente al otorgar puntos.");
        }

        this.logger.log(`[LoyaltyPointsService TX] Processing LCo points for customer ${customer.id} (Order: ${order.id}, Business: ${business.id})`);

        const orderAmountForPoints = order.finalAmount ?? order.totalAmount;
        let pointsToEarnDecimal = new Prisma.Decimal(orderAmountForPoints).mul(business.pointsPerEuro ?? 1);

        const multiplierBenefit = customer.currentTier?.benefits.find(
            b => b.type === 'POINTS_MULTIPLIER' && b.isActive
        );

        if (multiplierBenefit?.value) {
            const multiplier = parseFloat(multiplierBenefit.value);
            if (!isNaN(multiplier) && multiplier > 0) {
                pointsToEarnDecimal = pointsToEarnDecimal.mul(multiplier);
                this.logger.log(`[LoyaltyPointsService TX] Applied tier '${customer.currentTier?.name}' multiplier ${multiplier} for LCo points.`);
            } else {
                this.logger.warn(`[LoyaltyPointsService TX] Invalid LCo tier multiplier value '${multiplierBenefit.value}' for user ${customer.id} on tier '${customer.currentTier?.name}'.`);
            }
        }

        const finalPointsToAward = Math.floor(pointsToEarnDecimal.toNumber());

        if (finalPointsToAward <= 0) {
            this.logger.log(`[LoyaltyPointsService TX] No LCo points to award (calculated ${finalPointsToAward}) for customer ${customer.id} on order ${order.id}.`);
            return { pointsAwarded: 0 };
        }

        try {
            await tx.user.update({
                where: { id: customer.id },
                data: {
                    points: { increment: finalPointsToAward },
                    totalSpend: { increment: orderAmountForPoints.toNumber() },
                    totalVisits: { increment: 1 },
                    lastActivityAt: new Date(),
                },
            });
            this.logger.log(`[LoyaltyPointsService TX] Customer ${customer.id} updated: +${finalPointsToAward} points, +${orderAmountForPoints} spend, +1 visit.`);

            await tx.activityLog.create({
                data: {
                    userId: customer.id,
                    businessId: business.id,
                    type: ActivityType.POINTS_EARNED_ORDER_LC,
                    pointsChanged: finalPointsToAward,
                    description: `Puntos por pedido LC #${order.orderNumber}`,
                    relatedOrderId: order.id,
                },
            });
            this.logger.log(`[LoyaltyPointsService TX] ActivityLog created for order ${order.id}, user ${customer.id}.`);

            updateUserTier(customer.id).catch((tierError: any) => {
                this.logger.error(`[LoyaltyPointsService] Background tier update failed for customer ${customer.id} after LC order points:`, tierError);
            });
            this.logger.log(`[LoyaltyPointsService] Tier update process initiated for customer ${customer.id}.`);

            return { pointsAwarded: finalPointsToAward };

        } catch (error) {
            this.logger.error(`[LoyaltyPointsService TX] Error during points awarding transaction for order ${order.id}, customer ${customer.id}:`, error);
            return null;
        }
    }
}


// ====== [115] backend/src/shared/services/table.service.ts ======
// backend/src/services/table.service.ts (o backend/src/camarero/table.service.ts si prefieres)
import {
    PrismaClient,
    Prisma,
    Table,
    TableStatus,
} from '@prisma/client';
import {
    Logger,
    NotFoundException,
    InternalServerErrorException,
} from '@nestjs/common';

export class TableService {
    private readonly logger = new Logger(TableService.name);

    /**
     * Encuentra una mesa por su identificador y el ID del negocio.
     *
     * @param tx - Cliente Prisma de la transacci√≥n actual.
     * @param businessId - ID del negocio.
     * @param tableIdentifier - Identificador de la mesa (ej. "M1", "T2").
     * @returns El objeto Table si se encuentra, o null si no.
     */
    async findTableByIdentifier(
        tx: Prisma.TransactionClient,
        businessId: string,
        tableIdentifier: string
    ): Promise<Table | null> {
        this.logger.log(`[TableService] Finding table with identifier '${tableIdentifier}' for business '${businessId}'.`);
        try {
            const table = await tx.table.findUnique({
                where: {
                    businessId_identifier: {
                        businessId: businessId,
                        identifier: tableIdentifier,
                    },
                },
            });
            if (table) {
                this.logger.log(`[TableService] Table '${tableIdentifier}' found with ID '${table.id}'.`);
            } else {
                this.logger.warn(`[TableService] Table '${tableIdentifier}' not found for business '${businessId}'.`);
            }
            return table;
        } catch (error) {
            this.logger.error(`[TableService] Error finding table '${tableIdentifier}':`, error);
            throw new InternalServerErrorException('Error al buscar la mesa en la base de datos.');
        }
    }

    /**
     * Actualiza el estado de una mesa espec√≠fica.
     *
     * @param tx - Cliente Prisma de la transacci√≥n actual.
     * @param tableId - ID de la mesa a actualizar.
     * @param newStatus - El nuevo TableStatus para la mesa.
     * @returns El objeto Table actualizado.
     * @throws NotFoundException si la mesa no existe.
     */
    async updateTableStatus(
        tx: Prisma.TransactionClient,
        tableId: string,
        newStatus: TableStatus
    ): Promise<Table> {
        this.logger.log(`[TableService] Updating status of table '${tableId}' to '${newStatus}'.`);
        try {
            // Primero, verificar si la mesa existe para dar un error m√°s claro si no.
            // Esto podr√≠a ser redundante si la operaci√≥n que llama ya verific√≥, pero es una salvaguarda.
            const existingTable = await tx.table.findUnique({ where: { id: tableId }, select: { id: true } });
            if (!existingTable) {
                this.logger.warn(`[TableService] Table with ID '${tableId}' not found for status update.`);
                throw new NotFoundException(`Mesa con ID '${tableId}' no encontrada.`);
            }

            const updatedTable = await tx.table.update({
                where: { id: tableId },
                data: { status: newStatus },
            });
            this.logger.log(`[TableService] Table '${tableId}' status successfully updated to '${newStatus}'.`);
            return updatedTable;
        } catch (error) {
            if (error instanceof NotFoundException) throw error; // Relanzar si es nuestro error espec√≠fico
            
            this.logger.error(`[TableService] Error updating status for table '${tableId}':`, error);
            if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
                // P2025 = "An operation failed because it depends on one or more records that were required but not found."
                // (Registro para actualizar no encontrado)
                throw new NotFoundException(`Mesa con ID '${tableId}' no encontrada al intentar actualizar estado.`);
            }
            throw new InternalServerErrorException('Error al actualizar el estado de la mesa.');
        }
    }

    // --- Podr√≠as a√±adir m√°s m√©todos aqu√≠ si son necesarios, como: ---
    // async getTableById(tx: Prisma.TransactionClient, tableId: string): Promise<Table | null> { ... }
    // async createTable(tx: Prisma.TransactionClient, businessId: string, data: Prisma.TableCreateWithoutBusinessInput): Promise<Table> { ... }
    // etc.
}


// ====== [116] backend/src/shared/uploads/uploads.controller.ts ======
// filename: backend/src/uploads/uploads.controller.ts
// Version: 1.0.1 (Correct service import path)

import { Request, Response, NextFunction } from 'express';
// --- MODIFICADO: Importar desde 'uploads.service' (plural) ---
import { uploadImageToCloudinary } from './uploads.service';
// --- FIN MODIFICADO ---

/**
 * Maneja la subida de una imagen (generalmente para recompensas).
 * Espera que el middleware Multer (upload.single('image')) se haya ejecutado antes.
 */
export const handleImageUpload = async (req: Request, res: Response, next: NextFunction) => {
    console.log('[Upload CTRL] Received image upload request.');

    // Multer a√±ade 'file' a la request
    if (!req.file) {
        console.error('[Upload CTRL] No file found in req.file. Check field name in client and Multer config.');
        // El campo en Multer y en RewardForm debe ser 'image' seg√∫n c√≥digo anterior
        return res.status(400).json({ message: 'No se recibi√≥ ning√∫n archivo de imagen o el campo no es "image".' });
    }

    if (!req.file.buffer) {
        console.error('[Upload CTRL] File buffer is missing.');
        return res.status(500).json({ message: 'Error interno al procesar el archivo.' });
    }

    // Carpeta en Cloudinary
    const folderName = `loyalpyme/rewards_${process.env.NODE_ENV || 'development'}`;

    try {
        console.log(`[Upload CTRL] Uploading file ${req.file.originalname} (${(req.file.size / 1024).toFixed(1)} KB) to Cloudinary folder '${folderName}'...`);
        const imageUrl = await uploadImageToCloudinary(req.file.buffer, folderName);

        console.log(`[Upload CTRL] Image uploaded successfully. URL: ${imageUrl}`);
        // Devolver la URL (ajustado a como lo espera el form v2.1.0)
        res.status(200).json({
            // message: 'Imagen subida correctamente.', // El form no espera message
            url: imageUrl // El form espera 'url'
        });

    } catch (error) {
        console.error('[Upload CTRL] Error during image upload process:', error);
        next(error); // Pasar al manejador global
    }
};

// End of File: backend/src/uploads/uploads.controller.ts


// ====== [117] backend/src/shared/uploads/uploads.service.ts ======
// filename: backend/src/uploads/upload.service.ts
// Version: 1.0.0 (CORRECTED - Standard Cloudinary upload service with folder)

import cloudinary from '../utils/cloudinary.config'; // Importa config est√°ndar (lee .env)
import streamifier from 'streamifier';
import { UploadApiResponse, UploadApiErrorResponse } from 'cloudinary';

// --- ASEG√öRATE DE QUE LA FIRMA DE LA FUNCI√ìN EST√â AS√ç ---
export const uploadImageToCloudinary = (
    fileBuffer: Buffer,      // <-- Par√°metro para el buffer
    folderName: string       // <-- Par√°metro para la carpeta
): Promise<string> => {
// --- FIN FIRMA ---

    return new Promise((resolve, reject) => {
        // Usamos folderName en el log
        console.log(`[Upload SVC] Attempting to upload image buffer to Cloudinary folder: ${folderName}`);

        const uploadStream = cloudinary.uploader.upload_stream(
            {
                folder: folderName, // <-- Usamos el par√°metro folderName
                resource_type: 'image',
            },
            (error: UploadApiErrorResponse | undefined, result: UploadApiResponse | undefined) => {
                if (error) {
                    console.error('[Upload SVC] Cloudinary upload failed:', error);
                    // Usar un mensaje gen√©rico o el espec√≠fico de Cloudinary
                    reject(new Error(`Error al subir imagen a Cloudinary: ${error.message}`));
                } else if (result) {
                    console.log(`[Upload SVC] Cloudinary upload successful! Secure URL: ${result.secure_url}`);
                    resolve(result.secure_url); // Devuelve la URL segura
                } else {
                    // Caso improbable
                    console.error('[Upload SVC] Cloudinary upload stream finished without error or result.');
                    reject(new Error('La subida a Cloudinary finaliz√≥ sin resultado ni error.'));
                }
            }
        );
        // Usamos fileBuffer para crear el stream de lectura
        streamifier.createReadStream(fileBuffer).pipe(uploadStream);
    });
}; // <-- Aseg√∫rate que la llave de cierre de la funci√≥n est√°

// End of File: backend/src/uploads/upload.service.ts


// ====== [118] backend/src/shared/utils/cloudinary.config.ts ======
// filename: backend/src/utils/cloudinary.config.ts
// Version: 1.0.0 (Standard - Using process.env)
import { v2 as cloudinary } from 'cloudinary';
import dotenv from 'dotenv';
dotenv.config();
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;
if (!cloudName || !apiKey || !apiSecret) {
  console.error("ERROR: Cloudinary environment variables are missing!"); // ... resto del mensaje de error ...
} else {
   console.log("[Cloudinary Config] Credentials found from .env, configuring Cloudinary SDK...");
   cloudinary.config({ cloud_name: cloudName, api_key: apiKey, api_secret: apiSecret, secure: true });
   console.log("[Cloudinary Config] Cloudinary SDK configured successfully from .env.");
}
export default cloudinary;


// ====== [119] backend/src/shared/utils/validation.ts ======
// filename: backend/src/utils/validation.ts
// Version: 1.0.1 (Fix character encoding)

// Contiene funciones de utilidad para validaciones comunes

/**
 * Valida si un string tiene formato de DNI espa√±ol v√°lido.
 * @param dni - El string a validar.
 * @returns true si es v√°lido, false en caso contrario.
 */
export function isValidDni(dni: string): boolean {
    if (!/^\d{8}[A-Z]$/i.test(dni)) {
        return false;
    }
    const numero = parseInt(dni.substring(0, 8), 10);
    const letra = dni.substring(8, 9).toUpperCase();
    const letrasControl = "TRWAGMYFPDXBNJZSQVHLCKE";
    const letraCalculada = letrasControl.charAt(numero % 23);
    return letra === letraCalculada;
}

/**
 * Valida si un string tiene formato de NIE espa√±ol v√°lido.
 * @param nie - El string a validar.
 * @returns true si es v√°lido, false en caso contrario.
 */
export function isValidNie(nie: string): boolean {
    if (!/^[XYZ]\d{7}[A-Z]$/i.test(nie)) {
        return false;
    }
    let numeroStr = nie.substring(1, 8);
    const letraInicial = nie.substring(0, 1).toUpperCase();
    // Reemplazar letra inicial por su equivalente num√©rico para el c√°lculo
    if (letraInicial === 'Y') numeroStr = '1' + numeroStr;
    if (letraInicial === 'Z') numeroStr = '2' + numeroStr;
    // Si es X, se trata como 0, lo cual ya est√° impl√≠cito al no a√±adir prefijo

    const numero = parseInt(numeroStr, 10);
    const letra = nie.substring(8, 9).toUpperCase();
    const letrasControl = "TRWAGMYFPDXBNJZSQVHLCKE";
    const letraCalculada = letrasControl.charAt(numero % 23);
    return letra === letraCalculada;
}

/**
 * Valida si un string tiene formato de n√∫mero de tel√©fono internacional b√°sico.
 * @param phone - El string a validar.
 * @returns true si es v√°lido, false en caso contrario.
 */
export function isValidPhoneNumber(phone: string): boolean {
    // Regex simple: empieza con +, seguido de 9 a 15 d√≠gitos.
    const phoneRegex = /^\+[0-9]{9,15}$/;
    return phoneRegex.test(phone);
}

// Aqu√≠ podr√≠an a√±adirse m√°s funciones de validaci√≥n comunes en el futuro

// End of File: backend/src/utils/validation.ts


// ====== [120] backend/test-server.js ======
// File: backend/test-server.js
// Servidor Express m√≠nimo para pruebas - Puerto 3001

const express = require('express');
const app = express();
const port = 3001; // <-- CAMBIADO A 3001

app.get('/', (req, res) => {
  res.send(`¬°Servidor de prueba m√≠nimo funcionando en puerto ${port}!`);
});

app.listen(port, () => {
  console.log(`Servidor de PRUEBA escuchando en http://localhost:${port}`); // Mensaje actualizado
  console.log('Este proceso DEBER√çA quedarse corriendo. Presiona Ctrl+C para salir.');
});

process.on('exit', (code) => {
  console.log(`[TEST SERVER ${port}] Proceso saliendo con c√≥digo: ${code}`);
});
process.on('beforeExit', (code) => {
    console.log(`[TEST SERVER ${port}] Evento 'beforeExit' detectado con c√≥digo: ${code}`);
});


// ====== [121] backend/tests/integration/auth.test.ts ======
import { describe, it, expect } from 'vitest';
import request from 'supertest';
import app from '../../src/index';

describe('Auth API Integration Tests', () => {

  it('POST /api/auth/login - should login successfully with valid credentials', async () => {
    const credentials = {
      email: 'admin@cafeelsol.com', // Mantenemos este email, corr√≠gelo si es otro
      password: 'superpasswordseguro', // <-- CONTRASE√ëA ACTUALIZADA
    };

    const response = await request(app)
      .post('/api/auth/login')
      .send(credentials)
      .expect('Content-Type', /json/)
      .expect(200);

    expect(response.body).toBeTypeOf('object');
    expect(response.body).toHaveProperty('token');
    expect(response.body).toHaveProperty('user');
    expect(response.body.user).toBeTypeOf('object');
    expect(response.body.user.email).toBe(credentials.email);
    expect(response.body.user).not.toHaveProperty('password');
    expect(response.body.user.role).toBe('BUSINESS_ADMIN');
  });

  it('POST /api/auth/login - should fail with incorrect password', async () => {
    const credentials = {
      email: 'admin@cafeelsol.com', // Usa el email correcto aqu√≠ tambi√©n
      password: 'password123',     // Una contrase√±a incorrecta diferente a la buena
    };
    const response = await request(app)
      .post('/api/auth/login')
      .send(credentials)
      .expect('Content-Type', /json/)
      .expect(401);
    expect(response.body.message).toContain('inv√°lidas');
  });

   it('POST /api/auth/login - should fail with non-existent user', async () => {
    const credentials = {
      email: `no-existe-${Date.now()}@example.com`,
      password: 'somepassword',
    };
    const response = await request(app)
      .post('/api/auth/login')
      .send(credentials)
      .expect('Content-Type', /json/)
      .expect(401);
    expect(response.body.message).toContain('inv√°lidas');
  });

   it('POST /api/auth/login - should fail if email or password is missing', async () => {
     await request(app)
      .post('/api/auth/login')
      .send({ password: 'superpasswordseguro' }) // Contrase√±a correcta pero sin email
      .expect('Content-Type', /json/)
      .expect(400);

     await request(app)
      .post('/api/auth/login')
      .send({ email: 'admin@cafeelsol.com' }) // Email correcto pero sin contrase√±a
      .expect('Content-Type', /json/)
      .expect(400);
   });

});


// ====== [122] backend/tests/integration/points.test.ts ======
import { describe, it, expect, beforeAll, afterAll, vi } from 'vitest';
import request from 'supertest';
import app from '../../src/index';
import { UserRole, DocumentType } from '@prisma/client';

// Helper DNI (sin cambios)
function generateValidDni(): string {
    const num = Math.floor(Math.random() * 100000000);
    const numStr = num.toString().padStart(8, '0');
    const letters = "TRWAGMYFPDXBNJZSQVHLCKE";
    const letter = letters.charAt(parseInt(numStr, 10) % 23);
    return `${numStr}${letter}`;
}


describe('Points API Integration Tests (/api/points)', () => {

    // Variables para guardar estado entre tests
    let customerToken: string | null = null;
    let adminToken: string | null = null;
    let customerUserId: string | null = null; // <-- GUARDAMOS ID DEL CLIENTE CREADO
    let businessId: string | null = null;
    let generatedQrToken: string | null = null; // <-- Guardamos token QR
    const testCustomerEmail = `test-customer-${Date.now()}@test.loyal`;
    const testCustomerPassword = 'password123';
    const testCustomerDni = generateValidDni();

    beforeAll(async () => {
        console.log("Starting beforeAll setup for points tests...");
        // Login Admin
        try { /* ... (c√≥digo login admin sin cambios) ... */
            const adminLoginRes = await request(app).post('/api/auth/login').send({ email: 'admin@cafeelsol.com', password: 'superpasswordseguro' });
            if (adminLoginRes.status === 200 && adminLoginRes.body.token) {
                adminToken = adminLoginRes.body.token;
                businessId = adminLoginRes.body.user?.businessId;
                console.log("Admin logged in, businessId:", businessId);
            } else { throw new Error("Admin login failed in test setup"); }
        } catch (error) { console.error("CRITICAL: Error during admin login setup:", error); throw error; }

        // Crear y Loguear Cliente de Prueba
        if (businessId) { /* ... (c√≥digo crear/loguear cliente sin cambios) ... */
            try {
                console.log(`Attempting to register test customer: ${testCustomerEmail} with DNI: ${testCustomerDni}`);
                const registerRes = await request(app).post('/api/auth/register').send({ email: testCustomerEmail, password: testCustomerPassword, name: 'Test Customer', phone: `+${Date.now()}`.substring(0, 13), documentType: DocumentType.DNI, documentId: testCustomerDni, businessId: businessId, role: UserRole.CUSTOMER_FINAL });
                if (registerRes.status !== 201) { console.warn("Failed to register test customer", registerRes.status, registerRes.body.message); }
                else { console.log("Test customer registered:", testCustomerEmail); }

                console.log(`Attempting to login test customer: ${testCustomerEmail}`);
                const customerLoginRes = await request(app).post('/api/auth/login').send({ email: testCustomerEmail, password: testCustomerPassword });
                if (customerLoginRes.status === 200 && customerLoginRes.body.token) {
                    customerToken = customerLoginRes.body.token;
                    customerUserId = customerLoginRes.body.user?.id; // <-- Guardar ID del cliente
                    console.log("Test customer logged in, userId:", customerUserId);
                } else { console.error("Failed to login test customer", customerLoginRes.status, customerLoginRes.body.message); }
            } catch (error) { console.error("Error during customer setup:", error); }
        } else { console.error("Cannot setup customer - businessId not obtained."); }

        // Generar QR
        if (adminToken) { /* ... (c√≥digo generar QR sin cambios) ... */
             try {
                 const qrGenRes = await request(app).post('/api/points/generate-qr').set('Authorization', `Bearer ${adminToken}`).send({ amount: 10, ticketNumber: `TEST-${Date.now()}`});
                 if (qrGenRes.status === 201 && qrGenRes.body.qrToken) {
                    generatedQrToken = qrGenRes.body.qrToken;
                    console.log(`Generated QR Token for tests: ${generatedQrToken}`);
                 } else { console.warn("Failed to generate QR token for tests", qrGenRes.status, qrGenRes.body.message); }
             } catch(error) { console.error("Error generating QR during setup:", error); }
        } else { console.warn("Skipping QR generation, adminToken not available."); }
        console.log("Finished beforeAll setup.");
    }, 30000);

    // --- NUEVO: afterAll para limpiar cliente ---
    afterAll(async () => {
        console.log("Running afterAll cleanup for points tests...");
        // Intentar borrar el cliente creado si tenemos su ID y el token de admin
        if (customerUserId && adminToken) {
            console.log(`Attempting to delete test customer ${customerUserId}...`);
            try {
                // Usamos el endpoint de borrado masivo pas√°ndole un solo ID
                // OJO: Aseg√∫rate de que el endpoint DELETE /api/admin/customers/bulk-delete exista y funcione
                // Alternativamente, si tienes un DELETE /api/admin/customers/:id, √∫salo.
                // Si no hay endpoint de borrado, necesitar√≠amos usar Prisma Client directamente aqu√≠.
                // Asumiendo que bulk-delete funciona con un array de 1:
                await request(app)
                    .delete('/api/admin/customers/bulk-delete')
                    .set('Authorization', `Bearer ${adminToken}`)
                    .send({ customerIds: [customerUserId] }) // Enviar ID en el body
                    .timeout(5000); // Timeout por si acaso
                console.log(`Test customer ${customerUserId} deleted successfully.`);
            } catch (error: any) {
                console.warn(`Warning: Could not delete test customer ${customerUserId} during cleanup. Status: ${error?.status || 'unknown'}`);
            }
        } else {
            console.log("Cleanup skipped: No customerUserId or adminToken available.");
        }
        // NOTA: La limpieza del QR code es m√°s compleja porque no guardamos su ID
        // y no suele haber un endpoint para borrar QR por token. Se podr√≠a hacer
        // buscando en la BD por el ticketNumber 'TEST-*' y borrando directamente
        // con Prisma Client si fuera necesario, pero por ahora lo omitimos.
    });
    // --- FIN afterAll ---


    // --- Tests (Sin cambios, solo quitamos vi.skip) ---
    it('should fail validation if no token is provided in body', async () => {
        if (!customerToken) return; // Sigue saltando si el setup fall√≥
        await request(app).post('/api/points/validate-qr').set('Authorization', `Bearer ${customerToken}`).send({}).expect(400);
    });

    it('should fail validation with an invalid QR token format', async () => {
         if (!customerToken) return;
         const res = await request(app).post('/api/points/validate-qr').set('Authorization', `Bearer ${customerToken}`).send({ qrToken: 'invalid-token-format' }).expect(400);
         expect(res.body.message).toContain('inv√°lido');
    });

    it('should successfully validate a valid, pending QR token', async () => {
        if (!customerToken || !generatedQrToken) return;
        const response = await request(app).post('/api/points/validate-qr').set('Authorization', `Bearer ${customerToken}`).send({ qrToken: generatedQrToken }).expect(200);
        expect(response.body).toHaveProperty('pointsEarned');
        expect(response.body.pointsEarned).toBeGreaterThanOrEqual(0);
    });

    it('should fail validation if QR token is already used', async () => {
        if (!customerToken || !generatedQrToken) return;
        // Asumimos que el test anterior ya lo us√≥ (o lo usamos aqu√≠ por si acaso)
        try { await request(app).post('/api/points/validate-qr').set('Authorization', `Bearer ${customerToken}`).send({ qrToken: generatedQrToken }); } catch (e) {/* Ignorar error de la primera llamada */}
        // Segundo intento
        const response = await request(app).post('/api/points/validate-qr').set('Authorization', `Bearer ${customerToken}`).send({ qrToken: generatedQrToken }).expect(400);
        expect(response.body.message).toContain('utilizado');
    });

    it('should fail validation if user is not a customer', async () => {
         if (!adminToken || !generatedQrToken) return;
         await request(app).post('/api/points/validate-qr').set('Authorization', `Bearer ${adminToken}`).send({ qrToken: generatedQrToken }).expect(403);
    });

});


// ====== [123] backend/tests/integration/rewards.test.ts ======
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import app from '../../src/index';
import { Reward } from '@prisma/client';

describe('Rewards API Integration Tests (/api/rewards)', () => {

    let adminToken: string | null = null;
    let mainTestRewardId: string | null = null; // Reward creada en el test POST y usada en GET/PUT/PATCH
    let rewardToDeleteId: string | null = null; // Reward creada espec√≠ficamente para el test DELETE

    beforeAll(async () => {
        console.log("Starting beforeAll setup for rewards tests...");
        try {
            const adminLoginRes = await request(app)
                .post('/api/auth/login')
                .send({ email: 'admin@cafeelsol.com', password: 'superpasswordseguro' });
            if (adminLoginRes.status === 200 && adminLoginRes.body.token) {
                adminToken = adminLoginRes.body.token;
                console.log("Admin logged in successfully for rewards tests.");
            } else {
                throw new Error("Admin login failed in rewards test setup");
            }
        } catch (error) {
            console.error("CRITICAL: Error during admin login setup for rewards:", error);
            throw error;
        }
        console.log("Finished beforeAll setup for rewards tests.");
    }, 20000);

    afterAll(async () => {
        // Limpiar la recompensa principal si se cre√≥
        if (mainTestRewardId && adminToken) {
            console.log(`Running afterAll cleanup: deleting main reward ${mainTestRewardId}...`);
            try {
                await request(app).delete(`/api/rewards/${mainTestRewardId}`).set('Authorization', `Bearer ${adminToken}`);
                console.log(`Main reward ${mainTestRewardId} deleted successfully.`);
            } catch (error) {
                console.warn(`Warning during afterAll cleanup, could not delete main reward ${mainTestRewardId}:`, error);
            }
        }
        // Limpiar la recompensa del test DELETE si por alguna raz√≥n no se borr√≥ en su test
        if (rewardToDeleteId && adminToken) {
             console.log(`Running afterAll cleanup: attempting to delete leftover DELETE test reward ${rewardToDeleteId}...`);
             try {
                await request(app).delete(`/api/rewards/${rewardToDeleteId}`).set('Authorization', `Bearer ${adminToken}`);
                console.log(`DELETE test reward ${rewardToDeleteId} deleted successfully.`);
             } catch (error) {
                // Silenciar error aqu√≠, es solo una limpieza extra
             }
        }
    });


    // --- Tests POST ---
    it('POST /api/rewards - should fail to create reward without auth token', async () => {
        await request(app).post('/api/rewards').send({ name: 'Fail No Auth', pointsCost: 10 }).expect(401);
    });
    it('POST /api/rewards - should fail to create reward with missing name', async () => {
        if (!adminToken) throw new Error("Admin token not available");
        await request(app).post('/api/rewards').set('Authorization', `Bearer ${adminToken}`).send({ pointsCost: 50 }).expect(400);
    });
     it('POST /api/rewards - should fail to create reward with invalid pointsCost', async () => {
        if (!adminToken) throw new Error("Admin token not available");
        await request(app).post('/api/rewards').set('Authorization', `Bearer ${adminToken}`).send({ name: 'Fail Points', pointsCost: -10 }).expect(400);
    });
    it('POST /api/rewards - should create a new reward successfully', async () => {
        if (!adminToken) throw new Error("Admin token not available");
        const rewardData = { name: `Test ${Date.now()}`, description: 'Desc', pointsCost: 150 };
        const response = await request(app).post('/api/rewards').set('Authorization', `Bearer ${adminToken}`).send(rewardData).expect(201);
        expect(response.body.id).toBeTypeOf('string');
        expect(response.body.name).toBe(rewardData.name);
        expect(response.body.isActive).toBe(true);
        mainTestRewardId = response.body.id; // Guardar ID para otros tests
    });

    // --- Tests GET ---
    it('GET /api/rewards - should retrieve a list of rewards', async () => {
         if (!adminToken) throw new Error("Admin token not available");
         const response = await request(app).get('/api/rewards').set('Authorization', `Bearer ${adminToken}`).expect(200);
         expect(Array.isArray(response.body)).toBe(true);
         if (mainTestRewardId) { // Verificar que la creada existe
             expect(response.body.some((r: Reward) => r.id === mainTestRewardId)).toBe(true);
         }
    });
     it('GET /api/rewards - should fail to get rewards without auth token', async () => {
        await request(app).get('/api/rewards').expect(401);
    });
    it('GET /api/rewards/:id - should retrieve a specific reward', async () => {
        if (!adminToken || !mainTestRewardId) throw new Error("Prerequisites not met");
        const response = await request(app).get(`/api/rewards/${mainTestRewardId}`).set('Authorization', `Bearer ${adminToken}`).expect(200);
        expect(response.body.id).toBe(mainTestRewardId);
    });
   it('GET /api/rewards/:id - should return 404 for non-existent reward', async () => {
       if (!adminToken) throw new Error("Admin token not available");
       const nonExistentId = '00000000-0000-0000-0000-000000000000';
       await request(app).get(`/api/rewards/${nonExistentId}`).set('Authorization', `Bearer ${adminToken}`).expect(404);
   });

   // --- Tests PUT/PATCH ---
    it('PUT /api/rewards/:id - should update a reward completely', async () => {
       if (!adminToken || !mainTestRewardId) throw new Error("Prerequisites not met");
       const updateData = { name: `Updated ${Date.now()}`, description: 'Upd Desc', pointsCost: 250, isActive: false };
       const response = await request(app).put(`/api/rewards/${mainTestRewardId}`).set('Authorization', `Bearer ${adminToken}`).send(updateData).expect(200);
       expect(response.body.name).toBe(updateData.name);
       expect(response.body.pointsCost).toBe(updateData.pointsCost);
       expect(response.body.isActive).toBe(updateData.isActive);
    });
    it('PATCH /api/rewards/:id - should partially update a reward (toggle isActive)', async () => {
       if (!adminToken || !mainTestRewardId) throw new Error("Prerequisites not met");
       const currentState = await request(app).get(`/api/rewards/${mainTestRewardId}`).set('Authorization', `Bearer ${adminToken}`);
       const currentIsActive = currentState.body.isActive;
       const response = await request(app).patch(`/api/rewards/${mainTestRewardId}`).set('Authorization', `Bearer ${adminToken}`).send({ isActive: !currentIsActive }).expect(200);
       expect(response.body.isActive).toBe(!currentIsActive);
    });

    // --- Tests DELETE ---
    it('DELETE /api/rewards/:id - should delete a reward', async () => {
        if (!adminToken) throw new Error("Admin token not available");
        // 1. Crear una recompensa espec√≠ficamente para este test
        const rewardName = `To Delete ${Date.now()}`;
        const createRes = await request(app).post('/api/rewards').set('Authorization', `Bearer ${adminToken}`).send({ name: rewardName, pointsCost: 10 }).expect(201);
        rewardToDeleteId = createRes.body.id; // Guardar ID para posible limpieza en afterAll si falla
        expect(rewardToDeleteId).toBeTypeOf('string');

        // 2. Borrarla
        await request(app)
            .delete(`/api/rewards/${rewardToDeleteId}`)
            .set('Authorization', `Bearer ${adminToken}`)
            .expect(200); // O 204 si no devuelve cuerpo

        // 3. Verificar que ya no existe (GET debe dar 404)
        await request(app)
            .get(`/api/rewards/${rewardToDeleteId}`)
            .set('Authorization', `Bearer ${adminToken}`)
            .expect(404);

        rewardToDeleteId = null; // Indicar que se borr√≥ con √©xito
    });

     it('DELETE /api/rewards/:id - should return 404 if reward to delete not found', async () => {
         if (!adminToken) throw new Error("Admin token not available");
         const nonExistentId = '00000000-0000-0000-0000-000000000000';
         await request(app)
             .delete(`/api/rewards/${nonExistentId}`)
             .set('Authorization', `Bearer ${adminToken}`)
             .expect('Content-Type', /json/) // El servicio devuelve JSON para 404
             .expect(404);
     });

    // Test 409 (conflicto) sigue pendiente de setup m√°s complejo
    /*
     it('DELETE /api/rewards/:id - should return 409 if reward is in use', async () => { ... });
    */

});


// ====== [124] backend/tests/integration/tiers.test.ts ======
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import app from '../../src/index';
import { Tier } from '@prisma/client';

describe('Tiers API Integration Tests (/api/tiers)', () => {

    let adminToken: string | null = null;
    // --- CAMBIO: Usar array para TODOS los IDs creados ---
    const createdTierIds: string[] = [];
    // --- FIN CAMBIO ---
    let initialTierData: Partial<Tier> = {}; // Para comparar despu√©s de actualizar


    // Setup (sin cambios)
    beforeAll(async () => {
        console.log("Starting beforeAll setup for tiers tests...");
        try {
            const adminLoginRes = await request(app)
                .post('/api/auth/login')
                .send({ email: 'admin@cafeelsol.com', password: 'superpasswordseguro' });
            if (adminLoginRes.status === 200 && adminLoginRes.body.token) {
                adminToken = adminLoginRes.body.token;
                console.log("Admin logged in successfully for tiers tests.");
            } else {
                throw new Error("Admin login failed in tiers test setup");
            }
        } catch (error) {
            console.error("CRITICAL: Error during admin login setup for tiers:", error);
            throw error;
        }
        console.log("Finished beforeAll setup for tiers tests.");
    }, 20000);

    // --- CAMBIO: Limpieza afterAll mejorada ---
    afterAll(async () => {
        if (adminToken && createdTierIds.length > 0) {
             console.log(`Running afterAll cleanup: deleting ${createdTierIds.length} created tiers...`);
             // Borrar en orden inverso por si acaso
             for (let i = createdTierIds.length - 1; i >= 0; i--) {
                 const tierId = createdTierIds[i];
                 try {
                     // Usamos un try/catch individual para que un fallo no detenga la limpieza de otros
                     await request(app)
                         .delete(`/api/tiers/tiers/${tierId}`)
                         .set('Authorization', `Bearer ${adminToken}`)
                         .timeout(2000); // Timeout corto para cleanup
                     console.log(`Tier ${tierId} deleted during cleanup.`);
                 } catch (error: any) {
                     // Solo logueamos si falla, no detenemos
                     console.warn(`Warning during afterAll cleanup, could not delete tier ${tierId}: Status ${error?.status || 'unknown'}`);
                 }
             }
             createdTierIds.length = 0; // Vaciar array para futuras ejecuciones si el test runner reutiliza contexto
        } else {
            console.log("afterAll cleanup: No tiers to delete or no admin token.");
        }
    });
    // --- FIN CAMBIO ---


    // --- Tests POST (Modificado para a√±adir ID al array) ---
    it('POST /api/tiers/tiers - should fail to create tier without auth token', async () => { /* sin cambios */
        await request(app).post('/api/tiers/tiers').send({ name: 'Fail No Auth', level: 1, minValue: 100 }).expect(401);
    });
    it('POST /api/tiers/tiers - should fail to create tier with missing name', async () => { /* sin cambios */
        if (!adminToken) throw new Error("Admin token not available");
        await request(app).post('/api/tiers/tiers').set('Authorization', `Bearer ${adminToken}`).send({ level: 1, minValue: 100 }).expect(400);
    });
     it('POST /api/tiers/tiers - should fail to create tier with invalid level (negative)', async () => { /* sin cambios */
        if (!adminToken) throw new Error("Admin token not available");
        await request(app).post('/api/tiers/tiers').set('Authorization', `Bearer ${adminToken}`).send({ name: 'Fail Level', level: -1, minValue: 100 }).expect(400);
    });
     it('POST /api/tiers/tiers - should fail to create tier with invalid minValue (negative)', async () => { /* sin cambios */
        if (!adminToken) throw new Error("Admin token not available");
        await request(app).post('/api/tiers/tiers').set('Authorization', `Bearer ${adminToken}`).send({ name: 'Fail MinValue', level: 1, minValue: -100 }).expect(400);
    });
    it('POST /api/tiers/tiers - should create a new tier successfully', async () => { /* MODIFICADO */
        if (!adminToken) throw new Error("Admin token not available");
        const uniqueLevel = Math.floor(Date.now() / 1000);
        initialTierData = { name: `Test Tier ${uniqueLevel}`, level: uniqueLevel, minValue: uniqueLevel * 100, description: 'Tier for testing', isActive: true };
        const response = await request(app).post('/api/tiers/tiers').set('Authorization', `Bearer ${adminToken}`).send(initialTierData).expect(201);
        expect(response.body.id).toBeTypeOf('string');
        expect(response.body.name).toBe(initialTierData.name);
        expect(response.body.isActive).toBe(initialTierData.isActive);
        // --- CAMBIO: A√±adir ID al array para limpieza ---
        createdTierIds.push(response.body.id);
        // --- FIN CAMBIO ---
    });
     it('POST /api/tiers/tiers - should fail to create tier with duplicate level', async () => { /* sin cambios */
        if (!adminToken || createdTierIds.length === 0) throw new Error("Prerequisites not met - need created tier");
         const getRes = await request(app).get(`/api/tiers/tiers/${createdTierIds[0]}`).set('Authorization', `Bearer ${adminToken}`);
         const levelToDuplicate = getRes.body.level;
        await request(app).post('/api/tiers/tiers').set('Authorization', `Bearer ${adminToken}`).send({ name: 'Duplicate Level Tier', level: levelToDuplicate, minValue: 50 }).expect(409);
    });

    // --- Tests GET (Sin cambios) ---
    it('GET /api/tiers - should retrieve a list of tiers', async () => { /* sin cambios */
         if (!adminToken) throw new Error("Admin token not available");
         const response = await request(app).get('/api/tiers').set('Authorization', `Bearer ${adminToken}`).expect(200);
         expect(Array.isArray(response.body)).toBe(true);
         if (createdTierIds.length > 0) { expect(response.body.some((t: Tier) => t.id === createdTierIds[0])).toBe(true); }
    });
    it('GET /api/tiers/tiers/:tierId - should retrieve a specific tier', async () => { /* sin cambios */
        if (!adminToken || createdTierIds.length === 0) throw new Error("Prerequisites not met");
        const tierIdToGet = createdTierIds[0];
        const response = await request(app).get(`/api/tiers/tiers/${tierIdToGet}`).set('Authorization', `Bearer ${adminToken}`).expect(200);
        expect(response.body.id).toBe(tierIdToGet);
        expect(response.body.name).toBe(initialTierData.name);
    });
     it('GET /api/tiers/tiers/:tierId - should return 404 for non-existent tier', async () => { /* sin cambios */
        if (!adminToken) throw new Error("Admin token not available");
        const nonExistentId = '00000000-0000-0000-0000-000000000000';
        await request(app).get(`/api/tiers/tiers/${nonExistentId}`).set('Authorization', `Bearer ${adminToken}`).expect(404);
    });

   // --- Tests PUT/PATCH (Sin cambios) ---
    it('PUT /api/tiers/tiers/:tierId - should update a tier completely', async () => { /* sin cambios */
       if (!adminToken || createdTierIds.length === 0) throw new Error("Prerequisites not met");
       const tierIdToUpdate = createdTierIds[0];
       const updateData = { name: `Updated Tier ${Date.now()}`, level: initialTierData.level! + 1, minValue: initialTierData.minValue! + 50, description: 'Updated', isActive: false };
       const response = await request(app).put(`/api/tiers/tiers/${tierIdToUpdate}`).set('Authorization', `Bearer ${adminToken}`).send(updateData).expect(200);
       expect(response.body.name).toBe(updateData.name);
       expect(response.body.isActive).toBe(updateData.isActive);
       initialTierData = response.body;
    });
    it('PATCH /api/tiers/tiers/:tierId - should partially update a tier (toggle isActive)', async () => { /* sin cambios */
       if (!adminToken || createdTierIds.length === 0) throw new Error("Prerequisites not met");
       const tierIdToPatch = createdTierIds[0];
       const currentIsActive = initialTierData.isActive;
       const patchData = { isActive: !currentIsActive };
       const response = await request(app).patch(`/api/tiers/tiers/${tierIdToPatch}`).set('Authorization', `Bearer ${adminToken}`).send(patchData).expect(200);
       expect(response.body.isActive).toBe(patchData.isActive);
       expect(response.body.name).toBe(initialTierData.name);
    });

    // --- Tests DELETE (Modificado para a√±adir ID al array) ---
    it('DELETE /api/tiers/tiers/:tierId - should delete a tier', async () => { /* MODIFICADO */
        if (!adminToken) throw new Error("Admin token not available");
         const uniqueLevel = Math.floor(Date.now() / 1000) + 2000;
         const tierData = { name: `To Delete ${uniqueLevel}`, level: uniqueLevel, minValue: 1 };
         const createRes = await request(app).post('/api/tiers/tiers').set('Authorization', `Bearer ${adminToken}`).send(tierData).expect(201);
         const idToDelete = createRes.body.id;
         // --- CAMBIO: A√±adir ID temporal al array ---
         createdTierIds.push(idToDelete); // Lo a√±adimos para que afterAll lo limpie si algo falla
         // --- FIN CAMBIO ---
         expect(idToDelete).toBeTypeOf('string');

        await request(app).delete(`/api/tiers/tiers/${idToDelete}`).set('Authorization', `Bearer ${adminToken}`).expect(200);
        await request(app).get(`/api/tiers/tiers/${idToDelete}`).set('Authorization', `Bearer ${adminToken}`).expect(404);

         // Si llegamos aqu√≠, el borrado tuvo √©xito, podemos quitarlo del array para que afterAll no lo intente de nuevo (opcional)
         const indexToRemove = createdTierIds.indexOf(idToDelete);
         if (indexToRemove > -1) {
             createdTierIds.splice(indexToRemove, 1);
         }
    });
     it('DELETE /api/tiers/tiers/:tierId - should return 404 if tier to delete not found', async () => { /* sin cambios */
         if (!adminToken) throw new Error("Admin token not available");
         const nonExistentId = '00000000-0000-0000-0000-000000000000';
         await request(app).delete(`/api/tiers/tiers/${nonExistentId}`).set('Authorization', `Bearer ${adminToken}`).expect(404);
     });

});


// ====== [125] backend/tsconfig.json ======
{
  "compilerOptions": {
    "target": "es2022",
    "module": "commonjs",
    // --- CAMBIO PRINCIPAL: Ajustar rootDir ---
    "rootDir": ".", // La ra√≠z ahora es la carpeta principal del backend
    // --- FIN DEL CAMBIO ---
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  },
  "include": [
    "src/**/*.ts",
    "prisma/**/*.ts",
    "scripts/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "tests", // Excluimos la carpeta de tests para que no se compile a /dist
    "**/*.test.ts", // Excluimos archivos de test
    "**/*.spec.ts" // Excluimos archivos de spec
  ]
}


// ====== [126] backend/vitest.config.ts ======
// backend/vitest.config.ts (Opcional por ahora)
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true, // Para no tener que importar describe, it, expect, etc.
    environment: 'node', // Entorno de Node.js
    // setupFiles: ['./tests/setup.ts'], // Archivo opcional para configuraci√≥n global
    coverage: {
      provider: 'v8', // o 'istanbul'
      reporter: ['text', 'json', 'html'],
    },
  },
});


// ====== [127] frontend/eslint.config.js ======
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)



// ====== [128] frontend/index.html ======
<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LoyalPyME</title>

    <style>
      body {
        margin: 0; /* Asegura que no haya m√°rgenes por defecto */
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; /* Fuente simple de sistema */
      }
      #initial-loader {
        position: fixed; /* Posici√≥n fija para cubrir todo */
        inset: 0; /* Equivalente a top: 0; right: 0; bottom: 0; left: 0; */
        background-color: #f8f9fa; /* Un fondo claro simple (ajusta si prefieres oscuro) */
        display: flex;
        flex-direction: column; /* Apila texto y spinner */
        align-items: center;
        justify-content: center;
        z-index: 9999; /* Asegura que est√© por encima de todo */
        color: #495057;
        transition: opacity 0.5s ease-out; /* Transici√≥n suave al ocultar */
      }
      #initial-loader .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border-left-color: #09f; /* Color del spinner (puedes usar tu azul Mantine) */
        margin-top: 20px;
        animation: spin 1s ease infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      /* Estilo opcional para ocultar cuando se a√±ade la clase 'hidden' */
       #initial-loader.hidden {
          opacity: 0;
          pointer-events: none; /* No interferir con clics */
       }
    </style>
    </head>
  <body>
    <div id="initial-loader">
      <p>Cargando LoyalPyME...</p>
      <div class="spinner"></div>
    </div>
    <div id="root"></div>

    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


// ====== [129] frontend/package.json ======
{
  "name": "frontend",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "license": "SEE LICENSE IN ../LICENSE.md",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@mantine/core": "^7.17.4",
    "@mantine/form": "^7.17.4",
    "@mantine/hooks": "^7.17.4",
    "@mantine/modals": "^7.17.5",
    "@mantine/notifications": "^7.17.4",
    "@tabler/icons-react": "^3.31.0",
    "axios": "^1.8.4",
    "date-fns": "^4.1.0",
    "html5-qrcode": "^2.3.8",
    "i18next": "^23.13.2",
    "i18next-browser-languagedetector": "^8.0.1",
    "i18next-http-backend": "^2.5.2",
    "qrcode.react": "^4.2.0",
    "react": "^19.0.0",
    "react-country-flag": "^3.1.0",
    "react-dom": "^19.0.0",
    "react-i18next": "^15.0.1",
    "react-image-crop": "^11.0.10",
    "react-router-dom": "^6.26.1",
    "uuid": "^11.1.0",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@eslint/js": "^9.22.0",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.7.1",
    "@testing-library/react": "^16.0.0",
    "@testing-library/user-event": "^14.5.2",
    "@types/qrcode.react": "^1.0.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@types/uuid": "^10.0.0",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.22.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "jsdom": "^24.1.1",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.26.1",
    "vite": "^5.4.0",
    "vite-plugin-mkcert": "^1.17.8",
    "vitest": "^2.0.4"
  }
}



// ====== [130] frontend/public/locales/en/translation.json ======
{
  "common": {
    "loading": "Loading...",
    "save": "Save",
    "cancel": "Cancel",
    "delete": "Delete",
    "edit": "Edit",
    "add": "Add",
    "confirm": "Confirm",
    "close": "Close",
    "error": "Error",
    "success": "Success",
    "requiredField": "This field is required.",
    "back": "Back",
    "actions": "Actions",
    "status": "Status",
    "active": "Active",
    "inactive": "Inactive",
    "name": "Name",
    "description": "Description",
    "points": "Points",
    "level": "Level",
    "email": "Email",
    "registered": "Registered",
    "yes": "Yes",
    "no": "No",
    "searchPlaceholder": "Search...",
    "noResults": "No results found.",
    "selectPlaceholder": "Select one",
    "optional": "Optional",
    "confirmAction": "Confirm Action",
    "noItems": "No items defined yet.",
    "errorLoadingData": "Error loading data",
    "info": "Information",
    "errorUnknown": "Unknown error",
    "invalidDate": "Invalid date",
    "upcomingFeatureTitle": "Coming Soon",
    "deleting": "Deleting...",
    "customer": "Customer",
    "selected": "selected",
    "errorImageTooSmall": "The image is too small. It must be at least {{minSize}}x{{minSize}} pixels.",
    "errorMustBePositiveOrZero": "Must be a number equal to or greater than 0.",
    "nameNotAvailable": "(No name)",
    "saveChanges": "Save Changes",
    "camera": "Camera",
    "item": "Item"
  },
  "validation": {
    "cannotBeZero": "The amount cannot be zero.",
    "benefitTypeRequired": "Select a valid benefit type.",
    "nameRequired": "Name is required.",
    "levelMin0": "Level must be 0 or greater.",
    "minValueMin0": "Minimum value must be 0 or greater.",
    "mustBePositive": "Must be > 0",
    "invalidUrl": "Invalid image URL."
  },
  "loginPage": {
    "title": "Login",
    "subtitle": "Don't have an account?",
    "registerLink": "Register here",
    "forgotPasswordLink": "Forgot your password?",
    "emailLabel": "Email",
    "emailPlaceholder": "you@email.com",
    "passwordLabel": "Password",
    "passwordPlaceholder": "Your password",
    "loginButton": "Login",
    "errorCredentials": "Invalid credentials.",
    "errorServer": "Server error during login.",
    "errorUnknown": "An unexpected error occurred.",
    "accessMenuDirectlyTitle": "Know the business identifier?",
    "businessSlugPlaceholder": "Business identifier (slug)",
    "goToMenuButton": "View Menu"
  },
  "registerPage": {
    "welcomeTitle": "Welcome to LoyalPyME!",
    "title": "Create Your Customer Account",
    "subtitle": "Already have an account?",
    "loginLink": "Login",
    "emailLabel": "Email",
    "passwordLabel": "Password",
    "confirmPasswordLabel": "Confirm Password",
    "nameLabel": "Name (Optional)",
    "phoneLabel": "Phone (international format)",
    "docTypeLabel": "Document Type",
    "docIdLabel": "Document Number",
    "businessLabel": "Business to Join",
    "registerButton": "Register",
    "errorLoadingBusinesses": "Could not load the list of businesses.",
    "errorPasswordsDontMatch": "Passwords do not match.",
    "errorRegistration": "Error during registration.",
    "emailPlaceholder": "you@email.com",
    "passwordPlaceholder": "Create a password",
    "confirmPasswordPlaceholder": "Repeat password",
    "namePlaceholder": "Your full name",
    "phonePlaceholder": "+1555...",
    "docTypePlaceholder": "Select one",
    "docIdPlaceholder": "ID, Passport...",
    "businessSelectLoading": "Loading businesses...",
    "businessSelectPlaceholder": "Select a business",
    "businessSelectNotFound": "No businesses available",
    "businessSelectError": "Error loading",
    "errorInvalidEmail": "Invalid email format.",
    "errorPasswordLength": "Password must be at least 6 characters long.",
    "errorConfirmPassword": "Confirm the password.",
    "errorPhoneFormat": "Invalid format (e.g., +1555...).",
    "errorDocType": "Select a document type.",
    "errorDNIFormat": "Invalid ID format (e.g., 8 numbers and 1 letter for DNI).",
    "errorNIEFormat": "Invalid NIE format (e.g., letter, 7 numbers, letter).",
    "errorBusinessRequired": "You must select a business.",
    "successMessage": "Your account has been created. You will be redirected to the login page."
  },
  "forgotPasswordPage": {
    "title": "Reset Password",
    "subtitle": "Remember your password?",
    "loginLink": "Back to Login",
    "instructions": "Enter your email address and we will send you (or show in the backend console) a link to reset your password.",
    "emailLabel": "Registered Email",
    "emailPlaceholder": "you@email.com",
    "buttonText": "Request Reset",
    "successTitle": "Request Sent",
    "successMessage": "If an account with that email exists, you will receive (or see in console) a link to reset your password. The link will expire in 1 hour.",
    "errorTitle": "Error",
    "errorMissingEmail": "Please enter your email address.",
    "errorGenericTitle": "Request Processed",
    "errorGenericMessage": "If an account with that email exists, you will receive (or see in console) a link to reset your password."
  },
  "resetPasswordPage": {
    "title": "Set New Password",
    "subtitle": "Enter your new password below.",
    "passwordLabel": "New Password",
    "passwordPlaceholder": "Enter your new password",
    "confirmPasswordLabel": "Confirm New Password",
    "confirmPasswordPlaceholder": "Repeat the new password",
    "buttonText": "Save New Password",
    "loginLink": "Back to Login",
    "successTitle": "Password Changed!",
    "successMessage": "Your password has been successfully reset. You will be redirected to Login.",
    "errorTitle": "Error Resetting",
    "errorMissingToken": "Reset token is missing. Please use the link sent to your email.",
    "errorPasswordsRequired": "Please enter and confirm the new password.",
    "errorPasswordsDontMatch": "Passwords do not match.",
    "errorPasswordLength": "The new password must be at least 6 characters long.",
    "errorInvalidToken": "Error resetting password. The token might be invalid or expired."
  },
  "registerBusinessPage": {
    "title": "Register New Business",
    "subtitle": "Create the account for your business and the main administrator.",
    "businessNameLabel": "Business Name",
    "businessNamePlaceholder": "My Awesome Cafe",
    "adminNameLabel": "Your Name (Admin)",
    "adminNamePlaceholder": "John Doe",
    "adminEmailLabel": "Your Email (Admin)",
    "adminEmailPlaceholder": "john.doe@mycafe.com",
    "adminPasswordLabel": "Password (Admin)",
    "adminPasswordPlaceholder": "Your password",
    "confirmPasswordLabel": "Confirm Password",
    "confirmPasswordPlaceholder": "Repeat your password",
    "registerButton": "Register Business",
    "loginLink": "Login",
    "loginLinkSubtitle": "Already have an account?",
    "successTitle": "Registration Successful!",
    "successMessage": "The business '{{businessName}}' and administrator {{adminEmail}} have been created successfully.",
    "errorTitle": "Registration Error",
    "errorRegistration": "Could not complete registration. Please try again.",
    "errorBusinessNameLength": "Business name must be at least 2 characters long",
    "errorAdminEmailInvalid": "Invalid email",
    "errorAdminPasswordLength": "Password must be at least 6 characters long",
    "errorConfirmPasswordLength": "Password confirmation must be at least 6 characters long",
    "errorPasswordsDontMatch": "Passwords do not match"
  },
  "header": {
    "greeting": "Hello, {{name}}!",
    "logoutButton": "Logout",
    "languageLabel": "Language",
    "toggleNavigation": "Toggle navigation"
  },
  "customerDashboard": {
    "title": "Customer Dashboard",
    "points": "Points",
    "currentTier": "Current Tier:",
    "baseTier": "Basic",
    "validateQrSectionTitle": "Validate QR Code",
    "qrInputLabel": "Enter ticket/QR code",
    "qrInputPlaceholder": "Paste the code here...",
    "validateButton": "Validate Code",
    "scanButton": "Scan QR",
    "scanModalTitle": "Scan QR Code",
    "scanInstructions": "Point the camera at the QR code",
    "scanCancelButton": "Cancel Scan",
    "scanButtonDisabledTooltip": "Scan QR only available on mobile",
    "rewardsSectionTitle": "Rewards and Gifts",
    "noRewardsAvailable": "No rewards or gifts available at this time.",
    "redeemGiftButton": "Redeem Gift",
    "redeemRewardButton": "Redeem Reward",
    "insufficientPoints": "Insufficient points",
    "giftFree": "Free",
    "giftAssignedBy": "Gifted by {{assigner}} on {{date}}",
    "giftInfo": "Info",
    "errorLoadingProfile": "Error loading your profile: {{error}}",
    "errorLoadingRewards": "Could not load rewards or gifts. {{error}}",
    "errorScanningQr": "Scanner Error",
    "errorScanningQrDefault": "Could not start the camera: {{error}}",
    "validating": "Validating...",
    "errorValidatingQr": "Validation Error",
    "errorValidatingQrMessage": "Unknown error validating QR.",
    "successQrValidation": "QR code validated successfully. You've earned {{points}} points.",
    "errorRedeemTitle": "Error Redeeming",
    "errorRedeemMessage": "Unknown error while redeeming.",
    "successRedeemRewardTitle": "Reward Redeemed!",
    "successRedeemRewardMessage": "You have redeemed your reward.",
    "successRedeemGiftTitle": "Gift Redeemed!",
    "successRedeemGiftMessage": "You have redeemed \"{{rewardName}}\".",
    "errorLoadingProfileTitle": "Profile Error",
    "errorLoadingProfileDefault": "Could not load user data.",
    "noUserDataError": "Could not load user data.",
    "tierBenefitsTitle": "Benefits for Tier: {{tierName}}",
    "progressUnitVisits": "visits",
    "progressLabel": "{{currentValue}} / {{targetValue}} {{unit}} to reach {{nextTierName}}",
    "maxLevelReached": "Congratulations! You have reached the maximum level ({currentTierName}).",
    "maxLevelReachedShort": "Max Level!",
    "nextTierBenefitsTitle": "Upon reaching {{tierName}} you will have:",
    "errorLoadingProgress": "Could not load tier data to show progress.",
    "tabSummary": "Summary",
    "tabRewards": "Rewards",
    "tabActivity": "My Activity",
    "tabOffers": "Offers & News",
    "tabProfile": "My Profile",
    "tabHistory": "My Orders",
    "summary": {
      "pendingGifts_one": "You have {{count}} pending gift:",
      "pendingGifts_other": "You have {{count}} pending gifts:",
      "pendingGiftsDesc": "You have gifts waiting to be redeemed.",
      "nextReward": "Next reward: {{name}} for {{points}} points.",
      "viewAllButton": "View All Rewards and Gifts",
      "noRewardsInfo": "Collect more points to get rewards.",
      "giftsAndRewardsTitle": "Available Gifts and Rewards:",
      "rewardsTitle": "Available Rewards:",
      "unknownAssigner": "Unknown",
      "redeemButton": "Redeem",
      "viewAllButtonShort": "View All",
      "viewMenuFor": "View Menu for {{businessName}}",
      "viewMenuDefaultTitle": "View Menu and Order",
      "viewMenuSubtitle": "Access the digital menu and place your order.",
      "viewMenuButton": "Go to Menu"
    },
    "activityTab": {
      "noActivity": "You have no registered activity yet.",
      "type_POINTS_EARNED_QR": "Points Earned (QR)",
      "type_POINTS_REDEEMED_REWARD": "Reward Redeemed",
      "type_GIFT_REDEEMED": "Gift Redeemed",
      "type_POINTS_ADJUSTED_ADMIN": "Manual Points Adjustment",
      "totalItems": "{{count}} record(s) in total",
      "desc_EARNED": "Points for ticket #{{ticketNumber}}",
      "desc_REDEEMED": "Redemption: {{rewardName}}",
      "desc_GIFT": "Gift redeemed: {{rewardName}}",
      "desc_ADJUSTED": "Manual points adjustment",
      "desc_ADJUSTED_REASON": "Manual adjustment: {{reason}}"
    },
    "rewards": {
      "affordable": "Affordable"
    },
    "historyTab": {
      "title": "My Order History",
      "noOrders": "You have no registered orders yet.",
      "totalOrders": "{{count}} order(s) in total"
    },
    "availableCouponsTitle": "My Available Coupons",
    "noAvailableCoupons": "You don't have any available coupons. Redeem your points in the catalog to get them!",
    "couponExpires": "Expires on:",
    "rewardsCatalogTitle": "Rewards Catalog",
    "giftsSectionTitle": "Received Gifts",
    "acquireRewardButton": "Get for {{count}} Points",
    "acquireRewardSuccessTitle": "Reward Acquired!",
    "acquireRewardSuccessMessage": "The reward is now available in 'My Coupons' to use whenever you want.",
    "acquireRewardError": "Could not acquire the reward.",
    "errorAcquireTitle": "Error Acquiring",
    "errorRedeemGiftMessage": "Could not redeem the gift."
  },
  "adminCommon": {
    "dashboard": "Dashboard",
    "rewards": "Rewards",
    "generateQr": "Generate QR",
    "customers": "Customers",
    "manageTiers": "Manage Tiers",
    "tierSettings": "Tier Settings",
    "saveSuccess": "Saved successfully",
    "updateSuccess": "Updated successfully",
    "createSuccess": "Created successfully",
    "deleteSuccess": "Deleted successfully",
    "saveError": "Error saving",
    "updateError": "Error updating",
    "createError": "Error creating",
    "deleteError": "Error deleting",
    "confirmDeleteTitle": "Confirm Deletion",
    "confirmDeleteMessage": "Are you sure? This action cannot be undone.",
    "adminTitle": "LoyalPyME Admin"
  },
  "adminOverview": {
    "welcome": "Welcome, {{name}}!",
    "panelIntro": "You are in the administration panel for",
    "panelDescription": "From here you can manage your loyalty program: configure tiers, rewards, customers, and generate QR codes.",
    "quickSummaryTitle": "Quick Summary",
    "statActiveCustomers": "CUSTOMERS",
    "statNewCustomers": "NEW (7D)",
    "statPointsIssued": "POINTS (7D)",
    "statRedemptions": "REDEMPTIONS (7D)",
    "quickAccessTitle": "Quick Access",
    "cardRewardsTitle": "Rewards",
    "cardRewardsDesc": "Create and manage the rewards your customers can redeem.",
    "cardRewardsButton": "Manage Rewards",
    "cardTiersTitle": "Loyalty Tiers",
    "cardTiersDesc": "Define the different levels and benefits for your customers.",
    "cardTiersButton": "Manage Tiers",
    "cardTierSettingsTitle": "Tier Configuration",
    "cardTierSettingsDesc": "Adjust the logic of how customers move up or down tiers.",
    "cardTierSettingsButton": "Adjust Configuration",
    "cardQrTitle": "Generate Points QR",
    "cardQrDesc": "Create unique QR codes for your customers to earn points.",
    "cardQrButton": "Generate QR Code",
    "cardCustomersTitle": "Customers",
    "cardCustomersDesc": "View and manage the list of your registered customers.",
    "cardCustomersButton": "Manage Customers",
    "errorLoadingStats": "Could not load statistics.",
    "noStatsAvailable": "No statistical data available.",
    "defaultBusinessName": "your Business",
    "noModulesActivePrompt": "No modules are active for this business. Activate them from the Super Admin panel."
  },
  "adminRewardsPage": {
    "title": "Reward Management",
    "addButton": "Add Reward",
    "cancelAddButton": "Cancel Add",
    "tableHeaderName": "Name",
    "tableHeaderCost": "Cost",
    "tableHeaderStatus": "Status",
    "tableHeaderActions": "Actions",
    "tooltipEdit": "Edit Reward",
    "tooltipDeactivate": "Deactivate",
    "tooltipActivate": "Activate",
    "tooltipDelete": "Delete Reward",
    "noRewardsYet": "You haven't created any rewards yet.",
    "addFormTitle": "Add New Reward",
    "editFormTitle": "Edit Reward",
    "confirmDeleteMessage": "Are you sure you want to delete the reward \"{{name}}\"? This action cannot be undone.",
    "deleteSuccessMessage": "The reward \"{{name}}\" has been deleted.",
    "deleteErrorNotFound": "Reward \"{{name}}\" not found (perhaps it was already deleted).",
    "deleteErrorInUse": "\"{{name}}\" cannot be deleted because it is in use.",
    "toggleStatusSuccess": "The reward has been {{status}} successfully.",
    "toggleStatusError": "Error {{status}} the reward: {{error}}",
    "statusActivated": "activated",
    "statusDeactivated": "deactivated",
    "updateSuccessMessage": "Reward \"{{name}}\" updated.",
    "createSuccessMessage": "Reward \"{{name}}\" created."
  },
  "component": {
    "rewardForm": {
      "nameLabel": "Reward Name:",
      "namePlaceholder": "E.g.: Free Coffee",
      "descriptionLabel": "Description (Optional):",
      "descriptionPlaceholder": "E.g.: One espresso or americano coffee",
      "pointsCostLabel": "Cost in Points:",
      "pointsCostPlaceholder": "E.g.: 100",
      "errorNameRequired": "Reward name cannot be empty.",
      "errorPointsCostInvalid": "Cost in points must be a number equal to or greater than zero.",
      "nameEsLabel": "Name (ES)",
      "nameEsPlaceholder": "Ej: Caf√© Gratis",
      "nameEnLabel": "Name (EN)",
      "nameEnPlaceholder": "E.g.: Free Coffee",
      "descriptionEsLabel": "Description (ES, Optional)",
      "descriptionEsPlaceholder": "Ej: Un caf√© espresso o americano",
      "descriptionEnLabel": "Description (EN, Optional)",
      "descriptionEnPlaceholder": "E.g.: One espresso or americano coffee",
      "imageLabel": "Image",
      "removeImageButton": "Remove Image",
      "selectImageButton": "Select Image",
      "cropInstructions": "Crop the image",
      "confirmCropButton": "Confirm Crop and Upload",
      "errorInvalidDataTitle": "Invalid Data",
      "errorInvalidDataMsg": "Please fill in the names in both languages and a valid point cost (0 or greater).",
      "errorNameEsRequired": "Name in Spanish is required.",
      "errorNameEnRequired": "Name in English is required.",
      "errorImageTooSmall": "The image is too small. It must be at least {{minSize}}x{{minSize}} pixels.",
      "errorInvalidCrop": "Invalid crop selection or image. Ensure the crop has a size.",
      "errorCreatingCroppedFile": "Could not create the cropped image file.",
      "imageUploadSuccess": "Image cropped and uploaded successfully.",
      "errorApiNoUrl": "The API did not return a valid image URL.",
      "errorUploadingWithDetail": "Error uploading: {{error}}",
      "imageUploadError": "Could not upload the image: {{error}}",
      "errorMissingIdForUpdate": "Reward ID is missing for update.",
      "rewardFallbackName": "Reward",
      "altImagePreview": "Preview of {{name}}",
      "altCropImage": "Image to crop"
    },
    "generateQr": {
      "amountLabel": "Sale Amount (‚Ç¨):",
      "amountPlaceholder": "E.g.: 15.50",
      "ticketLabel": "Ticket Number:",
      "ticketPlaceholder": "E.g.: T-12345",
      "buttonText": "Generate QR Data",
      "errorAmountPositive": "The amount must be a positive number.",
      "errorTicketRequired": "Ticket number is required.",
      "successMessage": "QR Generated for {{amount}} ‚Ç¨!",
      "successInstructions": "Ask the customer to scan this code to get their points.",
      "tokenRef": "Token (ref.):",
      "errorGeneric": "Error generating QR: {{error}}",
      "initialPrompt": "Enter amount and ticket number to generate QR data."
    },
    "tierForm": {
      "nameLabel": "Tier Name",
      "namePlaceholder": "E.g.: Gold",
      "levelLabel": "Level (Order)",
      "levelPlaceholder": "E.g.: 3",
      "levelDescription": "Number for ordering tiers (0 or greater).",
      "minValueLabel": "Minimum Value to Reach",
      "minValuePlaceholder": "E.g.: 1500",
      "minValueDescription": "Spend (‚Ç¨), Visits or Points required (depending on business config).",
      "descriptionLabel": "Description (Optional)",
      "descriptionPlaceholder": "Brief description of the tier",
      "benefitsDescriptionLabel": "Benefits Summary (Optional)",
      "benefitsDescriptionPlaceholder": "Summary text of main benefits for the customer",
      "activeLabel": "Active Tier",
      "activeDescription": "If inactive, customers cannot reach it or see its benefits."
    },
    "tierBenefitsModal": {
      "modalTitle": "Manage Benefits - Tier: {{name}}",
      "addSectionTitle": "Add New Benefit",
      "listSectionTitle": "Current Benefits",
      "errorLoading": "Error loading benefits.",
      "noBenefits": "This tier has no defined benefits.",
      "addBenefitButton": "Add Benefit",
      "closeButton": "Close",
      "tableHeaderType": "Type",
      "tableHeaderValue": "Value",
      "tableHeaderDescription": "Description",
      "tableHeaderStatus": "Status",
      "tableHeaderActions": "Actions",
      "tooltipEditBenefit": "Edit Benefit",
      "tooltipDeleteBenefit": "Delete Benefit",
      "addSuccessTitle": "Benefit Added",
      "addSuccessMessage": "The new benefit has been added successfully.",
      "addErrorTitle": "Error Adding",
      "addErrorMessage": "Could not add the benefit.",
      "deleteUpcoming": "Benefit deletion not yet implemented.",
      "editUpcoming": "Benefit editing not yet implemented."
    },
    "addTierBenefitForm": {
      "typeLabel": "Benefit Type",
      "typePlaceholder": "Select a type",
      "valueLabel": "Value",
      "valuePlaceholder": "E.g.: 1.5, reward_id, 'X Discount'",
      "valueDescription": "Value associated with the type (number, ID, text)",
      "descriptionLabel": "Description (Optional)",
      "descriptionPlaceholder": "Additional details of the benefit",
      "activeLabel": "Active Benefit",
      "benefitType_POINTS_MULTIPLIER": "Points Multiplier",
      "benefitType_EXCLUSIVE_REWARD_ACCESS": "Exclusive Reward Access",
      "benefitType_CUSTOM_BENEFIT": "Custom Benefit",
      "errorValueRequired": "Value is required"
    }
  },
  "adminTiersManagePage": {
    "title": "Manage Tiers",
    "addButton": "Create New Tier",
    "tableHeaderLevel": "Level (Order)",
    "tableHeaderName": "Name",
    "tableHeaderThreshold": "Minimum Threshold",
    "tableHeaderBenefits": "Benefits",
    "tableHeaderStatus": "Status",
    "tableHeaderActions": "Actions",
    "tooltipManageBenefits": "Manage Benefits",
    "tooltipEditTier": "Edit Tier",
    "tooltipDeleteTier": "Delete Tier",
    "noTiersDefined": "No tiers defined yet.",
    "benefitsSummaryNone": "None",
    "benefitsSummaryNoneActive": "None active",
    "benefitsSummaryActive_one": "{{count}} active benefit",
    "benefitsSummaryActive_other": "{{count}} active benefits",
    "createModalTitle": "Create New Tier",
    "editModalTitle": "Edit Tier: {{name}}",
    "deleteModalTitle": "Confirm Deletion",
    "deleteModalMessage": "Are you sure you want to delete the tier \"{{name}}\"? This action cannot be undone.",
    "deleteModalConfirm": "Delete Tier",
    "createSuccessTitle": "Tier Created",
    "createSuccessMessage": "Tier \"{{name}}\" has been created successfully.",
    "createErrorTitle": "Error Creating",
    "createErrorMessage": "Could not create the tier.",
    "updateSuccessTitle": "Tier Updated",
    "updateSuccessMessage": "Tier \"{{name}}\" has been updated successfully.",
    "updateErrorTitle": "Error Updating",
    "updateErrorMessage": "Could not update the tier.",
    "deleteLoadingMessage": "Attempting to delete tier \"{{name}}\"",
    "deleteSuccessTitle": "Deleted!",
    "deleteSuccessMessage": "Tier \"{{name}}\" has been deleted successfully.",
    "deleteErrorTitle": "Error Deleting",
    "deleteErrorMessage": "Error deleting the tier.",
    "deleteErrorNotFound": "Selected tier for editing not found.",
    "deleteErrorInUse": "Cannot delete Tier {{id}} because it has assigned users. Reassign them first."
  },
  "adminTiersSettingsPage": {
    "title": "Tier System Configuration",
    "description": "Define here how your tier system works globally. Changes will apply to all customers.",
    "enableSystemLabel": "Enable Tier System",
    "enableSystemDescription": "Activates or deactivates tier calculation and its benefits.",
    "basisLabel": "Basis for Calculating Tier",
    "basisPlaceholder": "Select how tier is achieved",
    "basisPlaceholderDisabled": "N/A (System Disabled)",
    "basisDescription": "Main metric used to determine tier (Spend, Visits, or Historical Points).",
    "basisOption_SPEND": "Accumulated Spend (‚Ç¨)",
    "basisOption_VISITS": "Number of Visits",
    "basisOption_POINTS_EARNED": "Historical Points Earned",
    "periodLabel": "Calculation Period (Months)",
    "periodPlaceholder": "E.g.: 12",
    "periodPlaceholderNA": "N/A",
    "periodDescription": "Months back to calculate metric (0/empty = lifetime).",
    "downgradePolicyLabel": "Tier Downgrade Policy",
    "downgradePolicyPlaceholder": "Select how tiers are lowered",
    "downgradePolicyDescription": "Rule for tier downgrade (Never, Periodic Review, or After Inactivity).",
    "downgradePolicyOption_NEVER": "Never Downgrade",
    "downgradePolicyOption_PERIODIC_REVIEW": "Periodic Review",
    "downgradePolicyOption_AFTER_INACTIVITY": "After Inactivity",
    "inactivityLabel": "Months of Inactivity for Downgrade",
    "inactivityPlaceholder": "E.g.: 6",
    "inactivityDescription": "Months without activity to downgrade tier.",
    "editButton": "Edit Configuration",
    "saveButton": "Save Changes",
    "cancelButton": "Cancel",
    "errorLoading": "Error loading Tier configuration.",
    "errorSaving": "Error saving configuration.",
    "successSaving": "Settings have been saved successfully."
  },
  "adminCustomersPage": {
    "title": "Customer Management",
    "filterLabel": "Filters:",
    "searchPlaceholder": "Search by name or email...",
    "statusFilterPlaceholder": "Status",
    "statusFilterAll": "All Statuses",
    "statusFilterActive": "Active",
    "statusFilterInactive": "Inactive",
    "favoriteFilterLabel": "Favorites Only",
    "tierFilterPlaceholder": "Tier",
    "tierFilterAll": "All Tiers",
    "tierFilterNone": "No Tier (Basic)",
    "tierFilterError": "Error loading",
    "selectedCount_one": "{{count}} customer selected",
    "selectedCount_other": "{{count}} customers selected",
    "bulkDeleteButton": "Delete",
    "bulkActivateButton": "Activate",
    "bulkDeactivateButton": "Deactivate",
    "bulkPointsButton": "Points",
    "resultsCount_one": "{{count}} customer found",
    "resultsCount_other": "{{count}} customers found",
    "resultsCountFiltered": " with current criteria",
    "noResults": "No customers found.",
    "noResultsFiltered": "No customers found with current criteria.",
    "tableHeaderFavorite": "Fav.",
    "tableHeaderName": "Name",
    "tableHeaderEmail": "Email",
    "tableHeaderPoints": "Points",
    "tableHeaderTier": "Tier",
    "tableHeaderRegistered": "Registered",
    "tableHeaderStatus": "Status",
    "tableHeaderActions": "Actions",
    "tooltipViewDetails": "View Details",
    "tooltipAdjustPoints": "Adjust Points",
    "tooltipChangeTier": "Change Tier",
    "tooltipAssignReward": "Assign Reward",
    "tooltipDeactivateCustomer": "Deactivate Customer",
    "tooltipActivateCustomer": "Activate Customer",
    "tooltipFavorite": "Mark as Favorite",
    "tooltipUnfavorite": "Remove from Favorites",
    "checkboxAriaLabel": "Select row {{id}}",
    "checkboxSelectAllAriaLabel": "Select all visible rows",
    "adjustPointsModalTitle": "Adjust Points for {{name}}",
    "adjustPointsCurrent": "Current points: {{points}}",
    "adjustPointsAmountLabel": "Amount to Add/Subtract",
    "adjustPointsAmountPlaceholder": "E.g.: 50 (add) or -20 (subtract)",
    "adjustPointsReasonLabel": "Reason (Optional)",
    "adjustPointsReasonPlaceholder": "E.g.: Manual correction, Special bonus",
    "adjustPointsButton": "Adjust Points",
    "adjustPointsSuccess": "Points adjusted successfully for {{name}}.",
    "adjustPointsError": "Could not adjust points: {{error}}",
    "changeTierModalTitle": "Manually Change Tier for {{name}}",
    "changeTierCurrent": "Current tier: {{tierName}}",
    "changeTierSelectLabel": "Select New Tier",
    "changeTierSelectPlaceholder": "Choose a tier from the list",
    "changeTierOptionNone": "Remove Tier (Basic)",
    "changeTierOptionLevel": "Level {{level}}",
    "changeTierNotFound": "No tiers available or not found.",
    "changeTierButton": "Change Tier",
    "changeTierNoChange": "The selected tier is the same as the current one.",
    "changeTierNoChangeTitle": "No Changes",
    "changeTierSuccess": "Tier changed successfully for {{name}}.",
    "changeTierError": "Could not change tier: {{error}}",
    "changeTierErrorLoadingTiers": "Could not load tiers: {{error}}",
    "changeTierLoadingErrorTitle": "Error Loading Tiers",
    "assignRewardModalTitle": "Assign Reward as Gift to {{name}}",
    "assignRewardSelectLabel": "Select a Reward",
    "assignRewardSelectPlaceholder": "Choose a reward from the list",
    "assignRewardOptionPoints": "{{points}} pts",
    "assignRewardNotFound": "No rewards available or not found.",
    "assignRewardButton": "Assign Reward",
    "assignRewardSuccess": "Reward assigned successfully to {{name}}.",
    "assignRewardError": "Could not assign reward: {{error}}",
    "assignRewardErrorLoading": "Could not load rewards: {{error}}",
    "assignRewardLoadingErrorTitle": "Error Loading Rewards",
    "customerDetailsModalTitle": "Details for {{name}}",
    "customerDetailsLoadingError": "Error Loading Details",
    "customerDetailsPoints": "Current Points:",
    "customerDetailsTier": "Current Tier:",
    "customerDetailsTierDate": "Tier Achieved:",
    "customerDetailsStatus": "Status:",
    "customerDetailsFavorite": "Favorite:",
    "customerDetailsRegisteredDate": "Registration Date:",
    "customerDetailsAdminNotesLabel": "Admin Notes",
    "customerDetailsAdminNotesPlaceholder": "Add internal notes about this customer...",
    "customerDetailsSaveNotesButton": "Save Notes",
    "customerDetailsNoDetails": "No details found for this customer.",
    "customerDetailsNotesSaved": "Admin notes saved successfully.",
    "customerDetailsNotesError": "Could not save notes: {{error}}",
    "noCustomerSelected": "No customer selected.",
    "bulkActionNoneSelected": "No customers selected.",
    "bulkConfirmToggleActiveTitle": "Confirm Bulk Activation/Deactivation",
    "bulkConfirmToggleActiveMessage": "Are you sure you want to {{action}} {{count}} selected customer(s)?",
    "bulkConfirmToggleActivate": "activate",
    "bulkConfirmToggleDeactivate": "deactivate",
    "bulkConfirmDeleteTitle": "Confirm Bulk Deletion",
    "bulkConfirmDeleteMessage": "Are you sure you want to permanently delete {{count}} selected customer(s)? This action cannot be undone.",
    "bulkConfirmDeleteButton": "Delete Customers",
    "bulkActionStatusSuccess": "{{count}} customer(s) {{status}} successfully.",
    "bulkActionStatusActivated": "activated",
    "bulkActionStatusDeactivated": "deactivated",
    "bulkActionStatusError": "Could not {{action}} customers: {{error}}",
    "bulkActionDeleteSuccess": "{{count}} customer(s) deleted successfully.",
    "bulkActionDeleteError": "Could not delete customers: {{error}}",
    "bulkAdjustPointsModalTitle": "Adjust Points for {{count}} Selected Customer(s)",
    "bulkAdjustPointsAmountLabel": "Amount to Add/Subtract",
    "bulkAdjustPointsAmountPlaceholder": "E.g.: 50 (add) or -20 (subtract)",
    "bulkAdjustPointsReasonLabel": "Reason (Optional)",
    "bulkAdjustPointsReasonPlaceholder": "E.g.: Bulk bonus, General correction",
    "bulkAdjustPointsButton": "Adjust Points in Bulk",
    "bulkAdjustPointsSuccess": "{{points}} points {{action}} to {{count}} customer(s) successfully.",
    "bulkAdjustPointsAdded": "added",
    "bulkAdjustPointsSubtracted": "subtracted",
    "bulkAdjustPointsError": "Could not adjust points: {{error}}",
    "bulkAdjustPointsErrorNoneSelected": "Unexpected error: No customers selected."
  },
  "benefits": {
    "pointsMultiplier": "x{{value}} Points Multiplier",
    "exclusiveRewardAccess": "Exclusive Reward: {{value}}",
    "customBenefit": "{{value}}"
  },
  "superAdminPage": {
    "title": "Super Admin Panel",
    "searchPlaceholder": "Search businesses by name or slug...",
    "tableHeaderBusiness": "Business",
    "tableHeaderStatus": "General Status",
    "tableHeaderLoyalty": "Loyalty",
    "tableHeaderCamarero": "Waiter",
    "tableHeaderRegistered": "Registered",
    "noBusinesses": "No businesses registered.",
    "tooltipActivateBusiness": "Activate business",
    "tooltipDeactivateBusiness": "Deactivate business",
    "moduleLoyaltyCoreTooltip": "Activate/Deactivate Loyalty Module (LoyalPyME Core)",
    "moduleCamareroTooltip": "Activate/Deactivate Waiter Module",
    "statusChangeSuccess": "Business '{{businessName}}' status changed to {{status}}.",
    "statusChangeError": "Error changing business status.",
    "moduleChangeSuccess": "Module '{{moduleName}}' {{status}} for business '{{businessName}}'.",
    "moduleChangeError": "Error changing module '{{moduleName}}' status.",
    "moduleLoyaltyCore": "LoyalPyME Core",
    "moduleCamarero": "LoyalPyME Waiter",
    "businessFallbackName": "the business",
    "statusPaid": "Up to date",
    "statusPending": "Pending",
    "statusOverdue": "Overdue",
    "filterAll": "All",
    "manageSubscriptionTooltip": "Manage Subscription and Payments",
    "impersonateTooltip": "Log in as this administrator",
    "tableHeaderPrice": "Price/month",
    "tableHeaderPaymentStatus": "Payment Status"
  },
  "adminCamarero": {
    "manageMenu": "Manage Menu",
    "manageTables": "Manage Tables",
    "cardMenuTitle": "Digital Menu",
    "cardMenuDesc": "Create and edit your menu's products, categories, and modifiers.",
    "cardMenuButton": "Manage Menu",
    "manageMenu.title": "Digital Menu Management",
    "manageMenu.categoriesSectionTitle": "Menu Categories",
    "manageMenu.categoryManagerPlaceholder": "Category Manager will go here...",
    "manageMenu.itemsSectionTitle": "Menu Items",
    "manageMenu.itemManagerPlaceholder": "Item Manager (by category) will go here...",
    "manageMenu.editCategoryTitle": "Edit Category",
    "manageMenu.addCategoryTitle": "Add New Category",
    "manageMenu.categoryNameEsPlaceholder": "E.g.: Starters, Desserts...",
    "manageMenu.categoryNameEnPlaceholder": "E.g.: Starters, Desserts...",
    "manageMenu.categoryDescEsPlaceholder": "Description in Spanish (optional)",
    "manageMenu.categoryDescEnPlaceholder": "Description in English (optional)",
    "manageMenu.categoryImagePreviewAlt": "Category image preview",
    "manageMenu.uploadImageButton": "Upload selected image",
    "manageMenu.categoryPositionLabel": "Position (Order)",
    "manageMenu.categoryPositionPlaceholder": "E.g.: 1, 2, 3...",
    "manageMenu.categoryPositionDesc": "Number for ordering (0 or greater). Lower appears first.",
    "manageMenu.categoryActiveLabel": "Active Category",
    "manageMenu.categoryActiveDesc": "If inactive, it will not be shown to customers.",
    "manageMenu.categoryCreateSuccess": "Category '{{name}}' created successfully.",
    "manageMenu.categoryUpdateSuccess": "Category '{{name}}' updated successfully.",
    "manageMenu.categoryDeleteSuccess": "Category deleted successfully.",
    "manageMenu.pendingImageUpload": "Please upload the selected image or remove it before saving.",
    "manageMenu.category": "Category",
    "manageMenu.item": "Item",
    "manageMenu.itemLabel": "Item",
    "manageMenu.editItemTitle": "Edit Item",
    "manageMenu.addItemTitle": "Add New Item",
    "manageMenu.itemNameEsPlaceholder": "E.g.: Classic Burger",
    "manageMenu.itemNameEnPlaceholder": "E.g.: Classic Burger",
    "manageMenu.itemDescEsPlaceholder": "Detailed description in Spanish...",
    "manageMenu.itemDescEnPlaceholder": "Detailed description in English...",
    "manageMenu.itemPrice": "Price",
    "manageMenu.itemAllergens": "Allergens",
    "manageMenu.itemAllergensPlaceholder": "Select or type allergens",
    "manageMenu.itemTags": "Tags",
    "manageMenu.itemTagsPlaceholder": "Select or type tags",
    "manageMenu.itemPosition": "Position",
    "manageMenu.itemPrepTime": "Prep Time (min)",
    "manageMenu.itemCalories": "Calories (kcal)",
    "manageMenu.itemSku": "SKU / Ref.",
    "manageMenu.itemKds": "KDS Destination",
    "manageMenu.itemKdsPlaceholder": "E.g.: Kitchen, Bar",
    "manageMenu.itemKdsDesc": "For kitchen/bar display systems (optional)",
    "manageMenu.itemIsAvailable": "Item Available",
    "manageMenu.itemIsAvailableDesc": "If unavailable, it will not be shown to customers.",
    "manageMenu.modifierGroupsTitle": "Modifier Groups",
    "manageMenu.manageGroupsButton": "Manage Groups",
    "manageMenu.modifierGroupsDescription": "Define option groups to customize this item (e.g.: Size, Extras, Sauces).",
    "manageMenu.itemCreateSuccess": "Item '{{name}}' created successfully.",
    "manageMenu.itemUpdateSuccess": "Item '{{name}}' updated successfully.",
    "manageMenu.itemDeleteSuccess": "Item deleted successfully.",
    "manageMenu.itemFallbackName": "Item",
    "manageMenu.itemNew": "New Item",
    "manageMenu.noItemsInCategory": "No items in this category yet.",
    "manageMenu.itemImageLabel": "Item Image",
    "manageMenu.itemAvailability": "Availability",
    "manageMenu.itemAvailable": "Available",
    "manageMenu.itemNotAvailable": "Not Available",
    "manageMenu.markAvailable": "Mark Available",
    "manageMenu.markNotAvailable": "Mark Not Available",
    "manageMenu.manageModifiersTooltip": "Manage Modifiers",
    "manageMenu.viewItemsTooltip": "View/Manage Items in this Category",
    "manageMenu.previewButton": "Preview Public Menu",
    "manageMenu.previewErrorNoSlug": "Could not get business identifier for preview.",
    "manageMenu.previewDisabledTooltip": "Business identifier unavailable for preview.",
    "manageMenu.toCategories": "to Categories",
    "manageMenu.modifierGroupCreateSuccess": "Group '{{name}}' created successfully.",
    "manageMenu.modifierGroupUpdateSuccess": "Group '{{name}}' updated successfully.",
    "manageMenu.modifierGroupDeleteSuccess": "Modifier group deleted successfully.",
    "menuCategoryForm": {
      "errorInvalidCropOrImage": "Invalid crop or image.",
      "errorUploadingWithDetail": "Error uploading: {{error}}",
      "altPreview": "Category preview",
      "altCropImage": "Image to crop",
      "imageUploadSuccess": "Category image uploaded successfully.",
      "errorCreatingCroppedFile": "Could not create cropped category image file.",
      "errorApiNoUrl": "API did not return a valid URL for the category image.",
      "imageUploadError": "Could not upload category image: {{error}}"
    },
    "menuItemForm": {
      "errorInvalidCropOrImage": "Invalid crop or image.",
      "errorCreatingCroppedFile": "Could not create cropped item image file.",
      "imageUploadSuccess": "Item image uploaded successfully.",
      "errorApiNoUrl": "API did not return a valid URL for the item image.",
      "errorUploadingWithDetail": "Error uploading item image: {{error}}",
      "imageUploadError": "Could not upload item image: {{error}}",
      "altPreview": "Item preview",
      "altCropImage": "Item image to crop"
    },
    "menuItem": {
      "allergen.GLUTEN": "Gluten",
      "allergen.LACTOSE": "Lactose",
      "allergen.NUTS": "Nuts",
      "allergen.SOY": "Soy",
      "allergen.FISH": "Fish",
      "allergen.CRUSTACEANS": "Crustaceans",
      "allergen.CELERY": "Celery",
      "allergen.MUSTARD": "Mustard",
      "allergen.SESAME": "Sesame",
      "allergen.SULPHITES": "Sulphites",
      "allergen.LUPIN": "Lupin",
      "allergen.MOLLUSCS": "Molluscs",
      "tag.VEGAN": "Vegan",
      "tag.VEGETARIAN": "Vegetarian",
      "tag.SPICY": "Spicy",
      "tag.NEW": "New",
      "tag.POPULAR": "Popular",
      "tag.HOUSE_SPECIAL": "House Special"
    },
    "modifierGroupsModal": {
      "title": "Manage Modifier Groups for: \"{{itemName}}\"",
      "existingGroupsTitle": "Existing Groups",
      "createNewGroupButton": "Create New Group",
      "noGroupsForItem": "No modifier groups for this item.",
      "tableHeaderName": "Name",
      "tableHeaderUiType": "UI Type",
      "tableHeaderSelections": "Selections (Min-Max)",
      "tableHeaderRequired": "Required",
      "tableHeaderPosition": "Position",
      "tooltipManageOptions": "Manage Options",
      "tooltipEditGroup": "Edit Group",
      "tooltipDeleteGroup": "Delete Group",
      "formEditTitle": "Editing Group: {{groupName}}",
      "formCreateTitle": "Create New Modifier Group",
      "formCreateButton": "Create Group",
      "closeButton": "Close Group Management"
    },
    "modifierGroupForm": {
      "nameEsLabel": "Name (ES)",
      "nameEnLabel": "Name (EN)",
      "uiTypeLabel": "User Interface (UI) Type",
      "uiType.RADIO": "Single Option (Radio)",
      "uiType.CHECKBOX": "Multiple Options (Checkbox)",
      "minSelectionsLabel": "Minimum Selections",
      "maxSelectionsLabel": "Maximum Selections",
      "positionLabel": "Position (Order)",
      "isRequiredLabel": "Is Required",
      "validation": {
        "nameEsRequired": "Name in Spanish is required.",
        "uiTypeInvalid": "Select a valid UI type.",
        "minSelectionsInvalid": "Minimum selections must be 0 or more.",
        "maxSelectionsInvalid": "Maximum selections must be 1 or more.",
        "minMaxMismatch": "Minimum selections cannot be greater than maximum."
      }
    },
    "modifierOptionsModal": {
      "title": "Options for Group: \"{{groupName}}\"",
      "existingOptionsTitle": "Existing Options",
      "createNewOptionButton": "Create New Option",
      "noOptionsForGroup": "No options for this group.",
      "tableHeaderName": "Name",
      "tableHeaderPriceAdjustment": "Price Adjustment",
      "tableHeaderPosition": "Position",
      "tableHeaderDefault": "Default",
      "tableHeaderAvailable": "Available",
      "formEditTitle": "Editing Option: {{optionName}}",
      "formCreateTitle": "Create New Modifier Option",
      "formCreateButton": "Create Option",
      "closeButton": "Close Option Management"
    },
    "modifierOptionForm": {
      "nameEsLabel": "Name (ES)",
      "nameEnLabel": "Name (EN)",
      "priceAdjustmentLabel": "Price Adjustment (‚Ç¨)",
      "priceAdjustmentDescription": "Positive to increase, negative to decrease, 0 for no change.",
      "positionLabel": "Position (Order)",
      "isDefaultLabel": "Selected by Default",
      "isAvailableLabel": "Option Available",
      "validation": {
        "nameEsRequired": "Name in Spanish is required."
      }
    },
    "modifierOption": {
      "statusAvailable": "Available",
      "statusNotAvailable": "Not Avail.",
      "tooltipEditOption": "Edit Option",
      "tooltipMarkAvailable": "Mark Available",
      "tooltipMarkNotAvailable": "Mark Not Available",
      "tooltipDeleteOption": "Delete Option"
    },
    "modifierGroupHook": {
      "errorNoMenuItemForGroup": "Error: Cannot add a group without an associated menu item.",
      "fallbackGroupName": "Group",
      "createSuccess": "Group '{{name}}' created successfully.",
      "updateSuccess": "Group '{{name}}' updated successfully.",
      "deleteSuccess": "Modifier group deleted successfully."
    },
    "modifierOptionHook": {
      "errorLoadingOptions": "Error loading modifier options.",
      "errorNoGroupForOption": "Cannot add an option without an associated modifier group.",
      "createSuccess": "Option \"{{optionName}}\" created successfully.",
      "fallbackOptionName": "Option",
      "errorCreatingOption": "Error creating option.",
      "updateSuccess": "Option \"{{optionName}}\" updated successfully.",
      "errorUpdatingOption": "Error updating option.",
      "deleteSuccess": "Modifier option deleted successfully.",
      "errorDeletingOption": "Error deleting option."
    },
    "menuItemHook": {
      "errorNoCategoryForItem": "Cannot add an item without a selected category."
    }
  },
  "publicMenu": {
    "unnamedItem": "Unnamed Item",
    "unnamedCategory": "Unnamed Category",
    "noCategories": "No menu categories available.",
    "noItemsInCategory": "No items in this category.",
    "menuNotAvailable": "Menu not available or not found.",
    "customizeButton": "Customize",
    "optionsTitle": "Customize your choice:",
    "itemNotesLabel": "Notes for this item (optional)",
    "itemNotesPlaceholder": "E.g.: No onion, extra spicy...",
    "quantity": "Quantity",
    "confirmAndAddToCart": "Confirm and Add to Cart",
    "customizeAndAdd": "Customize and Add",
    "addToCart": "Add to Cart",
    "itemAddedTitle": "Added!",
    "itemAddedMessage": "{{itemName}} (x{{quantity}}) added to cart.",
    "invalidSelectionTitle": "Invalid Selection",
    "invalidSelectionMsg": "Please complete all required modifier options.",
    "modifier.chooseOneRequired": "Choose 1 (required)",
    "modifier.chooseMinUpToMax_required": "Choose from {{min}} to {{max}} (required)",
    "modifier.chooseUpToMaxOptional": "Choose up to {{max}} (optional)",
    "modifier.chooseOneOptional": "Choose 1 (optional)",
    "modifier.chooseOptional": "Optional",
    "modifier.chooseAtLeastOneUpToMax_required": "Choose at least 1 up to {{max}} (required)",
    "cart": {
      "title": "Your Order",
      "total": "Total",
      "empty": "Your order cart is empty.",
      "itemNotesLabel": "Notes:",
      "removeItem": "Remove item",
      "orderNotesLabel": "Notes for the Order (Optional)",
      "orderNotesPlaceholder": "E.g.: General allergies, delivery preference...",
      "totalOrder": "Order Total:",
      "continueShopping": "Continue Shopping",
      "submitOrder": "Submit Order",
      "viewOrderItems_one": "View your order ({{count}} item)",
      "viewOrderItems_other": "View your order ({{count}} items)",
      "decreaseQuantity": "Decrease quantity of {{itemName}}",
      "itemQuantity": "Quantity for {{itemName}}",
      "increaseQuantity": "Increase quantity of {{itemName}}",
      "removeItemFromOrder": "Remove {{itemName}} from order",
      "errorTitle": "Order Error",
      "errorEmpty": "Your cart is empty. Add some items before submitting.",
      "orderSuccessTitle": "Order Submitted!",
      "orderSuccessMsg": "Your order #{{orderNumber}} has been received and is being prepared.",
      "orderErrorTitle": "Error Submitting",
      "orderErrorMsg": "Could not submit your order. Please try again or contact staff.",
      "clearCartButton": "Clear Cart",
      "clearedTitle": "Cart Cleared",
      "clearedMsg": "All items have been removed from your order.",
      "titleAddToOrder": "Add to Order #{{orderNumber}}",
      "submitAddToOrder": "Add to Order",
      "emptyAddToOrder": "Select items to add to your order.",
      "totalAddItems": "Total to Add:",
      "addItemsToOrderButton": "Add {{count}} items to Order #{{orderNumber}}",
      "itemsAddedSuccessTitle": "Items Added",
      "itemsAddedSuccessMsg": "Items added to order #{{orderNumber}}.",
      "addItemsErrorTitle": "Error Adding Items",
      "redeemedItemBadge": "Reward",
      "rewardsSectionTitle": "My Rewards",
      "applyRewardButton": "View and Apply Rewards",
      "discountApplied": "Discount:",
      "subtotal": "Subtotal"
    },
    "unnamedModifier": "Unnamed Modifier",
    "activeOrder": {
      "addingToOrderTitle": "Adding to Order #{{orderNumber}}",
      "addingToOrderMsg": "New items will be added to your ongoing order.",
      "viewStatusButton": "View Order Status",
      "cannotAddTitle": "Cannot add items to Order #{{orderNumber}}",
      "cannotAddMsg": "The order no longer accepts new items. Please start a new order.",
      "startNewButton": "Start New Order",
      "startNewButtonAlt": "Create New Order"
    }
  },
  "error": {
    "missingBusinessSlug": "Error: Business slug not provided.",
    "noMenuDataReceived": "No menu data received."
  },
  "orderStatusPage": {
    "title": "Your Order Status",
    "error": {
      "missingOrderId": "Order ID not specified.",
      "noData": "No order status data received.",
      "notFound": "Order not found or unavailable.",
      "updateFailed": "Could not update status: {{message}}"
    },
    "generalStatus": "General Status:",
    "table": "Table:",
    "placedAt": "Placed at:",
    "itemsTitle": "Order Items",
    "quantity": "Quantity:",
    "orderNotesLabel": "General Order Notes",
    "refreshButton": "Refresh Status",
    "backToMenuButton": "Back to Menu",
    "addMoreItemsButton": "Add More Items",
    "requestBillButton": "Request Bill",
    "billRequestedSuccess": "Bill requested. A waiter will be with you shortly.",
    "errorRequestingBill": "Error requesting bill: {{message}}",
    "paidSuccessMessage": "Order Paid! Thank you for your visit.",
    "itemStatus": {
      "pending_kds": "Received in kitchen",
      "preparing": "Preparing",
      "ready": "Ready to serve",
      "served": "Served",
      "cancelled": "Cancelled",
      "cancellation_requested": "Cancellation Requested"
    },
    "orderStatus": {
      "received": "Received",
      "in_progress": "In Progress",
      "partially_ready": "Partially Ready",
      "all_items_ready": "All Items Ready",
      "completed": "Completed",
      "pending_payment": "Pending Payment",
      "paid": "Paid",
      "cancelled": "Cancelled",
      "payment_failed": "Payment Failed"
    },
    "kdsPage": {
      "title": "Kitchen Display System (KDS)",
      "destination": {
        "kitchen": "KITCHEN",
        "bar": "BAR"
      },
      "unknownItem": "Unknown Item",
      "noItems": "No pending items for this destination.",
      "quantity": "Quantity",
      "notes": "Notes",
      "noTable": "No Table",
      "createdAt": "KDS Received",
      "modifiers": "Modifiers:",
      "statusUpdateSuccessTitle": "Status Updated",
      "statusUpdateSuccessMsg": "Item \"{{itemName}}\" updated to {{status}}.",
      "statusUpdateErrorMsg": "Error updating item status.",
      "updateInProgressTitle": "Update in Progress",
      "updateInProgressMsg": "Wait for the current action to finish before starting another.",
      "refreshManual": "Refresh Manually",
      "action": {
        "startPreparing": "Start Preparing",
        "markReady": "Mark as Ready",
        "cancelItem": "Cancel Item"
      }
    }
  },
  "waiterInterface": {
    "pickupPageTitle": "Orders Ready for Pickup and Serving",
    "noItemsReady": "No items ready for pickup at this time.",
    "orderNumber": "Order",
    "pickupFrom": "Pick up from",
    "markAsServedButton": "Mark as Served",
    "actionInProgress": "Please wait for the current action to complete.",
    "itemMarkedServedSuccess": "Item '{{itemName}}' marked as served.",
    "errorMarkingServed": "Error marking item as served.",
    "navLinkPickup": "Pickup Orders"
  },
  "homePage": {
    "welcomeTitle": "Welcome to LoyalPyME",
    "heroTitle": "Engage Customers and Digitize Your Service. All in One Place.",
    "heroSubtitle": "LoyalPyME is the ultimate platform for restaurants, cafes, and SMEs to create loyalty programs and optimize their operations with a smart digital menu.",
    "ctaBusiness": "Create Business Account",
    "ctaLogin": "I already have an account",
    "featuresSection": {
      "superTitle": "Power Up Your Business",
      "title": "One Solution, Multiple Benefits"
    },
    "features": {
      "loyalty": {
        "title": "Loyalty Programs",
        "desc": "Create a points and tiers system to keep your customers coming back. Reward their loyalty with exclusive products and benefits."
      },
      "waiter": {
        "title": "Digital Waiter Module",
        "desc": "Digitize your menu, allow customers to order from their phones, and streamline communication with the kitchen through our KDS system."
      },
      "synergy": {
        "title": "Total Synergy",
        "desc": "When a customer orders from the digital menu, they automatically earn points! The two modules work together to maximize engagement and sales."
      }
    },
    "finalCta": {
      "title": "Ready to get started?",
      "desc": "Create your account today and discover how LoyalPyME can transform your business."
    }
  },
  "waiterOrderManagement": {
    "title": "Floor Order Management",
    "filterStatusLabel": "Filter by Status:",
    "statusOptionAll": "All Orders",
    "statusOptionPendingPayment": "Pending Payment",
    "statusOptionCompleted": "Completed (Not Paid)",
    "statusOptionPaid": "Paid",
    "noOrdersFound": "No orders found with the current filters.",
    "tableHeaderOrderNum": "Order #",
    "tableHeaderTable": "Table",
    "tableHeaderTotal": "Total",
    "tableHeaderStatus": "Status",
    "tableHeaderActions": "Actions",
    "buttonMarkAsPaid": "Mark As Paid",
    "buttonRequestBill": "Request Bill",
    "confirmMarkAsPaidTitle": "Confirm Payment",
    "confirmMarkAsPaidMessage": "Do you confirm that order #{{orderNumber}} has been paid?",
    "markAsPaidSuccess": "Order #{{orderNumber}} marked as paid.",
    "markAsPaidError": "Error marking order #{{orderNumber}} as paid: {{error}}",
    "paymentDetailsModalTitle": "Record Payment Details for Order #{{orderNumber}}",
    "paymentMethodLabel": "Payment Method",
    "paymentMethodPlaceholder": "E.g.: Cash, Visa Card",
    "paymentNotesLabel": "Payment Notes (Optional)",
    "paymentNotesPlaceholder": "Additional details...",
    "confirmPaymentButton": "Confirm Payment",
    "navLinkTitle": "Manage Orders"
  },
  "orderBillView": {
    "item": "Item",
    "price": "Price",
    "total": "Total",
    "reward": "Reward",
    "unnamedItem": "Unnamed Item",
    "subtotal": "Subtotal",
    "discount": "Discount",
    "finalTotal": "TOTAL TO PAY"
  },
  "applyRewardModal": {
    "title": "Apply Your Rewards",
    "tabs": {
      "coupons": "My Coupons",
      "redeem": "Redeem with Points"
    },
    "noCoupons": "You don't have any available coupons to use.",
    "noRewardsInCatalog": "There are no rewards in the catalog.",
    "summary": {
      "totalCost": "Total cost of selection:",
      "availablePoints": "Available points: {{points}}",
      "pointsBadge": "{{points}} Points"
    },
    "notEnoughPoints": "You don't have enough points for this selection.",
    "applyButton": "Apply to Order",
    "success": {
      "title": "Success!",
      "message": "The rewards have been successfully applied to your order."
    }
  },
  "orderDetailModal": {
    "title": "Order Details",
    "viewTooltip": "View Details",
    "headerOrder": "Order #",
    "headerDate": "Date",
    "headerTotal": "Total",
    "downloadPdf": "Download PDF",
    "sendByEmail": "Send by Email"
  },
  "profileForm": {
    "noChanges": "No changes to save.",
    "updateSuccess": "Profile updated successfully.",
    "updateError": "Error updating profile."
  }
}


// ====== [131] frontend/public/locales/es/translation.json ======
{
  "common": {
    "loading": "Cargando...",
    "save": "Guardar",
    "cancel": "Cancelar",
    "delete": "Eliminar",
    "edit": "Editar",
    "add": "A√±adir",
    "confirm": "Confirmar",
    "close": "Cerrar",
    "error": "Error",
    "success": "√âxito",
    "requiredField": "Este campo es obligatorio.",
    "back": "Volver",
    "actions": "Acciones",
    "status": "Estado",
    "active": "Activo",
    "inactive": "Inactivo",
    "name": "Nombre",
    "description": "Descripci√≥n",
    "points": "Puntos",
    "level": "Nivel",
    "email": "Email",
    "registered": "Registrado",
    "yes": "S√≠",
    "no": "No",
    "searchPlaceholder": "Buscar...",
    "noResults": "No se encontraron resultados.",
    "selectPlaceholder": "Selecciona uno",
    "optional": "Opcional",
    "confirmAction": "Confirmar Acci√≥n",
    "noItems": "No hay elementos definidos todav√≠a.",
    "errorLoadingData": "Error al cargar datos",
    "info": "Informaci√≥n",
    "errorUnknown": "Error desconocido",
    "invalidDate": "Fecha inv√°lida",
    "upcomingFeatureTitle": "Pr√≥ximamente",
    "deleting": "Eliminando...",
    "customer": "Cliente",
    "selected": "seleccionado",
    "errorImageTooSmall": "La imagen es demasiado peque√±a. Debe ser al menos {{minSize}}x{{minSize}} p√≠xeles.",
    "errorMustBePositiveOrZero": "Debe ser un n√∫mero igual o mayor que 0.",
    "nameNotAvailable": "(Sin nombre)",
    "saveChanges": "Guardar Cambios",
    "camera": "C√°mara",
    "item": "√çtem"
  },
  "validation": {
    "cannotBeZero": "La cantidad no puede ser cero.",
    "benefitTypeRequired": "Selecciona un tipo de beneficio v√°lido.",
    "nameRequired": "El nombre es obligatorio.",
    "levelMin0": "El nivel debe ser 0 o mayor.",
    "minValueMin0": "El valor m√≠nimo debe ser 0 o mayor.",
    "mustBePositive": "Debe ser > 0",
    "invalidUrl": "URL de imagen no v√°lida."
  },
  "loginPage": {
    "title": "Iniciar Sesi√≥n",
    "subtitle": "¬øNo tienes cuenta?",
    "registerLink": "Reg√≠strate aqu√≠",
    "forgotPasswordLink": "¬øHas olvidado tu contrase√±a?",
    "emailLabel": "Email",
    "emailPlaceholder": "tu@email.com",
    "passwordLabel": "Contrase√±a",
    "passwordPlaceholder": "Tu contrase√±a",
    "loginButton": "Iniciar Sesi√≥n",
    "errorCredentials": "Credenciales inv√°lidas.",
    "errorServer": "Error del servidor durante el inicio de sesi√≥n.",
    "errorUnknown": "Ocurri√≥ un error inesperado.",
    "accessMenuDirectlyTitle": "¬øConoces el identificador del negocio?",
    "businessSlugPlaceholder": "Identificador del negocio (slug)",
    "goToMenuButton": "Ver Men√∫"
  },
  "registerPage": {
    "welcomeTitle": "¬°Bienvenido a LoyalPyME!",
    "title": "Crea tu Cuenta de Cliente",
    "subtitle": "¬øYa tienes cuenta?",
    "loginLink": "Inicia sesi√≥n",
    "emailLabel": "Email",
    "passwordLabel": "Contrase√±a",
    "confirmPasswordLabel": "Confirmar Contrase√±a",
    "nameLabel": "Nombre (Opcional)",
    "phoneLabel": "Tel√©fono (formato internacional)",
    "docTypeLabel": "Tipo de Documento",
    "docIdLabel": "N√∫mero de Documento",
    "businessLabel": "Negocio al que Unirse",
    "registerButton": "Registrarse",
    "errorLoadingBusinesses": "No se pudo cargar la lista de negocios.",
    "errorPasswordsDontMatch": "Las contrase√±as no coinciden.",
    "errorRegistration": "Error durante el registro.",
    "emailPlaceholder": "tu@email.com",
    "passwordPlaceholder": "Crea una contrase√±a",
    "confirmPasswordPlaceholder": "Repite la contrase√±a",
    "namePlaceholder": "Tu nombre y apellidos",
    "phonePlaceholder": "+346...",
    "docTypePlaceholder": "Selecciona uno",
    "docIdPlaceholder": "DNI, NIE, Pasaporte...",
    "businessSelectLoading": "Cargando negocios...",
    "businessSelectPlaceholder": "Selecciona un negocio",
    "businessSelectNotFound": "No hay negocios disponibles",
    "businessSelectError": "Error al cargar",
    "errorInvalidEmail": "Formato de email inv√°lido.",
    "errorPasswordLength": "La contrase√±a debe tener al menos 6 caracteres.",
    "errorConfirmPassword": "Confirma la contrase√±a.",
    "errorPhoneFormat": "Formato inv√°lido (ej: +346...).",
    "errorDocType": "Selecciona un tipo de documento.",
    "errorDNIFormat": "Formato DNI inv√°lido (8 n√∫meros y 1 letra).",
    "errorNIEFormat": "Formato NIE inv√°lido (letra, 7 n√∫meros, letra).",
    "errorBusinessRequired": "Debes seleccionar un negocio.",
    "successMessage": "Tu cuenta ha sido creada. Ser√°s redirigido a la p√°gina de inicio de sesi√≥n."
  },
  "forgotPasswordPage": {
    "title": "Restablecer Contrase√±a",
    "subtitle": "¬øRecuerdas tu contrase√±a?",
    "loginLink": "Volver a Inicio de Sesi√≥n",
    "instructions": "Introduce tu direcci√≥n de email y te enviaremos (o mostraremos en la consola del backend) un enlace para restablecer tu contrase√±a.",
    "emailLabel": "Email Registrado",
    "emailPlaceholder": "tu@email.com",
    "buttonText": "Solicitar Reseteo",
    "successTitle": "Solicitud Enviada",
    "successMessage": "Si existe una cuenta con ese email, recibir√°s (o ver√°s en consola) un enlace para restablecer la contrase√±a. El enlace expirar√° en 1 hora.",
    "errorTitle": "Error",
    "errorMissingEmail": "Por favor, introduce tu direcci√≥n de email.",
    "errorGenericTitle": "Solicitud Procesada",
    "errorGenericMessage": "Si existe una cuenta con ese email, recibir√°s (o ver√°s en consola) un enlace para restablecer la contrase√±a."
  },
  "resetPasswordPage": {
    "title": "Establecer Nueva Contrase√±a",
    "subtitle": "Introduce tu nueva contrase√±a a continuaci√≥n.",
    "passwordLabel": "Nueva Contrase√±a",
    "passwordPlaceholder": "Introduce tu nueva contrase√±a",
    "confirmPasswordLabel": "Confirmar Nueva Contrase√±a",
    "confirmPasswordPlaceholder": "Repite la nueva contrase√±a",
    "buttonText": "Guardar Nueva Contrase√±a",
    "loginLink": "Volver a Inicio de Sesi√≥n",
    "successTitle": "¬°Contrase√±a Cambiada!",
    "successMessage": "Tu contrase√±a ha sido restablecida con √©xito. Ser√°s redirigido a Inicio de Sesi√≥n.",
    "errorTitle": "Error al Restablecer",
    "errorMissingToken": "Falta el token de reseteo. Por favor, usa el enlace enviado a tu email.",
    "errorPasswordsRequired": "Por favor, introduce y confirma la nueva contrase√±a.",
    "errorPasswordsDontMatch": "Las contrase√±as no coinciden.",
    "errorPasswordLength": "La nueva contrase√±a debe tener al menos 6 caracteres.",
    "errorInvalidToken": "Error al restablecer la contrase√±a. El token podr√≠a ser inv√°lido o haber expirado."
  },
  "registerBusinessPage": {
    "title": "Registrar Nuevo Negocio",
    "subtitle": "Crea la cuenta para tu negocio y el administrador principal.",
    "businessNameLabel": "Nombre del Negocio",
    "businessNamePlaceholder": "Mi Cafeter√≠a Estupenda",
    "adminNameLabel": "Tu Nombre (Admin)",
    "adminNamePlaceholder": "Juan P√©rez",
    "adminEmailLabel": "Tu Email (Admin)",
    "adminEmailPlaceholder": "juan.perez@micafeteria.com",
    "adminPasswordLabel": "Contrase√±a (Admin)",
    "adminPasswordPlaceholder": "Tu contrase√±a",
    "confirmPasswordLabel": "Confirmar Contrase√±a",
    "confirmPasswordPlaceholder": "Repite tu contrase√±a",
    "registerButton": "Registrar Negocio",
    "loginLink": "Iniciar sesi√≥n",
    "loginLinkSubtitle": "¬øYa tienes una cuenta?",
    "successTitle": "¬°Registro Exitoso!",
    "successMessage": "El negocio '{{businessName}}' y el administrador {{adminEmail}} se han creado correctamente.",
    "errorTitle": "Error en el Registro",
    "errorRegistration": "No se pudo completar el registro. Int√©ntalo de nuevo.",
    "errorBusinessNameLength": "El nombre del negocio debe tener al menos 2 caracteres",
    "errorAdminEmailInvalid": "Email inv√°lido",
    "errorAdminPasswordLength": "La contrase√±a debe tener al menos 6 caracteres",
    "errorConfirmPasswordLength": "La confirmaci√≥n de contrase√±a debe tener al menos 6 caracteres",
    "errorPasswordsDontMatch": "Las contrase√±as no coinciden"
  },
  "header": {
    "greeting": "Hola, {{name}}!",
    "logoutButton": "Cerrar Sesi√≥n",
    "languageLabel": "Idioma",
    "toggleNavigation": "Alternar navegaci√≥n"
  },
  "customerDashboard": {
    "title": "Panel de Cliente",
    "points": "Puntos",
    "currentTier": "Nivel Actual:",
    "baseTier": "B√°sico",
    "validateQrSectionTitle": "Validar C√≥digo QR",
    "qrInputLabel": "Introduce el c√≥digo del ticket/QR",
    "qrInputPlaceholder": "Pega el c√≥digo aqu√≠...",
    "validateButton": "Validar C√≥digo",
    "scanButton": "Escanear QR",
    "scanModalTitle": "Escanear C√≥digo QR",
    "scanInstructions": "Apunta la c√°mara al c√≥digo QR",
    "scanCancelButton": "Cancelar Escaneo",
    "scanButtonDisabledTooltip": "Escanear QR solo disponible en m√≥vil",
    "rewardsSectionTitle": "Recompensas y Regalos",
    "noRewardsAvailable": "No hay recompensas ni regalos disponibles en este momento.",
    "redeemGiftButton": "Canjear Regalo",
    "redeemRewardButton": "Canjear Recompensa",
    "insufficientPoints": "Puntos insuficientes",
    "giftFree": "Gratis",
    "giftAssignedBy": "Regalado por {{assigner}} el {{date}}",
    "giftInfo": "Info",
    "errorLoadingProfile": "Error al cargar tu perfil: {{error}}",
    "errorLoadingRewards": "No se pudieron cargar las recompensas o regalos. {{error}}",
    "errorScanningQr": "Error de Esc√°ner",
    "errorScanningQrDefault": "No se pudo iniciar la c√°mara: {{error}}",
    "validating": "Validando...",
    "errorValidatingQr": "Error de Validaci√≥n",
    "errorValidatingQrMessage": "Error desconocido al validar QR.",
    "successQrValidation": "C√≥digo QR validado con √©xito. Has ganado {{points}} puntos.",
    "errorRedeemTitle": "Error al Canjear",
    "errorRedeemMessage": "Error desconocido al canjear.",
    "successRedeemRewardTitle": "¬°Recompensa Canjeada!",
    "successRedeemRewardMessage": "Has canjeado tu recompensa.",
    "successRedeemGiftTitle": "¬°Regalo Canjeado!",
    "successRedeemGiftMessage": "Has canjeado \"{{rewardName}}\".",
    "errorLoadingProfileTitle": "Error de Perfil",
    "errorLoadingProfileDefault": "No se pudieron cargar los datos del usuario.",
    "noUserDataError": "No se pudieron cargar los datos del usuario.",
    "tierBenefitsTitle": "Beneficios del Nivel: {{tierName}}",
    "progressUnitVisits": "visitas",
    "progressLabel": "{{currentValue}} / {{targetValue}} {{unit}} para alcanzar {{nextTierName}}",
    "maxLevelReached": "¬°Felicidades! Has alcanzado el nivel m√°ximo ({currentTierName}).",
    "maxLevelReachedShort": "¬°Nivel M√°ximo!",
    "nextTierBenefitsTitle": "Al alcanzar {{tierName}} tendr√°s:",
    "errorLoadingProgress": "No se pudieron cargar los datos de niveles para mostrar el progreso.",
    "tabSummary": "Resumen",
    "tabRewards": "Recompensas",
    "tabActivity": "Mi Actividad",
    "tabOffers": "Ofertas y Noticias",
    "tabProfile": "Mi Perfil",
    "tabHistory": "Mis Pedidos",
    "summary": {
      "pendingGifts_one": "Tienes {{count}} regalo pendiente:",
      "pendingGifts_other": "Tienes {{count}} regalos pendientes:",
      "pendingGiftsDesc": "Tienes regalos esperando ser canjeados.",
      "nextReward": "Pr√≥xima recompensa: {{name}} por {{points}} puntos.",
      "viewAllButton": "Ver Todas las Recompensas y Regalos",
      "noRewardsInfo": "Acumula m√°s puntos para conseguir recompensas.",
      "giftsAndRewardsTitle": "Regalos y Recompensas Disponibles:",
      "rewardsTitle": "Recompensas Disponibles:",
      "unknownAssigner": "Desconocido",
      "redeemButton": "Canjear",
      "viewAllButtonShort": "Ver Todo",
      "viewMenuFor": "Ver Men√∫ de {{businessName}}",
      "viewMenuDefaultTitle": "Ver la Carta y Pedir",
      "viewMenuSubtitle": "Accede al men√∫ digital y haz tu pedido.",
      "viewMenuButton": "Ir a la Carta"
    },
    "activityTab": {
      "noActivity": "A√∫n no tienes actividad registrada.",
      "type_POINTS_EARNED_QR": "Puntos Ganados (QR)",
      "type_POINTS_REDEEMED_REWARD": "Recompensa Canjeada",
      "type_GIFT_REDEEMED": "Regalo Canjeado",
      "type_POINTS_ADJUSTED_ADMIN": "Ajuste Manual de Puntos",
      "totalItems": "{{count}} registro(s) en total",
      "desc_EARNED": "Puntos por ticket #{{ticketNumber}}",
      "desc_REDEEMED": "Canje: {{rewardName}}",
      "desc_GIFT": "Regalo canjeado: {{rewardName}}",
      "desc_ADJUSTED": "Ajuste manual de puntos",
      "desc_ADJUSTED_REASON": "Ajuste manual: {{reason}}"
    },
    "rewards": {
      "affordable": "Asequible"
    },
    "historyTab": {
      "title": "Mi Historial de Pedidos",
      "noOrders": "A√∫n no tienes pedidos registrados.",
      "totalOrders": "{{count}} pedido(s) en total"
    },
    "noAvailableCoupons": "No tienes cupones disponibles. ¬°Canjea tus puntos en el cat√°logo para obtenerlos!",
    "couponExpires": "Caduca el:",
    "availableCouponsTitle": "Mis Cupones Disponibles",
    "rewardsCatalogTitle": "Cat√°logo de Recompensas",
    "giftsSectionTitle": "Regalos Recibidos",
    "acquireRewardButton": "Obtener por {{count}} Puntos",
    "acquireRewardSuccessTitle": "¬°Recompensa Adquirida!",
    "acquireRewardSuccessMessage": "La recompensa ahora est√° disponible en 'Mis Cupones' para usarla cuando quieras.",
    "acquireRewardError": "No se pudo adquirir la recompensa.",
    "errorAcquireTitle": "Error al Adquirir",
    "errorRedeemGiftMessage": "No se pudo canjear el regalo."
  },
  "adminCommon": {
    "dashboard": "Dashboard",
    "rewards": "Recompensas",
    "generateQr": "Generar QR",
    "customers": "Clientes",
    "manageTiers": "Gestionar Niveles",
    "tierSettings": "Config. Niveles",
    "saveSuccess": "Guardado con √©xito",
    "updateSuccess": "Actualizado con √©xito",
    "createSuccess": "Creado con √©xito",
    "deleteSuccess": "Eliminado con √©xito",
    "saveError": "Error al guardar",
    "updateError": "Error al actualizar",
    "createError": "Error al crear",
    "deleteError": "Error al eliminar",
    "confirmDeleteTitle": "Confirmar Eliminaci√≥n",
    "confirmDeleteMessage": "¬øEst√°s seguro? Esta acci√≥n no se puede deshacer.",
    "adminTitle": "LoyalPyME Admin"
  },
  "adminOverview": {
    "welcome": "¬°Bienvenido, {{name}}!",
    "panelIntro": "Est√°s en el panel de administraci√≥n de",
    "panelDescription": "Desde aqu√≠ podr√°s gestionar tu programa de fidelizaci√≥n: configura niveles, recompensas, clientes y genera c√≥digos QR.",
    "quickSummaryTitle": "Resumen R√°pido",
    "statActiveCustomers": "CLIENTES",
    "statNewCustomers": "NUEVOS (7D)",
    "statPointsIssued": "PUNTOS (7D)",
    "statRedemptions": "CANJES (7D)",
    "quickAccessTitle": "Accesos R√°pidos",
    "cardRewardsTitle": "Recompensas",
    "cardRewardsDesc": "Crea y administra las recompensas que tus clientes pueden canjear.",
    "cardRewardsButton": "Gestionar Recompensas",
    "cardTiersTitle": "Niveles Fidelizaci√≥n",
    "cardTiersDesc": "Define los diferentes niveles y beneficios para tus clientes.",
    "cardTiersButton": "Gestionar Niveles",
    "cardTierSettingsTitle": "Configuraci√≥n Niveles",
    "cardTierSettingsDesc": "Ajusta la l√≥gica de c√≥mo los clientes suben o bajan de nivel.",
    "cardTierSettingsButton": "Ajustar Configuraci√≥n",
    "cardQrTitle": "Generar QR Puntos",
    "cardQrDesc": "Crea c√≥digos QR √∫nicos para que tus clientes sumen puntos.",
    "cardQrButton": "Generar C√≥digo QR",
    "cardCustomersTitle": "Clientes",
    "cardCustomersDesc": "Consulta y gestiona la lista de tus clientes registrados.",
    "cardCustomersButton": "Gestionar Clientes",
    "errorLoadingStats": "No se pudieron cargar las estad√≠sticas.",
    "noStatsAvailable": "No hay datos estad√≠sticos disponibles.",
    "defaultBusinessName": "tu Negocio",
    "noModulesActivePrompt": "No hay m√≥dulos activos para este negocio. Act√≠valos desde el panel de Super Administrador."
  },
  "adminRewardsPage": {
    "title": "Gesti√≥n de Recompensas",
    "addButton": "A√±adir Recompensa",
    "cancelAddButton": "Cancelar A√±adir",
    "tableHeaderName": "Nombre",
    "tableHeaderCost": "Coste",
    "tableHeaderStatus": "Estado",
    "tableHeaderActions": "Acciones",
    "tooltipEdit": "Editar Recompensa",
    "tooltipDeactivate": "Desactivar",
    "tooltipActivate": "Activar",
    "tooltipDelete": "Eliminar Recompensa",
    "noRewardsYet": "A√∫n no has creado ninguna recompensa.",
    "addFormTitle": "A√±adir Nueva Recompensa",
    "editFormTitle": "Editar Recompensa",
    "confirmDeleteMessage": "¬øEst√°s seguro de que quieres eliminar la recompensa \"{{name}}\"? Esta acci√≥n no se puede deshacer.",
    "deleteSuccessMessage": "La recompensa \"{{name}}\" ha sido eliminada.",
    "deleteErrorNotFound": "No se encontr√≥ la recompensa \"{{name}}\" (quiz√°s ya fue eliminada).",
    "deleteErrorInUse": "No se puede eliminar \"{{name}}\" porque est√° en uso.",
    "toggleStatusSuccess": "La recompensa se ha {{status}} correctamente.",
    "toggleStatusError": "Error al {{status}} la recompensa: {{error}}",
    "statusActivated": "activada",
    "statusDeactivated": "desactivada",
    "updateSuccessMessage": "Recompensa \"{{name}}\" actualizada.",
    "createSuccessMessage": "Recompensa \"{{name}}\" creada."
  },
  "component": {
    "rewardForm": {
      "nameLabel": "Nombre de la Recompensa:",
      "namePlaceholder": "Ej: Caf√© Gratis",
      "descriptionLabel": "Descripci√≥n (Opcional):",
      "descriptionPlaceholder": "Ej: Un caf√© espresso o americano",
      "pointsCostLabel": "Coste en Puntos:",
      "pointsCostPlaceholder": "Ej: 100",
      "errorNameRequired": "El nombre de la recompensa no puede estar vac√≠o.",
      "errorPointsCostInvalid": "El coste en puntos debe ser un n√∫mero igual o mayor que cero.",
      "nameEsLabel": "Nombre (ES)",
      "nameEsPlaceholder": "Ej: Caf√© Gratis",
      "nameEnLabel": "Nombre (EN)",
      "nameEnPlaceholder": "E.g.: Free Coffee",
      "descriptionEsLabel": "Descripci√≥n (ES, Opcional)",
      "descriptionEsPlaceholder": "Ej: Un caf√© espresso o americano",
      "descriptionEnLabel": "Descripci√≥n (EN, Opcional)",
      "descriptionEnPlaceholder": "E.g.: One espresso or americano coffee",
      "imageLabel": "Imagen",
      "removeImageButton": "Quitar Imagen",
      "selectImageButton": "Seleccionar Imagen",
      "cropInstructions": "Recorta la imagen",
      "confirmCropButton": "Confirmar Recorte y Subir",
      "errorInvalidDataTitle": "Datos Inv√°lidos",
      "errorInvalidDataMsg": "Por favor, rellena los nombres en ambos idiomas y un coste en puntos v√°lido (0 o mayor).",
      "errorNameEsRequired": "El nombre en espa√±ol es obligatorio.",
      "errorNameEnRequired": "El nombre en ingl√©s es obligatorio.",
      "errorImageTooSmall": "La imagen es demasiado peque√±a. Debe ser al menos {{minSize}}x{{minSize}} p√≠xeles.",
      "errorInvalidCrop": "Selecci√≥n de recorte o imagen no v√°lida. Aseg√∫rate de que el recorte tiene un tama√±o.",
      "errorCreatingCroppedFile": "No se pudo crear el archivo de imagen recortada.",
      "imageUploadSuccess": "Imagen recortada y subida correctamente.",
      "errorApiNoUrl": "La API no devolvi√≥ una URL de imagen v√°lida.",
      "errorUploadingWithDetail": "Error al subir: {{error}}",
      "imageUploadError": "No se pudo subir la imagen: {{error}}",
      "errorMissingIdForUpdate": "Falta el ID de la recompensa para actualizar.",
      "rewardFallbackName": "Recompensa",
      "altImagePreview": "Vista previa de {{name}}",
      "altCropImage": "Imagen para recortar"
    },
    "generateQr": {
      "amountLabel": "Importe de la Venta (‚Ç¨):",
      "amountPlaceholder": "Ej: 15.50",
      "ticketLabel": "N√∫mero de Ticket:",
      "ticketPlaceholder": "Ej: T-12345",
      "buttonText": "Generar Datos QR",
      "errorAmountPositive": "El importe debe ser un n√∫mero positivo.",
      "errorTicketRequired": "El n√∫mero de ticket es obligatorio.",
      "successMessage": "¬°QR Generado para {{amount}} ‚Ç¨!",
      "successInstructions": "P√≠dele al cliente que escanee este c√≥digo para obtener sus puntos.",
      "tokenRef": "Token (ref.):",
      "errorGeneric": "Error al generar QR: {{error}}",
      "initialPrompt": "Introduce importe y n√∫mero de ticket para generar los datos del QR."
    },
    "tierForm": {
      "nameLabel": "Nombre del Nivel",
      "namePlaceholder": "Ej: Oro",
      "levelLabel": "Nivel (Orden)",
      "levelPlaceholder": "Ej: 3",
      "levelDescription": "N√∫mero para ordenar los niveles (0 o mayor).",
      "minValueLabel": "Valor M√≠nimo para Alcanzar",
      "minValuePlaceholder": "Ej: 1500",
      "minValueDescription": "Gasto (‚Ç¨), Visitas o Puntos necesarios (seg√∫n config. negocio).",
      "descriptionLabel": "Descripci√≥n (Opcional)",
      "descriptionPlaceholder": "Breve descripci√≥n del nivel",
      "benefitsDescriptionLabel": "Resumen Beneficios (Opcional)",
      "benefitsDescriptionPlaceholder": "Texto resumen de los beneficios principales para el cliente",
      "activeLabel": "Nivel Activo",
      "activeDescription": "Si est√° inactivo, los clientes no podr√°n alcanzarlo ni ver sus beneficios."
    },
    "tierBenefitsModal": {
      "modalTitle": "Gestionar Beneficios - Nivel: {{name}}",
      "addSectionTitle": "A√±adir Nuevo Beneficio",
      "listSectionTitle": "Beneficios Actuales",
      "errorLoading": "Error al cargar los beneficios.",
      "noBenefits": "Este nivel no tiene beneficios definidos.",
      "addBenefitButton": "A√±adir Beneficio",
      "closeButton": "Cerrar",
      "tableHeaderType": "Tipo",
      "tableHeaderValue": "Valor",
      "tableHeaderDescription": "Descripci√≥n",
      "tableHeaderStatus": "Estado",
      "tableHeaderActions": "Acciones",
      "tooltipEditBenefit": "Editar Beneficio",
      "tooltipDeleteBenefit": "Eliminar Beneficio",
      "addSuccessTitle": "Beneficio A√±adido",
      "addSuccessMessage": "El nuevo beneficio se ha a√±adido correctamente.",
      "addErrorTitle": "Error al A√±adir",
      "addErrorMessage": "No se pudo a√±adir el beneficio.",
      "deleteUpcoming": "Eliminaci√≥n de beneficios a√∫n no implementada.",
      "editUpcoming": "Edici√≥n de beneficios a√∫n no implementada."
    },
    "addTierBenefitForm": {
      "typeLabel": "Tipo de Beneficio",
      "typePlaceholder": "Selecciona un tipo",
      "valueLabel": "Valor",
      "valuePlaceholder": "Ej: 1.5, reward_id, 'Descuento X'",
      "valueDescription": "Valor asociado al tipo (n√∫mero, ID, texto)",
      "descriptionLabel": "Descripci√≥n (Opcional)",
      "descriptionPlaceholder": "Detalles adicionales del beneficio",
      "activeLabel": "Beneficio Activo",
      "benefitType_POINTS_MULTIPLIER": "Multiplicador de Puntos",
      "benefitType_EXCLUSIVE_REWARD_ACCESS": "Acceso a Recompensa Exclusiva",
      "benefitType_CUSTOM_BENEFIT": "Beneficio Personalizado",
      "errorValueRequired": "El valor es obligatorio"
    }
  },
  "adminTiersManagePage": {
    "title": "Gestionar Niveles (Tiers)",
    "addButton": "Crear Nuevo Nivel",
    "tableHeaderLevel": "Nivel (Orden)",
    "tableHeaderName": "Nombre",
    "tableHeaderThreshold": "Umbral M√≠nimo",
    "tableHeaderBenefits": "Beneficios",
    "tableHeaderStatus": "Estado",
    "tableHeaderActions": "Acciones",
    "tooltipManageBenefits": "Gestionar Beneficios",
    "tooltipEditTier": "Editar Nivel",
    "tooltipDeleteTier": "Eliminar Nivel",
    "noTiersDefined": "No hay niveles definidos todav√≠a.",
    "benefitsSummaryNone": "Ninguno",
    "benefitsSummaryNoneActive": "Ninguno activo",
    "benefitsSummaryActive_one": "{{count}} beneficio activo",
    "benefitsSummaryActive_other": "{{count}} beneficios activos",
    "createModalTitle": "Crear Nuevo Nivel",
    "editModalTitle": "Editar Nivel: {{name}}",
    "deleteModalTitle": "Confirmar Eliminaci√≥n",
    "deleteModalMessage": "¬øEst√°s seguro de que quieres eliminar el nivel \"{{name}}\"? Esta acci√≥n no se puede deshacer.",
    "deleteModalConfirm": "Eliminar Nivel",
    "createSuccessTitle": "Nivel Creado",
    "createSuccessMessage": "El nivel \"{{name}}\" se ha creado correctamente.",
    "createErrorTitle": "Error al Crear",
    "createErrorMessage": "No se pudo crear el nivel.",
    "updateSuccessTitle": "Nivel Actualizado",
    "updateSuccessMessage": "El nivel \"{{name}}\" se ha actualizado correctamente.",
    "updateErrorTitle": "Error al Actualizar",
    "updateErrorMessage": "No se pudo actualizar el nivel.",
    "deleteLoadingMessage": "Intentando eliminar el nivel \"{{name}}\"",
    "deleteSuccessTitle": "¬°Eliminado!",
    "deleteSuccessMessage": "El nivel \"{{name}}\" se ha eliminado correctamente.",
    "deleteErrorTitle": "Error al Eliminar",
    "deleteErrorMessage": "Error al eliminar el nivel.",
    "deleteErrorNotFound": "No se encontr√≥ el nivel seleccionado para editar.",
    "deleteErrorInUse": "No se puede eliminar el Nivel {{id}} porque tiene usuarios asignados. Reas√≠gnelos primero."
  },
  "adminTiersSettingsPage": {
    "title": "Configuraci√≥n del Sistema de Niveles (Tiers)",
    "description": "Define aqu√≠ c√≥mo funciona globalmente tu sistema de niveles. Los cambios se aplicar√°n a todos los clientes.",
    "enableSystemLabel": "Habilitar Sistema de Tiers",
    "enableSystemDescription": "Activa o desactiva el c√°lculo de niveles y sus beneficios.",
    "basisLabel": "Base para Calcular el Nivel",
    "basisPlaceholder": "Selecciona c√≥mo se alcanza el nivel",
    "basisPlaceholderDisabled": "N/A (Sistema Deshabilitado)",
    "basisDescription": "M√©trica principal usada para determinar el nivel (Gasto, Visitas o Puntos Hist√≥ricos).",
    "basisOption_SPEND": "Gasto Acumulado (‚Ç¨)",
    "basisOption_VISITS": "N√∫mero de Visitas",
    "basisOption_POINTS_EARNED": "Puntos Hist√≥ricos Ganados",
    "periodLabel": "Periodo de C√°lculo (Meses)",
    "periodPlaceholder": "Ej: 12",
    "periodPlaceholderNA": "N/A",
    "periodDescription": "Meses hacia atr√°s para calcular m√©trica (0/vac√≠o = de por vida).",
    "downgradePolicyLabel": "Pol√≠tica de Descenso de Nivel",
    "downgradePolicyPlaceholder": "Selecciona c√≥mo se bajan niveles",
    "downgradePolicyDescription": "Regla para bajar de nivel (Nunca, Revisi√≥n Peri√≥dica o Inactividad).",
    "downgradePolicyOption_NEVER": "Nunca Bajar",
    "downgradePolicyOption_PERIODIC_REVIEW": "Revisi√≥n Peri√≥dica",
    "downgradePolicyOption_AFTER_INACTIVITY": "Tras Inactividad",
    "inactivityLabel": "Meses de Inactividad para Descenso",
    "inactivityPlaceholder": "Ej: 6",
    "inactivityDescription": "Meses sin actividad para bajar de nivel.",
    "editButton": "Editar Configuraci√≥n",
    "saveButton": "Guardar Cambios",
    "cancelButton": "Cancelar",
    "errorLoading": "Error al cargar la configuraci√≥n de Tiers.",
    "errorSaving": "Error al guardar la configuraci√≥n.",
    "successSaving": "Los ajustes se han guardado correctamente."
  },
  "adminCustomersPage": {
    "title": "Gesti√≥n de Clientes",
    "filterLabel": "Filtros:",
    "searchPlaceholder": "Buscar por nombre o email...",
    "statusFilterPlaceholder": "Estado",
    "statusFilterAll": "Todos los Estados",
    "statusFilterActive": "Activo",
    "statusFilterInactive": "Inactivo",
    "favoriteFilterLabel": "Solo Favoritos",
    "tierFilterPlaceholder": "Nivel",
    "tierFilterAll": "Todos los Niveles",
    "tierFilterNone": "Sin Nivel (B√°sico)",
    "tierFilterError": "Error al cargar",
    "selectedCount_one": "{{count}} cliente seleccionado",
    "selectedCount_other": "{{count}} clientes seleccionados",
    "bulkDeleteButton": "Eliminar",
    "bulkActivateButton": "Activar",
    "bulkDeactivateButton": "Desactivar",
    "bulkPointsButton": "Puntos",
    "resultsCount_one": "{{count}} cliente encontrado",
    "resultsCount_other": "{{count}} clientes encontrados",
    "resultsCountFiltered": " con los criterios actuales",
    "noResults": "No se encontraron clientes.",
    "noResultsFiltered": "No se encontraron clientes con los criterios actuales.",
    "tableHeaderFavorite": "Fav.",
    "tableHeaderName": "Nombre",
    "tableHeaderEmail": "Email",
    "tableHeaderPoints": "Puntos",
    "tableHeaderTier": "Nivel",
    "tableHeaderRegistered": "Registrado",
    "tableHeaderStatus": "Estado",
    "tableHeaderActions": "Acciones",
    "tooltipViewDetails": "Ver Detalles",
    "tooltipAdjustPoints": "Ajustar Puntos",
    "tooltipChangeTier": "Cambiar Nivel",
    "tooltipAssignReward": "Asignar Recompensa",
    "tooltipDeactivateCustomer": "Desactivar Cliente",
    "tooltipActivateCustomer": "Activar Cliente",
    "tooltipFavorite": "Marcar como Favorito",
    "tooltipUnfavorite": "Quitar de Favoritos",
    "checkboxAriaLabel": "Seleccionar fila {{id}}",
    "checkboxSelectAllAriaLabel": "Seleccionar todas las filas visibles",
    "adjustPointsModalTitle": "Ajustar Puntos para {{name}}",
    "adjustPointsCurrent": "Puntos actuales: {{points}}",
    "adjustPointsAmountLabel": "Cantidad a A√±adir/Restar",
    "adjustPointsAmountPlaceholder": "Ej: 50 (a√±adir) o -20 (restar)",
    "adjustPointsReasonLabel": "Raz√≥n (Opcional)",
    "adjustPointsReasonPlaceholder": "Ej: Correcci√≥n manual, Bonificaci√≥n especial",
    "adjustPointsButton": "Ajustar Puntos",
    "adjustPointsSuccess": "Puntos ajustados correctamente para {{name}}.",
    "adjustPointsError": "No se pudo ajustar los puntos: {{error}}",
    "changeTierModalTitle": "Cambiar Nivel Manualmente para {{name}}",
    "changeTierCurrent": "Nivel actual: {{tierName}}",
    "changeTierSelectLabel": "Selecciona el Nuevo Nivel",
    "changeTierSelectPlaceholder": "Elige un nivel de la lista",
    "changeTierOptionNone": "Quitar Nivel (B√°sico)",
    "changeTierOptionLevel": "Nivel {{level}}",
    "changeTierNotFound": "No hay niveles disponibles o no se encontraron.",
    "changeTierButton": "Cambiar Nivel",
    "changeTierNoChange": "El nivel seleccionado es el mismo que el actual.",
    "changeTierNoChangeTitle": "Sin Cambios",
    "changeTierSuccess": "Nivel cambiado correctamente para {{name}}.",
    "changeTierError": "No se pudo cambiar el nivel: {{error}}",
    "changeTierErrorLoadingTiers": "No se pudieron cargar los niveles: {{error}}",
    "changeTierLoadingErrorTitle": "Error Cargando Niveles",
    "assignRewardModalTitle": "Asignar Recompensa como Regalo a {{name}}",
    "assignRewardSelectLabel": "Selecciona una Recompensa",
    "assignRewardSelectPlaceholder": "Elige una recompensa de la lista",
    "assignRewardOptionPoints": "{{points}} pts",
    "assignRewardNotFound": "No hay recompensas disponibles o no se encontraron.",
    "assignRewardButton": "Asignar Recompensa",
    "assignRewardSuccess": "Recompensa asignada correctamente a {{name}}.",
    "assignRewardError": "No se pudo asignar la recompensa: {{error}}",
    "assignRewardErrorLoading": "No se pudieron cargar las recompensas: {{error}}",
    "assignRewardLoadingErrorTitle": "Error Cargando Recompensas",
    "customerDetailsModalTitle": "Detalles de {{name}}",
    "customerDetailsLoadingError": "Error al Cargar Detalles",
    "customerDetailsPoints": "Puntos Actuales:",
    "customerDetailsTier": "Nivel Actual:",
    "customerDetailsTierDate": "Nivel Conseguido:",
    "customerDetailsStatus": "Estado:",
    "customerDetailsFavorite": "Favorito:",
    "customerDetailsRegisteredDate": "Fecha Registro:",
    "customerDetailsAdminNotesLabel": "Notas del Administrador",
    "customerDetailsAdminNotesPlaceholder": "A√±adir notas internas sobre este cliente...",
    "customerDetailsSaveNotesButton": "Guardar Notas",
    "customerDetailsNoDetails": "No se encontraron detalles para este cliente.",
    "customerDetailsNotesSaved": "Las notas del administrador se han guardado correctamente.",
    "customerDetailsNotesError": "No se pudieron guardar las notas: {{error}}",
    "noCustomerSelected": "No se ha seleccionado ning√∫n cliente.",
    "bulkActionNoneSelected": "No hay clientes seleccionados.",
    "bulkConfirmToggleActiveTitle": "Confirmar Activaci√≥n/Desactivaci√≥n Masiva",
    "bulkConfirmToggleActiveMessage": "¬øEst√°s seguro de que quieres {{action}} a {{count}} cliente(s) seleccionado(s)?",
    "bulkConfirmToggleActivate": "activar",
    "bulkConfirmToggleDeactivate": "desactivar",
    "bulkConfirmDeleteTitle": "Confirmar Eliminaci√≥n Masiva",
    "bulkConfirmDeleteMessage": "¬øEst√°s seguro de que quieres eliminar permanentemente a {{count}} cliente(s) seleccionado(s)? Esta acci√≥n no se puede deshacer.",
    "bulkConfirmDeleteButton": "Eliminar Clientes",
    "bulkActionStatusSuccess": "{{count}} cliente(s) {{status}} correctamente.",
    "bulkActionStatusActivated": "activados",
    "bulkActionStatusDeactivated": "desactivados",
    "bulkActionStatusError": "No se pudo {{action}} a los clientes: {{error}}",
    "bulkActionDeleteSuccess": "{{count}} cliente(s) eliminados correctamente.",
    "bulkActionDeleteError": "No se pudo eliminar a los clientes: {{error}}",
    "bulkAdjustPointsModalTitle": "Ajustar Puntos para {{count}} Cliente(s) Seleccionado(s)",
    "bulkAdjustPointsAmountLabel": "Cantidad a A√±adir/Restar",
    "bulkAdjustPointsAmountPlaceholder": "Ej: 50 (a√±adir) o -20 (restar)",
    "bulkAdjustPointsReasonLabel": "Raz√≥n (Opcional)",
    "bulkAdjustPointsReasonPlaceholder": "Ej: Bonificaci√≥n masiva, Correcci√≥n general",
    "bulkAdjustPointsButton": "Ajustar Puntos Masivamente",
    "bulkAdjustPointsSuccess": "{{points}} puntos {{action}} a {{count}} cliente(s) correctamente.",
    "bulkAdjustPointsAdded": "a√±adidos",
    "bulkAdjustPointsSubtracted": "restados",
    "bulkAdjustPointsError": "No se pudo ajustar los puntos: {{error}}",
    "bulkAdjustPointsErrorNoneSelected": "Error inesperado: No hay clientes seleccionados."
  },
  "benefits": {
    "pointsMultiplier": "Multiplicador x{{value}} Puntos",
    "exclusiveRewardAccess": "Recompensa Exclusiva: {{value}}",
    "customBenefit": "{{value}}"
  },
  "superAdminPage": {
    "title": "Panel de Super Administrador",
    "searchPlaceholder": "Buscar negocios por nombre o slug...",
    "tableHeaderBusiness": "Negocio",
    "tableHeaderStatus": "Estado General",
    "tableHeaderLoyalty": "Fidelizaci√≥n",
    "tableHeaderCamarero": "Camarero",
    "tableHeaderRegistered": "Registrado",
    "noBusinesses": "No hay negocios registrados.",
    "tooltipActivateBusiness": "Activar negocio",
    "tooltipDeactivateBusiness": "Desactivar negocio",
    "moduleLoyaltyCoreTooltip": "Activar/Desactivar M√≥dulo Fidelizaci√≥n (LoyalPyME Core)",
    "moduleCamareroTooltip": "Activar/Desactivar M√≥dulo Camarero",
    "statusChangeSuccess": "Estado del negocio '{{businessName}}' cambiado a {{status}}.",
    "statusChangeError": "Error al cambiar el estado del negocio.",
    "moduleChangeSuccess": "M√≥dulo '{{moduleName}}' {{status}} para el negocio '{{businessName}}'.",
    "moduleChangeError": "Error al cambiar el estado del m√≥dulo '{{moduleName}}'.",
    "moduleLoyaltyCore": "LoyalPyME Core",
    "moduleCamarero": "LoyalPyME Camarero",
    "businessFallbackName": "el negocio",
    "statusPaid": "Al d√≠a",
    "statusPending": "Pendiente",
    "statusOverdue": "Atrasado",
    "filterAll": "Todos",
    "manageSubscriptionTooltip": "Gestionar Suscripci√≥n y Pagos",
    "impersonateTooltip": "Iniciar sesi√≥n como este administrador",
    "tableHeaderPrice": "Precio/mes",
    "tableHeaderPaymentStatus": "Estado de Pago"
  },
  "adminCamarero": {
    "manageMenu": "Gestionar Carta",
    "manageTables": "Gestionar Mesas",
    "cardMenuTitle": "Carta Digital",
    "cardMenuDesc": "Crea y edita los productos, categor√≠as y modificadores de tu men√∫.",
    "cardMenuButton": "Gestionar Carta",
    "manageMenu.title": "Gesti√≥n de Carta Digital",
    "manageMenu.categoriesSectionTitle": "Categor√≠as del Men√∫",
    "manageMenu.categoryManagerPlaceholder": "Gestor de Categor√≠as ir√° aqu√≠...",
    "manageMenu.itemsSectionTitle": "√çtems del Men√∫",
    "manageMenu.itemManagerPlaceholder": "Gestor de √çtems (por categor√≠a) ir√° aqu√≠...",
    "manageMenu.editCategoryTitle": "Editar Categor√≠a",
    "manageMenu.addCategoryTitle": "A√±adir Nueva Categor√≠a",
    "manageMenu.categoryNameEsPlaceholder": "Ej: Entrantes, Postres...",
    "manageMenu.categoryNameEnPlaceholder": "Ej: Starters, Desserts...",
    "manageMenu.categoryDescEsPlaceholder": "Descripci√≥n en espa√±ol (opcional)",
    "manageMenu.categoryDescEnPlaceholder": "Descripci√≥n en ingl√©s (opcional)",
    "manageMenu.categoryImagePreviewAlt": "Vista previa de la imagen de categor√≠a",
    "manageMenu.uploadImageButton": "Subir imagen seleccionada",
    "manageMenu.categoryPositionLabel": "Posici√≥n (Orden)",
    "manageMenu.categoryPositionPlaceholder": "Ej: 1, 2, 3...",
    "manageMenu.categoryPositionDesc": "N√∫mero para ordenar (0 o mayor). Menor aparece primero.",
    "manageMenu.categoryActiveLabel": "Categor√≠a Activa",
    "manageMenu.categoryActiveDesc": "Si est√° inactiva, no se mostrar√° a los clientes.",
    "manageMenu.categoryCreateSuccess": "Categor√≠a '{{name}}' creada con √©xito.",
    "manageMenu.categoryUpdateSuccess": "Categor√≠a '{{name}}' actualizada con √©xito.",
    "manageMenu.categoryDeleteSuccess": "Categor√≠a eliminada con √©xito.",
    "manageMenu.pendingImageUpload": "Por favor, sube la imagen seleccionada o elim√≠nala antes de guardar.",
    "manageMenu.category": "Categor√≠a",
    "manageMenu.item": "√çtem",
    "manageMenu.itemLabel": "√çtem",
    "manageMenu.editItemTitle": "Editar √çtem",
    "manageMenu.addItemTitle": "A√±adir Nuevo √çtem",
    "manageMenu.itemNameEsPlaceholder": "Ej: Hamburguesa Cl√°sica",
    "manageMenu.itemNameEnPlaceholder": "Ej: Classic Burger",
    "manageMenu.itemDescEsPlaceholder": "Descripci√≥n detallada en espa√±ol...",
    "manageMenu.itemDescEnPlaceholder": "Descripci√≥n detallada en ingl√©s...",
    "manageMenu.itemPrice": "Precio",
    "manageMenu.itemAllergens": "Al√©rgenos",
    "manageMenu.itemAllergensPlaceholder": "Selecciona o escribe al√©rgenos",
    "manageMenu.itemTags": "Etiquetas",
    "manageMenu.itemTagsPlaceholder": "Selecciona o escribe etiquetas",
    "manageMenu.itemPosition": "Posici√≥n",
    "manageMenu.itemPrepTime": "Tiempo Prep. (min)",
    "manageMenu.itemCalories": "Calor√≠as (kcal)",
    "manageMenu.itemSku": "SKU / Ref.",
    "manageMenu.itemKds": "Destino KDS",
    "manageMenu.itemKdsPlaceholder": "Ej: Cocina, Barra",
    "manageMenu.itemKdsDesc": "Para sistemas de pantalla en cocina/barra (opcional)",
    "manageMenu.itemIsAvailable": "√çtem Disponible",
    "manageMenu.itemIsAvailableDesc": "Si no est√° disponible, no se mostrar√° a los clientes.",
    "manageMenu.modifierGroupsTitle": "Grupos de Modificadores",
    "manageMenu.manageGroupsButton": "Gestionar Grupos",
    "manageMenu.modifierGroupsDescription": "Define grupos de opciones para personalizar este √≠tem (ej: Tama√±o, Extras, Salsas).",
    "manageMenu.itemCreateSuccess": "√çtem '{{name}}' creado con √©xito.",
    "manageMenu.itemUpdateSuccess": "√çtem '{{name}}' actualizado con √©xito.",
    "manageMenu.itemDeleteSuccess": "√çtem eliminado con √©xito.",
    "manageMenu.itemFallbackName": "√çtem",
    "manageMenu.itemNew": "Nuevo √çtem",
    "manageMenu.noItemsInCategory": "No hay √≠tems en esta categor√≠a todav√≠a.",
    "manageMenu.itemImageLabel": "Imagen del √çtem",
    "manageMenu.itemAvailability": "Disponibilidad",
    "manageMenu.itemAvailable": "Disponible",
    "manageMenu.itemNotAvailable": "No Disponible",
    "manageMenu.markAvailable": "Marcar Disponible",
    "manageMenu.markNotAvailable": "Marcar No Disponible",
    "manageMenu.manageModifiersTooltip": "Gestionar Modificadores",
    "manageMenu.viewItemsTooltip": "Ver/Gestionar √çtems de esta Categor√≠a",
    "manageMenu.previewButton": "Previsualizar Carta P√∫blica",
    "manageMenu.previewErrorNoSlug": "No se pudo obtener el identificador del negocio para la previsualizaci√≥n.",
    "manageMenu.previewDisabledTooltip": "Identificador de negocio no disponible para previsualizar.",
    "manageMenu.toCategories": "a Categor√≠as",
    "manageMenu.modifierGroupCreateSuccess": "Grupo '{{name}}' creado con √©xito.",
    "manageMenu.modifierGroupUpdateSuccess": "Grupo '{{name}}' actualizado con √©xito.",
    "manageMenu.modifierGroupDeleteSuccess": "Grupo de modificadores eliminado con √©xito.",
    "menuCategoryForm": {
      "errorInvalidCropOrImage": "Recorte o imagen no v√°lida.",
      "errorUploadingWithDetail": "Error al subir: {{error}}",
      "altPreview": "Vista previa de la categor√≠a",
      "altCropImage": "Imagen para recortar",
      "imageUploadSuccess": "Imagen de categor√≠a subida correctamente.",
      "errorCreatingCroppedFile": "No se pudo crear el archivo de imagen de categor√≠a recortada.",
      "errorApiNoUrl": "La API no devolvi√≥ una URL v√°lida para la imagen de categor√≠a.",
      "imageUploadError": "No se pudo subir la imagen de categor√≠a: {{error}}"
    },
    "menuItemForm": {
      "errorInvalidCropOrImage": "Recorte o imagen no v√°lida.",
      "errorCreatingCroppedFile": "No se pudo crear el archivo de imagen de √≠tem recortada.",
      "imageUploadSuccess": "Imagen de √≠tem subida correctamente.",
      "errorApiNoUrl": "La API no devolvi√≥ una URL v√°lida para la imagen de √≠tem.",
      "errorUploadingWithDetail": "Error al subir imagen de √≠tem: {{error}}",
      "imageUploadError": "No se pudo subir la imagen de √≠tem: {{error}}",
      "altPreview": "Vista previa del √≠tem",
      "altCropImage": "Imagen del √≠tem para recortar"
    },
    "menuItem": {
      "allergen.GLUTEN": "Gluten",
      "allergen.LACTOSE": "Lactosa",
      "allergen.NUTS": "Frutos Secos",
      "allergen.SOY": "Soja",
      "allergen.FISH": "Pescado",
      "allergen.CRUSTACEANS": "Crust√°ceos",
      "allergen.CELERY": "Apio",
      "allergen.MUSTARD": "Mostaza",
      "allergen.SESAME": "S√©samo",
      "allergen.SULPHITES": "Sulfitos",
      "allergen.LUPIN": "Altramuces",
      "allergen.MOLLUSCS": "Moluscos",
      "tag.VEGAN": "Vegano",
      "tag.VEGETARIAN": "Vegetariano",
      "tag.SPICY": "Picante",
      "tag.NEW": "Nuevo",
      "tag.POPULAR": "Popular",
      "tag.HOUSE_SPECIAL": "Especialidad de la Casa"
    },
    "modifierGroupsModal": {
      "title": "Gestionar Grupos de Modificadores para: \"{{itemName}}\"",
      "existingGroupsTitle": "Grupos Existentes",
      "createNewGroupButton": "Crear Nuevo Grupo",
      "noGroupsForItem": "No hay grupos de modificadores para este √≠tem.",
      "tableHeaderName": "Nombre",
      "tableHeaderUiType": "Tipo UI",
      "tableHeaderSelections": "Selecciones (Min-Max)",
      "tableHeaderRequired": "Requerido",
      "tableHeaderPosition": "Posici√≥n",
      "tooltipManageOptions": "Gestionar Opciones",
      "tooltipEditGroup": "Editar Grupo",
      "tooltipDeleteGroup": "Eliminar Grupo",
      "formEditTitle": "Editando Grupo: {{groupName}}",
      "formCreateTitle": "Crear Nuevo Grupo de Modificadores",
      "formCreateButton": "Crear Grupo",
      "closeButton": "Cerrar Gesti√≥n de Grupos"
    },
    "modifierGroupForm": {
      "nameEsLabel": "Nombre (ES)",
      "nameEnLabel": "Nombre (EN)",
      "uiTypeLabel": "Tipo de Interfaz de Usuario (UI)",
      "uiType.RADIO": "Opci√≥n √önica (Radio)",
      "uiType.CHECKBOX": "M√∫ltiples Opciones (Checkbox)",
      "minSelectionsLabel": "M√≠nimo Selecciones",
      "maxSelectionsLabel": "M√°ximo Selecciones",
      "positionLabel": "Posici√≥n (Orden)",
      "isRequiredLabel": "Es Requerido",
      "validation": {
        "nameEsRequired": "El nombre en espa√±ol es obligatorio.",
        "uiTypeInvalid": "Selecciona un tipo de UI v√°lido.",
        "minSelectionsInvalid": "M√≠nimo de selecciones debe ser 0 o m√°s.",
        "maxSelectionsInvalid": "M√°ximo de selecciones debe ser 1 o m√°s.",
        "minMaxMismatch": "El m√≠nimo de selecciones no puede ser mayor que el m√°ximo."
      }
    },
    "modifierOptionsModal": {
      "title": "Opciones para Grupo: \"{{groupName}}\"",
      "existingOptionsTitle": "Opciones Existentes",
      "createNewOptionButton": "Crear Nueva Opci√≥n",
      "noOptionsForGroup": "No hay opciones para este grupo.",
      "tableHeaderName": "Nombre",
      "tableHeaderPriceAdjustment": "Ajuste Precio",
      "tableHeaderPosition": "Posici√≥n",
      "tableHeaderDefault": "Por Defecto",
      "tableHeaderAvailable": "Disponible",
      "formEditTitle": "Editando Opci√≥n: {{optionName}}",
      "formCreateTitle": "Crear Nueva Opci√≥n de Modificador",
      "formCreateButton": "Crear Opci√≥n",
      "closeButton": "Cerrar Gesti√≥n de Opciones"
    },
    "modifierOptionForm": {
      "nameEsLabel": "Nombre (ES)",
      "nameEnLabel": "Nombre (EN)",
      "priceAdjustmentLabel": "Ajuste de Precio (‚Ç¨)",
      "priceAdjustmentDescription": "Positivo para aumentar, negativo para disminuir, 0 sin cambio.",
      "positionLabel": "Posici√≥n (Orden)",
      "isDefaultLabel": "Seleccionada por Defecto",
      "isAvailableLabel": "Opci√≥n Disponible",
      "validation": {
        "nameEsRequired": "El nombre en espa√±ol es obligatorio."
      }
    },
    "modifierOption": {
      "statusAvailable": "Disponible",
      "statusNotAvailable": "No Disp.",
      "tooltipEditOption": "Editar Opci√≥n",
      "tooltipMarkAvailable": "Marcar Disponible",
      "tooltipMarkNotAvailable": "Marcar No Disponible",
      "tooltipDeleteOption": "Eliminar Opci√≥n"
    },
    "modifierGroupHook": {
      "errorNoMenuItemForGroup": "Error: No se puede a√±adir un grupo sin un √≠tem de men√∫ asociado.",
      "fallbackGroupName": "Grupo",
      "createSuccess": "Grupo '{{name}}' creado con √©xito.",
      "updateSuccess": "Grupo '{{name}}' actualizado con √©xito.",
      "deleteSuccess": "Grupo de modificadores eliminado con √©xito."
    },
    "modifierOptionHook": {
      "errorLoadingOptions": "Error cargando opciones de modificador.",
      "errorNoGroupForOption": "No se puede a√±adir una opci√≥n sin un grupo de modificadores asociado.",
      "createSuccess": "Opci√≥n \"{{optionName}}\" creada correctamente.",
      "fallbackOptionName": "Opci√≥n",
      "errorCreatingOption": "Error al crear la opci√≥n.",
      "updateSuccess": "Opci√≥n \"{{optionName}}\" actualizada correctamente.",
      "errorUpdatingOption": "Error al actualizar la opci√≥n.",
      "deleteSuccess": "Opci√≥n de modificador eliminada correctamente.",
      "errorDeletingOption": "Error al eliminar la opci√≥n."
    },
    "menuItemHook": {
      "errorNoCategoryForItem": "No se puede a√±adir un √≠tem sin una categor√≠a seleccionada."
    }
  },
  "publicMenu": {
    "unnamedItem": "√çtem sin nombre",
    "unnamedCategory": "Categor√≠a sin nombre",
    "noCategories": "No hay categor√≠as de men√∫ disponibles.",
    "noItemsInCategory": "No hay √≠tems en esta categor√≠a.",
    "menuNotAvailable": "Men√∫ no disponible o no encontrado.",
    "customizeButton": "Personalizar",
    "optionsTitle": "Personaliza tu elecci√≥n:",
    "itemNotesLabel": "Notas para este √≠tem (opcional)",
    "itemNotesPlaceholder": "Ej: Sin cebolla, extra picante...",
    "quantity": "Cantidad",
    "confirmAndAddToCart": "Confirmar y A√±adir",
    "customizeAndAdd": "Personalizar y A√±adir",
    "addToCart": "A√±adir al Carrito",
    "itemAddedTitle": "¬°A√±adido!",
    "itemAddedMessage": "{{itemName}} (x{{quantity}}) a√±adido al carrito.",
    "invalidSelectionTitle": "Selecci√≥n Inv√°lida",
    "invalidSelectionMsg": "Por favor, completa todas las opciones obligatorias de los modificadores.",
    "modifier.chooseOneRequired": "Elige 1 (obligatorio)",
    "modifier.chooseMinUpToMax_required": "Elige de {{min}} a {{max}} (obligatorio)",
    "modifier.chooseUpToMaxOptional": "Elige hasta {{max}} (opcional)",
    "modifier.chooseOneOptional": "Elige 1 (opcional)",
    "modifier.chooseOptional": "Opcional",
    "modifier.chooseAtLeastOneUpToMax_required": "Elige al menos 1 hasta {{max}} (obligatorio)",
    "cart": {
      "title": "Tu Pedido",
      "total": "Total",
      "empty": "Tu carrito de pedido est√° vac√≠o.",
      "itemNotesLabel": "Notas:",
      "removeItem": "Eliminar √≠tem",
      "orderNotesLabel": "Notas para el Pedido (Opcional)",
      "orderNotesPlaceholder": "Ej: Alergias generales, preferencia de entrega...",
      "totalOrder": "Total del Pedido:",
      "continueShopping": "Seguir Pidiendo",
      "submitOrder": "Enviar Pedido",
      "viewOrderItems_one": "Ver tu pedido ({{count}} √≠tem)",
      "viewOrderItems_other": "Ver tu pedido ({{count}} √≠tems)",
      "decreaseQuantity": "Disminuir cantidad de {{itemName}}",
      "itemQuantity": "Cantidad para {{itemName}}",
      "increaseQuantity": "Aumentar cantidad de {{itemName}}",
      "removeItemFromOrder": "Eliminar {{itemName}} del pedido",
      "errorTitle": "Error en Pedido",
      "errorEmpty": "Tu carrito est√° vac√≠o. A√±ade algunos √≠tems antes de enviar.",
      "orderSuccessTitle": "¬°Pedido Enviado!",
      "orderSuccessMsg": "Tu pedido #{{orderNumber}} ha sido recibido y se est√° preparando.",
      "orderErrorTitle": "Error al Enviar",
      "orderErrorMsg": "No se pudo enviar tu pedido. Por favor, int√©ntalo de nuevo o contacta con el personal.",
      "clearCartButton": "Vaciar Carrito",
      "clearedTitle": "Carrito Vac√≠o",
      "clearedMsg": "Se han eliminado todos los √≠tems de tu pedido.",
      "titleAddToOrder": "A√±adir a Pedido #{{orderNumber}}",
      "submitAddToOrder": "A√±adir al Pedido",
      "emptyAddToOrder": "Selecciona √≠tems para a√±adir a tu pedido.",
      "totalAddItems": "Total a A√±adir:",
      "addItemsToOrderButton": "A√±adir {{count}} √≠tems al Pedido #{{orderNumber}}",
      "itemsAddedSuccessTitle": "√çtems A√±adidos",
      "itemsAddedSuccessMsg": "√çtems a√±adidos al pedido #{{orderNumber}}.",
      "addItemsErrorTitle": "Error al A√±adir √çtems",
      "redeemedItemBadge": "Recompensa",
      "rewardsSectionTitle": "Mis Recompensas",
      "applyRewardButton": "Ver y Aplicar Recompensas",
      "discountApplied": "Descuento:",
      "subtotal": "Subtotal"
    },
    "unnamedModifier": "Modificador sin nombre",
    "activeOrder": {
      "addingToOrderTitle": "A√±adiendo al Pedido #{{orderNumber}}",
      "addingToOrderMsg": "Los nuevos √≠tems se a√±adir√°n a tu pedido en curso.",
      "viewStatusButton": "Ver Estado del Pedido",
      "cannotAddTitle": "No se pueden a√±adir √≠tems al Pedido #{{orderNumber}}",
      "cannotAddMsg": "El pedido ya no acepta nuevos √≠tems. Comienza un nuevo pedido.",
      "startNewButton": "Empezar Nuevo Pedido",
      "startNewButtonAlt": "Crear Pedido Nuevo"
    }
  },
  "error": {
    "missingBusinessSlug": "Error: Slug del negocio no proporcionado.",
    "noMenuDataReceived": "No se recibieron datos del men√∫."
  },
  "orderStatusPage": {
    "title": "Estado de tu Pedido",
    "error": {
      "missingOrderId": "No se especific√≥ un ID de pedido.",
      "noData": "No se recibieron datos del estado del pedido.",
      "notFound": "Pedido no encontrado o no disponible.",
      "updateFailed": "No se pudo actualizar el estado: {{message}}"
    },
    "generalStatus": "Estado General:",
    "table": "Mesa:",
    "placedAt": "Realizado el:",
    "itemsTitle": "√çtems del Pedido",
    "quantity": "Cantidad:",
    "orderNotesLabel": "Notas Generales del Pedido",
    "refreshButton": "Actualizar Estado",
    "backToMenuButton": "Volver al Men√∫",
    "addMoreItemsButton": "A√±adir m√°s √≠tems",
    "requestBillButton": "Pedir la Cuenta",
    "billRequestedSuccess": "Cuenta solicitada. Un camarero se acercar√° pronto.",
    "errorRequestingBill": "Error al solicitar la cuenta: {{message}}",
    "paidSuccessMessage": "¬°Pedido Pagado! Gracias por tu visita.",
    "itemStatus": {
      "pending_kds": "Recibido en cocina",
      "preparing": "En preparaci√≥n",
      "ready": "Listo para servir",
      "served": "Entregado",
      "cancelled": "Cancelado",
      "cancellation_requested": "Cancelaci√≥n Solicitada"
    },
    "orderStatus": {
      "received": "Recibido",
      "in_progress": "En Progreso",
      "partially_ready": "Parcialmente Listo",
      "all_items_ready": "Todos los √çtems Listos",
      "completed": "Completado",
      "pending_payment": "Pendiente de Pago",
      "paid": "Pagado",
      "cancelled": "Cancelado",
      "payment_failed": "Pago Fallido"
    },
    "kdsPage": {
      "title": "Pantalla de Cocina (KDS)",
      "destination": {
        "kitchen": "COCINA",
        "bar": "BARRA"
      },
      "unknownItem": "√çtem Desconocido",
      "noItems": "No hay √≠tems pendientes para este destino.",
      "quantity": "Cantidad",
      "notes": "Notas",
      "noTable": "Sin Mesa",
      "createdAt": "Recibido KDS",
      "modifiers": "Modificadores:",
      "statusUpdateSuccessTitle": "Estado Actualizado",
      "statusUpdateSuccessMsg": "El √≠tem \"{{itemName}}\" se actualiz√≥ a {{status}}.",
      "statusUpdateErrorMsg": "Error al actualizar estado del √≠tem.",
      "updateInProgressTitle": "Actualizaci√≥n en Progreso",
      "updateInProgressMsg": "Espera a que finalice la acci√≥n actual antes de iniciar otra.",
      "refreshManual": "Refrescar Manualmente",
      "action": {
        "startPreparing": "Empezar Preparaci√≥n",
        "markReady": "Marcar como Listo",
        "cancelItem": "Cancelar √çtem"
      }
    }
  },
  "waiterInterface": {
    "pickupPageTitle": "Pedidos Listos para Recoger y Servir",
    "noItemsReady": "No hay √≠tems listos para recoger en este momento.",
    "orderNumber": "Pedido",
    "pickupFrom": "Recoger de",
    "markAsServedButton": "Marcar como Servido",
    "actionInProgress": "Por favor, espera a que la acci√≥n actual termine.",
    "itemMarkedServedSuccess": "√çtem '{{itemName}}' marcado como servido.",
    "errorMarkingServed": "Error al marcar el √≠tem como servido.",
    "navLinkPickup": "Recoger Pedidos"
  },
  "homePage": {
    "welcomeTitle": "Bienvenido a LoyalPyME",
    "heroTitle": "Fideliza Clientes y Digitaliza tu Servicio. Todo en un Mismo Lugar.",
    "heroSubtitle": "LoyalPyME es la plataforma definitiva para que restaurantes, cafeter√≠as y PYMES creen programas de lealtad y optimicen su operativa con una carta digital inteligente.",
    "ctaBusiness": "Crear Cuenta de Negocio",
    "ctaLogin": "Ya tengo una cuenta",
    "featuresSection": {
      "superTitle": "Potencia Tu Negocio",
      "title": "Una Soluci√≥n, M√∫ltiples Beneficios"
    },
    "features": {
      "loyalty": {
        "title": "Programas de Lealtad",
        "desc": "Crea un sistema de puntos y niveles para que tus clientes vuelvan una y otra vez. Recompensa su fidelidad con productos y beneficios exclusivos."
      },
      "waiter": {
        "title": "M√≥dulo Camarero Digital",
        "desc": "Digitaliza tu carta, permite que los clientes pidan desde su m√≥vil y optimiza la comunicaci√≥n con cocina a trav√©s de nuestro sistema KDS."
      },
      "synergy": {
        "title": "Sinergia Total",
        "desc": "Cuando un cliente pide desde la carta, ¬°autom√°ticamente gana puntos! Los dos m√≥dulos trabajan juntos para maximizar el engagement y las ventas."
      }
    },
    "finalCta": {
      "title": "¬øListo para empezar?",
      "desc": "Crea tu cuenta hoy mismo y descubre c√≥mo LoyalPyME puede transformar tu negocio."
    }
  },
  "waiterOrderManagement": {
    "title": "Gesti√≥n de Pedidos de Sala",
    "filterStatusLabel": "Filtrar por Estado:",
    "statusOptionAll": "Todos los Pedidos",
    "statusOptionPendingPayment": "Pendientes de Pago",
    "statusOptionCompleted": "Completados (No Pagados)",
    "statusOptionPaid": "Pagados",
    "noOrdersFound": "No se encontraron pedidos con los filtros actuales.",
    "tableHeaderOrderNum": "N¬∫ Pedido",
    "tableHeaderTable": "Mesa",
    "tableHeaderTotal": "Total",
    "tableHeaderStatus": "Estado",
    "tableHeaderActions": "Acciones",
    "buttonMarkAsPaid": "Marcar Como Pagado",
    "buttonRequestBill": "Solicitar Cuenta",
    "confirmMarkAsPaidTitle": "Confirmar Pago",
    "confirmMarkAsPaidMessage": "¬øConfirmas que el pedido #{{orderNumber}} ha sido pagado?",
    "markAsPaidSuccess": "Pedido #{{orderNumber}} marcado como pagado.",
    "markAsPaidError": "Error al marcar el pedido #{{orderNumber}} como pagado: {{error}}",
    "paymentDetailsModalTitle": "Registrar Detalles del Pago para Pedido #{{orderNumber}}",
    "paymentMethodLabel": "M√©todo de Pago",
    "paymentMethodPlaceholder": "Ej: Efectivo, Tarjeta Visa",
    "paymentNotesLabel": "Notas del Pago (Opcional)",
    "paymentNotesPlaceholder": "Detalles adicionales...",
    "confirmPaymentButton": "Confirmar Pago",
    "navLinkTitle": "Gestionar Pedidos"
  },
  "orderBillView": {
    "item": "√çtem",
    "price": "Precio",
    "total": "Total",
    "reward": "Recompensa",
    "unnamedItem": "√çtem sin nombre",
    "subtotal": "Subtotal",
    "discount": "Descuento",
    "finalTotal": "TOTAL A PAGAR"
  },
  "applyRewardModal": {
    "title": "Aplica tus Recompensas",
    "tabs": {
      "coupons": "Mis Cupones",
      "redeem": "Canjear con Puntos"
    },
    "noCoupons": "No tienes cupones disponibles para usar.",
    "noRewardsInCatalog": "No hay recompensas en el cat√°logo.",
    "summary": {
      "totalCost": "Coste total de la selecci√≥n:",
      "availablePoints": "Puntos disponibles: {{points}}",
      "pointsBadge": "{{points}} Puntos"
    },
    "notEnoughPoints": "No tienes suficientes puntos para esta selecci√≥n.",
    "applyButton": "Aplicar al Pedido",
    "success": {
      "title": "¬°√âxito!",
      "message": "Las recompensas se han aplicado correctamente a tu pedido."
    }
  },
  "orderDetailModal": {
    "title": "Detalle del Pedido",
    "viewTooltip": "Ver Detalle",
    "headerOrder": "N¬∫ Pedido",
    "headerDate": "Fecha",
    "headerTotal": "Total",
    "downloadPdf": "Descargar PDF",
    "sendByEmail": "Enviar por Email"
  },
  "profileForm": {
    "noChanges": "No hay cambios para guardar.",
    "updateSuccess": "Perfil actualizado correctamente.",
    "updateError": "Error al actualizar el perfil."
  }
}


// ====== [132] frontend/src/App.tsx ======
// filename: frontend/src/App.tsx
// Version: 1.0.2 (Clean comments, fix encoding)

import AppRoutes from './routes/index'; // Importa el componente que define las rutas

// Opcional: Importar estilos globales si se usan activamente
// import './index.css';

function App() {
  // Renderiza el componente AppRoutes que maneja las p√°ginas seg√∫n la URL
  return (
    <div className="App"> {/* Clase global opcional */}
      <AppRoutes />
    </div>
  );
}

export default App;

// End of File: frontend/src/App.tsx


// ====== [133] frontend/src/i18n.ts ======
// filename: frontend/src/i18n.ts
// Version: 1.4.1 (Enable debug mode)

import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import HttpApi from 'i18next-http-backend';
import LanguageDetector from 'i18next-browser-languagedetector';

i18n
  .use(HttpApi)
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    supportedLngs: ['es', 'en'],
    fallbackLng: 'es',
    defaultNS: 'translation',
    backend: {
      loadPath: '/locales/{{lng}}/{{ns}}.json',
    },
    detection: {
      order: ['localStorage', 'navigator'],
      caches: ['localStorage'],
      lookupLocalStorage: 'i18nextLng',
    },
    // --- A√ëADIR ESTA L√çNEA ---
    debug: true, // Muestra logs detallados de i18next en la consola
    // --- FIN A√ëADIR ---
    interpolation: {
      escapeValue: false,
    },
    react: {
      useSuspense: true,
    }
  });

export default i18n;

// End of File: frontend/src/i18n.ts


// ====== [134] frontend/src/index.css ======
/* File: frontend/src/index.css */
/* Version: 1.0.6 (Simplify font-family variable) */

:root {
  /* --- CAMBIO: Simplificar fuente --- */
  --font-family-sans: sans-serif;
  /* --- FIN CAMBIO --- */
  --font-family-mono: Consolas, 'Courier New', monospace;

  /* Paleta Modo Claro (Predeterminado) */
  --color-text: #213547;
  --color-background: #ffffff;
  --color-primary: #646cff;
  --color-primary-light: #747bff;
  --color-secondary: #f9f9f9; /* Un gris muy claro */
  --color-border: #e0e0e0;
  --color-error: #d32f2f;
  --color-success: #388e3c;

  /* Paleta Modo Oscuro */
  --color-text-dark: rgba(255, 255, 255, 0.87);
  --color-background-dark: #242424;
  --color-primary-dark: #747bff;
  --color-primary-light-dark: #535bf2;
  --color-secondary-dark: #1a1a1a;
  --color-border-dark: #444;
  --color-error-dark: #ef5350;
  --color-success-dark: #66bb6a;

  line-height: 1.6;
  font-weight: 400;
  color-scheme: light dark;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

@media (prefers-color-scheme: dark) {
  :root {
    /* Aplicar variables modo oscuro */
     --color-text: var(--color-text-dark);
     --color-background: var(--color-background-dark);
     --color-primary: var(--color-primary-dark);
     --color-primary-light: var(--color-primary-light-dark);
     --color-secondary: var(--color-secondary-dark);
     --color-border: var(--color-border-dark);
     --color-error: var(--color-error-dark);
     --color-success: var(--color-success-dark);
  }
}

*, *::before, *::after {
  box-sizing: border-box;
}

html, body {
  /* Aplicar fuente base y colores */
  font-family: var(--font-family-sans); /* Ahora usar√° 'sans-serif' */
  color: var(--color-text);
  background-color: var(--color-background);
}


body {
  margin: 0;
  min-height: 100vh;
}

/* Estilos base para elementos comunes */
h1, h2, h3, h4 {
  margin-top: 0;
  font-weight: 700;
  font-family: inherit; /* Forzar herencia de fuente */
}
h1 {
  font-size: 2.5em;
  line-height: 1.1;
  margin-bottom: 1rem;
}
h2 {
  font-size: 1.8em;
  line-height: 1.2;
  margin-bottom: 0.75rem;
  border-bottom: 1px solid var(--color-border);
  padding-bottom: 0.25em;
}
a {
  font-weight: 500;
  color: var(--color-primary);
  text-decoration: inherit;
  transition: color 0.2s ease;
}
a:hover {
  color: var(--color-primary-light);
}
button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: var(--color-secondary);
  color: var(--color-text);
  cursor: pointer;
  transition: border-color 0.25s, background-color 0.2s ease;
}
button:hover {
  border-color: var(--color-primary);
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
  outline-color: var(--color-primary-light);
}
button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
input[type="text"],
input[type="email"],
input[type="password"],
input[type="number"],
textarea {
    display: block;
    width: 100%;
    padding: 0.6em 0.8em;
    font-size: 1em;
    font-family: inherit;
    line-height: 1.5;
    border: 1px solid var(--color-border);
    border-radius: 6px;
    background-color: var(--color-background);
    color: var(--color-text);
    margin-bottom: 0.75rem;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
input:focus,
textarea:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 2px var(--color-primary-light);
}
label {
    display: block;
    margin-bottom: 0.25rem;
    font-weight: 500;
}
.text-error {
  color: var(--color-error);
  font-size: 0.9em;
}
.text-success {
  color: var(--color-success);
  font-size: 0.9em;
}

/* End of File: frontend/src/index.css */


// ====== [135] frontend/src/main.tsx ======
// filename: frontend/src/main.tsx
// Version: 1.4.0 (Import i18n config and add Suspense)

import React from 'react'; // Necesario para Suspense
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

// Mantine Imports
import '@mantine/core/styles.css';
import { MantineProvider, Loader, Center } from '@mantine/core'; // A√±adido Loader y Center para fallback
import { Notifications } from '@mantine/notifications';
import '@mantine/notifications/styles.css';
import { ModalsProvider } from '@mantine/modals';
import { theme } from './theme';

// React Router
import { BrowserRouter } from 'react-router-dom';

// --- NUEVO: Importar la configuraci√≥n de i18next ---
// Simplemente importarlo aqu√≠ ejecuta el c√≥digo de inicializaci√≥n
import './i18n';
// --- FIN NUEVO ---

// Renderizar la aplicaci√≥n React
ReactDOM.createRoot(document.getElementById('root')!).render(
  // MantineProvider y BrowserRouter envuelven todo
  <MantineProvider theme={theme}>
    <BrowserRouter>
      {/* --- NUEVO: Envolver App con Suspense --- */}
      {/* Muestra un loader mientras i18next carga las traducciones iniciales */}
      <React.Suspense fallback={
          <Center style={{ height: '100vh' }}> {/* Centrar el loader */}
            <Loader color="blue" />
          </Center>
        }>
        <ModalsProvider>
          <Notifications position="top-right" zIndex={1000} />
          <App /> {/* App ahora est√° dentro de Suspense */}
        </ModalsProvider>
      </React.Suspense>
      {/* --- FIN NUEVO --- */}
    </BrowserRouter>
  </MantineProvider>
);

// Ocultar/Eliminar el loader inicial HTML (sin cambios)
const loaderElement = document.getElementById('initial-loader');
if (loaderElement) {
     loaderElement.remove();
     console.log("Initial loader removed.");
 }

// End of file: frontend/src/main.tsx


// ====== [136] frontend/src/modules/camarero/components/admin/menu/MenuCategoryFormModal.tsx ======
// frontend/src/components/admin/camarero/menu/MenuCategoryFormModal.tsx
// Version 2.0.1 (Corrected aspect ratio to 1:1 and minDimension to 150px)

import React, { useEffect } from 'react';
import {
    Modal, TextInput, Textarea, NumberInput, Switch, Button, Group, Stack, Text
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next';
import { IconDeviceFloppy } from '@tabler/icons-react';
import { MenuCategoryData, MenuCategoryFormData } from '../../../types/menu.types';

// Importar el componente reutilizable
import ImageUploadCropper from '../../../../../shared/components/utils/ImageUploadCropper';

const createCategoryFormSchema = (t: Function) => z.object({
  name_es: z.string().min(1, { message: t('common.requiredField') }),
  name_en: z.string().nullable().optional(),
  description_es: z.string().nullable().optional(),
  description_en: z.string().nullable().optional(),
  imageUrl: z.string().url({ message: t('validation.invalidUrl') }).nullable().optional(),
  position: z.number().min(0, { message: t('validation.minValueMin0') }),
  isActive: z.boolean(),
});

type CategoryFormValues = z.infer<ReturnType<typeof createCategoryFormSchema>>;

interface MenuCategoryFormModalProps {
    opened: boolean;
    onClose: () => void;
    onSubmit: (values: MenuCategoryFormData) => Promise<void>;
    initialData?: MenuCategoryData | null;
    isSubmitting: boolean;
}

const MenuCategoryFormModal: React.FC<MenuCategoryFormModalProps> = ({
    opened,
    onClose,
    onSubmit,
    initialData,
    isSubmitting,
}) => {
    const { t } = useTranslation();
    
    const form = useForm<CategoryFormValues>({
        initialValues: {
            name_es: '', name_en: null, description_es: null, description_en: null,
            imageUrl: null, position: 0, isActive: true,
        },
        validate: zodResolver(createCategoryFormSchema(t)),
    });

    useEffect(() => {
        if (opened) {
            if (initialData) {
                form.setValues({
                    name_es: initialData.name_es, name_en: initialData.name_en || null,
                    description_es: initialData.description_es || null, description_en: initialData.description_en || null,
                    imageUrl: initialData.imageUrl || null, position: initialData.position, isActive: initialData.isActive,
                });
            } else {
                form.reset();
            }
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, initialData]);


    const handleSubmitForm = async (values: CategoryFormValues) => {
        const submitData: MenuCategoryFormData = {
            name_es: values.name_es, name_en: values.name_en?.trim() || null,
            description_es: values.description_es?.trim() || null, description_en: values.description_en?.trim() || null,
            imageUrl: values.imageUrl || null, position: values.position, isActive: values.isActive,
        };
        await onSubmit(submitData);
    };

    const handleModalClose = () => { if (!isSubmitting) onClose(); }

    return (
        <Modal
            opened={opened} onClose={handleModalClose}
            title={initialData ? t('adminCamarero.manageMenu.editCategoryTitle') : t('adminCamarero.manageMenu.addCategoryTitle')}
            centered size="lg" overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
            trapFocus closeOnClickOutside={!isSubmitting} closeOnEscape={!isSubmitting}
        >
            <form onSubmit={form.onSubmit(handleSubmitForm)}>
                <Stack gap="md">
                    <TextInput label={t('component.rewardForm.nameEsLabel')} placeholder={t('adminCamarero.manageMenu.categoryNameEsPlaceholder')} required disabled={isSubmitting} {...form.getInputProps('name_es')} />
                    <TextInput label={t('component.rewardForm.nameEnLabel')} placeholder={t('adminCamarero.manageMenu.categoryNameEnPlaceholder')} disabled={isSubmitting} {...form.getInputProps('name_en')} />
                    <Textarea label={t('component.rewardForm.descriptionEsLabel')} placeholder={t('adminCamarero.manageMenu.categoryDescEsPlaceholder')} rows={2} disabled={isSubmitting} {...form.getInputProps('description_es')} />
                    <Textarea label={t('component.rewardForm.descriptionEnLabel')} placeholder={t('adminCamarero.manageMenu.categoryDescEnPlaceholder')} rows={2} disabled={isSubmitting} {...form.getInputProps('description_en')} />
                    
                    <ImageUploadCropper
                        aspectRatio={1} // <-- CORRECCI√ìN AQU√ç: Cambiado de 16/9 a 1
                        minDimension={150} // <-- CORRECCI√ìN AQU√ç: Cambiado de 300 a 150
                        initialImageUrl={form.values.imageUrl || null}
                        onUploadSuccess={(url) => form.setFieldValue('imageUrl', url)}
                        onUploadError={(errorMsg) => form.setFieldError('imageUrl', errorMsg)}
                        onClearImage={() => form.setFieldValue('imageUrl', null)}
                        folderName="loyalpyme/categories"
                        disabled={isSubmitting}
                        imagePreviewAltText={t('adminCamarero.menuCategoryForm.altPreview')}
                    />
                     {form.errors.imageUrl && (
                        <Text c="red" size="xs" mt={-10}>{form.errors.imageUrl}</Text>
                    )}

                    <NumberInput label={t('adminCamarero.manageMenu.categoryPositionLabel')} placeholder={t('adminCamarero.manageMenu.categoryPositionPlaceholder')} description={t('adminCamarero.manageMenu.categoryPositionDesc')} required min={0} step={1} allowDecimal={false} disabled={isSubmitting} {...form.getInputProps('position')} />
                    <Switch label={t('adminCamarero.manageMenu.categoryActiveLabel')} description={t('adminCamarero.manageMenu.categoryActiveDesc')} mt="sm" disabled={isSubmitting} {...form.getInputProps('isActive', { type: 'checkbox' })} />

                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={handleModalClose} disabled={isSubmitting}>
                            {t('common.cancel')}
                        </Button>
                        <Button type="submit" loading={isSubmitting} disabled={isSubmitting} leftSection={<IconDeviceFloppy size={18} />} >
                            {initialData ? t('common.save') : t('common.add')}
                        </Button>
                    </Group>
                </Stack>
            </form>
        </Modal>
    );
};

export default MenuCategoryFormModal;


// ====== [137] frontend/src/modules/camarero/components/admin/menu/MenuCategoryManager.tsx ======
// frontend/src/components/admin/camarero/menu/MenuCategoryManager.tsx
import React, { useState } from 'react';
import {
    Button,
    Text, 
    Stack,
    Group,
    Loader,
    Alert,
    Table,
    ActionIcon,
    Badge,
    Image as MantineImage,
    AspectRatio,
    Center,
    Tooltip,
    Box // <--- A√ëADIDO Box
} from '@mantine/core';
import { IconPlus, IconAlertCircle, IconPencil, IconTrash, IconPhoto, IconPlayerPlay, IconPlayerStop, IconListDetails } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useModals } from '@mantine/modals';

import { useAdminMenuCategories } from '../../../hooks/useAdminMenuCategories';
import { MenuCategoryData, MenuCategoryFormData } from '../../../types/menu.types';
import MenuCategoryFormModal from './MenuCategoryFormModal';

interface MenuCategoryManagerProps {
    onSelectCategoryForItems: (category: MenuCategoryData) => void;
}

const MenuCategoryManager: React.FC<MenuCategoryManagerProps> = ({ onSelectCategoryForItems }) => {
    const { t, i18n } = useTranslation();
    const modals = useModals();
    const currentLanguage = i18n.language;

    const {
        categories,
        loading: loadingCategories,
        error: errorCategories,
        addCategory,
        updateCategory,
        deleteCategory,
    } = useAdminMenuCategories();

    const [modalOpened, setModalOpened] = useState(false);
    const [editingCategory, setEditingCategory] = useState<MenuCategoryData | null>(null);
    const [isSubmittingForm, setIsSubmittingForm] = useState(false);
    const [isUpdatingStatusId, setIsUpdatingStatusId] = useState<string | null>(null);
    const [isDeletingId, setIsDeletingId] = useState<string | null>(null);

    // console.log("[MenuCategoryManager - V2 con Prop] Renderizando. Categor√≠as:", categories.length, "Loading:", loadingCategories);

    const handleOpenAddModal = () => { setEditingCategory(null); setModalOpened(true); };
    const handleOpenEditModal = (category: MenuCategoryData) => { setEditingCategory(category); setModalOpened(true); };
    const handleCloseModal = () => { setModalOpened(false); setEditingCategory(null); };

    const handleSubmitCategoryForm = async (formData: MenuCategoryFormData) => {
        setIsSubmittingForm(true);
        let success = false;
        if (editingCategory) {
            const result = await updateCategory(editingCategory.id, formData);
            if (result) success = true;
        } else {
            const result = await addCategory(formData);
            if (result) success = true;
        }
        if (success) { handleCloseModal(); }
        setIsSubmittingForm(false);
    };

    const handleDeleteCategoryClick = (category: MenuCategoryData) => {
        const categoryName = (currentLanguage === 'es' ? category.name_es : category.name_en) || category.name_es || `ID ${category.id}`;
        modals.openConfirmModal({
            title: t('adminCommon.confirmDeleteTitle'), centered: true,
            children: ( <Text size="sm"> {t('adminCommon.confirmDeleteMessage')}{' '} {t('adminCamarero.manageMenu.category')}: <strong>"{categoryName}"</strong>? </Text> ),
            labels: { confirm: t('common.delete'), cancel: t('common.cancel') }, confirmProps: { color: 'red' },
            onConfirm: async () => { setIsDeletingId(category.id); await deleteCategory(category.id); setIsDeletingId(null); },
        });
    };

    const handleToggleCategoryActive = async (category: MenuCategoryData) => {
        setIsUpdatingStatusId(category.id);
        const newStatus = !category.isActive;
        try { await updateCategory(category.id, { isActive: newStatus }); }
        catch (error) { console.error(`Error toggling status for category ${category.id}:`, error); }
        finally { setIsUpdatingStatusId(null); }
    };

    const rows = categories.map((category) => {
        const displayName = (currentLanguage === 'es' ? category.name_es : category.name_en) || category.name_es || 'N/A';
        const isLoadingThisRowStatus = isUpdatingStatusId === category.id;
        const isLoadingThisRowDelete = isDeletingId === category.id;
        const disableActions = isSubmittingForm || !!isDeletingId || !!isUpdatingStatusId;

        return (
            <Table.Tr key={category.id}>
                <Table.Td>
                    <AspectRatio ratio={16 / 9} w={60}>
                        {category.imageUrl ? ( <MantineImage src={category.imageUrl} alt={displayName} radius="xs" fit="contain" /> )
                         : ( <Center bg="gray.1" h="100%" style={{ borderRadius: 'var(--mantine-radius-xs)' }}> <IconPhoto size={24} color="var(--mantine-color-gray-5)" /> </Center> )}
                    </AspectRatio>
                </Table.Td>
                <Table.Td>
                    <Text fw={500}>{displayName}</Text>
                    {displayName !== category.name_es && category.name_es && <Text size="xs" c="dimmed">ES: {category.name_es}</Text>}
                    {displayName !== category.name_en && category.name_en && <Text size="xs" c="dimmed">EN: {category.name_en}</Text>}
                </Table.Td>
                <Table.Td>{category.position}</Table.Td>
                <Table.Td> <Badge color={category.isActive ? 'green' : 'gray'} variant="light"> {category.isActive ? t('common.active') : t('common.inactive')} </Badge> </Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        {/* Clave de traducci√≥n: "adminCamarero.manageMenu.viewItemsTooltip": "Ver/Gestionar √çtems de esta Categor√≠a" */}
                        <Tooltip label={t('adminCamarero.manageMenu.viewItemsTooltip')} withArrow position="top">
                            <Box> {/* <--- Envolver ActionIcon en Box */}
                                <ActionIcon variant="subtle" color="cyan" onClick={() => onSelectCategoryForItems(category)} disabled={disableActions || isLoadingThisRowStatus || isLoadingThisRowDelete} >
                                    <IconListDetails size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                        
                        <Tooltip label={t('common.edit')} withArrow position="top">
                            <Box> {/* <--- Envolver ActionIcon en Box */}
                                <ActionIcon variant="subtle" color="blue" onClick={() => handleOpenEditModal(category)} disabled={disableActions || isLoadingThisRowStatus || isLoadingThisRowDelete} >
                                    <IconPencil size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>

                        <Tooltip label={category.isActive ? t('adminRewardsPage.tooltipDeactivate') : t('adminRewardsPage.tooltipActivate')} withArrow position="top" >
                            <Box> {/* <--- Envolver ActionIcon en Box */}
                                <ActionIcon variant="subtle" color={category.isActive ? 'orange' : 'teal'} onClick={() => handleToggleCategoryActive(category)} loading={isLoadingThisRowStatus} disabled={disableActions || isLoadingThisRowDelete || (isUpdatingStatusId !== null && isUpdatingStatusId !== category.id)} >
                                    {category.isActive ? <IconPlayerStop size={16} /> : <IconPlayerPlay size={16} />}
                                </ActionIcon>
                            </Box>
                        </Tooltip>

                        <Tooltip label={t('common.delete')} withArrow position="top">
                            <Box> {/* <--- Envolver ActionIcon en Box */}
                                <ActionIcon variant="subtle" color="red" onClick={() => handleDeleteCategoryClick(category)} loading={isLoadingThisRowDelete} disabled={disableActions || isLoadingThisRowStatus || (isDeletingId !== null && isDeletingId !== category.id)} >
                                    <IconTrash size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    return (
        <Stack gap="md">
            <Group justify="space-between">
                {/* Clave de traducci√≥n: "adminCamarero.manageMenu.category": "Categor√≠a" */}
                <Button leftSection={<IconPlus size={16} />} onClick={handleOpenAddModal} disabled={loadingCategories || isSubmittingForm || !!isDeletingId || !!isUpdatingStatusId} >
                    {t('common.add')} {t('adminCamarero.manageMenu.category')}
                </Button>
            </Group>
            {loadingCategories && <Group justify="center" mt="xl"><Loader /></Group>}
            {errorCategories && !loadingCategories && ( <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{errorCategories}</Alert> )}
            {!loadingCategories && !errorCategories && categories.length === 0 && ( <Text c="dimmed" ta="center" mt="md">{t('common.noItems')}</Text> )}
            {!loadingCategories && !errorCategories && categories.length > 0 && (
                <Table.ScrollContainer minWidth={600}>
                    <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                        <Table.Thead>
                            <Table.Tr>
                                <Table.Th style={{width: '80px'}}>{t('component.rewardForm.imageLabel')}</Table.Th>
                                <Table.Th>{t('common.name')}</Table.Th>
                                <Table.Th>{t('adminCamarero.manageMenu.categoryPositionLabel')}</Table.Th>
                                <Table.Th>{t('common.status')}</Table.Th>
                                <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                            </Table.Tr>
                        </Table.Thead>
                        <Table.Tbody>{rows}</Table.Tbody>
                    </Table>
                </Table.ScrollContainer>
            )}
            <MenuCategoryFormModal opened={modalOpened} onClose={handleCloseModal} onSubmit={handleSubmitCategoryForm} initialData={editingCategory} isSubmitting={isSubmittingForm} />
        </Stack>
    );
};

export default MenuCategoryManager;


// ====== [138] frontend/src/modules/camarero/components/admin/menu/MenuItemFormModal.tsx ======
// frontend/src/components/admin/camarero/menu/MenuItemFormModal.tsx
// Version 2.0.0 (Refactored to use ImageUploadCropper component)

import React, { useEffect } from 'react';
import {
    Modal, TextInput, Textarea, NumberInput, Switch, Button, Group, Stack, MultiSelect, 
    NativeScrollArea, Title, useMantineTheme, Box, Text as MantineText
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next';
import {
    IconDeviceFloppy, IconCurrencyEuro, IconSettings
} from '@tabler/icons-react';
import { useDisclosure } from '@mantine/hooks';
import { MenuItemData, MenuItemFormData } from '../../../types/menu.types';

// Importar el componente reutilizable
import ImageUploadCropper from '../../../../../shared/components/utils/ImageUploadCropper';
import ModifierGroupsManagementModal from './ModifierGroupsManagementModal';

// El schema de Zod no cambia
const createItemFormSchema = (t: Function) => z.object({
    name_es: z.string().min(1, { message: t('common.requiredField') }),
    name_en: z.string().nullable().optional(),
    description_es: z.string().nullable().optional(),
    description_en: z.string().nullable().optional(),
    price: z.number().min(0, { message: t('validation.minValueMin0') }),
    imageUrl: z.string().url({ message: t('validation.invalidUrl') }).nullable().optional(),
    allergens: z.array(z.string()).optional(),
    tags: z.array(z.string()).optional(),
    isAvailable: z.boolean(),
    position: z.number().min(0, { message: t('validation.minValueMin0') }),
    preparationTime: z.number().min(0, { message: t('common.errorMustBePositiveOrZero') }).nullable().optional(),
    calories: z.number().min(0, { message: t('common.errorMustBePositiveOrZero') }).nullable().optional(),
    kdsDestination: z.string().nullable().optional(),
    sku: z.string().nullable().optional(),
});

type ItemFormValues = z.infer<ReturnType<typeof createItemFormSchema>>;

interface MenuItemFormModalProps {
    opened: boolean;
    onClose: () => void;
    onSubmit: (values: MenuItemFormData) => Promise<void>;
    initialData?: MenuItemData | null;
    isSubmitting: boolean;
    categoryId: string;
}

const MenuItemFormModal: React.FC<MenuItemFormModalProps> = ({
    opened,
    onClose,
    onSubmit,
    initialData,
    isSubmitting,
}) => {
    const { t } = useTranslation();
    const theme = useMantineTheme();
    
    const form = useForm<ItemFormValues>({
        initialValues: {
            name_es: '', name_en: null, description_es: null, description_en: null,
            price: 0, imageUrl: null, allergens: [], tags: [],
            isAvailable: true, position: 0, preparationTime: null, calories: null,
            kdsDestination: null, sku: null,
        },
        validate: zodResolver(createItemFormSchema(t)),
    });

    const [groupsModalOpened, { open: openGroupsModal, close: closeGroupsModal }] = useDisclosure(false);

    useEffect(() => {
        if (opened) {
            if (initialData) {
                form.setValues({
                    name_es: initialData.name_es, name_en: initialData.name_en || null,
                    description_es: initialData.description_es || null, description_en: initialData.description_en || null,
                    price: initialData.price, imageUrl: initialData.imageUrl || null,
                    allergens: initialData.allergens || [], tags: initialData.tags || [],
                    isAvailable: initialData.isAvailable, position: initialData.position,
                    preparationTime: initialData.preparationTime || null, calories: initialData.calories || null,
                    kdsDestination: initialData.kdsDestination || null, sku: initialData.sku || null,
                });
            } else {
                form.reset();
            }
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, initialData]);

    const handleSubmitForm = async (values: ItemFormValues) => {
        const submitData: MenuItemFormData = {
            ...values,
            name_en: values.name_en?.trim() || null,
            description_es: values.description_es?.trim() || null,
            description_en: values.description_en?.trim() || null,
            imageUrl: values.imageUrl || null,
            allergens: values.allergens || [],
            tags: values.tags || [],
            preparationTime: values.preparationTime ?? null,
            calories: values.calories ?? null,
            kdsDestination: values.kdsDestination?.trim() || null,
            sku: values.sku?.trim() || null,
        };
        await onSubmit(submitData);
    };

    const handleModalClose = () => { if (!isSubmitting) onClose(); }
    
    const allergenOptions = ['GLUTEN', 'LACTOSE', 'NUTS', 'SOY', 'FISH', 'CRUSTACEANS', 'CELERY', 'MUSTARD', 'SESAME', 'SULPHITES', 'LUPIN', 'MOLLUSCS'].map(val => ({value: val, label: t(`adminCamarero.menuItem.allergen.${val}`, val)}));
    const tagOptions = ['VEGAN', 'VEGETARIAN', 'SPICY', 'NEW', 'POPULAR', 'HOUSE_SPECIAL'].map(val => ({value: val, label: t(`adminCamarero.menuItem.tag.${val}`, val)}));

    const allergenInputProps = form.getInputProps('allergens');
    const tagInputProps = form.getInputProps('tags');

    const menuItemIdForGroupsModal = initialData ? initialData.id : null;
    const menuItemDisplayNameForModal = initialData ? (initialData.name_es || initialData.name_en || t('adminCamarero.manageMenu.itemFallbackName')) : t('adminCamarero.manageMenu.itemNew');

    return (
        <>
            <Modal
                opened={opened} onClose={handleModalClose}
                title={initialData ? t('adminCamarero.manageMenu.editItemTitle') : t('adminCamarero.manageMenu.addItemTitle')}
                centered size="xl"
                overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
                trapFocus closeOnClickOutside={!isSubmitting} closeOnEscape={!isSubmitting}
                scrollAreaComponent={NativeScrollArea}
            >
                <form onSubmit={form.onSubmit(handleSubmitForm)}>
                    <Stack gap="md">
                        <Group grow>
                            <TextInput label={t('component.rewardForm.nameEsLabel')} placeholder={t('adminCamarero.manageMenu.itemNameEsPlaceholder')} required disabled={isSubmitting} {...form.getInputProps('name_es')} />
                            <TextInput label={t('component.rewardForm.nameEnLabel')} placeholder={t('adminCamarero.manageMenu.itemNameEnPlaceholder')} disabled={isSubmitting} {...form.getInputProps('name_en')} />
                        </Group>
                        <Textarea label={t('component.rewardForm.descriptionEsLabel')} placeholder={t('adminCamarero.manageMenu.itemDescEsPlaceholder')} rows={3} disabled={isSubmitting} {...form.getInputProps('description_es')} />
                        <Textarea label={t('component.rewardForm.descriptionEnLabel')} placeholder={t('adminCamarero.manageMenu.itemDescEnPlaceholder')} rows={3} disabled={isSubmitting} {...form.getInputProps('description_en')} />

                        <NumberInput
                            label={t('adminCamarero.manageMenu.itemPrice')}
                            placeholder="0.00" required min={0} step={0.01} decimalScale={2} fixedDecimalScale
                            leftSection={<IconCurrencyEuro size={16} />}
                            disabled={isSubmitting}
                            {...form.getInputProps('price')}
                        />
                        
                        <ImageUploadCropper
                            aspectRatio={1}
                            minDimension={150}
                            initialImageUrl={form.values.imageUrl || null}
                            onUploadSuccess={(url) => form.setFieldValue('imageUrl', url)}
                            onUploadError={(errorMsg) => form.setFieldError('imageUrl', errorMsg)}
                            onClearImage={() => form.setFieldValue('imageUrl', null)}
                            folderName="loyalpyme/menu-items"
                            disabled={isSubmitting}
                            imagePreviewAltText={t('adminCamarero.menuItemForm.altPreview')}
                            imageToCropAltText={t('adminCamarero.menuItemForm.altCropImage')}
                        />
                         {form.errors.imageUrl && (
                            <MantineText c="red" size="xs" mt={-10}>{form.errors.imageUrl}</MantineText>
                        )}

                        <MultiSelect
                            label={t('adminCamarero.manageMenu.itemAllergens')}
                            placeholder={t('adminCamarero.manageMenu.itemAllergensPlaceholder')}
                            data={allergenOptions}
                            searchable
                            // @ts-expect-error creatable is a valid prop for Mantine v7 MultiSelect
                            creatable
                            getCreateLabel={(query: string) => `+ ${t('common.add')} "${query}"`}
                            disabled={isSubmitting}
                            {...allergenInputProps}
                        />
                        <MultiSelect
                            label={t('adminCamarero.manageMenu.itemTags')}
                            placeholder={t('adminCamarero.manageMenu.itemTagsPlaceholder')}
                            data={tagOptions}
                            searchable
                            // @ts-expect-error creatable is a valid prop for Mantine v7 MultiSelect
                            creatable
                            getCreateLabel={(query: string) => `+ ${t('common.add')} "${query}"`}
                            disabled={isSubmitting}
                            {...tagInputProps}
                        />
                        <Group grow>
                            <NumberInput label={t('adminCamarero.manageMenu.itemPosition')} placeholder="0" min={0} step={1} allowDecimal={false} disabled={isSubmitting} {...form.getInputProps('position')} />
                            <NumberInput label={t('adminCamarero.manageMenu.itemPrepTime')} placeholder={t('common.optional')} min={0} step={1} allowDecimal={false} disabled={isSubmitting} {...form.getInputProps('preparationTime')} />
                        </Group>
                        <Group grow>
                            <NumberInput label={t('adminCamarero.manageMenu.itemCalories')} placeholder={t('common.optional')} min={0} step={1} allowDecimal={false} disabled={isSubmitting} {...form.getInputProps('calories')} />
                            <TextInput label={t('adminCamarero.manageMenu.itemSku')} placeholder={t('common.optional')} disabled={isSubmitting} {...form.getInputProps('sku')} />
                        </Group>
                        <TextInput label={t('adminCamarero.manageMenu.itemKds')} placeholder={t('adminCamarero.manageMenu.itemKdsPlaceholder')} description={t('adminCamarero.manageMenu.itemKdsDesc')} disabled={isSubmitting} {...form.getInputProps('kdsDestination')} />
                        <Switch label={t('adminCamarero.manageMenu.itemIsAvailable')} description={t('adminCamarero.manageMenu.itemIsAvailableDesc')} mt="sm" disabled={isSubmitting} {...form.getInputProps('isAvailable', { type: 'checkbox' })} />

                        {initialData && (
                            <Box mt="lg" pt="lg" style={{ borderTop: `1px solid ${theme.colors.gray[3]}` }}>
                                <Group justify="space-between" mb="sm">
                                    <Title order={5}>{t('adminCamarero.manageMenu.modifierGroupsTitle')}</Title>
                                    <Button
                                        variant="outline" size="xs"
                                        leftSection={<IconSettings size={16} />}
                                        onClick={openGroupsModal}
                                        disabled={isSubmitting}
                                    >
                                        {t('adminCamarero.manageMenu.manageGroupsButton')}
                                    </Button>
                                </Group>
                                <MantineText size="xs" c="dimmed" mb="md">
                                    {t('adminCamarero.manageMenu.modifierGroupsDescription')}
                                </MantineText>
                            </Box>
                        )}

                        <Group justify="flex-end" mt="lg">
                            <Button variant="default" onClick={handleModalClose} disabled={isSubmitting}>{t('common.cancel')}</Button>
                            <Button type="submit" loading={isSubmitting} leftSection={<IconDeviceFloppy size={18} />} >
                                {initialData ? t('common.save') : t('common.add')}
                            </Button>
                        </Group>
                    </Stack>
                </form>
            </Modal>

            {initialData && menuItemIdForGroupsModal && (
                <ModifierGroupsManagementModal
                    opened={groupsModalOpened}
                    onClose={closeGroupsModal}
                    menuItemId={menuItemIdForGroupsModal}
                    menuItemName={menuItemDisplayNameForModal}
                />
            )}
        </>
    );
};

export default MenuItemFormModal;


// ====== [139] frontend/src/modules/camarero/components/admin/menu/MenuItemManager.tsx ======
// frontend/src/components/admin/camarero/menu/MenuItemManager.tsx
// Version 1.0.1 (Remove unused categoryName prop)

import React, { useState } from 'react';
import {
    Box, Button, Text, Stack, Group, Loader, Alert,
    Table, ActionIcon, Badge, Tooltip,
    Image as MantineImage, AspectRatio, Center,
} from '@mantine/core';
import {
    IconPlus, IconAlertCircle, IconPencil, IconTrash, IconPhoto,
    IconPlayerPlay, IconPlayerStop, IconFileDescription
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useModals } from '@mantine/modals';
import { notifications } from '@mantine/notifications'; // A√±adido para handleManageModifiers

import { useAdminMenuItems } from '../../../hooks/useAdminMenuItems';
import { MenuItemData, MenuItemFormData } from '../../../types/menu.types';
import MenuItemFormModal from './MenuItemFormModal';

interface MenuItemManagerProps {
    categoryId: string;
    // categoryName: string; // <-- PROP ELIMINADA
}

// --- CORRECCI√ìN: Quitar categoryName de la desestructuraci√≥n ---
const MenuItemManager: React.FC<MenuItemManagerProps> = ({ categoryId /*, categoryName*/ }) => {
    const { t, i18n } = useTranslation();
    const modals = useModals();
    const currentLanguage = i18n.language;

    const {
        items,
        loading: loadingItems,
        error: errorItems,
        addItem,
        updateItem,
        deleteItem,
    } = useAdminMenuItems(categoryId);

    const [itemModalOpened, setItemModalOpened] = useState(false);
    const [editingItem, setEditingItem] = useState<MenuItemData | null>(null);
    const [isSubmittingItemForm, setIsSubmittingItemForm] = useState(false);
    const [isUpdatingItemStatusId, setIsUpdatingItemStatusId] = useState<string | null>(null);
    const [isDeletingItemId, setIsDeletingItemId] = useState<string | null>(null);

    const handleOpenAddItemModal = () => {
        setEditingItem(null);
        setItemModalOpened(true);
    };

    const handleOpenEditItemModal = (item: MenuItemData) => {
        setEditingItem(item);
        setItemModalOpened(true);
    };

    const handleCloseItemModal = () => {
        setItemModalOpened(false);
        setEditingItem(null);
    };

    const handleSubmitItemForm = async (formData: MenuItemFormData) => {
        setIsSubmittingItemForm(true);
        let success = false;
        if (editingItem) {
            const result = await updateItem(editingItem.id, formData);
            if (result) success = true;
        } else {
            const result = await addItem(formData);
            if (result) success = true;
        }
        if (success) {
            handleCloseItemModal();
        }
        setIsSubmittingItemForm(false);
    };

    const handleToggleItemAvailable = async (item: MenuItemData) => {
        setIsUpdatingItemStatusId(item.id);
        const newStatus = !item.isAvailable;
        try {
            // Asegurarse de que solo se env√≠a el campo que se quiere actualizar
            await updateItem(item.id, { isAvailable: newStatus });
        } catch (error) {
            console.error(`Error toggling availability for item ${item.id}:`, error);
            // La notificaci√≥n de error ya la maneja el hook si ocurre
        } finally {
            setIsUpdatingItemStatusId(null);
        }
    };

    const handleDeleteItemClick = (item: MenuItemData) => {
        const itemName = (currentLanguage === 'es' && item.name_es) ? item.name_es : (item.name_en || item.name_es || t('adminCamarero.manageMenu.itemFallbackName'));
        modals.openConfirmModal({
            title: t('adminCommon.confirmDeleteTitle'),
            centered: true,
            children: ( <Text size="sm"> {t('adminCommon.confirmDeleteMessage')}{' '} {t('adminCamarero.manageMenu.itemLabel')}: <strong>"{itemName}"</strong>? </Text> ),
            labels: { confirm: t('common.delete'), cancel: t('common.cancel') },
            confirmProps: { color: 'red' },
            onConfirm: async () => {
                setIsDeletingItemId(item.id);
                await deleteItem(item.id); // El hook maneja la notificaci√≥n
                setIsDeletingItemId(null);
            },
        });
    };
    
    const handleManageModifiers = (item: MenuItemData) => {
        const itemName = (currentLanguage === 'es' && item.name_es) ? item.name_es : (item.name_en || item.name_es || t('adminCamarero.manageMenu.itemFallbackName'));
        // Implementaci√≥n real para abrir el modal de modificadores
        // Esto es solo un placeholder:
        notifications.show({
             title: t('common.upcomingFeatureTitle'),
             message: `${t('adminCamarero.manageMenu.manageModifiersTooltip')} para: ${itemName} (ID: ${item.id})`,
             color: 'blue'
        });
        console.log("Abrir modal de modificadores para el √≠tem:", item.id, itemName);
    };


    const rows = items.map((item) => {
        const displayName = (currentLanguage === 'es' && item.name_es) ? item.name_es : (item.name_en || item.name_es || t('common.nameNotAvailable'));
        const isLoadingThisRowStatus = isUpdatingItemStatusId === item.id;
        const isLoadingThisRowDelete = isDeletingItemId === item.id;
        const disableActions = isSubmittingItemForm || !!isDeletingItemId || !!isUpdatingItemStatusId;
        const itemAvailabilityText = item.isAvailable ? t('adminCamarero.manageMenu.itemAvailable') : t('adminCamarero.manageMenu.itemNotAvailable');
        const tooltipToggleAvailable = item.isAvailable ? t('adminCamarero.manageMenu.markNotAvailable') : t('adminCamarero.manageMenu.markAvailable');

        return (
            <Table.Tr key={item.id}>
                <Table.Td>
                    <AspectRatio ratio={1 / 1} w={50}>
                        {item.imageUrl ? ( <MantineImage src={item.imageUrl} alt={displayName} radius="xs" fit="cover" fallbackSrc="/placeholder-item.png" /> )
                         : ( <Center bg="gray.1" h="100%" style={{ borderRadius: 'var(--mantine-radius-xs)' }}> <IconPhoto size={20} color="var(--mantine-color-gray-5)" /> </Center> )}
                    </AspectRatio>
                </Table.Td>
                <Table.Td>
                    <Text fw={500}>{displayName}</Text>
                    {displayName !== item.name_es && item.name_es && <Text size="xs" c="dimmed">ES: {item.name_es}</Text>}
                    {displayName !== item.name_en && item.name_en && <Text size="xs" c="dimmed">EN: {item.name_en}</Text>}
                </Table.Td>
                <Table.Td ta="right">{Number(item.price).toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}</Table.Td>
                <Table.Td>{item.position}</Table.Td>
                <Table.Td>
                    <Badge color={item.isAvailable ? 'green' : 'gray'} variant="light">
                        {itemAvailabilityText}
                    </Badge>
                </Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        <Tooltip label={t('adminCamarero.manageMenu.manageModifiersTooltip')} withArrow position="top">
                            <Box>
                                <ActionIcon variant="subtle" color="violet" onClick={() => handleManageModifiers(item)} disabled={disableActions || isLoadingThisRowStatus || isLoadingThisRowDelete}>
                                    <IconFileDescription size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                        <Tooltip label={t('common.edit')} withArrow position="top">
                            <Box>
                                <ActionIcon variant="subtle" color="blue" onClick={() => handleOpenEditItemModal(item)} disabled={disableActions || isLoadingThisRowStatus || isLoadingThisRowDelete} >
                                    <IconPencil size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                        <Tooltip label={tooltipToggleAvailable} withArrow position="top" >
                           <Box>
                                <ActionIcon
                                    variant="subtle"
                                    color={item.isAvailable ? "orange" : "teal"}
                                    onClick={() => handleToggleItemAvailable(item)}
                                    loading={isLoadingThisRowStatus}
                                    disabled={disableActions || isLoadingThisRowDelete || (isUpdatingItemStatusId !== null && isUpdatingItemStatusId !== item.id)}
                                >
                                    {item.isAvailable ? <IconPlayerStop size={16} /> : <IconPlayerPlay size={16} />}
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                        <Tooltip label={t('common.delete')} withArrow position="top">
                            <Box>
                                <ActionIcon
                                    variant="subtle"
                                    color="red"
                                    onClick={() => handleDeleteItemClick(item)}
                                    loading={isLoadingThisRowDelete}
                                    disabled={disableActions || isLoadingThisRowStatus || (isDeletingItemId !== null && isDeletingItemId !== item.id)}
                                >
                                    <IconTrash size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    return (
        <Stack gap="md" mt="lg">
            <Group justify="space-between">
                <Button
                    leftSection={<IconPlus size={16} />}
                    onClick={handleOpenAddItemModal}
                    disabled={loadingItems || isSubmittingItemForm || !!isDeletingItemId || !!isUpdatingItemStatusId}
                >
                    {t('common.add')} {t('adminCamarero.manageMenu.itemLabel')}
                </Button>
            </Group>

            {loadingItems && <Group justify="center" mt="xl"><Loader /></Group>}
            {errorItems && !loadingItems && (
                <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{errorItems}</Alert>
            )}

            {!loadingItems && !errorItems && items.length === 0 && (
                <Text c="dimmed" ta="center" mt="md">
                    {t('adminCamarero.manageMenu.noItemsInCategory')}
                </Text>
            )}

            {!loadingItems && !errorItems && items.length > 0 && (
                <Table.ScrollContainer minWidth={700}>
                    <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                        <Table.Thead>
                            <Table.Tr>
                                <Table.Th style={{width: '70px'}}>{t('adminCamarero.manageMenu.itemImageLabel')}</Table.Th>
                                <Table.Th>{t('common.name')}</Table.Th>
                                <Table.Th ta="right">{t('adminCamarero.manageMenu.itemPrice')}</Table.Th>
                                <Table.Th>{t('adminCamarero.manageMenu.itemPosition')}</Table.Th>
                                <Table.Th>{t('adminCamarero.manageMenu.itemAvailability')}</Table.Th>
                                <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                            </Table.Tr>
                        </Table.Thead>
                        <Table.Tbody>{rows}</Table.Tbody>
                    </Table>
                </Table.ScrollContainer>
            )}

            {categoryId && ( // categoryId existe porque es una prop requerida
                 <MenuItemFormModal
                    opened={itemModalOpened}
                    onClose={handleCloseItemModal}
                    onSubmit={handleSubmitItemForm}
                    initialData={editingItem}
                    isSubmitting={isSubmittingItemForm}
                    categoryId={categoryId}
                />
            )}
        </Stack>
    );
};

export default MenuItemManager;


// ====== [140] frontend/src/modules/camarero/components/admin/menu/ModifierGroupsManagementModal.tsx ======
// frontend/src/components/admin/camarero/menu/ModifierGroupsManagementModal.tsx
import React, { useState, useEffect } from 'react';
import {
    Modal, Button, Stack, Group, Title, Text, Loader, Alert,
    Table, ActionIcon, Badge, Tooltip, TextInput, Select, NumberInput, Switch,
    Paper, Divider, NativeScrollArea
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import { z } from 'zod';
import {
    IconPlus, IconAlertCircle, IconPencil, IconTrash, IconDeviceFloppy, IconSettings
} from '@tabler/icons-react';
import { useAdminModifierGroups } from '../../../hooks/useAdminModifierGroups';
import { ModifierGroupData, ModifierGroupFormData, ModifierUiType } from '../../../types/menu.types';
import ModifierOptionsManagementModal from './ModifierOptionsManagementModal';
import { useTranslation } from 'react-i18next'; // Asegurarse de importar

const createModifierGroupSchema = (t: Function) => z.object({
    name_es: z.string().min(1, { message: t('adminCamarero.modifierGroupForm.validation.nameEsRequired') }),
    name_en: z.string().nullable().optional(),
    uiType: z.nativeEnum(ModifierUiType, { errorMap: () => ({ message: t('adminCamarero.modifierGroupForm.validation.uiTypeInvalid') }) }),
    minSelections: z.number().min(0, { message: t('adminCamarero.modifierGroupForm.validation.minSelectionsInvalid') }).default(0),
    maxSelections: z.number().min(1, { message: t('adminCamarero.modifierGroupForm.validation.maxSelectionsInvalid') }).default(1),
    position: z.number().min(0).default(0),
    isRequired: z.boolean().default(false),
}).refine(data => data.minSelections <= data.maxSelections, {
    message: t('adminCamarero.modifierGroupForm.validation.minMaxMismatch'),
    path: ["maxSelections"],
});

type ModifierGroupFormValues = z.infer<ReturnType<typeof createModifierGroupSchema>>;

interface ModifierGroupsManagementModalProps {
    opened: boolean;
    onClose: () => void;
    menuItemId: string | null;
    menuItemName: string;
}

const ModifierGroupsManagementModal: React.FC<ModifierGroupsManagementModalProps> = ({
    opened,
    onClose,
    menuItemId,
    menuItemName,
}) => {
    const { t, i18n } = useTranslation(); // A√±adir i18n para currentLanguage si es necesario
    const currentLanguage = i18n.language;

    const {
        modifierGroups,
        loading: loadingGroups,
        error: errorGroups,
        addModifierGroup,
        updateModifierGroup,
        deleteModifierGroup,
        fetchModifierGroups,
    } = useAdminModifierGroups(menuItemId);

    const [showForm, setShowForm] = useState(false);
    const [editingGroup, setEditingGroup] = useState<ModifierGroupData | null>(null);
    const [isSubmittingForm, setIsSubmittingForm] = useState(false);
    const [isDeletingGroupId, setIsDeletingGroupId] = useState<string | null>(null);

    const [optionsModalOpened, { open: openOptionsModal, close: closeOptionsModal }] = useDisclosure(false);
    const [selectedGroupForOptions, setSelectedGroupForOptions] = useState<ModifierGroupData | null>(null);

    const form = useForm<ModifierGroupFormValues>({
        initialValues: {
            name_es: '', name_en: null, uiType: ModifierUiType.RADIO,
            minSelections: 0, maxSelections: 1, position: 0, isRequired: false,
        },
        validate: zodResolver(createModifierGroupSchema(t)),
    });

    useEffect(() => {
        if (opened && menuItemId) {
            fetchModifierGroups();
        }
        if (!opened) {
            setShowForm(false);
            setEditingGroup(null);
            form.reset();
            closeOptionsModal();
            setSelectedGroupForOptions(null);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, menuItemId, closeOptionsModal]);

    const handleOpenAddForm = () => {
        setEditingGroup(null);
        form.reset();
        form.setFieldValue('position', modifierGroups.length > 0 ? Math.max(...modifierGroups.map(g => g.position)) + 1 : 0);
        setShowForm(true);
    };

    const handleOpenEditForm = (group: ModifierGroupData) => {
        setEditingGroup(group);
        form.setValues({
            name_es: group.name_es,
            name_en: group.name_en || null,
            uiType: group.uiType,
            minSelections: group.minSelections,
            maxSelections: group.maxSelections,
            position: group.position,
            isRequired: group.isRequired,
        });
        setShowForm(true);
    };

    const handleFormSubmit = async (values: ModifierGroupFormValues) => {
        if (!menuItemId) return;
        setIsSubmittingForm(true);
        const formData: ModifierGroupFormData = {
            name_es: values.name_es,
            name_en: values.name_en || null,
            uiType: values.uiType,
            minSelections: values.minSelections,
            maxSelections: values.maxSelections,
            position: values.position,
            isRequired: values.isRequired,
        };

        let success = false;
        if (editingGroup) {
            const result = await updateModifierGroup(editingGroup.id, formData);
            if (result) success = true;
        } else {
            const result = await addModifierGroup(formData);
            if (result) success = true;
        }

        if (success) {
            setShowForm(false);
            setEditingGroup(null);
            form.reset();
        }
        setIsSubmittingForm(false);
    };

    const handleDeleteGroup = async (groupId: string) => {
        setIsDeletingGroupId(groupId);
        await deleteModifierGroup(groupId); // El hook se encarga de la notificaci√≥n
        setIsDeletingGroupId(null);
    };

    const handleManageOptions = (group: ModifierGroupData) => {
        setSelectedGroupForOptions(group);
        openOptionsModal();
    };

    const groupRows = modifierGroups.map((group) => {
        const groupDisplayName = (currentLanguage === 'es' && group.name_es) ? group.name_es : (group.name_en || group.name_es || t('common.nameNotAvailable'));
        return (
            <Table.Tr key={group.id}>
                <Table.Td>
                    <Text fw={500}>{groupDisplayName}</Text>
                    {groupDisplayName !== group.name_es && group.name_es && <Text size="xs" c="dimmed">ES: {group.name_es}</Text>}
                    {groupDisplayName !== group.name_en && group.name_en && <Text size="xs" c="dimmed">EN: {group.name_en}</Text>}
                </Table.Td>
                <Table.Td><Badge color="cyan" variant="light">{group.uiType}</Badge></Table.Td>
                <Table.Td>{group.minSelections} - {group.maxSelections}</Table.Td>
                <Table.Td>{group.isRequired ? t('common.yes') : t('common.no')}</Table.Td>
                <Table.Td>{group.position}</Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        <Tooltip label={t('adminCamarero.modifierGroupsModal.tooltipManageOptions')} withArrow>
                            <ActionIcon variant="subtle" color="green" onClick={() => handleManageOptions(group)} disabled={!!isDeletingGroupId}>
                                <IconSettings size={16} />
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={t('adminCamarero.modifierGroupsModal.tooltipEditGroup')} withArrow>
                            <ActionIcon variant="subtle" color="blue" onClick={() => handleOpenEditForm(group)} disabled={!!isDeletingGroupId}>
                                <IconPencil size={16} />
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={t('adminCamarero.modifierGroupsModal.tooltipDeleteGroup')} withArrow>
                            <ActionIcon variant="subtle" color="red" onClick={() => handleDeleteGroup(group.id)} loading={isDeletingGroupId === group.id} disabled={!!isDeletingGroupId && isDeletingGroupId !== group.id}>
                                <IconTrash size={16} />
                            </ActionIcon>
                        </Tooltip>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    const uiTypeOptions = Object.values(ModifierUiType).map(type => ({
        value: type,
        label: t(`adminCamarero.modifierGroupForm.uiType.${type}`, type) // Claves como 'adminCamarero.modifierGroupForm.uiType.RADIO'
    }));


    return (
        <>
            <Modal
                opened={opened && !!menuItemId}
                onClose={onClose}
                title={t('adminCamarero.modifierGroupsModal.title', { itemName: menuItemName })}
                size="xl"
                centered
                scrollAreaComponent={NativeScrollArea}
                overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
            >
                <Stack gap="lg">
                    {!showForm ? (
                        <>
                            <Group justify="space-between">
                                <Title order={5}>{t('adminCamarero.modifierGroupsModal.existingGroupsTitle')}</Title>
                                <Button leftSection={<IconPlus size={16} />} onClick={handleOpenAddForm} disabled={loadingGroups}>
                                    {t('adminCamarero.modifierGroupsModal.createNewGroupButton')}
                                </Button>
                            </Group>

                            {loadingGroups && <Group justify="center" mt="md"><Loader /></Group>}
                            {errorGroups && !loadingGroups && <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{errorGroups}</Alert>}
                            {!loadingGroups && !errorGroups && modifierGroups.length === 0 && <Text c="dimmed" ta="center" mt="md">{t('adminCamarero.modifierGroupsModal.noGroupsForItem')}</Text>}
                            {!loadingGroups && !errorGroups && modifierGroups.length > 0 && (
                                <Table.ScrollContainer minWidth={600}>
                                    <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                                        <Table.Thead>
                                            <Table.Tr>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderName')}</Table.Th>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderUiType')}</Table.Th>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderSelections')}</Table.Th>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderRequired')}</Table.Th>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderPosition')}</Table.Th>
                                                <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                                            </Table.Tr>
                                        </Table.Thead>
                                        <Table.Tbody>{groupRows}</Table.Tbody>
                                    </Table>
                                </Table.ScrollContainer>
                            )}
                        </>
                    ) : (
                        <Paper withBorder p="md" radius="md">
                            <Title order={5} mb="md">{editingGroup ? t('adminCamarero.modifierGroupsModal.formEditTitle', { groupName: (currentLanguage === 'es' && editingGroup.name_es) ? editingGroup.name_es : (editingGroup.name_en || editingGroup.name_es || '') }) : t('adminCamarero.modifierGroupsModal.formCreateTitle')}</Title>
                            <form onSubmit={form.onSubmit(handleFormSubmit)}>
                                <Stack gap="sm">
                                    <TextInput label={t('adminCamarero.modifierGroupForm.nameEsLabel')} required {...form.getInputProps('name_es')} disabled={isSubmittingForm} />
                                    <TextInput label={t('adminCamarero.modifierGroupForm.nameEnLabel')} {...form.getInputProps('name_en')} disabled={isSubmittingForm} />
                                    <Select
                                        label={t('adminCamarero.modifierGroupForm.uiTypeLabel')}
                                        data={uiTypeOptions}
                                        required
                                        {...form.getInputProps('uiType')}
                                        disabled={isSubmittingForm}
                                    />
                                    <Group grow>
                                        <NumberInput label={t('adminCamarero.modifierGroupForm.minSelectionsLabel')} min={0} {...form.getInputProps('minSelections')} disabled={isSubmittingForm} />
                                        <NumberInput label={t('adminCamarero.modifierGroupForm.maxSelectionsLabel')} min={1} {...form.getInputProps('maxSelections')} disabled={isSubmittingForm} />
                                    </Group>
                                    <NumberInput label={t('adminCamarero.modifierGroupForm.positionLabel')} min={0} {...form.getInputProps('position')} disabled={isSubmittingForm} />
                                    <Switch label={t('adminCamarero.modifierGroupForm.isRequiredLabel')} {...form.getInputProps('isRequired', { type: 'checkbox' })} disabled={isSubmittingForm} />

                                    <Group justify="flex-end" mt="md">
                                        <Button variant="default" onClick={() => { setShowForm(false); setEditingGroup(null); form.reset(); }} disabled={isSubmittingForm}>
                                            {t('common.cancel')}
                                        </Button>
                                        <Button type="submit" loading={isSubmittingForm} leftSection={<IconDeviceFloppy size={16} />}>
                                            {editingGroup ? t('common.saveChanges') : t('adminCamarero.modifierGroupsModal.formCreateButton')}
                                        </Button>
                                    </Group>
                                </Stack>
                            </form>
                        </Paper>
                    )}
                    <Divider mt="lg" />
                    <Group justify="flex-end" mt="md">
                        <Button variant="outline" onClick={onClose}>{t('adminCamarero.modifierGroupsModal.closeButton')}</Button>
                    </Group>
                </Stack>
            </Modal>

            {selectedGroupForOptions && (
                <ModifierOptionsManagementModal
                    opened={optionsModalOpened}
                    onClose={() => {
                        closeOptionsModal();
                        setSelectedGroupForOptions(null);
                        fetchModifierGroups();
                    }}
                    modifierGroupId={selectedGroupForOptions.id}
                    modifierGroupName={(currentLanguage === 'es' && selectedGroupForOptions.name_es) ? selectedGroupForOptions.name_es : (selectedGroupForOptions.name_en || selectedGroupForOptions.name_es || t('common.nameNotAvailable'))}
                />
            )}
        </>
    );
};

export default ModifierGroupsManagementModal;


// ====== [141] frontend/src/modules/camarero/components/admin/menu/ModifierOptionsManagementModal.tsx ======
// frontend/src/components/admin/camarero/menu/ModifierOptionsManagementModal.tsx
import React, { useState, useEffect } from 'react';
import {
    Modal, Button, Stack, Group, Title, Text, Loader, Alert,
    Table, ActionIcon, Badge, Tooltip, TextInput, NumberInput, Switch,
    Paper, Divider, NativeScrollArea
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import {
    IconPlus, IconAlertCircle, IconPencil, IconTrash, IconDeviceFloppy, IconCurrencyEuro,
    IconPlayerPlay, IconPlayerStop
} from '@tabler/icons-react';
import { useAdminModifierOptions } from '../../../hooks/useAdminModifierOptions';
import { ModifierOptionData, ModifierOptionFormData } from '../../../types/menu.types';
import { useTranslation } from 'react-i18next'; // Asegurarse de importar

// Schema de validaci√≥n Zod usando la funci√≥n t
const createModifierOptionSchema = (t: Function) => z.object({
    name_es: z.string().min(1, { message: t('adminCamarero.modifierOptionForm.validation.nameEsRequired') }),
    name_en: z.string().nullable().optional(),
    priceAdjustment: z.coerce.number().default(0),
    position: z.coerce.number().min(0).default(0),
    isDefault: z.boolean().default(false),
    isAvailable: z.boolean().default(true),
});

type ModifierOptionFormValues = z.infer<ReturnType<typeof createModifierOptionSchema>>;

interface ModifierOptionsManagementModalProps {
    opened: boolean;
    onClose: () => void;
    modifierGroupId: string | null;
    modifierGroupName: string;
}

const ModifierOptionsManagementModal: React.FC<ModifierOptionsManagementModalProps> = ({
    opened,
    onClose,
    modifierGroupId,
    modifierGroupName,
}) => {
    const { t, i18n } = useTranslation(); // A√±adir i18n para currentLanguage si es necesario
    const currentLanguage = i18n.language;

    const {
        modifierOptions,
        loading: loadingOptions,
        error: errorOptions,
        addModifierOption,
        updateModifierOption,
        deleteModifierOption,
        fetchModifierOptions,
    } = useAdminModifierOptions(modifierGroupId);

    const [showOptionForm, setShowOptionForm] = useState(false);
    const [editingOption, setEditingOption] = useState<ModifierOptionData | null>(null);
    const [isSubmittingOptionForm, setIsSubmittingOptionForm] = useState(false);
    const [isDeletingOptionId, setIsDeletingOptionId] = useState<string | null>(null);
    const [isTogglingStatusOptionId, setIsTogglingStatusOptionId] = useState<string | null>(null);

    const form = useForm<ModifierOptionFormValues>({
        initialValues: {
            name_es: '', name_en: null, priceAdjustment: 0,
            position: 0, isDefault: false, isAvailable: true,
        },
        validate: zodResolver(createModifierOptionSchema(t)), // Pasar t al resolver
    });

    useEffect(() => {
        if (opened && modifierGroupId) {
            fetchModifierOptions();
        }
        if (!opened) {
            setShowOptionForm(false);
            setEditingOption(null);
            form.reset();
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, modifierGroupId]);

    const handleOpenAddOptionForm = () => {
        setEditingOption(null);
        form.reset();
        form.setFieldValue('position', modifierOptions.length > 0 ? Math.max(...modifierOptions.map(o => o.position)) + 1 : 0);
        setShowOptionForm(true);
    };

    const handleOpenEditOptionForm = (option: ModifierOptionData) => {
        setEditingOption(option);
        form.setValues({
            name_es: option.name_es,
            name_en: option.name_en || null,
            priceAdjustment: Number(option.priceAdjustment),
            position: Number(option.position),
            isDefault: option.isDefault,
            isAvailable: option.isAvailable,
        });
        setShowOptionForm(true);
    };

    const handleOptionFormSubmit = async (values: ModifierOptionFormValues) => {
        if (!modifierGroupId) return;
        setIsSubmittingOptionForm(true);
        const formData: ModifierOptionFormData = {
            name_es: values.name_es,
            name_en: values.name_en || null,
            priceAdjustment: values.priceAdjustment,
            position: values.position,
            isDefault: values.isDefault,
            isAvailable: values.isAvailable,
        };
        let success = false;
        if (editingOption) {
            const result = await updateModifierOption(editingOption.id, formData);
            if (result) success = true;
        } else {
            const result = await addModifierOption(formData);
            if (result) success = true;
        }
        if (success) {
            setShowOptionForm(false);
            setEditingOption(null);
            form.reset();
        }
        setIsSubmittingOptionForm(false);
    };

    const handleDeleteOption = async (optionId: string) => {
        setIsDeletingOptionId(optionId);
        await deleteModifierOption(optionId); // El hook maneja la notificaci√≥n
        setIsDeletingOptionId(null);
    };

    const handleToggleOptionAvailable = async (option: ModifierOptionData) => {
        setIsTogglingStatusOptionId(option.id);
        const newStatus = !option.isAvailable;
        try {
            await updateModifierOption(option.id, { isAvailable: newStatus });
        } catch (error) {
            console.error(`Error toggling availability for option ${option.id}:`, error);
        } finally {
            setIsTogglingStatusOptionId(null);
        }
    };


    const optionRows = modifierOptions.map((option) => {
        const optionDisplayName = (currentLanguage === 'es' && option.name_es) ? option.name_es : (option.name_en || option.name_es || t('common.nameNotAvailable'));
        const isLoadingThisStatus = isTogglingStatusOptionId === option.id;
        const isLoadingThisDelete = isDeletingOptionId === option.id;
        const disableActionsGeneral = isSubmittingOptionForm || !!isDeletingOptionId || !!isTogglingStatusOptionId;
        const optionAvailabilityText = option.isAvailable ? t('adminCamarero.modifierOption.statusAvailable') : t('adminCamarero.modifierOption.statusNotAvailable');
        const tooltipToggleAvailable = option.isAvailable ? t('adminCamarero.modifierOption.tooltipMarkNotAvailable') : t('adminCamarero.modifierOption.tooltipMarkAvailable');

        return (
            <Table.Tr key={option.id}>
                <Table.Td>
                    <Text fw={500}>{optionDisplayName}</Text>
                    {optionDisplayName !== option.name_es && option.name_es && <Text size="xs" c="dimmed">ES: {option.name_es}</Text>}
                    {optionDisplayName !== option.name_en && option.name_en && <Text size="xs" c="dimmed">EN: {option.name_en}</Text>}
                </Table.Td>
                <Table.Td ta="right">
                    {option.priceAdjustment.toLocaleString(undefined, { style: 'currency', currency: 'EUR' })}
                </Table.Td>
                <Table.Td>{option.position}</Table.Td>
                <Table.Td>{option.isDefault ? t('common.yes') : t('common.no')}</Table.Td>
                <Table.Td>
                    <Badge color={option.isAvailable ? 'green' : 'gray'} variant="light">
                        {optionAvailabilityText}
                    </Badge>
                </Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        <Tooltip label={t('adminCamarero.modifierOption.tooltipEditOption')} withArrow>
                            <ActionIcon variant="subtle" color="blue"
                                onClick={() => handleOpenEditOptionForm(option)}
                                disabled={disableActionsGeneral || isLoadingThisStatus || isLoadingThisDelete}
                            >
                                <IconPencil size={16} />
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={tooltipToggleAvailable} withArrow>
                            <ActionIcon
                                variant="subtle"
                                color={option.isAvailable ? "orange" : "teal"}
                                onClick={() => handleToggleOptionAvailable(option)}
                                loading={isLoadingThisStatus}
                                disabled={disableActionsGeneral || isLoadingThisDelete || (isTogglingStatusOptionId !== null && isTogglingStatusOptionId !== option.id)}
                            >
                                {option.isAvailable ? <IconPlayerStop size={16} /> : <IconPlayerPlay size={16} />}
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={t('adminCamarero.modifierOption.tooltipDeleteOption')} withArrow>
                            <ActionIcon variant="subtle" color="red"
                                onClick={() => handleDeleteOption(option.id)}
                                loading={isLoadingThisDelete}
                                disabled={disableActionsGeneral || isLoadingThisStatus || (isDeletingOptionId !== null && isDeletingOptionId !== option.id)}
                            >
                                <IconTrash size={16} />
                            </ActionIcon>
                        </Tooltip>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    return (
        <Modal
            opened={opened && !!modifierGroupId}
            onClose={onClose}
            title={t('adminCamarero.modifierOptionsModal.title', { groupName: modifierGroupName })}
            size="lg"
            centered
            scrollAreaComponent={NativeScrollArea}
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            <Stack gap="lg">
                {!showOptionForm ? (
                    <>
                        <Group justify="space-between">
                            <Title order={5}>{t('adminCamarero.modifierOptionsModal.existingOptionsTitle')}</Title>
                            <Button leftSection={<IconPlus size={16} />} onClick={handleOpenAddOptionForm} disabled={loadingOptions}>
                                {t('adminCamarero.modifierOptionsModal.createNewOptionButton')}
                            </Button>
                        </Group>

                        {loadingOptions && <Group justify="center" mt="md"><Loader /></Group>}
                        {errorOptions && !loadingOptions && <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{errorOptions}</Alert>}
                        {!loadingOptions && !errorOptions && modifierOptions.length === 0 && <Text c="dimmed" ta="center" mt="md">{t('adminCamarero.modifierOptionsModal.noOptionsForGroup')}</Text>}
                        {!loadingOptions && !errorOptions && modifierOptions.length > 0 && (
                            <Table.ScrollContainer minWidth={500}>
                                <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                                    <Table.Thead>
                                        <Table.Tr>
                                            <Table.Th>{t('adminCamarero.modifierOptionsModal.tableHeaderName')}</Table.Th>
                                            <Table.Th ta="right">{t('adminCamarero.modifierOptionsModal.tableHeaderPriceAdjustment')}</Table.Th>
                                            <Table.Th>{t('adminCamarero.modifierOptionsModal.tableHeaderPosition')}</Table.Th>
                                            <Table.Th>{t('adminCamarero.modifierOptionsModal.tableHeaderDefault')}</Table.Th>
                                            <Table.Th>{t('adminCamarero.modifierOptionsModal.tableHeaderAvailable')}</Table.Th>
                                            <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                                        </Table.Tr>
                                    </Table.Thead>
                                    <Table.Tbody>{optionRows}</Table.Tbody>
                                </Table>
                            </Table.ScrollContainer>
                        )}
                    </>
                ) : (
                    <Paper withBorder p="md" radius="md">
                        <Title order={5} mb="md">{editingOption ? t('adminCamarero.modifierOptionsModal.formEditTitle', { optionName: (currentLanguage === 'es' && editingOption.name_es) ? editingOption.name_es : (editingOption.name_en || editingOption.name_es || '') }) : t('adminCamarero.modifierOptionsModal.formCreateTitle')}</Title>
                        <form onSubmit={form.onSubmit(handleOptionFormSubmit)}>
                            <Stack gap="sm">
                                <TextInput label={t('adminCamarero.modifierOptionForm.nameEsLabel')} required {...form.getInputProps('name_es')} disabled={isSubmittingOptionForm} />
                                <TextInput label={t('adminCamarero.modifierOptionForm.nameEnLabel')} {...form.getInputProps('name_en')} disabled={isSubmittingOptionForm} />
                                <NumberInput
                                    label={t('adminCamarero.modifierOptionForm.priceAdjustmentLabel')}
                                    description={t('adminCamarero.modifierOptionForm.priceAdjustmentDescription')}
                                    decimalScale={2}
                                    fixedDecimalScale
                                    step={0.10}
                                    leftSection={<IconCurrencyEuro size={16} />}
                                    {...form.getInputProps('priceAdjustment')}
                                    disabled={isSubmittingOptionForm}
                                />
                                <NumberInput
                                    label={t('adminCamarero.modifierOptionForm.positionLabel')}
                                    min={0}
                                    step={1}
                                    allowDecimal={false}
                                    {...form.getInputProps('position')}
                                    disabled={isSubmittingOptionForm}
                                />
                                <Switch label={t('adminCamarero.modifierOptionForm.isDefaultLabel')} {...form.getInputProps('isDefault', { type: 'checkbox' })} disabled={isSubmittingOptionForm} />
                                <Switch label={t('adminCamarero.modifierOptionForm.isAvailableLabel')} {...form.getInputProps('isAvailable', { type: 'checkbox' })} disabled={isSubmittingOptionForm} />

                                <Group justify="flex-end" mt="md">
                                    <Button variant="default" onClick={() => { setShowOptionForm(false); setEditingOption(null); form.reset(); }} disabled={isSubmittingOptionForm}>
                                        {t('common.cancel')}
                                    </Button>
                                    <Button type="submit" loading={isSubmittingOptionForm} leftSection={<IconDeviceFloppy size={16} />}>
                                        {editingOption ? t('common.saveChanges') : t('adminCamarero.modifierOptionsModal.formCreateButton')}
                                    </Button>
                                </Group>
                            </Stack>
                        </form>
                    </Paper>
                )}
                 <Divider mt="lg" />
                <Group justify="flex-end" mt="md">
                    <Button variant="outline" onClick={onClose}>{t('adminCamarero.modifierOptionsModal.closeButton')}</Button>
                </Group>
            </Stack>
        </Modal>
    );
};

export default ModifierOptionsManagementModal;


// ====== [142] frontend/src/modules/camarero/components/public/menu/CategoryAccordion.tsx ======
// frontend/src/modules/camarero/components/public/menu/CategoryAccordion.tsx
// Version 1.3.0 - Final Corrected Version

import React from 'react';
import { Accordion, Group, Image, Stack, Title, Text } from '@mantine/core';
import { IconChevronDown } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import {
    PublicMenuCategory,
    PublicMenuItem,
    ModifierUiType
} from '../../../types/menu.types';
import MenuItemCard, { MenuItemCardConfiguringState } from './MenuItemCard';

// --- INTERFAZ DE PROPS DEFINITIVA Y CORRECTA ---
interface CategoryAccordionProps {
    categories: PublicMenuCategory[];
    activeAccordionItems: string[];
    onAccordionChange: (value: string[]) => void;
    configuringItemId: string | null;
    configuringItemState: MenuItemCardConfiguringState | null;
    onStartConfigureItem: (item: PublicMenuItem) => void;
    onCancelConfiguration: () => void;
    onConfigQuantityChange: (newQuantity: number) => void;
    onConfigModifierSelectionChange: (groupId: string, newSelection: string | string[], groupUiType: ModifierUiType) => void;
    onConfigNotesChange: (newNotes: string) => void;
    onConfigAddToCart: () => void;
    onSimpleAddToCart: (item: PublicMenuItem, quantity: number) => void;
}

const CategoryAccordion: React.FC<CategoryAccordionProps> = ({
    categories, activeAccordionItems, onAccordionChange,
    configuringItemId, configuringItemState, onStartConfigureItem, onCancelConfiguration,
    onConfigQuantityChange, onConfigModifierSelectionChange, onConfigNotesChange,
    onConfigAddToCart, onSimpleAddToCart,
}) => {
    const { t, i18n } = useTranslation();

    if (!categories || categories.length === 0) {
        return <Text c="dimmed" ta="center">{t('publicMenu.noCategories')}</Text>;
    }

    return (
        <Accordion
            variant="separated" chevron={<IconChevronDown />} multiple
            value={activeAccordionItems} onChange={onAccordionChange}
        >
            {categories.map((category) => (
                <Accordion.Item key={category.id} value={category.id}>
                    <Accordion.Control>
                        <Group wrap="nowrap">
                            {category.imageUrl && (<Image src={category.imageUrl} alt={(i18n.language === 'es' && category.name_es) ? category.name_es : (category.name_en || category.name_es || '')} w={60} h={60} fit="cover" radius="sm" />)}
                            <Stack gap={0}>
                                <Title order={4}>{i18n.language === 'es' && category.name_es ? category.name_es : category.name_en || category.name_es || t('publicMenu.unnamedCategory')}</Title>
                                {i18n.language === 'es' && category.description_es && <Text size="sm" c="dimmed" lineClamp={1}>{category.description_es}</Text>}
                                {i18n.language === 'en' && category.description_en && <Text size="sm" c="dimmed" lineClamp={1}>{category.description_en}</Text>}
                            </Stack>
                        </Group>
                    </Accordion.Control>
                    <Accordion.Panel>
                        {category.items.length > 0 ? (
                            <Stack gap="md" pt="md">
                                {category.items.map((item) => {
                                    const isConfiguringThisItem = configuringItemId === item.id;
                                    return (
                                        <MenuItemCard
                                            key={item.id} item={item}
                                            isConfiguringThisItem={isConfiguringThisItem}
                                            currentConfig={isConfiguringThisItem ? configuringItemState : null}
                                            onStartConfigure={() => onStartConfigureItem(item)}
                                            onCancelConfiguration={onCancelConfiguration}
                                            onQuantityChange={onConfigQuantityChange}
                                            onModifierSelectionChange={onConfigModifierSelectionChange}
                                            onNotesChange={onConfigNotesChange}
                                            onAddToCart={isConfiguringThisItem ? onConfigAddToCart : () => onSimpleAddToCart(item, 1)}
                                        />
                                    );
                                })}
                            </Stack>
                        ) : (
                            <Text c="dimmed">{t('publicMenu.noItemsInCategory')}</Text>
                        )}
                    </Accordion.Panel>
                </Accordion.Item>
            ))}
        </Accordion>
    );
};

export default CategoryAccordion;


// ====== [143] frontend/src/modules/camarero/components/public/menu/MenuItemCard.tsx ======
// frontend/src/modules/camarero/components/public/menu/MenuItemCard.tsx
// VERSI√ìN 2.0.0 - Implementa el doble bot√≥n de "A√±adir" y "Canjear".

import React from 'react';
import {
    Paper, Title, Text, Stack, Group, Badge, Box, Image,
    Button as MantineButton, Tooltip
} from '@mantine/core';
import { IconGift, IconShoppingCartPlus } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

import { PublicMenuItem } from '../../../types/menu.types';

// --- NUEVA INTERFAZ DE PROPS ---
interface MenuItemCardProps {
    item: PublicMenuItem;
    onAddToCart: (item: PublicMenuItem, quantity: number) => void;
    // Props para el canje
    isRedeemable: boolean;
    rewardCost?: number;
    canAffordReward?: boolean;
    onRedeem: (item: PublicMenuItem) => void;
}

const MenuItemCard: React.FC<MenuItemCardProps> = ({
    item,
    onAddToCart,
    isRedeemable,
    rewardCost,
    canAffordReward,
    onRedeem,
}) => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;

    const displayName = (currentLanguage === 'es' ? item.name_es : item.name_en) || item.name_es || t('publicMenu.unnamedItem');
    const displayDescription = (currentLanguage === 'es' ? item.description_es : item.description_en) || item.description_es;

    return (
        <Paper p="md" radius="sm" withBorder>
            <Group wrap="nowrap" align="flex-start" gap="md">
                {item.imageUrl && (
                    <Image src={item.imageUrl} alt={displayName} w={100} h={100} fit="cover" radius="sm" />
                )}
                <Stack gap="xs" style={{ flexGrow: 1 }}>
                    <Title order={5}>{displayName}</Title>
                    
                    {displayDescription && <Text size="sm" c="dimmed" lineClamp={3}>{displayDescription}</Text>}
                    
                    {(item.allergens.length > 0 || item.tags.length > 0) && (
                        <Group gap="xs" mt="sm">
                            {item.allergens.map(allergen => (
                                <Badge key={allergen} variant="outline" color="orange" size="xs">
                                    {t(`adminCamarero.menuItem.allergen.${allergen}`, allergen)}
                                </Badge>
                            ))}
                            {item.tags.map(tag => (
                                <Badge key={tag} variant="light" color="grape" size="xs">
                                    {t(`adminCamarero.menuItem.tag.${tag}`, tag)}
                                </Badge>
                            ))}
                        </Group>
                    )}
                    
                    {/* --- NUEVA L√ìGICA DE BOTONES --- */}
                    <Group mt="md" justify="flex-end" align="center">
                        <Text fw={700} fz="lg" c="blue.7">
                            {item.price.toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}
                        </Text>
                        
                        <Group gap="xs">
                            {/* Bot√≥n para comprar con dinero */}
                            <MantineButton 
                                onClick={() => onAddToCart(item, 1)}
                                leftSection={<IconShoppingCartPlus size={16} />}
                                size="sm"
                                variant="filled"
                            >
                                {t('publicMenu.addToCart')}
                            </Button>

                            {/* Bot√≥n para canjear con puntos (condicional) */}
                            {isRedeemable && (
                                <Tooltip 
                                    label={!canAffordReward ? t('customerDashboard.insufficientPoints') : ''}
                                    color="red"
                                    withArrow
                                    disabled={canAffordReward}
                                >
                                    <Box>
                                        <Button
                                            onClick={() => canAffordReward && onRedeem(item)}
                                            variant="gradient"
                                            gradient={{ from: 'orange', to: 'yellow' }}
                                            size="sm"
                                            leftSection={<IconGift size={16} />}
                                            disabled={!canAffordReward}
                                            style={{ cursor: canAffordReward ? 'pointer' : 'not-allowed' }}
                                        >
                                            {t('component.rewardForm.pointsCostPlaceholder', '{{count}} pts', { count: rewardCost })}
                                        </Button>
                                    </Box>
                                </Tooltip>
                            )}
                        </Group>
                    </Group>
                </Stack>
            </Group>
        </Paper>
    );
};

export default MenuItemCard;


// ====== [144] frontend/src/modules/camarero/components/public/menu/ModifierGroupInteractiveRenderer.tsx ======
// frontend/src/components/public/menu/ModifierGroupInteractiveRenderer.tsx
// Version: 1.0.1 (Corrected imports)

import React from 'react';
import { 
    Stack, Text, Radio, Checkbox, 
    Box // <--- A√ëADIDO Box
} from '@mantine/core';
// Group, Badge, ThemeIcon, IconPoint eliminados de las importaciones ya que no se usan aqu√≠
import { useTranslation } from 'react-i18next';
import { PublicMenuModifierGroup, PublicMenuModifierOption, ModifierUiType } from '../../../types/menu.types';

interface ModifierGroupInteractiveRendererProps {
    group: PublicMenuModifierGroup;
    selectedOptionsForThisGroup: string | string[]; 
    onSelectionChange: (newSelection: string | string[]) => void;
}

const ModifierGroupInteractiveRenderer: React.FC<ModifierGroupInteractiveRendererProps> = ({
    group,
    selectedOptionsForThisGroup,
    onSelectionChange,
}) => {
    const { t, i18n } = useTranslation();

    const getModifierGroupSelectionText = (grp: PublicMenuModifierGroup): string => {
        const { isRequired, uiType, minSelections, maxSelections } = grp;
        if (isRequired) {
            if (uiType === ModifierUiType.RADIO) { return t('publicMenu.modifier.chooseOneRequired', 'Elige 1 (obligatorio)'); }
            if (minSelections === 1 && maxSelections === 1) { return t('publicMenu.modifier.chooseOneRequired', 'Elige 1 (obligatorio)');}
            if (minSelections === 1 && maxSelections > 1) { return t('publicMenu.modifier.chooseAtLeastOneUpToMax', { max: maxSelections, context: 'required' }); }
            if (minSelections > 0 && maxSelections >= minSelections) { return t('publicMenu.modifier.chooseMinUpToMax', { min: minSelections, max: maxSelections, context: 'required' }); }
        } else { 
            if (uiType === ModifierUiType.RADIO && maxSelections === 1) { return t('publicMenu.modifier.chooseOneOptional', 'Elige 1 (opcional)'); }
            if (maxSelections > 0) { return t('publicMenu.modifier.chooseUpToMaxOptional', { max: maxSelections }); }
        }
        return t('publicMenu.modifier.chooseOptional', 'Opcional');
    };
    
    const renderOptionLabel = (option: PublicMenuModifierOption) => (
        <>
            {i18n.language === 'es' && option.name_es ? option.name_es : option.name_en || option.name_es}
            {option.priceAdjustment !== 0 && (
                <Text span c={option.priceAdjustment > 0 ? "teal.7" : "pink.7"} ml={5} fz="xs">
                    ({option.priceAdjustment > 0 ? '+' : ''}{option.priceAdjustment.toFixed(2)}‚Ç¨)
                </Text>
            )}
        </>
    );

    return (
        <Box key={group.id} mb="md" pl="sm" style={{borderLeft: `2px solid var(--mantine-color-gray-3)`, marginLeft:'4px'}}>
            <Text size="sm" fw={500}>
                {i18n.language === 'es' && group.name_es ? group.name_es : group.name_en || group.name_es}
                {group.isRequired && <Text span c="red.7" ml={4} fw={700}>*</Text>}
            </Text>
            <Text size="xs" c="dimmed" mb={4}>
                {getModifierGroupSelectionText(group)}
            </Text>
            <Stack gap="xs" mt={4}>
                {group.uiType === ModifierUiType.RADIO && (
                    <Radio.Group
                        value={selectedOptionsForThisGroup as string || ''}
                        onChange={(value) => onSelectionChange(value)}
                        name={`radio-group-${group.id}`}
                    >
                        <Stack gap="xs">
                            {group.options.map((option: PublicMenuModifierOption) => (
                                <Radio 
                                    key={option.id} 
                                    value={option.id}
                                    label={renderOptionLabel(option)} 
                                />
                            ))}
                        </Stack>
                    </Radio.Group>
                )}
                {group.uiType === ModifierUiType.CHECKBOX && (
                    <Checkbox.Group
                        value={selectedOptionsForThisGroup as string[] || []}
                        onChange={(values) => onSelectionChange(values)}
                    >
                         <Stack gap="xs">
                            {group.options.map((option: PublicMenuModifierOption) => (
                                <Checkbox
                                    key={option.id}
                                    value={option.id}
                                    label={renderOptionLabel(option)}
                                />
                            ))}
                        </Stack>
                    </Checkbox.Group>
                )}
            </Stack>
        </Box>
    );
};

export default ModifierGroupInteractiveRenderer;


// ====== [145] frontend/src/modules/camarero/components/public/menu/ShoppingCartModal.tsx ======
// frontend/src/modules/camarero/components/public/menu/ShoppingCartModal.tsx
// VERSI√ìN 2.2.0 - REFACTORIZADO: Recibe el descuento calculado como prop

import React from 'react';
import {
    Modal, Text, Stack, Group, Button, Divider, ScrollArea, Box, NumberInput,
    ActionIcon, Textarea, Paper, Tooltip, useMantineTheme, Badge, useMantineColorScheme
} from '@mantine/core';
import { useTranslation } from 'react-i18next';
import {
    IconTrash, IconSend, IconCirclePlus, IconCircleMinus, IconShoppingCartOff,
    IconTicket, IconX
} from '@tabler/icons-react';
import { useLayoutUserData } from '../../../../../shared/hooks/useLayoutUserData';
import { OrderItemFE } from '../../../types/publicOrder.types';
import type { DisplayReward } from '../../../../../shared/types/user.types';

// --- PROPS REFACTORIZADAS ---
interface ShoppingCartModalProps {
    opened: boolean;
    onClose: () => void;
    orderItems: OrderItemFE[];
    orderNotes: string;
    subtotal: number; // Prop para el subtotal sin descuento
    totalWithDiscount: number; // Prop para el total FINAL ya calculado
    appliedDiscount: DisplayReward | null; // Prop para saber QU√â descuento se aplic√≥
    onUpdateItemQuantity: (cartItemId: string, newQuantity: number) => void;
    onRemoveItem: (cartItemId: string) => void;
    onUpdateOrderNotes: (notes: string) => void;
    onSubmitOrder: () => Promise<void>;
    isSubmittingOrder: boolean;
    onClearCart: () => void;
    isAddingToExistingOrder?: boolean;
    activeOrderNumber?: string | null;
    onOpenRewardModal: () => void;
    onRemoveDiscount: () => void;
}

const ShoppingCartModal: React.FC<ShoppingCartModalProps> = ({
    opened, onClose, orderItems, orderNotes, subtotal, totalWithDiscount, appliedDiscount, 
    onUpdateItemQuantity, onRemoveItem, onUpdateOrderNotes, 
    onSubmitOrder, isSubmittingOrder, onClearCart,
    isAddingToExistingOrder, activeOrderNumber,
    onOpenRewardModal, onRemoveDiscount
}) => {
    const { t, i18n } = useTranslation();
    const { userData } = useLayoutUserData();
    const theme = useMantineTheme();
    const { colorScheme } = useMantineColorScheme();
    const currentLanguage = i18n.language;

    // --- L√ìGICA DE C√ÅLCULO ELIMINADA ---
    // El c√°lculo del descuento ahora se hace en el componente padre (PublicMenuViewPage)
    // y se pasa a trav√©s de las props `subtotal` y `totalWithDiscount`.
    const calculatedDiscountAmount = subtotal - totalWithDiscount;

    const handleQuantityChange = (cartItemId: string, value: number | string) => {
        onUpdateItemQuantity(cartItemId, Math.max(1, Number(value)));
    };

    const modalTitle = isAddingToExistingOrder ? t('publicMenu.cart.titleAddToOrder', { orderNumber: activeOrderNumber || '' }) : t('publicMenu.cart.title');
    const submitButtonText = isAddingToExistingOrder ? t('publicMenu.cart.submitAddToOrder') : t('publicMenu.cart.submitOrder');
    
    return (
        <Modal
            opened={opened} onClose={onClose} title={modalTitle} size="lg"
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
            scrollAreaComponent={ScrollArea.Autosize} centered
        >
            <Stack gap="md">
                {orderItems.length > 0 && (
                    <Group justify="flex-end">
                        <Button variant="outline" color="red" size="xs" leftSection={<IconShoppingCartOff size={14} />} onClick={onClearCart} disabled={isSubmittingOrder}>
                            {t('publicMenu.cart.clearCartButton')}
                        </Button>
                    </Group>
                )}

                {orderItems.length === 0 ? (
                    <Text c="dimmed" ta="center" py="xl">{isAddingToExistingOrder ? t('publicMenu.cart.emptyAddToOrder') : t('publicMenu.cart.empty')}</Text>
                ) : (
                    <ScrollArea.Autosize mah="40vh">
                        <Stack gap="md">
                            {orderItems.map((item) => {
                                const itemNameForLabel = (currentLanguage === 'es' && item.menuItemName_es ? item.menuItemName_es : item.menuItemName_en || item.menuItemName_es) || t('publicMenu.unnamedItem');
                                const isRedeemedItem = !!item.redeemedRewardId;
                                return (
                                    <Paper key={item.cartItemId} p="sm" withBorder radius="sm" bg={isRedeemedItem ? (colorScheme === 'dark' ? theme.colors.green[9] : theme.colors.green[0]) : undefined}>
                                        <Group justify="space-between" align="flex-start" wrap='nowrap'>
                                            <Box style={{ flex: 1, minWidth: 0 }}>
                                                {isRedeemedItem && <Badge color="green" variant="light" mb={4}>{t('publicMenu.cart.redeemedItemBadge')}</Badge>}
                                                <Text fw={500} truncate>{itemNameForLabel}</Text>
                                                {item.selectedModifiers.length > 0 && (
                                                    <Box ml="xs" mt={2}>
                                                        {item.selectedModifiers.map(mod => (
                                                            <Text key={mod.modifierOptionId} size="xs" c="dimmed">
                                                                + {(currentLanguage === 'es' && mod.name_es ? mod.name_es : mod.name_en || mod.name_es)}
                                                                {mod.priceAdjustment !== 0 && ` (${mod.priceAdjustment > 0 ? '+' : ''}${mod.priceAdjustment.toFixed(2)}‚Ç¨)`}
                                                            </Text>
                                                        ))}
                                                    </Box>
                                                )}
                                                {item.notes && (<Text size="xs" c="dimmed" fs="italic" mt={2}>{t('publicMenu.cart.itemNotesLabel')} {item.notes}</Text>)}
                                            </Box>
                                            <Stack align="flex-end" gap={4} style={{ flexShrink: 0 }}>
                                                <Text fw={500} size="sm" style={{ textDecoration: isRedeemedItem ? 'line-through' : 'none' }}>
                                                    {item.totalPriceForItem.toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}
                                                </Text>
                                                <Group gap="xs" wrap="nowrap">
                                                    <ActionIcon variant="default" size="sm" onClick={() => handleQuantityChange(item.cartItemId, item.quantity - 1)} disabled={item.quantity <= 1 || isSubmittingOrder || isRedeemedItem}><IconCircleMinus size={16} /></ActionIcon>
                                                    <NumberInput value={item.quantity} onChange={(val) => handleQuantityChange(item.cartItemId, val)} min={1} max={20} hideControls disabled={isSubmittingOrder || isRedeemedItem} styles={{ input: { width: '40px', textAlign: 'center', padding: '0'} }} />
                                                    <ActionIcon variant="default" size="sm" onClick={() => handleQuantityChange(item.cartItemId, item.quantity + 1)} disabled={isSubmittingOrder || isRedeemedItem}><IconCirclePlus size={16} /></ActionIcon>
                                                    <Tooltip label={t('publicMenu.cart.removeItem')} withArrow>
                                                        <Box><ActionIcon color="red" variant="light" onClick={() => onRemoveItem(item.cartItemId)} disabled={isSubmittingOrder}><IconTrash size={16} /></ActionIcon></Box>
                                                    </Tooltip>
                                                </Group>
                                            </Stack>
                                        </Group>
                                    </Paper>
                                );
                            })}
                        </Stack>
                    </ScrollArea.Autosize>
                )}
                
                {userData && (
                    <>
                        <Divider my="sm" label={t('publicMenu.cart.rewardsSectionTitle')} labelPosition="center" />
                        <Button
                            variant="light"
                            color="blue"
                            fullWidth
                            onClick={onOpenRewardModal}
                            leftSection={<IconTicket size={18} />}
                        >
                            {t('publicMenu.cart.applyRewardButton')}
                        </Button>
                    </>
                )}

                <Divider my="sm" />
                <Textarea label={t('publicMenu.cart.orderNotesLabel')} placeholder={t('publicMenu.cart.orderNotesPlaceholder')} value={orderNotes} onChange={(event) => onUpdateOrderNotes(event.currentTarget.value)} minRows={2} disabled={isSubmittingOrder} />
                <Divider my="sm" />

                <Stack gap={4}>
                    <Group justify="space-between"><Text size="sm">{t('publicMenu.cart.subtotal')}</Text><Text size="sm">{subtotal.toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}</Text></Group>
                    {appliedDiscount && (
                        <Group justify="space-between">
                            <Group gap="xs">
                                <Text size="sm" c="green">{t('publicMenu.cart.discountApplied')}</Text>
                                <Tooltip label="Quitar descuento">
                                    <ActionIcon size="xs" color="red" variant="subtle" onClick={onRemoveDiscount}>
                                        <IconX/>
                                    </ActionIcon>
                                </Tooltip>
                            </Group>
                            <Text size="sm" c="green">{`- ${calculatedDiscountAmount.toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}`}</Text>
                        </Group>
                    )}
                    <Group justify="space-between" mt="sm">
                        <Text fw={700} size="lg">{t(isAddingToExistingOrder ? 'publicMenu.cart.totalAddItems' : 'publicMenu.cart.totalOrder')}</Text>
                        <Text fw={700} size="lg">{totalWithDiscount.toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}</Text>
                    </Group>
                </Stack>

                <Group justify="flex-end" mt="xl">
                    <Button variant="default" onClick={onClose} disabled={isSubmittingOrder}>{t('publicMenu.cart.continueShopping')}</Button>
                    <Button onClick={onSubmitOrder} loading={isSubmittingOrder} disabled={orderItems.length === 0} leftSection={<IconSend size={16} />} color="green">{submitButtonText}</Button>
                </Group>
            </Stack>
        </Modal>
    );
};

export default ShoppingCartModal;


// ====== [146] frontend/src/modules/camarero/components/public/menu/order/OrderBillView.tsx ======
// frontend/src/modules/camarero/components/public/order/OrderBillView.tsx
// Version 1.1.0 - Corrected type imports and added explicit types to map callbacks.
import React from 'react';
import { Paper, Text, Stack, Group, Divider, Box, Badge } from '@mantine/core';
import { useTranslation } from 'react-i18next';

// --- CORRECCI√ìN 1: Ruta de importaci√≥n corregida ---
import { PublicOrderStatusInfo, PublicOrderItemStatusInfo, PublicModifierStatusInfo } from '../../../../types/publicOrder.types';

interface OrderBillViewProps {
  orderData: PublicOrderStatusInfo;
}

const OrderBillView: React.FC<OrderBillViewProps> = ({ orderData }) => {
  const { t, i18n } = useTranslation();
  const currentLanguage = i18n.language;

  // Extraemos los datos necesarios
  const { items, totalAmount, discountAmount, finalAmount } = orderData;

  const formatCurrency = (value: number) => {
    return value.toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' });
  };

  return (
    <Paper withBorder p="lg" radius="md" mt="md">
      <Stack gap="md">
        {/* Cabecera de la factura */}
        <Group justify="space-between" align="baseline">
          <Text fw={500}>{t('orderBillView.item', '√çtem')}</Text>
          <Group gap="xl">
            <Text fw={500} style={{ width: '80px', textAlign: 'right' }}>{t('orderBillView.price', 'Precio')}</Text>
            <Text fw={500} style={{ width: '80px', textAlign: 'right' }}>{t('orderBillView.total', 'Total')}</Text>
          </Group>
        </Group>
        <Divider />

        {/* Lista de √çtems */}
        <Stack gap="sm">
          {items.map((item: PublicOrderItemStatusInfo) => {
            const isRedeemedItem = item.priceAtPurchase === 0 && item.totalItemPrice === 0;
            const itemName = item.itemNameSnapshot || t('orderBillView.unnamedItem', '√çtem sin nombre');
            
            return (
              <Box key={item.id}>
                <Group justify="space-between" align="flex-start" wrap="nowrap">
                  <Stack gap={0} style={{ flex: 1, minWidth: 0 }}>
                    <Text fw={500} truncate>
                      {item.quantity}x {itemName}
                    </Text>
                    {isRedeemedItem && <Badge color="green" variant="light" size="sm" mt={4} style={{width: 'fit-content'}}>{t('orderBillView.reward', 'Recompensa')}</Badge>}
                    {item.selectedModifiers && item.selectedModifiers.length > 0 && (
                      <Box ml="sm" mt={4}>
                        {/* --- CORRECCI√ìN 2: Tipado expl√≠cito para 'mod' e 'index' --- */}
                        {item.selectedModifiers.map((mod: PublicModifierStatusInfo, index: number) => (
                          <Text key={index} size="xs" c="dimmed">
                            + {mod.optionNameSnapshot}
                            {mod.optionPriceAdjustmentSnapshot > 0 && ` (${formatCurrency(mod.optionPriceAdjustmentSnapshot)})`}
                          </Text>
                        ))}
                      </Box>
                    )}
                  </Stack>
                  <Group gap="xl" wrap="nowrap">
                     <Text size="sm" style={{ width: '80px', textAlign: 'right', textDecoration: isRedeemedItem ? 'line-through' : 'none' }}>
                        {formatCurrency(item.priceAtPurchase)}
                    </Text>
                    <Text fw={500} size="sm" style={{ width: '80px', textAlign: 'right' }}>
                        {formatCurrency(item.totalItemPrice)}
                    </Text>
                  </Group>
                </Group>
              </Box>
            );
          })}
        </Stack>

        <Divider mt="sm"/>

        {/* Secci√≥n de Totales */}
        <Stack gap={4} align="flex-end">
            <Group justify="space-between" style={{ width: '250px' }}>
                <Text size="sm">{t('orderBillView.subtotal', 'Subtotal')}:</Text>
                <Text size="sm">{formatCurrency(totalAmount)}</Text>
            </Group>
            {discountAmount !== null && discountAmount > 0 && (
                <Group justify="space-between" style={{ width: '250px' }}>
                    <Text size="sm" c="green">{t('orderBillView.discount', 'Descuento')}:</Text>
                    <Text size="sm" c="green">{formatCurrency(-discountAmount)}</Text>
                </Group>
            )}
            <Group justify="space-between" style={{ width: '250px' }} mt="xs">
                <Text fw={700} size="lg">{t('orderBillView.finalTotal', 'TOTAL A PAGAR')}:</Text>
                <Text fw={700} size="lg">{formatCurrency(finalAmount)}</Text>
            </Group>
        </Stack>
      </Stack>
    </Paper>
  );
};

export default OrderBillView;


// ====== [147] frontend/src/modules/camarero/hooks/useActiveOrderState.ts ======
// frontend/src/modules/camarero/hooks/useActiveOrderState.ts
// Versi√≥n 1.1.1 - CORRECCI√ìN: A√±adir activeOrderDetails a la interfaz de retorno

import { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { OrderStatus } from '../../../shared/types/user.types';
import { PublicOrderStatusInfo } from '../types/publicOrder.types'; 

interface ActiveOrderInfo {
    orderId: string;
    orderNumber: string;
    businessSlug: string;
    tableIdentifier?: string;
    savedAt: number;
}

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL_PUBLIC || 'http://localhost:3000/public';
const ACTIVE_ORDER_INFO_KEY_PREFIX = 'loyalpyme_active_order_info_';

export interface UseActiveOrderStateReturn {
    activeOrderId: string | null;
    activeOrderNumber: string | null;
    canCurrentlyAddToExistingOrder: boolean;
    loadingActiveOrderStatus: boolean;
    checkActiveOrderStatus: () => Promise<void>;
    clearActiveOrder: () => void;
    setActiveOrderManually: (orderId: string, orderNumber: string) => void;
    activeOrderDetails: PublicOrderStatusInfo | null; // <--- ¬°CORRECCI√ìN CLAVE AQU√ç!
}

export const useActiveOrderState = (businessSlug: string | undefined, tableIdentifier: string | undefined): UseActiveOrderStateReturn => {
    const activeOrderKey = businessSlug ? `${ACTIVE_ORDER_INFO_KEY_PREFIX}${businessSlug}${tableIdentifier ? `_${tableIdentifier}` : ''}` : null;

    const [activeOrderId, setActiveOrderId] = useState<string | null>(null);
    const [activeOrderNumber, setActiveOrderNumber] = useState<string | null>(null);
    const [canCurrentlyAddToExistingOrder, setCanCurrentlyAddToExistingOrder] = useState<boolean>(false);
    const [loadingActiveOrderStatus, setLoadingActiveOrderStatus] = useState<boolean>(true);
    const [activeOrderDetails, setActiveOrderDetails] = useState<PublicOrderStatusInfo | null>(null); // Estado para los detalles completos del pedido

    const isOrderActiveForClient = useCallback((status: OrderStatus | undefined): boolean => {
        if (!status) return false;
        return [
            OrderStatus.RECEIVED, OrderStatus.IN_PROGRESS, OrderStatus.PARTIALLY_READY,
            OrderStatus.ALL_ITEMS_READY, OrderStatus.COMPLETED, OrderStatus.PENDING_PAYMENT
        ].includes(status);
    }, []);

    const canAddMoreItemsToOrderStatus = useCallback((status: OrderStatus | undefined): boolean => {
        if (!status) return false;
        return [
            OrderStatus.RECEIVED, OrderStatus.IN_PROGRESS, OrderStatus.PARTIALLY_READY,
            OrderStatus.ALL_ITEMS_READY, OrderStatus.COMPLETED
        ].includes(status);
    }, []);


    const checkActiveOrderStatus = useCallback(async (currentOrderId?: string, currentOrderNumber?: string) => {
        const orderIdToCheck = currentOrderId || activeOrderId;
        const orderNumberToCheck = currentOrderNumber || activeOrderNumber;

        if (!orderIdToCheck || !orderNumberToCheck) {
            setCanCurrentlyAddToExistingOrder(false);
            setActiveOrderDetails(null); // Limpiar detalles
            setLoadingActiveOrderStatus(false);
            return;
        }

        setLoadingActiveOrderStatus(true);
        try {
            const response = await axios.get<PublicOrderStatusInfo>(`${API_BASE_URL}/order/${orderIdToCheck}/status`);
            
            if (response.data && isOrderActiveForClient(response.data.orderStatus)) {
                setActiveOrderId(orderIdToCheck);
                setActiveOrderNumber(orderNumberToCheck);
                setActiveOrderDetails(response.data); // Guardar los detalles completos del pedido
                setCanCurrentlyAddToExistingOrder(canAddMoreItemsToOrderStatus(response.data.orderStatus));
            } else {
                setCanCurrentlyAddToExistingOrder(false);
                setActiveOrderDetails(null); // Limpiar detalles
                if (activeOrderKey) localStorage.removeItem(activeOrderKey);
                setActiveOrderId(null);
                setActiveOrderNumber(null);
            }
        } catch (error) {
            console.error(`[useActiveOrderState] Error checking status for order ${orderIdToCheck}:`, error);
            setCanCurrentlyAddToExistingOrder(false);
            setActiveOrderDetails(null); // Limpiar detalles
            if (activeOrderKey) localStorage.removeItem(activeOrderKey);
            setActiveOrderId(null);
            setActiveOrderNumber(null);
        } finally {
            setLoadingActiveOrderStatus(false);
        }
    }, [activeOrderId, activeOrderNumber, activeOrderKey, isOrderActiveForClient, canAddMoreItemsToOrderStatus]);

    useEffect(() => {
        if (activeOrderKey) {
            const storedActiveOrderInfo = localStorage.getItem(activeOrderKey);
            if (storedActiveOrderInfo) {
                try {
                    const parsedInfo: ActiveOrderInfo = JSON.parse(storedActiveOrderInfo);
                    if (parsedInfo.orderId && parsedInfo.orderNumber) {
                        setActiveOrderId(parsedInfo.orderId);
                        setActiveOrderNumber(parsedInfo.orderNumber);
                        // Llamar a checkActiveOrderStatus para obtener los detalles completos tambi√©n
                        checkActiveOrderStatus(parsedInfo.orderId, parsedInfo.orderNumber);
                    } else {
                        localStorage.removeItem(activeOrderKey);
                        setLoadingActiveOrderStatus(false);
                        setActiveOrderDetails(null); // Limpiar detalles
                    }
                } catch (e) {
                    localStorage.removeItem(activeOrderKey);
                    setLoadingActiveOrderStatus(false);
                    setActiveOrderDetails(null); // Limpiar detalles
                }
            } else {
                setLoadingActiveOrderStatus(false);
                setActiveOrderDetails(null); // Asegurar que sea null si no hay info
            }
        } else {
            setLoadingActiveOrderStatus(false);
            setActiveOrderDetails(null); // Asegurar que sea null si no hay info
        }
    }, [activeOrderKey, checkActiveOrderStatus]);

    const clearActiveOrder = useCallback(() => {
        if (activeOrderKey) {
            localStorage.removeItem(activeOrderKey);
        }
        setActiveOrderId(null);
        setActiveOrderNumber(null);
        setCanCurrentlyAddToExistingOrder(false);
        setActiveOrderDetails(null); // Limpiar detalles al limpiar el pedido
    }, [activeOrderKey]);

    const setActiveOrderManually = useCallback((orderId: string, orderNumber: string) => {
        if (activeOrderKey && businessSlug) {
            const activeOrderData: ActiveOrderInfo = { orderId, orderNumber, businessSlug, tableIdentifier, savedAt: Date.now() };
            localStorage.setItem(activeOrderKey, JSON.stringify(activeOrderData));
            setActiveOrderId(orderId);
            setActiveOrderNumber(orderNumber);
            setCanCurrentlyAddToExistingOrder(true);
            // Si se activa manualmente, se asume que los detalles se obtendr√°n con la pr√≥xima llamada
            // o se pueden pasar aqu√≠ si est√°n disponibles. Por ahora, no se actualizan aqu√≠.
        }
    }, [activeOrderKey, businessSlug, tableIdentifier]);

    return {
        activeOrderId,
        activeOrderNumber,
        canCurrentlyAddToExistingOrder,
        loadingActiveOrderStatus,
        checkActiveOrderStatus: () => checkActiveOrderStatus(),
        clearActiveOrder,
        setActiveOrderManually,
        activeOrderDetails, // ¬°Devolver el nuevo estado!
    };
};


// ====== [148] frontend/src/modules/camarero/hooks/useAdminMenuCategories.ts ======
// Nuevo archivo: frontend/src/hooks/useAdminMenuCategories.ts

import { useState, useCallback, useEffect } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
import { MenuCategoryData, MenuCategoryFormData } from '../types/menu.types'; // Importar nuestros nuevos tipos

const API_ENDPOINT = '/camarero/admin/menu/categories'; // Endpoint base para categor√≠as

export interface UseAdminMenuCategoriesReturn {
    categories: MenuCategoryData[];
    loading: boolean;
    error: string | null;
    fetchCategories: () => Promise<void>;
    addCategory: (data: MenuCategoryFormData) => Promise<MenuCategoryData | null>;
    updateCategory: (id: string, data: Partial<MenuCategoryFormData>) => Promise<MenuCategoryData | null>;
    deleteCategory: (id: string) => Promise<boolean>;
    // Podr√≠amos a√±adir aqu√≠ funciones para reordenar si fuera necesario
}

export const useAdminMenuCategories = (): UseAdminMenuCategoriesReturn => {
    const { t } = useTranslation();
    const [categories, setCategories] = useState<MenuCategoryData[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);

    const fetchCategories = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
            const response = await axiosInstance.get<MenuCategoryData[]>(API_ENDPOINT);
            // El backend ya deber√≠a devolverlas ordenadas por 'position'
            setCategories(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            setError(msg);
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
        } finally {
            setLoading(false);
        }
    }, [t]);

    useEffect(() => {
        fetchCategories();
    }, [fetchCategories]);

    const addCategory = async (data: MenuCategoryFormData): Promise<MenuCategoryData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.post<MenuCategoryData>(API_ENDPOINT, data);
            notifications.show({
                title: t('adminCommon.createSuccess'),
                message: t('adminCamarero.manageMenu.categoryCreateSuccess', { name: response.data.name_es }), // Necesitaremos esta clave i18n
                color: 'green',
            });
            await fetchCategories(); // Refrescar la lista
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.createError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false); // Asegurar que loading se desactiva en error
            return null;
        }
    };

    const updateCategory = async (id: string, data: Partial<MenuCategoryFormData>): Promise<MenuCategoryData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.put<MenuCategoryData>(`${API_ENDPOINT}/${id}`, data);
            notifications.show({
                title: t('adminCommon.updateSuccess'),
                message: t('adminCamarero.manageMenu.categoryUpdateSuccess', { name: response.data.name_es }), // Necesitaremos esta clave i18n
                color: 'green',
            });
            await fetchCategories(); // Refrescar
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.updateError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        }
    };

    const deleteCategory = async (id: string): Promise<boolean> => {
        setLoading(true);
        try {
            await axiosInstance.delete(`${API_ENDPOINT}/${id}`);
            notifications.show({
                title: t('adminCommon.deleteSuccess'),
                message: t('adminCamarero.manageMenu.categoryDeleteSuccess'), // Necesitaremos esta clave i18n
                color: 'green',
            });
            await fetchCategories(); // Refrescar
            return true;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.deleteError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return false;
        }
    };

    return {
        categories,
        loading,
        error,
        fetchCategories,
        addCategory,
        updateCategory,
        deleteCategory,
    };
};


// ====== [149] frontend/src/modules/camarero/hooks/useAdminMenuItems.ts ======
// frontend/src/hooks/useAdminMenuItems.ts
import { useState, useCallback, useEffect } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
import { MenuItemData, MenuItemFormData } from '../types/menu.types';

const ITEMS_API_BASE = `/camarero/admin/menu/items`;
const CATEGORY_ITEMS_API_BASE = (categoryId: string) => `/camarero/admin/menu/categories/${categoryId}/items`;

export interface UseAdminMenuItemsReturn {
    items: MenuItemData[];
    loading: boolean;
    error: string | null;
    fetchItems: () => Promise<void>;
    addItem: (data: MenuItemFormData) => Promise<MenuItemData | null>;
    updateItem: (itemId: string, data: Partial<MenuItemFormData>) => Promise<MenuItemData | null>;
    deleteItem: (itemId: string) => Promise<boolean>;
}

export const useAdminMenuItems = (categoryId: string | null): UseAdminMenuItemsReturn => {
    const { t } = useTranslation();
    const [items, setItems] = useState<MenuItemData[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    const fetchItems = useCallback(async () => {
        if (!categoryId) {
            setItems([]);
            setLoading(false);
            return;
        }
        setLoading(true);
        setError(null);
        try {
            const response = await axiosInstance.get<MenuItemData[]>(CATEGORY_ITEMS_API_BASE(categoryId));
            setItems(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            setError(msg);
            // No mostrar notificaci√≥n aqu√≠ directamente
        } finally {
            setLoading(false);
        }
    }, [categoryId, t]);

    useEffect(() => {
        if (categoryId) {
            fetchItems();
        } else {
            setItems([]);
        }
    }, [categoryId, fetchItems]);

    const addItem = async (data: MenuItemFormData): Promise<MenuItemData | null> => {
        if (!categoryId) {
            notifications.show({
                title: t('common.error'),
                message: t('adminCamarero.menuItemHook.errorNoCategoryForItem'),
                color: 'red'
            });
            return null;
        }
        setLoading(true);
        try {
            const response = await axiosInstance.post<MenuItemData>(CATEGORY_ITEMS_API_BASE(categoryId), data);
            notifications.show({
                title: t('adminCommon.createSuccess'),
                message: t('adminCamarero.manageMenu.itemCreateSuccess', { name: response.data.name_es || t('adminCamarero.manageMenu.itemFallbackName') }),
                color: 'green',
            });
            fetchItems();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.createError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            // Asegurar que loading se desactive si no se hizo ya
            if (loading) setLoading(false);
        }
    };

    const updateItem = async (itemId: string, data: Partial<MenuItemFormData>): Promise<MenuItemData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.put<MenuItemData>(`${ITEMS_API_BASE}/${itemId}`, data);
            notifications.show({
                title: t('adminCommon.updateSuccess'),
                message: t('adminCamarero.manageMenu.itemUpdateSuccess', { name: response.data.name_es || t('adminCamarero.manageMenu.itemFallbackName') }),
                color: 'green',
            });
            fetchItems();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.updateError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const deleteItem = async (itemId: string): Promise<boolean> => {
        setLoading(true);
        try {
            await axiosInstance.delete(`${ITEMS_API_BASE}/${itemId}`);
            notifications.show({
                title: t('adminCommon.deleteSuccess'),
                message: t('adminCamarero.manageMenu.itemDeleteSuccess'),
                color: 'green',
            });
            fetchItems();
            return true;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.deleteError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return false;
        } finally {
            if (loading) setLoading(false);
        }
    };

    return {
        items,
        loading,
        error,
        fetchItems,
        addItem,
        updateItem,
        deleteItem,
    };
};


// ====== [150] frontend/src/modules/camarero/hooks/useAdminModifierGroups.ts ======
// frontend/src/hooks/useAdminModifierGroups.ts
import { useState, useCallback, useEffect } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
import { ModifierGroupData, ModifierGroupFormData } from '../types/menu.types';

const getGroupsApiEndpoint = (menuItemId: string) => `/camarero/admin/menu/items/${menuItemId}/modifier-groups`;
const groupApiEndpoint = (modifierGroupId: string) => `/camarero/admin/modifier-groups/${modifierGroupId}`;

export interface UseAdminModifierGroupsReturn {
    modifierGroups: ModifierGroupData[];
    loading: boolean;
    error: string | null;
    fetchModifierGroups: () => Promise<void>;
    addModifierGroup: (data: ModifierGroupFormData) => Promise<ModifierGroupData | null>;
    updateModifierGroup: (groupId: string, data: Partial<ModifierGroupFormData>) => Promise<ModifierGroupData | null>;
    deleteModifierGroup: (groupId: string) => Promise<boolean>;
}

export const useAdminModifierGroups = (menuItemId: string | null): UseAdminModifierGroupsReturn => {
    const { t } = useTranslation();
    const [modifierGroups, setModifierGroups] = useState<ModifierGroupData[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    const fetchModifierGroups = useCallback(async () => {
        if (!menuItemId) {
            setModifierGroups([]);
            setLoading(false);
            return;
        }
        setLoading(true);
        setError(null);
        console.log(`[useAdminModifierGroups] Fetching groups for menuItemId: ${menuItemId}`);
        try {
            const response = await axiosInstance.get<ModifierGroupData[]>(getGroupsApiEndpoint(menuItemId));
            setModifierGroups(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            setError(msg);
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
        } finally {
            setLoading(false);
        }
    }, [menuItemId, t]);

    useEffect(() => {
        fetchModifierGroups();
    }, [fetchModifierGroups]);

    const addModifierGroup = async (data: ModifierGroupFormData): Promise<ModifierGroupData | null> => {
        if (!menuItemId) {
            notifications.show({
                title: t('common.error'),
                message: t('adminCamarero.modifierGroupHook.errorNoMenuItemForGroup'), // Nueva clave
                color: 'red'
            });
            return null;
        }
        setLoading(true);
        try {
            const response = await axiosInstance.post<ModifierGroupData>(getGroupsApiEndpoint(menuItemId), data);
            notifications.show({
                title: t('adminCommon.createSuccess'),
                message: t('adminCamarero.manageMenu.modifierGroupCreateSuccess', { name: response.data.name_es || t('adminCamarero.modifierGroupHook.fallbackGroupName') }), // Nueva clave para fallback
                color: 'green',
            });
            await fetchModifierGroups();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.createError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const updateModifierGroup = async (groupId: string, data: Partial<ModifierGroupFormData>): Promise<ModifierGroupData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.put<ModifierGroupData>(groupApiEndpoint(groupId), data);
            notifications.show({
                title: t('adminCommon.updateSuccess'),
                message: t('adminCamarero.manageMenu.modifierGroupUpdateSuccess', { name: response.data.name_es || t('adminCamarero.modifierGroupHook.fallbackGroupName') }),
                color: 'green',
            });
            await fetchModifierGroups();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.updateError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const deleteModifierGroup = async (groupId: string): Promise<boolean> => {
        setLoading(true);
        try {
            await axiosInstance.delete(groupApiEndpoint(groupId));
            notifications.show({
                title: t('adminCommon.deleteSuccess'),
                message: t('adminCamarero.manageMenu.modifierGroupDeleteSuccess'),
                color: 'green',
            });
            await fetchModifierGroups();
            return true;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.deleteError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return false;
        } finally {
            if (loading) setLoading(false);
        }
    };

    return {
        modifierGroups,
        loading,
        error,
        fetchModifierGroups,
        addModifierGroup,
        updateModifierGroup,
        deleteModifierGroup,
    };
};


// ====== [151] frontend/src/modules/camarero/hooks/useAdminModifierOptions.ts ======
// frontend/src/hooks/useAdminModifierOptions.ts
import { useState, useCallback, useEffect } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next'; // Importar useTranslation
import { ModifierOptionData, ModifierOptionFormData } from '../types/menu.types';

const getOptionsApiEndpoint = (modifierGroupId: string) => `/camarero/admin/modifier-groups/${modifierGroupId}/options`;
const optionApiEndpoint = (modifierOptionId: string) => `/camarero/admin/modifier-options/${modifierOptionId}`;

export interface UseAdminModifierOptionsReturn {
    modifierOptions: ModifierOptionData[];
    loading: boolean;
    error: string | null;
    fetchModifierOptions: () => Promise<void>;
    addModifierOption: (data: ModifierOptionFormData) => Promise<ModifierOptionData | null>;
    updateModifierOption: (optionId: string, data: Partial<ModifierOptionFormData>) => Promise<ModifierOptionData | null>;
    deleteModifierOption: (optionId: string) => Promise<boolean>;
}

export const useAdminModifierOptions = (modifierGroupId: string | null): UseAdminModifierOptionsReturn => {
    const { t } = useTranslation(); // Inicializar hook
    const [modifierOptions, setModifierOptions] = useState<ModifierOptionData[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    const fetchModifierOptions = useCallback(async () => {
        if (!modifierGroupId) {
            setModifierOptions([]);
            setLoading(false);
            return;
        }
        setLoading(true);
        setError(null);
        console.log(`[useAdminModifierOptions] Fetching options for modifierGroupId: ${modifierGroupId}`);
        try {
            const response = await axiosInstance.get<ModifierOptionData[]>(getOptionsApiEndpoint(modifierGroupId));
            setModifierOptions(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCamarero.modifierOptionHook.errorLoadingOptions'); // Usar clave
            setError(msg);
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
        } finally {
            setLoading(false);
        }
    }, [modifierGroupId, t]); // A√±adir t como dependencia

    useEffect(() => {
        if (modifierGroupId) {
            fetchModifierOptions();
        } else {
            setModifierOptions([]);
        }
    }, [modifierGroupId, fetchModifierOptions]);

    const addModifierOption = async (data: ModifierOptionFormData): Promise<ModifierOptionData | null> => {
        if (!modifierGroupId) {
            notifications.show({
                title: t('common.error'),
                message: t('adminCamarero.modifierOptionHook.errorNoGroupForOption'), // Usar clave
                color: 'red'
            });
            return null;
        }
        setLoading(true);
        try {
            const response = await axiosInstance.post<ModifierOptionData>(getOptionsApiEndpoint(modifierGroupId), data);
            notifications.show({
                title: t('common.success'),
                message: t('adminCamarero.modifierOptionHook.createSuccess', { optionName: response.data.name_es || t('adminCamarero.modifierOptionHook.fallbackOptionName') }), // Usar clave
                color: 'green',
            });
            await fetchModifierOptions();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCamarero.modifierOptionHook.errorCreatingOption'); // Usar clave
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const updateModifierOption = async (optionId: string, data: Partial<ModifierOptionFormData>): Promise<ModifierOptionData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.put<ModifierOptionData>(optionApiEndpoint(optionId), data);
            notifications.show({
                title: t('common.success'),
                message: t('adminCamarero.modifierOptionHook.updateSuccess', { optionName: response.data.name_es || t('adminCamarero.modifierOptionHook.fallbackOptionName') }), // Usar clave
                color: 'green',
            });
            await fetchModifierOptions();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCamarero.modifierOptionHook.errorUpdatingOption'); // Usar clave
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const deleteModifierOption = async (optionId: string): Promise<boolean> => {
        setLoading(true);
        try {
            await axiosInstance.delete(optionApiEndpoint(optionId));
            notifications.show({
                title: t('common.success'),
                message: t('adminCamarero.modifierOptionHook.deleteSuccess'), // Usar clave
                color: 'green',
            });
            await fetchModifierOptions();
            return true;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCamarero.modifierOptionHook.errorDeletingOption'); // Usar clave
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return false;
        } finally {
            if (loading) setLoading(false);
        }
    };

    return {
        modifierOptions,
        loading,
        error,
        fetchModifierOptions,
        addModifierOption,
        updateModifierOption,
        deleteModifierOption,
    };
};


// ====== [152] frontend/src/modules/camarero/hooks/useMenuItemConfigurator.ts ======
// frontend/src/hooks/useMenuItemConfigurator.ts
import { useState, useEffect, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import {
    PublicMenuItem,
    ModifierUiType,
} from '../types/menu.types';
import { ConfiguringItemState } from '../types/publicOrder.types';

const getTranslatedNameHelper = (item: { name_es?: string | null, name_en?: string | null }, lang: string, defaultName: string = 'Unnamed') => {
    if (lang === 'es' && item.name_es) return item.name_es;
    if (lang === 'en' && item.name_en) return item.name_en;
    return item.name_es || item.name_en || defaultName;
};

export interface UseMenuItemConfiguratorReturn {
    configuringItem: ConfiguringItemState | null;
    startConfiguringItem: (item: PublicMenuItem) => void;
    cancelConfiguration: () => void;
    updateConfigQuantity: (newQuantity: number) => void;
    updateConfigModifierSelection: (groupId: string, newSelection: string | string[], groupUiType: ModifierUiType) => void;
    updateConfigNotes: (newNotes: string) => void;
}

export const useMenuItemConfigurator = (): UseMenuItemConfiguratorReturn => {
    const { i18n } = useTranslation();
    const currentLang = i18n.language;
    const [configuringItem, setConfiguringItem] = useState<ConfiguringItemState | null>(null);

    const calculatePriceAndValidate = useCallback((itemDetails: PublicMenuItem, selectedOptions: Record<string, string[] | string>): { newPrice: number; isValid: boolean } => {
        let newPrice = itemDetails.price;
        let isValid = true;
        const itemNameForLog = getTranslatedNameHelper(itemDetails, currentLang, "Item Desconocido");

        if (Array.isArray(itemDetails.modifierGroups)) {
            for (const group of itemDetails.modifierGroups) {
                const groupNameForLog = getTranslatedNameHelper(group, currentLang, "Grupo Desconocido");
                const selections = selectedOptions[group.id];
                let count = 0;
                let currentSelectionsForGroup: string[] = [];

                if (Array.isArray(selections)) {
                    currentSelectionsForGroup = selections.filter(s => s && s.trim() !== '');
                    count = currentSelectionsForGroup.length;
                } else if (typeof selections === 'string' && selections.trim() !== '') {
                    currentSelectionsForGroup = [selections.trim()];
                    count = 1;
                }

                if (group.isRequired && count < group.minSelections) isValid = false;
                if (count > group.maxSelections) isValid = false;
                if (group.uiType === ModifierUiType.RADIO && count > 1) isValid = false;
                
                if(Array.isArray(group.options)) {
                    currentSelectionsForGroup.forEach(optionId => {
                        const option = group.options.find(opt => opt.id === optionId);
                        if (option) {
                            newPrice += option.priceAdjustment;
                        } else {
                            console.warn(`[useMenuItemConfigurator] Option ID "${optionId}" not found in group "${groupNameForLog}" for item "${itemNameForLog}".`);
                        }
                    });
                }
            }
        }
        return { newPrice, isValid };
    }, [currentLang]);

    useEffect(() => {
        if (configuringItem) {
            const { newPrice, isValid } = calculatePriceAndValidate(configuringItem.itemDetails, configuringItem.selectedOptionsByGroup);
            if (newPrice !== configuringItem.currentUnitPrice || isValid !== configuringItem.areModifiersValid) {
                setConfiguringItem(prev => prev ? { ...prev, currentUnitPrice: newPrice, areModifiersValid: isValid } : null);
            }
        }
    }, [configuringItem, calculatePriceAndValidate, currentLang]);

    const startConfiguringItem = useCallback((item: PublicMenuItem) => {
        const initialSelectedOptions: Record<string, string[] | string> = {};
        if (Array.isArray(item.modifierGroups)) {
            item.modifierGroups.forEach(group => {
                const optionsAvailable = Array.isArray(group.options) ? group.options : [];
                const defaultOptions = optionsAvailable.filter(opt => opt.isDefault && opt.isAvailable);

                if (group.uiType === ModifierUiType.RADIO) {
                    let defaultRadioOptionId = '';
                    if (defaultOptions.length > 0) {
                        defaultRadioOptionId = defaultOptions[0].id;
                    } else if (optionsAvailable.length > 0 && group.isRequired && group.minSelections === 1) {
                        const firstAvailableOption = optionsAvailable.find(opt => opt.isAvailable);
                        if (firstAvailableOption) defaultRadioOptionId = firstAvailableOption.id;
                    }
                    initialSelectedOptions[group.id] = defaultRadioOptionId;
                } else {
                    initialSelectedOptions[group.id] = defaultOptions.map(opt => opt.id);
                }
            });
        }
        const {newPrice, isValid} = calculatePriceAndValidate(item, initialSelectedOptions);
        setConfiguringItem({
            itemDetails: item,
            quantity: 1,
            selectedOptionsByGroup: initialSelectedOptions,
            currentUnitPrice: newPrice,
            itemNotes: '',
            areModifiersValid: isValid
        });
    }, [calculatePriceAndValidate, currentLang]);

    const cancelConfiguration = useCallback(() => setConfiguringItem(null), []);
    const updateConfigQuantity = useCallback((newQuantity: number) => setConfiguringItem(prev => prev ? { ...prev, quantity: newQuantity } : null), []);

    const updateConfigModifierSelection = useCallback((groupId: string, newSelection: string | string[]) => {
        setConfiguringItem(prev => {
            if (!prev) return null;
            return {
                ...prev,
                selectedOptionsByGroup: {
                    ...prev.selectedOptionsByGroup,
                    [groupId]: newSelection
                }
            };
        });
    }, []);
    
    const updateConfigNotes = useCallback((newNotes: string) => setConfiguringItem(prev => prev ? { ...prev, itemNotes: newNotes } : null), []);

    return {
        configuringItem,
        startConfiguringItem,
        cancelConfiguration,
        updateConfigQuantity,
        updateConfigModifierSelection,
        updateConfigNotes,
    };
};


// ====== [153] frontend/src/modules/camarero/hooks/usePublicMenuData.ts ======
// frontend/src/hooks/usePublicMenuData.ts
// Version 1.0.0 (Created to encapsulate menu fetching logic)

import { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { useTranslation } from 'react-i18next';
import { PublicDigitalMenuData } from '../types/menu.types';

const API_MENU_BASE_URL = import.meta.env.VITE_API_BASE_URL_PUBLIC || 'http://localhost:3000/public';

export interface UsePublicMenuDataReturn {
    menuData: PublicDigitalMenuData | null;
    loadingMenu: boolean;
    errorMenu: string | null;
    fetchMenu: () => void;
}

export const usePublicMenuData = (businessSlug: string | undefined): UsePublicMenuDataReturn => {
    const { t } = useTranslation();
    const [menuData, setMenuData] = useState<PublicDigitalMenuData | null>(null);
    const [loadingMenu, setLoadingMenu] = useState<boolean>(true);
    const [errorMenu, setErrorMenu] = useState<string | null>(null);

    const fetchMenu = useCallback(async () => {
        if (!businessSlug) {
            setErrorMenu(t('error.missingBusinessSlug'));
            setLoadingMenu(false);
            return;
        }
        setLoadingMenu(true);
        setErrorMenu(null);
        try {
            const response = await axios.get<PublicDigitalMenuData>(`${API_MENU_BASE_URL}/menu/business/${businessSlug}`);
            if (response.data) {
                // Parse prices from string to number, as Prisma Decimal can be serialized as string
                const parsedMenuData = {
                    ...response.data,
                    categories: response.data.categories.map(c => ({
                        ...c,
                        items: c.items.map(i => ({
                            ...i,
                            price: parseFloat(String(i.price)),
                            modifierGroups: Array.isArray(i.modifierGroups) ? i.modifierGroups.map(g => ({
                                ...g,
                                options: Array.isArray(g.options) ? g.options.map(o => ({ ...o, priceAdjustment: parseFloat(String(o.priceAdjustment)) })) : []
                            })) : []
                        }))
                    }))
                };
                setMenuData(parsedMenuData);
            } else {
                throw new Error(t('error.noMenuDataReceived'));
            }
        } catch (err: any) {
            setErrorMenu(err.response?.data?.message || err.message || t('common.errorUnknown'));
            setMenuData(null);
        } finally {
            setLoadingMenu(false);
        }
    }, [businessSlug, t]);

    useEffect(() => {
        fetchMenu();
    }, [fetchMenu]);

    return { menuData, loadingMenu, errorMenu, fetchMenu };
};


// ====== [154] frontend/src/modules/camarero/hooks/usePublicOrderCart.ts ======
// frontend/src/modules/camarero/hooks/usePublicOrderCart.ts
// VERSI√ìN 4.1.0 - FINAL Y CORRECTA: Tipado expl√≠cito en todo el hook.

import React, { useState, useEffect, useCallback } from 'react';
import { notifications, NotificationData } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
import { IconShoppingCartPlus, IconCheck } from '@tabler/icons-react';
import { v4 as uuidv4 } from 'uuid';

import { OrderItemFE } from '../types/publicOrder.types';
import type { Reward } from '../../../shared/types/user.types';

const LOCAL_STORAGE_CART_KEY_PREFIX = 'loyalpyme_public_cart_v4_';
const NOTES_STORAGE_KEY_PREFIX = 'loyalpyme_public_order_notes_v4_';

// Estructura m√≠nima para a√±adir un √≠tem de recompensa.
export interface MinimalItemForReward {
    id: string;
    name_es: string | null;
    name_en: string | null;
}

export const usePublicOrderCart = (
    businessSlug: string | undefined,
    tableIdentifier: string | undefined,
    activeOrderId: string | null
) => {
    const { t, i18n } = useTranslation();
    const currentLang = i18n.language;

    const [currentOrderItems, setCurrentOrderItems] = useState<OrderItemFE[]>([]);
    const [orderNotes, setOrderNotes] = useState<string>('');

    const cartStorageKey = businessSlug ? `${LOCAL_STORAGE_CART_KEY_PREFIX}${businessSlug}${tableIdentifier ? `_${tableIdentifier}` : ''}` : null;
    const notesStorageKey = businessSlug ? `${NOTES_STORAGE_KEY_PREFIX}${businessSlug}${tableIdentifier ? `_${tableIdentifier}` : ''}` : null;

    // Cargar desde localStorage al montar
    const loadCartFromStorage = useCallback(() => {
        if (activeOrderId || !cartStorageKey) {
            setCurrentOrderItems([]);
            setOrderNotes('');
            return;
        }
        try {
            const savedCart = localStorage.getItem(cartStorageKey);
            const savedNotes = localStorage.getItem(notesStorageKey || '');
            setCurrentOrderItems(savedCart ? JSON.parse(savedCart) : []);
            setOrderNotes(savedNotes || '');
        } catch (e) {
            console.error("Error parsing cart state from localStorage", e);
            setCurrentOrderItems([]);
            setOrderNotes('');
        }
    }, [cartStorageKey, notesStorageKey, activeOrderId]);

    useEffect(() => {
        loadCartFromStorage();
    }, [loadCartFromStorage]);

    // Guardar en localStorage al cambiar
    useEffect(() => {
        if (!activeOrderId && cartStorageKey) {
            localStorage.setItem(cartStorageKey, JSON.stringify(currentOrderItems));
        }
    }, [currentOrderItems, cartStorageKey, activeOrderId]);

    useEffect(() => {
        if (!activeOrderId && notesStorageKey) {
            localStorage.setItem(notesStorageKey, orderNotes);
        }
    }, [orderNotes, notesStorageKey, activeOrderId]);

    // --- FUNCI√ìN `addFreeItemReward` CON FIRMA CORRECTA ---
    const addFreeItemReward = useCallback((menuItemData: MinimalItemForReward, reward: Reward) => {
        const uniqueCartItemId = `reward-${reward.id}-${uuidv4()}`;

        const newRewardItem: OrderItemFE = {
            cartItemId: uniqueCartItemId,
            menuItemId: menuItemData.id,
            menuItemName_es: menuItemData.name_es,
            menuItemName_en: menuItemData.name_en,
            quantity: 1,
            basePrice: 0,
            currentPricePerUnit: 0,
            totalPriceForItem: 0,
            redeemedRewardId: reward.id,
            selectedModifiers: [],
        };
        
        setCurrentOrderItems((prev: OrderItemFE[]) => [...prev, newRewardItem]);

        const itemName = (currentLang === 'es' ? menuItemData.name_es : menuItemData.name_en) || 'Recompensa';
        notifications.show({
            title: '¬°Recompensa A√±adida!',
            message: `${itemName} se ha a√±adido a tu pedido.`,
            color: 'green',
            icon: <IconCheck size={18} />,
        });
    }, [currentLang]);
    
    const getTranslatedNameHelper = (item: { name_es?: string | null; name_en?: string | null }, lang: string, defaultName: string) => {
        if (lang === 'es' && item.name_es) return item.name_es;
        if (lang === 'en' && item.name_en) return item.name_en;
        return item.name_es || item.name_en || defaultName;
    };

    const addItemToCart = useCallback((newItem: OrderItemFE) => {
        setCurrentOrderItems((prev: OrderItemFE[]) => {
            const existingItem = prev.find((item: OrderItemFE) => item.cartItemId === newItem.cartItemId);
            if (existingItem) {
                return prev.map((item: OrderItemFE) => item.cartItemId === newItem.cartItemId ? { ...item, quantity: item.quantity + newItem.quantity, totalPriceForItem: item.currentPricePerUnit * (item.quantity + newItem.quantity) } : item);
            }
            return [...prev, newItem];
        });
        const itemName = getTranslatedNameHelper({name_es: newItem.menuItemName_es, name_en: newItem.menuItemName_en}, currentLang, t('publicMenu.unnamedItem'));
        const notifData: NotificationData = { title: t('publicMenu.itemAddedTitle'), message: t('publicMenu.itemAddedMessage', { itemName, quantity: newItem.quantity }), color: 'green', icon: <IconShoppingCartPlus size={18} /> };
        notifications.show(notifData);
    }, [currentLang, t]);

    const addSimpleItemToCart = useCallback((menuItem: {id: string; name_es: string | null; name_en: string | null; price: number }, quantity: number) => {
        const cartItemId = menuItem.id;
        setCurrentOrderItems((prev: OrderItemFE[]) => {
            const existingIdx = prev.findIndex((item: OrderItemFE) => item.menuItemId === menuItem.id && (!item.selectedModifiers || item.selectedModifiers.length === 0) && !item.notes && !item.redeemedRewardId);
            if (existingIdx > -1) { const updated = [...prev]; updated[existingIdx] = { ...updated[existingIdx], quantity: updated[existingIdx].quantity + quantity, totalPriceForItem: updated[existingIdx].currentPricePerUnit * (updated[existingIdx].quantity + quantity) }; return updated; }
            return [...prev, { cartItemId, menuItemId: menuItem.id, menuItemName_es: menuItem.name_es, menuItemName_en: menuItem.name_en, quantity, basePrice: menuItem.price, currentPricePerUnit: menuItem.price, totalPriceForItem: menuItem.price * quantity, notes: undefined, selectedModifiers: [], redeemedRewardId: null }];
        });
        const itemName = getTranslatedNameHelper(menuItem, currentLang, t('publicMenu.unnamedItem'));
        const notifData: NotificationData = { title: t('publicMenu.itemAddedTitle'), message: t('publicMenu.itemAddedMessage', { itemName, quantity }), color: 'green', icon: <IconShoppingCartPlus size={18} /> };
        notifications.show(notifData);
    }, [currentLang, t]);

    const updateItemQuantityInCart = useCallback((cartItemId: string, newQuantity: number) => {
        setCurrentOrderItems((prev: OrderItemFE[]) => prev.map((item: OrderItemFE) => item.cartItemId === cartItemId ? { ...item, quantity: newQuantity, totalPriceForItem: item.currentPricePerUnit * newQuantity } : item).filter((item: OrderItemFE) => item.quantity > 0));
    }, []);

    const removeItemFromCart = useCallback((cartItemId: string) => {
        setCurrentOrderItems((prev: OrderItemFE[]) => prev.filter((item: OrderItemFE) => item.cartItemId !== cartItemId));
    }, []);

    const updateOrderNotes = useCallback((notes: string) => {
        setOrderNotes(notes);
    }, []);

    const clearCart = useCallback(() => {
        setCurrentOrderItems([]);
        setOrderNotes('');
        notifications.show({ title: t('publicMenu.cart.clearedTitle'), message: t('publicMenu.cart.clearedMsg'), color: 'blue', icon: <IconCheck size={18} /> });
    }, [t]);

    const clearCartStorage = useCallback(() => {
        if (cartStorageKey) localStorage.removeItem(cartStorageKey);
        if (notesStorageKey) localStorage.removeItem(notesStorageKey);
    }, [cartStorageKey, notesStorageKey]);
    
    const totalCartItems = currentOrderItems.reduce((sum: number, item: OrderItemFE) => sum + item.quantity, 0);

    return {
        currentOrderItems,
        orderNotes,
        totalCartItems,
        addItemToCart,
        addSimpleItemToCart,
        updateItemQuantityInCart,
        removeItemFromCart,
        updateOrderNotes,
        clearCart,
        clearCartStorage,
        addFreeItemReward,
    };
};


// ====== [155] frontend/src/modules/camarero/hooks/useWaiterPickupItems.ts ======
// frontend/src/hooks/useWaiterPickupItems.ts
import { useState, useCallback, useEffect, useRef } from 'react';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
// IconCheck y IconX no se usar√°n temporalmente en las notificaciones para depurar
// import { IconCheck, IconX } from '@tabler/icons-react'; 

import { getReadyForPickupItems, markOrderItemAsServed } from '../services/waiterService';
import type { ReadyPickupItem } from '../types/camarero.types';

const POLLING_INTERVAL_MS = 15000;

export interface UseWaiterPickupItemsReturn {
    items: ReadyPickupItem[];
    isLoadingInitial: boolean;
    fetchError: string | null;
    markingItemId: string | null;
    fetchItems: (isInitialLoad?: boolean) => Promise<void>; // La declaraci√≥n es Promise<void>
    handleMarkAsServed: (orderItemId: string) => Promise<void>;
}

export const useWaiterPickupItems = (): UseWaiterPickupItemsReturn => {
    const { t, i18n } = useTranslation();
    const [items, setItems] = useState<ReadyPickupItem[]>([]);
    const [isLoadingInitial, setIsLoadingInitial] = useState<boolean>(true);
    const [fetchError, setFetchError] = useState<string | null>(null);
    const [markingItemId, setMarkingItemId] = useState<string | null>(null);

    const pollingTimeoutRef = useRef<number | null>(null);
    const isMountedRef = useRef<boolean>(true);

    // fetchItems: Obtiene los √≠tems listos del servidor.
    // La declaraci√≥n de retorno es Promise<void> porque es una funci√≥n async que no devuelve un valor expl√≠cito.
    const fetchItems = useCallback(async (isInitialLoad = false): Promise<void> => {
        if (isInitialLoad) {
            setIsLoadingInitial(true);
            setFetchError(null);
        }
        // console.log(`[useWaiterPickupItems] Fetching items. Initial: ${isInitialLoad}`);

        try {
            const fetchedItems = await getReadyForPickupItems();
            if (isMountedRef.current) {
                setItems(fetchedItems);
                if (fetchError && !isInitialLoad) { // Limpiar error si un fetch posterior es exitoso
                    setFetchError(null);
                }
            }
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            if (isMountedRef.current) {
                setFetchError(msg);
                // console.error("[useWaiterPickupItems] Error fetching items:", msg);
            }
        } finally {
            if (isMountedRef.current && isInitialLoad) {
                setIsLoadingInitial(false);
            }
        }
    }, [t, fetchError]); // Dependencias: t, fetchError

    // Efecto para la carga inicial y limpieza al desmontar
    useEffect(() => {
        isMountedRef.current = true;
        fetchItems(true); // Carga inicial
        return () => {
            isMountedRef.current = false;
            if (pollingTimeoutRef.current) {
                clearTimeout(pollingTimeoutRef.current);
            }
        };
    }, [fetchItems]); // Solo depende de fetchItems para la carga inicial

    // Efecto para el polling
    useEffect(() => {
        if (pollingTimeoutRef.current) {
            clearTimeout(pollingTimeoutRef.current);
        }
        // Condiciones para activar el polling
        if (!isLoadingInitial && !fetchError && !markingItemId && isMountedRef.current) {
            pollingTimeoutRef.current = window.setTimeout(() => {
                // console.log(`[useWaiterPickupItems] Polling for new items...`);
                fetchItems(false);
            }, POLLING_INTERVAL_MS);
        }
        // Funci√≥n de limpieza para este efecto espec√≠fico (se ejecuta si las dependencias cambian o al desmontar)
        return () => {
            if (pollingTimeoutRef.current) {
                clearTimeout(pollingTimeoutRef.current);
            }
        };
    }, [items, isLoadingInitial, fetchError, markingItemId, fetchItems]); // Dependencias que reinician el polling

    // handleMarkAsServed: Marca un √≠tem como servido
    const handleMarkAsServed = async (orderItemId: string): Promise<void> => {
        if (markingItemId) { // Prevenir acciones concurrentes
            notifications.show({
                title: t('common.info'),
                message: t('waiterInterface.actionInProgress', 'Por favor, espera a que la acci√≥n actual termine.'),
                color: 'yellow',
            });
            return;
        }

        setMarkingItemId(orderItemId);

        const itemToMark = items.find(it => it.orderItemId === orderItemId);
        const itemNameForNotification =
            (i18n.language === 'es' && itemToMark?.itemNameSnapshot_es)
                ? itemToMark.itemNameSnapshot_es
                : (itemToMark?.itemNameSnapshot_en || itemToMark?.itemNameSnapshot_es || t('common.item', '√çtem'));

        try {
            await markOrderItemAsServed(orderItemId); // Llamada al servicio

            if (isMountedRef.current) {
                notifications.show({ // Notificaci√≥n SIN icono temporalmente
                    title: t('common.success'),
                    message: t('waiterInterface.itemMarkedServedSuccess', { itemName: itemNameForNotification }),
                    color: 'green',
                    // icon: <IconCheck size={18} />, // TEMPORALMENTE COMENTADO
                });
                fetchItems(); // Refrescar la lista para mostrar los cambios
            }
        } catch (err: any) {
            const errorMsg = err.response?.data?.message || err.message || t('waiterInterface.errorMarkingServed', 'Error al marcar el √≠tem como servido.');
            if (isMountedRef.current) {
                notifications.show({ // Notificaci√≥n SIN icono temporalmente
                    title: t('common.error'),
                    message: errorMsg,
                    color: 'red',
                    // icon: <IconX size={18} />, // TEMPORALMENTE COMENTADO
                });
                // console.error(`[useWaiterPickupItems] Error marking item ${orderItemId} as served:`, err);
            }
        } finally {
            if (isMountedRef.current) {
                setMarkingItemId(null);
            }
        }
    };

    return {
        items,
        isLoadingInitial,
        fetchError,
        markingItemId,
        fetchItems,
        handleMarkAsServed,
    };
};


// ====== [156] frontend/src/modules/camarero/pages/OrderStatusPage.tsx ======
// frontend/src/modules/camarero/pages/OrderStatusPage.tsx
// Version 2.9.7 - Corrected prop name from 'coupons' to 'availableCoupons' in ApplyRewardModal call.

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useParams, useLocation, Link, useNavigate } from 'react-router-dom';
import axios from 'axios';
import {
    Container, Title, Text, Loader, Alert, Paper, Stack, Group,
    Button, Divider, Badge, List, ThemeIcon, Box
} from '@mantine/core';
import {
    IconAlertCircle, IconClipboardList, IconToolsKitchen, IconChefHat,
    IconCircleCheck, IconCircleX, IconReload, IconArrowLeft, IconShoppingCart,
    IconPlus, IconCreditCard, IconDiscount2
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { notifications } from '@mantine/notifications';
import { useDisclosure } from '@mantine/hooks';

import axiosInstance from '../../../shared/services/axiosInstance';
import { GrantedReward, OrderStatus, OrderItemStatus } from '../../../shared/types/user.types';
import ApplyRewardModal, { AppliedSelections } from '../../loyalpyme/components/customer/ApplyRewardModal';
import { PublicOrderStatusInfo } from '../types/publicOrder.types';
import OrderBillView from '../components/public/menu/order/OrderBillView';

const API_BASE_URL_PUBLIC = import.meta.env.VITE_API_BASE_URL_PUBLIC || 'http://localhost:3000/public';
const POLLING_INTERVAL = 10000;
const ACTIVE_ORDER_INFO_KEY_PREFIX = 'loyalpyme_active_order_info_';

const OrderStatusPage: React.FC = () => {
    const { t, i18n } = useTranslation();
    const { orderId } = useParams<{ orderId: string; }>();
    const location = useLocation();
    const navigate = useNavigate();

    const navigationState = location.state as { orderNumber?: string; businessSlug?: string, tableIdentifier?: string } | null;
    const displayOrderNumber = navigationState?.orderNumber || orderId;
    const businessSlugForReturn = navigationState?.businessSlug;
    const currentTableIdentifierForReturn = navigationState?.tableIdentifier;

    const [orderStatusData, setOrderStatusData] = useState<PublicOrderStatusInfo | null>(null);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const pollingTimeoutRef = useRef<number | null>(null);
    const [isRequestingBill, setIsRequestingBill] = useState<boolean>(false);
    
    const [availableCoupons, setAvailableCoupons] = useState<GrantedReward[]>([]);
    const [loadingCoupons, setLoadingCoupons] = useState(false);
    const [applyModalOpened, { open: openApplyModal, close: closeApplyModal }] = useDisclosure(false);
    const [isApplyingReward, setIsApplyingReward] = useState(false);
    const activeOrderKey = businessSlugForReturn ? `${ACTIVE_ORDER_INFO_KEY_PREFIX}${businessSlugForReturn}${currentTableIdentifierForReturn ? `_${currentTableIdentifierForReturn}` : ''}` : null;

    const isOrderConsideredFinal = (status: OrderStatus | undefined): boolean => {
        if (!status) return false;
        return [ OrderStatus.PAID, OrderStatus.CANCELLED, OrderStatus.PAYMENT_FAILED ].includes(status);
    };

    const canAddMoreItemsToOrder = (status: OrderStatus | undefined): boolean => {
        if (!status) return false;
        return [
            OrderStatus.RECEIVED, OrderStatus.IN_PROGRESS, OrderStatus.PARTIALLY_READY,
            OrderStatus.ALL_ITEMS_READY, OrderStatus.COMPLETED
        ].includes(status);
    };

    const fetchOrderStatus = useCallback(async (isInitialFetch = false) => {
        if (!orderId) { setError(t('orderStatusPage.error.missingOrderId')); if (isInitialFetch) setLoading(false); return; }
        if (isInitialFetch) { setLoading(true); setError(null); }
        try {
            const response = await axios.get<PublicOrderStatusInfo>(`${API_BASE_URL_PUBLIC}/order/${orderId}/status`);
            setOrderStatusData(response.data ?? null);
            if (error) setError(null);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorUnknown');
            setError(msg);
            if (err.response?.status === 404) setOrderStatusData(null);
        } finally { if (isInitialFetch) setLoading(false); }
    }, [orderId, t, error]);
    
    const fetchAvailableCoupons = useCallback(async () => {
        const token = localStorage.getItem('token'); if (!token) return; setLoadingCoupons(true);
        try {
            const response = await axiosInstance.get<GrantedReward[]>('/customer/available-coupons');
            setAvailableCoupons(response.data || []);
        } catch (err) { console.error("Error fetching available coupons:", err); } finally { setLoadingCoupons(false); }
    }, []);

    useEffect(() => {
        fetchOrderStatus(true);
        fetchAvailableCoupons();
    }, [fetchOrderStatus, fetchAvailableCoupons]);

    const shouldPoll = !isOrderConsideredFinal(orderStatusData?.orderStatus) && !loading && !error && !isRequestingBill && !isApplyingReward;

    useEffect(() => {
        if (shouldPoll) { pollingTimeoutRef.current = window.setTimeout(() => fetchOrderStatus(false), POLLING_INTERVAL); }
        return () => { if (pollingTimeoutRef.current) clearTimeout(pollingTimeoutRef.current); };
    }, [orderStatusData, shouldPoll, fetchOrderStatus]);

    useEffect(() => {
        if (isOrderConsideredFinal(orderStatusData?.orderStatus) && activeOrderKey && orderStatusData?.orderId === orderId) { localStorage.removeItem(activeOrderKey); }
    }, [orderStatusData?.orderStatus, activeOrderKey, orderId]);

    const handleApplyReward = async (selections: AppliedSelections) => {
        if (!orderId) return;
        const discountToApply = selections.discount;
        if (!discountToApply || !discountToApply.isGift || !discountToApply.grantedRewardId) {
            closeApplyModal(); return;
        }
        const grantedRewardId = discountToApply.grantedRewardId;
        setIsApplyingReward(true);
        closeApplyModal();
        try {
            await axiosInstance.patch(`/public/order/${orderId}/apply-reward`, { grantedRewardId });
            notifications.show({ title: "¬°√âxito!", message: "La recompensa se ha aplicado correctamente a tu pedido.", color: 'green', icon: <IconCircleCheck/> });
            await fetchOrderStatus(false);
            await fetchAvailableCoupons();
        } catch (err: any) {
            const msg = err.response?.data?.message || "No se pudo aplicar la recompensa.";
            notifications.show({ title: "Error", message: msg, color: 'red' });
        } finally {
            setIsApplyingReward(false);
        }
    };
    
    const handleRequestBill = async () => {
        if (!orderId || !orderStatusData || isRequestingBill) return;
        setIsRequestingBill(true); setError(null);
        try {
            await axios.post(`${API_BASE_URL_PUBLIC}/order/${orderId}/request-bill`);
            notifications.show({ title: t('common.success'), message: t('orderStatusPage.billRequestedSuccess'), color: 'green', icon: <IconCircleCheck /> });
            fetchOrderStatus(false);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorUnknown');
            setError(msg);
            notifications.show({ title: t('common.error'), message: t('orderStatusPage.errorRequestingBill', { message: msg }), color: 'red', icon: <IconAlertCircle /> });
        } finally { setIsRequestingBill(false); }
    };
    
    const handleStartNewOrder = () => {
        if (activeOrderKey) localStorage.removeItem(activeOrderKey);
        const cartKey = businessSlugForReturn ? `loyalpyme_public_cart_${businessSlugForReturn}${currentTableIdentifierForReturn ? `_${currentTableIdentifierForReturn}` : ''}` : null;
        if (cartKey) localStorage.removeItem(cartKey);
        if (businessSlugForReturn) {
            navigate(`/m/${businessSlugForReturn}${currentTableIdentifierForReturn ? `/${currentTableIdentifierForReturn}` : ''}`, { replace: true });
        } else {
            navigate('/login', { replace: true });
        }
    };

    const getOrderItemStatusInfo = (status: OrderItemStatus): { text: string; color: string; icon: React.ReactNode } => {
        switch (status) {
            case OrderItemStatus.PENDING_KDS: return { text: t('orderStatusPage.itemStatus.pending_kds'), color: 'gray', icon: <IconClipboardList size={16}/> };
            case OrderItemStatus.PREPARING: return { text: t('orderStatusPage.itemStatus.preparing'), color: 'blue', icon: <IconToolsKitchen size={16}/> };
            case OrderItemStatus.READY: return { text: t('orderStatusPage.itemStatus.ready'), color: 'lime', icon: <IconChefHat size={16}/> };
            case OrderItemStatus.SERVED: return { text: t('orderStatusPage.itemStatus.served'), color: 'green', icon: <IconCircleCheck size={16}/> };
            case OrderItemStatus.CANCELLED: return { text: t('orderStatusPage.itemStatus.cancelled'), color: 'red', icon: <IconCircleX size={16}/> };
            case OrderItemStatus.CANCELLATION_REQUESTED: return { text: t('orderStatusPage.itemStatus.cancellation_requested'), color: 'orange', icon: <IconAlertCircle size={16}/> };
            default: return { text: String(t(status as string, status as string)), color: 'gray', icon: <IconClipboardList size={16}/> };
        }
    };

    const getOrderStatusText = (status: OrderStatus | undefined): string => {
        if (!status) return t('common.loading');
        return String(t(`orderStatusPage.orderStatus.${status.toLowerCase()}`, status as string));
    };

    if (loading && !orderStatusData) {
        return <Container size="sm" py="xl" style={{ display: 'flex', justifyContent: 'center' }}><Loader size="xl" /></Container>;
    }
    
    if (!orderStatusData) {
        return (
            <Container size="sm" py="xl">
                {error ? (
                     <Alert icon={<IconAlertCircle size="1rem" />} title={t('common.error')} color="red" radius="md">{error}</Alert>
                ) : (
                    <Text ta="center" c="dimmed">{t('orderStatusPage.error.notFound')}</Text>
                )}
            </Container>
        );
    }
    
    const { orderNumber, orderStatus, items, tableIdentifier: orderTableIdentifier, orderNotes: generalOrderNotes, createdAt } = orderStatusData;
    const canRequestBill = orderStatus === OrderStatus.COMPLETED || orderStatus === OrderStatus.ALL_ITEMS_READY;
    const canApplyReward = orderStatus === OrderStatus.PENDING_PAYMENT && availableCoupons.length > 0 && !isApplyingReward;
    const showAddMoreItemsButton = canAddMoreItemsToOrder(orderStatus);
    const showBillView = orderStatus === OrderStatus.PENDING_PAYMENT || orderStatus === OrderStatus.PAID;
    
    return (
        <>
            <Container size="md" py="xl">
                <Paper shadow="md" p="xl" radius="lg" withBorder>
                    <Stack gap="lg">
                        <Title order={2} ta="center">{t('orderStatusPage.title')}</Title>
                        <Text ta="center" fz="xl" fw={700}>#{orderNumber || displayOrderNumber}</Text>
                        <Paper withBorder p="md" radius="sm" bg={i18n.language === 'dark' ? "dark.6" : "gray.0"}>
                            <Group justify="space-between"><Text fw={500}>{t('orderStatusPage.generalStatus')}</Text><Badge size="lg" color="blue" variant="filled">{getOrderStatusText(orderStatus)}</Badge></Group>
                            {orderTableIdentifier && <Text size="sm" mt="xs">{t('orderStatusPage.table')} <Text span fw={500}>{orderTableIdentifier}</Text></Text>}
                            <Text size="sm" c="dimmed" mt="xs">{t('orderStatusPage.placedAt')} {new Date(createdAt).toLocaleString(i18n.language, { dateStyle: 'medium', timeStyle: 'short' })}</Text>
                        </Paper>
                        {showBillView ? (<OrderBillView orderData={orderStatusData} />) : ( <> <Divider my="sm" label={t('orderStatusPage.itemsTitle')} labelPosition="center" /> <Box><List spacing="md" listStyleType="none" p={0}>{items.map((item) => { const statusInfo = getOrderItemStatusInfo(item.status); const itemName = item.itemNameSnapshot || '√çtem sin nombre'; return (<List.Item key={item.id} icon={<ThemeIcon color={statusInfo.color} size={24} radius="xl">{statusInfo.icon}</ThemeIcon>}><Paper p="sm" radius="sm" withBorder style={{ flexGrow: 1 }}><Group justify="space-between" wrap="nowrap"><Stack gap={2} style={{flexGrow: 1, minWidth: 0}}><Text fw={500} truncate>{itemName}</Text><Text size="sm" c="dimmed">{t('orderStatusPage.quantity')} {item.quantity}</Text></Stack><Text size="sm" c={statusInfo.color} style={{flexShrink: 0}}>{statusInfo.text}</Text></Group></Paper></List.Item>); })}</List></Box> </> )}
                        {generalOrderNotes && (<><Divider my="sm" label={t('orderStatusPage.orderNotesLabel')} labelPosition="center" /><Paper withBorder p="sm" radius="sm" bg={i18n.language === 'dark' ? "dark.6" : "gray.0"}><Text size="sm" style={{ whiteSpace: 'pre-wrap' }}>{generalOrderNotes}</Text></Paper></>)}
                        <Group justify="space-between" mt="xl" wrap="nowrap">
                            <Group>
                                {showAddMoreItemsButton && businessSlugForReturn && ( <Button component={Link} to={`/m/${businessSlugForReturn}${currentTableIdentifierForReturn ? `/${currentTableIdentifierForReturn}` : ''}`} variant="filled" leftSection={<IconPlus size={16} />} mr="sm">{t('orderStatusPage.addMoreItemsButton')}</Button> )}
                                {canApplyReward && ( <Button variant="filled" color="violet" onClick={openApplyModal} loading={loadingCoupons} disabled={isRequestingBill || isApplyingReward} leftSection={<IconDiscount2 size={16} />}>Aplicar Recompensa</Button> )}
                                {canRequestBill && ( <Button variant="gradient" gradient={{ from: 'orange', to: 'yellow' }} onClick={handleRequestBill} loading={isRequestingBill} leftSection={<IconCreditCard size={16} />}>{t('orderStatusPage.requestBillButton')}</Button> )}
                                {!isOrderConsideredFinal(orderStatus) && ( <Button variant="outline" onClick={() => fetchOrderStatus(false)} leftSection={<IconReload size={16}/>} loading={loading && !!orderStatusData} disabled={isRequestingBill || isApplyingReward}>{t('orderStatusPage.refreshButton')}</Button> )}
                                {isOrderConsideredFinal(orderStatus) && ( <Button variant="filled" color="green" onClick={handleStartNewOrder} leftSection={<IconShoppingCart size={16} />}>{t('publicMenu.activeOrder.startNewButton')}</Button> )}
                            </Group>
                            {businessSlugForReturn ? ( <Button component={Link} to={`/m/${businessSlugForReturn}${currentTableIdentifierForReturn ? `/${currentTableIdentifierForReturn}`: ''}`} variant="light" leftSection={<IconArrowLeft size={16}/>}>{t('orderStatusPage.backToMenuButton')}</Button> ) : ( <Button onClick={() => navigate('/login')} variant="light" leftSection={<IconArrowLeft size={16}/>}> {t('common.back')} </Button> )}
                        </Group>
                    </Stack>
                </Paper>
            </Container>
            
            <ApplyRewardModal
                opened={applyModalOpened}
                onClose={closeApplyModal}
                // --- CORRECCI√ìN DE PROP: `coupons` -> `availableCoupons` ---
                availableCoupons={availableCoupons}
                redeemableRewards={[]}
                initialSelections={{ discount: null, freeItems: [] }}
                onApply={handleApplyReward}
                isApplying={isApplyingReward}
                userPoints={0}
                appliedLcoRewardIdOnActiveOrder={orderStatusData.appliedLcoRewardId}
            />
        </>
    );
};

export default OrderStatusPage;


// ====== [157] frontend/src/modules/camarero/pages/PublicMenuViewPage.tsx ======
// frontend/src/modules/camarero/pages/PublicMenuViewPage.tsx
// VERSI√ìN 6.2.3 - Corregidas las llamadas a addFreeItemReward para pasar el objeto Reward completo.

import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { useParams, useNavigate, Link, useLocation } from 'react-router-dom';
import {
    Container, Title, Loader, Alert, Text, Stack, Paper, Image, Group,
    useMantineTheme, Button, useMantineColorScheme
} from '@mantine/core';
import {
    IconAlertCircle, IconShoppingCart, IconCheck, IconInfoCircle, IconGift, IconLogin,
    IconDashboard, IconAward
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { notifications } from '@mantine/notifications';
import { useDisclosure } from '@mantine/hooks';

// Hooks y Servicios
import { RewardType } from '../../../shared/types/enums';
import { useLayoutUserData } from '../../../shared/hooks/useLayoutUserData';
import { useActiveOrderState } from '../hooks/useActiveOrderState';
import { usePublicOrderCart } from '../hooks/usePublicOrderCart';
import { useMenuItemConfigurator } from '../hooks/useMenuItemConfigurator';
import { usePublicMenuData } from '../hooks/usePublicMenuData';
import { useCustomerRewardsData } from '../../loyalpyme/hooks/useCustomerRewardsData';
import { handleOrderSubmission } from '../services/publicOrderApiService';

// Componentes
import CategoryAccordion from '../components/public/menu/CategoryAccordion';
import ShoppingCartModal from '../components/public/menu/ShoppingCartModal';
import ApplyRewardModal, { AppliedSelections } from '../../loyalpyme/components/customer/ApplyRewardModal';

// Tipos
import type { Reward } from '../../../shared/types/user.types';
import { OrderItemFE } from '../types/publicOrder.types';
import { PublicMenuModifierGroup } from '../types/menu.types';

const PublicMenuViewPage: React.FC = () => {
    // --- Setup de Hooks ---
    const { t, i18n } = useTranslation();
    const theme = useMantineTheme();
    const { colorScheme } = useMantineColorScheme();
    const { businessSlug, tableIdentifier: tableIdentifierFromParams } = useParams<{ businessSlug: string; tableIdentifier?: string }>();
    const navigate = useNavigate();
    const location = useLocation();
    const processedStateKeyRef = useRef<string | null>(null);

    // --- Hooks de Datos ---
    const { menuData, loadingMenu, errorMenu } = usePublicMenuData(businessSlug);
    const { userData } = useLayoutUserData();
    const { redeemableRewards, availableCoupons } = useCustomerRewardsData();
    
    // --- Hooks de Estado de la P√°gina ---
    const { activeOrderId, activeOrderNumber, canCurrentlyAddToExistingOrder, loadingActiveOrderStatus, setActiveOrderManually, activeOrderDetails } = useActiveOrderState(businessSlug, tableIdentifierFromParams);
    const {
        currentOrderItems, orderNotes, totalCartItems,
        addItemToCart, addSimpleItemToCart, removeItemFromCart, updateItemQuantityInCart,
        updateOrderNotes, clearCart, clearCartStorage, addFreeItemReward
    } = usePublicOrderCart(businessSlug, tableIdentifierFromParams, activeOrderId);
    
    const { configuringItem, startConfiguringItem, cancelConfiguration, updateConfigQuantity, updateConfigModifierSelection, updateConfigNotes } = useMenuItemConfigurator();
    
    const [activeAccordionItems, setActiveAccordionItems] = useState<string[]>([]);
    const [isCartOpen, { open: openCart, close: closeCart }] = useDisclosure(false);
    const [isSubmittingOrder, setIsSubmittingOrder] = useState<boolean>(false);
    const [isRewardModalOpen, { open: openRewardModal, close: closeRewardModal }] = useDisclosure(false);
    
    const [appliedRewards, setAppliedRewards] = useState<AppliedSelections>({ discount: null, freeItems: [] });

    // L√≥gica para aplicar recompensa desde el dashboard (al cargar la p√°gina)
    useEffect(() => {
        const rewardToApply = location.state?.rewardToApply as Reward | undefined;
        const grantedRewardId = location.state?.grantedRewardIdToApply as string | undefined;
        const currentLocationKey = location.key;

        if (rewardToApply && menuData && currentLocationKey !== processedStateKeyRef.current) {
            processedStateKeyRef.current = currentLocationKey;

            const menuItemForReward = (rewardToApply.type === RewardType.MENU_ITEM && rewardToApply.linkedMenuItemId)
                ? menuData.categories.flatMap(c => c.items).find(i => i.id === rewardToApply.linkedMenuItemId)
                : rewardToApply;

            if (menuItemForReward) {
                // --- CORRECCI√ìN AQU√ç ---
                // Pasamos el objeto de recompensa completo
                addFreeItemReward(menuItemForReward, rewardToApply, grantedRewardId);
            }
        }
    }, [menuData, location, addFreeItemReward]);
    
    // El resto del c√≥digo no tiene cambios funcionales, solo se corrige el tipado en el JSX
    const subtotal = useMemo(() => currentOrderItems.reduce((acc, item) => acc + item.totalPriceForItem, 0), [currentOrderItems]);
    const calculatedDiscountAmount = useMemo(() => {
        if (!appliedRewards.discount) return 0;
        const discount = appliedRewards.discount;
        const discountValue = discount.discountValue ? Number(discount.discountValue) : 0;
        let baseAmountForDiscount = subtotal;
        if (discount.type === RewardType.DISCOUNT_ON_ITEM && discount.linkedMenuItemId) { baseAmountForDiscount = currentOrderItems.filter(item => item.menuItemId === discount.linkedMenuItemId).reduce((sum, item) => sum + item.totalPriceForItem, 0); }
        let amount = 0;
        if (discount.discountType && discount.discountType.toUpperCase() === 'PERCENTAGE') { amount = baseAmountForDiscount * (discountValue / 100); } else { amount = discountValue; }
        return Math.min(baseAmountForDiscount, amount);
    }, [subtotal, appliedRewards.discount, currentOrderItems]);
    const totalAmountWithDiscount = useMemo(() => Math.max(0, subtotal - calculatedDiscountAmount), [subtotal, calculatedDiscountAmount]);
    const handleSubmitOrderOrAddItems = useCallback(async () => {
        if (currentOrderItems.length === 0 && !appliedRewards.discount) { notifications.show({ title: t('publicMenu.cart.errorTitle'), message: activeOrderId ? t('publicMenu.cart.errorEmptyAddToOrder') : t('publicMenu.cart.errorEmpty'), color: 'orange' }); return; }
        if (!businessSlug) return;
        setIsSubmittingOrder(true);
        try {
            const discountId = appliedRewards.discount ? (appliedRewards.discount.isGift ? appliedRewards.discount.grantedRewardId : appliedRewards.discount.id) : null;
            const response = await handleOrderSubmission(currentOrderItems, orderNotes, canCurrentlyAddToExistingOrder ? activeOrderId : null, businessSlug, tableIdentifierFromParams, userData?.id, discountId);
            const orderIdToNavigate = response.id; const orderNumberToNavigate = response.orderNumber || activeOrderNumber || orderIdToNavigate;
            const successMessage = activeOrderId ? t('publicMenu.cart.itemsAddedSuccessMsg', { orderNumber: orderNumberToNavigate }) : t('publicMenu.cart.orderSuccessMsg', { orderNumber: orderNumberToNavigate });
            notifications.show({ title: activeOrderId ? t('publicMenu.cart.itemsAddedSuccessTitle') : t('publicMenu.cart.orderSuccessTitle'), message: successMessage, color: 'green', icon: <IconCheck /> });
            if (!activeOrderId) setActiveOrderManually(orderIdToNavigate, orderNumberToNavigate);
            clearCart(); setAppliedRewards({ discount: null, freeItems: [] }); clearCartStorage(); closeCart();
            navigate(`/order-status/${orderIdToNavigate}`, { state: { orderNumber: orderNumberToNavigate, businessSlug, tableIdentifier: tableIdentifierFromParams } });
        } catch (err: any) { const errMsg = err.response?.data?.message || err.message || t('publicMenu.cart.orderErrorMsg'); notifications.show({ title: t('publicMenu.cart.orderErrorTitle'), message: errMsg, color: 'red', icon: <IconAlertCircle /> });
        } finally { setIsSubmittingOrder(false); }
    }, [currentOrderItems, orderNotes, canCurrentlyAddToExistingOrder, activeOrderId, businessSlug, tableIdentifierFromParams, userData?.id, navigate, t, setActiveOrderManually, clearCart, clearCartStorage, closeCart, appliedRewards.discount, activeOrderNumber]);
    useEffect(() => { if (menuData?.categories.length && !activeOrderId) setActiveAccordionItems([menuData.categories[0].id]); }, [menuData, activeOrderId]);

    const handleApplyRewardsFromModal = useCallback((selections: AppliedSelections) => {
        if (!menuData) return;
        setAppliedRewards(selections);
        const selectedFreeItemRewardUniqueIds = new Set(selections.freeItems.map(item => item.isGift ? item.grantedRewardId! : item.id));

        currentOrderItems.forEach(cartItem => {
            if (cartItem.redeemedRewardId && !selectedFreeItemRewardUniqueIds.has(cartItem.redeemedRewardId)) {
                removeItemFromCart(cartItem.cartItemId);
            }
        });

        selections.freeItems.forEach(rewardDisplay => {
            const rewardIdToFind = rewardDisplay.isGift ? rewardDisplay.grantedRewardId! : rewardDisplay.id;
            if (!currentOrderItems.some(ci => ci.redeemedRewardId === rewardIdToFind)) {
                const fullReward = redeemableRewards.find(r => r.id === rewardDisplay.id) || availableCoupons.find(c => c.id === rewardIdToFind)?.reward;
                if (fullReward) {
                    const menuItemToRedeem = (fullReward.type === RewardType.MENU_ITEM && fullReward.linkedMenuItemId)
                        ? menuData.categories.flatMap(c => c.items).find(item => item.id === fullReward.linkedMenuItemId)
                        : fullReward;
                    if (menuItemToRedeem) {
                        // --- CORRECCI√ìN AQU√ç ---
                        addFreeItemReward(menuItemToRedeem, fullReward, rewardDisplay.isGift ? rewardIdToFind : undefined);
                    }
                }
            }
        });
        notifications.show({ title: t('applyRewardModal.success.title'), message: t('applyRewardModal.success.message'), color: 'green' });
        closeRewardModal();
    }, [menuData, currentOrderItems, removeItemFromCart, addFreeItemReward, closeRewardModal, t, redeemableRewards, availableCoupons]);
    
    const handleConfiguredItemAddToCart = () => {
        if (!configuringItem) return;
        const { itemDetails, quantity, selectedOptionsByGroup, currentUnitPrice, itemNotes, areModifiersValid } = configuringItem;
        if (!areModifiersValid) { notifications.show({ title: t('publicMenu.invalidSelectionTitle'), message: t('publicMenu.invalidSelectionMsg'), color: 'orange' }); return; }
        const flatSelectedModifiers = Object.entries(selectedOptionsByGroup).flatMap(([groupId, optionSelections]) => {
            const group = itemDetails.modifierGroups.find((g: PublicMenuModifierGroup) => g.id === groupId);
            if (!group?.options) return [];
            const ids = Array.isArray(optionSelections) ? optionSelections.filter(Boolean) : (typeof optionSelections === 'string' ? [optionSelections] : []).filter(Boolean);
            return ids.map(optId => {
                const option = group.options.find((o: any) => o.id === optId);
                return option ? { modifierOptionId: option.id, name_es: option.name_es, name_en: option.name_en, priceAdjustment: option.priceAdjustment, modifierGroupName_es: group.name_es, modifierGroupName_en: group.name_en } : null;
            }).filter((mod): mod is NonNullable<typeof mod> => mod !== null);
        });
        const sortedModifierOptionIds = flatSelectedModifiers.map(mod => mod.modifierOptionId).sort().join(',');
        const notesHash = itemNotes ? `_notes-${itemNotes.toLocaleLowerCase().replace(/\s/g, '')}` : '';
        const cartItemId = `${itemDetails.id}${flatSelectedModifiers.length > 0 ? `-[${sortedModifierOptionIds}]` : ''}${notesHash}`;
        const newCartItem: OrderItemFE = { cartItemId, menuItemId: itemDetails.id, menuItemName_es: itemDetails.name_es, menuItemName_en: itemDetails.name_en, quantity, basePrice: itemDetails.price, currentPricePerUnit: currentUnitPrice, totalPriceForItem: currentUnitPrice * quantity, notes: itemNotes || undefined, selectedModifiers: flatSelectedModifiers, redeemedRewardId: null };
        addItemToCart(newCartItem); cancelConfiguration();
    };

    const isLoadingPage = loadingMenu || loadingActiveOrderStatus;
    const pageError = errorMenu;
    const cartButtonText = activeOrderId && canCurrentlyAddToExistingOrder ? t('publicMenu.cart.addItemsToOrderButton', { count: totalCartItems, orderNumber: activeOrderNumber }) : t('publicMenu.cart.viewOrderItems', { count: totalCartItems });

    if (isLoadingPage) return <Container size="md" py="xl" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '80vh' }}><Loader size="xl" /></Container>;
    if (pageError || !menuData) return <Container size="md" py="xl"><Alert icon={<IconAlertCircle size="1rem" />} title={t('common.error')} color="red" radius="md">{pageError || t('publicMenu.menuNotAvailable')}</Alert></Container>;

    return (
        <>
            <Container size="lg" py="xl">
                <Stack gap="xl">
                    <Group justify="center" align="center" wrap="nowrap"><Image src={menuData.businessLogoUrl || ''} alt={`${menuData.businessName} logo`} h={50} w="auto" fit="contain" radius="sm" /><Title order={1} ta="center" style={{ flexShrink: 1, minWidth: 0 }}>{menuData.businessName}</Title></Group>
                    {menuData.isLoyaltyCoreActive && !userData && (<Paper shadow="xs" p="sm" radius="md" withBorder><Group justify="space-between" align="center"><Group gap="xs"><IconGift size={24} color={theme.colors.blue[6]} /><Text size="sm" fw={500}>¬øQuieres ganar puntos y canjear recompensas?</Text></Group><Button component={Link} to="/login" state={{ from: location }} variant="light" size="xs" leftSection={<IconLogin size={14} />}>Inicia Sesi√≥n o Reg√≠strate</Button></Group></Paper>)}
                    {menuData.isLoyaltyCoreActive && userData && (<Paper shadow="xs" p="sm" radius="md" withBorder bg={colorScheme === 'dark' ? theme.colors.dark[6] : theme.colors.green[0]}><Group justify="space-between" align="center"><Stack gap={0}><Text fw={500}>¬°Hola, {userData.name || userData.email}!</Text><Group gap="xs" mt={2}><IconAward size={16} color={theme.colors.yellow[7]} /><Text size="sm" c="dimmed">Tienes <Text span fw={700}>{userData.points ?? 0}</Text> puntos.</Text></Group></Stack><Button component={Link} to="/customer/dashboard" variant="outline" color="gray" size="xs" leftSection={<IconDashboard size={14} />}>Ver mi Panel</Button></Group></Paper>)}
                    {activeOrderId && !configuringItem && (<Paper shadow="md" p="lg" radius="md" withBorder mb="xl" bg={canCurrentlyAddToExistingOrder ? (colorScheme === 'dark' ? theme.colors.dark[5] : theme.colors.blue[0]) : (colorScheme === 'dark' ? theme.colors.dark[5] : theme.colors.gray[0])}><Group justify="space-between" align="center"><Group><IconInfoCircle size={24} color={canCurrentlyAddToExistingOrder ? theme.colors.blue[6] : theme.colors.orange[6]} /><Stack gap={0}><Text fw={500}>{t(canCurrentlyAddToExistingOrder ? 'publicMenu.activeOrder.addingToOrderTitle' : 'publicMenu.activeOrder.cannotAddTitle', { orderNumber: activeOrderNumber })}</Text><Text size="sm">{t(canCurrentlyAddToExistingOrder ? 'publicMenu.activeOrder.addingToOrderMsg' : 'publicMenu.activeOrder.cannotAddMsg')}</Text></Stack></Group><Button variant="outline" size="xs" component={Link} to={`/order-status/${activeOrderId}`} state={{ orderNumber: activeOrderNumber, businessSlug, tableIdentifier: tableIdentifierFromParams }}>{t('publicMenu.activeOrder.viewStatusButton')}</Button></Group></Paper>)}
                    {(totalCartItems > 0 || appliedRewards.discount) && (<Paper p={0} shadow="xs" withBorder={false} radius="md" style={{ position: 'sticky', top: `calc(${theme.spacing.md} + 10px)`, zIndex: 200 }} ><Button fullWidth size="lg" variant="gradient" gradient={{ from: theme.primaryColor, to: theme.colors[theme.primaryColor][4], deg: 105 }} onClick={openCart} disabled={isCartOpen} styles={{ root: { height: 'auto', padding: `${theme.spacing.sm} ${theme.spacing.md}` }, label: { width: '100%' } }}><Group justify="space-between" style={{ width: '100%' }}><Group gap="xs"><IconShoppingCart size={22} stroke={1.8} /><Text fw={500} inherit> {cartButtonText} </Text></Group><Text fw={700} inherit>{t('publicMenu.cart.total')}: {totalAmountWithDiscount.toLocaleString(i18n.language, { style: 'currency', currency: 'EUR' })}</Text></Group></Button></Paper>)}
                    <CategoryAccordion categories={menuData.categories} activeAccordionItems={activeAccordionItems} onAccordionChange={setActiveAccordionItems} configuringItemId={configuringItem?.itemDetails.id || null} configuringItemState={configuringItem} onStartConfigureItem={startConfiguringItem} onCancelConfiguration={cancelConfiguration} onConfigQuantityChange={updateConfigQuantity} onConfigModifierSelectionChange={updateConfigModifierSelection} onConfigNotesChange={updateConfigNotes} onConfigAddToCart={handleConfiguredItemAddToCart} onSimpleAddToCart={addSimpleItemToCart} />
                </Stack>
            </Container>
            <ShoppingCartModal opened={isCartOpen} onClose={closeCart} orderItems={currentOrderItems} orderNotes={orderNotes} subtotal={subtotal} totalWithDiscount={totalAmountWithDiscount} appliedDiscount={appliedRewards.discount} onUpdateItemQuantity={updateItemQuantityInCart} onRemoveItem={removeItemFromCart} onUpdateOrderNotes={updateOrderNotes} onSubmitOrder={handleSubmitOrderOrAddItems} isSubmittingOrder={isSubmittingOrder} onClearCart={clearCart} isAddingToExistingOrder={!!(activeOrderId && canCurrentlyAddToExistingOrder)} activeOrderNumber={activeOrderNumber} onOpenRewardModal={openRewardModal} onRemoveDiscount={() => setAppliedRewards(prev => ({ ...prev, discount: null }))}/>
            {userData && (<ApplyRewardModal opened={isRewardModalOpen} onClose={closeRewardModal} userPoints={userData.points ?? 0} availableCoupons={availableCoupons} redeemableRewards={redeemableRewards} initialSelections={appliedRewards} onApply={handleApplyRewardsFromModal} isApplying={isSubmittingOrder} appliedLcoRewardIdOnActiveOrder={activeOrderDetails?.appliedLcoRewardId || null} />)}
        </>
    );
};

export default PublicMenuViewPage;


// ====== [158] frontend/src/modules/camarero/pages/admin/camarero/KitchenDisplayPage.tsx ======
// frontend/src/modules/camarero/pages/admin/camarero/KitchenDisplayPage.tsx
import React, { useState, useEffect, useCallback, useRef } from 'react';
import {
    Container, Title, Text, Loader, Alert, Paper, List, Stack, Group,
    Badge, SegmentedControl, Box, Button,
} from '@mantine/core';
import { 
    IconAlertCircle, IconReload, IconCheck,
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { 
    KdsListItem, getItemsForKds, updateOrderItemKdsStatus 
} from '../../../services/kdsService'; 

// --- CORRECCI√ìN 1: Importar los enums desde la fuente correcta ---
import { OrderItemStatus } from '../../../../../shared/types/user.types'; 
// --- FIN CORRECCI√ìN 1 ---

import { notifications } from '@mantine/notifications';

const DEFAULT_KDS_DESTINATION = 'COCINA';
const POLLING_INTERVAL_MS = 15000; 

const KitchenDisplayPage: React.FC = () => {
    // El resto del c√≥digo del componente no necesita cambios funcionales.
    // Simplemente se beneficia de tener la importaci√≥n correcta.
    
    const { t, i18n } = useTranslation();
    const [items, setItems] = useState<KdsListItem[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [currentDestination, setCurrentDestination] = useState<string>(DEFAULT_KDS_DESTINATION);
    
    const pollingTimeoutRef = useRef<number | null>(null);
    const [updatingItemId, setUpdatingItemId] = useState<string | null>(null);

    const fetchKdsItems = useCallback(async (isInitialFetch = false) => {
        if (isInitialFetch) {
            setLoading(true);
            setError(null);
        }
        try {
            const fetchedItems = await getItemsForKds(currentDestination, [
                OrderItemStatus.PENDING_KDS,
                OrderItemStatus.PREPARING,
            ]);
            setItems(fetchedItems);
            if (error && !isInitialFetch) setError(null); 
        } catch (err: any) {
            const errMsg = err.response?.data?.message || err.message || t('common.errorFetchingData');
            setError(errMsg);
        } finally {
            if (isInitialFetch) {
                setLoading(false);
            }
        }
    }, [currentDestination, t, error]);

    useEffect(() => {
        fetchKdsItems(true); 
    }, [fetchKdsItems]); 

    useEffect(() => {
        if (pollingTimeoutRef.current) {
            clearTimeout(pollingTimeoutRef.current);
        }
        if (!updatingItemId) {
            pollingTimeoutRef.current = window.setTimeout(() => {
                fetchKdsItems(false); 
            }, POLLING_INTERVAL_MS);
        }
        return () => {
            if (pollingTimeoutRef.current) {
                clearTimeout(pollingTimeoutRef.current);
            }
        };
    }, [items, fetchKdsItems, currentDestination, updatingItemId]);

    const getItemName = (item: KdsListItem | undefined): string => {
        if (!item) return t('kdsPage.unknownItem', '√çtem Desconocido');
        return (i18n.language === 'es' && item.menuItemName_es) ? item.menuItemName_es : (item.menuItemName_en || item.menuItemName_es || t('kdsPage.unknownItem', '√çtem Desconocido'));
    };

    const getOrderItemDisplayInfo = (status: OrderItemStatus): { textKey: string; color: string } => {
        switch (status) {
            case OrderItemStatus.PENDING_KDS: return { textKey: 'orderStatusPage.itemStatus.pending_kds', color: 'gray' };
            case OrderItemStatus.PREPARING: return { textKey: 'orderStatusPage.itemStatus.preparing', color: 'blue' };
            case OrderItemStatus.READY: return { textKey: 'orderStatusPage.itemStatus.ready', color: 'lime' };
            case OrderItemStatus.SERVED: return { textKey: 'orderStatusPage.itemStatus.served', color: 'green' };
            case OrderItemStatus.CANCELLED: return { textKey: 'orderStatusPage.itemStatus.cancelled', color: 'red' };
            case OrderItemStatus.CANCELLATION_REQUESTED: return { textKey: 'orderStatusPage.itemStatus.cancellation_requested', color: 'orange' };
            default: return { textKey: String(status), color: 'gray' };
        }
    };

    const handleUpdateStatus = async (itemId: string, newStatus: OrderItemStatus) => {
        if (updatingItemId) {
            notifications.show({
                title: t('kdsPage.updateInProgressTitle', 'Actualizaci√≥n en Progreso'),
                message: t('kdsPage.updateInProgressMsg', 'Espera a que finalice la acci√≥n actual.'),
                color: 'yellow'
            });
            return;
        }
        const itemBeingUpdated = items.find(i => i.id === itemId);
        const itemNameForNotif = getItemName(itemBeingUpdated);
        const newStatusText = t(`orderStatusPage.itemStatus.${newStatus.toLowerCase()}`, newStatus);
        setUpdatingItemId(itemId);
        try {
            await updateOrderItemKdsStatus(itemId, newStatus);
            notifications.show({
                title: t('kdsPage.statusUpdateSuccessTitle', 'Estado Actualizado'),
                message: t('kdsPage.statusUpdateSuccessMsg', { itemName: itemNameForNotif , status: newStatusText }),
                color: 'green',
                icon: <IconCheck size={18} />
            });
            await fetchKdsItems(false); 
        } catch (err: any) {
            const errorMsg = err.response?.data?.message || err.message || t('kdsPage.statusUpdateErrorMsg', 'Error al actualizar estado');
            notifications.show({
                title: t('common.error'),
                message: errorMsg,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
        } finally {
            setUpdatingItemId(null);
        }
    };

    if (loading && items.length === 0) { 
        return <Container style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}><Loader size="xl" /></Container>;
    }

    return (
        <Container fluid p="md">
            <Stack gap="lg">
                <Title order={2} ta="center">{t('kdsPage.title', 'Pantalla de Cocina (KDS)')} - {currentDestination}</Title>
                <SegmentedControl
                    value={currentDestination}
                    onChange={(value) => {
                        if (pollingTimeoutRef.current) clearTimeout(pollingTimeoutRef.current);
                        setCurrentDestination(value);
                        setItems([]); 
                    }}
                    data={[
                        { label: t('kdsPage.destination.kitchen', 'COCINA'), value: 'COCINA' },
                        { label: t('kdsPage.destination.bar', 'BARRA'), value: 'BARRA' },
                    ]}
                    fullWidth mb="md"
                />
                {error && (<Alert icon={<IconAlertCircle size="1rem" />} title={t('common.error')} color="red" withCloseButton onClose={() => setError(null)}>{error}</Alert>)}
                {items.length === 0 && !loading && !error && (<Paper p="xl" shadow="xs" withBorder><Text ta="center" c="dimmed">{t('kdsPage.noItems', 'No hay √≠tems pendientes para este destino.')}</Text></Paper>)}
                {items.length > 0 && (
                    <List spacing="sm" listStyleType="none">
                        {items.map((item) => {
                            const displayInfo = getOrderItemDisplayInfo(item.status);
                            const isThisItemUpdating = updatingItemId === item.id;
                            const disableOtherItemsActions = !!updatingItemId && !isThisItemUpdating;
                            return (
                                <List.Item key={item.id}>
                                    <Paper withBorder p="md" radius="sm" shadow="xs">
                                        <Group justify="space-between">
                                            <Stack gap={0}>
                                                <Text fw={500} size="lg">{getItemName(item)}</Text>
                                                <Text size="sm" c="dimmed">{t('kdsPage.quantity', 'Cantidad')}: {item.quantity}</Text>
                                                {item.notes && <Text size="xs" c="orange">{t('kdsPage.notes', 'Notas')}: {item.notes}</Text>}
                                                <Text size="xs" c="dimmed">#{item.orderInfo.orderNumber} ({item.orderInfo.tableIdentifier || t('kdsPage.noTable', 'Sin Mesa')})</Text>
                                                 <Text size="xs" c="dimmed">{t('kdsPage.createdAt', 'Recibido KDS')}: {new Date(item.orderInfo.createdAt).toLocaleTimeString(i18n.language, { hour: '2-digit', minute: '2-digit' })}</Text>
                                            </Stack>
                                            <Badge color={displayInfo.color} variant="filled">{t(displayInfo.textKey, item.status)}</Badge>
                                        </Group>
                                        {item.selectedModifiers && item.selectedModifiers.length > 0 && (
                                            <Box mt="xs" pl="sm" style={{ borderLeft: '2px solid #ccc', marginLeft: '4px'}}>
                                                <Text size="xs" fw={500} mb={2}>{t('kdsPage.modifiers', 'Modificadores:')}</Text>
                                                <List listStyleType="disc" size="xs" c="dimmed" spacing={2}>
                                                    {item.selectedModifiers.map((mod, index) => (<List.Item key={index}>{(i18n.language === 'es' && mod.optionName_es) ? mod.optionName_es : (mod.optionName_en || mod.optionName_es)}</List.Item>))}
                                                </List>
                                            </Box>
                                        )}
                                        <Group justify="flex-end" mt="md">
                                            {item.status === OrderItemStatus.PENDING_KDS && (<Button size="xs" color="blue" onClick={() => handleUpdateStatus(item.id, OrderItemStatus.PREPARING)} loading={isThisItemUpdating} disabled={disableOtherItemsActions}>{t('kdsPage.action.startPreparing', 'Empezar Preparaci√≥n')}</Button>)}
                                            {item.status === OrderItemStatus.PREPARING && (<Button size="xs" color="green" onClick={() => handleUpdateStatus(item.id, OrderItemStatus.READY)} loading={isThisItemUpdating} disabled={disableOtherItemsActions}>{t('kdsPage.action.markReady', 'Marcar como Listo')}</Button>)}
                                            {(item.status === OrderItemStatus.PENDING_KDS || item.status === OrderItemStatus.PREPARING) && (<Button size="xs" color="red" variant="outline" onClick={() => handleUpdateStatus(item.id, OrderItemStatus.CANCELLED)} loading={isThisItemUpdating} disabled={disableOtherItemsActions}>{t('kdsPage.action.cancelItem', 'Cancelar √çtem')}</Button>)}
                                        </Group>
                                    </Paper>
                                </List.Item>
                            );
                        })}
                    </List>
                )}
                <Group justify="center" mt="md"><Button onClick={() => fetchKdsItems(true)} leftSection={<IconReload size={16}/>} variant="outline" loading={loading && items.length > 0}>{t('kdsPage.refreshManual', 'Refrescar Manualmente')}</Button></Group>
            </Stack>
        </Container>
    );
};

export default KitchenDisplayPage;


// ====== [159] frontend/src/modules/camarero/pages/admin/camarero/MenuManagementPage.tsx ======
// frontend/src/modules/camarero/pages/admin/camarero/MenuManagementPage.tsx (CORREGIDO)
import React, { useState } from 'react';
import { 
    Container, 
    Title, 
    Paper, 
    Stack, 
    Button,
    Group     
} from '@mantine/core';
import { useTranslation } from 'react-i18next';
import { notifications } from '@mantine/notifications'; 
import { IconExternalLink } from '@tabler/icons-react'; 

// --- RUTAS CORREGIDAS ---
import MenuCategoryManager from '../../../../../modules/camarero/components/admin/menu/MenuCategoryManager';
import MenuItemManager from '../../../../../modules/camarero/components/admin/menu/MenuItemManager'; 
import { MenuCategoryData } from '../../../../../modules/camarero/types/menu.types';
import { useLayoutUserData } from '../../../../../shared/hooks/useLayoutUserData'; 
// --- FIN RUTAS CORREGIDAS ---

const MenuManagementPage: React.FC = () => {
    const { t } = useTranslation();
    const [selectedCategory, setSelectedCategory] = useState<MenuCategoryData | null>(null);
    
    const { userData, loadingUser: loadingLayoutUser } = useLayoutUserData();

    const handleViewItems = (category: MenuCategoryData) => {
        setSelectedCategory(category);
    };
    const handleBackToCategories = () => {
        setSelectedCategory(null);
    };

    const handlePreviewMenu = () => {
        if (userData?.businessSlug) {
            window.open(`/m/${userData.businessSlug}`, '_blank');
        } else {
            console.error("[MenuManagementPage] Business slug no disponible para previsualizar el men√∫.");
            notifications.show({
                 title: t('common.error'),
                 message: t('adminCamarero.manageMenu.previewErrorNoSlug'),
                 color: 'red'
            });
        }
    };

    return (
        <Container size="xl" py="xl">
            <Stack gap="lg">
                <Group justify="space-between" align="flex-start">
                    <Title order={2}>
                        {t('adminCamarero.manageMenu.title')}
                    </Title>
                    {userData?.isCamareroActive && !loadingLayoutUser && (
                        <Button
                            variant="outline"
                            leftSection={<IconExternalLink size={16} />}
                            onClick={handlePreviewMenu}
                            disabled={!userData?.businessSlug}
                            title={!userData?.businessSlug ? t('adminCamarero.manageMenu.previewDisabledTooltip') : undefined}
                        >
                            {t('adminCamarero.manageMenu.previewButton')}
                        </Button>
                    )}
                </Group>

                {!selectedCategory ? (
                    <Paper shadow="sm" p="lg" withBorder radius="lg">
                        <Title order={4} mb="md">
                            {t('adminCamarero.manageMenu.categoriesSectionTitle')}
                        </Title>
                        <MenuCategoryManager 
                            onSelectCategoryForItems={handleViewItems}
                        />
                    </Paper>
                ) : (
                    <Paper shadow="sm" p="lg" withBorder radius="lg">
                        <Group justify="space-between" mb="md">
                            <Title order={4}>
                                {t('adminCamarero.manageMenu.itemsSectionTitle')} - {selectedCategory.name_es || selectedCategory.name_en}
                            </Title>
                            <Button variant="outline" onClick={handleBackToCategories}>
                                {t('common.back')} {t('adminCamarero.manageMenu.toCategories')}
                            </Button>
                        </Group>
                        <MenuItemManager 
                            categoryId={selectedCategory.id} 
                        />
                    </Paper>
                )}
            </Stack>
        </Container>
    );
};

export default MenuManagementPage;


// ====== [160] frontend/src/modules/camarero/pages/admin/camarero/WaiterOrderManagementPage.tsx ======
// frontend/src/pages/admin/camarero/WaiterOrderManagementPage.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
    Container,
    Title,
    Text,
    Loader,
    Alert,
    Paper,
    Stack,
    Group,
    Button,
    Table,
    Badge,
    SegmentedControl,
    // Modal, // Para el futuro modal de detalles de pago
    // TextInput, // Para el futuro modal de detalles de pago
} from '@mantine/core';
import {
    IconAlertCircle,
    IconCash, // Para el bot√≥n de "Marcar como Pagado"
    //IconReceipt2, // Para "Pedir Cuenta" (si se a√±ade aqu√≠)
    IconReload,
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX } from '@tabler/icons-react'; // Para notificaciones

// Suponiendo que estos tipos y servicios se crear√°n/adaptar√°n:
import { WaiterOrderListItemDto } from '../../../types/camarero.types'; // Aseg√∫rate que este DTO exista y se importe
import { OrderStatus } from '../../../../../shared/types/user.types'; // Usaremos el enum de OrderStatus
import axiosInstance from '../../../../../shared/services/axiosInstance'; // Para las llamadas API

// Hook para los datos (a√∫n por crear)
// import { useWaiterOrders } from '../../../hooks/useWaiterOrders';

const WaiterOrderManagementPage: React.FC = () => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;

    // Estado para los pedidos
    const [orders, setOrders] = useState<WaiterOrderListItemDto[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [selectedStatusFilter, setSelectedStatusFilter] = useState<string>(OrderStatus.PENDING_PAYMENT); // Filtro inicial
    const [markingPaidOrderId, setMarkingPaidOrderId] = useState<string | null>(null);

    // Opciones para el filtro de estado
    const statusFilterOptions = [
        { label: t('waiterOrderManagement.statusOptionPendingPayment', 'Pendientes de Pago'), value: OrderStatus.PENDING_PAYMENT },
        { label: t('waiterOrderManagement.statusOptionCompleted', 'Completados (No Pagados)'), value: OrderStatus.COMPLETED },
        { label: t('orderStatusPage.orderStatus.all_items_ready', 'Listos para Entregar'), value: OrderStatus.ALL_ITEMS_READY },
        { label: t('orderStatusPage.orderStatus.in_progress', 'En Progreso'), value: OrderStatus.IN_PROGRESS },
        { label: t('orderStatusPage.orderStatus.received', 'Recibidos'), value: OrderStatus.RECEIVED },
        { label: t('waiterOrderManagement.statusOptionPaid', 'Pagados'), value: OrderStatus.PAID },
        { label: t('waiterOrderManagement.statusOptionAll', 'Todos los Pedidos'), value: 'ALL' }, // 'ALL' es un valor especial
    ];

    // Funci√≥n para cargar pedidos
    const fetchOrders = useCallback(async (status?: string) => {
        setLoading(true);
        setError(null);
        console.log(`[WaiterOrderMgmt] Fetching orders with status filter: ${status || 'Default (from service)'}`);
        try {
            const params: { status?: string } = {};
            if (status && status !== 'ALL') {
                params.status = status;
            }
            // El endpoint es /api/camarero/staff/orders
            const response = await axiosInstance.get<WaiterOrderListItemDto[]>('/camarero/staff/orders', { params });
            setOrders(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            setError(msg);
            notifications.show({ title: t('common.error'), message: msg, color: 'red', icon: <IconAlertCircle /> });
        } finally {
            setLoading(false);
        }
    }, [t]);

    // Carga inicial y cuando cambia el filtro
    useEffect(() => {
        fetchOrders(selectedStatusFilter);
    }, [fetchOrders, selectedStatusFilter]);

    // Handler para marcar como pagado
    const handleMarkAsPaid = async (orderId: string, orderNumber: string) => {
        if (markingPaidOrderId) return; // Evitar clics m√∫ltiples

        setMarkingPaidOrderId(orderId);
        // Por ahora, un payload simple. En el futuro, un modal para 'method' y 'notes'.
        const payload = {
            method: "EFECTIVO_CAJA", // Valor por defecto para la prueba
            notes: `Pagado por camarero UI (MVP) - ${new Date().toLocaleTimeString()}`
        };

        try {
            await axiosInstance.post(`/camarero/staff/order/${orderId}/mark-as-paid`, payload);
            notifications.show({
                title: t('common.success'),
                message: t('waiterOrderManagement.markAsPaidSuccess', { orderNumber: orderNumber }),
                color: 'green',
                icon: <IconCheck />,
            });
            fetchOrders(selectedStatusFilter); // Refrescar la lista
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorUnknown');
            notifications.show({
                title: t('common.error'),
                message: t('waiterOrderManagement.markAsPaidError', { orderNumber: orderNumber, error: msg }),
                color: 'red',
                icon: <IconX />,
            });
        } finally {
            setMarkingPaidOrderId(null);
        }
    };

    const getStatusBadgeColor = (status: OrderStatus): string => {
        switch (status) {
            case OrderStatus.PENDING_PAYMENT: return 'orange';
            case OrderStatus.COMPLETED: return 'blue';
            case OrderStatus.PAID: return 'green';
            case OrderStatus.CANCELLED: return 'red';
            case OrderStatus.RECEIVED: return 'gray';
            case OrderStatus.IN_PROGRESS: return 'cyan';
            case OrderStatus.PARTIALLY_READY: return 'yellow';
            case OrderStatus.ALL_ITEMS_READY: return 'lime';
            default: return 'gray';
        }
    };

    const rows = orders.map((order) => {
        const isThisOrderLoading = markingPaidOrderId === order.orderId;
        const canMarkAsPaid = order.status === OrderStatus.PENDING_PAYMENT || order.status === OrderStatus.COMPLETED;
        
        return (
            <Table.Tr key={order.orderId}>
                <Table.Td>{order.orderNumber}</Table.Td>
                <Table.Td>{order.tableIdentifier || 'N/A'}</Table.Td>
                <Table.Td ta="right">
                    {order.finalAmount.toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}
                </Table.Td>
                <Table.Td>
                    <Badge color={getStatusBadgeColor(order.status)} variant="light">
                        {t(`orderStatusPage.orderStatus.${order.status.toLowerCase()}`, order.status)}
                    </Badge>
                </Table.Td>
                <Table.Td>
                    <Text size="xs" c="dimmed">
                        {new Date(order.createdAt).toLocaleString(currentLanguage, { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' })}
                    </Text>
                </Table.Td>
                <Table.Td>
                    <Group justify="flex-end">
                        {canMarkAsPaid && (
                            <Button
                                size="xs"
                                color="green"
                                leftSection={<IconCash size={14} />}
                                onClick={() => handleMarkAsPaid(order.orderId, order.orderNumber)}
                                loading={isThisOrderLoading}
                                disabled={!!markingPaidOrderId && !isThisOrderLoading}
                            >
                                {t('waiterOrderManagement.buttonMarkAsPaid')}
                            </Button>
                        )}
                        {/* Aqu√≠ podr√≠amos a√±adir m√°s acciones, como "Pedir Cuenta" si el estado lo permite */}
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    return (
        <Container size="xl" py="xl">
            <Stack gap="lg">
                <Group justify="space-between">
                    <Title order={2}>{t('waiterOrderManagement.title')}</Title>
                    <Button
                        onClick={() => fetchOrders(selectedStatusFilter)}
                        leftSection={<IconReload size={16} />}
                        variant="outline"
                        loading={loading && orders.length > 0} // Mostrar loading si ya hay datos y se refresca
                        disabled={loading || !!markingPaidOrderId}
                    >
                        {t('orderStatusPage.refreshButton')}
                    </Button>
                </Group>

                <SegmentedControl
                    data={statusFilterOptions}
                    value={selectedStatusFilter}
                    onChange={setSelectedStatusFilter}
                    disabled={loading || !!markingPaidOrderId}
                />

                {loading && orders.length === 0 && <Group justify="center" mt="xl"><Loader /></Group>}
                {error && !loading && (
                    <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>
                        {error}
                    </Alert>
                )}

                {!loading && !error && orders.length === 0 && (
                    <Paper p="xl" shadow="xs" withBorder mt="md">
                        <Text ta="center" c="dimmed">
                            {t('waiterOrderManagement.noOrdersFound')}
                        </Text>
                    </Paper>
                )}

                {!loading && !error && orders.length > 0 && (
                    <Table.ScrollContainer minWidth={700}>
                        <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                            <Table.Thead>
                                <Table.Tr>
                                    <Table.Th>{t('waiterOrderManagement.tableHeaderOrderNum')}</Table.Th>
                                    <Table.Th>{t('waiterOrderManagement.tableHeaderTable')}</Table.Th>
                                    <Table.Th ta="right">{t('waiterOrderManagement.tableHeaderTotal')}</Table.Th>
                                    <Table.Th>{t('waiterOrderManagement.tableHeaderStatus')}</Table.Th>
                                    <Table.Th>{t('common.registered')}</Table.Th>
                                    <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                                </Table.Tr>
                            </Table.Thead>
                            <Table.Tbody>{rows}</Table.Tbody>
                        </Table>
                    </Table.ScrollContainer>
                )}
            </Stack>
        </Container>
    );
};

export default WaiterOrderManagementPage;


// ====== [161] frontend/src/modules/camarero/pages/admin/camarero/WaiterPickupPage.tsx ======
// frontend/src/pages/admin/camarero/WaiterPickupPage.tsx
import React from 'react';
import {
    Container,
    Title,
    Text,
    Loader,
    Alert,
    Paper,
    Stack,
    Group,
    Button,
    Badge,
    ScrollArea,
    Box,
    useMantineTheme,
    List, // <--- A√ëADIDO AQU√ç
} from '@mantine/core';
import {
    IconAlertCircle,
    IconChefHat,
    IconClipboardList,
    IconToolsKitchen,
    IconCircleCheck,
    IconReload,
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useWaiterPickupItems } from '../../../hooks/useWaiterPickupItems'; // Ajusta la ruta si es necesario
import type { ReadyPickupItem } from '../../../types/camarero.types';
import { OrderItemStatus } from '../../../../../shared/types/user.types';

const WaiterPickupPage: React.FC = () => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;
    const theme = useMantineTheme();

    const {
        items,
        isLoadingInitial,
        fetchError,
        markingItemId,
        fetchItems,
        handleMarkAsServed,
    } = useWaiterPickupItems();

    const getItemNameForDisplay = (item: ReadyPickupItem): string => {
        return (currentLanguage === 'es' && item.itemNameSnapshot_es)
            ? item.itemNameSnapshot_es
            : (item.itemNameSnapshot_en || item.itemNameSnapshot_es || t('common.item', '√çtem'));
    };
    
    const getStatusBadge = (status: OrderItemStatus): React.ReactNode => {
        let color = "gray";
        let textKey = '';
        let IconComponent = IconClipboardList;

        switch (status) {
            case OrderItemStatus.READY:
                color = "lime";
                textKey = 'orderStatusPage.itemStatus.ready';
                IconComponent = IconChefHat;
                break;
            case OrderItemStatus.PREPARING:
                color = "blue";
                textKey = 'orderStatusPage.itemStatus.preparing';
                IconComponent = IconToolsKitchen;
                break;
            default:
                textKey = String(status); 
        }
        return <Badge color={color} leftSection={<IconComponent size={14} />} variant="light">{t(textKey, status)}</Badge>;
    };

    if (isLoadingInitial) {
        return (
            <Container size="lg" py="xl" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: 'calc(100vh - 120px)' }}>
                <Loader size="xl" />
            </Container>
        );
    }

    return (
        <Container size="xl" py="xl">
            <Stack gap="lg">
                <Group justify="space-between" align="center">
                    <Title order={2}>
                        {t('waiterInterface.pickupPageTitle', 'Pedidos Listos para Recoger y Servir')}
                    </Title>
                    <Button
                        onClick={() => fetchItems(true)}
                        leftSection={<IconReload size={16} />}
                        variant="outline"
                        loading={isLoadingInitial && items.length > 0}
                        disabled={isLoadingInitial || !!markingItemId}
                    >
                        {t('orderStatusPage.refreshButton', 'Actualizar')}
                    </Button>
                </Group>

                {fetchError && (
                    <Alert
                        icon={<IconAlertCircle size="1rem" />}
                        title={t('common.error')}
                        color="red"
                        radius="md"
                        withCloseButton
                        onClose={() => fetchItems(true)} 
                    >
                        {fetchError}
                    </Alert>
                )}

                {!fetchError && items.length === 0 && (
                    <Paper p="xl" shadow="xs" withBorder mt="xl">
                        <Text ta="center" c="dimmed">
                            {t('waiterInterface.noItemsReady', 'No hay √≠tems listos para recoger en este momento.')}
                        </Text>
                    </Paper>
                )}

                {items.length > 0 && (
                    <ScrollArea style={{ height: 'calc(100vh - 220px)' }} mt="md">
                        <Stack gap="md">
                            {items.map((item) => (
                                <Paper key={item.orderItemId} shadow="sm" p="md" withBorder radius="md">
                                    <Group justify="space-between" align="flex-start" wrap="nowrap">
                                        <Box style={{ flexGrow: 1 }}>
                                            <Title order={4}>{getItemNameForDisplay(item)}</Title>
                                            <Text size="sm">
                                                {t('kdsPage.quantity', 'Cantidad')}: <Text span fw={700}>{item.quantity}</Text>
                                            </Text>
                                            <Text size="xs" c="dimmed">
                                                {t('waiterInterface.orderNumber', 'Pedido')}: #{item.orderNumber}
                                            </Text>
                                            <Text size="xs" c="dimmed">
                                                {t('orderStatusPage.table', 'Mesa')}: {item.tableIdentifier || t('kdsPage.noTable', 'Sin Mesa')}
                                            </Text>
                                            {item.kdsDestination && (
                                                <Text size="xs" c="dimmed">
                                                    {t('waiterInterface.pickupFrom', 'Recoger de')}: <Badge variant="outline" size="xs">{item.kdsDestination}</Badge>
                                                </Text>
                                            )}
                                            <Text size="xs" c="dimmed">
                                                {t('kdsPage.createdAt', 'Recibido KDS')}: {new Date(item.orderCreatedAt).toLocaleTimeString(i18n.language, { hour: '2-digit', minute: '2-digit' })}
                                            </Text>
                                            {item.currentOrderItemStatus && (
                                                <Box mt={4}>{getStatusBadge(item.currentOrderItemStatus)}</Box>
                                            )}
                                        </Box>
                                        <Button
                                            onClick={() => handleMarkAsServed(item.orderItemId)}
                                            loading={markingItemId === item.orderItemId}
                                            disabled={!!markingItemId && markingItemId !== item.orderItemId}
                                            variant="filled"
                                            color="green"
                                            leftSection={<IconCircleCheck size={18} />}
                                        >
                                            {t('waiterInterface.markAsServedButton', 'Marcar como Servido')}
                                        </Button>
                                    </Group>

                                    {item.selectedModifiers && item.selectedModifiers.length > 0 && (
                                        <Box mt="sm" pt="xs" style={{ borderTop: `1px solid ${theme.colors.gray[3]}` }}>
                                            <Text size="xs" fw={500} mb={2}>{t('kdsPage.modifiers', 'Modificadores:')}</Text>
                                            <List listStyleType="none" spacing={2} size="xs" c="dimmed"> {/* <--- Uso de List */}
                                                {item.selectedModifiers.map((mod, index) => (
                                                    <List.Item key={index}> {/* <--- Uso de List.Item */}
                                                        {(currentLanguage === 'es' && mod.optionName_es) ? mod.optionName_es : (mod.optionName_en || mod.optionName_es)}
                                                    </List.Item>
                                                ))}
                                            </List>
                                        </Box>
                                    )}
                                    {item.itemNotes && (
                                        <Box mt="sm" pt="xs" style={{ borderTop: `1px solid ${theme.colors.gray[3]}` }}>
                                            <Text size="xs" fw={500} mb={2}>{t('kdsPage.notes', 'Notas √çtem')}:</Text>
                                            <Text size="xs" c="orange.7" style={{ whiteSpace: 'pre-wrap' }}>{item.itemNotes}</Text>
                                        </Box>
                                    )}
                                </Paper>
                            ))}
                        </Stack>
                    </ScrollArea>
                )}
            </Stack>
        </Container>
    );
};

export default WaiterPickupPage;


// ====== [162] frontend/src/modules/camarero/services/kdsService.ts ======
// frontend/src/modules/camarero/services/kdsService.ts
// Version 1.0.3 - Corrected type imports to point to the shared types file.

import axiosInstance from '../../../shared/services/axiosInstance';
// --- CORRECCI√ìN: Importar los enums desde la fuente correcta de tipos compartidos ---
import { OrderItemStatus, OrderStatus } from '../../../shared/types/user.types';

// --- Tipos para la respuesta del GET (la estructura interna no cambia) ---
export interface KdsListItem {
    id: string; 
    quantity: number;
    status: OrderItemStatus; // Ahora usa el tipo importado correctamente
    notes: string | null;
    kdsDestination: string | null;
    menuItemName_es: string | null;
    menuItemName_en: string | null; 
    selectedModifiers: {
        optionName_es: string | null;
        optionName_en: string | null; 
    }[];
    orderInfo: {
        id: string; 
        orderNumber: string;
        createdAt: string; 
        tableIdentifier: string | null;
    };
    preparationTime?: number | null; 
    preparedAt?: string | null; 
    servedAt?: string | null; 
}

// --- Tipos para la respuesta del PATCH (la estructura interna no cambia) ---
interface ModifierOptionInfo {
    id: string;
    name_es: string | null;
    name_en: string | null;
    priceAdjustment: string; 
    position: number;
    isDefault: boolean;
    isAvailable: boolean;
    groupId: string;
    createdAt: string; 
    updatedAt: string; 
}

interface SelectedModifierInfo {
    orderItemId: string;
    modifierOptionId: string;
    optionNameSnapshot: string | null;
    optionPriceAdjustmentSnapshot: string; 
    createdAt: string; 
    modifierOption: ModifierOptionInfo; 
}

interface MenuItemInfoForKdsPatchResponse {
    id: string;
    sku: string | null;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    price: string; 
    imageUrl: string | null;
    allergens: string[]; 
    tags: string[]; 
    isAvailable: boolean;
    position: number;
    preparationTime: number | null;
    calories: number | null;
    kdsDestination: string | null;
    categoryId: string;
    businessId: string;
    trackInventory: boolean;
    stockQuantity: number | null;
    createdAt: string; 
    updatedAt: string; 
}

interface OrderInfoForKdsPatchResponse {
    id: string;
    orderNumber: string;
    status: OrderStatus; // Usa el tipo correcto
    totalAmount: string; 
    discountAmount: string | null; 
    finalAmount: string; 
    notes: string | null;
    source: string | null; 
    tableId: string | null;
    customerLCoId: string | null;
    waiterId: string | null;
    businessId: string;
    createdAt: string; 
    updatedAt: string; 
    confirmedAt: string | null; 
    billedAt: string | null; 
    paidAt: string | null; 
    orderType: string; 
    paymentMethodPreference: string | null;
    amountToPayWith: string | null; 
    paymentIntentId: string | null;
    paymentProvider: string | null;
    deliveryAddressJson: string | null; 
    deliveryFee: string | null; 
    estimatedDeliveryTime: string | null; 
    appliedLcoRewardId: string | null;
    appliedLcoRewardDiscountAmount: string | null; 
    appliedLcoTierBenefitDiscountAmount: string | null; 
}

export interface FullOrderItemKdsResponse {
    id: string;
    quantity: number;
    priceAtPurchase: string; 
    totalItemPrice: string; 
    notes: string | null;
    status: OrderItemStatus; // Usa el tipo correcto
    kdsDestination: string | null;
    orderId: string;
    menuItemId: string;
    itemNameSnapshot: string | null;
    itemDescriptionSnapshot: string | null;
    servedById: string | null;
    preparedAt: string | null; 
    servedAt: string | null; 
    cancellationReason: string | null;
    createdAt: string; 
    updatedAt: string; 
    order: OrderInfoForKdsPatchResponse;
    menuItem: MenuItemInfoForKdsPatchResponse;
    selectedModifiers: SelectedModifierInfo[];
}

const KDS_API_PATH = '/camarero/kds';

export const getItemsForKds = async (
    destination: string,
    statusValues?: OrderItemStatus[] // Usa el tipo correcto
): Promise<KdsListItem[]> => {
    try {
        const params: Record<string, string | string[]> = { destination: destination.toUpperCase() };
        if (statusValues && statusValues.length > 0) {
            params.status = statusValues; 
        }
        const response = await axiosInstance.get<KdsListItem[]>(`${KDS_API_PATH}/items`, { params });
        console.log('[kdsService.getItemsForKds] Raw response data:', response.data);
        return response.data;
    } catch (error) {
        console.error('[kdsService.getItemsForKds] Error fetching KDS items:', error);
        throw error;
    }
};

export const updateOrderItemKdsStatus = async (
    orderItemId: string,
    newStatus: OrderItemStatus // Usa el tipo correcto
): Promise<FullOrderItemKdsResponse> => { 
    try {
        const response = await axiosInstance.patch<FullOrderItemKdsResponse>(
            `${KDS_API_PATH}/items/${orderItemId}/status`,
            { newStatus } 
        );
        console.log('[kdsService.updateOrderItemKdsStatus] Raw response data:', response.data);
        return response.data;
    } catch (error) {
        console.error(`[kdsService.updateOrderItemKdsStatus] Error updating KDS order item ${orderItemId} status:`, error);
        throw error;
    }
};


// ====== [163] frontend/src/modules/camarero/services/publicOrderApiService.ts ======
// frontend/src/modules/camarero/services/publicOrderApiService.ts
// Version 2.0.1 - Corregida la importaci√≥n del DTO.

import axios from 'axios';
import {
    CreateOrderPayloadDto,
    AddItemsToOrderPayloadDto,
    BackendOrderResponse,
    OrderItemFE,
    // --- CORRECCI√ìN AQU√ç ---
    FrontendCreateOrderItemDto, // Importamos el tipo correcto que usa el payload
} from '../types/publicOrder.types';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL_PUBLIC || 'http://localhost:3000/public';

const getProcessedNotesValue = (notesInput: string | null | undefined): string | null => {
    if (notesInput === null || notesInput === undefined) return null;
    const trimmed = notesInput.trim();
    return trimmed === "" ? null : trimmed;
};

export const submitNewOrder = async (
    businessSlug: string,
    payload: CreateOrderPayloadDto
): Promise<BackendOrderResponse> => {
    try {
        const response = await axios.post<BackendOrderResponse>(`${API_BASE_URL}/order/${businessSlug}`, payload);
        return response.data;
    } catch (error) {
        console.error(`[PublicOrderApiService] Error submitting NEW order for slug ${businessSlug}:`, error);
        throw error;
    }
};

export const addItemsToExistingOrderApi = async (
    orderId: string,
    businessSlug: string,
    payload: AddItemsToOrderPayloadDto
): Promise<BackendOrderResponse> => {
    try {
        const headers: Record<string, string> = { 'Content-Type': 'application/json' };
        if (businessSlug) {
            headers['x-loyalpyme-business-slug'] = businessSlug;
        }
        const response = await axios.post<BackendOrderResponse>(
            `${API_BASE_URL}/order/${orderId}/items`,
            payload,
            { headers }
        );
        return response.data;
    } catch (error) {
        console.error(`[PublicOrderApiService] Error adding items to order ${orderId}:`, error);
        throw error;
    }
};

export const handleOrderSubmission = async (
    cartItems: OrderItemFE[],
    generalOrderNotes: string,
    activeOrderId: string | null,
    businessSlug: string,
    tableIdentifier: string | undefined,
    requestingCustomerId: string | null | undefined,
    appliedDiscountId: string | null | undefined
): Promise<BackendOrderResponse> => {
    
    // --- CORRECCI√ìN AQU√ç ---
    // El tipo del array ahora es el DTO correcto que importamos.
    const dtoItems: FrontendCreateOrderItemDto[] = cartItems.map(feItem => ({
        menuItemId: feItem.menuItemId,
        quantity: feItem.quantity,
        notes: getProcessedNotesValue(feItem.notes),
        selectedModifierOptions: feItem.selectedModifiers.length > 0
            ? feItem.selectedModifiers.map(sm => ({ modifierOptionId: sm.modifierOptionId }))
            : [],
        redeemedRewardId: feItem.redeemedRewardId || null,
    }));

    if (activeOrderId) {
        const payloadForAdd: AddItemsToOrderPayloadDto = {
            items: dtoItems,
            customerNotes: getProcessedNotesValue(generalOrderNotes),
            appliedLcoRewardId: appliedDiscountId || null,
        };
        const response = await addItemsToExistingOrderApi(activeOrderId, businessSlug, payloadForAdd);
        return { ...response, id: activeOrderId };
    } else {
        const payloadForCreate: CreateOrderPayloadDto = {
            items: dtoItems,
            customerNotes: getProcessedNotesValue(generalOrderNotes),
            tableIdentifier: tableIdentifier || null,
            customerId: requestingCustomerId || null,
            appliedLcoRewardId: appliedDiscountId || null,
        };
        return submitNewOrder(businessSlug, payloadForCreate);
    }
};


// ====== [164] frontend/src/modules/camarero/services/waiterService.ts ======
// frontend/src/services/waiterService.ts
// Version: 1.0.0 (Initial service for waiter actions: get ready items, mark as served)

import axiosInstance from '../../../shared/services/axiosInstance'; // Nuestra instancia de Axios configurada con interceptor de token
import { ReadyPickupItem, OrderItemStatusUpdateResponse } from '../types/camarero.types'; // Tipos que definimos antes
import { OrderItemStatus } from '../../../shared/types/user.types';

const WAITER_STAFF_API_BASE = '/camarero/staff'; // Prefijo base para las rutas de este servicio

/**
 * Obtiene la lista de √≠tems de pedido que est√°n listos para ser recogidos.
 * Llama a GET /api/camarero/staff/ready-for-pickup
 * @returns Una promesa que resuelve con un array de ReadyPickupItem.
 */
export const getReadyForPickupItems = async (): Promise<ReadyPickupItem[]> => {
    console.log('[WaiterService] Fetching items ready for pickup...');
    try {
        const response = await axiosInstance.get<ReadyPickupItem[]>(`${WAITER_STAFF_API_BASE}/ready-for-pickup`);
        console.log(`[WaiterService] Successfully fetched ${response.data?.length || 0} ready items.`);
        return response.data || []; // Devolver array vac√≠o si no hay datos
    } catch (error) {
        // El error ya deber√≠a ser manejado y logueado por el interceptor de axiosInstance,
        // pero podemos a√±adir un log espec√≠fico aqu√≠ si es necesario.
        console.error("[WaiterService] Error fetching ready for pickup items:", error);
        // Relanzar para que el hook o componente que llama pueda manejarlo (ej. mostrar UI de error)
        throw error; 
    }
};

/**
 * Marca un OrderItem espec√≠fico como SERVED.
 * Llama a PATCH /api/camarero/staff/order-items/:orderItemId/status
 * @param orderItemId - El ID del OrderItem a actualizar.
 * @returns Una promesa que resuelve con la respuesta del backend (OrderItemStatusUpdateResponse).
 */
export const markOrderItemAsServed = async (orderItemId: string): Promise<OrderItemStatusUpdateResponse> => {
    console.log(`[WaiterService] Marking order item ${orderItemId} as SERVED...`);
    try {
        // El backend espera un payload: { newStatus: "SERVED" }
        const payload = { newStatus: OrderItemStatus.SERVED }; 

        const response = await axiosInstance.patch<OrderItemStatusUpdateResponse>(
            `${WAITER_STAFF_API_BASE}/order-items/${orderItemId}/status`,
            payload
        );
        console.log(`[WaiterService] Successfully marked item ${orderItemId} as SERVED. Response:`, response.data);
        return response.data;
    } catch (error) {
        console.error(`[WaiterService] Error marking order item ${orderItemId} as served:`, error);
        throw error;
    }
};


// ====== [165] frontend/src/modules/camarero/types/camarero.types.ts ======
// frontend/src/modules/camarero/types/camarero.types.ts
// Version 1.1.1 - Corrected type import path

// --- CORRECCI√ìN: Apuntar a la ruta correcta de tipos compartidos ---
import { OrderItemStatus, OrderStatus, OrderType } from '../../../shared/types/user.types';

/**
 * DTO para la informaci√≥n de un modificador seleccionado que se muestra al camarero.
 */
export interface WaiterSelectedModifier {
  optionName_es: string | null;
  optionName_en: string | null;
}

/**
 * DTO para cada √≠tem de pedido que est√° listo para ser recogido y servido por el camarero.
 */
export interface ReadyPickupItem {
  orderItemId: string;
  orderId: string;
  orderNumber: string;
  orderCreatedAt: Date;
  tableIdentifier: string | null;
  itemNameSnapshot_es: string | null;
  itemNameSnapshot_en: string | null;
  quantity: number;
  itemNotes: string | null;
  kdsDestination: string | null;
  selectedModifiers: WaiterSelectedModifier[];
  currentOrderItemStatus: OrderItemStatus;
}

/**
 * DTO para la respuesta del backend al actualizar el estado de un OrderItem
 * desde la interfaz de camarero o KDS.
 */
export interface OrderItemStatusUpdateResponse {
  message: string;
  orderItemId: string;
  newStatus: OrderItemStatus;
  orderStatus?: OrderStatus;
}

/**
 * DTO para representar un √≠tem en la lista de pedidos para la interfaz del camarero.
 * Usado en: GET /api/camarero/staff/orders (respuesta del backend)
 */
export interface WaiterOrderListItemDto {
  orderId: string;
  orderNumber: string;
  tableIdentifier: string | null;
  status: OrderStatus;
  finalAmount: number;
  itemCount: number;
  customerName?: string | null;
  createdAt: Date;
  isBillRequested?: boolean;
  orderType?: OrderType | null;
}


// ====== [166] frontend/src/modules/camarero/types/menu.types.ts ======
// frontend/src/modules/camarero/types/menu.types.ts (MODIFICADO)

// --- MENU CATEGORY (Existente) ---
export interface MenuCategoryData {
  id: string;
  businessId: string; 
  name_es: string;
  name_en: string | null;
  description_es?: string | null;
  description_en?: string | null;
  imageUrl?: string | null;
  position: number;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  items?: MenuItemData[];
}

export interface MenuCategoryFormData {
  name_es: string;
  name_en: string | null;
  description_es?: string | null;
  description_en?: string | null;
  imageUrl?: string | null;
  position: number;
  isActive: boolean;
}

// --- MENU ITEM (Existente) ---
export interface MenuItemData {
  id: string;
  categoryId: string;
  businessId: string;
  name_es: string;
  name_en: string | null;
  description_es: string | null;
  description_en: string | null;
  price: number; 
  imageUrl: string | null;
  allergens: string[];
  tags: string[];
  isAvailable: boolean;
  position: number;
  preparationTime: number | null;
  calories: number | null;
  kdsDestination: string | null;
  sku: string | null;
  createdAt: string;
  updatedAt: string;
  modifierGroups?: ModifierGroupData[];
}

export interface MenuItemFormData {
  name_es: string;
  name_en: string | null;
  description_es: string | null;
  description_en: string | null;
  price: number; 
  imageUrl: string | null;
  allergens: string[];
  tags: string[];
  isAvailable: boolean;
  position: number;
  preparationTime?: number | null;
  calories?: number | null;
  kdsDestination?: string | null;
  sku?: string | null;
}

// --- MODIFIER GROUP (Existente) ---
export enum ModifierUiType {
    RADIO = 'RADIO',
    CHECKBOX = 'CHECKBOX',
}

export interface ModifierGroupData {
  id: string;
  menuItemId: string;
  businessId: string;
  name_es: string;
  name_en: string | null;
  uiType: ModifierUiType;
  minSelections: number;
  maxSelections: number;
  position: number;
  isRequired: boolean;
  options?: ModifierOptionData[];
  createdAt: string;
  updatedAt: string;
}

export interface ModifierGroupFormData {
  name_es: string;
  name_en: string | null;
  uiType: ModifierUiType;
  minSelections: number;
  maxSelections: number;
  position: number;
  isRequired: boolean;
}


// --- MODIFIER OPTION (Existente) ---
export interface ModifierOptionData {
  id: string;
  groupId: string;
  name_es: string;
  name_en: string | null;
  priceAdjustment: number;
  position: number;
  isDefault: boolean;
  isAvailable: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface ModifierOptionFormData {
  name_es: string;
  name_en: string | null;
  priceAdjustment: number;
  position: number;
  isDefault: boolean;
  isAvailable: boolean;
}

// --- Tipos para la Visualizaci√≥n P√∫blica del Men√∫ ---
export interface PublicMenuModifierOption {
    id: string;
    name_es: string | null;
    name_en: string | null;
    priceAdjustment: number;
    position: number;
    isDefault: boolean;
    isAvailable: boolean;
}

export interface PublicMenuModifierGroup {
    id: string;
    name_es: string | null;
    name_en: string | null;
    uiType: ModifierUiType;
    minSelections: number;
    maxSelections: number;
    isRequired: boolean;
    position: number;
    options: PublicMenuModifierOption[];
}

export interface PublicMenuItem {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    price: number; 
    imageUrl: string | null;
    allergens: string[];
    tags: string[];
    position: number;
    modifierGroups: PublicMenuModifierGroup[];
}

export interface PublicMenuCategory {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    imageUrl: string | null;
    position: number;
    items: PublicMenuItem[];
}

// --- CAMBIO AQU√ç ---
export interface PublicDigitalMenuData {
    businessName: string;
    businessSlug: string;
    businessLogoUrl: string | null;
    isLoyaltyCoreActive: boolean;
    isCamareroActive: boolean; // <-- CAMPO A√ëADIDO
    categories: PublicMenuCategory[];
}
// --- FIN DEL CAMBIO ---


// ====== [167] frontend/src/modules/camarero/types/publicOrder.types.ts ======
// frontend/src/modules/camarero/types/publicOrder.types.ts
// VERSI√ìN 2.0.0 - Limpio y con todas las exportaciones necesarias.

// No debe importar nada de @prisma/client en el frontend.
// Importamos los enums y tipos que s√≠ son compartidos.
import { OrderStatus, OrderItemStatus } from '../../../shared/types/user.types';
import type { DisplayReward } from '../../../shared/types/user.types';

// --- TIPO PARA EL ESTADO DE RECOMPENSAS APLICADAS ---
export interface AppliedSelections {
    discount: DisplayReward | null;
    freeItems: DisplayReward[];
}

// --- TIPOS PARA EL CARRITO EN EL FRONTEND ---
export interface SelectedModifierFE {
    modifierOptionId: string;
    name_es?: string | null;
    name_en?: string | null;
    priceAdjustment: number;
    modifierGroupName_es?: string | null;
    modifierGroupName_en?: string | null;
}

export interface OrderItemFE {
    cartItemId: string;
    menuItemId: string;
    menuItemName_es: string | null;
    menuItemName_en: string | null;
    quantity: number;
    basePrice: number;
    currentPricePerUnit: number;
    totalPriceForItem: number;
    notes?: string | null;
    selectedModifiers: SelectedModifierFE[];
    redeemedRewardId?: string | null; 
}

// --- TIPO PARA EL ESTADO DE CONFIGURACI√ìN DE UN √çTEM ---
export interface ConfiguringItemState {
    itemDetails: any; // PublicMenuItem
    quantity: number;
    selectedOptionsByGroup: Record<string, string[] | string>;
    currentUnitPrice: number;
    itemNotes: string;
    areModifiersValid: boolean;
}

// --- TIPOS PARA PAYLOADS DE API ---
export interface FrontendCreateOrderItemDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: { modifierOptionId: string }[] | null;
    redeemedRewardId?: string | null;
}

export interface CreateOrderPayloadDto {
    tableIdentifier?: string | null;
    customerId?: string | null;
    customerNotes: string | null;
    items: FrontendCreateOrderItemDto[];
    appliedLcoRewardId?: string | null;
}

export interface AddItemsToOrderPayloadDto {
    items: FrontendCreateOrderItemDto[];
    customerNotes: string | null;
    appliedLcoRewardId?: string | null;
}

// --- TIPOS PARA RESPUESTAS DE API ---
export interface BackendOrderResponse {
    id: string;
    orderNumber?: string | null;
}

export interface PublicModifierStatusInfo {
    optionNameSnapshot: string | null;
    optionPriceAdjustmentSnapshot: number; 
}

export interface PublicOrderItemStatusInfo {
    id: string;
    itemNameSnapshot: string | null; 
    quantity: number;
    status: OrderItemStatus;
    priceAtPurchase: number;
    totalItemPrice: number;
    selectedModifiers: PublicModifierStatusInfo[];
}

export interface PublicOrderStatusInfo {
    orderId: string;
    orderNumber: string;
    orderStatus: OrderStatus;
    items: PublicOrderItemStatusInfo[];
    tableIdentifier?: string | null;
    orderNotes?: string | null;
    createdAt: string;
    isBillRequested?: boolean;
    totalAmount: number;
    discountAmount: number | null;
    finalAmount: number;
    appliedLcoRewardId: string | null;
}


// ====== [168] frontend/src/modules/loyalpyme/components/GenerateQrCode.tsx ======
// filename: frontend/src/components/GenerateQrCode.tsx
import { useState } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { QRCodeCanvas } from 'qrcode.react';
import {
    TextInput, NumberInput, Button, Stack, Alert, Loader,
    Paper, Text, Code, Box, Group, Center
} from '@mantine/core';
import { IconAlertCircle, IconCheck } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

interface QrCodeData {
    qrToken: string;
    amount: number;
}

const GenerateQrCode: React.FC = () => {
    const { t } = useTranslation();
    const [amount, setAmount] = useState<number | ''>('');
    const [ticketNumber, setTicketNumber] = useState<string>('');
    const [isLoading, setIsLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);
    const [generatedData, setGeneratedData] = useState<QrCodeData | null>(null);

    const handleGenerateClick = async () => {
        setError(null);
        setGeneratedData(null);

        if (amount === '' || amount <= 0) {
            setError(t('component.generateQr.errorAmountPositive'));
            return;
        }
        if (!ticketNumber || ticketNumber.trim() === '') {
            setError(t('component.generateQr.errorTicketRequired'));
            return;
        }
        setIsLoading(true);
        try {
            const requestData = { amount: Number(amount), ticketNumber: ticketNumber.trim() };
            const response = await axiosInstance.post<QrCodeData>('/points/generate-qr', requestData);
            setGeneratedData(response.data);
            setAmount('');
            setTicketNumber('');
        } catch (err: any) {
            console.error('Error generating QR code data:', err);
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown'); // Clave com√∫n para error desconocido
            setError(t('component.generateQr.errorGeneric', { error: apiError }));
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Stack gap="md">
            <NumberInput
                label={t('component.generateQr.amountLabel')}
                placeholder={t('component.generateQr.amountPlaceholder')}
                value={amount}
                onChange={(value) => setAmount(typeof value === 'number' ? value : '')}
                min={0.01}
                step={0.01}
                decimalScale={2}
                fixedDecimalScale
                required
                radius="lg"
                disabled={isLoading}
            />
            <TextInput
                label={t('component.generateQr.ticketLabel')}
                placeholder={t('component.generateQr.ticketPlaceholder')}
                value={ticketNumber}
                onChange={(e) => setTicketNumber(e.currentTarget.value)}
                required
                radius="lg"
                disabled={isLoading}
            />
            <Box>
                <Button onClick={handleGenerateClick} loading={isLoading} radius="lg">
                    {t('component.generateQr.buttonText')}
                </Button>
            </Box>

            <Box mt="md" style={{ minHeight: '200px' }}>
                {isLoading && (
                    <Group justify="center"><Loader size="sm" /></Group>
                )}
                {error && (
                    <Alert
                        icon={<IconAlertCircle size={16} />}
                        title={t('common.error')}
                        color="red"
                        radius="lg"
                        withCloseButton
                        onClose={() => setError(null)}
                    >
                        {error}
                    </Alert>
                )}
                {generatedData && (
                    <Paper withBorder p="md" radius="lg" mt="sm">
                        <Group gap="xs" mb="xs">
                            <IconCheck size={16} color="var(--mantine-color-green-7)" />
                            <Text fw={500} size="sm">
                                {t('component.generateQr.successMessage', { amount: generatedData.amount.toFixed(2) })}
                            </Text>
                        </Group>
                        <Text size="sm" mb="md">
                            {t('component.generateQr.successInstructions')}
                        </Text>
                        <Center>
                            <QRCodeCanvas
                                value={generatedData.qrToken}
                                size={160}
                                bgColor={"#ffffff"}
                                fgColor={"#000000"}
                                level={"L"}
                                includeMargin={true}
                            />
                        </Center>
                        <Text size="xs" c="dimmed" mt="md" ta="center">
                            {t('component.generateQr.tokenRef')}{' '}
                            <Code>{generatedData.qrToken}</Code>
                        </Text>
                    </Paper>
                )}
                 {!isLoading && !error && !generatedData && (
                     <Text size="sm" c="dimmed">{t('component.generateQr.initialPrompt', 'Introduce importe y n√∫mero de ticket para generar los datos del QR.')}</Text>
                 )}
            </Box>
        </Stack>
    );
};

export default GenerateQrCode;


// ====== [169] frontend/src/modules/loyalpyme/components/admin/AdjustPointsModal.tsx ======
// frontend/src/components/admin/AdjustPointsModal.tsx
// Version 1.1.0 (Use adminCustomerService for API call)

import React, { useState, useEffect } from 'react';
import { Modal, TextInput, Button, Group, Text, NumberInput } from '@mantine/core';
import { useForm } from '@mantine/form'; // zodResolver no es estrictamente necesario aqu√≠ si la validaci√≥n es simple
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX } from '@tabler/icons-react';
import { Customer } from '../../hooks/useAdminCustomersData';
import { useTranslation } from 'react-i18next';

// --- NUEVO: Importar el servicio ---
import * as adminCustomerService from '../../services/adminCustomerService';
// --- FIN NUEVO ---

interface AdjustPointsModalProps {
    opened: boolean;
    onClose: () => void;
    customer: Customer | null;
    onSuccess: () => void; // Callback para refrescar datos en la p√°gina principal
}

const AdjustPointsModal: React.FC<AdjustPointsModalProps> = ({ opened, onClose, customer, onSuccess }) => {
    const { t } = useTranslation();
    const [loading, setLoading] = useState(false); // Renombrado de isSubmitting a loading para consistencia

    const form = useForm({
        initialValues: { amount: 0, reason: '' },
        validate: {
            amount: (value) => (value === 0 ? t('validation.cannotBeZero') : null),
            // 'reason' es opcional, no necesita validaci√≥n aqu√≠ a menos que cambien los requisitos
        }
    });

    useEffect(() => {
        if (opened) {
             form.reset(); // Resetear el formulario cada vez que se abre
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened]); // No necesitamos customer como dependencia si solo reseteamos

    const handleSubmit = async (values: typeof form.values) => {
        if (!customer) return;
        setLoading(true);
        try {
            // --- CAMBIO: Llamar al servicio en lugar de axiosInstance directamente ---
            await adminCustomerService.adjustCustomerPointsApi(
                customer.id,
                values.amount,
                values.reason.trim() ? values.reason.trim() : null // Enviar null si la raz√≥n est√° vac√≠a
            );
            // --- FIN CAMBIO ---

            notifications.show({
                title: t('common.success'),
                message: t('adminCustomersPage.adjustPointsSuccess', { name: customer.name || customer.email }),
                color: 'green',
                icon: <IconCheck size={18} />,
            });
            onSuccess(); // Llama al callback para refrescar la tabla en la p√°gina principal
            onClose();   // Cierra el modal
        } catch (error: any) {
            console.error("Error adjusting points via modal:", error);
            const apiError = error.response?.data?.message || error.message || t('common.errorUnknown');
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.adjustPointsError', { error: apiError }),
                color: 'red',
                icon: <IconX size={18} />,
            });
            // No cerramos el modal en caso de error para que el usuario pueda corregir si es necesario
        } finally {
            setLoading(false);
        }
    };

    const modalTitle = t('adminCustomersPage.adjustPointsModalTitle', {
        name: customer?.name || customer?.email || t('common.customer')
    });

    return (
        <Modal
            opened={opened}
            onClose={() => { if (!loading) onClose(); }} // Prevenir cierre si est√° enviando
            title={modalTitle}
            centered
            trapFocus // Mantener el foco dentro del modal
            closeOnClickOutside={!loading} // Prevenir cierre al hacer clic fuera si est√° cargando
            closeOnEscape={!loading}     // Prevenir cierre con ESC si est√° cargando
        >
            {customer ? (
                <form onSubmit={form.onSubmit(handleSubmit)}>
                    <Text size="sm" mb="md">
                        {t('adminCustomersPage.adjustPointsCurrent', { points: customer.points })}
                    </Text>
                    <NumberInput
                        label={t('adminCustomersPage.adjustPointsAmountLabel')}
                        placeholder={t('adminCustomersPage.adjustPointsAmountPlaceholder')}
                        required
                        allowNegative
                        disabled={loading}
                        data-autofocus // Enfocar este campo al abrir
                        {...form.getInputProps('amount')}
                    />
                    <TextInput
                        label={t('adminCustomersPage.adjustPointsReasonLabel')}
                        placeholder={t('adminCustomersPage.adjustPointsReasonPlaceholder')}
                        mt="md"
                        disabled={loading}
                        {...form.getInputProps('reason')}
                    />
                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={onClose} disabled={loading}>
                            {t('common.cancel')}
                        </Button>
                        <Button
                            type="submit"
                            loading={loading}
                            disabled={!form.isValid() || form.values.amount === 0 || loading}
                        >
                            {t('adminCustomersPage.adjustPointsButton')}
                        </Button>
                    </Group>
                </form>
            ) : (
                // Esto no deber√≠a mostrarse si el modal solo se abre con un customer
                <Text c="dimmed">{t('adminCustomersPage.noCustomerSelected')}</Text>
            )}
        </Modal>
    );
};

export default AdjustPointsModal;


// ====== [170] frontend/src/modules/loyalpyme/components/admin/AssignRewardModal.tsx ======
// frontend/src/components/admin/AssignRewardModal.tsx
// Version 1.2.0 (Use adminCustomerService for API call)

import React, { useState, useEffect } from 'react';
import { Modal, Select, Button, Group, Text, Loader, Alert } from '@mantine/core';
// axiosInstance ya no se usa aqu√≠ para la acci√≥n principal
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX, IconAlertCircle } from '@tabler/icons-react';
import type { Customer } from '../../hooks/useAdminCustomersData';
import { useTranslation } from 'react-i18next';

// --- NUEVO: Importar el servicio ---
import * as adminCustomerService from '../../services/adminCustomerService';
import axiosInstance from '../../../../shared/services/axiosInstance';// A√∫n necesario para fetchRewards

// Importar el tipo Reward de nuestro archivo centralizado
import type { Reward } from '../../../../shared/types/user.types';

interface AssignRewardModalProps {
    opened: boolean;
    onClose: () => void;
    customer: Customer | null;
    onSuccess: () => void; // Para refrescar la lista de clientes o detalles si es necesario
}

const AssignRewardModal: React.FC<AssignRewardModalProps> = ({ opened, onClose, customer, onSuccess }) => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;

    const [rewards, setRewards] = useState<{ value: string; label: string }[]>([]);
    const [selectedRewardId, setSelectedRewardId] = useState<string | null>(null);
    const [loadingRewards, setLoadingRewards] = useState(false);
    const [loadingAssign, setLoadingAssign] = useState(false);
    const [errorRewards, setErrorRewards] = useState<string | null>(null);

    useEffect(() => {
        if (opened && customer) {
            setLoadingRewards(true);
            setErrorRewards(null);
            setSelectedRewardId(null); // Resetear selecci√≥n al abrir

            // La API /rewards devuelve todos, filtramos las activas en el frontend para este modal
            axiosInstance.get<Reward[]>('/rewards')
                .then(response => {
                    const activeRewards = response.data?.filter(r => r.isActive) ?? [];
                    const availableRewards = activeRewards.map(reward => {
                        const displayName = (currentLanguage === 'es' ? reward.name_es : reward.name_en) || reward.name_es || reward.name_en || `ID: ${reward.id}`;
                        return {
                            value: reward.id,
                            label: `${displayName} (${t('adminCustomersPage.assignRewardOptionPoints', { points: reward.pointsCost ?? 0 })})`
                        };
                    });
                    setRewards(availableRewards);
                })
                .catch(err => {
                    console.error("Error fetching rewards for modal:", err);
                    const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
                    setErrorRewards(t('adminCustomersPage.assignRewardErrorLoading', { error: apiError }));
                })
                .finally(() => {
                    setLoadingRewards(false);
                });
        } else if (!opened) {
            setSelectedRewardId(null);
            setRewards([]);
            setErrorRewards(null);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, customer, t, currentLanguage]); // A√±adir t y currentLanguage

    const handleAssign = async () => {
        if (!customer || !selectedRewardId) return;
        setLoadingAssign(true);
        try {
            // --- CAMBIO: Llamar al servicio en lugar de axiosInstance directamente ---
            await adminCustomerService.assignRewardToCustomerApi(customer.id, selectedRewardId);
            // --- FIN CAMBIO ---

            notifications.show({
                title: t('common.success'),
                message: t('adminCustomersPage.assignRewardSuccess', { name: customer.name || customer.email }),
                color: 'green',
                icon: <IconCheck size={18} />
            });
            onSuccess(); // Refrescar datos en la p√°gina principal
            onClose();   // Cerrar el modal
        } catch (error: any) {
            console.error("Error assigning reward via modal:", error);
            const apiError = error.response?.data?.message || error.message || t('common.errorUnknown');
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.assignRewardError', { error: apiError }),
                color: 'red',
                icon: <IconX size={18} />
            });
        } finally {
            setLoadingAssign(false);
        }
    };

    const modalTitle = t('adminCustomersPage.assignRewardModalTitle', {
        name: customer?.name || customer?.email || t('common.customer')
    });

    return (
        <Modal
            opened={opened}
            onClose={() => { if (!loadingAssign) onClose(); }}
            title={modalTitle}
            centered
            trapFocus
            closeOnClickOutside={!loadingAssign}
            closeOnEscape={!loadingAssign}
        >
            {loadingRewards && <Group justify="center"><Loader /></Group>}
            {errorRewards && !loadingRewards && (
                <Alert title={t('adminCustomersPage.assignRewardLoadingErrorTitle')} color="red" icon={<IconAlertCircle />}>
                    {errorRewards}
                </Alert>
            )}

            {!loadingRewards && !errorRewards && customer && (
                <>
                    <Select
                        label={t('adminCustomersPage.assignRewardSelectLabel')}
                        placeholder={t('adminCustomersPage.assignRewardSelectPlaceholder')}
                        data={rewards}
                        value={selectedRewardId}
                        onChange={setSelectedRewardId}
                        searchable
                        nothingFoundMessage={rewards.length === 0 && !loadingRewards ? t('adminCustomersPage.assignRewardNotFound') : t('common.noResults')}
                        required
                        disabled={rewards.length === 0 || loadingRewards || loadingAssign}
                        mb="md"
                        data-autofocus
                    />
                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={onClose} disabled={loadingAssign}>
                            {t('common.cancel')}
                        </Button>
                        <Button
                            onClick={handleAssign}
                            loading={loadingAssign}
                            disabled={!selectedRewardId || loadingRewards || rewards.length === 0}
                        >
                            {t('adminCustomersPage.assignRewardButton')}
                        </Button>
                    </Group>
                </>
            )}
            {!loadingRewards && !errorRewards && !customer && (
                <Text c="dimmed">{t('adminCustomersPage.noCustomerSelected')}</Text>
            )}
        </Modal>
    );
};

export default AssignRewardModal;


// ====== [171] frontend/src/modules/loyalpyme/components/admin/BulkAdjustPointsModal.tsx ======
// filename: frontend/src/components/admin/BulkAdjustPointsModal.tsx
import React, { useState, useEffect } from 'react';
import {
    Modal, NumberInput, TextInput, Button, Group, Stack
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { IconPlusMinus } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next'; // Importar hook

// Tipo inferido del esquema
type FormValues = z.infer<ReturnType<typeof createValidationSchema>>;

// Funci√≥n para crear el esquema de validaci√≥n (para poder usar t())
const createValidationSchema = (t: Function) => z.object({
  amount: z.number().refine(val => val !== 0, { message: t('validation.cannotBeZero', 'La cantidad no puede ser cero') }),
  reason: z.string().optional(),
});

interface BulkAdjustPointsModalProps {
    opened: boolean;
    onClose: () => void;
    onSubmit: (values: FormValues) => Promise<void>; // La funci√≥n que manejar√° la l√≥gica de env√≠o y notificaciones
    numberOfCustomers: number;
}

const BulkAdjustPointsModal: React.FC<BulkAdjustPointsModalProps> = ({
    opened,
    onClose,
    onSubmit,
    numberOfCustomers
}) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [isSubmitting, setIsSubmitting] = useState(false);

    const form = useForm<FormValues>({
        initialValues: { amount: 0, reason: '', },
        // Pasar t al crear el schema
        validate: zodResolver(createValidationSchema(t)),
    });

    useEffect(() => {
        if (opened) {
            form.reset();
            setIsSubmitting(false);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened]);

    const handleSubmit = async (values: FormValues) => {
        setIsSubmitting(true);
        try {
            await onSubmit(values);
            // Notificaciones y cierre manejados por el padre
        } catch (error) {
            console.error("Error during bulk adjust points submission callback:", error);
            // Notificaci√≥n de error manejada por el padre
        } finally {
            // Decidimos si resetear isSubmitting aqu√≠ o dejarlo al padre/reapertura
            // setIsSubmitting(false);
        }
    };

    // Usar t() para el t√≠tulo del modal
    const modalTitle = t('adminCustomersPage.bulkAdjustPointsModalTitle', { count: numberOfCustomers });

    return (
        <Modal
            opened={opened}
            onClose={() => { if(!isSubmitting) onClose(); }} // Prevenir cierre si est√° enviando
            title={modalTitle}
            centered
        >
            <form onSubmit={form.onSubmit(handleSubmit)}>
                <Stack>
                    <NumberInput
                        label={t('adminCustomersPage.bulkAdjustPointsAmountLabel')}
                        placeholder={t('adminCustomersPage.bulkAdjustPointsAmountPlaceholder')}
                        required
                        allowNegative
                        {...form.getInputProps('amount')}
                        disabled={isSubmitting}
                        data-autofocus // Enfocar este campo al abrir
                    />
                    <TextInput
                        label={t('adminCustomersPage.bulkAdjustPointsReasonLabel')}
                        placeholder={t('adminCustomersPage.bulkAdjustPointsReasonPlaceholder')}
                        {...form.getInputProps('reason')}
                        disabled={isSubmitting}
                    />
                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={onClose} disabled={isSubmitting}>
                            {t('common.cancel')}
                        </Button>
                        <Button
                            type="submit"
                            loading={isSubmitting}
                            leftSection={<IconPlusMinus size={16} />}
                            disabled={!form.isValid() || form.values.amount === 0 || isSubmitting}
                        >
                            {t('adminCustomersPage.bulkAdjustPointsButton')}
                        </Button>
                    </Group>
                </Stack>
            </form>
        </Modal>
    );
};

export default BulkAdjustPointsModal;


// ====== [172] frontend/src/modules/loyalpyme/components/admin/ChangeTierModal.tsx ======
// frontend/src/components/admin/ChangeTierModal.tsx
// Version 1.1.0 (Use adminCustomerService for API call)

import React, { useState, useEffect } from 'react';
import { Modal, Select, Button, Group, Text, Loader, Alert } from '@mantine/core';
// axiosInstance ya no es necesario aqu√≠ directamente
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX, IconAlertCircle } from '@tabler/icons-react';
import { Customer } from '../../hooks/useAdminCustomersData';
import { useTranslation } from 'react-i18next';

// --- NUEVO: Importar el servicio ---
import * as adminCustomerService from '../../services/adminCustomerService';
import axiosInstance from '../../../../shared/services/axiosInstance'; // A√∫n necesario para fetchTiers

// Interfaz para los Tiers (se mantiene igual)
interface TierOption {
    value: string;
    label: string;
}
interface TierFromApi { // Para la respuesta de la API de tiers
    id: string;
    name: string;
    level: number;
}

interface ChangeTierModalProps {
    opened: boolean;
    onClose: () => void;
    customer: Customer | null;
    onSuccess: () => void;
}

const ChangeTierModal: React.FC<ChangeTierModalProps> = ({ opened, onClose, customer, onSuccess }) => {
    const { t } = useTranslation();
    const [tiers, setTiers] = useState<TierOption[]>([]);
    const [selectedTierId, setSelectedTierId] = useState<string | null>(null);
    const [loadingTiers, setLoadingTiers] = useState(false);
    const [loadingChange, setLoadingChange] = useState(false);
    const [errorTiers, setErrorTiers] = useState<string | null>(null);

    useEffect(() => {
        if (opened && customer) {
            setLoadingTiers(true);
            setErrorTiers(null);
            // Inicializar con el tier actual del cliente o '' para "Sin Nivel"
            setSelectedTierId(customer.currentTier?.id || '');

            axiosInstance.get<TierFromApi[]>('/tiers') // La ruta es /api/tiers (el servicio de admin para obtener todos los tiers)
                .then(response => {
                    const sortedTiers = response.data.sort((a, b) => a.level - b.level);
                    const availableTiers: TierOption[] = [
                        { value: '', label: t('adminCustomersPage.changeTierOptionNone') }, // Opci√≥n para quitar tier
                        ...sortedTiers.map(tier => ({
                            value: tier.id,
                            label: `${tier.name} (${t('adminCustomersPage.changeTierOptionLevel', { level: tier.level })})`
                        }))
                    ];
                    setTiers(availableTiers);
                })
                .catch(err => {
                    console.error("Error fetching tiers for modal:", err);
                    const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
                    setErrorTiers(t('adminCustomersPage.changeTierErrorLoadingTiers', { error: apiError }));
                })
                .finally(() => {
                    setLoadingTiers(false);
                });
        } else if (!opened) {
            // Resetear al cerrar
            setSelectedTierId(null);
            setTiers([]);
            setErrorTiers(null);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, customer, t]); // t como dependencia por si las claves cambian

    const handleChangeTier = async () => {
        if (!customer) return;

        const tierIdToSend = selectedTierId === '' ? null : selectedTierId; // '' representa "Sin Nivel"

        if (tierIdToSend === (customer.currentTier?.id || null)) {
            notifications.show({
                title: t('adminCustomersPage.changeTierNoChangeTitle'),
                message: t('adminCustomersPage.changeTierNoChange'),
                color: 'blue'
            });
            return;
        }

        setLoadingChange(true);
        try {
            // --- CAMBIO: Llamar al servicio en lugar de axiosInstance directamente ---
            await adminCustomerService.changeCustomerTierApi(customer.id, tierIdToSend);
            // --- FIN CAMBIO ---

            notifications.show({
                title: t('common.success'),
                message: t('adminCustomersPage.changeTierSuccess', { name: customer.name || customer.email }),
                color: 'green',
                icon: <IconCheck size={18} />,
            });
            onSuccess(); // Refrescar datos en la p√°gina principal
            onClose();   // Cerrar el modal
        } catch (error: any) {
            console.error("Error changing tier via modal:", error);
            const apiError = error.response?.data?.message || error.message || t('common.errorUnknown');
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.changeTierError', { error: apiError }),
                color: 'red',
                icon: <IconX size={18} />,
            });
        } finally {
            setLoadingChange(false);
        }
    };

    const modalTitle = t('adminCustomersPage.changeTierModalTitle', {
        name: customer?.name || customer?.email || t('common.customer')
    });
    const currentTierName = customer?.currentTier?.name || t('customerDashboard.baseTier');

    return (
        <Modal
            opened={opened}
            onClose={() => { if (!loadingChange) onClose(); }}
            title={modalTitle}
            centered
            trapFocus
            closeOnClickOutside={!loadingChange}
            closeOnEscape={!loadingChange}
        >
            {customer && (
                <Text size="sm" mb="xs">
                    {t('adminCustomersPage.changeTierCurrent', { tierName: currentTierName })}
                </Text>
            )}

            {loadingTiers && <Group justify="center"><Loader /></Group>}
            {errorTiers && !loadingTiers && (
                <Alert title={t('adminCustomersPage.changeTierLoadingErrorTitle')} color="red" icon={<IconAlertCircle />}>
                    {errorTiers}
                </Alert>
            )}

            {!loadingTiers && !errorTiers && customer && (
                <>
                    <Select
                        label={t('adminCustomersPage.changeTierSelectLabel')}
                        placeholder={t('adminCustomersPage.changeTierSelectPlaceholder')}
                        data={tiers}
                        value={selectedTierId ?? ''} // Usar '' si es null para que coincida con la opci√≥n "Sin Nivel"
                        onChange={(value) => setSelectedTierId(value)} // Select de Mantine devuelve string | null
                        searchable
                        nothingFoundMessage={t('adminCustomersPage.changeTierNotFound')}
                        disabled={loadingTiers || loadingChange || tiers.length === 0}
                        mb="md"
                        clearable={false} // La opci√≥n "Sin Nivel" maneja la "limpieza"
                    />
                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={onClose} disabled={loadingChange}>
                            {t('common.cancel')}
                        </Button>
                        <Button
                            onClick={handleChangeTier}
                            loading={loadingChange}
                            disabled={loadingTiers || (selectedTierId ?? '') === (customer.currentTier?.id || '') || tiers.length === 0}
                        >
                            {t('adminCustomersPage.changeTierButton')}
                        </Button>
                    </Group>
                </>
            )}
            {!loadingTiers && !errorTiers && !customer && (
                <Text c="dimmed">{t('adminCustomersPage.noCustomerSelected')}</Text>
            )}
        </Modal>
    );
};

export default ChangeTierModal;


// ====== [173] frontend/src/modules/loyalpyme/components/admin/CustomerBulkActionsBar.tsx ======
// frontend/src/components/admin/CustomerBulkActionsBar.tsx
import React from 'react';
import { Paper, Group, Text, Button } from '@mantine/core';
import {
    IconPlayerPlay,
    IconPlayerStop,
    IconTrash,
    IconPlusMinus
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

interface CustomerBulkActionsBarProps {
    selectedRowCount: number;
    onBulkDelete: () => void;
    onBulkActivate: () => void; // Ser√° onBulkToggleActive(true)
    onBulkDeactivate: () => void; // Ser√° onBulkToggleActive(false)
    onOpenBulkAdjustPoints: () => void; // Para abrir el modal de ajuste masivo de puntos
    isPerformingBulkAction: boolean; // Para el estado de carga de los botones
}

const CustomerBulkActionsBar: React.FC<CustomerBulkActionsBarProps> = ({
    selectedRowCount,
    onBulkDelete,
    onBulkActivate,
    onBulkDeactivate,
    onOpenBulkAdjustPoints,
    isPerformingBulkAction,
}) => {
    const { t } = useTranslation();

    if (selectedRowCount === 0) {
        return null; // No mostrar nada si no hay filas seleccionadas
    }

    return (
        <Paper p="xs" mb="md" withBorder shadow="xs">
            <Group justify="space-between">
                <Text fw={500} size="sm">
                    {/* Usar clave i18n con pluralizaci√≥n para el conteo */}
                    {t('adminCustomersPage.selectedCount', { count: selectedRowCount })}
                </Text>
                <Group>
                    <Button
                        size="xs"
                        color="red"
                        variant="filled" // O 'outline' si se prefiere
                        leftSection={<IconTrash size={14} />}
                        onClick={onBulkDelete}
                        loading={isPerformingBulkAction} // Asumimos un solo estado de carga para todas las acciones masivas
                        disabled={isPerformingBulkAction}
                    >
                        {t('adminCustomersPage.bulkDeleteButton')}
                    </Button>
                    <Button
                        size="xs"
                        color="green"
                        variant="outline"
                        leftSection={<IconPlayerPlay size={14} />}
                        onClick={onBulkActivate}
                        loading={isPerformingBulkAction}
                        disabled={isPerformingBulkAction}
                    >
                        {t('adminCustomersPage.bulkActivateButton')}
                    </Button>
                    <Button
                        size="xs"
                        color="red" // Podr√≠a ser 'orange' o 'gray' tambi√©n
                        variant="outline"
                        leftSection={<IconPlayerStop size={14} />}
                        onClick={onBulkDeactivate}
                        loading={isPerformingBulkAction}
                        disabled={isPerformingBulkAction}
                    >
                        {t('adminCustomersPage.bulkDeactivateButton')}
                    </Button>
                    <Button
                        size="xs"
                        color="blue"
                        variant="outline"
                        leftSection={<IconPlusMinus size={14} />}
                        onClick={onOpenBulkAdjustPoints} // Esta prop abre el modal
                        disabled={isPerformingBulkAction} // Se deshabilita si otra acci√≥n masiva est√° en curso
                    >
                        {t('adminCustomersPage.bulkPointsButton')}
                    </Button>
                </Group>
            </Group>
        </Paper>
    );
};

export default CustomerBulkActionsBar;


// ====== [174] frontend/src/modules/loyalpyme/components/admin/CustomerDetailsModal.tsx ======
// filename: frontend/src/components/admin/CustomerDetailsModal.tsx
import React, { useState, useEffect } from 'react';
import {
    Modal, LoadingOverlay, Alert, Text, Group, Badge, Divider, Stack, ScrollArea,
    Textarea, Button
} from '@mantine/core';
import { IconAlertCircle, IconDeviceFloppy } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next'; // Importar hook

// Interfaz CustomerDetails
export interface CustomerDetails {
    id: string;
    email: string;
    name?: string | null;
    points: number;
    createdAt: string;
    isActive: boolean;
    isFavorite?: boolean | null;
    tierAchievedAt?: string | null;
    adminNotes?: string | null;
    businessId: string;
    role: string;
    currentTier?: {
        id: string;
        name: string;
        level: number;
        description?: string | null;
    } | null;
}

// Props del Modal
interface CustomerDetailsModalProps {
    opened: boolean;
    onClose: () => void;
    customerDetails: CustomerDetails | null;
    isLoading: boolean;
    error: string | null;
    onSaveNotes: (notes: string | null) => Promise<void>;
}

const CustomerDetailsModal: React.FC<CustomerDetailsModalProps> = ({
    opened,
    onClose,
    customerDetails,
    isLoading,
    error,
    onSaveNotes
}) => {
    const { t, i18n } = useTranslation(); // Hook de traducci√≥n
    const [editedNotes, setEditedNotes] = useState<string>('');
    const [isSaving, setIsSaving] = useState<boolean>(false);

    // Efecto para inicializar/resetear las notas editables
    useEffect(() => {
        if (opened && customerDetails) {
            setEditedNotes(customerDetails.adminNotes || '');
        }
    }, [opened, customerDetails]);

    // Funci√≥n para formatear fechas usando el idioma actual
    const formatDate = (dateString: string | null | undefined) => {
        if (!dateString) return 'N/A';
        try {
            // Usar i18n.language para el locale
            return new Date(dateString).toLocaleDateString(i18n.language, { day: '2-digit', month: '2-digit', year: 'numeric' });
        } catch {
            return t('common.invalidDate', 'Fecha inv√°lida'); // Clave i18n
        }
    };

    // Usar t() para el t√≠tulo del modal
    const modalTitle = t('adminCustomersPage.customerDetailsModalTitle', {
        name: customerDetails?.name || customerDetails?.email || t('common.customer', 'Cliente')
    });

    // Handler para Guardar Notas
    const handleSave = async () => {
        if (!customerDetails) return;
        setIsSaving(true);
        try {
            await onSaveNotes(editedNotes.trim() ? editedNotes.trim() : null);
            // Notificaciones y cierre los maneja el padre
        } catch (saveError) {
            console.error("Error during save callback execution in modal:", saveError);
            // El padre deber√≠a mostrar la notificaci√≥n de error
        } finally {
            setIsSaving(false);
        }
    };

    return (
        <Modal opened={opened} onClose={onClose} title={modalTitle} size="lg" centered scrollAreaComponent={ScrollArea.Autosize} >
            <LoadingOverlay visible={isLoading} zIndex={1000} overlayProps={{ radius: "sm", blur: 2 }} />
            {error && !isLoading && (
                // Usar t() para el t√≠tulo del Alert
                <Alert icon={<IconAlertCircle size="1rem" />} title={t('adminCustomersPage.customerDetailsLoadingError')} color="red">
                    {error}
                </Alert>
            )}

            {!isLoading && !error && customerDetails && (
                <Stack gap="sm">
                    {/* Usar t() para las etiquetas */}
                    <Group justify="space-between"> <Text fw={500}>{t('common.email')}:</Text> <Text>{customerDetails.email}</Text> </Group>
                    <Group justify="space-between"> <Text fw={500}>{t('common.name')}:</Text> <Text>{customerDetails.name || '-'}</Text> </Group>
                    <Divider my="xs" />
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsPoints')}</Text> <Text fw={700} c="blue">{customerDetails.points}</Text> </Group>
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsTier')}</Text> <Badge color={customerDetails.currentTier ? 'teal' : 'gray'} variant="light"> {customerDetails.currentTier?.name || t('customerDashboard.baseTier')} </Badge> </Group>
                    {customerDetails.currentTier?.description && ( <Text size="sm" c="dimmed"> {customerDetails.currentTier.description} </Text> )}
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsTierDate')}</Text> <Text>{formatDate(customerDetails.tierAchievedAt)}</Text> </Group>
                    <Divider my="xs" />
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsStatus')}</Text> <Badge color={customerDetails.isActive ? 'green' : 'red'} variant="filled"> {customerDetails.isActive ? t('common.active') : t('common.inactive')} </Badge> </Group>
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsFavorite')}</Text> <Text>{customerDetails.isFavorite ? t('common.yes') : t('common.no')}</Text> </Group>
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsRegisteredDate')}</Text> <Text>{formatDate(customerDetails.createdAt)}</Text> </Group>

                    <Divider my="sm" />
                    <Textarea
                        label={t('adminCustomersPage.customerDetailsAdminNotesLabel')}
                        placeholder={t('adminCustomersPage.customerDetailsAdminNotesPlaceholder')}
                        value={editedNotes}
                        onChange={(event) => setEditedNotes(event.currentTarget.value)}
                        minRows={4}
                        autosize
                        disabled={isSaving}
                    />
                    <Group justify="flex-end" mt="md">
                        <Button
                            variant="filled"
                            onClick={handleSave}
                            loading={isSaving}
                            leftSection={<IconDeviceFloppy size={16} />}
                            disabled={editedNotes === (customerDetails.adminNotes || '') || isSaving}
                        >
                            {t('adminCustomersPage.customerDetailsSaveNotesButton')}
                        </Button>
                    </Group>
                </Stack>
            )}
            {!isLoading && !error && !customerDetails && (
                <Text c="dimmed">{t('adminCustomersPage.customerDetailsNoDetails')}</Text>
            )}
        </Modal>
    );
};

export default CustomerDetailsModal;


// ====== [175] frontend/src/modules/loyalpyme/components/admin/CustomerFiltersBar.tsx ======
// frontend/src/components/admin/CustomerFiltersBar.tsx
import React from 'react';
import { Paper, Group, Text, TextInput, Select, Checkbox } from '@mantine/core';
import { IconSearch, IconFilter } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

// Tipo para las opciones del Select de Tier (debe coincidir con el de la p√°gina principal)
export interface TierOption {
    value: string;
    label: string;
}

interface CustomerFiltersBarProps {
    searchTerm: string;
    onSearchTermChange: (term: string) => void;
    activeFilterValue: string; // '', 'active', 'inactive'
    onActiveFilterChange: (value: string | null) => void;
    isFavoriteFilterChecked: boolean;
    onIsFavoriteFilterChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
    tierFilterValue: string; // ID del tier, 'NONE', o '' para todos
    onTierFilterChange: (value: string | null) => void;
    tierOptions: TierOption[]; // Opciones para el selector de Tier
    loadingFilters: boolean; // Para deshabilitar inputs mientras cargan datos (ej. tiers)
    disabled: boolean; // Para deshabilitar todos los filtros si la tabla principal est√° cargando
}

const CustomerFiltersBar: React.FC<CustomerFiltersBarProps> = ({
    searchTerm,
    onSearchTermChange,
    activeFilterValue,
    onActiveFilterChange,
    isFavoriteFilterChecked,
    onIsFavoriteFilterChange,
    tierFilterValue,
    onTierFilterChange,
    tierOptions,
    loadingFilters, // Usado para deshabilitar select de tier mientras carga
    disabled,       // Usado para deshabilitar todo mientras la tabla carga
}) => {
    const { t } = useTranslation();

    return (
        <Paper p="md" withBorder radius="md" shadow="xs">
            <Group>
                <IconFilter size={18} />
                <Text fw={500} size="sm">{t('adminCustomersPage.filterLabel')}</Text>
                <TextInput
                    placeholder={t('adminCustomersPage.searchPlaceholder')}
                    leftSection={<IconSearch size={16} stroke={1.5} />}
                    value={searchTerm}
                    onChange={(event) => onSearchTermChange(event.currentTarget.value)}
                    radius="md"
                    style={{ flex: 1, minWidth: 200 }} // Darle flexibilidad y un m√≠nimo
                    disabled={disabled}
                />
                <Select
                    placeholder={t('adminCustomersPage.statusFilterPlaceholder')}
                    data={[
                        { value: '', label: t('adminCustomersPage.statusFilterAll') },
                        { value: 'active', label: t('adminCustomersPage.statusFilterActive') },
                        { value: 'inactive', label: t('adminCustomersPage.statusFilterInactive') }
                    ]}
                    value={activeFilterValue}
                    onChange={onActiveFilterChange}
                    clearable={false} // Para que siempre haya una opci√≥n (aunque sea 'todos')
                    radius="md"
                    disabled={disabled}
                    style={{ minWidth: 150 }}
                />
                <Checkbox
                    label={t('adminCustomersPage.favoriteFilterLabel')}
                    checked={isFavoriteFilterChecked}
                    onChange={onIsFavoriteFilterChange}
                    disabled={disabled}
                />
                <Select
                    placeholder={t('adminCustomersPage.tierFilterPlaceholder')}
                    data={tierOptions} // Las opciones vienen del componente padre
                    value={tierFilterValue}
                    onChange={onTierFilterChange}
                    disabled={disabled || loadingFilters} // Deshabilitar si los tiers est√°n cargando
                    searchable
                    nothingFoundMessage={t('adminCustomersPage.tierFilterError')} // Reutilizar clave
                    clearable={false} // Para que siempre haya una opci√≥n (ej. 'todos')
                    radius="md"
                    style={{ minWidth: 180 }}
                />
            </Group>
        </Paper>
    );
};

export default CustomerFiltersBar;


// ====== [176] frontend/src/modules/loyalpyme/components/admin/CustomerTable.tsx ======
// filename: frontend/src/components/admin/CustomerTable.tsx
import React from 'react';
import {
    Table, Group, ActionIcon, Text, useMantineTheme, UnstyledButton, Center, rem,
    Checkbox, Badge
} from '@mantine/core';
import {
    IconAdjustments, IconGift, IconEye, IconStar,
    IconStairsUp, IconSelector, IconChevronDown, IconChevronUp,
    IconEyeCheck, IconEyeOff
} from '@tabler/icons-react';
import classes from '../../pages/admin/AdminCustomerManagementPage.module.css';
import { useTranslation } from 'react-i18next'; // Importar hook

// Importar tipos necesarios desde el hook
import { Customer, SortStatus, SortColumn } from '../../hooks/useAdminCustomersData';

// --- Componente Th Auxiliar ---
interface ThProps {
    children: React.ReactNode;
    reversed: boolean;
    sorted: boolean;
    onSort(): void;
    sortKey: SortColumn;
    currentSortKey: SortColumn;
    disabled?: boolean;
}

function Th({ children, reversed, sorted, onSort, sortKey, currentSortKey, disabled }: ThProps) {
    const Icon = sorted && currentSortKey === sortKey ? (reversed ? IconChevronUp : IconChevronDown) : IconSelector;
    const isCurrent = sorted && currentSortKey === sortKey;
    return (
        <Table.Th className={classes.th}>
            <UnstyledButton onClick={disabled ? undefined : onSort} className={classes.control} disabled={disabled}>
                <Group justify="space-between" gap={0} data-active-sort={isCurrent || undefined}>
                    <Text fw={500} fz="sm" span>{children}</Text>
                    {!disabled && (
                        <Center className={classes.icon}>
                            <Icon style={{ width: rem(16), height: rem(16), color: isCurrent ? 'var(--mantine-color-blue-filled)' : undefined }} stroke={1.5} />
                        </Center>
                    )}
                </Group>
            </UnstyledButton>
        </Table.Th>
    );
}
// --- Fin Componente Th ---

// --- Props del Componente CustomerTable ---
interface CustomerTableProps {
    customers: Customer[];
    sortStatus: SortStatus;
    togglingFavoriteId: string | null;
    togglingActiveId?: string | null;
    selectedRows: string[];
    onSort: (column: SortColumn) => void;
    onToggleFavorite: (customerId: string, currentIsFavorite: boolean) => void;
    onOpenAdjustPoints: (customer: Customer) => void;
    onOpenChangeTier: (customer: Customer) => void;
    onOpenAssignReward: (customer: Customer) => void;
    onViewDetails: (customer: Customer) => void;
    onToggleActive: (customer: Customer) => void;
    onRowSelectionChange: (selectedIds: string[]) => void;
}
// --- Fin Props ---

// --- COMPONENTE PRINCIPAL: AdminCustomerTable ---
const CustomerTable: React.FC<CustomerTableProps> = ({
    customers,
    sortStatus,
    togglingFavoriteId,
    togglingActiveId,
    selectedRows,
    onSort,
    onToggleFavorite,
    onOpenAdjustPoints,
    onOpenChangeTier,
    onOpenAssignReward,
    onViewDetails,
    onToggleActive,
    onRowSelectionChange
}) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const theme = useMantineTheme();

    // L√≥gica de Selecci√≥n
    const allVisibleSelected = customers.length > 0 && customers.every(customer => selectedRows.includes(customer.id));
    const someVisibleSelected = customers.some(customer => selectedRows.includes(customer.id));
    const indeterminate = someVisibleSelected && !allVisibleSelected;

    const handleSelectAllClick = () => {
        if (allVisibleSelected) {
            const visibleIds = customers.map(c => c.id);
            onRowSelectionChange(selectedRows.filter(id => !visibleIds.includes(id)));
        } else {
            const visibleIds = customers.map(c => c.id);
            onRowSelectionChange(Array.from(new Set([...selectedRows, ...visibleIds])));
        }
    };

    const handleRowCheckboxChange = (customerId: string, checked: boolean) => {
        if (checked) { onRowSelectionChange([...selectedRows, customerId]); }
        else { onRowSelectionChange(selectedRows.filter(id => id !== customerId)); }
    };

    // Mapeo de filas
    const rows = customers.map((customer) => {
        const isActive = customer.isActive ?? false;
        // Usar t() para los t√≠tulos de los tooltips de activar/desactivar
        const ToggleIcon = isActive ? IconEyeOff : IconEyeCheck;
        const toggleTitle = isActive ? t('adminCustomersPage.tooltipDeactivateCustomer') : t('adminCustomersPage.tooltipActivateCustomer');
        const toggleColor = isActive ? 'red' : 'green';
        const isTogglingThisActive = togglingActiveId === customer.id;
        const isTogglingThisFavorite = togglingFavoriteId === customer.id;
        const isSelected = selectedRows.includes(customer.id);
        const favoriteTooltip = customer.isFavorite
            ? t('adminCustomersPage.tooltipUnfavorite', 'Quitar de Favoritos')
            : t('adminCustomersPage.tooltipFavorite', 'Marcar como Favorito');

        return (
            <Table.Tr key={customer.id} bg={isSelected ? theme.colors.blue[0] : undefined}>
                <Table.Td>
                    <Checkbox
                        aria-label={t('adminCustomersPage.checkboxAriaLabel', `Seleccionar fila ${customer.id}`)} // Nueva clave i18n
                        checked={isSelected}
                        onChange={(event) => handleRowCheckboxChange(customer.id, event.currentTarget.checked)}
                    />
                </Table.Td>
                <Table.Td>
                    <ActionIcon
                        variant="subtle"
                        onClick={() => onToggleFavorite(customer.id, customer.isFavorite ?? false)}
                        loading={isTogglingThisFavorite}
                        disabled={!!togglingFavoriteId || !!togglingActiveId}
                        title={favoriteTooltip} // Usar variable con clave i18n
                    >
                        <IconStar size={18} stroke={1.5} color={customer.isFavorite ? theme.colors.yellow[6] : theme.colors.gray[4]} fill={customer.isFavorite ? theme.colors.yellow[6] : 'none'} />
                    </ActionIcon>
                </Table.Td>
                <Table.Td>{customer.name || '-'}</Table.Td>
                <Table.Td>{customer.email}</Table.Td>
                <Table.Td ta="right">{customer.points}</Table.Td>
                <Table.Td>{customer.currentTier?.name || t('customerDashboard.baseTier')}</Table.Td>
                <Table.Td>{new Date(customer.createdAt).toLocaleDateString()}</Table.Td>
                <Table.Td> <Badge color={isActive ? 'green' : 'red'} variant="light"> {isActive ? t('common.active') : t('common.inactive')} </Badge> </Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        <ActionIcon variant="subtle" color="gray" title={t('adminCustomersPage.tooltipViewDetails')} onClick={() => onViewDetails(customer)} disabled={isTogglingThisActive || isTogglingThisFavorite}><IconEye size={16} stroke={1.5} /></ActionIcon>
                        <ActionIcon variant="subtle" color="blue" title={t('adminCustomersPage.tooltipAdjustPoints')} onClick={() => onOpenAdjustPoints(customer)} disabled={isTogglingThisActive || isTogglingThisFavorite}><IconAdjustments size={16} stroke={1.5} /></ActionIcon>
                        <ActionIcon variant="subtle" color="teal" title={t('adminCustomersPage.tooltipChangeTier')} onClick={() => onOpenChangeTier(customer)} disabled={isTogglingThisActive || isTogglingThisFavorite}><IconStairsUp size={16} stroke={1.5} /></ActionIcon>
                        <ActionIcon variant="subtle" color="grape" title={t('adminCustomersPage.tooltipAssignReward')} onClick={() => onOpenAssignReward(customer)} disabled={isTogglingThisActive || isTogglingThisFavorite}><IconGift size={16} stroke={1.5} /></ActionIcon>
                        <ActionIcon variant="subtle" color={toggleColor} title={toggleTitle} onClick={() => onToggleActive(customer)} loading={isTogglingThisActive} disabled={!!togglingFavoriteId || !!togglingActiveId}><ToggleIcon size={16} stroke={1.5} /></ActionIcon>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    // Renderizado de la tabla
    return (
        <Table.ScrollContainer minWidth={800}>
            <Table striped highlightOnHover withTableBorder verticalSpacing="sm" className={classes.table}>
                <Table.Thead className={classes.thead}>
                    <Table.Tr>
                        <Table.Th style={{ width: rem(40) }}>
                            <Checkbox
                                aria-label={t('adminCustomersPage.checkboxSelectAllAriaLabel', 'Seleccionar todas las filas visibles')} // Nueva clave i18n
                                checked={allVisibleSelected}
                                indeterminate={indeterminate}
                                onChange={handleSelectAllClick}
                            />
                        </Table.Th>
                        <Th sorted={sortStatus.column === 'isFavorite'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('isFavorite')} sortKey="isFavorite" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderFavorite')}</Th>
                        <Th sorted={sortStatus.column === 'name'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('name')} sortKey="name" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderName')}</Th>
                        <Th sorted={sortStatus.column === 'email'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('email')} sortKey="email" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderEmail')}</Th>
                        <Th sorted={sortStatus.column === 'points'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('points')} sortKey="points" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderPoints')}</Th>
                        <Th sorted={sortStatus.column === 'currentTier.level'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('currentTier.level')} sortKey="currentTier.level" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderTier')}</Th>
                        <Th sorted={sortStatus.column === 'createdAt'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('createdAt')} sortKey="createdAt" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderRegistered')}</Th>
                        <Th sorted={sortStatus.column === 'isActive'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('isActive')} sortKey="isActive" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderStatus')}</Th>
                        <Table.Th style={{ textAlign: 'right' }}>{t('adminCustomersPage.tableHeaderActions')}</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>{rows.length > 0 ? rows : (
                    <Table.Tr><Table.Td colSpan={9}><Text c="dimmed" ta="center">{t('adminCustomersPage.noResults')}</Text></Table.Td></Table.Tr>
                 )}</Table.Tbody>
            </Table>
        </Table.ScrollContainer>
    );
};

export default CustomerTable;


// ====== [177] frontend/src/modules/loyalpyme/components/admin/StatCard.module.css ======
/* filename: frontend/src/components/admin/StatCard.module.css */
.card {
    position: relative;
    overflow: hidden;
    background-color: var(--mantine-color-body); /* Asegura fondo */
  }
  
  .value {
    font-size: var(--mantine-font-size-xl); /* Usa variable Mantine o rem(24px) */
    font-weight: 700;
    line-height: 1.3; 
  }
  
  .label {
    font-size: var(--mantine-font-size-xs);
    line-height: var(--mantine-line-height-xs);
    color: var(--mantine-color-dimmed);
    text-transform: uppercase; /* A√±adido para coincidir con dise√±o com√∫n */
  }


// ====== [178] frontend/src/modules/loyalpyme/components/admin/StatCard.test.tsx ======
// frontend/src/modules/loyalpyme/components/admin/StatCard.test.tsx
// Version 1.0.3 - Corrected theme import path

import React from 'react';
import { render } from '@testing-library/react';
import { screen } from '@testing-library/dom';
import { describe, it, expect } from 'vitest';
import StatCard from './StatCard';
import { IconUsers } from '@tabler/icons-react';
import { MantineProvider } from '@mantine/core';

// --- CORRECCI√ìN DE RUTA ---
import { theme } from '../../../../theme';
// --- FIN CORRECCI√ìN ---

describe('StatCard Component', () => {

    const renderWithTheme = (ui: React.ReactElement) => {
        return render(<MantineProvider theme={theme}>{ui}</MantineProvider>);
    };

    it('should render title and value correctly', () => {
        renderWithTheme(<StatCard title="CLIENTES" value={123} />);
        expect(screen.getByText('CLIENTES')).toBeInTheDocument();
        expect(screen.getByText('123')).toBeInTheDocument();
    });

    it('should render icon when provided', () => {
        renderWithTheme(<StatCard title="Test" value={10} icon={<IconUsers data-testid="users-icon" size={24}/>} />);
        expect(screen.getByTestId('users-icon')).toBeInTheDocument();
    });

    it('should render "-" when value is null or undefined', () => {
        const { rerender } = renderWithTheme(<StatCard title="Test Null" value={null} />);
        expect(screen.getByText('-')).toBeInTheDocument();

        rerender(<MantineProvider theme={theme}><StatCard title="Test Undefined" value={undefined} /></MantineProvider>);
        expect(screen.getByText('-')).toBeInTheDocument();
    });

    it('should render trend up icon and value correctly', () => {
        renderWithTheme(<StatCard title="Trend Up" value={100} trendValue="+10.5%" trendDirection="up" />);
        expect(screen.getByText('+10.5%')).toBeInTheDocument();
    });

    it('should render trend down icon and value correctly', () => {
        renderWithTheme(<StatCard title="Trend Down" value={90} trendValue="-5.0%" trendDirection="down" />);
        expect(screen.getByText('-5.0%')).toBeInTheDocument();
    });

     it('should render neutral trend value without arrow', () => {
        const { rerender } = renderWithTheme(<StatCard title="Trend Neutral" value={100} trendValue="N/A" trendDirection="neutral" />);
        expect(screen.getByText('N/A')).toBeInTheDocument();

        rerender(<MantineProvider theme={theme}><StatCard title="Trend Zero" value={100} trendValue="+0.0%" trendDirection="neutral" /></MantineProvider>);
        expect(screen.getByText('+0.0%')).toBeInTheDocument();
    });

    it('should not render trend section if trendValue is null/undefined', () => {
        renderWithTheme(<StatCard title="No Trend" value={100} trendValue={null} trendDirection="neutral" />);
        expect(screen.queryByText(/%/)).not.toBeInTheDocument();
        expect(screen.queryByText('+')).not.toBeInTheDocument();
    });

    it('should display skeletons when loading', () => {
        renderWithTheme(<StatCard title="Loading Test" value={null} loading={true} />);
        expect(screen.queryByText(/-/)).not.toBeInTheDocument();
        expect(screen.getByText('Loading Test')).toBeInTheDocument();
    });
});


// ====== [179] frontend/src/modules/loyalpyme/components/admin/StatCard.tsx ======
// filename: frontend/src/components/admin/StatCard.tsx
import React from 'react';
import { Paper, Group, Text, ThemeIcon, Skeleton, MantineColor, useMantineTheme, Stack } from '@mantine/core';
import { IconArrowUpRight, IconArrowDownRight } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import classes from './StatCard.module.css';

// Tipo para la direcci√≥n de la tendencia
type TrendDirection = 'up' | 'down' | 'neutral';

// Props que acepta nuestro componente StatCard
interface StatCardProps {
  title: string;
  value: number | string | null | undefined;
  icon?: React.ReactNode;
  loading?: boolean;
  color?: MantineColor;
  trendValue?: string | null | undefined; // Aseguramos que trendValue siempre sea string o null/undefined
  trendDirection?: TrendDirection | null | undefined;
}

const StatCard: React.FC<StatCardProps> = ({
  title,
  value,
  icon,
  loading,
  color = 'gray',
  trendValue, // Recibe el string formateado o null/undefined desde el hook
  trendDirection,
}) => {
  const { i18n } = useTranslation(); // Solo para i18n.language
  const theme = useMantineTheme();

  // Formateo del valor principal (sin cambios)
  const displayValue = loading || value === null || value === undefined
    ? '-'
    : typeof value === 'number' ? value.toLocaleString(i18n.language) : value;

  // Determinar icono y color de la tendencia (sin cambios)
  let TrendIcon = null;
  let trendColor: MantineColor = 'dimmed';
  if (trendDirection === 'up') {
    TrendIcon = IconArrowUpRight;
    trendColor = 'teal';
  } else if (trendDirection === 'down') {
    TrendIcon = IconArrowDownRight;
    trendColor = 'red';
  }

  // **CORRECCI√ìN:** No necesitamos formatear `trendValue` aqu√≠, ya viene formateado.
  // Simplemente comprobamos si existe para renderizar la secci√≥n de tendencia.
  const displayTrendValue = trendValue; // Usamos directamente el valor recibido
  const renderTrend = displayTrendValue !== null && displayTrendValue !== undefined && trendDirection;

  return (
    <Paper withBorder p="md" radius="md" className={classes.card}>
      <Group justify="space-between" wrap="nowrap" align="flex-start">
        <Stack gap={0}>
          <Text c="dimmed" tt="uppercase" fw={700} fz="xs" className={classes.label}>
            {title}
          </Text>
          {loading ? (
            <Skeleton height={28} mt={5} width={70} />
          ) : (
             <Text fw={700} fz="xl" className={classes.value} c={color}>
               {displayValue}
             </Text>
          )}
        </Stack>

        {icon && !loading && (
          <ThemeIcon color={color} variant="light" size={38} radius="md">
            {icon}
          </ThemeIcon>
        )}
         {loading && (
            <Skeleton height={38} width={38} radius="md" />
         )}
      </Group>

      {/* Mostramos la tendencia si renderTrend es true */}
      {!loading && renderTrend && (
           <Group gap={4} mt={5} wrap="nowrap">
               {TrendIcon && <TrendIcon size={16} stroke={1.5} color={theme.colors[trendColor][6]} />}
               <Text c={trendColor} fz="xs" fw={500}>
                   {displayTrendValue} {/* Mostramos el string directamente */}
               </Text>
           </Group>
      )}
    </Paper>
  );
};

export default StatCard;


// ====== [180] frontend/src/modules/loyalpyme/components/admin/rewards/RewardForm.tsx ======
// frontend/src/modules/loyalpyme/components/admin/rewards/RewardForm.tsx
// Version 3.5.1 - Fix type mismatch on form.setValues

import React, { useState, useEffect, useCallback } from 'react';
import {
    TextInput, Textarea, NumberInput, Button, Stack, Group, Text as MantineText,
    Select, Alert, Loader, Paper, Switch, Box
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next';
import { notifications } from '@mantine/notifications';
import { IconAlertCircle, IconX } from '@tabler/icons-react';

import axiosInstance from '../../../../../shared/services/axiosInstance';
import { Reward } from '../../../../../shared/types/user.types';
import { RewardType, DiscountType } from '../../../../../shared/types/enums';
import { MenuItemData } from '../../../../camarero/types/menu.types';
import ImageUploadCropper from '../../../../../shared/components/utils/ImageUploadCropper';
import { useLayoutUserData } from '../../../../../shared/hooks/useLayoutUserData';

const createRewardFormSchema = (t: Function) => z.object({
  name_es: z.string().min(1, { message: t('component.rewardForm.errorNameEsRequired') }),
  name_en: z.string().min(1, { message: t('component.rewardForm.errorNameEnRequired') }),
  description_es: z.string().optional(),
  description_en: z.string().optional(),
  pointsCost: z.number().min(0, { message: t('component.rewardForm.errorPointsCostInvalid') }),
  imageUrl: z.string().url({ message: t('validation.invalidUrl') }).nullable().optional(),
  type: z.nativeEnum(RewardType),
  linkedMenuItemId: z.string().optional().nullable(),
  discountType: z.nativeEnum(DiscountType).optional().nullable(),
  discountValue: z.number().optional().nullable(),
  kdsDestination: z.string().optional().nullable(),
})
.refine(data => {
    if (data.type === RewardType.MENU_ITEM) return !!data.linkedMenuItemId;
    return true;
}, {
    message: 'Debes seleccionar un producto del men√∫ para este tipo de recompensa.',
    path: ['linkedMenuItemId'],
})
.refine(data => {
    if (data.type === RewardType.DISCOUNT_ON_ITEM || data.type === RewardType.DISCOUNT_ON_TOTAL) {
        return !!data.discountType && data.discountValue != null && data.discountValue > 0;
    }
    return true;
}, {
    message: 'Debes especificar un tipo y valor de descuento v√°lido y mayor que cero.',
    path: ['discountValue'],
})
.refine(data => {
    if (data.type === RewardType.GENERIC_FREE_PRODUCT) return !!data.kdsDestination;
    return true;
}, {
    message: 'Debes seleccionar un destino de preparaci√≥n para el producto gen√©rico.',
    path: ['kdsDestination'],
});

type RewardFormValues = z.infer<ReturnType<typeof createRewardFormSchema>>;

interface RewardFormProps {
    onSubmitSuccess: (reward: Reward) => void;
    onCancel: () => void;
    initialData?: Reward | null;
}

const RewardForm: React.FC<RewardFormProps> = ({ onSubmitSuccess, onCancel, initialData }) => {
    const { t, i18n } = useTranslation();
    const { userData } = useLayoutUserData();
    const isCamareroActive = userData?.isCamareroActive === true;

    const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
    const [menuItems, setMenuItems] = useState<MenuItemData[]>([]);
    const [loadingMenuItems, setLoadingMenuItems] = useState<boolean>(false);
    const [errorMenuItems, setErrorMenuItems] = useState<string | null>(null);
    const [isSpecificItemDiscount, setIsSpecificItemDiscount] = useState<boolean>(false);

    const form = useForm<RewardFormValues>({
        initialValues: {
            name_es: '', name_en: '', description_es: '', description_en: '',
            pointsCost: 0, imageUrl: null,
            type: RewardType.GENERIC_FREE_PRODUCT,
            linkedMenuItemId: null,
            discountType: DiscountType.FIXED_AMOUNT,
            discountValue: undefined,
            kdsDestination: null,
        },
        validate: zodResolver(createRewardFormSchema(t)),
    });

    const fetchMenuItems = useCallback(async () => {
        if (!isCamareroActive) return;
        setLoadingMenuItems(true);
        setErrorMenuItems(null);
        try {
            const response = await axiosInstance.get<MenuItemData[]>('/camarero/admin/menu/items/all');
            setMenuItems(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || 'No se pudieron cargar los productos del men√∫.';
            setErrorMenuItems(msg);
        } finally {
            setLoadingMenuItems(false);
        }
    }, [isCamareroActive]);

    useEffect(() => {
        if (isCamareroActive) {
            fetchMenuItems();
        }
    }, [isCamareroActive, fetchMenuItems]);
    
    useEffect(() => {
        if (initialData) {
            // --- CORRECCI√ìN: Usar '||' para transformar 'null' a un valor v√°lido para el form ---
            form.setValues({
                name_es: initialData.name_es || '',
                name_en: initialData.name_en || '',
                description_es: initialData.description_es || '',
                description_en: initialData.description_en || '',
                pointsCost: initialData.pointsCost ?? 0,
                imageUrl: initialData.imageUrl || null,
                type: initialData.type || RewardType.DISCOUNT_ON_TOTAL,
                linkedMenuItemId: initialData.linkedMenuItemId || null,
                discountType: initialData.discountType || null,
                discountValue: initialData.discountValue ? Number(initialData.discountValue) : undefined,
                kdsDestination: initialData.kdsDestination || null,
            });
            // --- FIN DE LA CORRECCI√ìN ---

            if (initialData.type === RewardType.DISCOUNT_ON_ITEM && !!initialData.linkedMenuItemId) {
                setIsSpecificItemDiscount(true);
            } else {
                setIsSpecificItemDiscount(false);
            }
        } else {
            form.reset();
            form.setFieldValue('type', isCamareroActive ? RewardType.MENU_ITEM : RewardType.GENERIC_FREE_PRODUCT);
            setIsSpecificItemDiscount(false);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [initialData, isCamareroActive]);

    const handleTypeChange = (value: string | null) => {
        const newType = value as RewardType;
        form.setFieldValue('type', newType);
        
        setIsSpecificItemDiscount(false);
        form.setFieldValue('linkedMenuItemId', null);
        form.setFieldValue('kdsDestination', null);
        
        if (newType !== RewardType.MENU_ITEM) {
            form.setFieldValue('name_es', '');
            form.setFieldValue('name_en', '');
            form.setFieldValue('description_es', '');
            form.setFieldValue('description_en', '');
        }

        if (newType === RewardType.MENU_ITEM || newType === RewardType.GENERIC_FREE_PRODUCT) {
            form.setFieldValue('discountType', null);
            form.setFieldValue('discountValue', undefined);
        } else {
            if (!form.values.discountType) form.setFieldValue('discountType', DiscountType.FIXED_AMOUNT);
        }
    };
    
    const handleMenuItemChange = (value: string | null) => {
        form.setFieldValue('linkedMenuItemId', value);
        const selectedItem = menuItems.find(item => item.id === value);
        if (selectedItem) {
            if (form.values.type === RewardType.MENU_ITEM) {
                form.setFieldValue('name_es', `Gratis: ${selectedItem.name_es}`);
                form.setFieldValue('name_en', `Free: ${selectedItem.name_en || selectedItem.name_es}`);
                form.setFieldValue('description_es', `Obt√©n un(a) ${selectedItem.name_es} gratis con tus puntos.`);
                form.setFieldValue('imageUrl', selectedItem.imageUrl || null);
            }
        }
    };

    const handleToggleSpecificDiscount = (checked: boolean) => {
        setIsSpecificItemDiscount(checked);
        if (!checked) {
            form.setFieldValue('linkedMenuItemId', null);
        }
    };

    const handleSubmit = async (values: RewardFormValues) => {
        setIsSubmitting(true);
        const endpoint = initialData ? `/rewards/${initialData.id}` : '/rewards';
        const method = initialData ? 'patch' : 'post';

        try {
            const response = await axiosInstance[method]<Reward>(endpoint, values);
            onSubmitSuccess(response.data);
        } catch (err: any) {
            const apiError = err.response?.data?.message || err.message || 'Error desconocido';
            notifications.show({ title: 'Error al Guardar', message: apiError, color: 'red', icon: <IconX /> });
        } finally {
            setIsSubmitting(false);
        }
    };

    const menuItemOptions = menuItems.map(item => ({
        value: item.id,
        label: (i18n.language === 'es' ? item.name_es : item.name_en) || item.name_es || `ID: ${item.id}`,
    }));

    const rewardTypeOptions = [
        { value: RewardType.GENERIC_FREE_PRODUCT, label: 'Producto Gen√©rico Gratis (Manual)' },
        ...(isCamareroActive ? [{ value: RewardType.MENU_ITEM, label: 'Producto Gratis (de la Carta)' }] : []),
        { value: RewardType.DISCOUNT_ON_TOTAL, label: 'Descuento en el Total del Pedido' },
        { value: RewardType.DISCOUNT_ON_ITEM, label: 'Descuento en un Producto' },
    ];

    const discountTypeOptions = [
        { value: DiscountType.FIXED_AMOUNT, label: 'Importe Fijo (‚Ç¨)' },
        { value: DiscountType.PERCENTAGE, label: 'Porcentaje (%)' },
    ];
    
    const kdsDestinationOptions = [
        { value: 'COCINA', label: 'Cocina' },
        { value: 'BARRA', label: 'Barra' },
        { value: 'ALMACEN', label: 'Almac√©n / Otro' },
    ];

    const isNameDisabled = isSubmitting || form.values.type === RewardType.MENU_ITEM;

    return (
        <form onSubmit={form.onSubmit(handleSubmit)}>
            <Stack gap="lg">
                <Select
                    label="Tipo de Recompensa" data={rewardTypeOptions} required
                    disabled={isSubmitting} {...form.getInputProps('type')} onChange={handleTypeChange}
                />

                {isCamareroActive && form.values.type === RewardType.MENU_ITEM && (
                    <Paper withBorder p="sm" radius="md">
                        <Select
                            label="Producto del Men√∫" placeholder="Selecciona un producto para regalar..."
                            data={menuItemOptions} searchable required
                            disabled={isSubmitting || loadingMenuItems}
                            rightSection={loadingMenuItems ? <Loader size="xs" /> : undefined}
                            error={form.errors.linkedMenuItemId || errorMenuItems}
                            {...form.getInputProps('linkedMenuItemId')}
                            onChange={handleMenuItemChange}
                        />
                         {errorMenuItems && (<Alert color="orange" icon={<IconAlertCircle size={16} />} mt="xs" p="xs" fz="xs">{errorMenuItems}</Alert>)}
                    </Paper>
                )}

                <Paper withBorder p="sm" radius="md">
                    <Stack>
                        <TextInput label="Nombre (ES)" required disabled={isNameDisabled} {...form.getInputProps('name_es')} />
                        <TextInput label="Nombre (EN)" required disabled={isNameDisabled} {...form.getInputProps('name_en')} />
                        <Textarea label="Descripci√≥n (ES)" rows={2} disabled={isSubmitting} {...form.getInputProps('description_es')} />
                        <Textarea label="Descripci√≥n (EN)" rows={2} disabled={isSubmitting} {...form.getInputProps('description_en')} />
                    </Stack>
                </Paper>

                {form.values.type === RewardType.GENERIC_FREE_PRODUCT && (
                    <Paper withBorder p="sm" radius="md">
                        <Select
                            label="Destino de Preparaci√≥n (KDS)"
                            placeholder="Elige d√≥nde se prepara este producto"
                            data={kdsDestinationOptions}
                            required
                            disabled={isSubmitting}
                            {...form.getInputProps('kdsDestination')}
                        />
                    </Paper>
                )}

                {(form.values.type === RewardType.DISCOUNT_ON_ITEM || form.values.type === RewardType.DISCOUNT_ON_TOTAL) && (
                    <Paper withBorder p="sm" radius="md">
                        <Stack>
                            <Group grow>
                                <Select label="Tipo de Descuento" data={discountTypeOptions} required disabled={isSubmitting} {...form.getInputProps('discountType')} />
                                <NumberInput label="Valor del Descuento" required min={0.01} decimalScale={2} disabled={isSubmitting} {...form.getInputProps('discountValue')} />
                            </Group>
                            
                            {form.values.type === RewardType.DISCOUNT_ON_ITEM && isCamareroActive && (
                                <Box mt="sm" pt="sm" style={{ borderTop: '1px solid var(--mantine-color-gray-3)' }}>
                                    <Switch
                                        label="Aplicar este descuento a un producto espec√≠fico"
                                        checked={isSpecificItemDiscount}
                                        onChange={(event) => handleToggleSpecificDiscount(event.currentTarget.checked)}
                                        disabled={isSubmitting}
                                    />
                                    {isSpecificItemDiscount && (
                                        <Select
                                            label="Producto Espec√≠fico para el Descuento"
                                            placeholder="Selecciona un producto..."
                                            data={menuItemOptions}
                                            searchable
                                            required
                                            mt="xs"
                                            disabled={isSubmitting || loadingMenuItems}
                                            rightSection={loadingMenuItems ? <Loader size="xs" /> : undefined}
                                            error={form.errors.linkedMenuItemId || errorMenuItems}
                                            {...form.getInputProps('linkedMenuItemId')}
                                        />
                                    )}
                                </Box>
                            )}
                        </Stack>
                    </Paper>
                )}

                <NumberInput label="Coste en Puntos" required min={0} disabled={isSubmitting} {...form.getInputProps('pointsCost')} />

                <ImageUploadCropper
                    aspectRatio={1}
                    minDimension={150}
                    initialImageUrl={form.values.imageUrl || null}
                    onUploadSuccess={(url) => form.setFieldValue('imageUrl', url)}
                    onUploadError={(errorMsg) => form.setFieldError('imageUrl', errorMsg)}
                    onClearImage={() => form.setFieldValue('imageUrl', null) }
                    folderName="loyalpyme/rewards"
                    disabled={isSubmitting}
                />
                {form.errors.imageUrl && (<MantineText c="red" size="xs">{form.errors.imageUrl}</MantineText>)}

                <Group justify="flex-end" mt="md">
                    <Button variant="default" onClick={onCancel} disabled={isSubmitting}>{t('common.cancel')}</Button>
                    <Button type="submit" loading={isSubmitting}>{t('common.save')}</Button>
                </Group>
            </Stack>
        </form>
    );
};

export default RewardForm;


// ====== [181] frontend/src/modules/loyalpyme/components/admin/tiers/AddTierBenefitForm.tsx ======
// filename: frontend/src/components/admin/tiers/AddTierBenefitForm.tsx
import React from 'react';
import { TextInput, Textarea, Select, Switch, Stack } from '@mantine/core';
import { UseFormReturnType } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next'; // Importar hook

// --- Tipos/Enums ---
export enum BenefitType {
    POINTS_MULTIPLIER = 'POINTS_MULTIPLIER',
    EXCLUSIVE_REWARD_ACCESS = 'EXCLUSIVE_REWARD_ACCESS',
    CUSTOM_BENEFIT = 'CUSTOM_BENEFIT'
}

// Este schema no se usa directamente aqu√≠ para validar, pero define el tipo
const benefitFormSchema = z.object({
    type: z.nativeEnum(BenefitType),
    value: z.string().min(1),
    description: z.string().optional(),
    isActive: z.boolean(),
});
export type BenefitFormValues = z.infer<typeof benefitFormSchema>;
// --- Fin Tipos/Enums ---


// --- Props del Componente ---
interface AddTierBenefitFormProps {
    form: UseFormReturnType<BenefitFormValues>;
    isSubmitting: boolean;
}
// --- Fin Props ---

const AddTierBenefitForm: React.FC<AddTierBenefitFormProps> = ({ form, isSubmitting }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n

    // Las etiquetas para las opciones del Select se generan en el componente padre (TierBenefitsModal)
    // usando t(), aqu√≠ solo necesitamos los valores del enum.
    const typeOptions = Object.values(BenefitType).map(value => ({
        value: value,
        label: t(`component.addTierBenefitForm.benefitType_${value}`) // Usar t() para la etiqueta si fuera necesario aqu√≠, pero se hace en el padre
    }));

    return (
        <Stack gap="sm">
            <Select
                label={t('component.addTierBenefitForm.typeLabel')}
                placeholder={t('component.addTierBenefitForm.typePlaceholder')}
                data={typeOptions} // Las etiquetas ya vienen traducidas del padre
                required
                disabled={isSubmitting}
                {...form.getInputProps('type')}
            />
            <TextInput
                label={t('component.addTierBenefitForm.valueLabel')}
                placeholder={t('component.addTierBenefitForm.valuePlaceholder')}
                description={t('component.addTierBenefitForm.valueDescription')}
                required
                disabled={isSubmitting}
                {...form.getInputProps('value')}
            />
            <Textarea
                label={t('component.addTierBenefitForm.descriptionLabel')}
                placeholder={t('component.addTierBenefitForm.descriptionPlaceholder')}
                rows={2}
                disabled={isSubmitting}
                {...form.getInputProps('description')}
            />
            <Switch
                label={t('component.addTierBenefitForm.activeLabel')}
                disabled={isSubmitting}
                {...form.getInputProps('isActive', { type: 'checkbox' })}
            />
        </Stack>
    );
};

export default AddTierBenefitForm;


// ====== [182] frontend/src/modules/loyalpyme/components/admin/tiers/CreateTierModal.tsx ======
// filename: frontend/src/components/admin/tiers/CreateTierModal.tsx
import React, { useState } from 'react';
import { Modal, Button, Group } from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { notifications } from '@mantine/notifications';
import { IconDeviceFloppy, IconCheck, IconAlertCircle } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';
import TierForm from './TierForm'; // Este componente tambi√©n necesitar√° i18n
import { useTranslation } from 'react-i18next'; // Importar hook

// Tipos
interface Tier { id: string; name: string; level: number; /* ... otros campos si los devuelve la API ... */ }

// Funci√≥n para crear el esquema Zod, aceptando t
const createTierFormSchema = (t: Function) => z.object({
    name: z.string().min(1, { message: t('validation.nameRequired', 'El nombre es obligatorio') }),
    level: z.number().int().min(0, { message: t('validation.levelMin0', 'El nivel debe ser 0 o mayor') }),
    minValue: z.number().min(0, { message: t('validation.minValueMin0', 'El valor m√≠nimo debe ser 0 o mayor') }),
    description: z.string().optional(),
    benefitsDescription: z.string().optional(),
    isActive: z.boolean(),
});

// Tipo inferido del schema
type TierFormValues = z.infer<ReturnType<typeof createTierFormSchema>>;

// Props
interface CreateTierModalProps {
    opened: boolean;
    onClose: () => void;
    onSuccess: (newTier: Tier) => void;
}

const CreateTierModal: React.FC<CreateTierModalProps> = ({ opened, onClose, onSuccess }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [isCreating, setIsCreating] = useState<boolean>(false);

    // useForm - pasar t al resolver
    const form = useForm<TierFormValues>({
        initialValues: { name: '', level: 0, minValue: 0, description: '', benefitsDescription: '', isActive: true, },
        validate: zodResolver(createTierFormSchema(t)),
    });

    // handleSubmit
    const handleSubmit = async (values: TierFormValues) => {
        setIsCreating(true);
        try {
            const response = await axiosInstance.post<Tier>('/tiers/tiers', values);
            notifications.show({
                title: t('adminTiersManagePage.createSuccessTitle'),
                message: t('adminTiersManagePage.createSuccessMessage', { name: response.data.name }),
                color: 'green',
                icon: <IconCheck size={18} />
            });
            form.reset();
            onSuccess(response.data);
            onClose();
        } catch (err: any) {
            console.error("Error creating tier:", err);
            const apiError = err.response?.data?.message || t('adminTiersManagePage.createErrorMessage');
            notifications.show({
                title: t('adminTiersManagePage.createErrorTitle'),
                message: apiError,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
        } finally {
            setIsCreating(false);
        }
    };

    // handleClose
    const handleClose = () => { form.reset(); onClose(); }

    // JSX
    return (
        <Modal
            opened={opened}
            onClose={handleClose}
            title={t('adminTiersManagePage.createModalTitle')} // Usar t() para el t√≠tulo
            centered
            size="md"
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            <form onSubmit={form.onSubmit(handleSubmit)}>
                {/* TierForm necesita i18n internamente */}
                <TierForm form={form} />
                <Group justify="flex-end" mt="lg">
                    <Button variant="default" onClick={handleClose} disabled={isCreating}>{t('common.cancel')}</Button>
                    <Button type="submit" loading={isCreating} leftSection={<IconDeviceFloppy size={18} />}>
                        {/* Reutilizamos la clave del bot√≥n de la p√°gina principal */}
                        {t('adminTiersManagePage.addButton')}
                    </Button>
                </Group>
            </form>
        </Modal>
    );
};

export default CreateTierModal;


// ====== [183] frontend/src/modules/loyalpyme/components/admin/tiers/DeleteTierModal.tsx ======
// filename: frontend/src/components/admin/tiers/DeleteTierModal.tsx
import React from 'react';
import { Modal, Text, Button, Group } from '@mantine/core';
import { useTranslation } from 'react-i18next'; // Importar hook

// --- Props del Componente ---
interface DeleteTierModalProps {
    opened: boolean;
    onClose: () => void;
    onConfirm: () => void;
    tierName?: string | null;
    loading?: boolean;
}
// --- Fin Props ---

const DeleteTierModal: React.FC<DeleteTierModalProps> = ({ opened, onClose, onConfirm, tierName, loading }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n

    return (
        <Modal
            opened={opened}
            onClose={onClose}
            title={t('adminTiersManagePage.deleteModalTitle')} // Usar t() para el t√≠tulo
            centered
            size="sm"
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            {/* Usar t() para el mensaje, pasando el nombre del tier */}
            <Text size="sm">
                {t('adminTiersManagePage.deleteModalMessage', { name: tierName || '' })}
            </Text>
            <Group justify="flex-end" mt="lg">
                <Button variant="default" onClick={onClose} disabled={loading}>
                    {t('common.cancel')}
                </Button>
                <Button color="red" onClick={onConfirm} loading={loading}>
                    {t('adminTiersManagePage.deleteModalConfirm')}
                </Button>
            </Group>
        </Modal>
    );
};

export default DeleteTierModal;


// ====== [184] frontend/src/modules/loyalpyme/components/admin/tiers/EditTierModal.tsx ======
// filename: frontend/src/components/admin/tiers/EditTierModal.tsx
import React, { useState, useEffect } from 'react';
import { Modal, Button, Group } from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { notifications } from '@mantine/notifications';
import { IconDeviceFloppy, IconCheck, IconAlertCircle } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';
import TierForm from './TierForm'; // Este componente tambi√©n necesita i18n
import { useTranslation } from 'react-i18next'; // Importar hook

// --- Tipos ---
interface Tier {
    id: string;
    name: string;
    level: number;
    minValue: number;
    description: string | null;
    benefitsDescription: string | null;
    isActive: boolean;
}

// Funci√≥n para crear el esquema Zod, aceptando t
const createTierFormSchema = (t: Function) => z.object({
    name: z.string().min(1, { message: t('validation.nameRequired', 'El nombre es obligatorio') }),
    level: z.number().int().min(0, { message: t('validation.levelMin0', 'El nivel debe ser 0 o mayor') }),
    minValue: z.number().min(0, { message: t('validation.minValueMin0', 'El valor m√≠nimo debe ser 0 o mayor') }),
    description: z.string().optional(),
    benefitsDescription: z.string().optional(),
    isActive: z.boolean(),
});

type TierFormValues = z.infer<ReturnType<typeof createTierFormSchema>>;
// --- Fin Tipos ---

// --- Props del Componente ---
interface EditTierModalProps {
    opened: boolean;
    onClose: () => void;
    onSuccess: () => void;
    tier: Tier | null;
}
// --- Fin Props ---

const EditTierModal: React.FC<EditTierModalProps> = ({ opened, onClose, onSuccess, tier }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [isSaving, setIsSaving] = useState<boolean>(false);

    const form = useForm<TierFormValues>({
        initialValues: {
            name: '', level: 0, minValue: 0, description: '',
            benefitsDescription: '', isActive: true,
        },
        validate: zodResolver(createTierFormSchema(t)), // Pasar t al resolver
    });

    useEffect(() => {
        if (tier && opened) {
            form.setValues({
                name: tier.name,
                level: tier.level,
                minValue: tier.minValue,
                description: tier.description ?? '',
                benefitsDescription: tier.benefitsDescription ?? '',
                isActive: tier.isActive,
            });
        } else if (!opened) {
            form.reset();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [tier, opened]);

    const handleSubmit = async (values: TierFormValues) => {
        if (!tier) return;
        setIsSaving(true);
        try {
            await axiosInstance.put(`/tiers/tiers/${tier.id}`, values);
            notifications.show({
                title: t('adminTiersManagePage.updateSuccessTitle'),
                message: t('adminTiersManagePage.updateSuccessMessage', { name: values.name }),
                color: 'green',
                icon: <IconCheck size={18} />
            });
            onSuccess();
            onClose();
        } catch (err: any) {
            console.error(`Error updating tier ${tier.id}:`, err);
            const apiError = err.response?.data?.message || t('adminTiersManagePage.updateErrorMessage');
            notifications.show({
                title: t('adminTiersManagePage.updateErrorTitle'),
                message: apiError,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
        } finally {
            setIsSaving(false);
        }
    };

    const handleClose = () => {
        onClose();
    }

    return (
        <Modal
            opened={opened}
            onClose={handleClose}
            // Usar t() para el t√≠tulo
            title={t('adminTiersManagePage.editModalTitle', { name: tier?.name || '' })}
            centered
            size="md"
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            <form onSubmit={form.onSubmit(handleSubmit)}>
                {/* TierForm necesita i18n internamente */}
                <TierForm form={form} />
                <Group justify="flex-end" mt="lg">
                    <Button variant="default" onClick={handleClose} disabled={isSaving}>{t('common.cancel')}</Button>
                    <Button type="submit" loading={isSaving} leftSection={<IconDeviceFloppy size={18} />}>
                        {t('common.save')}
                    </Button>
                </Group>
            </form>
        </Modal>
    );
};

export default EditTierModal;


// ====== [185] frontend/src/modules/loyalpyme/components/admin/tiers/TierBenefitsModal.tsx ======
// filename: frontend/src/components/admin/tiers/TierBenefitsModal.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
    Modal, Title, Text, Stack, Group, Button, Loader, Alert, Table, ActionIcon,
    Divider, Box, Badge
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next'; // Importar hook
import AddTierBenefitForm, { BenefitFormValues, BenefitType } from './AddTierBenefitForm'; // Este componente tambi√©n necesita i18n
import { notifications } from '@mantine/notifications';
import { IconPencil, IconTrash, IconAlertCircle, IconCheck } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';

// --- Tipos ---
interface TierBenefit { id: string; type: BenefitType; value: string; description: string | null; isActive: boolean; }
interface Tier { id: string; name: string; }

// --- Funci√≥n para crear Schema Zod con t() ---
const createBenefitFormSchema = (t: Function) => z.object({
    type: z.nativeEnum(BenefitType, { errorMap: () => ({ message: t('validation.benefitTypeRequired', 'Selecciona un tipo de beneficio v√°lido.') }) }),
    value: z.string().min(1, { message: t('component.addTierBenefitForm.errorValueRequired', 'El valor es obligatorio') }), // Usando clave del componente hijo (deber√≠a estar all√≠)
    description: z.string().optional(),
    isActive: z.boolean(),
});
// --- FIN ---

// --- Props ---
interface TierBenefitsModalProps {
    opened: boolean;
    onClose: () => void;
    tier: Tier | null;
}
// --- Fin Props ---

const TierBenefitsModal: React.FC<TierBenefitsModalProps> = ({ opened, onClose, tier }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [benefits, setBenefits] = useState<TierBenefit[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);
    const [isSubmitting, setIsSubmitting] = useState<boolean>(false);

    // Definir etiquetas de tipos de beneficio usando t()
    const benefitTypeLabels: Record<BenefitType, string> = {
        [BenefitType.POINTS_MULTIPLIER]: t('component.addTierBenefitForm.benefitType_POINTS_MULTIPLIER'),
        [BenefitType.EXCLUSIVE_REWARD_ACCESS]: t('component.addTierBenefitForm.benefitType_EXCLUSIVE_REWARD_ACCESS'),
        [BenefitType.CUSTOM_BENEFIT]: t('component.addTierBenefitForm.benefitType_CUSTOM_BENEFIT')
    };

    // useForm usa el schema con t()
    const form = useForm<BenefitFormValues>({
        initialValues: { type: BenefitType.CUSTOM_BENEFIT, value: '', description: '', isActive: true, },
        validate: zodResolver(createBenefitFormSchema(t)),
    });

    // Cargar beneficios
    const fetchBenefits = useCallback(async () => {
        if (!tier?.id || !opened) { setBenefits([]); return; }
        setLoading(true); setError(null);
        try {
            const response = await axiosInstance.get<TierBenefit[]>(`/tiers/tiers/${tier.id}/benefits`);
            setBenefits(response.data);
        } catch (err: any) {
            console.error(`Error fetching benefits for tier ${tier.id}:`, err);
            const message = err.response?.data?.message || t('component.tierBenefitsModal.errorLoading');
            setError(message);
            notifications.show({
                title: t('common.errorLoadingData'), // T√≠tulo gen√©rico
                message,
                color: 'red',
                icon: <IconAlertCircle />
            });
        } finally { setLoading(false); }
    }, [tier?.id, opened, t]); // A√±adir t como dependencia

    useEffect(() => { fetchBenefits(); }, [fetchBenefits]);

    // Handler para A√ëADIR beneficio
    const handleAddBenefit = async (values: BenefitFormValues) => {
        if (!tier?.id) return;
        setIsSubmitting(true);
        try {
            await axiosInstance.post(`/tiers/tiers/${tier.id}/benefits`, values);
            notifications.show({
                title: t('component.tierBenefitsModal.addSuccessTitle'),
                message: t('component.tierBenefitsModal.addSuccessMessage'),
                color: 'green',
                icon: <IconCheck />
            });
            form.reset();
            fetchBenefits();
        } catch (err: any) {
            console.error(`Error adding benefit to tier ${tier.id}:`, err);
            notifications.show({
                title: t('component.tierBenefitsModal.addErrorTitle'),
                message: err.response?.data?.message || t('component.tierBenefitsModal.addErrorMessage'),
                color: 'red',
                icon: <IconAlertCircle />
            });
        } finally { setIsSubmitting(false); }
    };

    // Handlers para Editar/Eliminar (Placeholders con t())
    const handleEditBenefit = (benefit: TierBenefit) => {
        console.log("TODO: Edit benefit", benefit);
        notifications.show({
            title: t('common.upcomingFeatureTitle', 'Pr√≥ximamente'), // Nueva clave
            message: t('component.tierBenefitsModal.editUpcoming'),
            color: 'blue'
        });
    };
    const handleDeleteBenefit = async (benefitId: string) => {
        console.log("TODO: Delete benefit", benefitId);
        notifications.show({
            title: t('common.upcomingFeatureTitle', 'Pr√≥ximamente'), // Nueva clave
            message: t('component.tierBenefitsModal.deleteUpcoming'),
            color: 'blue'
        });
    };

    // Filas tabla beneficios (Usa benefitTypeLabels local con t())
    const benefitRows = benefits.map((benefit) => (
        <Table.Tr key={benefit.id}>
            <Table.Td>{benefitTypeLabels[benefit.type] || benefit.type}</Table.Td>
            <Table.Td><Text size="sm" truncate style={{ maxWidth: 150 }}>{benefit.value}</Text></Table.Td>
            <Table.Td><Text size="sm" truncate style={{ maxWidth: 200 }}>{benefit.description || '-'}</Text></Table.Td>
            <Table.Td>
                <Badge color={benefit.isActive ? 'green' : 'gray'} variant="light">
                    {benefit.isActive ? t('common.active') : t('common.inactive')}
                </Badge>
            </Table.Td>
            <Table.Td>
                <Group gap="xs" wrap="nowrap">
                    <ActionIcon variant="subtle" color="blue" onClick={() => handleEditBenefit(benefit)} title={t('component.tierBenefitsModal.tooltipEditBenefit')}>
                        <IconPencil size={16} />
                    </ActionIcon>
                    <ActionIcon variant="subtle" color="red" onClick={() => handleDeleteBenefit(benefit.id)} title={t('component.tierBenefitsModal.tooltipDeleteBenefit')}>
                        <IconTrash size={16} />
                    </ActionIcon>
                </Group>
            </Table.Td>
        </Table.Tr>
    ));

    // JSX Modal
    return (
        <Modal
            opened={opened}
            onClose={() => { form.reset(); onClose(); }}
            // Usar t() para el t√≠tulo
            title={t('component.tierBenefitsModal.modalTitle', { name: tier?.name || '...' })}
            size="xl" centered
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            <Stack gap="lg">
                {/* Secci√≥n a√±adir */}
                <Box>
                    <Title order={4} mb="sm">{t('component.tierBenefitsModal.addSectionTitle')}</Title>
                    <form onSubmit={form.onSubmit(handleAddBenefit)}>
                        {/* AddTierBenefitForm necesita i18n internamente */}
                        <AddTierBenefitForm form={form} isSubmitting={isSubmitting} />
                        <Group justify="flex-end" mt="md">
                            <Button type="submit" loading={isSubmitting} size="sm">
                                {t('component.tierBenefitsModal.addBenefitButton')}
                            </Button>
                        </Group>
                    </form>
                </Box>

                <Divider my="sm" />

                {/* Secci√≥n listar beneficios */}
                <Box>
                    <Title order={4} mb="sm">{t('component.tierBenefitsModal.listSectionTitle')}</Title>
                    {loading && <Group justify="center"><Loader size="sm" /></Group>}
                    {error && !loading &&
                        <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>
                            {error}
                        </Alert>
                    }
                    {!loading && !error && benefits.length === 0 && (
                        <Text c="dimmed" ta="center">{t('component.tierBenefitsModal.noBenefits')}</Text>
                    )}
                    {!loading && !error && benefits.length > 0 && (
                        <Table.ScrollContainer minWidth={500}>
                            <Table striped highlightOnHover withTableBorder withColumnBorders verticalSpacing="sm">
                                <Table.Thead>
                                    <Table.Tr>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderType')}</Table.Th>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderValue')}</Table.Th>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderDescription')}</Table.Th>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderStatus')}</Table.Th>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderActions')}</Table.Th>
                                    </Table.Tr>
                                </Table.Thead>
                                <Table.Tbody>{benefitRows}</Table.Tbody>
                            </Table>
                        </Table.ScrollContainer>
                    )}
                </Box>

                {/* Bot√≥n cerrar */}
                <Group justify="flex-end" mt="lg">
                    <Button variant="default" onClick={() => { form.reset(); onClose(); }}>{t('common.close')}</Button>
                </Group>
            </Stack>
        </Modal>
    );
};

export default TierBenefitsModal;


// ====== [186] frontend/src/modules/loyalpyme/components/admin/tiers/TierForm.tsx ======
// filename: frontend/src/components/admin/tiers/TierForm.tsx
import React from 'react';
import { TextInput, NumberInput, Textarea, Switch, Stack } from '@mantine/core';
import { UseFormReturnType } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next'; // Importar hook

// --- Tipos ---
// Esquema Zod (no necesita 't' aqu√≠ ya que los mensajes se definen en el componente padre)
const tierFormSchema = z.object({
    name: z.string().min(1),
    level: z.number().int().min(0),
    minValue: z.number().min(0),
    description: z.string().optional(),
    benefitsDescription: z.string().optional(),
    isActive: z.boolean(),
});

export type TierFormValues = z.infer<typeof tierFormSchema>;
// --- Fin Tipos ---

// --- Props del Componente ---
interface TierFormProps {
    form: UseFormReturnType<TierFormValues>;
    disabled?: boolean;
}
// --- Fin Props ---

const TierForm: React.FC<TierFormProps> = ({ form, disabled }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n

    return (
        <Stack gap="md">
            <TextInput
                label={t('component.tierForm.nameLabel')}
                placeholder={t('component.tierForm.namePlaceholder')}
                required
                disabled={disabled}
                {...form.getInputProps('name')}
            />
            <NumberInput
                label={t('component.tierForm.levelLabel')}
                placeholder={t('component.tierForm.levelPlaceholder')}
                description={t('component.tierForm.levelDescription')}
                required
                min={0}
                step={1}
                allowDecimal={false}
                disabled={disabled}
                {...form.getInputProps('level')}
            />
            <NumberInput
                label={t('component.tierForm.minValueLabel')}
                placeholder={t('component.tierForm.minValuePlaceholder')}
                description={t('component.tierForm.minValueDescription')}
                required
                min={0}
                decimalScale={2} // Permite decimales para gasto, pero step=1 si es para visitas/puntos
                // step={1} // Considera ajustar esto seg√∫n la l√≥gica de minValue
                disabled={disabled}
                {...form.getInputProps('minValue')}
            />
            <Textarea
                label={t('component.tierForm.descriptionLabel')}
                placeholder={t('component.tierForm.descriptionPlaceholder')}
                rows={2}
                disabled={disabled}
                {...form.getInputProps('description')}
            />
            <Textarea
                label={t('component.tierForm.benefitsDescriptionLabel')}
                placeholder={t('component.tierForm.benefitsDescriptionPlaceholder')}
                rows={3}
                disabled={disabled}
                {...form.getInputProps('benefitsDescription')}
            />
            <Switch
                label={t('component.tierForm.activeLabel')}
                description={t('component.tierForm.activeDescription')}
                mt="sm"
                disabled={disabled}
                {...form.getInputProps('isActive', { type: 'checkbox' })}
            />
        </Stack>
    );
};

export default TierForm;


// ====== [187] frontend/src/modules/loyalpyme/components/admin/tiers/TierTable.tsx ======
// filename: frontend/src/components/admin/tiers/TierTable.tsx
import React from 'react';
import { Table, Group, ActionIcon, Badge, Text } from '@mantine/core';
import { IconPencil, IconTrash, IconListDetails } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next'; // Importar hook

// Tipos
enum BenefitType { POINTS_MULTIPLIER = 'POINTS_MULTIPLIER', EXCLUSIVE_REWARD_ACCESS = 'EXCLUSIVE_REWARD_ACCESS', CUSTOM_BENEFIT = 'CUSTOM_BENEFIT' }
interface TierBenefit { id: string; isActive: boolean; type: BenefitType; value: string; description: string | null; }
interface Tier { id: string; name: string; level: number; minValue: number; description: string | null; benefitsDescription: string | null; isActive: boolean; benefits: TierBenefit[]; }

// Props
interface TierTableProps {
    tiers: Tier[];
    onEditClick: (tierId: string) => void;
    onDeleteClick: (tierId: string) => void;
    onManageBenefitsClick: (tier: Tier) => void;
}

const TierTable: React.FC<TierTableProps> = ({ tiers, onEditClick, onDeleteClick, onManageBenefitsClick }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n

    // Funci√≥n interna para formatear resumen de beneficios
    const formatBenefitsSummary = (benefits: TierBenefit[]): string => {
        if (!benefits || benefits.length === 0) return t('adminTiersManagePage.benefitsSummaryNone');
        const activeBenefits = benefits.filter(b => b.isActive);
        if (activeBenefits.length === 0) return t('adminTiersManagePage.benefitsSummaryNoneActive');
        // Usar clave con pluralizaci√≥n
        return t('adminTiersManagePage.benefitsSummaryActive', { count: activeBenefits.length });
    };

    // Crear filas de la tabla
    const rows = tiers.map((tier) => (
        <Table.Tr key={tier.id}>
            <Table.Td>{tier.level}</Table.Td>
            <Table.Td fw={500}>{tier.name}</Table.Td>
            <Table.Td>{tier.minValue}</Table.Td>
            <Table.Td>{formatBenefitsSummary(tier.benefits)}</Table.Td>
            <Table.Td>
                <Badge color={tier.isActive ? 'green' : 'gray'} variant="light">
                    {tier.isActive ? t('common.active') : t('common.inactive')}
                </Badge>
            </Table.Td>
            <Table.Td>
                <Group gap="xs" wrap="nowrap">
                    <ActionIcon variant="subtle" color="teal" onClick={() => onManageBenefitsClick(tier)} title={t('adminTiersManagePage.tooltipManageBenefits')}>
                        <IconListDetails size={16} />
                    </ActionIcon>
                    <ActionIcon variant="subtle" color="blue" onClick={() => onEditClick(tier.id)} title={t('adminTiersManagePage.tooltipEditTier')}>
                        <IconPencil size={16} />
                    </ActionIcon>
                    <ActionIcon variant="subtle" color="red" onClick={() => onDeleteClick(tier.id)} title={t('adminTiersManagePage.tooltipDeleteTier')}>
                        <IconTrash size={16} />
                    </ActionIcon>
                </Group>
            </Table.Td>
        </Table.Tr>
    ));

    // Renderizado de la tabla
    return (
        <Table.ScrollContainer minWidth={600}>
            <Table verticalSpacing="sm" striped highlightOnHover withTableBorder withColumnBorders>
                <Table.Thead>
                    <Table.Tr>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderLevel')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderName')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderThreshold')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderBenefits')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderStatus')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderActions')}</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>
                    {rows.length > 0 ? rows : (
                        <Table.Tr>
                            <Table.Td colSpan={6}>
                                <Text c="dimmed" ta="center">{t('adminTiersManagePage.noTiersDefined')}</Text>
                            </Table.Td>
                        </Table.Tr>
                    )}
                </Table.Tbody>
            </Table>
        </Table.ScrollContainer>
    );
};

export default TierTable;


// ====== [188] frontend/src/modules/loyalpyme/components/customer/ApplyRewardModal.tsx ======
// frontend/src/modules/loyalpyme/components/customer/ApplyRewardModal.tsx
// VERSI√ìN 4.1.0 - Correcci√≥n final y definitiva de la l√≥gica de fusi√≥n de recompensas.

import React, { useState, useEffect, useMemo } from 'react';
import { Modal, Button, Group, Stack, Text, Divider, Badge, Box, Checkbox, Paper, ScrollArea } from '@mantine/core';
import { useTranslation } from 'react-i18next';
import { notifications } from '@mantine/notifications';

import { Reward, GrantedReward, DisplayReward } from '../../../../shared/types/user.types';
import { RewardType } from '../../../../shared/types/enums';

export interface AppliedSelections {
  discount: DisplayReward | null;
  freeItems: DisplayReward[];
}

interface ApplyRewardModalProps {
  opened: boolean;
  onClose: () => void;
  userPoints: number;
  availableCoupons: GrantedReward[] | undefined;
  redeemableRewards: Reward[] | undefined;
  initialSelections: AppliedSelections;
  onApply: (selections: AppliedSelections) => void;
  isApplying: boolean;
  appliedLcoRewardIdOnActiveOrder: string | null;
}

const ApplyRewardModal: React.FC<ApplyRewardModalProps> = ({
    opened, onClose, userPoints, availableCoupons, redeemableRewards,
    initialSelections, onApply, isApplying, appliedLcoRewardIdOnActiveOrder,
}) => {
    const { t, i18n } = useTranslation();
    const [localSelections, setLocalSelections] = useState<AppliedSelections>(initialSelections);

    useEffect(() => {
        if (opened) {
            setLocalSelections(initialSelections);
        }
    }, [opened, initialSelections]);

    const unifiedRewards: DisplayReward[] = useMemo(() => {
        const rewardMap = new Map<string, DisplayReward>();

        // 1. A√±adir cupones (GrantedReward). Tienen prioridad.
        (availableCoupons || []).forEach(gr => {
            const rewardData = gr.reward;
            rewardMap.set(rewardData.id, {
                isGift: true,
                grantedRewardId: gr.id,
                id: rewardData.id,
                name_es: rewardData.name_es, name_en: rewardData.name_en,
                description_es: rewardData.description_es, description_en: rewardData.description_en,
                pointsCost: 0,
                imageUrl: rewardData.imageUrl,
                type: rewardData.type,
                linkedMenuItemId: rewardData.linkedMenuItemId,
                discountType: rewardData.discountType,
                // --- ¬°¬°¬°LA CORRECCI√ìN M√ÅS IMPORTANTE EST√Å AQU√ç!!! ---
                // Leemos el valor del objeto anidado 'reward' y lo asignamos al nivel superior.
                // Nos aseguramos de que se convierta a n√∫mero.
                discountValue: rewardData.discountValue ? Number(rewardData.discountValue) : null,
                assignedAt: gr.assignedAt,
                assignedByString: ''
            });
        });

        // 2. A√±adir recompensas del cat√°logo si no existe ya un cup√≥n.
        (redeemableRewards || []).forEach(r => {
            if (!rewardMap.has(r.id)) {
                rewardMap.set(r.id, {
                    isGift: false,
                    id: r.id,
                    name_es: r.name_es, name_en: r.name_en,
                    description_es: r.description_es, description_en: r.description_en,
                    pointsCost: r.pointsCost,
                    imageUrl: r.imageUrl,
                    type: r.type,
                    linkedMenuItemId: r.linkedMenuItemId,
                    discountType: r.discountType,
                    discountValue: r.discountValue ? Number(r.discountValue) : null,
                });
            }
        });
        
        return Array.from(rewardMap.values());
    }, [availableCoupons, redeemableRewards]);

    const handleSelect = (item: DisplayReward) => {
        const isDiscountType = item.type === RewardType.DISCOUNT_ON_ITEM || item.type === RewardType.DISCOUNT_ON_TOTAL;
        const uniqueItemId = item.isGift ? item.grantedRewardId! : item.id;
        
        setLocalSelections(prev => {
            const newSelections = { ...prev };
            const prevDiscountId = prev.discount ? (prev.discount.isGift ? prev.discount.grantedRewardId! : prev.discount.id) : null;

            if (isDiscountType) {
                newSelections.discount = prevDiscountId === uniqueItemId ? null : item;
            } else {
                const existingIndex = prev.freeItems.findIndex(fi => (fi.isGift ? fi.grantedRewardId : fi.id) === uniqueItemId);
                if (existingIndex > -1) newSelections.freeItems = prev.freeItems.filter(fi => (fi.isGift ? fi.grantedRewardId : fi.id) !== uniqueItemId);
                else newSelections.freeItems = [...prev.freeItems, item];
            }
            return newSelections;
        });
    };

    const pointsToSpend = useMemo(() => {
        let totalCost = localSelections.freeItems.reduce((sum, item) => sum + (item.isGift ? 0 : item.pointsCost), 0);
        if (localSelections.discount && !localSelections.discount.isGift) totalCost += localSelections.discount.pointsCost;
        return totalCost;
    }, [localSelections]);
    
    const remainingPointsAfterSelection = userPoints - pointsToSpend;
    const canAffordSelection = remainingPointsAfterSelection >= 0;

    const isItemSelected = (item: DisplayReward) => {
        const uniqueId = item.isGift ? item.grantedRewardId! : item.id;
        const discountId = localSelections.discount ? (localSelections.discount.isGift ? localSelections.discount.grantedRewardId! : localSelections.discount.id) : null;
        return discountId === uniqueId || localSelections.freeItems.some(fi => (fi.isGift ? fi.grantedRewardId : fi.id) === uniqueId);
    };

    const handleConfirm = () => {
        if (!canAffordSelection) {
            notifications.show({ title: t('common.error'), message: t('applyRewardModal.notEnoughPoints'), color: 'red' });
            return;
        }
        onApply(localSelections); onClose();
    };
    
    return (
        <Modal opened={opened} onClose={onClose} title={t('applyRewardModal.title')} size="lg" centered>
            <Stack>
                {unifiedRewards.length > 0 ? (
                    <ScrollArea.Autosize mah="50vh">
                        <Stack>
                            {unifiedRewards.map(item => {
                                const isSelected = isItemSelected(item);
                                const isDiscountType = item.type.includes('DISCOUNT');
                                const canAfford = item.isGift || userPoints >= item.pointsCost;
                                
                                const isDisabled =
                                    (!isSelected && !canAfford) ||
                                    (isDiscountType && localSelections.discount !== null && !isSelected) ||
                                    (item.id === appliedLcoRewardIdOnActiveOrder && !isSelected);

                                return (
                                    <Paper key={item.id + (item.isGift ? '-gift' : '')} withBorder p="sm" radius="md" opacity={isDisabled ? 0.5 : 1}>
                                        <Checkbox
                                            checked={isSelected}
                                            onChange={() => handleSelect(item)}
                                            disabled={isDisabled}
                                            label={
                                                <Group justify="space-between" w="100%">
                                                    <Text>{(i18n.language === 'es' ? item.name_es : item.name_en) || 'Recompensa'}</Text>
                                                    {item.isGift ? (
                                                        <Badge color="green" variant="light">Gratis (Cup√≥n)</Badge>
                                                    ) : (
                                                        <Badge color={canAfford ? 'blue' : 'gray'}>{item.pointsCost} pts</Badge>
                                                    )}
                                                </Group>
                                            }
                                        />
                                        {isDisabled && item.id === appliedLcoRewardIdOnActiveOrder && (
                                            <Text size="xs" c="orange" mt={4}>{t('applyRewardModal.alreadyApplied')}</Text>
                                        )}
                                    </Paper>
                                );
                            })}
                        </Stack>
                    </ScrollArea.Autosize>
                ) : (
                    <Text c="dimmed" ta="center" p="md">{t('applyRewardModal.noRewardsInCatalog')}</Text>
                )}

                <Divider my="sm" />

                <Box p="xs" bg={!canAffordSelection ? 'red.1' : undefined} style={{ borderRadius: 'var(--mantine-radius-sm)' }}>
                    <Group justify="space-between">
                        <Stack gap={0}><Text fw={500}>{t('applyRewardModal.summary.totalCost')}</Text><Text size="sm" c={!canAffordSelection ? 'red' : 'dimmed'}>{t('applyRewardModal.summary.availablePoints', { points: userPoints })}</Text></Stack>
                        <Badge size="xl" color={!canAffordSelection ? 'red' : 'blue'}>{t('applyRewardModal.summary.pointsBadge', { points: pointsToSpend })}</Badge>
                    </Group>
                    {!canAffordSelection && (<Text c="red" size="xs" mt={4}>{t('applyRewardModal.notEnoughPoints')}</Text>)}
                </Box>
                
                <Group justify="flex-end" mt="md">
                    <Button variant="default" onClick={onClose} disabled={isApplying}>{t('common.cancel')}</Button>
                    <Button onClick={handleConfirm} disabled={isApplying || !canAffordSelection} loading={isApplying}>{t('applyRewardModal.applyButton')}</Button>
                </Group>
            </Stack>
        </Modal>
    );
};

export default ApplyRewardModal;


// ====== [189] frontend/src/modules/loyalpyme/components/customer/AvailableCouponsList.tsx ======
// frontend/src/modules/loyalpyme/components/customer/AvailableCouponsList.tsx
// NEW COMPONENT - Version 1.0.0

import React from 'react';
import { SimpleGrid, Paper, Text, Group, ThemeIcon, Stack, Alert } from '@mantine/core';
import { IconTicket, IconAlertCircle } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { GrantedReward } from '../../../../shared/types/user.types';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';

interface AvailableCouponsListProps {
    coupons: GrantedReward[];
    loading: boolean;
    error: string | null;
}

const AvailableCouponsList: React.FC<AvailableCouponsListProps> = ({ coupons, loading, error }) => {
    const { t, i18n } = useTranslation();

    if (loading) {
        return <Text>{t('common.loading', 'Cargando...')}</Text>;
    }

    if (error) {
        return (
            <Alert title={t('common.error')} color="red" icon={<IconAlertCircle size="1rem" />}>
                {error}
            </Alert>
        );
    }

    if (coupons.length === 0) {
        return (
            <Paper withBorder p="lg" radius="md" style={{ borderStyle: 'dashed' }}>
                <Text c="dimmed" ta="center">
                    {t('customerDashboard.noAvailableCoupons', 'No tienes cupones disponibles. ¬°Canjea tus puntos en el cat√°logo para obtenerlos!')}
                </Text>
            </Paper>
        );
    }

    return (
        <SimpleGrid cols={{ base: 1, sm: 2, lg: 3 }} spacing="md">
            {coupons.map((coupon) => (
                <Paper key={coupon.id} withBorder p="md" radius="md">
                    <Group wrap="nowrap" align="flex-start">
                        <ThemeIcon size="lg" variant="light" radius="md">
                            <IconTicket size={24} />
                        </ThemeIcon>
                        <Stack gap={0}>
                            <Text fw={500}>{i18n.language === 'es' ? coupon.reward.name_es : coupon.reward.name_en}</Text>
                            <Text size="sm" c="dimmed">
                                {i18n.language === 'es' ? coupon.reward.description_es : coupon.reward.description_en}
                            </Text>
                            {coupon.expiresAt && (
                                <Text size="xs" c="dimmed" mt="xs">
                                    {t('customerDashboard.couponExpires', 'Caduca el:')} {format(new Date(coupon.expiresAt), 'dd/MM/yyyy', { locale: es })}
                                </Text>
                            )}
                        </Stack>
                    </Group>
                </Paper>
            ))}
        </SimpleGrid>
    );
};

export default AvailableCouponsList;


// ====== [190] frontend/src/modules/loyalpyme/components/customer/NextTierPreview.tsx ======
// frontend/src/modules/loyalpyme/components/customer/NextTierPreview.tsx
// Version 1.0.2 - Corrected type import path

import React from 'react';
import { Title, List, ThemeIcon, Text, Stack, Box } from '@mantine/core';
import { IconSparkles } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

// --- CORRECCI√ìN DE RUTA ---
import { TierBenefitData } from '../../../../shared/types/user.types';
// --- FIN CORRECCI√ìN ---


interface NextTierPreviewProps {
    nextTierName: string;
    nextTierBenefits: TierBenefitData[];
}

const NextTierPreview: React.FC<NextTierPreviewProps> = ({ nextTierName, nextTierBenefits }) => {
    const { t } = useTranslation();

    if (!nextTierBenefits || nextTierBenefits.length === 0) {
        return null;
    }

    const formatBenefitText = (benefit: TierBenefitData) => {
        switch (benefit.type) {
            case 'POINTS_MULTIPLIER':
                return <>{t('benefits.pointsMultiplier', { value: benefit.value })}</>;
            case 'EXCLUSIVE_REWARD_ACCESS':
                return <>{t('benefits.exclusiveRewardAccess', { value: benefit.value })}</>;
            case 'CUSTOM_BENEFIT':
            default:
                return benefit.value;
        }
    }

    return (
        <Box mt="xl">
            <Stack gap="md">
                <Title order={5} c="dimmed">
                    {t('customerDashboard.nextTierBenefitsTitle', { tierName: nextTierName })}
                </Title>

                <List
                    spacing="sm"
                    size="sm"
                    center
                    icon={
                        <ThemeIcon color="gray" variant='light' size={24} radius="xl">
                            <IconSparkles style={{ width: '70%', height: '70%' }} />
                        </ThemeIcon>
                    }
                >
                    {nextTierBenefits.map((benefit) => (
                        <List.Item key={benefit.id}>
                            <Text span c="dimmed">
                                {formatBenefitText(benefit)}
                            </Text>
                            {benefit.description && (
                                <Text size="xs" c="dimmed" display="block">
                                    {benefit.description}
                                </Text>
                            )}
                        </List.Item>
                    ))}
                </List>
            </Stack>
        </Box>
    );
};

export default NextTierPreview;


// ====== [191] frontend/src/modules/loyalpyme/components/customer/QrValidationSection.tsx ======
// filename: frontend/src/components/customer/QrValidationSection.tsx
// Version: 2.3.2 (Remove isMobile check, Add console log for isValidating prop)

import React, { useState, useCallback } from 'react';
import {
    Paper, Title, Group, TextInput, Button, Modal, Stack, Alert, Text, Box, 
} from '@mantine/core';
import { IconAlertCircle, IconScan, IconTicket } from '@tabler/icons-react';
import { useQrScanner } from '../../hooks/useQrScanner'; // Asume v1.2.1 con try/catch
// useMediaQuery ya no es necesario
import { useTranslation } from 'react-i18next';

// Props (sin cambios)
interface QrValidationSectionProps {
    onValidate: (token: string) => Promise<void>;
    isValidating: boolean;
    scannerOpened: boolean;
    onOpenScanner: () => void;
    onCloseScanner: () => void;
}

const QrValidationSection: React.FC<QrValidationSectionProps> = ({
    onValidate,
    isValidating, // <-- La prop que queremos comprobar
    scannerOpened,
    onOpenScanner,
    onCloseScanner
}) => {
    const { t } = useTranslation();
    const [qrTokenInput, setQrTokenInput] = useState('');
    const qrcodeRegionId = "html5qr-code-reader-region";

    // --- Log de Depuraci√≥n ---
    console.log('[QrValidationSection] Rendering. isValidating =', isValidating);
    // --- Fin Log ---

    const handleScanSuccess = useCallback((decodedText: string) => { if (!isValidating) { onValidate(decodedText); onCloseScanner(); } }, [isValidating, onValidate, onCloseScanner]);
    const { scannerError, clearScannerError } = useQrScanner({ qrcodeRegionId: qrcodeRegionId, enabled: scannerOpened, onScanSuccess: handleScanSuccess, config: { fps: 10, qrbox: { width: 250, height: 250 } } });
    const handleManualSubmit = () => { if (qrTokenInput.trim() && !isValidating) { onValidate(qrTokenInput.trim()); } };
    const handleCloseModal = () => { clearScannerError(); onCloseScanner(); };

    return (
        <>
            <Paper shadow="sm" p="lg" mb="xl" withBorder radius="lg">
                <Title order={4} mb="md">{t('customerDashboard.validateQrSectionTitle')}</Title>
                <Group align="flex-end">
                     <TextInput label={t('customerDashboard.qrInputLabel')} placeholder={t('customerDashboard.qrInputPlaceholder')} value={qrTokenInput} onChange={(event) => setQrTokenInput(event.currentTarget.value)} style={{ flexGrow: 1 }} disabled={isValidating || scannerOpened} />
                     <Button onClick={handleManualSubmit} leftSection={<IconTicket size={18} />} loading={isValidating && !scannerOpened} disabled={!qrTokenInput.trim() || isValidating || scannerOpened} variant='outline'> {t('customerDashboard.validateButton')} </Button>
                    {/* --- Bot√≥n Scan: ELIMINADA condici√≥n !isMobile de 'disabled' --- */}
                    <Button
                        onClick={onOpenScanner}
                        leftSection={<IconScan size={18} />}
                        disabled={isValidating} // <-- SOLO deshabilitado si isValidating es true
                        variant='gradient'
                        gradient={{ from: 'blue', to: 'cyan', deg: 90 }}
                    >
                        {t('customerDashboard.scanButton')}
                    </Button>
                    {/* --- FIN CAMBIO --- */}
                </Group>
            </Paper>

            {/* Modal (sin cambios aqu√≠) */}
            <Modal opened={scannerOpened} onClose={handleCloseModal} title={t('customerDashboard.scanModalTitle')} size="auto" centered>
                <Stack>
                   <Text size="sm" ta="center" c="dimmed">{t('customerDashboard.scanInstructions')}</Text>
                    <Box id={qrcodeRegionId} w="100%"></Box>
                    {/* El error del scanner ahora se mostrar√° aqu√≠ si no hay c√°mara */}
                    {scannerError && ( <Alert icon={<IconAlertCircle size="1rem" />} title={t('customerDashboard.errorScanningQr')} color="red" withCloseButton onClose={clearScannerError} mt="sm"> {scannerError} </Alert> )}
                    {isValidating && <Group justify='center'><Text>{t('customerDashboard.validating')}</Text></Group>}
                    <Button variant="outline" onClick={handleCloseModal} disabled={isValidating}> {t('customerDashboard.scanCancelButton')} </Button>
                </Stack>
            </Modal>
        </>
    );
};

export default QrValidationSection;

// End of File: frontend/src/components/customer/QrValidationSection.tsx


// ====== [192] frontend/src/modules/loyalpyme/components/customer/RewardList.tsx ======
// frontend/src/modules/loyalpyme/components/customer/RewardList.tsx
// VERSI√ìN 2.1.0 - CORRECCI√ìN DE IMPORTACI√ìN

import React from 'react';
import { 
    SimpleGrid, Card, Button, Alert, Group, Text, Badge, Tooltip, Box, 
    AspectRatio, Image as MantineImage, Stack, Title // <-- Title A√ëADIDO AQU√ç
} from '@mantine/core';
import { IconGift, IconAlertCircle, IconInfoCircle, IconCoin, IconCirclePlus } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { DisplayReward } from '../../../../shared/types/user.types';

// --- PROPS REFACTORIZADAS ---
interface RewardListProps {
    rewards: DisplayReward[];
    userPoints?: number;
    redeemingRewardId: string | null;
    errorRewards: string | null;
    loadingRewards: boolean;
    onRedeemPoints: (rewardId: string) => void;
    onRedeemGift: (grantedRewardId: string, rewardName: string) => void;
    isAcquireFlow?: boolean;
}

const RewardList: React.FC<RewardListProps> = ({
    rewards,
    userPoints,
    redeemingRewardId,
    errorRewards,
    loadingRewards,
    onRedeemPoints,
    onRedeemGift,
    isAcquireFlow = false,
}) => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;

    const formatDate = (dateString: string | undefined) => {
        if (!dateString) return '?';
        try {
            return new Date(dateString).toLocaleDateString(i18n.language);
        } catch {
            return '?';
        }
    };

    if (loadingRewards) {
        return <Text>{t('common.loading', 'Cargando...')}</Text>;
    }
    
    if (errorRewards) {
        return (
            <Alert icon={<IconAlertCircle size="1rem" />} title={t('common.error')} color="red" mt="lg">
                {errorRewards}
            </Alert>
        );
    }

    if (rewards.length === 0) {
        const messageKey = isAcquireFlow
            ? 'customerDashboard.noRewardsInCatalog'
            : 'customerDashboard.noRewardsAvailable';
        return <Text mt="md">{t(messageKey)}</Text>;
    }
    
    return (
        <SimpleGrid cols={{ base: 1, xs: 2, md: 3 }} spacing="lg">
            {rewards.map((item) => {
                const displayName = (currentLanguage === 'es' ? item.name_es : item.name_en) || item.name_es || item.name_en || '(Sin nombre)';
                const displayDescription = (currentLanguage === 'es' ? item.description_es : item.description_en) || item.description_es || item.description_en;
                const isAffordable = item.isGift || (typeof userPoints !== 'undefined' && userPoints >= item.pointsCost);
                
                const isThisItemLoading = redeemingRewardId === (item.isGift ? item.grantedRewardId : item.id);
                const isAnyItemLoading = !!redeemingRewardId;

                const buttonText = isAcquireFlow
                    ? t('customerDashboard.acquireRewardButton', 'Obtener por {{count}} Puntos', { count: item.pointsCost })
                    : t('customerDashboard.redeemRewardButton', 'Canjear Recompensa');
                
                const buttonIcon = isAcquireFlow ? <IconCirclePlus size={16}/> : <IconCoin size={16}/>;

                return (
                    <Card shadow="sm" padding="sm" radius="md" withBorder key={item.isGift ? `G-${item.grantedRewardId}` : `R-${item.id}`}>
                        <Stack gap="md">
                            <AspectRatio ratio={1 / 1}>
                                <MantineImage src={item.imageUrl || '/placeholder-reward.png'} alt={displayName} fit="cover" radius="sm" fallbackSrc="/placeholder-reward.png" />
                            </AspectRatio>
                            <Stack gap="xs" style={{ flexGrow: 1 }}>
                                <Title order={5}>{displayName}</Title>
                                {displayDescription && <Text size="sm" c="dimmed" lineClamp={2}>{displayDescription}</Text>}
                            </Stack>
                            
                            {item.isGift ? (
                                <>
                                    <Group gap="xs" mt="sm" justify='space-between'>
                                        <Badge color="lime" variant='light' size="lg" radius="sm">{t('customerDashboard.giftFree')}</Badge>
                                        <Tooltip multiline w={220} withArrow position="top" label={t('customerDashboard.giftAssignedBy', { assigner: item.assignedByString, date: formatDate(item.assignedAt) })}>
                                            <Box style={{ display: 'inline-block', cursor: 'help' }}>
                                                <Group gap={4}>
                                                    <IconInfoCircle size={16} stroke={1.5} style={{ display: 'block' }}/>
                                                    <Text size="xs" c="dimmed">{t('customerDashboard.giftInfo')}</Text>
                                                </Group>
                                            </Box>
                                        </Tooltip>
                                    </Group>
                                    <Button variant="filled" color="yellow" fullWidth mt="sm" radius="md" size="sm" onClick={() => onRedeemGift(item.grantedRewardId!, displayName)} disabled={isAnyItemLoading} loading={isThisItemLoading} leftSection={<IconGift size={16}/>}>
                                        {t('customerDashboard.redeemGiftButton')}
                                    </Button>
                                </>
                            ) : (
                                <>
                                    <Group justify="space-between" align="center" mt="sm">
                                        <Text fw={500} size="sm">{item.pointsCost} {t('common.points')}</Text>
                                        {isAffordable && <Badge color="green" variant="light" size="xs">{t('customerDashboard.rewards.affordable', 'Asequible')}</Badge>}
                                    </Group>
                                    <Button
                                        variant="light" color="blue" fullWidth mt="sm" radius="md" size="sm"
                                        onClick={() => onRedeemPoints(item.id)}
                                        disabled={!isAffordable || isAnyItemLoading}
                                        loading={isThisItemLoading}
                                        leftSection={buttonIcon}
                                    >
                                        {isAffordable ? buttonText : t('customerDashboard.insufficientPoints')}
                                    </Button>
                                </>
                            )}
                        </Stack>
                    </Card>
                );
            })}
        </SimpleGrid>
    );
};

export default RewardList;


// ====== [193] frontend/src/modules/loyalpyme/components/customer/TierBenefitsDisplay.tsx ======
// frontend/src/modules/loyalpyme/components/customer/TierBenefitsDisplay.tsx
// Version 1.0.3 - Corrected type import path and implemented benefit text formatting.

import React from 'react';
import { Paper, Title, List, ThemeIcon, Text, Stack } from '@mantine/core';
import { IconCircleCheck } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

// --- CORRECCI√ìN DE RUTA ---
import { TierBenefitData } from '../../../../shared/types/user.types';
// --- FIN CORRECCI√ìN ---

interface TierBenefitsDisplayProps {
    tierName: string;
    benefits: TierBenefitData[];
}

const TierBenefitsDisplay: React.FC<TierBenefitsDisplayProps> = ({ tierName, benefits }) => {
    const { t } = useTranslation();

    if (!benefits || benefits.length === 0) {
        return null;
    }
    
    // --- L√ìGICA MEJORADA PARA MOSTRAR BENEFICIOS ---
    const formatBenefitText = (benefit: TierBenefitData) => {
        switch (benefit.type) {
            case 'POINTS_MULTIPLIER':
                return t('benefits.pointsMultiplier', { value: benefit.value });
            case 'EXCLUSIVE_REWARD_ACCESS':
                return t('benefits.exclusiveRewardAccess', { value: benefit.value });
            case 'CUSTOM_BENEFIT':
            default:
                return benefit.value;
        }
    };
    // --- FIN L√ìGICA MEJORADA ---

    return (
        <Paper shadow="sm" p="lg" mt="xl" mb="xl" withBorder radius="lg">
            <Stack gap="md">
                <Title order={4}>
                    {t('customerDashboard.tierBenefitsTitle', { tierName })}
                </Title>

                <List
                    spacing="xs"
                    size="sm"
                    center
                    icon={
                        <ThemeIcon color="teal" size={20} radius="xl">
                            <IconCircleCheck style={{ width: '70%', height: '70%' }} />
                        </ThemeIcon>
                    }
                >
                    {benefits.map((benefit) => (
                        <List.Item key={benefit.id}>
                            <Text fw={500} span>
                                {formatBenefitText(benefit)}
                            </Text>
                            {benefit.description && (
                                <Text size="xs" c="dimmed" display="block">
                                    {benefit.description}
                                </Text>
                            )}
                        </List.Item>
                    ))}
                </List>
            </Stack>
        </Paper>
    );
};

export default TierBenefitsDisplay;


// ====== [194] frontend/src/modules/loyalpyme/components/customer/UserInfoDisplay.tsx ======
// frontend/src/modules/loyalpyme/components/customer/UserInfoDisplay.tsx
// Version 1.0.2 - Corrected type import path

import React from 'react';
import {
    Card, Text, Group, Progress, Stack, Popover, List, ThemeIcon, Loader, Alert, Box,
    ActionIcon
} from '@mantine/core';
import {
    IconCircleCheck, IconGift, IconDiscount2, IconStar, IconAlertCircle,
    IconHelp
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { TFunction } from 'i18next';
import { useDisclosure, useMediaQuery } from '@mantine/hooks';

// --- CORRECCI√ìN DE RUTA ---
import { UserData, TierBenefitData, TierCalculationBasis, TierData } from '../../../../shared/types/user.types';
// --- FIN CORRECCI√ìN ---


type ProgressBarDataType = {
    type: 'progress';
    percentage: number;
    currentValueLabel: string;
    targetValueLabel: string;
    unit: string;
    nextTierName: string;
} | {
    type: 'max_level';
    currentTierName: string;
} | null;

export interface UserInfoDisplayProps {
    userData: UserData | null;
    loadingUser: boolean;
    errorUser: string | null;
    progressBarData: ProgressBarDataType;
    benefits: TierBenefitData[];
    nextTierName: string | null;
    nextTierBenefits: TierBenefitData[];
    tierCalculationBasis?: TierCalculationBasis | null;
    allTiers?: TierData[];
}

const renderBenefitItem = (benefit: TierBenefitData, index: number, t: TFunction): JSX.Element => {
    let icon = <IconStar size={16} />;
    let text = benefit.description || `${benefit.type}: ${benefit.value}`;
    switch (benefit.type) {
        case 'POINTS_MULTIPLIER': icon = <IconCircleCheck size={16} />; text = t('benefits.pointsMultiplier', { value: benefit.value }); break;
        case 'EXCLUSIVE_REWARD_ACCESS': icon = <IconGift size={16} />; text = t('benefits.exclusiveRewardAccess', { value: benefit.value }); break;
        case 'CUSTOM_BENEFIT': icon = <IconDiscount2 size={16} />; text = t('benefits.customBenefit', { value: benefit.value }); break;
    }
    return ( <List.Item key={benefit.id || index} icon={<ThemeIcon color="teal" size={24} radius="xl">{icon}</ThemeIcon>}>{text}</List.Item> );
};


const UserInfoDisplay: React.FC<UserInfoDisplayProps> = ({
    userData,
    loadingUser,
    errorUser,
    progressBarData,
    benefits,
    nextTierBenefits,
}) => {
    const { t } = useTranslation();
    const isMobile = useMediaQuery('(max-width: em(768px))');
    const [popoverOpened, { open: openPopover, close: closePopover, toggle: togglePopover }] = useDisclosure(false);

    if (loadingUser) { return <Card withBorder radius="md" p="xl"><Loader size="sm" data-testid="user-info-loader" /></Card>; }
    if (errorUser || !userData) { return ( <Card withBorder radius="md" p="xl"><Alert title={t('customerDashboard.errorLoadingProfileTitle')} color="red" icon={<IconAlertCircle size="1rem" />} data-testid="user-info-error">{errorUser || t('customerDashboard.errorLoadingProfileDefault')}</Alert></Card> ); }

    const currentTierDisplayName = userData.currentTier?.name ?? t('customerDashboard.baseTier');
    const displayPoints = userData.points ?? 0;

    const nextTierTitle = progressBarData?.type === 'progress' ? progressBarData.nextTierName : null;
    const popoverTitleText = nextTierTitle ? t('customerDashboard.nextTierBenefitsTitle', { tierName: nextTierTitle }) : '';

    const nextTierContent = nextTierTitle ? (
        <Stack gap="xs">
            <Text fw={500}>{popoverTitleText}</Text>
            {nextTierBenefits && nextTierBenefits.length > 0 ? (
                <List spacing="xs" size="sm" center>{nextTierBenefits.map((b, i) => renderBenefitItem(b, i, t))}</List>
            ) : ( <Text size="sm" c="dimmed">{t('common.noItems')}</Text> )}
        </Stack>
    ) : null;

    return (
        <Card withBorder radius="md" p="xl" data-testid="user-info-card">
            <Stack gap="lg">
                <Group justify="space-between">
                    <Text fz="lg" fw={600}>{userData.name || userData.email}</Text>
                    <Text fz="lg" fw={700} c="blue">{displayPoints.toLocaleString()} {t('common.points')}</Text>
                </Group>

                <Stack gap="xs">
                    <Group justify="space-between">
                        <Text fz="sm" fw={500} c="dimmed">{t('customerDashboard.currentTier')}</Text>
                        <Text fz="sm" fw={700} data-testid="current-tier-name">{currentTierDisplayName}</Text>
                    </Group>

                    {progressBarData?.type === 'progress' && nextTierContent && (
                        <Box>
                            <Popover width={300} position="top" withArrow shadow="md" opened={popoverOpened}>
                                <Popover.Target>
                                    <Group
                                        wrap="nowrap"
                                        gap="xs"
                                        onMouseEnter={!isMobile ? openPopover : undefined}
                                        onMouseLeave={!isMobile ? closePopover : undefined}
                                        style={{ cursor: !isMobile ? 'help' : 'default' }}
                                    >
                                        <Progress
                                            value={progressBarData.percentage}
                                            size="lg" radius="xl" striped animated
                                            style={{ flexGrow: 1 }}
                                            data-testid="progress-bar"
                                        />
                                        <ActionIcon
                                            variant="subtle"
                                            color="gray"
                                            onClick={togglePopover}
                                            hiddenFrom="sm"
                                            aria-label={t('customerDashboard.nextTierBenefitsTitle', { tierName: nextTierTitle || ''})}
                                            title={t('customerDashboard.nextTierBenefitsTitle', { tierName: nextTierTitle || ''})}
                                            data-testid="mobile-popover-trigger"
                                        >
                                            <IconHelp size={18} stroke={1.5}/>
                                        </ActionIcon>
                                    </Group>
                                </Popover.Target>
                                <Popover.Dropdown>
                                    {nextTierContent}
                                </Popover.Dropdown>
                            </Popover>
                            <Group justify="space-between" mt={5}>
                                <Text fz="xs" c="dimmed" data-testid="progress-label">
                                    {t('customerDashboard.progressLabel', {
                                        currentValue: progressBarData.currentValueLabel,
                                        targetValue: progressBarData.targetValueLabel,
                                        unit: progressBarData.unit,
                                        nextTierName: progressBarData.nextTierName
                                    })}
                                </Text>
                            </Group>
                        </Box>
                    )}
                    {progressBarData?.type === 'max_level' && (
                         <Box data-testid="max-level-indicator">
                            <Progress value={100} size="lg" radius="xl" color="teal" />
                            <Text fz="xs" c="teal" fw={500} mt={5}>{t('customerDashboard.maxLevelReachedShort')}</Text>
                         </Box>
                    )}
                    {!progressBarData && !loadingUser && !errorUser && (
                       <Text fz="xs" c="dimmed">{t('customerDashboard.errorLoadingProgress')}</Text>
                    )}
                </Stack>

                <Stack gap="xs" mt="md" data-testid="current-benefits-section">
                    <Text fw={500}>{t('customerDashboard.tierBenefitsTitle', { tierName: currentTierDisplayName })}</Text>
                    {benefits && benefits.length > 0 ? (
                        <List spacing="xs" size="sm" center icon={<></>}>
                            {benefits.map((b, i) => renderBenefitItem(b, i, t))}
                        </List>
                    ) : (
                        <Text size="sm" c="dimmed">{t('common.noItems')}</Text>
                    )}
                </Stack>
            </Stack>
        </Card>
    );
};

export default UserInfoDisplay;


// ====== [195] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/ActivityTab.tsx ======
// frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/ActivityTab.tsx
// Version 2.1.5 - Corrected type import paths

import React from 'react';
import {
    Stack, Loader, Alert, Text, Pagination, Group, Box,
    Timeline, ThemeIcon, Badge,
    Title
} from '@mantine/core';
import {
    IconAlertCircle, IconGift, IconReceipt, IconTicket, IconAdjustments, IconShoppingCart, IconDiscount2
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useCustomerActivity } from '../../../../hooks/useCustomerActivity';

// --- CORRECCI√ìN DE RUTAS ---
import type { ActivityLogItem } from '../../../../../../shared/types/user.types';
import { ActivityType } from '../../../../../../shared/types/user.types';
// --- FIN CORRECCI√ìN ---


const ActivityTab: React.FC = () => {
    const { t, i18n } = useTranslation();
    const {
        activityLogs,
        loading,
        error,
        currentPage,
        totalPages,
        totalItems,
        setPage,
    } = useCustomerActivity();

    // Funci√≥n para obtener icono y color
    const getActivityVisuals = (type: ActivityType): { icon: React.ReactNode; color: string } => {
        switch (type) {
            case 'POINTS_EARNED_QR': return { icon: <IconTicket size={12} />, color: 'green' };
            case 'POINTS_EARNED_ORDER_LC': return { icon: <IconShoppingCart size={12} />, color: 'green' };
            case 'POINTS_REDEEMED_REWARD': return { icon: <IconReceipt size={12} />, color: 'blue' };
            case 'REWARD_ACQUIRED': return { icon: <IconGift size={12} />, color: 'yellow' };
            case 'REWARD_APPLIED_TO_ORDER': return { icon: <IconDiscount2 size={12} />, color: 'indigo' };
            case 'GIFT_REDEEMED': return { icon: <IconGift size={12} />, color: 'yellow' };
            case 'POINTS_ADJUSTED_ADMIN': return { icon: <IconAdjustments size={12} />, color: 'grape' };
            default: return { icon: <IconTicket size={12} />, color: 'gray' };
        }
    };

    // Funci√≥n para formatear la fecha
    const formatDate = (dateString: string) => {
        if (!dateString) return 'N/A';
        try { return new Date(dateString).toLocaleString(i18n.language, { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' }); } catch { return t('common.invalidDate'); }
    };

    // Contenido principal
    const renderContent = () => {
        if (loading && activityLogs.length === 0) { return <Group justify="center" p="lg"><Loader /></Group>; }
        if (error) { return <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{error}</Alert>; }
        if (activityLogs.length === 0) { return <Text c="dimmed" ta="center">{t('customerDashboard.activityTab.noActivity')}</Text>; }

        return (
            <Timeline active={-1} bulletSize={20} lineWidth={2}>
                {activityLogs.map((item: ActivityLogItem) => {
                    const visuals = getActivityVisuals(item.type);
                    const pointsText = item.pointsChanged !== null ? `${item.pointsChanged > 0 ? '+' : ''}${item.pointsChanged}` : null;
                    const pointsColor = item.pointsChanged === null ? 'gray' : (item.pointsChanged > 0 ? 'green' : 'red');

                    const descriptionData = item.description || '';
                    let timelineTitleCalculationResult: string | ReturnType<typeof t> = '';

                    switch(item.type) {
                        case 'POINTS_EARNED_QR':
                        case 'POINTS_EARNED_ORDER_LC':
                            timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_EARNED', { ticketNumber: descriptionData });
                            break;
                        case 'POINTS_REDEEMED_REWARD':
                        case 'REWARD_ACQUIRED':
                            timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_REDEEMED', { rewardName: descriptionData });
                            break;
                         case 'GIFT_REDEEMED':
                            timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_GIFT', { rewardName: descriptionData });
                             break;
                        case 'POINTS_ADJUSTED_ADMIN':
                            if (item.description) {
                                timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_ADJUSTED_REASON', { reason: item.description });
                            } else {
                                timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_ADJUSTED');
                            }
                            break;
                        default:
                            timelineTitleCalculationResult = item.description || t(`customerDashboard.activityTab.type_${item.type}`, item.type);
                    }

                    const finalTimelineTitle: string = String(timelineTitleCalculationResult);

                    return (
                        <Timeline.Item
                            key={item.id}
                            bullet={ <ThemeIcon size={20} variant="light" color={visuals.color} radius="xl"> {visuals.icon} </ThemeIcon> }
                            title={finalTimelineTitle}
                        >
                            <Group justify="space-between">
                                <Text c="dimmed" size="xs"> {formatDate(item.createdAt)} </Text>
                                {pointsText && ( <Badge color={pointsColor} variant="light" size="sm"> {pointsText} {t('common.points')} </Badge> )}
                            </Group>
                        </Timeline.Item>
                    );
                })}
            </Timeline>
        );
    };

    return (
        <Stack gap="lg">
            <Title order={3}>{t('customerDashboard.tabActivity')}</Title>
            <Box style={{ position: 'relative' }}>
                {loading && activityLogs.length > 0 && ( <Box style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(255,255,255,0.5)', zIndex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}> <Loader size="sm" /> </Box> )}
                {renderContent()}
            </Box>
            {totalPages > 1 && !loading && !error && ( <Group justify="center" mt="xl"> <Pagination total={totalPages} value={currentPage} onChange={setPage} disabled={loading} /> </Group> )}
            {totalItems > 0 && !loading && !error && ( <Text size="sm" c="dimmed" ta="center"> {t('customerDashboard.activityTab.totalItems', { count: totalItems })} </Text> )}
        </Stack>
    );
};

export default ActivityTab;


// ====== [196] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/OffersTab.tsx ======
// filename: frontend/src/components/customer/dashboard/tabs/OffersTab.tsx
// Version: 1.0.0 (Placeholder component for Offers & News Tab)

import React from 'react';
import { Text } from '@mantine/core';
import { useTranslation } from 'react-i18next';

// No props needed for this placeholder initially
// interface OffersTabProps {}

const OffersTab: React.FC = (/* props: OffersTabProps */) => {
    const { t } = useTranslation();

    return (
        <Text c="dimmed">
            ({t('common.upcomingFeatureTitle', 'Pr√≥ximamente')}) {t('customerDashboard.tabOffers', 'Ofertas y Noticias')}
        </Text>
        // Future: Replace with actual offers/news feed component
    );
};

export default OffersTab;

// End of File: frontend/src/components/customer/dashboard/tabs/OffersTab.tsx


// ====== [197] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/OrderDetailModal.tsx ======
// frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/OrderDetailModal.tsx
// Version 1.2.1 - Added missing `appliedLcoRewardId` property in adapter function.

import React from 'react';
import { Modal, Stack, Title, Group, Text, Divider, Button, ScrollArea } from '@mantine/core';
import { useTranslation } from 'react-i18next';
import { IconPdf, IconMail } from '@tabler/icons-react';

import OrderBillView from '../../../../../camarero/components/public/menu/order/OrderBillView';
import { PublicOrderStatusInfo } from '../../../../../camarero/types/publicOrder.types';
import { CustomerOrder } from '../../../../types/history.types';
import { OrderStatus, OrderItemStatus } from '../../../../../../shared/types/user.types';


interface OrderDetailModalProps {
    opened: boolean;
    onClose: () => void;
    order: CustomerOrder | null;
}

const OrderDetailModal: React.FC<OrderDetailModalProps> = ({ opened, onClose, order }) => {
    const { t, i18n } = useTranslation();

    if (!order) return null;

    const adaptOrderDataForBillView = (historialOrder: CustomerOrder): PublicOrderStatusInfo => {
        const totalAmount = Number(historialOrder.items.reduce((sum, item) => sum + Number(item.totalItemPrice), 0));
        const finalAmount = Number(historialOrder.finalAmount);
        
        return {
            orderId: historialOrder.id,
            orderNumber: historialOrder.orderNumber,
            orderStatus: OrderStatus.PAID, 
            tableIdentifier: null,
            orderNotes: null,
            createdAt: historialOrder.paidAt || new Date().toISOString(),
            isBillRequested: true,
            totalAmount: totalAmount,
            finalAmount: finalAmount,
            discountAmount: totalAmount - finalAmount,
            // --- CORRECCI√ìN: A√±adir la propiedad que faltaba ---
            appliedLcoRewardId: historialOrder.appliedLcoRewardId || null,
            // --- FIN CORRECCI√ìN ---
            items: historialOrder.items.map(item => ({
                id: item.itemNameSnapshot || Math.random().toString(), 
                itemNameSnapshot: item.itemNameSnapshot,
                quantity: item.quantity,
                status: OrderItemStatus.SERVED,
                priceAtPurchase: Number(item.priceAtPurchase),
                totalItemPrice: Number(item.totalItemPrice),
                selectedModifiers: item.selectedModifiers.map(mod => ({
                    optionNameSnapshot: mod.optionNameSnapshot,
                    optionPriceAdjustmentSnapshot: Number(mod.optionPriceAdjustmentSnapshot)
                }))
            }))
        };
    };

    const billData = adaptOrderDataForBillView(order);
    const formattedDate = order.paidAt ? new Date(order.paidAt).toLocaleString(i18n.language) : t('common.invalidDate');

    return (
        <Modal
            opened={opened}
            onClose={onClose}
            title={
                <Stack gap={0}>
                    <Title order={4}>{t('orderDetailModal.title')}</Title>
                    <Text size="sm" c="dimmed">#{order.orderNumber} - {formattedDate}</Text>
                </Stack>
            }
            size="lg"
            centered
            scrollAreaComponent={ScrollArea.Autosize}
        >
            <Stack>
                <OrderBillView orderData={billData} />
                
                <Divider my="sm" />

                <Group justify="flex-end">
                    <Button variant="outline" leftSection={<IconPdf size={16} />} disabled>
                        {t('orderDetailModal.downloadPdf')}
                    </Button>
                    <Button variant="outline" leftSection={<IconMail size={16} />} disabled>
                        {t('orderDetailModal.sendByEmail')}
                    </Button>
                </Group>
            </Stack>
        </Modal>
    );
};

export default OrderDetailModal;


// ====== [198] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/ProfileTab.tsx ======
// frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/ProfileTab.tsx
import React from 'react';
import { Title, Stack, Grid } from '@mantine/core';
import { useTranslation } from 'react-i18next';
import { useUserProfileData } from '../../../../hooks/useUserProfileData';
import ProfileInfoForm from './profile/ProfileInfoForm';
// La importaci√≥n de ChangePasswordForm se ha eliminado.

const ProfileTab: React.FC = () => {
    const { t } = useTranslation();
    const { userData, loading, error, refetch } = useUserProfileData();

    return (
        <Stack>
            <Title order={3}>{t('customerDashboard.tabProfile')}</Title>
            <Grid>
                {/* Hacemos que la columna ocupe todo el ancho disponible */}
                <Grid.Col span={12}>
                    <ProfileInfoForm
                        userData={userData}
                        isLoading={loading}
                        error={error}
                        onProfileUpdate={refetch}
                    />
                </Grid.Col>
                
                {/* La columna para ChangePasswordForm se ha eliminado por completo. */}
            </Grid>
        </Stack>
    );
};

export default ProfileTab;


// ====== [199] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/PurchaseHistoryTab.tsx ======
// frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/PurchaseHistoryTab.tsx
// Version 2.0.0 - Final implementation with Table and Modal integration.

import React, { useState } from 'react';
import { Stack, Title, Loader, Alert, Group, Pagination, Text, Table, ActionIcon, Tooltip } from '@mantine/core';
import { useTranslation } from 'react-i18next';
import { useDisclosure } from '@mantine/hooks';
import { IconEye } from '@tabler/icons-react';

import { useCustomerPurchaseHistory } from '../../../../hooks/useCustomerPurchaseHistory';
import { CustomerOrder } from '../../../../types/history.types';
import OrderDetailModal from './OrderDetailModal';

const PurchaseHistoryTab: React.FC = () => {
    const { t, i18n } = useTranslation();
    const {
        orders,
        loading,
        error,
        currentPage,
        totalPages,
        totalItems,
        setPage,
    } = useCustomerPurchaseHistory();

    const [selectedOrder, setSelectedOrder] = useState<CustomerOrder | null>(null);
    const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);

    const handleViewDetails = (order: CustomerOrder) => {
        setSelectedOrder(order);
        openModal();
    };

    const formatCurrency = (value: number) => {
        return value.toLocaleString(i18n.language, { style: 'currency', currency: 'EUR' });
    };

    const formatDate = (dateString: string | null) => {
        if (!dateString) return 'N/A';
        try {
            return new Date(dateString).toLocaleDateString(i18n.language, { day: '2-digit', month: 'short', year: 'numeric' });
        } catch {
            return t('common.invalidDate', 'Fecha inv√°lida');
        }
    };

    // Mapeamos los pedidos a filas de la tabla
    const rows = orders.map((order) => (
        <Table.Tr key={order.id} onClick={() => handleViewDetails(order)} style={{ cursor: 'pointer' }}>
            <Table.Td>#{order.orderNumber}</Table.Td>
            <Table.Td>{formatDate(order.paidAt)}</Table.Td>
            <Table.Td style={{ textAlign: 'right' }}>{formatCurrency(Number(order.finalAmount))}</Table.Td>
            <Table.Td style={{ textAlign: 'right' }}>
                <Tooltip label={t('orderDetailModal.viewTooltip', 'Ver Detalle')}>
                    <ActionIcon variant="subtle" onClick={(e) => { e.stopPropagation(); handleViewDetails(order); }}>
                        <IconEye size={16} />
                    </ActionIcon>
                </Tooltip>
            </Table.Td>
        </Table.Tr>
    ));

    // Funci√≥n para renderizar el contenido principal
    const renderContent = () => {
        if (loading && orders.length === 0) {
            return <Group justify="center" p="xl"><Loader /></Group>;
        }
        if (error) {
            return <Alert color="red" title="Error">{error}</Alert>;
        }
        if (orders.length === 0) {
            return <Text c="dimmed">{t('customerDashboard.historyTab.noOrders', 'A√∫n no tienes pedidos registrados.')}</Text>;
        }
        return (
            <Table.ScrollContainer minWidth={400}>
                <Table striped highlightOnHover verticalSpacing="sm">
                    <Table.Thead>
                        <Table.Tr>
                            <Table.Th>{t('orderDetailModal.headerOrder', 'N¬∫ Pedido')}</Table.Th>
                            <Table.Th>{t('orderDetailModal.headerDate', 'Fecha')}</Table.Th>
                            <Table.Th style={{ textAlign: 'right' }}>{t('orderDetailModal.headerTotal', 'Total')}</Table.Th>
                            <Table.Th style={{ textAlign: 'right' }}>{t('common.actions', 'Acciones')}</Table.Th>
                        </Table.Tr>
                    </Table.Thead>
                    <Table.Tbody>{rows}</Table.Tbody>
                </Table>
            </Table.ScrollContainer>
        );
    };

    return (
        <>
            <Stack>
                <Title order={3}>{t('customerDashboard.historyTab.title', 'Mi Historial de Pedidos')}</Title>
                
                {!loading && totalItems > 0 && (
                    <Text size="sm" c="dimmed">
                        {t('customerDashboard.historyTab.totalOrders', { count: totalItems })}
                    </Text>
                )}
                
                {renderContent()}
                
                {!loading && totalPages > 1 && (
                    <Group justify="center" mt="md">
                        <Pagination total={totalPages} value={currentPage} onChange={setPage} />
                    </Group>
                )}
            </Stack>
            
            <OrderDetailModal
                opened={modalOpened}
                onClose={closeModal}
                order={selectedOrder}
            />
        </>
    );
};

export default PurchaseHistoryTab;


// ====== [200] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/RewardsTab.tsx ======
// frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/RewardsTab.tsx
// VERSI√ìN 5.0.2 - Limpieza final de importaciones no utilizadas.

import React from 'react';
import { Box, Title, Stack, Divider, Alert } from '@mantine/core'; // 'Text' eliminado
import { IconAlertCircle } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

import RewardList from '../../RewardList';
import AvailableCouponsList from '../../AvailableCouponsList'; 
import { Reward, GrantedReward, DisplayReward } from '../../../../../../shared/types/user.types';

// --- Interfaz de Props Final y Simplificada ---
interface RewardsTabProps {
    redeemableRewards: Reward[];
    userPoints: number | undefined;
    loadingRewards: boolean;
    errorRewards: string | null;
    
    availableCoupons: GrantedReward[];
    loadingCoupons: boolean;
    errorCoupons: string | null;
    
    pendingGifts: GrantedReward[];
    loadingGifts: boolean;
    errorGifts: string | null;
}

const RewardsTab: React.FC<RewardsTabProps> = ({
    redeemableRewards, userPoints, loadingRewards, errorRewards,
    availableCoupons, loadingCoupons, errorCoupons,
    pendingGifts, loadingGifts, errorGifts,
}) => {
    const { t } = useTranslation();
    
    const giftDisplayItems: DisplayReward[] = pendingGifts.map(gr => ({
        isGift: true, id: gr.reward.id, grantedRewardId: gr.id, name_es: gr.reward.name_es, name_en: gr.reward.name_en,
        description_es: gr.reward.description_es, description_en: gr.reward.description_en, pointsCost: 0,
        imageUrl: gr.reward.imageUrl, assignedAt: gr.assignedAt,
        assignedByString: gr.assignedBy?.name || gr.assignedBy?.email || t('customerDashboard.summary.unknownAssigner'),
        type: gr.reward.type, linkedMenuItemId: gr.reward.linkedMenuItemId, 
        discountType: gr.reward.discountType, discountValue: Number(gr.reward.discountValue) || null, 
    }));
    
    const catalogDisplayItems: DisplayReward[] = redeemableRewards.map(r => ({
        isGift: false, id: r.id, name_es: r.name_es, name_en: r.name_en,
        description_es: r.description_es, description_en: r.description_en,
        pointsCost: r.pointsCost, imageUrl: r.imageUrl, type: r.type,
        linkedMenuItemId: r.linkedMenuItemId, discountType: r.discountType, 
        discountValue: Number(r.discountValue) || null,
    }));

    return (
        <Stack gap="xl">
            {pendingGifts.length > 0 && (
                 <Box>
                    <Title order={4}>{t('customerDashboard.giftsSectionTitle')}</Title>
                    <RewardList
                        rewards={giftDisplayItems}
                        loadingRewards={loadingGifts}
                        errorRewards={errorGifts}
                        userPoints={userPoints}
                        redeemingRewardId={null} // No hay acci√≥n de carga aqu√≠
                        onRedeemPoints={() => {}} // No-op
                        onRedeemGift={() => Promise.resolve()} // No-op
                    />
                </Box>
            )}

            <Box>
                <Title order={4}>{t('customerDashboard.availableCouponsTitle')}</Title>
                <AvailableCouponsList
                    coupons={availableCoupons}
                    loading={loadingCoupons}
                    error={errorCoupons}
                />
            </Box>
            
            <Divider my="xl" label={t('customerDashboard.rewardsCatalogTitle')} labelPosition="center" />

            <Box>
                {errorRewards && <Alert color="red" title={t('common.error')} icon={<IconAlertCircle />}>{errorRewards}</Alert>}
                <RewardList
                    rewards={catalogDisplayItems}
                    userPoints={userPoints}
                    loadingRewards={loadingRewards}
                    errorRewards={null}
                    redeemingRewardId={null}
                    onRedeemPoints={() => {}} // No-op, el bot√≥n ahora solo es informativo
                    onRedeemGift={() => Promise.resolve()}
                    isAcquireFlow={true}
                />
            </Box>
        </Stack>
    );
};

export default RewardsTab;


// ====== [201] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/SummaryTab.tsx ======
// frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/SummaryTab.tsx
// VERSI√ìN 2.0.1 - Limpiado: eliminadas props e importaciones no utilizadas.

import React, { useMemo } from 'react';
import {
    Stack, Grid, Paper, Title, Group, Text, Box, Image as MantineImage,
    AspectRatio, Button, Alert, Loader, Center,
    SimpleGrid, Badge
} from '@mantine/core';
// IconCoin ya no es necesario
import { IconGift, IconArrowRight, IconToolsKitchen2 } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { Link, useNavigate } from 'react-router-dom';

// Tipos
import UserInfoDisplay, { type UserInfoDisplayProps } from '../../UserInfoDisplay';
import QrValidationSection from '../../QrValidationSection';
import type { DisplayReward, UserData, TierBenefitData } from '../../../../../../shared/types/user.types';

// --- Props del Componente Simplificadas ---
interface SummaryTabProps {
    userData: UserData | null;
    loadingUser: boolean;
    errorUser: string | null;
    progressBarData: UserInfoDisplayProps['progressBarData'];
    currentTierBenefits: TierBenefitData[];
    nextTierName: string | null;
    nextTierBenefits: TierBenefitData[];
    displayRewards: DisplayReward[] | null;
    setActiveTab: (tabValue: string | null) => void;
    handleValidateQr: (token: string) => Promise<void>;
    validatingQr: boolean;
    scannerOpened: boolean;
    onOpenScanner: () => void;
    onCloseScanner: () => void;
}

const MAX_PREVIEW_ITEMS = 3;

const SummaryTab: React.FC<SummaryTabProps> = ({
    userData, loadingUser, errorUser, progressBarData, currentTierBenefits,
    nextTierName, nextTierBenefits, displayRewards,
    setActiveTab, handleValidateQr, validatingQr, scannerOpened,
    onOpenScanner, onCloseScanner
}) => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;
    const navigate = useNavigate();

    const rewardsSummary = useMemo(() => {
        const pendingGifts = displayRewards?.filter(r => r.isGift) ?? [];
        const pointsRewards = displayRewards?.filter(r => !r.isGift && r.pointsCost > 0) ?? [];
        const previewItems = [...pendingGifts, ...pointsRewards].slice(0, MAX_PREVIEW_ITEMS);
        return {
            pendingGiftsCount: pendingGifts.length,
            previewItems,
            hasAnyRewards: !!displayRewards && displayRewards.length > 0
        };
    }, [displayRewards]);
    
    const handleRewardClick = (item: DisplayReward) => {
        if (userData?.businessSlug) {
            const rewardObject = { ...item };
            delete (rewardObject as any).isGift;
            delete (rewardObject as any).grantedRewardId;
            delete (rewardObject as any).assignedAt;
            delete (rewardObject as any).assignedByString;
            navigate(`/m/${userData.businessSlug}`, { state: { rewardToApply: rewardObject, grantedRewardIdToApply: item.grantedRewardId } });
        }
    };

    if (loadingUser && !userData) {
        return <Group justify="center" p="xl"><Loader /></Group>;
    }

    return (
        <Grid gutter="xl">
            <Grid.Col span={{ base: 12, md: 7 }}>
                <Stack gap="xl">
                    <UserInfoDisplay
                        userData={userData} loadingUser={loadingUser} errorUser={errorUser}
                        progressBarData={progressBarData} benefits={currentTierBenefits}
                        nextTierName={nextTierName} nextTierBenefits={nextTierBenefits}
                    />
                    <QrValidationSection
                        onValidate={handleValidateQr} isValidating={validatingQr}
                        scannerOpened={scannerOpened} onOpenScanner={onOpenScanner} onCloseScanner={onCloseScanner}
                    />
                </Stack>
            </Grid.Col>
            <Grid.Col span={{ base: 12, md: 5 }}>
                <Stack gap="xl" style={{ height: '100%' }}>
                    {userData?.isCamareroActive && userData?.businessSlug && (
                        <Paper withBorder p="lg" radius="md" shadow="sm">
                            <Group justify="space-between" align="center">
                                <Stack gap={0} style={{ flex: 1, minWidth: 0 }}>
                                    <Text fw={500} size="lg" truncate>{userData.businessName ? t('customerDashboard.summary.viewMenuFor', { businessName: userData.businessName }) : t('customerDashboard.summary.viewMenuDefaultTitle')}</Text>
                                    <Text size="sm" c="dimmed" lineClamp={2}>{t('customerDashboard.summary.viewMenuSubtitle')}</Text>
                                </Stack>
                                <Button component={Link} to={`/m/${userData.businessSlug}`} leftSection={<IconToolsKitchen2 size={18} />} variant="gradient" gradient={{ from: 'teal', to: 'lime', deg: 105 }} size="sm" style={{ flexShrink: 0 }}>
                                    {t('customerDashboard.summary.viewMenuButton')}
                                </Button>
                            </Group>
                        </Paper>
                    )}

                    {userData?.isLoyaltyCoreActive && (
                        <Paper shadow="sm" p="lg" withBorder radius="md" style={{ flexGrow: 1, display: 'flex', flexDirection: 'column' }}>
                            <Stack gap="lg" style={{ flexGrow: 1 }}>
                                <Title order={4}>{rewardsSummary.pendingGiftsCount > 0 ? t('customerDashboard.summary.giftsAndRewardsTitle') : t('customerDashboard.summary.rewardsTitle')}</Title>
                                {rewardsSummary.pendingGiftsCount > 0 && (<Alert color="yellow" icon={<IconGift />} title={t('customerDashboard.summary.pendingGifts', { count: rewardsSummary.pendingGiftsCount })} variant='light' radius="md">{t('customerDashboard.summary.pendingGiftsDesc')}</Alert>)}
                                {rewardsSummary.previewItems.length > 0 ? (
                                    <SimpleGrid cols={MAX_PREVIEW_ITEMS === 3 ? 3 : 2} spacing="sm" verticalSpacing="md">
                                        {rewardsSummary.previewItems.map(item => {
                                            const displayName = (currentLanguage === 'es' ? item.name_es : item.name_en) || item.name_es || item.name_en || t('common.nameNotAvailable');
                                            const isAffordable = item.isGift || (userData?.points !== undefined && userData.points >= item.pointsCost);
                                            return (
                                                <Stack key={item.id + (item.isGift ? '-gift' : '-reward')} gap={4} align="center" style={{ cursor: isAffordable ? 'pointer' : 'default', opacity: isAffordable ? 1 : 0.6 }} onClick={() => isAffordable && handleRewardClick(item)}>
                                                    <AspectRatio ratio={1 / 1} style={{ width: '80%', maxWidth: '80px' }}>
                                                        <MantineImage src={item.imageUrl || '/placeholder-reward.png'} alt={displayName} radius="sm" fallbackSrc="/placeholder-reward.png" />
                                                    </AspectRatio>
                                                    <Text size="xs" ta="center" lineClamp={2} style={{ height: '2.4em', fontWeight: 500 }}>{displayName}</Text>
                                                    {item.isGift ? (<Badge size="xs" color="lime" variant='light' mt={2}>{t('customerDashboard.giftFree')}</Badge>) : (<Text size="xs" fw={500} mt={2}>{item.pointsCost} {t('common.points')}</Text>)}
                                                </Stack>
                                            );
                                        })}
                                    </SimpleGrid>
                                ) : (<Center style={{flexGrow: 1}}><Text c="dimmed">{t('customerDashboard.summary.noRewardsInfo')}</Text></Center>)}
                                
                                <Box mt="auto">
                                    {rewardsSummary.hasAnyRewards && (
                                        <Button variant="light" fullWidth mt="sm" onClick={() => setActiveTab('rewards')} radius="lg" rightSection={<IconArrowRight size={16} />}>
                                            {t('customerDashboard.summary.viewAllButtonShort')}
                                        </Button>
                                    )}
                                </Box>
                            </Stack>
                        </Paper>
                    )}
                </Stack>
            </Grid.Col>
        </Grid>
    );
};

export default SummaryTab;


// ====== [202] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/profile/ProfileInfoForm.tsx ======
// frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/profile/ProfileInfoForm.tsx
import React, { useEffect, useState, useRef, SyntheticEvent } from 'react';
import {
    Paper, Title, Stack, TextInput, Button, Group, Alert, LoadingOverlay, Box,
    Text as MantineText,
    Image as MantineImage
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
// --- CORRECCI√ìN: Se elimina IconPhoto ---
import { IconDeviceFloppy, IconCheck, IconX, IconAlertCircle, IconCrop, IconCameraRotate } from '@tabler/icons-react';

import { UserData } from '../../../../../../../shared/types/user.types';
import axiosInstance from '../../../../../../../shared/services/axiosInstance';
import { canvasPreview, canvasToBlob } from '../../../../../../../shared/components/utils/canvasPreview';
import ReactCrop, {
    centerCrop,
    makeAspectCrop,
    type Crop,
    type PixelCrop,
} from 'react-image-crop';
import 'react-image-crop/dist/ReactCrop.css';


const profileFormSchema = (t: (key: string) => string) => z.object({
  name: z.string().optional(),
  phone: z.string().min(1, { message: t('common.requiredField') })
           .regex(/^\+\d{9,15}$/, { message: t('registerPage.errorPhoneFormat') }),
});
type ProfileFormValues = z.infer<ReturnType<typeof profileFormSchema>>;

interface ProfileInfoFormProps {
    userData: UserData | null;
    isLoading: boolean;
    error: string | null;
    onProfileUpdate: () => void;
}

const ProfileInfoForm: React.FC<ProfileInfoFormProps> = ({ userData, isLoading, error, onProfileUpdate }) => {
    const { t } = useTranslation();
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [imageBlob, setImageBlob] = useState<Blob | null>(null);
    const [previewImageUrl, setPreviewImageUrl] = useState<string | null>(null);

    const form = useForm<ProfileFormValues>({
        initialValues: { name: '', phone: '' },
        validate: zodResolver(profileFormSchema(t)),
    });

    useEffect(() => {
        if (userData) {
            form.setValues({
                name: userData.name || '',
                phone: userData.phone || '',
            });
            setPreviewImageUrl(userData.imageUrl || null);
            form.resetDirty();
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [userData]);
    
    const hasUnsavedChanges = form.isDirty() || imageBlob !== null;

    const handleSubmit = async (values: ProfileFormValues) => {
        setIsSubmitting(true);
        try {
            const formData = new FormData();
            
            if (form.isDirty('name')) formData.append('name', values.name || '');
            if (form.isDirty('phone')) formData.append('phone', values.phone || '');
            if (imageBlob) formData.append('profileImage', imageBlob, 'profile-image.jpg');

            if (!hasUnsavedChanges) {
                notifications.show({ title: t('common.info'), message: t('profileForm.noChanges'), color: 'blue' });
                setIsSubmitting(false);
                return;
            }
            
            await axiosInstance.put('/profile', formData, {
                headers: { 'Content-Type': 'multipart/form-data' },
            });

            notifications.show({ title: t('common.success'), message: t('profileForm.updateSuccess'), color: 'green', icon: <IconCheck /> });
            onProfileUpdate();
            setImageBlob(null);

        } catch (err: any) {
            const errorMsg = err.response?.data?.message || t('profileForm.updateError');
            notifications.show({ title: t('common.error'), message: errorMsg, color: 'red', icon: <IconX /> });
        } finally {
            setIsSubmitting(false);
        }
    };
    
    return (
        <Paper withBorder p="lg" radius="md" style={{ position: 'relative' }}>
            <LoadingOverlay visible={isLoading || isSubmitting} />
            <Title order={4}>Informaci√≥n Personal</Title>
            <MantineText size="sm" c="dimmed" mb="lg">Actualiza tus datos personales.</MantineText>

            {error && <Alert color="red" icon={<IconAlertCircle />}>{error}</Alert>}
            
            {userData && (
                <form onSubmit={form.onSubmit(handleSubmit)}>
                    <Stack>
                        <Box mx="auto" w={200}>
                            <ProfileImageUploader
                                currentImageUrl={previewImageUrl}
                                onCropComplete={(blob, previewUrl) => {
                                    setImageBlob(blob);
                                    setPreviewImageUrl(previewUrl);
                                }}
                                disabled={isSubmitting}
                            />
                        </Box>
                        
                        <TextInput label="Email" value={userData.email} disabled />
                        <TextInput label="Nombre Completo" placeholder="Tu nombre y apellidos" disabled={isSubmitting} {...form.getInputProps('name')} />
                        <TextInput label="Tel√©fono" placeholder="+34612345678" required disabled={isSubmitting} {...form.getInputProps('phone')} />

                        <Group justify="flex-end" mt="md">
                            <Button
                                type="submit"
                                loading={isSubmitting}
                                disabled={!hasUnsavedChanges || !form.isValid()}
                                leftSection={<IconDeviceFloppy size={18} />}
                            >
                                {t('common.saveChanges')}
                            </Button>
                        </Group>
                    </Stack>
                </form>
            )}
        </Paper>
    );
};

// Componente de subida/recorte espec√≠fico para este formulario
const ProfileImageUploader: React.FC<{
    currentImageUrl: string | null;
    onCropComplete: (blob: Blob | null, previewUrl: string | null) => void;
    disabled?: boolean;
}> = (props) => {
    const { t } = useTranslation();
    const imgRef = useRef<HTMLImageElement>(null);
    const [imgSrc, setImgSrc] = useState('');
    const [crop, setCrop] = useState<Crop>();
    const [completedCrop, setCompletedCrop] = useState<PixelCrop>();
    const [isConfirmingCrop, setIsConfirmingCrop] = useState(false);

    const onFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        if (e.target.files && e.target.files.length > 0) {
            setCrop(undefined);
            props.onCropComplete(null, props.currentImageUrl);
            const reader = new FileReader();
            reader.addEventListener('load', () => setImgSrc(reader.result?.toString() || ''));
            reader.readAsDataURL(e.target.files[0]);
        }
    };

    const onImageLoad = (e: SyntheticEvent<HTMLImageElement>) => {
        const { width, height, naturalWidth, naturalHeight } = e.currentTarget;
        const percentCrop = centerCrop(makeAspectCrop({ unit: '%', width: 100 }, 1, width, height), width, height);
        setCrop(percentCrop);
        if (naturalWidth && naturalHeight) {
            const pixelCrop: PixelCrop = {
                unit: 'px', x: (percentCrop.x / 100) * naturalWidth,
                y: (percentCrop.y / 100) * naturalHeight,
                width: (percentCrop.width / 100) * naturalWidth,
                height: (percentCrop.height / 100) * naturalHeight,
            };
            setCompletedCrop(pixelCrop);
        }
    };

    const handleConfirmCrop = async () => {
        if (!imgRef.current || !completedCrop) return;
        setIsConfirmingCrop(true);
        try {
            const canvas = document.createElement('canvas');
            canvasPreview(imgRef.current, canvas, completedCrop, 1, 0, 150, 150);
            const blob = await canvasToBlob(canvas, 'image/jpeg', 0.9);
            const previewUrl = blob ? URL.createObjectURL(blob) : null;
            props.onCropComplete(blob, previewUrl);
            setImgSrc('');
        } catch (e) {
            console.error("Error creating blob from canvas", e);
        } finally {
            setIsConfirmingCrop(false);
        }
    };

    return (
        <Stack align="center">
            {imgSrc ? (
                <>
                    <ReactCrop
                        crop={crop} onChange={(_, percentCrop) => setCrop(percentCrop)} onComplete={(c) => setCompletedCrop(c)}
                        aspect={1} minWidth={50} minHeight={50} circularCrop >
                        <img ref={imgRef} alt="Crop me" src={imgSrc} onLoad={onImageLoad} style={{ maxHeight: '300px' }} />
                    </ReactCrop>
                    <Group justify="center" mt="xs">
                        <Button
                            size="xs" variant="outline" color="gray"
                            onClick={() => setImgSrc('')}
                            leftSection={<IconCameraRotate size={14}/>} disabled={props.disabled || isConfirmingCrop} >
                            {t('common.cancel')}
                        </Button>
                        <Button
                            size="xs" onClick={handleConfirmCrop}
                            leftSection={<IconCrop size={14} />} loading={isConfirmingCrop} disabled={!completedCrop || props.disabled} >
                            {t('component.rewardForm.confirmCropButton')}
                        </Button>
                    </Group>
                </>
            ) : (
                <>
                    <MantineImage
                        radius="50%" h={150} w={150} fit="cover"
                        src={props.currentImageUrl || '/default-avatar.png'}
                        fallbackSrc="/default-avatar.png"
                    />
                    <input type="file" accept="image/*" onChange={onFileChange} style={{ marginTop: '10px' }} disabled={props.disabled} />
                </>
            )}
        </Stack>
    );
};

export default ProfileInfoForm;


// ====== [203] frontend/src/modules/loyalpyme/hooks/useAdminCustomersData.ts ======
// filename: frontend/src/hooks/useAdminCustomersData.ts
// Version: 1.1.3 (Fix character encoding)

import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';

// --- Tipos necesarios (Exportados) ---
// TODO: Mover estas interfaces a archivos compartidos (e.g., src/types/)
export interface Customer { id: string; name?: string | null; email: string; points: number; currentTier?: { id: string; name: string; level?: number; } | null; createdAt: string; isFavorite?: boolean; isActive?: boolean; }
interface CustomerApiResponse { items: Customer[]; totalPages: number; currentPage: number; totalItems: number; }
export type SortColumn = 'name' | 'email' | 'points' | 'createdAt' | 'isActive' | 'isFavorite' | 'currentTier.level';
export interface SortStatus { column: SortColumn; direction: 'asc' | 'desc'; }
export interface CustomerFilters {
    search?: string;
    isFavorite?: boolean;
    isActive?: boolean;
    tierId?: string;
}

// Interfaz para el resultado que el hook devolver√° (Exportada)
export interface UseAdminCustomersDataResult {
    customers: Customer[];
    loading: boolean;
    error: string | null;
    totalPages: number;
    currentPage: number;
    totalItems: number;
    searchTerm: string;
    sortStatus: SortStatus;
    filters: CustomerFilters;
    setPage: (page: number) => void;
    setSearchTerm: (term: string) => void;
    setSortStatus: (status: SortStatus) => void;
    setFilters: (filters: Partial<CustomerFilters>) => void;
    refetch: () => Promise<void>;
}
// --- Fin Tipos ---


const useAdminCustomersData = (): UseAdminCustomersDataResult => {
    // Estados internos
    const [customers, setCustomers] = useState<Customer[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [activePage, setPage] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const [totalItems, setTotalItems] = useState(0);
    const [searchTerm, setSearchTerm] = useState<string>('');
    const [sortStatus, setSortStatusState] = useState<SortStatus>({ column: 'createdAt', direction: 'desc' });
    const [filters, setFiltersState] = useState<CustomerFilters>({});

    // Funci√≥n de carga de datos
    const fetchCustomers = useCallback(async () => {
        setLoading(true);
        setError(null);
        console.log(`[useAdminCustomersData] Fetching customers: Page=${activePage}, Search='${searchTerm}', SortBy=${sortStatus.column}, SortDir=${sortStatus.direction}, Filters=`, filters);
        try {
            const params = new URLSearchParams({
                page: activePage.toString(),
                limit: '10', // L√≠mite fijo por ahora
                sortBy: sortStatus.column,
                sortDir: sortStatus.direction
            });
            // A√±adir filtros a los par√°metros
            if (searchTerm) params.append('search', searchTerm);
            if (filters.isFavorite !== undefined) params.append('isFavorite', filters.isFavorite.toString());
            if (filters.isActive !== undefined) params.append('isActive', filters.isActive.toString());
            if (filters.tierId) { params.append('tierId', filters.tierId); }

            const response = await axiosInstance.get<CustomerApiResponse>(`/admin/customers?${params.toString()}`);
            const apiData = response.data;

            if (apiData && Array.isArray(apiData.items) && typeof apiData.currentPage === 'number' && typeof apiData.totalPages === 'number' && typeof apiData.totalItems === 'number') {
                setCustomers(apiData.items);
                setTotalPages(apiData.totalPages);
                setTotalItems(apiData.totalItems);
                // Ajustar p√°gina activa si es necesario
                if(apiData.currentPage !== activePage && apiData.currentPage <= apiData.totalPages) { setPage(apiData.currentPage); }
                else if (activePage > apiData.totalPages && apiData.totalPages > 0) { setPage(apiData.totalPages); }
                else if (apiData.totalPages === 0 && activePage !== 1) { setPage(1); }

                console.log(`[useAdminCustomersData] Fetched ${apiData.items.length} customers. Total: ${apiData.totalItems}, Pages: ${apiData.totalPages}. Current page state: ${activePage}`);
            } else {
                console.error("[useAdminCustomersData] Invalid paginated response structure:", apiData);
                throw new Error("La respuesta del servidor no tiene el formato esperado.");
            }
        } catch (err: any) {
            console.error("[useAdminCustomersData] Error fetching customers:", err);
            const errorMsg = err.response?.data?.message || err.message || 'Error desconocido al cargar clientes.';
            setError(errorMsg);
            setCustomers([]); setTotalPages(1); setTotalItems(0); setPage(1); // Resetear todo en error
        } finally {
            setLoading(false);
        }
    }, [activePage, searchTerm, sortStatus, filters]); // Dependencias correctas

    // Efecto para Carga Inicial y Recarga por cambio de dependencias
    useEffect(() => {
        fetchCustomers();
    }, [fetchCustomers]);

    // Efecto para resetear p√°gina SOLO al cambiar filtros/b√∫squeda (y si no est√°bamos ya en p√°gina 1)
     useEffect(() => {
        if (activePage !== 1) {
             console.log("[useAdminCustomersData] Search or filters changed, resetting page to 1.");
             setPage(1);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [searchTerm, filters]); // No incluir activePage aqu√≠ para evitar bucle


    // Funciones Setters expuestas
    const handleSetPage = useCallback((page: number) => { setPage(page); }, []);
    const handleSetSearchTerm = useCallback((term: string) => { setSearchTerm(term); }, []);
    const handleSetSortStatus = useCallback((status: SortStatus) => { setSortStatusState(status); }, []);
    const handleSetFilters = useCallback((newFilters: Partial<CustomerFilters>) => {
        setFiltersState(prevFilters => {
            const updatedFilters = { ...prevFilters };
             for (const key in newFilters) {
                if (Object.prototype.hasOwnProperty.call(newFilters, key)) {
                    const filterKey = key as keyof CustomerFilters;
                    const value = newFilters[filterKey];
                    // Si el valor es undefined o string vac√≠o, quitar filtro
                    if (value === undefined || value === '') {
                        delete updatedFilters[filterKey];
                    } else {
                        // Validar tipo antes de asignar
                        if ((filterKey === 'isActive' || filterKey === 'isFavorite') && typeof value === 'boolean') {
                            updatedFilters[filterKey] = value;
                        } else if ((filterKey === 'search' || filterKey === 'tierId') && typeof value === 'string') {
                            updatedFilters[filterKey] = value;
                        } else { console.warn(`[useAdminCustomersData] Ignorando filtro con tipo inesperado para key '${filterKey}':`, value); }
                    }
                }
            }
            console.log('[useAdminCustomersData] Filters updated:', updatedFilters);
            return updatedFilters;
        });
    }, []);

    const refetch = useCallback(async () => { await fetchCustomers(); }, [fetchCustomers]);

    // Retorno del hook
    return {
        customers, loading, error, totalPages,
        currentPage: activePage, totalItems, searchTerm, sortStatus, filters,
        setPage: handleSetPage, setSearchTerm: handleSetSearchTerm,
        setSortStatus: handleSetSortStatus, setFilters: handleSetFilters, refetch,
    };
};

export default useAdminCustomersData;

// End of File: frontend/src/hooks/useAdminCustomersData.ts


// ====== [204] frontend/src/modules/loyalpyme/hooks/useAdminOverviewStats.ts ======
// filename: frontend/src/hooks/useAdminOverviewStats.ts
// Version: 1.0.1 (Add console.log inside calculateTrend for debugging)

import { useState, useEffect, useCallback, useMemo } from 'react';
import { getAdminDashboardStats, AdminOverviewStats } from '../services/adminService';

type TrendDirection = 'up' | 'down' | 'neutral';
interface TrendResult {
    trendValue: string | null;
    trendDirection: TrendDirection | null;
}
interface UseAdminOverviewStatsReturn {
    statsData: AdminOverviewStats | null;
    loadingStats: boolean;
    errorStats: string | null;
    newCustomersTrend: TrendResult;
    pointsIssuedTrend: TrendResult;
    rewardsRedeemedTrend: TrendResult;
    refetchStats: () => void;
}

export const useAdminOverviewStats = (): UseAdminOverviewStatsReturn => {
    const [statsData, setStatsData] = useState<AdminOverviewStats | null>(null);
    const [loadingStats, setLoadingStats] = useState<boolean>(true);
    const [errorStats, setErrorStats] = useState<string | null>(null);

    const fetchStats = useCallback(async () => {
        setLoadingStats(true);
        setErrorStats(null);
        console.log("[useAdminOverviewStats] Fetching stats...");
        try {
            const data = await getAdminDashboardStats();
            setStatsData(data);
        } catch (err: any) {
            console.error("[useAdminOverviewStats] Error fetching stats:", err);
            setErrorStats(err.message || 'No se pudieron cargar las estad√≠sticas.');
        } finally {
            setLoadingStats(false);
            console.log("[useAdminOverviewStats] Stats fetch finished.");
        }
    }, []);

    useEffect(() => {
        fetchStats();
    }, [fetchStats]);

    const calculateTrend = useMemo(() => {
        // A√±adimos un identificador para saber qu√© m√©trica se est√° calculando
        return (metricName: string, current: number | null | undefined, previous: number | null | undefined): TrendResult => {
            const currentVal = current ?? 0;
            const previousVal = previous ?? 0;

            // --- DEBUG LOGGING ---
            console.log(`[calculateTrend - ${metricName}] Inputs: current=${currentVal}, previous=${previousVal}`);
            // --- FIN DEBUG LOGGING ---

            if (previousVal === 0) {
                if (currentVal > 0) {
                    // --- DEBUG LOGGING ---
                    console.log(`[calculateTrend - ${metricName}] Result: '+' (Previous was 0)`);
                    // --- FIN DEBUG LOGGING ---
                    return { trendValue: '+', trendDirection: 'up' };
                }
                // --- DEBUG LOGGING ---
                 console.log(`[calculateTrend - ${metricName}] Result: 'N/A' (Both 0 or current <= 0)`);
                 // --- FIN DEBUG LOGGING ---
                return { trendValue: 'N/A', trendDirection: 'neutral' };
            }

            const percentageChange = ((currentVal - previousVal) / previousVal) * 100;
            // --- DEBUG LOGGING ---
            console.log(`[calculateTrend - ${metricName}] Percentage Change: ${percentageChange}`);
            // --- FIN DEBUG LOGGING ---

            if (isNaN(percentageChange) || !isFinite(percentageChange)) {
                 console.warn(`[calculateTrend - ${metricName}] Invalid percentageChange calculated.`);
                return { trendValue: 'Error', trendDirection: 'neutral' };
            }

            let direction: TrendDirection = 'neutral';
            const threshold = 0.1;
            if (percentageChange > threshold) direction = 'up';
            else if (percentageChange < -threshold) direction = 'down';

            const formattedValue = `${percentageChange >= 0 ? '+' : ''}${percentageChange.toFixed(1)}%`;
            // --- DEBUG LOGGING ---
            console.log(`[calculateTrend - ${metricName}] Result: value='${formattedValue}', direction='${direction}'`);
            // --- FIN DEBUG LOGGING ---
            return { trendValue: formattedValue, trendDirection: direction };
        };
    }, []);

    const newCustomersTrend = useMemo(() => {
        if (!statsData) return { trendValue: null, trendDirection: null };
        // Pasar nombre de m√©trica para logs
        return calculateTrend('NewCustomers', statsData.newCustomersLast7Days, statsData.newCustomersPrevious7Days);
    }, [statsData, calculateTrend]);

    const pointsIssuedTrend = useMemo(() => {
        if (!statsData) return { trendValue: null, trendDirection: null };
         // Pasar nombre de m√©trica para logs
        return calculateTrend('PointsIssued', statsData.pointsIssuedLast7Days, statsData.pointsIssuedPrevious7Days);
    }, [statsData, calculateTrend]);

    const rewardsRedeemedTrend = useMemo(() => {
        if (!statsData) return { trendValue: null, trendDirection: null };
         // Pasar nombre de m√©trica para logs
        return calculateTrend('RewardsRedeemed', statsData.rewardsRedeemedLast7Days, statsData.rewardsRedeemedPrevious7Days);
    }, [statsData, calculateTrend]);

    return {
        statsData,
        loadingStats,
        errorStats,
        newCustomersTrend,
        pointsIssuedTrend,
        rewardsRedeemedTrend,
        refetchStats: fetchStats
    };
};

// End of File: frontend/src/hooks/useAdminOverviewStats.ts


// ====== [205] frontend/src/modules/loyalpyme/hooks/useAdminRewards.ts ======
// filename: frontend/src/hooks/useAdminRewards.ts
// Version: 1.2.0 (Ensure correct Reward type with i18n fields is used)

import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';

// --- IMPORTANTE: Asegurarse de importar Reward desde la ubicaci√≥n correcta ---
import { Reward } from '../../../shared/types/user.types'; // Debe importar la interfaz Reward actualizada
// --- FIN IMPORTANTE ---


// Tipos (sin cambios en la definici√≥n, pero ahora usan la Reward importada)
export type ActionLoading = { type: 'toggle' | 'delete'; id: string } | null;

export interface UseAdminRewardsReturn {
    rewards: Reward[]; // <-- Usa la interfaz Reward importada (que ahora tiene name_es/en)
    loading: boolean;
    error: string | null;
    actionLoading: ActionLoading;
    fetchRewards: () => Promise<void>;
    handleToggleActive: (rewardId: string, currentIsActive: boolean) => Promise<void>;
    handleDeleteReward: (rewardId: string, rewardName: string) => Promise<void>; // rewardName puede ser ahora name_es o name_en
}


export const useAdminRewards = (): UseAdminRewardsReturn => {
    // --- Estado interno usa la interfaz Reward importada ---
    const [rewards, setRewards] = useState<Reward[]>([]);
    // --- Fin Estado ---
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [actionLoading, setActionLoading] = useState<ActionLoading>(null);

    // Funciones (sin cambios en la l√≥gica interna, pero ahora trabajan con el tipo Reward correcto)
    const fetchRewards = useCallback(async () => {
        if (rewards.length === 0 || !loading) setLoading(true); // Ajuste para mostrar loading en refetch
        setError(null);
        console.log("[useAdminRewards] Fetching rewards...");
        try {
            // La llamada espera un array de objetos Reward (con name_es/en)
            const response = await axiosInstance.get<Reward[]>('/rewards'); // Usa el tipo Reward correcto
            console.log("[useAdminRewards] Raw rewards data received:", response.data);
            setRewards(response.data ?? []);
        } catch (err: any) {
           console.error('[useAdminRewards] Error fetching rewards:', err);
           const message = err.response?.data?.message || err.message || 'Error desconocido al cargar recompensas.';
           setError(message);
           // Solo mostrar notificaci√≥n si ya hab√≠a datos y falla el refetch
           if (rewards.length > 0) {
                notifications.show({ title: 'Error al Refrescar', message, color: 'red' });
           }
         } finally {
            setLoading(false);
            console.log("[useAdminRewards] Fetch rewards finished.");
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loading]); // Dependencia ajustada para permitir refetch

    useEffect(() => {
        fetchRewards();
    }, [fetchRewards]); // fetchRewards ahora tiene dependencias correctas

    const handleToggleActive = useCallback(async (rewardId: string, currentIsActive: boolean) => {
         setActionLoading({ type: 'toggle', id: rewardId });
        const newIsActive = !currentIsActive;
        const actionText = newIsActive ? 'activada' : 'desactivada'; // TODO: i18n
        try {
            await axiosInstance.patch(`/rewards/${rewardId}`, { isActive: newIsActive });
            // Actualizaci√≥n optimista del estado
            setRewards((prevRewards) =>
                prevRewards.map((r) =>
                    r.id === rewardId ? { ...r, isActive: newIsActive, updatedAt: new Date().toISOString() } : r
                )
            );
            notifications.show({
                 title: `Recompensa ${actionText}`, // TODO: i18n
                message: `La recompensa se ha ${actionText} correctamente.`, // TODO: i18n
                color: 'green',
                autoClose: 4000
            });
        } catch (err: any) {
             console.error('Error toggling reward active state:', err);
             const message = `Error al ${actionText} la recompensa: ${err.response?.data?.message || err.message || 'Error desconocido'}`; // TODO: i18n
             notifications.show({
                title: 'Error al Actualizar Estado', message, color: 'red', // TODO: i18n
                autoClose: 6000
            });
        } finally {
            setActionLoading(null);
        }
    }, []);

    const handleDeleteReward = useCallback(async (rewardId: string, rewardName: string) => { // rewardName es ahora name_es o name_en
        setActionLoading({ type: 'delete', id: rewardId });
        try {
            await axiosInstance.delete(`/rewards/${rewardId}`);
            setRewards((prevRewards) => prevRewards.filter((r) => r.id !== rewardId) );
             notifications.show({
                title: 'Recompensa Eliminada', // TODO: i18n
                message: `La recompensa "${rewardName}" ha sido eliminada.`, // Usa el nombre pasado
                color: 'green',
                autoClose: 4000
            });
         } catch (err: any) {
            console.error('Error deleting reward:', err);
            const apiMessage = err.response?.data?.message || err.message || 'Error desconocido';
            let notifyMessage = `Error al eliminar "${rewardName}": ${apiMessage}`; // TODO: i18n
            if (err.response?.status === 404 || apiMessage.includes('no encontrada')) {
                 notifyMessage = `No se encontr√≥ la recompensa "${rewardName}" (quiz√°s ya fue eliminada).`; // TODO: i18n
            }
             if (err.response?.status === 409 || apiMessage.includes('siendo utilizada')) {
                notifyMessage = `No se puede eliminar "${rewardName}" porque est√° en uso.`; // TODO: i18n
            }
            notifications.show({
                title: 'Error al Eliminar', message: notifyMessage, color: 'red', // TODO: i18n
                autoClose: 6000
            });
        } finally {
            setActionLoading(null);
        }
    }, []);

    // Retorno del Hook (sin cambios)
    return {
        rewards,
        loading,
        error,
        actionLoading,
        fetchRewards,
        handleToggleActive,
        handleDeleteReward
    };
};

// End of File: frontend/src/hooks/useAdminRewards.ts


// ====== [206] frontend/src/modules/loyalpyme/hooks/useCustomerActivity.ts ======
// filename: frontend/src/hooks/useCustomerActivity.ts
import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { ActivityLogItem, PaginatedActivityResponse } from '../../../shared/types/user.types'; // Importar tipos definidos

// Definir el tipo de retorno del hook
export interface UseCustomerActivityResult {
    activityLogs: ActivityLogItem[];
    loading: boolean;
    error: string | null;
    currentPage: number;
    totalPages: number;
    totalItems: number;
    setPage: (page: number) => void; // Funci√≥n para cambiar de p√°gina
    refetch: () => void; // Funci√≥n para recargar la p√°gina actual
}

const ITEMS_PER_PAGE = 15; // N√∫mero de items por p√°gina

export const useCustomerActivity = (): UseCustomerActivityResult => {
    // Estados del hook
    const [activityLogs, setActivityLogs] = useState<ActivityLogItem[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [currentPage, setCurrentPage] = useState<number>(1);
    const [totalPages, setTotalPages] = useState<number>(1);
    const [totalItems, setTotalItems] = useState<number>(0);

    // Funci√≥n para obtener los datos de una p√°gina espec√≠fica
    const fetchActivity = useCallback(async (pageToFetch: number) => {
        setLoading(true);
        // No limpiar el error aqu√≠ necesariamente, podr√≠a ser √∫til verlo mientras carga
        // setError(null);
        console.log(`[useCustomerActivity] Fetching page ${pageToFetch}...`);

        try {
            const response = await axiosInstance.get<PaginatedActivityResponse>('/customer/activity', {
                params: {
                    page: pageToFetch,
                    limit: ITEMS_PER_PAGE,
                },
            });

            const data = response.data;
            if (data && Array.isArray(data.logs)) {
                setActivityLogs(data.logs);
                setTotalPages(data.totalPages ?? 1);
                setTotalItems(data.totalItems ?? 0);
                setCurrentPage(data.currentPage ?? pageToFetch); // Usar la p√°gina devuelta por la API si existe
                setError(null); // Limpiar error en caso de √©xito
                console.log(`[useCustomerActivity] Fetch successful for page ${pageToFetch}. Total Items: ${data.totalItems}`);
            } else {
                console.error('[useCustomerActivity] Invalid response structure:', data);
                throw new Error('La respuesta del servidor para el historial no tiene el formato esperado.');
            }

        } catch (err: any) {
            console.error(`[useCustomerActivity] Error fetching activity page ${pageToFetch}:`, err);
            const errorMsg = err.response?.data?.message || err.message || 'Error desconocido al cargar el historial.';
            setError(errorMsg);
            // No limpiar los logs existentes en caso de error de fetch, podr√≠a ser confuso
            // setActivityLogs([]);
            // setTotalPages(1);
            // setTotalItems(0);
            // setCurrentPage(1);
        } finally {
            setLoading(false);
            console.log(`[useCustomerActivity] Fetch process finished for page ${pageToFetch}.`);
        }
    }, []); // No necesita dependencias si usa 'currentPage' del estado

    // Funci√≥n para establecer la p√°gina (disparar√° el useEffect)
    const setPage = useCallback((page: number) => {
        // Validar que la p√°gina est√© dentro de los l√≠mites si ya conocemos totalPages
        if (page > 0 && (totalPages === 1 || page <= totalPages)) {
             if(page !== currentPage){ // Solo actualiza si la p√°gina es diferente
                console.log(`[useCustomerActivity] Setting page to: ${page}`);
                setCurrentPage(page);
             }
        } else {
             console.warn(`[useCustomerActivity] Attempted to set invalid page: ${page} (Total: ${totalPages})`);
        }
    }, [totalPages, currentPage]); // Depende de totalPages y currentPage

    // Efecto para la carga inicial
    useEffect(() => {
        console.log('[useCustomerActivity] Initial fetch triggered.');
        fetchActivity(1); // Cargar p√°gina 1 al montar
    }, [fetchActivity]);

    // Efecto para recargar cuando cambia la p√°gina (excepto en carga inicial)
    useEffect(() => {
        // Evitar recarga si es la carga inicial (manejada por el otro useEffect)
        // o si la p√°gina no es v√°lida
        if (currentPage !== 1 && currentPage > 0 && (totalPages === 1 || currentPage <= totalPages)) {
             console.log(`[useCustomerActivity] Page changed to ${currentPage}, refetching...`);
            fetchActivity(currentPage);
        }
    }, [currentPage, fetchActivity, totalPages]); // Depende de currentPage

    // Funci√≥n para recargar la p√°gina actual
    const refetch = useCallback(() => {
        console.log(`[useCustomerActivity] Manual refetch triggered for page ${currentPage}.`);
        fetchActivity(currentPage);
    }, [fetchActivity, currentPage]);


    // Retornar el estado y las funciones
    return {
        activityLogs,
        loading,
        error,
        currentPage,
        totalPages,
        totalItems,
        setPage,
        refetch
    };
};


// ====== [207] frontend/src/modules/loyalpyme/hooks/useCustomerPurchaseHistory.ts ======
// frontend/src/modules/loyalpyme/hooks/useCustomerPurchaseHistory.ts
import { useState, useEffect, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import axiosInstance from '../../../shared/services/axiosInstance';
import { CustomerOrder, PaginatedOrdersResponse } from '../types/history.types';

// Interfaz para el valor de retorno del hook
export interface UseCustomerPurchaseHistoryResult {
    orders: CustomerOrder[];
    loading: boolean;
    error: string | null;
    currentPage: number;
    totalPages: number;
    totalItems: number;
    setPage: (page: number) => void;
    refetch: () => void;
}

const ITEMS_PER_PAGE = 10; // 10 pedidos por p√°gina

export const useCustomerPurchaseHistory = (): UseCustomerPurchaseHistoryResult => {
    const { t } = useTranslation();
    
    // Estados del hook
    const [orders, setOrders] = useState<CustomerOrder[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [currentPage, setCurrentPage] = useState<number>(1);
    const [totalPages, setTotalPages] = useState<number>(1);
    const [totalItems, setTotalItems] = useState<number>(0);

    // Funci√≥n para obtener los datos de una p√°gina espec√≠fica
    const fetchOrders = useCallback(async (pageToFetch: number) => {
        setLoading(true);
        console.log(`[useCustomerPurchaseHistory] Fetching page ${pageToFetch}...`);

        try {
            const response = await axiosInstance.get<PaginatedOrdersResponse>('/customer/orders', {
                params: {
                    page: pageToFetch,
                    limit: ITEMS_PER_PAGE,
                },
            });

            const data = response.data;
            if (data && Array.isArray(data.orders)) {
                // Mapear la respuesta para asegurar que los campos Decimal (que llegan como string o number)
                // sean tratados como n√∫meros en nuestro estado.
                const parsedOrders = data.orders.map(order => ({
                    ...order,
                    finalAmount: Number(order.finalAmount),
                    items: order.items.map(item => ({
                        ...item,
                        totalItemPrice: Number(item.totalItemPrice),
                        priceAtPurchase: Number(item.priceAtPurchase),
                        selectedModifiers: item.selectedModifiers.map(mod => ({
                            ...mod,
                            optionPriceAdjustmentSnapshot: Number(mod.optionPriceAdjustmentSnapshot)
                        }))
                    }))
                }));

                setOrders(parsedOrders);
                setTotalPages(data.totalPages ?? 1);
                setTotalItems(data.totalItems ?? 0);
                setCurrentPage(data.currentPage ?? pageToFetch);
                setError(null);
                console.log(`[useCustomerPurchaseHistory] Fetch successful for page ${pageToFetch}. Total Items: ${data.totalItems}`);
            } else {
                console.error('[useCustomerPurchaseHistory] Invalid response structure:', data);
                throw new Error(t('historyHook.error.invalidResponse', 'La respuesta del servidor para el historial de pedidos no tiene el formato esperado.'));
            }

        } catch (err: any) {
            console.error(`[useCustomerPurchaseHistory] Error fetching orders page ${pageToFetch}:`, err);
            const errorMsg = err.response?.data?.message || err.message || t('historyHook.error.unknown', 'Error desconocido al cargar el historial de pedidos.');
            setError(errorMsg);
        } finally {
            setLoading(false);
            console.log(`[useCustomerPurchaseHistory] Fetch process finished for page ${pageToFetch}.`);
        }
    }, [t]);

    // Funci√≥n para establecer la p√°gina
    const setPage = useCallback((page: number) => {
        if (page > 0 && page <= totalPages && page !== currentPage) {
            setCurrentPage(page);
        }
    }, [totalPages, currentPage]);
    
    // Efecto para la carga inicial y cuando cambia la p√°gina
    useEffect(() => {
        fetchOrders(currentPage);
    }, [currentPage, fetchOrders]);


    // Funci√≥n para recargar la p√°gina actual
    const refetch = useCallback(() => {
        console.log(`[useCustomerPurchaseHistory] Manual refetch triggered for page ${currentPage}.`);
        fetchOrders(currentPage);
    }, [fetchOrders, currentPage]);

    // Retornar el estado y las funciones
    return {
        orders,
        loading,
        error,
        currentPage,
        totalPages,
        totalItems,
        setPage,
        refetch
    };
};


// ====== [208] frontend/src/modules/loyalpyme/hooks/useCustomerRewardsData.ts ======
// frontend/src/modules/loyalpyme/hooks/useCustomerRewardsData.ts
// VERSI√ìN 4.0.0 - Simplificado. Ahora devuelve listas separadas en lugar de un array unificado.

import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { useTranslation } from 'react-i18next';

import { Reward, GrantedReward } from '../../../shared/types/user.types';

export interface UseCustomerRewardsDataResult {
    redeemableRewards: Reward[];          // Recompensas del cat√°logo para canjear con puntos
    availableCoupons: GrantedReward[];    // Cupones ya adquiridos y listos para usar
    pendingGifts: GrantedReward[];        // Regalos asignados por el admin, pendientes de canje
    loading: boolean;
    error: string | null;
    refresh: () => Promise<void>;
}

export const useCustomerRewardsData = (): UseCustomerRewardsDataResult => {
    const { t } = useTranslation();

    const [rewardsCatalog, setRewardsCatalog] = useState<Reward[]>([]);
    const [allGrantedRewards, setAllGrantedRewards] = useState<GrantedReward[]>([]);
    
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);

    const fetchAllData = useCallback(async () => {
        setLoading(true);
        setError(null);
        console.log('[useCustomerRewardsData] Fetching all rewards data...');
        
        try {
            // Se mantienen las mismas dos llamadas a la API
            const [rewardsResponse, grantedRewardsResponse] = await Promise.all([
                axiosInstance.get<Reward[]>('/customer/rewards'),
                axiosInstance.get<GrantedReward[]>('/customer/granted-rewards') 
            ]);

            // Guardamos los datos en sus respectivos estados
            setRewardsCatalog(rewardsResponse.data || []);
            setAllGrantedRewards(grantedRewardsResponse.data || []);
            
            console.log(`[useCustomerRewardsData] Fetched ${rewardsResponse.data?.length ?? 0} catalog rewards and ${grantedRewardsResponse.data?.length ?? 0} granted rewards.`);

        } catch (err: any) {
            const message = err.response?.data?.message || err.message || t('customerDashboard.errorLoadingRewards');
            setError(message);
            console.error('[useCustomerRewardsData] Error fetching rewards data:', err);
        } finally {
            setLoading(false);
        }
    }, [t]);

    useEffect(() => {
        fetchAllData();
    }, [fetchAllData]);
    
    // El hook ahora devuelve las listas filtradas y separadas
    return {
        redeemableRewards: rewardsCatalog,
        availableCoupons: allGrantedRewards.filter(gr => gr.status === 'AVAILABLE'),
        pendingGifts: allGrantedRewards.filter(gr => gr.status === 'PENDING'),
        loading,
        error,
        refresh: fetchAllData,
    };
};


// ====== [209] frontend/src/modules/loyalpyme/hooks/useCustomerTierData.ts ======
// filename: frontend/src/hooks/useCustomerTierData.ts
// Version: 1.2.2 (Remove unused TierCalculationBasis import)

import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { AxiosError } from 'axios';
import { notifications } from '@mantine/notifications';
// import { IconAlertCircle } from '@tabler/icons-react'; // Sigue sin usarse

// --- MODIFICACI√ìN: Importar solo los tipos usados directamente por el hook ---
import {
    TierData,
    CustomerBusinessConfig,
    UseCustomerTierDataResult,
} from '../../../shared/types/user.types';


// --- Hook ---

// Usar el tipo importado para el retorno
export const useCustomerTierData = (): UseCustomerTierDataResult => {
    // Usar los tipos importados para el estado
    const [allTiers, setAllTiers] = useState<TierData[] | null>(null);
    const [businessConfig, setBusinessConfig] = useState<CustomerBusinessConfig | null>(null);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);

    const fetchData = useCallback(async () => {
        setLoading(true);
        setError(null);
        console.log('[useCustomerTierData] Fetching all tiers and business config...');

        try {
            const [tiersResponse, configResponse] = await Promise.all([
                // Usar los tipos importados en las llamadas
                axiosInstance.get<TierData[]>('/customer/tiers'),
                axiosInstance.get<CustomerBusinessConfig>('/customer/business-config')
            ]);

            const activeTiers = tiersResponse.data?.filter(t => t.isActive) ?? [];
            setAllTiers(activeTiers);
            console.log('[useCustomerTierData] Active tiers fetched:', activeTiers);

            setBusinessConfig(configResponse.data ?? null);
            console.log('[useCustomerTierData] Business config fetched:', configResponse.data);

        } catch (err) {
            console.error("[useCustomerTierData] Error fetching data:", err);
            let errorMsg = 'Error al cargar datos de niveles o configuraci√≥n.';
            if (err instanceof AxiosError) {
                errorMsg = err.response?.data?.message || err.message || errorMsg;
            } else if (err instanceof Error) {
                errorMsg = err.message;
            }
            setError(errorMsg);

            notifications.show({
                title: 'Error de Carga',
                message: errorMsg,
                color: 'red',
                // icon: <IconAlertCircle />, // Mantenemos sin icono
            });

            setAllTiers(null);
            setBusinessConfig(null);
        } finally {
            setLoading(false);
            console.log('[useCustomerTierData] Fetch process finished.');
        }
    }, []);

    useEffect(() => {
        fetchData();
    }, [fetchData]);

    // El tipo de retorno ya coincide con UseCustomerTierDataResult importado
    return {
        allTiers,
        businessConfig,
        loading,
        error,
        refetch: fetchData
    };
};

// End of File: frontend/src/hooks/useCustomerTierData.ts


// ====== [210] frontend/src/modules/loyalpyme/hooks/useQrScanner.ts ======
// filename: frontend/src/hooks/useQrScanner.ts
// Version: 1.2.1 (Fix type errors and unused warnings)

import { useState, useEffect, useRef, useCallback } from 'react';
// --- MODIFICADO: Eliminar Html5QrcodeError y Html5QrcodeResult ---
import {
    Html5Qrcode,
    // Html5QrcodeError, // <-- Eliminado
    // Html5QrcodeResult, // <-- Eliminado
    QrcodeSuccessCallback,
    QrcodeErrorCallback
} from 'html5-qrcode';
import type { Html5QrcodeScannerConfig } from 'html5-qrcode/html5-qrcode-scanner';

// Props del Hook (sin cambios)
interface UseQrScannerProps {
    qrcodeRegionId: string;
    enabled: boolean;
    onScanSuccess: QrcodeSuccessCallback;
    onScanError?: QrcodeErrorCallback;
    config?: Omit<Html5QrcodeScannerConfig, 'fps' | 'qrbox'> & { fps?: number; qrbox?: { width: number; height: number; } | number };
    verbose?: boolean;
}

// Tipo de Retorno del Hook (sin cambios)
export interface UseQrScannerReturn {
    scannerError: string | null;
    clearScannerError: () => void;
    isScanning: boolean;
}

export const useQrScanner = ({
    qrcodeRegionId,
    enabled,
    onScanSuccess,
    // --- MODIFICADO: Prefijar errorMessage no usado ---
    onScanError = (_errorMessage) => { /* No hacer nada por defecto */ },
    // --- FIN MODIFICADO ---
    config = {},
    verbose = false,
}: UseQrScannerProps): UseQrScannerReturn => {
    const [scannerError, setScannerError] = useState<string | null>(null);
    const [isScanning, setIsScanning] = useState<boolean>(false);
    const scannerInstanceRef = useRef<Html5Qrcode | null>(null);
    // --- MODIFICADO: Cambiar tipo de Timeout a number ---
    const initTimeoutRef = useRef<number | null>(null); // <- Tipo number
    // --- FIN MODIFICADO ---
    // --- ELIMINADO: initialMount ref ---
    // const initialMount = useRef(true);
    // --- FIN ELIMINADO ---


    const log = useCallback((message: string, ...optionalParams: any[]) => {
        if (verbose) { console.log(`[useQrScanner] ${message}`, ...optionalParams); }
    }, [verbose]);

    const clearScannerError = useCallback(() => { setScannerError(null); }, []);

    const startScanner = useCallback(async () => {
        // ... (l√≥gica interna de startScanner sin cambios funcionales, solo usa tipos correctos) ...
        if (!scannerInstanceRef.current) { log("Scanner instance not ready in startScanner."); setScannerError("El esc√°ner no est√° listo."); return; }
        if (isScanning) { log("Scanner already scanning in startScanner."); return; }
        log("Attempting to start scanner..."); clearScannerError();
        try {
            await scannerInstanceRef.current.start(
                { facingMode: "environment" },
                { fps: 10, qrbox: { width: 250, height: 250 }, ...config },
                (decodedText, result) => { // QrcodeSuccessCallback - result es de tipo Html5QrcodeResult impl√≠citamente
                     log(`Scan successful: ${decodedText}`, result);
                     if (!isScanning) return;
                     setIsScanning(false);
                     onScanSuccess(decodedText, result);
                 },
                (errorMessage, error) => { // QrcodeErrorCallback - error es de tipo Html5QrcodeError impl√≠citamente
                     const commonIgnoredErrors = ['QR code parse error', 'NotFoundException'];
                     if (!commonIgnoredErrors.some(e => errorMessage.includes(e))) {
                         console.warn(`[useQrScanner] Scan Error: ${errorMessage}`, error);
                         if (onScanError) { onScanError(errorMessage, error); }
                     }
                 }
            );
            log("Scanner started successfully."); setIsScanning(true);
        } catch (err: any) {
             console.error("[useQrScanner] Error starting scanner:", err);
             let friendlyError = 'Error desconocido al iniciar esc√°ner.';
             if (err.name === 'NotFoundError' || err.message?.includes('device not found')) { friendlyError = 'No se encontr√≥ una c√°mara compatible.'; }
             else if (err.name === 'NotAllowedError' || err.message?.includes('Permission denied')) { friendlyError = 'Permiso para acceder a la c√°mara denegado.'; }
             else if (err.message) { friendlyError = `Error al iniciar c√°mara: ${err.message}`; }
             setScannerError(friendlyError); setIsScanning(false);
        }
    }, [config, log, onScanError, onScanSuccess, isScanning, clearScannerError]);


    // Efecto para inicializar y limpiar
    useEffect(() => {
        if (enabled) {
            log("Hook enabled. Setting up initialization timeout...");
            // --- MODIFICADO: Usar window.setTimeout y window.clearTimeout ---
            initTimeoutRef.current = window.setTimeout(() => { // Usar window.setTimeout
                log("Initializing Html5Qrcode (after delay)...");
                try {
                    // A√±adir try/catch aqu√≠ por si el constructor falla
                    const scanner = new Html5Qrcode(qrcodeRegionId, verbose);
                    scannerInstanceRef.current = scanner;
                    startScanner();
                } catch (initError: any) {
                    console.error("[useQrScanner] Error initializing Html5Qrcode object:", initError);
                    setScannerError(`Error al inicializar lector QR: ${initError.message || 'Error desconocido'}`);
                }
            }, 500);
            // --- FIN MODIFICADO ---
        } else {
            // Limpieza cuando enabled pasa a false (sin cambios funcionales)
            if (initTimeoutRef.current) { log("Cleanup: Cleared pending initialization timeout."); window.clearTimeout(initTimeoutRef.current); initTimeoutRef.current = null; } // Usar window.clearTimeout
            if (scannerInstanceRef.current && isScanning) { log("Cleanup: Attempting to stop scanner..."); scannerInstanceRef.current.stop().then(() => { log("Cleanup: Scanner stopped successfully."); setIsScanning(false); }).catch((err) => { if (err.message?.includes('not running')) { log("Cleanup Warning: Attempted to stop scanner that wasn't running."); } else { console.error("[useQrScanner] Cleanup: Error stopping scanner:", err); } setIsScanning(false); }).finally(() => { log("Cleanup: Setting scanner instance ref to null."); scannerInstanceRef.current = null; });
            } else { log("Cleanup: No active scanner instance found to stop or hook disabled."); if (scannerInstanceRef.current) { scannerInstanceRef.current = null; } setIsScanning(false); }
        }

        // Funci√≥n de limpieza al desmontar (sin cambios funcionales)
        return () => {
            log("Component unmounting or 'enabled' changed. Running cleanup...");
            if (initTimeoutRef.current) { log("Cleanup: Cleared pending initialization timeout on unmount."); window.clearTimeout(initTimeoutRef.current); } // Usar window.clearTimeout
             if (scannerInstanceRef.current && isScanning) {
                 log("Cleanup: Attempting to stop scanner on unmount...");
                 try { scannerInstanceRef.current.stop().then(() => log("Cleanup: Scanner stopped successfully on unmount.")).catch((err) => { if (err.message?.includes('not running')) { log("Cleanup Warning: Attempted to stop scanner (unmount) that wasn't running."); } else { console.error("[useQrScanner] Cleanup: Error stopping scanner on unmount:", err); } }).finally(() => { scannerInstanceRef.current = null; log("Cleanup: Scanner instance ref set to null on unmount."); }); } catch (stopError) { console.error("[useQrScanner] Cleanup: Immediate error calling stop() on unmount:", stopError); scannerInstanceRef.current = null; }
             } else if (scannerInstanceRef.current) { log("Cleanup: Scanner instance exists but wasn't scanning on unmount. Setting ref to null."); scannerInstanceRef.current = null; }
            setIsScanning(false);
        };
    }, [qrcodeRegionId, enabled, verbose, log, startScanner, isScanning]);

    return { scannerError, clearScannerError, isScanning };
};

// End of File: frontend/src/hooks/useQrScanner.ts


// ====== [211] frontend/src/modules/loyalpyme/hooks/useUserProfileData.ts ======
// filename: frontend/src/hooks/useUserProfileData.ts
// Version: 1.5.0 (Return setUserData function and use imported types)

import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { AxiosError } from 'axios';
// Importar tipos desde el archivo central
import { UserData, UseProfileResult } from '../../../shared/types/user.types'; // Aseg√∫rate que la ruta es correcta


/**
 * Hook para obtener y gestionar los datos del perfil del usuario logueado.
 */
export const useUserProfileData = (): UseProfileResult => { // <-- Usa tipo importado
    const [userData, setUserData] = useState<UserData | null>(null); // <-- Usa tipo importado
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);

    const fetchUserProfile = useCallback(async () => {
        console.log('[useUserProfileData] Fetching user profile...');
        setLoading(true);
        setError(null);
        try {
            const response = await axiosInstance.get<UserData>('/profile'); // <-- Usa tipo importado
            if (response.data) {
                setUserData(response.data);
                console.log('[useUserProfileData] User profile updated.');
            } else {
                console.warn('[useUserProfileData] No user data received from /profile endpoint.');
                setUserData(null);
            }
        } catch (err) {
            console.error("[useUserProfileData] Error fetching user profile:", err);
            const errorMsg = err instanceof Error ? err.message : 'Ocurri√≥ un error desconocido.';
            let detailedError = `Error al cargar perfil: ${errorMsg}.`;
            if (err instanceof AxiosError && err.response) { detailedError += ` (Status: ${err.response.status})`; }
            setError(detailedError);
            setUserData(null);
        } finally {
            setLoading(false);
            console.log('[useUserProfileData] Fetch user profile finished.');
        }
    }, []);

    useEffect(() => {
        fetchUserProfile();
    }, [fetchUserProfile]);

    // Devolver tambi√©n setUserData
    // Aseg√∫rate de que esta secci√≥n es id√©ntica en tu archivo:
    return {
        userData,
        loading,
        error,
        refetch: fetchUserProfile,
        setUserData // <-- La propiedad que falta seg√∫n el error
    };
};

export default useUserProfileData;

// End of File: frontend/src/hooks/useUserProfileData.ts


// ====== [212] frontend/src/modules/loyalpyme/pages/CustomerDashboardPage.tsx ======
// frontend/src/modules/loyalpyme/pages/CustomerDashboardPage.tsx
// VERSI√ìN 6.1.0 - Eliminadas props obsoletas de SummaryTab.

import { useState, useCallback, useMemo } from 'react';
import { Container, Title, Alert, Tabs, Space, LoadingOverlay, Text } from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { IconAlertCircle, IconCircleCheck, IconGift, IconLayoutDashboard, IconHistory, IconUserCircle, IconReceipt } from '@tabler/icons-react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { AxiosError } from 'axios';
import { useDisclosure } from '@mantine/hooks';
import { useTranslation } from 'react-i18next';

// Hooks
import { useUserProfileData } from '../hooks/useUserProfileData';
import { useCustomerRewardsData } from '../hooks/useCustomerRewardsData';
import { useCustomerTierData } from '../hooks/useCustomerTierData';

// Componentes
import SummaryTab from '../components/customer/dashboard/tabs/SummaryTab';
import RewardsTab from '../components/customer/dashboard/tabs/RewardsTab';
import ActivityTab from '../components/customer/dashboard/tabs/ActivityTab';
import PurchaseHistoryTab from '../components/customer/dashboard/tabs/PurchaseHistoryTab';
import ProfileTab from '../components/customer/dashboard/tabs/ProfileTab';

// Tipos
import { TierBenefitData, DisplayReward, TierCalculationBasis } from '../../../shared/types/user.types';

type ProgressBarDataType = { type: 'progress'; percentage: number; currentValueLabel: string; targetValueLabel: string; unit: string; nextTierName: string; } | { type: 'max_level'; currentTierName: string; } | null;
interface TierDisplayMemoResult { progressBarData: ProgressBarDataType; nextTierName: string | null; nextTierBenefits: TierBenefitData[]; }

function CustomerDashboardPage() {
    const { t } = useTranslation();
    const { userData, loading: loadingUser, error: errorUser, refetch: refetchUser } = useUserProfileData();
    
    const { 
        redeemableRewards, availableCoupons, pendingGifts, 
        loading: loadingRewardsData, error: errorRewardsData, 
        refresh: refreshRewards 
    } = useCustomerRewardsData();
    
    const { allTiers, businessConfig, loading: loadingTierData, error: errorTierData, refetch: refetchTierData } = useCustomerTierData();
    
    const [validatingQr, setValidatingQr] = useState(false);
    const [scannerOpened, { open: openScanner, close: closeScanner }] = useDisclosure(false);
    const [activeTab, setActiveTab] = useState<string | null>('summary');
    
    const handleRefetchAll = useCallback(async () => {
        await Promise.all([refetchUser(), refreshRewards(), refetchTierData()]);
    }, [refetchUser, refreshRewards, refetchTierData]);

    const handleValidateQr = useCallback(async (token: string) => {
        setValidatingQr(true);
        try {
            const response = await axiosInstance.post<any>('/points/validate-qr', { qrToken: token });
            if (!response.data.user) { throw new Error(t('customerDashboard.errorValidatingQrMessage')); }
            notifications.show({ title: t('common.success'), message: t('customerDashboard.successQrValidation', { points: response.data.pointsEarned ?? 0 }), color: 'green', icon: <IconCircleCheck /> });
            await handleRefetchAll();
        } catch (err: unknown) {
            const errorMsg = (err instanceof AxiosError && err.response?.data?.message) ? err.response.data.message : (err instanceof Error ? err.message : t('customerDashboard.errorValidatingQrMessage'));
            notifications.show({ title: t('customerDashboard.errorValidatingQr'), message: errorMsg, color: 'red', icon: <IconAlertCircle /> });
        } finally {
            setValidatingQr(false);
        }
    }, [handleRefetchAll, t]);
    
    const displayRewardsForSummary: DisplayReward[] = useMemo(() => {
        const gifts: DisplayReward[] = pendingGifts.map(gr => ({ isGift: true, id: gr.reward.id, grantedRewardId: gr.id, name_es: gr.reward.name_es, name_en: gr.reward.name_en, description_es: gr.reward.description_es, description_en: gr.reward.description_en, pointsCost: 0, imageUrl: gr.reward.imageUrl, assignedAt: gr.assignedAt, assignedByString: gr.assignedBy?.name || gr.assignedBy?.email || t('customerDashboard.summary.unknownAssigner'), type: gr.reward.type, linkedMenuItemId: gr.reward.linkedMenuItemId, discountType: gr.reward.discountType, discountValue: Number(gr.reward.discountValue) || null, }));
        const pointsRewards: DisplayReward[] = redeemableRewards.map(r => ({ isGift: false, id: r.id, name_es: r.name_es, name_en: r.name_en, description_es: r.description_es, description_en: r.description_en, pointsCost: r.pointsCost, imageUrl: r.imageUrl, type: r.type, linkedMenuItemId: r.linkedMenuItemId, discountType: r.discountType, discountValue: Number(r.discountValue) || null, }));
        return [...gifts, ...pointsRewards];
    }, [pendingGifts, redeemableRewards, t]);

    const tierDisplayData = useMemo((): TierDisplayMemoResult => {
        if (loadingUser || loadingTierData || !userData || !allTiers || !businessConfig || !businessConfig.tierCalculationBasis) { return { progressBarData: null, nextTierName: null, nextTierBenefits: [] }; }
        const sortedTiers = [...allTiers].sort((a, b) => a.level - b.level);
        const currentTierIndex = sortedTiers.findIndex(t => t.id === userData.currentTier?.id);
        const currentTier = currentTierIndex !== -1 ? sortedTiers[currentTierIndex] : null;
        const nextTier = currentTierIndex !== -1 && currentTierIndex < sortedTiers.length - 1 ? sortedTiers[currentTierIndex + 1] : null;
        if (!nextTier) { return { progressBarData: { type: 'max_level', currentTierName: currentTier?.name || t('customerDashboard.baseTier') }, nextTierName: null, nextTierBenefits: [] }; }
        let unit = ''; let currentMetricValue = 0;
        switch (businessConfig.tierCalculationBasis) {
            case TierCalculationBasis.SPEND: unit = '‚Ç¨'; currentMetricValue = userData.totalSpend ?? 0; break;
            case TierCalculationBasis.VISITS: unit = t('customerDashboard.progressUnitVisits'); currentMetricValue = userData.totalVisits ?? 0; break;
            case TierCalculationBasis.POINTS_EARNED: unit = t('common.points'); currentMetricValue = userData.points ?? 0; break;
        }
        const currentTierMinValue = currentTier?.minValue ?? 0;
        const range = Math.max(0.01, nextTier.minValue - currentTierMinValue);
        const progressInTier = Math.max(0, currentMetricValue - currentTierMinValue);
        const percentage = Math.max(0, Math.min(100, (progressInTier / range) * 100));
        const formatOptions = { maximumFractionDigits: unit === '‚Ç¨' ? 2 : 0 };
        const currentValueLabel = currentMetricValue.toLocaleString(undefined, formatOptions);
        const targetValueLabel = nextTier.minValue.toLocaleString(undefined, formatOptions);
        return { progressBarData: { type: 'progress', percentage, currentValueLabel, targetValueLabel, unit, nextTierName: nextTier.name }, nextTierName: nextTier.name, nextTierBenefits: nextTier.benefits ?? [] };
    }, [userData, allTiers, businessConfig, loadingUser, loadingTierData, t]);

    const currentTierBenefits = useMemo(() => userData?.currentTier?.benefits ?? [], [userData?.currentTier]);
    const isLoading = loadingUser || loadingTierData || loadingRewardsData;
    const mainError = errorUser || errorTierData || errorRewardsData;

    if (mainError && !isLoading) { return ( <Container size="lg" py="xl"><Alert icon={<IconAlertCircle size="1rem" />} title={t('common.errorLoadingData')} color="red" radius="md">{mainError}</Alert></Container> ); }

    return (
        <Container size="lg" py="xl">
            <LoadingOverlay visible={isLoading && !userData} overlayProps={{ radius: 'sm', blur: 2 }} />
            {userData && (
                <>
                    <Title order={2} ta="center" mb="xl">{t('customerDashboard.title')}</Title>
                    <Tabs value={activeTab} onChange={setActiveTab} keepMounted={false}>
                        <Tabs.List grow>
                            <Tabs.Tab value="summary" leftSection={<IconLayoutDashboard size={16} />}>{t('customerDashboard.tabSummary')}</Tabs.Tab>
                            <Tabs.Tab value="rewards" leftSection={<IconGift size={16} />}>{t('customerDashboard.tabRewards')}</Tabs.Tab>
                            <Tabs.Tab value="history" leftSection={<IconReceipt size={16} />}>{t('customerDashboard.tabHistory')}</Tabs.Tab>
                            <Tabs.Tab value="activity" leftSection={<IconHistory size={16} />}>{t('customerDashboard.tabActivity')}</Tabs.Tab>
                            <Tabs.Tab value="profile" leftSection={<IconUserCircle size={16} />}>{t('customerDashboard.tabProfile')}</Tabs.Tab>
                        </Tabs.List>
                        <Space h="xl" />
                        <Tabs.Panel value="summary">
                            <SummaryTab
                                userData={userData} loadingUser={loadingUser} errorUser={errorUser}
                                progressBarData={tierDisplayData.progressBarData} currentTierBenefits={currentTierBenefits}
                                nextTierName={tierDisplayData.nextTierName} nextTierBenefits={tierDisplayData.nextTierBenefits}
                                displayRewards={displayRewardsForSummary} setActiveTab={setActiveTab}
                                handleValidateQr={handleValidateQr} validatingQr={validatingQr}
                                scannerOpened={scannerOpened} onOpenScanner={openScanner} onCloseScanner={closeScanner}
                            />
                        </Tabs.Panel>
                        <Tabs.Panel value="rewards">
                            <RewardsTab
                                 redeemableRewards={redeemableRewards}
                                 userPoints={userData.points}
                                 loadingRewards={loadingRewardsData}
                                 errorRewards={errorRewardsData}
                                 availableCoupons={availableCoupons}
                                 loadingCoupons={loadingRewardsData}
                                 errorCoupons={errorRewardsData}
                                 pendingGifts={pendingGifts}
                                 loadingGifts={loadingRewardsData}
                                 errorGifts={errorRewardsData}
                             />
                        </Tabs.Panel>
                         <Tabs.Panel value="history"><PurchaseHistoryTab /></Tabs.Panel>
                         <Tabs.Panel value="activity"><ActivityTab /></Tabs.Panel>
                         <Tabs.Panel value="profile"><ProfileTab /></Tabs.Panel>
                    </Tabs>
                </>
            )}
            {!userData && !isLoading && !mainError && (
                <Text ta="center" c="dimmed" mt="xl">{t('customerDashboard.noUserDataError')}</Text>
            )}
        </Container>
    );
}

export default CustomerDashboardPage;


// ====== [213] frontend/src/modules/loyalpyme/pages/admin/AdminCustomerManagementPage.module.css ======
/*
.th {
  padding: 0 !important;
}

.control {
  width: 100%;
  padding: var(--mantine-spacing-xs) var(--mantine-spacing-md);
  display: flex;
  justify-content: space-between;
  align-items: center;

  &:hover {
    background-color: light-dark(var(--mantine-color-gray-0), var(--mantine-color-dark-6));
  }

  &:disabled {
    cursor: default;
    &:hover {
       background-color: transparent;
    }
  }
}

.icon {
  width: rem(21px);
  height: rem(21px);
  border-radius: rem(21px);
}

.thead {
  position: sticky;
  top: 0;
  background-color: var(--mantine-color-body);
  transition: box-shadow 150ms ease;
  z-index: 1;

  &::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    border-bottom: rem(1px) solid var(--table-border-color);
  }
}
*/


// ====== [214] frontend/src/modules/loyalpyme/pages/admin/AdminCustomerManagementPage.tsx ======
// frontend/src/pages/admin/AdminCustomerManagementPage.tsx
// Version 2.0.1 (Complete integration of FiltersBar, BulkActionsBar, and adminCustomerService)

import React, { useState, useEffect, useCallback } from 'react';
import {
    Paper, Title, Stack, Loader, Alert, Pagination, Group, Text
} from '@mantine/core';
import {
    IconAlertCircle, IconCheck, IconX
} from '@tabler/icons-react';
import { useDisclosure } from '@mantine/hooks';
import { useModals } from '@mantine/modals';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';

// Nuevos Componentes
import CustomerFiltersBar, { TierOption } from '../../components/admin/CustomerFiltersBar';
import CustomerBulkActionsBar from '../../components/admin/CustomerBulkActionsBar';

// Componentes Modales
import AdjustPointsModal from '../../components/admin/AdjustPointsModal';
import ChangeTierModal from '../../components/admin/ChangeTierModal';
import AssignRewardModal from '../../components/admin/AssignRewardModal';
import CustomerDetailsModal, { CustomerDetails } from '../../components/admin/CustomerDetailsModal';
import BulkAdjustPointsModal from '../../components/admin/BulkAdjustPointsModal';

// Hook y Tipos de Datos
import useAdminCustomersData, {
    Customer,
    UseAdminCustomersDataResult,
    SortColumn,
} from '../../hooks/useAdminCustomersData';
import CustomerTable from '../../components/admin/CustomerTable';

// Nuevo Servicio API
import * as adminCustomerService from '../../services/adminCustomerService';
import axiosInstance from '../../../../shared/services/axiosInstance';// Para fetchTiersForFilter

const AdminCustomerManagementPage: React.FC = () => {
    const { t } = useTranslation();
    const {
        customers, loading, error,
        currentPage, totalPages, totalItems,
        setPage, searchTerm, setSearchTerm, sortStatus, setSortStatus,
        filters, setFilters,
        refetch
    }: UseAdminCustomersDataResult = useAdminCustomersData();
    const modals = useModals();

    const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(null);
    const [adjustModalOpened, { open: openAdjustModal, close: closeAdjustModal }] = useDisclosure(false);
    const [changeTierModalOpened, { open: openChangeTierModal, close: closeChangeTierModal }] = useDisclosure(false);
    const [assignRewardModalOpened, { open: openAssignRewardModal, close: closeAssignRewardModal }] = useDisclosure(false);
    const [detailsModalOpened, { open: openDetailsModal, close: closeDetailsModal }] = useDisclosure(false);
    const [bulkAdjustModalOpened, { open: openBulkAdjustModal, close: closeBulkAdjustModal }] = useDisclosure(false);
    const [selectedCustomerDetails, setSelectedCustomerDetails] = useState<CustomerDetails | null>(null);
    const [loadingDetails, setLoadingDetails] = useState<boolean>(false);
    const [errorDetails, setErrorDetails] = useState<string | null>(null);
    const [togglingFavoriteId, setTogglingFavoriteId] = useState<string | null>(null);
    const [togglingActiveId, setTogglingActiveId] = useState<string | null>(null);
    const [isSavingNotes, setIsSavingNotes] = useState<boolean>(false);
    const [selectedRowIds, setSelectedRowIds] = useState<string[]>([]);
    const [isPerformingBulkAction, setIsPerformingBulkAction] = useState<boolean>(false);
    const [tierOptions, setTierOptions] = useState<TierOption[]>([]);
    const [loadingTiers, setLoadingTiers] = useState<boolean>(true);

    useEffect(() => {
        const fetchTiersForFilter = async () => {
            setLoadingTiers(true);
            try {
                const response = await axiosInstance.get<{ id: string; name: string; level: number }[]>('/tiers');
                const sortedTiers = response.data.sort((a, b) => a.level - b.level);
                const options: TierOption[] = [
                    { value: '', label: t('adminCustomersPage.tierFilterAll') },
                    { value: 'NONE', label: t('adminCustomersPage.tierFilterNone') },
                    ...sortedTiers.map(tier => ({ value: tier.id, label: tier.name }))
                ];
                setTierOptions(options);
            } catch (err) {
                console.error("Error fetching tiers for filter:", err);
                notifications.show({ title: t('common.error'), message: t('adminCustomersPage.tierFilterError'), color: 'red' });
                setTierOptions([{ value: '', label: t('adminCustomersPage.tierFilterError') }]);
            } finally { setLoadingTiers(false); }
        };
        fetchTiersForFilter();
    }, [t]);

    const handleOpenAdjustPoints = useCallback((customer: Customer) => { setSelectedCustomer(customer); openAdjustModal(); }, [openAdjustModal]);
    const handleAdjustSuccess = useCallback(() => { refetch(); closeAdjustModal(); setSelectedCustomer(null); }, [refetch, closeAdjustModal]);
    const handleOpenChangeTier = useCallback((customer: Customer) => { setSelectedCustomer(customer); openChangeTierModal(); }, [openChangeTierModal]);
    const handleChangeTierSuccess = useCallback(() => { refetch(); closeChangeTierModal(); setSelectedCustomer(null); }, [refetch, closeChangeTierModal]);
    const handleOpenAssignReward = useCallback((customer: Customer) => { setSelectedCustomer(customer); openAssignRewardModal(); }, [openAssignRewardModal]);
    const handleAssignRewardSuccess = useCallback(() => { refetch(); closeAssignRewardModal(); setSelectedCustomer(null); }, [refetch, closeAssignRewardModal]);
    const handleCloseDetailsModal = () => { closeDetailsModal(); setSelectedCustomerDetails(null); setLoadingDetails(false); setErrorDetails(null); };

    const handleToggleFavorite = useCallback(async (customerId: string, currentIsFavorite: boolean) => {
        setTogglingFavoriteId(customerId);
        try {
            await adminCustomerService.toggleCustomerFavoriteApi(customerId);
            notifications.show({
                title: t('common.updateSuccess'),
                message: t('adminCustomersPage.bulkActionStatusSuccess', { // Reutilizando clave de acci√≥n masiva para mensaje similar
                    count: 1, // Implica un cliente
                    status: !currentIsFavorite
                        ? t('adminCustomersPage.bulkActionStatusActivated').replace('activado', 'marcado como favorito') // Adaptar
                        : t('adminCustomersPage.bulkActionStatusDeactivated').replace('desactivado', 'desmarcado de favorito') // Adaptar
                }),
                color: 'green', icon: <IconCheck />
            });
            refetch();
        } catch (err: any) {
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.bulkActionStatusError', { // Reutilizando clave
                    action: 'cambiar estado de favorito', // Adaptar
                    error: err.response?.data?.message || err.message
                }),
                color: 'red', icon: <IconX />
            });
        } finally { setTogglingFavoriteId(null); }
    }, [refetch, t]);

    const handleToggleActive = useCallback(async (customer: Customer) => {
        const actionText = customer.isActive ? t('adminCustomersPage.bulkConfirmToggleDeactivate') : t('adminCustomersPage.bulkConfirmToggleActivate');
        const currentStatusText = customer.isActive ? t('adminCustomersPage.bulkActionStatusDeactivated') : t('adminCustomersPage.bulkActionStatusActivated');

        if (!window.confirm(t('adminCustomersPage.bulkConfirmToggleActiveMessage', { action: actionText, count: 1 }))) return;

        setTogglingActiveId(customer.id);
        try {
            await adminCustomerService.toggleCustomerActiveApi(customer.id);
            notifications.show({
                title: t('common.updateSuccess'),
                message: t('adminCustomersPage.bulkActionStatusSuccess', { count: 1, status: currentStatusText }),
                color: 'green', icon: <IconCheck />,
            });
            refetch();
        } catch (err: any) {
            console.error(`Error toggling active status for customer ${customer.id}:`, err);
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.bulkActionStatusError', { action: actionText, error: err.response?.data?.message || err.message }),
                color: 'red', icon: <IconX />,
            });
        } finally { setTogglingActiveId(null); }
    }, [refetch, t]);

    const handleViewDetails = useCallback(async (customer: Customer) => {
        setSelectedCustomerDetails(null); setErrorDetails(null); setLoadingDetails(true); openDetailsModal();
        try {
            const details = await adminCustomerService.getCustomerDetailsApi(customer.id);
            setSelectedCustomerDetails(details);
        } catch (err: any) {
            setErrorDetails(err.response?.data?.message || err.message || t('adminCustomersPage.customerDetailsLoadingError'));
        } finally { setLoadingDetails(false); }
    }, [openDetailsModal, t]);

    const handleSaveNotes = useCallback(async (notes: string | null) => {
        if (!selectedCustomerDetails?.id) { return Promise.reject(new Error("Missing customer ID")); }
        setIsSavingNotes(true);
        try {
            await adminCustomerService.updateCustomerNotesApi(selectedCustomerDetails.id, notes);
            notifications.show({ title: t('common.saveSuccess'), message: t('adminCustomersPage.customerDetailsNotesSaved'), color: 'green', icon: <IconCheck /> });
            const details = await adminCustomerService.getCustomerDetailsApi(selectedCustomerDetails.id);
            setSelectedCustomerDetails(details);
        } catch (err: any) {
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
            notifications.show({ title: t('common.saveError'), message: t('adminCustomersPage.customerDetailsNotesError', { error: apiError }), color: 'red', icon: <IconX /> });
            throw err;
        } finally { setIsSavingNotes(false); }
    }, [selectedCustomerDetails, t]);

    const handleTableSort = useCallback((column: SortColumn) => { setSortStatus({ column, direction: sortStatus.column === column && sortStatus.direction === 'asc' ? 'desc' : 'asc' }); }, [sortStatus, setSortStatus]);
    const handleRowSelectionChange = useCallback((selectedIds: string[]) => { setSelectedRowIds(selectedIds); }, []);

    const handleBulkToggleActive = useCallback(async (targetStatus: boolean) => {
        const action = targetStatus ? t('adminCustomersPage.bulkConfirmToggleActivate') : t('adminCustomersPage.bulkConfirmToggleDeactivate');
        const count = selectedRowIds.length;
        if (count === 0) {
            notifications.show({ title: t('common.info'), message: t('adminCustomersPage.bulkActionNoneSelected'), color: 'yellow' });
            return;
        }
        if (!window.confirm(t('adminCustomersPage.bulkConfirmToggleActiveMessage', { action, count }))) return;

        setIsPerformingBulkAction(true);
        try {
            const response = await adminCustomerService.bulkUpdateCustomerStatusApi(selectedRowIds, targetStatus);
            const statusResult = targetStatus ? t('adminCustomersPage.bulkActionStatusActivated') : t('adminCustomersPage.bulkActionStatusDeactivated');
            notifications.show({ title: t('adminCommon.updateSuccess'), message: t('adminCustomersPage.bulkActionStatusSuccess', { count: response.count, status: statusResult }), color: 'green', icon: <IconCheck /> });
            refetch(); setSelectedRowIds([]);
        } catch (err: any) {
            console.error(`Error during bulk ${action}:`, err);
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
            notifications.show({ title: t('adminCommon.updateError'), message: t('adminCustomersPage.bulkActionStatusError', { action, error: apiError }), color: 'red', icon: <IconX /> });
        } finally { setIsPerformingBulkAction(false); }
    }, [selectedRowIds, refetch, t]);

    const handleBulkDelete = useCallback(() => {
        const count = selectedRowIds.length;
        if (count === 0) {
            notifications.show({ title: t('common.info'), message: t('adminCustomersPage.bulkActionNoneSelected'), color: 'yellow' });
            return;
        }
        modals.openConfirmModal({
            title: t('adminCustomersPage.bulkConfirmDeleteTitle'), centered: true,
            children: ( <Text size="sm">{t('adminCustomersPage.bulkConfirmDeleteMessage', { count })}</Text> ),
            labels: { confirm: t('adminCustomersPage.bulkConfirmDeleteButton'), cancel: t('common.cancel') },
            confirmProps: { color: 'red' }, zIndex: 1001,
            onConfirm: async () => {
                setIsPerformingBulkAction(true);
                try {
                    const response = await adminCustomerService.bulkDeleteCustomersApi(selectedRowIds);
                    notifications.show({ title: t('adminCommon.deleteSuccess'), message: t('adminCustomersPage.bulkActionDeleteSuccess', { count: response.count }), color: 'green', icon: <IconCheck /> });
                    refetch(); setSelectedRowIds([]);
                } catch (err: any) {
                    console.error(`Error during bulk delete:`, err);
                    const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
                    notifications.show({ title: t('adminCommon.deleteError'), message: t('adminCustomersPage.bulkActionDeleteError', { error: apiError }), color: 'red', icon: <IconX /> });
                } finally { setIsPerformingBulkAction(false); }
            },
        });
    }, [selectedRowIds, refetch, modals, t]);

    const handleBulkAdjustPointsSubmit = useCallback(async (values: { amount: number; reason?: string | undefined }) => {
        const { amount, reason } = values; const count = selectedRowIds.length;
        if (count === 0) {
            notifications.show({ title: t('common.error'), message: t('adminCustomersPage.bulkAdjustPointsErrorNoneSelected'), color: 'red' });
            return Promise.reject(new Error("No customers selected"));
        }
        setIsPerformingBulkAction(true); closeBulkAdjustModal();
        try {
            const response = await adminCustomerService.bulkAdjustCustomerPointsApi(selectedRowIds, amount, reason || null);
            const actionResult = amount > 0 ? t('adminCustomersPage.bulkAdjustPointsAdded') : t('adminCustomersPage.bulkAdjustPointsSubtracted');
            notifications.show({ title: t('adminCommon.updateSuccess'), message: t('adminCustomersPage.bulkAdjustPointsSuccess', { points: Math.abs(amount), action: actionResult, count: response.count }), color: 'green', icon: <IconCheck /> });
            refetch(); setSelectedRowIds([]);
        } catch (err: any) {
            console.error(`Error during bulk points adjustment:`, err);
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
            notifications.show({ title: t('adminCommon.updateError'), message: t('adminCustomersPage.bulkAdjustPointsError', { error: apiError }), color: 'red', icon: <IconX /> });
            throw err; // Relanzar para que el modal sepa que fall√≥ y no se cierre si as√≠ est√° programado
        } finally { setIsPerformingBulkAction(false); }
    }, [selectedRowIds, refetch, closeBulkAdjustModal, t]);

    const handleFilterSearchTermChange = (term: string) => setSearchTerm(term);
    const handleFilterActiveChange = (value: string | null) => {
        setFilters({ isActive: value === 'active' ? true : value === 'inactive' ? false : undefined });
    };
    const handleFilterFavoriteChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        setFilters({ isFavorite: event.currentTarget.checked ? true : undefined });
    };
    const handleFilterTierChange = (value: string | null) => {
        setFilters({ tierId: value || undefined });
    };

    const areFiltersActive = filters.isActive !== undefined || filters.isFavorite !== undefined || filters.tierId !== undefined;

    return (
        <>
            <Paper shadow="sm" p="lg" withBorder radius="lg">
                <Stack gap="lg">
                    <Title order={2}>{t('adminCustomersPage.title')}</Title>
                    <CustomerFiltersBar
                        searchTerm={searchTerm}
                        onSearchTermChange={handleFilterSearchTermChange}
                        activeFilterValue={filters.isActive === true ? 'active' : filters.isActive === false ? 'inactive' : ''}
                        onActiveFilterChange={handleFilterActiveChange}
                        isFavoriteFilterChecked={filters.isFavorite === true}
                        onIsFavoriteFilterChange={handleFilterFavoriteChange}
                        tierFilterValue={filters.tierId || ''}
                        onTierFilterChange={handleFilterTierChange}
                        tierOptions={tierOptions}
                        loadingFilters={loadingTiers}
                        disabled={loading || isPerformingBulkAction}
                    />
                    <CustomerBulkActionsBar
                        selectedRowCount={selectedRowIds.length}
                        onBulkDelete={handleBulkDelete}
                        onBulkActivate={() => handleBulkToggleActive(true)}
                        onBulkDeactivate={() => handleBulkToggleActive(false)}
                        onOpenBulkAdjustPoints={openBulkAdjustModal}
                        isPerformingBulkAction={isPerformingBulkAction}
                    />

                    {!loading && !error && (
                        <Group justify="space-between">
                            <Text size="sm" c="dimmed">
                                {t('adminCustomersPage.resultsCount', { count: totalItems })}
                                {searchTerm || areFiltersActive ? ` ${t('adminCustomersPage.resultsCountFiltered')}` : ''}.
                            </Text>
                        </Group>
                    )}
                    {loading && <Group justify="center" p="md"><Loader /></Group>}
                    {error && !loading && <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{error}</Alert>}
                    {!loading && !error && customers.length === 0 && totalItems > 0 && (
                         <Text c="dimmed" ta="center" p="md">{t('adminCustomersPage.noResultsFiltered')}</Text>
                     )}
                    {!loading && !error && totalItems === 0 && (
                         <Text c="dimmed" ta="center" p="md">{searchTerm || areFiltersActive ? t('adminCustomersPage.noResultsFiltered') : t('adminCustomersPage.noResults')}.</Text>
                     )}

                    {!loading && !error && customers.length > 0 && (
                        <CustomerTable
                            customers={customers}
                            sortStatus={sortStatus}
                            togglingFavoriteId={togglingFavoriteId}
                            togglingActiveId={togglingActiveId}
                            selectedRows={selectedRowIds}
                            onSort={handleTableSort}
                            onToggleFavorite={handleToggleFavorite}
                            onOpenAdjustPoints={handleOpenAdjustPoints}
                            onOpenChangeTier={handleOpenChangeTier}
                            onOpenAssignReward={handleOpenAssignReward}
                            onViewDetails={handleViewDetails}
                            onToggleActive={handleToggleActive}
                            onRowSelectionChange={handleRowSelectionChange}
                        />
                    )}
                    {!loading && !error && totalPages > 1 && (
                        <Group justify="center" mt="md">
                            <Pagination total={totalPages} value={currentPage} onChange={setPage} disabled={loading || isPerformingBulkAction}/>
                        </Group>
                    )}
                </Stack>
            </Paper>

            <AdjustPointsModal
                opened={adjustModalOpened}
                onClose={() => { closeAdjustModal(); setSelectedCustomer(null); }}
                customer={selectedCustomer}
                onSuccess={handleAdjustSuccess} // Este onSuccess ahora es solo para refetch y cerrar modal
            />
            <ChangeTierModal
                opened={changeTierModalOpened}
                onClose={() => { closeChangeTierModal(); setSelectedCustomer(null); }}
                customer={selectedCustomer}
                onSuccess={handleChangeTierSuccess} // Similarmente, para refetch y cerrar
            />
            <AssignRewardModal
                opened={assignRewardModalOpened}
                onClose={() => { closeAssignRewardModal(); setSelectedCustomer(null); }}
                customer={selectedCustomer}
                onSuccess={handleAssignRewardSuccess} // Similarmente
            />
            <CustomerDetailsModal
                opened={detailsModalOpened}
                onClose={handleCloseDetailsModal}
                customerDetails={selectedCustomerDetails}
                isLoading={loadingDetails || isSavingNotes}
                error={errorDetails}
                onSaveNotes={handleSaveNotes} // Este ya usa el servicio
            />
            <BulkAdjustPointsModal
                opened={bulkAdjustModalOpened}
                onClose={closeBulkAdjustModal}
                onSubmit={handleBulkAdjustPointsSubmit} // Este ya usa el servicio
                numberOfCustomers={selectedRowIds.length}
            />
        </>
    );
};

export default AdminCustomerManagementPage;


// ====== [215] frontend/src/modules/loyalpyme/pages/admin/AdminGenerateQr.tsx ======
// filename: frontend/src/pages/admin/AdminGenerateQr.tsx
import React from 'react';
import GenerateQrCode from '../../components/GenerateQrCode';
import { Paper, Stack, Title } from '@mantine/core';
import { useTranslation } from 'react-i18next';

const AdminGenerateQr: React.FC = () => {
    const { t } = useTranslation();

    return (
        <Paper shadow="xs" p="lg" withBorder radius="lg">
            <Stack gap="md">
                {/* Usamos la clave del t√≠tulo de la tarjeta de acceso r√°pido que ya ten√≠amos */}
                <Title order={2}>{t('adminOverview.cardQrTitle')}</Title>
                <GenerateQrCode />
            </Stack>
        </Paper>
    );
};

export default AdminGenerateQr;


// ====== [216] frontend/src/modules/loyalpyme/pages/admin/AdminOverview.tsx ======
// frontend/src/pages/admin/AdminOverview.tsx
import { useEffect, useState, FC } from 'react';
import {
    Container, Title, Text, SimpleGrid, Card, Button, Group, Stack,
    Loader, Alert
} from '@mantine/core';
import {
    IconGift, IconStairsUp, IconQrcode, IconUsers, IconSettings,
    IconUserPlus, IconTicket, IconAlertCircle, IconToolsKitchen
} from '@tabler/icons-react';
import { Link } from 'react-router-dom';
import { useTranslation } from 'react-i18next';

import { useAdminOverviewStats } from '../../hooks/useAdminOverviewStats';
import StatCard from '../../components/admin/StatCard';
import { useLayoutUserData } from '../../../../shared/hooks/useLayoutUserData';

const AdminOverview: FC = () => {
    const { t } = useTranslation();
    const { userData: layoutUserData, loadingUser: loadingLayoutUser } = useLayoutUserData();
    const [adminName, setAdminName] = useState<string | null>(null);
    const [businessName, setBusinessName] = useState<string | null>(null);

    const {
        statsData,
        loadingStats,
        errorStats,
        newCustomersTrend,
        pointsIssuedTrend,
        rewardsRedeemedTrend,
    } = useAdminOverviewStats();

    useEffect(() => {
        if (layoutUserData) {
            setAdminName(layoutUserData.name || layoutUserData.email || t('adminCommon.adminTitle'));
            // Como discutimos, /api/profile no devuelve el nombre del negocio directamente en layoutUserData.
            // Si quisieras el nombre real del negocio aqu√≠, necesitar√≠as:
            // 1. Que /api/profile (auth.middleware.ts) a√±ada business.name a req.user
            // 2. O hacer una llamada API separada aqu√≠ para obtener los detalles del layoutUserData.businessId
            // Por ahora, mantenemos el placeholder.
            setBusinessName(t('adminOverview.defaultBusinessName'));
        } else if (!loadingLayoutUser) {
            setAdminName(t('adminCommon.adminTitle'));
            setBusinessName(t('adminOverview.defaultBusinessName'));
        }
    }, [layoutUserData, loadingLayoutUser, t]);

    const routes = {
        rewards: '/admin/dashboard/rewards',
        generateQr: '/admin/dashboard/generate-qr',
        manageTiers: '/admin/dashboard/tiers/manage',
        settingsTiers: '/admin/dashboard/tiers/settings',
        customers: '/admin/dashboard/customers',
        camareroMenuEditor: "/admin/dashboard/camarero/menu-editor", // Ruta actualizada
    };

    const isLoadingPage = loadingLayoutUser || loadingStats;

    const quickAccessCards = [
        {
            titleKey: 'adminOverview.cardRewardsTitle',
            descriptionKey: 'adminOverview.cardRewardsDesc',
            buttonTextKey: 'adminOverview.cardRewardsButton',
            icon: IconGift,
            color: 'blue',
            to: routes.rewards,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true,
        },
        {
            titleKey: 'adminOverview.cardTiersTitle',
            descriptionKey: 'adminOverview.cardTiersDesc',
            buttonTextKey: 'adminOverview.cardTiersButton',
            icon: IconStairsUp,
            color: 'teal',
            to: routes.manageTiers,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true,
        },
        {
            titleKey: 'adminOverview.cardTierSettingsTitle',
            descriptionKey: 'adminOverview.cardTierSettingsDesc',
            buttonTextKey: 'adminOverview.cardTierSettingsButton',
            icon: IconSettings,
            color: 'orange',
            to: routes.settingsTiers,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true,
        },
        {
            titleKey: 'adminOverview.cardQrTitle',
            descriptionKey: 'adminOverview.cardQrDesc',
            buttonTextKey: 'adminOverview.cardQrButton',
            icon: IconQrcode,
            color: 'grape',
            to: routes.generateQr,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true,
        },
        {
            titleKey: 'adminOverview.cardCustomersTitle',
            descriptionKey: 'adminOverview.cardCustomersDesc',
            buttonTextKey: 'adminOverview.cardCustomersButton',
            icon: IconUsers,
            color: 'indigo',
            to: routes.customers,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true || layoutUserData?.isCamareroActive === true,
        },
        // Tarjeta para Gesti√≥n de Men√∫ del M√≥dulo Camarero
        {
            titleKey: 'adminCamarero.manageMenu.title', // Usar clave de t√≠tulo de p√°gina para consistencia
            descriptionKey: 'adminCamarero.cardMenuDesc', // Clave para descripci√≥n de la tarjeta
            buttonTextKey: 'adminCamarero.cardMenuButton', // Clave para texto del bot√≥n
            icon: IconToolsKitchen,
            color: 'lime',
            to: routes.camareroMenuEditor, // Ruta correcta
            showCondition: layoutUserData?.isCamareroActive === true,
        },
    ];

    if (isLoadingPage && !statsData && !layoutUserData) {
        return <Container size="lg" mt="md"><Group justify="center" p="xl"><Loader /></Group></Container>;
    }

    return (
        <Container size="lg" mt="md">
            <Stack gap="xl">
                <Title order={2}>{t('adminOverview.welcome', { name: adminName || t('adminCommon.adminTitle') })}</Title>
                <Text fz="lg">
                    {t('adminOverview.panelIntro')}{' '}
                    <Text span fw={700}>{businessName || '...'}</Text>.
                </Text>
                <Text c="dimmed">{t('adminOverview.panelDescription')}</Text>

                <Title order={3} mt="lg">{t('adminOverview.quickSummaryTitle')}</Title>
                {loadingStats && !statsData && ( <Group justify="center" p="lg"><Loader size="sm" /></Group> )}
                {errorStats && !loadingStats && ( <Alert title={t('common.errorLoadingData')} color="red" icon={<IconAlertCircle size={18} />}>{errorStats}</Alert> )}
                {!loadingStats && !errorStats && statsData && (
                    <SimpleGrid cols={{ base: 1, sm: 2, lg: 4 }}>
                        <StatCard title={t('adminOverview.statActiveCustomers')} value={statsData.totalActiveCustomers} icon={<IconUsers size={24} stroke={1.5} />} color="blue" />
                        <StatCard title={t('adminOverview.statNewCustomers')} value={statsData.newCustomersLast7Days} icon={<IconUserPlus size={24} stroke={1.5} />} color="teal" trendValue={newCustomersTrend.trendValue} trendDirection={newCustomersTrend.trendDirection} />
                        <StatCard title={t('adminOverview.statPointsIssued')} value={statsData.pointsIssuedLast7Days} icon={<IconTicket size={24} stroke={1.5} />} color="grape" trendValue={pointsIssuedTrend.trendValue} trendDirection={pointsIssuedTrend.trendDirection} />
                        <StatCard title={t('adminOverview.statRedemptions')} value={statsData.rewardsRedeemedLast7Days} icon={<IconGift size={24} stroke={1.5} />} color="orange" trendValue={rewardsRedeemedTrend.trendValue} trendDirection={rewardsRedeemedTrend.trendDirection} />
                    </SimpleGrid>
                )}
                {!loadingStats && !errorStats && !statsData && ( <Text c="dimmed" ta="center">{t('adminOverview.noStatsAvailable')}</Text> )}

                <Title order={3} mt="lg">{t('adminOverview.quickAccessTitle')}</Title>
                <SimpleGrid cols={{ base: 1, sm: 2, md: 3 }}>
                    {quickAccessCards.filter(card => card.showCondition).map((card) => (
                        <Card shadow="sm" padding="lg" radius="md" withBorder key={card.to}>
                            <Group justify="space-between" mt="md" mb="xs">
                                <Text fw={500}>{t(card.titleKey)}</Text>
                                <card.icon size={24} stroke={1.5} />
                            </Group>
                            <Text size="sm" c="dimmed">{t(card.descriptionKey)}</Text>
                            <Button variant="light" color={card.color} fullWidth mt="md" radius="md" component={Link} to={card.to}>
                                {t(card.buttonTextKey)}
                            </Button>
                        </Card>
                    ))}
                </SimpleGrid>
                {quickAccessCards.filter(card => card.showCondition).length === 0 && !isLoadingPage && (
                    <Text c="dimmed" ta="center">{t('adminOverview.noModulesActivePrompt')}</Text>
                )}
            </Stack>
        </Container>
    );
};

export default AdminOverview;


// ====== [217] frontend/src/modules/loyalpyme/pages/admin/AdminRewardsManagement.tsx ======
// frontend/src/modules/loyalpyme/pages/admin/AdminRewardsManagement.tsx
// Version 1.4.5 - Corrected type import path & removed obsolete props from RewardForm

import React, { useState, useCallback } from 'react';
import {
    Group, Button, Title, Text, Loader, Alert, Paper, Stack,
    Table, Badge, ActionIcon, Tooltip, Modal,
} from '@mantine/core';
import { useDisclosure, useMediaQuery } from '@mantine/hooks';
import { useMantineTheme } from '@mantine/core';
import {
    IconAlertCircle, IconPencil, IconTrash, IconToggleLeft, IconToggleRight,
    IconPlus
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useAdminRewards } from '../../hooks/useAdminRewards';

// --- CORRECCI√ìN DE RUTA ---
import type { Reward } from '../../../../shared/types/user.types';
// --- FIN CORRECCI√ìN ---
import RewardForm from '../../components/admin/rewards/RewardForm';

const AdminRewardsManagement: React.FC = () => {
    const { t, i18n } = useTranslation();
    const { rewards, loading, error, actionLoading, fetchRewards, handleToggleActive, handleDeleteReward } = useAdminRewards();
    const [showAddForm, setShowAddForm] = useState<boolean>(false);
    const [editModalOpened, { open: openEditModalHandler, close: closeEditModal }] = useDisclosure(false);
    const [editingReward, setEditingReward] = useState<Reward | null>(null);
    const theme = useMantineTheme();
    const isMobile = useMediaQuery(`(max-width: ${theme.breakpoints.sm})`);

    const handleRewardAdded = useCallback(() => { setShowAddForm(false); fetchRewards(); }, [fetchRewards]);
    const handleOpenEditModal = (reward: Reward) => { setEditingReward(reward); openEditModalHandler(); };
    const handleCloseEditModal = () => { closeEditModal(); setEditingReward(null); };
    const handleRewardUpdated = useCallback(() => { handleCloseEditModal(); fetchRewards(); }, [fetchRewards, handleCloseEditModal]);

    const confirmAndDeleteReward = useCallback((reward: Reward) => {
        const displayName = (i18n.language === 'es' ? reward.name_es : reward.name_en) || reward.name_es || reward.name_en || `ID ${reward.id}`;
        if (window.confirm(t('adminRewardsPage.confirmDeleteMessage', { name: displayName }))) {
            handleDeleteReward(reward.id, displayName);
        }
    }, [handleDeleteReward, t, i18n.language]);


    const renderRewardsTable = () => {
        const rows = rewards.map((reward) => {
            const iconSize = 14;
            const isLoadingToggle = actionLoading?.type === 'toggle' && actionLoading?.id === reward.id;
            const isLoadingDelete = actionLoading?.type === 'delete' && actionLoading?.id === reward.id;
            const isAnyActionLoading = !!actionLoading;
            const displayName = (i18n.language === 'es' ? reward.name_es : reward.name_en) || reward.name_es || reward.name_en || '(Sin nombre)';

            const editIcon = (
                <Tooltip label={t('adminRewardsPage.tooltipEdit')} withArrow position={isMobile ? 'bottom' : 'left'}>
                    <ActionIcon variant="subtle" color="blue" onClick={() => handleOpenEditModal(reward)} disabled={isAnyActionLoading}>
                        <IconPencil size={iconSize} stroke={1.5} />
                    </ActionIcon>
                </Tooltip>
            );
            const toggleIcon = (
                <Tooltip label={reward.isActive ? t('adminRewardsPage.tooltipDeactivate') : t('adminRewardsPage.tooltipActivate')} withArrow position="top">
                    <ActionIcon variant="subtle" color={reward.isActive ? 'orange' : 'teal'} onClick={() => handleToggleActive(reward.id, reward.isActive)} loading={isLoadingToggle} disabled={isAnyActionLoading}>
                        {reward.isActive ? <IconToggleLeft size={iconSize} stroke={1.5} /> : <IconToggleRight size={iconSize} stroke={1.5} />}
                    </ActionIcon>
                </Tooltip>
            );
             const deleteIcon = (
                <Tooltip label={t('adminRewardsPage.tooltipDelete')} withArrow position={isMobile ? 'bottom' : 'right'}>
                    <ActionIcon variant="subtle" color="red" onClick={() => confirmAndDeleteReward(reward)} loading={isLoadingDelete} disabled={isAnyActionLoading}>
                        <IconTrash size={iconSize} stroke={1.5} />
                    </ActionIcon>
                </Tooltip>
             );

            return (
                <Table.Tr key={reward.id}>
                    <Table.Td fz={{ base: 'xs', sm: 'sm' }}>{displayName}</Table.Td>
                    <Table.Td fz={{ base: 'xs', sm: 'sm' }}>{reward.pointsCost}</Table.Td>
                    <Table.Td><Badge color={reward.isActive ? 'green' : 'gray'} variant="light" radius="lg" fz={{ base: 'xs', sm: 'sm' }}>{reward.isActive ? t('common.active') : t('common.inactive')}</Badge></Table.Td>
                    <Table.Td>
                        {isMobile ? (
                            <Stack gap={2} align="flex-end">
                                {editIcon}
                                {toggleIcon}
                                {deleteIcon}
                            </Stack>
                        ) : (
                            <Group gap="xs" justify="flex-end" wrap="nowrap">
                                {editIcon}
                                {toggleIcon}
                                {deleteIcon}
                            </Group>
                        )}
                    </Table.Td>
                </Table.Tr>
            );
        });

        return (
            <Table striped highlightOnHover withTableBorder withColumnBorders verticalSpacing="sm">
                <Table.Thead>
                    <Table.Tr>
                        <Table.Th fz={{ base: 'xs', sm: 'sm' }}>{t('adminRewardsPage.tableHeaderName')}</Table.Th>
                        <Table.Th fz={{ base: 'xs', sm: 'sm' }}>{t('adminRewardsPage.tableHeaderCost')}</Table.Th>
                        <Table.Th fz={{ base: 'xs', sm: 'sm' }}>{t('adminRewardsPage.tableHeaderStatus')}</Table.Th>
                        <Table.Th style={{ textAlign: 'right' }} fz={{ base: 'xs', sm: 'sm' }}>{t('adminRewardsPage.tableHeaderActions')}</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>{rows}</Table.Tbody>
            </Table>
        );
    };

    const renderRewardsSectionContent = () => { if (loading && rewards.length === 0) return <Group justify="center" p="lg"><Loader /></Group>; if (error && rewards.length === 0) return (<Alert icon={<IconAlertCircle size={16} />} title={t('common.errorLoadingData')} color="red" radius="lg">{error}</Alert>); if (!loading && rewards.length === 0 && !showAddForm) return <Text c="dimmed" ta="center" p="lg">{t('adminRewardsPage.noRewardsYet')}</Text>; if (rewards.length > 0) return renderRewardsTable(); return null; };

    return (
        <>
            <Paper shadow="xs" p="lg" withBorder radius="lg">
                <Stack gap="md">
                    <Group justify="space-between" align="flex-start">
                        <Title order={2}>{t('adminRewardsPage.title')}</Title>
                        <Button
                            leftSection={showAddForm ? undefined : <IconPlus size={18} />}
                            onClick={() => setShowAddForm(!showAddForm)}
                            disabled={loading && rewards.length === 0}
                            variant={showAddForm ? "outline" : "filled"}
                            radius="lg"
                        >
                            {showAddForm ? t('adminRewardsPage.cancelAddButton') : t('adminRewardsPage.addButton')}
                        </Button>
                    </Group>
                     {renderRewardsSectionContent()}
                    {showAddForm && (
                        <Paper withBorder p="md" mt="md" radius="lg">
                            {/* --- CORRECCI√ìN: Eliminar prop 'mode' --- */}
                            <RewardForm onSubmitSuccess={handleRewardAdded} onCancel={() => setShowAddForm(false)} />
                        </Paper>
                    )}
                </Stack>
            </Paper>
            <Modal
                opened={editModalOpened}
                onClose={handleCloseEditModal}
                title={t('adminRewardsPage.editFormTitle')}
                centered
                radius="lg"
                size="lg"
                overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
            >
                {editingReward && (
                    /* --- CORRECCI√ìN: Eliminar props 'mode' y 'rewardIdToUpdate' --- */
                    <RewardForm
                        initialData={editingReward}
                        onSubmitSuccess={handleRewardUpdated}
                        onCancel={handleCloseEditModal}
                    />
                )}
            </Modal>
        </>
    );
};

export default AdminRewardsManagement;


// ====== [218] frontend/src/modules/loyalpyme/pages/admin/tiers/TierManagementPage.tsx ======
// filename: frontend/src/pages/admin/tiers/TierManagementPage.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
    Paper, Title, Stack, Button, Group, Loader, Alert,
    Text
} from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { notifications } from '@mantine/notifications';
import { IconPlus, IconAlertCircle, IconCheck } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';
import { useTranslation } from 'react-i18next'; // Importar hook

// Importar componentes
import TierTable from '../../../components/admin/tiers/TierTable';
import CreateTierModal from '../../../components/admin/tiers/CreateTierModal';
import DeleteTierModal from '../../../components/admin/tiers/DeleteTierModal';
import EditTierModal from '../../../components/admin/tiers/EditTierModal';
import TierBenefitsModal from '../../../components/admin/tiers/TierBenefitsModal';

// Tipos
enum BenefitType { POINTS_MULTIPLIER = 'POINTS_MULTIPLIER', EXCLUSIVE_REWARD_ACCESS = 'EXCLUSIVE_REWARD_ACCESS', CUSTOM_BENEFIT = 'CUSTOM_BENEFIT' }
interface TierBenefit { id: string; isActive: boolean; type: BenefitType; value: string; description: string | null; }
interface Tier { id: string; name: string; level: number; minValue: number; description: string | null; benefitsDescription: string | null; isActive: boolean; benefits: TierBenefit[]; }


const TierManagementPage: React.FC = () => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    // Estado
    const [tiers, setTiers] = useState<Tier[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [deletingTier, setDeletingTier] = useState<Tier | null>(null);
    const [deleteModalOpened, { open: openDeleteModal, close: closeDeleteModal }] = useDisclosure(false);
    const [createModalOpened, { open: openCreateModal, close: closeCreateModal }] = useDisclosure(false);
    const [editingTier, setEditingTier] = useState<Tier | null>(null);
    const [editModalOpened, { open: openEditModal, close: closeEditModal }] = useDisclosure(false);
    const [viewingBenefitsForTier, setViewingBenefitsForTier] = useState<Tier | null>(null);
    const [benefitsModalOpened, { open: openBenefitsModal, close: closeBenefitsModal }] = useDisclosure(false);

    // L√≥gica de Datos
    const fetchTiers = useCallback(async () => {
        setLoading(true); setError(null);
        try {
            const response = await axiosInstance.get<Tier[]>('/tiers?includeBenefits=true');
            setTiers(response.data);
        } catch (err: any) {
            console.error("Error fetching tiers:", err);
            const message = err.response?.data?.message || t('adminCommon.errorLoadingData'); // Usar t() para error gen√©rico
            setError(message);
            notifications.show({
                title: t('common.errorLoadingData'), // T√≠tulo gen√©rico
                message: message,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
        } finally {
            setLoading(false);
        }
    }, [t]); // A√±adir t como dependencia

    useEffect(() => {
        fetchTiers();
    }, [fetchTiers]);

    // Handlers CRUD
    const handleCreate = () => { openCreateModal(); };
    const handleCreateSuccess = () => { fetchTiers(); }; // Ya no muestra notificaci√≥n, el modal lo hace
    const handleEdit = (tierId: string) => {
        const tierToEdit = tiers.find(t => t.id === tierId);
        if (tierToEdit) {
            setEditingTier(tierToEdit);
            openEditModal();
        } else {
            console.error(`Tier with ID ${tierId} not found for editing.`);
            notifications.show({
                title: t('common.error'), // T√≠tulo gen√©rico
                message: t('adminTiersManagePage.deleteErrorNotFound'), // Mensaje espec√≠fico
                color: 'orange'
            });
        }
    };
    const handleEditSuccess = () => { fetchTiers(); setEditingTier(null); }; // Notificaci√≥n en modal
    const confirmDelete = (tierId: string) => {
        const tierToDelete = tiers.find(t => t.id === tierId);
        if (tierToDelete) {
            setDeletingTier(tierToDelete);
            openDeleteModal(); // El modal DeleteTierModal ahora necesitar√° usar t() internamente
        }
    };
    const handleDelete = async () => {
        if (!deletingTier) return;
        const tierToDeleteId = deletingTier.id;
        const tierToDeleteName = deletingTier.name;
        closeDeleteModal();

        // Usar t() para las notificaciones de borrado
        notifications.show({
            id: `delete-tier-${tierToDeleteId}`,
            title: t('common.deleting', 'Eliminando...'), // Nueva clave
            message: t('adminTiersManagePage.deleteLoadingMessage', { name: tierToDeleteName }),
            loading: true,
            autoClose: false,
            withCloseButton: false,
        });

        try {
            await axiosInstance.delete(`/tiers/tiers/${tierToDeleteId}`);
            notifications.update({
                id: `delete-tier-${tierToDeleteId}`,
                title: t('adminTiersManagePage.deleteSuccessTitle'),
                message: t('adminTiersManagePage.deleteSuccessMessage', { name: tierToDeleteName }),
                color: 'green',
                icon: <IconCheck size={18} />,
                loading: false,
                autoClose: 4000,
            });
            setDeletingTier(null);
            fetchTiers();
        } catch (err: any) {
            console.error(`Error deleting tier ${tierToDeleteId}:`, err);
            const message = err.response?.data?.message || t('adminTiersManagePage.deleteErrorMessage');
            notifications.update({
                id: `delete-tier-${tierToDeleteId}`,
                title: t('adminTiersManagePage.deleteErrorTitle'),
                message: message,
                color: 'red',
                icon: <IconAlertCircle size={18} />,
                loading: false,
                autoClose: 6000,
            });
            setDeletingTier(null);
        }
    };
    const handleManageBenefits = (tier: Tier) => {
        setViewingBenefitsForTier(tier);
        openBenefitsModal(); // El modal TierBenefitsModal necesita usar t() internamente
    };

    // Renderizado
    return (
        <>
            <Paper shadow="sm" p="lg" withBorder radius="lg">
                <Stack gap="lg">
                    <Group justify="space-between">
                        <Title order={2}>{t('adminTiersManagePage.title')}</Title>
                        <Button leftSection={<IconPlus size={18} />} onClick={handleCreate}>
                            {t('adminTiersManagePage.addButton')}
                        </Button>
                    </Group>

                    {loading && <Group justify="center" mt="xl"><Loader /></Group>}
                    {error && !loading &&
                        <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>
                            {error}
                        </Alert>
                    }

                    {!loading && !error && (
                        // TierTable necesita i18n internamente
                        <TierTable
                            tiers={tiers}
                            onEditClick={handleEdit}
                            onDeleteClick={confirmDelete}
                            onManageBenefitsClick={handleManageBenefits}
                        />
                    )}
                    {!loading && !error && tiers.length === 0 && (
                        <Text c="dimmed" ta="center" mt="md">{t('adminTiersManagePage.noTiersDefined')}</Text>
                    )}
                </Stack>
            </Paper>

            {/* Modales (necesitan i18n internamente) */}
            <CreateTierModal
                opened={createModalOpened}
                onClose={closeCreateModal}
                onSuccess={handleCreateSuccess} />
            <DeleteTierModal
                opened={deleteModalOpened}
                onClose={() => { setDeletingTier(null); closeDeleteModal(); }}
                onConfirm={handleDelete}
                tierName={deletingTier?.name} />
            {editingTier && (
                <EditTierModal
                    opened={editModalOpened}
                    onClose={() => { setEditingTier(null); closeEditModal();}}
                    onSuccess={handleEditSuccess}
                    tier={editingTier} />
            )}
            {viewingBenefitsForTier && (
                <TierBenefitsModal
                    opened={benefitsModalOpened}
                    onClose={() => { setViewingBenefitsForTier(null); closeBenefitsModal(); }}
                    tier={viewingBenefitsForTier} />
            )}
        </>
    );
};

export default TierManagementPage;


// ====== [219] frontend/src/modules/loyalpyme/pages/admin/tiers/TierSettingsPage.tsx ======
// filename: frontend/src/pages/admin/tiers/TierSettingsPage.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
    Paper, Title, Stack, Switch, Select, NumberInput, Button, Loader, Alert, Group, LoadingOverlay, Text
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { notifications } from '@mantine/notifications';
import { IconAlertCircle, IconCheck, IconDeviceFloppy } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';
import { useTranslation } from 'react-i18next'; // Importar hook

// Tipos/Enums
enum TierCalculationBasis { SPEND = 'SPEND', VISITS = 'VISITS', POINTS_EARNED = 'POINTS_EARNED' }
enum TierDowngradePolicy { NEVER = 'NEVER', PERIODIC_REVIEW = 'PERIODIC_REVIEW', AFTER_INACTIVITY = 'AFTER_INACTIVITY' }

interface TierConfigData {
    tierSystemEnabled: boolean;
    tierCalculationBasis: TierCalculationBasis | null;
    tierCalculationPeriodMonths: number | null;
    tierDowngradePolicy: TierDowngradePolicy;
    inactivityPeriodMonths: number | null;
}

const TierSettingsPage: React.FC = () => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [isLoading, setIsLoading] = useState<boolean>(true);
    const [isSaving, setIsSaving] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    const form = useForm<TierConfigData>({
        initialValues: {
            tierSystemEnabled: false,
            tierCalculationBasis: null,
            tierCalculationPeriodMonths: null,
            tierDowngradePolicy: TierDowngradePolicy.NEVER,
            inactivityPeriodMonths: null,
        },
        // Validaci√≥n no necesita t() aqu√≠ directamente si los mensajes son gen√©ricos o manejados por Mantine/Zod
        validate: (values) => ({
            // L√≥gica de validaci√≥n se mantiene, los mensajes se pueden mejorar si es necesario
             tierCalculationBasis: (!values.tierSystemEnabled || values.tierCalculationBasis) ? null : t('common.requiredField'), // Ejemplo gen√©rico
             tierCalculationPeriodMonths: (!values.tierSystemEnabled || !values.tierCalculationBasis || values.tierCalculationBasis === TierCalculationBasis.POINTS_EARNED) ? null : (values.tierCalculationPeriodMonths === null || values.tierCalculationPeriodMonths <= 0) ? t('validation.mustBePositive', 'Debe ser > 0') : null, // Clave nueva propuesta
             inactivityPeriodMonths: (!values.tierSystemEnabled || values.tierDowngradePolicy !== TierDowngradePolicy.AFTER_INACTIVITY) ? null : (values.inactivityPeriodMonths === null || values.inactivityPeriodMonths <= 0) ? t('validation.mustBePositive', 'Debe ser > 0') : null, // Clave nueva propuesta
         }),
    });

    // fetchConfig (usar t() en mensajes de error)
    const fetchConfig = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        try {
            const response = await axiosInstance.get<TierConfigData>('/tiers/config');
            const fetchedConfig = {
                tierSystemEnabled: response.data.tierSystemEnabled ?? false,
                tierCalculationBasis: response.data.tierCalculationBasis ?? null,
                tierCalculationPeriodMonths: response.data.tierCalculationPeriodMonths ?? null,
                tierDowngradePolicy: response.data.tierDowngradePolicy ?? TierDowngradePolicy.NEVER,
                inactivityPeriodMonths: response.data.inactivityPeriodMonths ?? null,
            };
            form.setValues(fetchedConfig);
            form.resetDirty(fetchedConfig); // Asegurar que el estado inicial no est√© 'dirty'
            console.log("Config fetched and form set:", fetchedConfig);
        } catch (err: any) {
            console.error("Error fetching tier config:", err);
            const message = err.response?.data?.message || t('adminTiersSettingsPage.errorLoading');
            setError(message);
            notifications.show({ title: t('common.errorLoadingData'), message, color: 'red', icon: <IconAlertCircle size={18} /> });
        } finally {
            setIsLoading(false);
        }
     // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [t]); // A√±adir t como dependencia

    useEffect(() => {
        fetchConfig();
    }, [fetchConfig]);

    // handleSaveChanges (usar t() en mensajes de notificaci√≥n/error)
    const handleSaveChanges = async (values: TierConfigData) => {
        setIsSaving(true);
        setError(null);
        const dataToSend = { /* ... l√≥gica sin cambios ... */
            ...values,
             tierCalculationPeriodMonths: values.tierCalculationPeriodMonths || null,
             inactivityPeriodMonths: values.inactivityPeriodMonths || null,
             tierCalculationBasis: values.tierSystemEnabled ? values.tierCalculationBasis : null,
        };
         if (dataToSend.tierCalculationBasis === TierCalculationBasis.POINTS_EARNED) { dataToSend.tierCalculationPeriodMonths = null; }
         if (dataToSend.tierDowngradePolicy !== TierDowngradePolicy.AFTER_INACTIVITY) { dataToSend.inactivityPeriodMonths = null; }

        console.log("Saving config:", dataToSend);
        try {
            await axiosInstance.put('/tiers/config', dataToSend);
            notifications.show({
                title: t('adminTiersSettingsPage.successSaving'), // Usar t√≠tulo espec√≠fico
                message: t('adminTiersSettingsPage.successSaving'), // Usar mismo texto como mensaje por ahora
                color: 'green',
                icon: <IconCheck size={18} />
            });
            form.setValues(values);
            form.resetDirty(values); // Resetear dirty con los nuevos valores guardados
        } catch (err: any) {
            console.error("Error saving tier config:", err);
            const message = err.response?.data?.message || t('adminTiersSettingsPage.errorSaving');
            setError(message);
            notifications.show({
                title: t('adminCommon.saveError'), // T√≠tulo gen√©rico de error
                message,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
        } finally {
            setIsSaving(false);
        }
    };

    // Opciones para Selects (usando t())
    const basisOptions = Object.values(TierCalculationBasis).map(value => ({
        value,
        label: t(`adminTiersSettingsPage.basisOption_${value}`)
    }));
    const policyOptions = Object.values(TierDowngradePolicy).map(value => ({
        value,
        label: t(`adminTiersSettingsPage.downgradePolicyOption_${value}`)
    }));

    // Renderizado
    if (isLoading) {
        return <Group justify="center" mt="xl"><Loader /></Group>;
    }
    // Usar t() en t√≠tulo del Alert de error
    if (error && !isLoading && form.values.tierCalculationBasis === null && !form.values.tierSystemEnabled) {
        return <Alert title={t('common.errorLoadingData')} color="red" icon={<IconAlertCircle />}>{error}</Alert>;
    }

    return (
        <Paper shadow="sm" p="lg" withBorder radius="lg" style={{ position: 'relative' }}>
            <LoadingOverlay visible={isSaving} zIndex={1000} overlayProps={{ radius: "sm", blur: 2 }} />
            <Title order={2} mb="xl">{t('adminTiersSettingsPage.title')}</Title>
            <Text c="dimmed" size="sm" mb="lg">
                {t('adminTiersSettingsPage.description')}
            </Text>

            <form onSubmit={form.onSubmit(handleSaveChanges)}>
                <Stack gap="lg">
                    {/* Usar t() para labels y descriptions */}
                    <Switch
                        label={t('adminTiersSettingsPage.enableSystemLabel')}
                        description={t('adminTiersSettingsPage.enableSystemDescription')}
                        disabled={isSaving}
                        {...form.getInputProps('tierSystemEnabled', { type: 'checkbox' })}
                    />
                    <Select
                        label={t('adminTiersSettingsPage.basisLabel')}
                        placeholder={!form.values.tierSystemEnabled ? t('adminTiersSettingsPage.basisPlaceholderDisabled') : t('adminTiersSettingsPage.basisPlaceholder')}
                        data={basisOptions}
                        disabled={isSaving || !form.values.tierSystemEnabled}
                        clearable
                        description={t('adminTiersSettingsPage.basisDescription')}
                        {...form.getInputProps('tierCalculationBasis')}
                    />
                    <NumberInput
                        label={t('adminTiersSettingsPage.periodLabel')}
                        placeholder={!form.values.tierCalculationBasis || form.values.tierCalculationBasis === TierCalculationBasis.POINTS_EARNED ? t('adminTiersSettingsPage.periodPlaceholderNA') : t('adminTiersSettingsPage.periodPlaceholder')}
                        description={t('adminTiersSettingsPage.periodDescription')}
                        min={0}
                        step={1}
                        allowDecimal={false}
                        disabled={isSaving || !form.values.tierSystemEnabled || !form.values.tierCalculationBasis || form.values.tierCalculationBasis === TierCalculationBasis.POINTS_EARNED}
                        {...form.getInputProps('tierCalculationPeriodMonths')}
                    />
                    <Select
                        label={t('adminTiersSettingsPage.downgradePolicyLabel')}
                        placeholder={t('adminTiersSettingsPage.downgradePolicyPlaceholder')}
                        data={policyOptions}
                        disabled={isSaving || !form.values.tierSystemEnabled}
                        clearable={false}
                        description={t('adminTiersSettingsPage.downgradePolicyDescription')}
                        {...form.getInputProps('tierDowngradePolicy')}
                    />
                    {form.values.tierDowngradePolicy === TierDowngradePolicy.AFTER_INACTIVITY && (
                        <NumberInput
                            label={t('adminTiersSettingsPage.inactivityLabel')}
                            placeholder={t('adminTiersSettingsPage.inactivityPlaceholder')}
                            description={t('adminTiersSettingsPage.inactivityDescription')}
                            min={1}
                            step={1}
                            allowDecimal={false}
                            disabled={isSaving || !form.values.tierSystemEnabled}
                            required
                            {...form.getInputProps('inactivityPeriodMonths')}
                        />
                    )}

                    {error && (
                        <Alert title={t('common.error')} color="red" icon={<IconAlertCircle size="1rem" />} mt="md" withCloseButton onClose={() => setError(null)}>
                            {error}
                        </Alert>
                    )}

                    <Group justify="flex-end" mt="xl">
                        <Button
                            type="submit"
                            disabled={!form.isDirty() || isSaving}
                            loading={isSaving}
                            leftSection={<IconDeviceFloppy size={18} />}
                        >
                            {t('adminTiersSettingsPage.saveButton')}
                        </Button>
                    </Group>
                </Stack>
            </form>
        </Paper>
    );
};

export default TierSettingsPage;


// ====== [220] frontend/src/modules/loyalpyme/services/adminCustomerService.ts ======
// frontend/src/services/adminCustomerService.ts
import axiosInstance from '../../../shared/services/axiosInstance';
import { CustomerDetails } from '../components/admin/CustomerDetailsModal';
// Customer ya no se importa directamente aqu√≠ si la respuesta de la API es diferente

// ... (otros tipos de Payload sin cambios) ...
interface UpdateNotesPayload { notes: string | null; }
interface AdjustPointsPayload { amount: number; reason: string | null; }
interface ChangeTierPayload { tierId: string | null; }
interface AssignRewardPayload { rewardId: string; }
interface BulkStatusPayload { customerIds: string[]; isActive: boolean; }
interface BulkDeletePayload { customerIds: string[]; }
interface BulkAdjustPointsPayload { customerIds: string[]; amount: number; reason: string | null; }

// --- CORRECCI√ìN EN CustomerActionResponse ---
// Definir la estructura del objeto 'customer' que devuelve la API para estas acciones
interface CustomerUpdatePartial {
    id: string;
    points?: number;          // Hacer opcional si no siempre viene
    currentTierId?: string | null; // Propiedad directa del backend
    tierAchievedAt?: string | null; // Propiedad directa del backend
    isFavorite?: boolean;     // Hacer opcional
    isActive?: boolean;       // Hacer opcional
    // A√±adir cualquier otro campo que la API devuelva en el objeto 'customer'
}

export interface CustomerActionResponse {
    message: string;
    customer: CustomerUpdatePartial; // Usar el nuevo tipo
}
// --- FIN CORRECCI√ìN ---

export interface GrantedRewardIdResponse {
    message: string;
    grantedRewardId: string;
}

export interface BulkOperationResponse {
    message: string;
    count: number;
}

// --- Funciones del Servicio (sin cambios en la l√≥gica, solo usan el tipo corregido) ---

export const getCustomerDetailsApi = async (customerId: string): Promise<CustomerDetails> => {
    const response = await axiosInstance.get<CustomerDetails>(`/admin/customers/${customerId}/details`);
    return response.data;
};

export const updateCustomerNotesApi = async (customerId: string, notes: string | null): Promise<{ message: string }> => {
    const payload: UpdateNotesPayload = { notes };
    const response = await axiosInstance.patch<{ message: string }>(`/admin/customers/${customerId}/notes`, payload);
    return response.data;
};

export const adjustCustomerPointsApi = async (customerId: string, amount: number, reason: string | null): Promise<CustomerActionResponse> => {
    const payload: AdjustPointsPayload = { amount, reason };
    const response = await axiosInstance.post<CustomerActionResponse>(`/admin/customers/${customerId}/adjust-points`, payload);
    return response.data;
};

export const changeCustomerTierApi = async (customerId: string, tierId: string | null): Promise<CustomerActionResponse> => {
    const payload: ChangeTierPayload = { tierId };
    const response = await axiosInstance.put<CustomerActionResponse>(`/admin/customers/${customerId}/tier`, payload);
    return response.data;
};

export const assignRewardToCustomerApi = async (customerId: string, rewardId: string): Promise<GrantedRewardIdResponse> => {
    const payload: AssignRewardPayload = { rewardId };
    const response = await axiosInstance.post<GrantedRewardIdResponse>(`/admin/customers/${customerId}/assign-reward`, payload);
    return response.data;
};

export const toggleCustomerFavoriteApi = async (customerId: string): Promise<CustomerActionResponse> => {
    const response = await axiosInstance.patch<CustomerActionResponse>(`/admin/customers/${customerId}/toggle-favorite`);
    return response.data;
};

export const toggleCustomerActiveApi = async (customerId: string): Promise<CustomerActionResponse> => {
    const response = await axiosInstance.patch<CustomerActionResponse>(`/admin/customers/${customerId}/toggle-active`);
    return response.data;
};

export const bulkUpdateCustomerStatusApi = async (customerIds: string[], isActive: boolean): Promise<BulkOperationResponse> => {
    const payload: BulkStatusPayload = { customerIds, isActive };
    const response = await axiosInstance.patch<BulkOperationResponse>('/admin/customers/bulk-status', payload);
    return response.data;
};

export const bulkDeleteCustomersApi = async (customerIds: string[]): Promise<BulkOperationResponse> => {
    const payload: BulkDeletePayload = { customerIds };
    const response = await axiosInstance.delete<BulkOperationResponse>('/admin/customers/bulk-delete', { data: payload });
    return response.data;
};

export const bulkAdjustCustomerPointsApi = async (customerIds: string[], amount: number, reason: string | null): Promise<BulkOperationResponse> => {
    const payload: BulkAdjustPointsPayload = { customerIds, amount, reason };
    const response = await axiosInstance.post<BulkOperationResponse>('/admin/customers/bulk-adjust-points', payload);
    return response.data;
};


// ====== [221] frontend/src/modules/loyalpyme/services/adminService.ts ======
// filename: frontend/src/services/adminService.ts
// Version: 1.1.1 (Fix character encoding)

import axiosInstance from '../../../shared/services/axiosInstance'; // Usar instancia configurada

/**
 * Interface actualizada que define la estructura de los datos de estad√≠sticas
 * devueltos por el endpoint del backend /api/admin/stats/overview,
 * incluyendo datos del periodo anterior para calcular tendencias.
 */
export interface AdminOverviewStats {
    totalActiveCustomers: number;       // Valor puntual
    newCustomersLast7Days: number;
    newCustomersPrevious7Days: number; // Para tendencia
    pointsIssuedLast7Days: number;
    pointsIssuedPrevious7Days: number; // Para tendencia
    rewardsRedeemedLast7Days: number;   // Nota: Solo cuenta regalos canjeados actualmente
    rewardsRedeemedPrevious7Days: number;// Para tendencia
}

/**
 * Obtiene las estad√≠sticas clave (incluyendo datos previos) para el dashboard
 * del administrador desde la API.
 * @returns Una promesa que resuelve con el objeto AdminOverviewStats actualizado.
 * @throws Lanza un error si la petici√≥n a la API falla.
 */
export const getAdminDashboardStats = async (): Promise<AdminOverviewStats> => {
  console.log('[AdminService] Fetching dashboard overview stats (including previous period)...');
  try {
    // La petici√≥n GET sigue siendo la misma, espera la nueva estructura
    const response = await axiosInstance.get<AdminOverviewStats>('/admin/stats/overview');

    // AxiosInstance ya est√° tipado con la interfaz AdminOverviewStats
    console.log('[AdminService] Stats received (with previous period):', response.data);
    return response.data;

  } catch (error: any) {
    console.error('[AdminService] Error fetching extended dashboard stats:', error);
    const errorMessage = error.response?.data?.message ||
                           error.message ||
                           'Error desconocido al obtener estad√≠sticas extendidas.'; // Corregido: estad√≠sticas, desconocido
    // Relanzamos para que el hook/componente que llama lo maneje
    throw new Error(errorMessage);
  }
};

// End of file: frontend/src/services/adminService.ts


// ====== [222] frontend/src/modules/loyalpyme/types/history.types.ts ======
// frontend/src/modules/loyalpyme/types/history.types.ts
// Versi√≥n 1.1.1 - A√±adida la propiedad opcional `appliedLcoRewardId` a CustomerOrder.

export interface OrderHistoryModifier {
    optionNameSnapshot: string | null;
    optionPriceAdjustmentSnapshot: number;
}

export interface OrderHistoryItem {
    itemNameSnapshot: string | null;
    quantity: number;
    totalItemPrice: number;
    priceAtPurchase: number;
    redeemedRewardId: string | null;
    selectedModifiers: OrderHistoryModifier[];
}

export interface CustomerOrder {
    id: string;
    orderNumber: string;
    finalAmount: number;
    paidAt: string | null;
    items: OrderHistoryItem[];
    // --- L√çNEA A√ëADIDA ---
    appliedLcoRewardId?: string | null; // Hacerla opcional para no romper otros usos si no viene
    // --- FIN L√çNEA A√ëADIDA ---
}

export interface PaginatedOrdersResponse {
    orders: CustomerOrder[];
    totalPages: number;
    currentPage: number;
    totalItems: number;
}


// ====== [223] frontend/src/modules/superadmin/components/SubscriptionManagementModal.tsx ======
// frontend/src/modules/superadmin/components/SubscriptionManagementModal.tsx
// Version 1.0.1 - Corrected type import path

import React, { useState, useEffect, useCallback } from 'react';
import { Modal, Stack, Tabs, Title, Text, NumberInput, Button, Group, Table, Loader, Alert, Textarea, Select, LoadingOverlay, TextInput } from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { notifications } from '@mantine/notifications';
import { IconDeviceFloppy, IconHistory, IconSettings, IconCirclePlus, IconAlertCircle, IconCheck } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import * as superAdminService from '../services/superAdminService';

// --- CORRECCI√ìN DE RUTA ---
import { SuperAdminBusiness, BusinessPayment } from '../../../shared/types/superadmin.types';
// --- FIN CORRECCI√ìN ---

interface SubscriptionManagementModalProps {
    opened: boolean;
    onClose: () => void;
    business: SuperAdminBusiness | null;
    onSuccess: () => void;
}

const priceFormSchema = z.object({
    monthlyPrice: z.number().min(0, { message: 'El precio debe ser 0 o mayor.' }),
    currency: z.string().length(3, { message: 'La moneda debe ser un c√≥digo de 3 letras.' }),
});
type PriceFormValues = z.infer<typeof priceFormSchema>;

const paymentFormSchema = z.object({
    amountPaid: z.number().min(0.01, { message: 'El importe debe ser mayor que 0.' }),
    period: z.string().min(1, { message: 'Debe seleccionar un periodo.' }),
    notes: z.string().optional(),
    paymentMethod: z.string().optional(),
});
type PaymentFormValues = z.infer<typeof paymentFormSchema>;

const SubscriptionManagementModal: React.FC<SubscriptionManagementModalProps> = ({ opened, onClose, business, onSuccess }) => {
    const { i18n } = useTranslation();
    const [activeTab, setActiveTab] = useState<string | null>('config');
    const [isSaving, setIsSaving] = useState(false);
    
    const [paymentHistory, setPaymentHistory] = useState<BusinessPayment[]>([]);
    const [loadingHistory, setLoadingHistory] = useState(false);
    const [errorHistory, setErrorHistory] = useState<string | null>(null);

    const [pendingPeriods, setPendingPeriods] = useState<{ value: string; label: string; }[]>([]);
    const [loadingPeriods, setLoadingPeriods] = useState(false);

    const priceForm = useForm<PriceFormValues>({
        initialValues: { monthlyPrice: 0, currency: 'EUR' },
        validate: zodResolver(priceFormSchema),
    });

    const paymentForm = useForm<PaymentFormValues>({
        initialValues: { amountPaid: 0, period: '', notes: '', paymentMethod: 'Manual' },
        validate: zodResolver(paymentFormSchema),
    });
    
    const fetchDropdownData = useCallback(async () => {
        if (!business) return;
        setLoadingHistory(true);
        setLoadingPeriods(true);
        setErrorHistory(null);
        
        try {
            const historyPromise = superAdminService.getPaymentHistory(business.id);
            const periodsPromise = superAdminService.getPendingPaymentPeriods(business.id);

            const [history, periods] = await Promise.all([historyPromise, periodsPromise]);
            
            setPaymentHistory(history);
            
            const formattedPeriods = periods.map(p => ({
                value: `${p.year}-${p.month}`,
                label: p.label,
            }));
            setPendingPeriods(formattedPeriods);

            if (formattedPeriods.length > 0) {
                paymentForm.setFieldValue('period', formattedPeriods[0].value);
            }

        } catch (err: any) {
            setErrorHistory(err.message || "Error al cargar los datos del modal.");
        } finally {
            setLoadingHistory(false);
            setLoadingPeriods(false);
        }
    }, [business, paymentForm]);

    useEffect(() => {
        if (opened && business) {
            priceForm.setValues({ monthlyPrice: Number(business.monthlyPrice) || 0, currency: business.currency || 'EUR' });
            paymentForm.setFieldValue('amountPaid', Number(business.monthlyPrice) || 0);
            fetchDropdownData();
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, business]);

    const handleUpdatePrice = async (values: PriceFormValues) => {
        if (!business) return;
        setIsSaving(true);
        try {
            await superAdminService.setSubscriptionPrice(business.id, { price: values.monthlyPrice, currency: values.currency });
            notifications.show({ title: '√âxito', message: 'Precio de suscripci√≥n actualizado.', color: 'green', icon: <IconCheck/> });
            onSuccess();
        } catch (error: any) {
            notifications.show({ title: 'Error', message: error.response?.data?.message || error.message, color: 'red', icon: <IconAlertCircle/> });
        } finally {
            setIsSaving(false);
        }
    };

    const handleRecordPayment = async (values: PaymentFormValues) => {
        if (!business) return;
        
        const [year, month] = values.period.split('-').map(Number);
        if (!year || !month) {
            notifications.show({ title: 'Error', message: 'Periodo seleccionado no v√°lido.', color: 'red' });
            return;
        }

        setIsSaving(true);
        try {
            await superAdminService.recordPayment(business.id, {
                amountPaid: values.amountPaid,
                month: month,
                year: year,
                notes: values.notes,
                paymentMethod: values.paymentMethod
            });
            notifications.show({ title: '√âxito', message: 'Pago registrado correctamente.', color: 'green', icon: <IconCheck/> });
            
            paymentForm.reset();
            fetchDropdownData();
            onSuccess();
        } catch (error: any) {
            notifications.show({ title: 'Error', message: error.response?.data?.message || error.message, color: 'red', icon: <IconAlertCircle/> });
        } finally {
            setIsSaving(false);
        }
    };

    return (
        <Modal
            opened={opened}
            onClose={onClose}
            title={<Title order={4}>Gestionar Suscripci√≥n: {business?.name}</Title>}
            size="lg"
            centered
        >
            <LoadingOverlay visible={isSaving} />
            <Tabs value={activeTab} onChange={setActiveTab}>
                <Tabs.List>
                    <Tabs.Tab value="config" leftSection={<IconSettings size={16} />}>Configuraci√≥n</Tabs.Tab>
                    <Tabs.Tab value="payment" leftSection={<IconCirclePlus size={16} />}>Registrar Pago</Tabs.Tab>
                    <Tabs.Tab value="history" leftSection={<IconHistory size={16} />}>Historial</Tabs.Tab>
                </Tabs.List>

                <Tabs.Panel value="config" pt="md">
                    <form onSubmit={priceForm.onSubmit(handleUpdatePrice)}>
                        <Stack>
                            <Text size="sm">Establece el precio mensual que se le cobrar√° a este negocio.</Text>
                            <Group grow align="flex-end">
                                <NumberInput label="Precio Mensual" required min={0} decimalScale={2} {...priceForm.getInputProps('monthlyPrice')} />
                                <Select label="Moneda" data={['EUR', 'USD']} required {...priceForm.getInputProps('currency')} />
                            </Group>
                            <Group justify="flex-end" mt="md">
                                <Button type="submit" leftSection={<IconDeviceFloppy size={16}/>} loading={isSaving}>Guardar Precio</Button>
                            </Group>
                        </Stack>
                    </form>
                </Tabs.Panel>

                <Tabs.Panel value="payment" pt="md">
                     <form onSubmit={paymentForm.onSubmit(handleRecordPayment)}>
                        <Stack>
                            <Text size="sm">Registra un pago manual para un periodo espec√≠fico.</Text>
                            <Select
                                label="Periodo a Pagar"
                                placeholder={loadingPeriods ? "Cargando periodos..." : "Selecciona un mes pendiente"}
                                data={pendingPeriods}
                                required
                                disabled={pendingPeriods.length === 0 || loadingPeriods}
                                {...paymentForm.getInputProps('period')}
                            />
                            <NumberInput label="Importe Pagado" required min={0.01} decimalScale={2} {...paymentForm.getInputProps('amountPaid')} />
                            <Textarea label="Notas (Opcional)" placeholder="Ej: Pago parcial, referencia de transferencia..." {...paymentForm.getInputProps('notes')} />
                             <TextInput label="M√©todo de Pago (Opcional)" placeholder="Ej: Transferencia, Efectivo" {...paymentForm.getInputProps('paymentMethod')} />
                            <Group justify="flex-end" mt="md">
                                <Button type="submit" color="green" leftSection={<IconCheck size={16}/>} loading={isSaving} disabled={pendingPeriods.length === 0 || loadingPeriods}>
                                    {pendingPeriods.length > 0 ? "Registrar Pago" : "Sin meses pendientes"}
                                </Button>
                            </Group>
                        </Stack>
                    </form>
                </Tabs.Panel>
                
                <Tabs.Panel value="history" pt="md">
                    <Stack>
                        {loadingHistory && <Loader />}
                        {errorHistory && <Alert color="red" title="Error">{errorHistory}</Alert>}
                        {!loadingHistory && !errorHistory && paymentHistory.length === 0 && <Text c="dimmed" ta="center">No hay pagos registrados para este negocio.</Text>}
                        {!loadingHistory && !errorHistory && paymentHistory.length > 0 && (
                            <Table.ScrollContainer minWidth={500}>
                                <Table striped highlightOnHover>
                                    <Table.Thead>
                                        <Table.Tr>
                                            <Table.Th>Fecha</Table.Th>
                                            <Table.Th>Periodo</Table.Th>
                                            <Table.Th ta="right">Importe</Table.Th>
                                        </Table.Tr>
                                    </Table.Thead>
                                    <Table.Tbody>
                                        {paymentHistory.map(p => (
                                            <Table.Tr key={p.id}>
                                                <Table.Td>{new Date(p.paymentDate).toLocaleDateString(i18n.language)}</Table.Td>
                                                <Table.Td>{`${p.month}/${p.year}`}</Table.Td>
                                                <Table.Td ta="right">{p.amountPaid.toLocaleString(i18n.language, { style: 'currency', currency: 'EUR' })}</Table.Td>
                                            </Table.Tr>
                                        ))}
                                    </Table.Tbody>
                                </Table>
                            </Table.ScrollContainer>
                        )}
                    </Stack>
                </Tabs.Panel>
            </Tabs>
        </Modal>
    );
};

export default SubscriptionManagementModal;


// ====== [224] frontend/src/modules/superadmin/pages/SuperAdminPage.tsx ======
import React, { useEffect, useState, useCallback, useMemo } from 'react';
import {
    Container,
    Title,
    Table,
    Switch,
    ActionIcon,
    Tooltip,
    Loader,
    Alert,
    Group,
    Text,
    TextInput,
    Badge,
    Stack,
    SegmentedControl
} from '@mantine/core';
import {
    IconBuildingCommunity,
    IconLockOpen,
    IconLockOff,
    IconToolsKitchen2,
    IconHeartHandshake,
    IconAlertCircle,
    IconSearch,
    IconCash,
    IconSpy,
    IconCheck,
    IconX
} from '@tabler/icons-react';
import { useDisclosure } from '@mantine/hooks';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
import SubscriptionManagementModal from '../components/SubscriptionManagementModal';

// --- CAMBIO: Importar el tipo desde el archivo central ---
import { SuperAdminBusiness } from '../../../shared/types/superadmin.types';

const SuperAdminPage: React.FC = () => {
    const { t } = useTranslation();
    const [businesses, setBusinesses] = useState<SuperAdminBusiness[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [searchTerm, setSearchTerm] = useState('');
    const [statusFilter, setStatusFilter] = useState('ALL');
    
    const [subscriptionModalOpened, { open: openSubscriptionModal, close: closeSubscriptionModal }] = useDisclosure(false);
    const [selectedBusiness, setSelectedBusiness] = useState<SuperAdminBusiness | null>(null);
    
    const fetchBusinesses = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
            const response = await axiosInstance.get<SuperAdminBusiness[]>('/superadmin/businesses');
            setBusinesses(response.data);
        } catch (err: any) {
            console.error("Error fetching businesses for superadmin:", err);
            const message = err.response?.data?.message || t('common.errorLoadingData');
            setError(message);
        } finally {
            setLoading(false);
        }
    }, [t]);

    useEffect(() => {
        fetchBusinesses();
    }, [fetchBusinesses]);
    
    const handleManageSubscription = (business: SuperAdminBusiness) => {
        // Al pasar el objeto al estado, nos aseguramos que el tipo coincide con lo que el modal espera.
        // La conversi√≥n de string a number se maneja dentro del modal.
        setSelectedBusiness(business);
        openSubscriptionModal();
    };

    const handleToggleBusinessStatus = async (businessId: string, currentIsActive: boolean) => {
        const newStatus = !currentIsActive;
        const statusText = newStatus ? t('common.active') : t('common.inactive');
        const businessName = businesses.find(b => b.id === businessId)?.name || t('superAdminPage.businessFallbackName');
        try {
            await axiosInstance.patch(`/superadmin/businesses/${businessId}/status`, { isActive: newStatus });
            notifications.show({ title: t('common.success'), message: t('superAdminPage.statusChangeSuccess', { businessName, status: statusText.toLowerCase() }), color: 'green', icon: <IconCheck />, });
            fetchBusinesses();
        } catch (err: any) {
            const message = err.response?.data?.message || t('superAdminPage.statusChangeError');
            notifications.show({ title: t('common.error'), message, color: 'red', icon: <IconX /> });
        }
    };

    const handleToggleModule = async (businessId: string, moduleKey: 'loyaltycore' | 'camarero', currentIsActive: boolean) => {
        const newStatus = !currentIsActive;
        const moduleName = moduleKey === 'loyaltycore' ? t('superAdminPage.moduleLoyaltyCore') : t('superAdminPage.moduleCamarero');
        const statusText = newStatus ? t('common.active') : t('common.inactive');
        const businessName = businesses.find(b => b.id === businessId)?.name || t('superAdminPage.businessFallbackName');
        try {
            await axiosInstance.patch(`/superadmin/businesses/${businessId}/module-${moduleKey}`, { isActive: newStatus });
            notifications.show({ title: t('common.success'), message: t('superAdminPage.moduleChangeSuccess', { moduleName, status: statusText.toLowerCase(), businessName }), color: 'green', icon: <IconCheck />, });
            fetchBusinesses();
        } catch (err: any) {
            const message = err.response?.data?.message || t('superAdminPage.moduleChangeError', { moduleName });
            notifications.show({ title: t('common.error'), message, color: 'red', icon: <IconX /> });
        }
    };

    const handleImpersonate = (business: SuperAdminBusiness) => {
        console.log("Iniciar suplantaci√≥n para el admin de:", business.name);
        notifications.show({ title: t('common.upcomingFeatureTitle'), message: `Aqu√≠ se iniciar√≠a la suplantaci√≥n de identidad para el admin de ${business.name}.`, color: 'grape' });
    };
    
    const filteredBusinesses = useMemo(() => {
        return businesses
            .filter(business => 
                business.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                business.slug.toLowerCase().includes(searchTerm.toLowerCase())
            )
            .filter(business => {
                if (statusFilter === 'ALL') return true;
                return business.paymentStatus === statusFilter;
            });
    }, [businesses, searchTerm, statusFilter]);
    
    const rows = filteredBusinesses.map((business) => {
        const paymentStatusConfig = {
            PAID: { color: 'green', label: t('superAdminPage.statusPaid', 'Al d√≠a') },
            PENDING: { color: 'orange', label: t('superAdminPage.statusPending', 'Pendiente') },
            OVERDUE: { color: 'red', label: t('superAdminPage.statusOverdue', 'Atrasado') }
        };
        const statusInfo = paymentStatusConfig[business.paymentStatus];

        // Convertir el precio (que puede ser string) a n√∫mero para formatearlo
        const priceAsNumber = business.monthlyPrice !== null ? Number(business.monthlyPrice) : null;

        return (
            <Table.Tr key={business.id}>
                <Table.Td>
                    <Text fw={500}>{business.name}</Text>
                    <Text size="xs" c="dimmed">{business.slug}</Text>
                </Table.Td>
                
                <Table.Td>
                    <Text ta="right">{`${priceAsNumber !== null ? priceAsNumber.toFixed(2) : 'N/A'} ${business.currency}`}</Text>
                </Table.Td>

                <Table.Td>
                    <Badge color={statusInfo.color} variant="light">{statusInfo.label}</Badge>
                    {business.pendingMonths > 0 && (
                        <Text size="xs" c="dimmed">{`${business.pendingMonths} mes(es) pendiente(s)`}</Text>
                    )}
                </Table.Td>

                <Table.Td>
                    <Switch
                        checked={business.isLoyaltyCoreActive}
                        onChange={() => handleToggleModule(business.id, 'loyaltycore', business.isLoyaltyCoreActive)}
                        thumbIcon={<IconHeartHandshake size={12} />}
                        color="teal"
                        aria-label={t('superAdminPage.moduleLoyaltyCoreTooltip')}
                    />
                </Table.Td>
                <Table.Td>
                    <Switch
                        checked={business.isCamareroActive}
                        onChange={() => handleToggleModule(business.id, 'camarero', business.isCamareroActive)}
                        thumbIcon={<IconToolsKitchen2 size={12} />}
                        color="indigo"
                        aria-label={t('superAdminPage.moduleCamareroTooltip')}
                    />
                </Table.Td>

                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        <Tooltip label={t('superAdminPage.manageSubscriptionTooltip', "Gestionar Suscripci√≥n y Pagos")}>
                            <ActionIcon variant="subtle" color="blue" onClick={() => handleManageSubscription(business)}>
                                <IconCash size={18} />
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={business.isActive ? t('superAdminPage.tooltipDeactivateBusiness') : t('superAdminPage.tooltipActivateBusiness')}>
                            <ActionIcon variant="subtle" color={business.isActive ? 'red' : 'green'} onClick={() => handleToggleBusinessStatus(business.id, business.isActive)}>
                                {business.isActive ? <IconLockOff size={18} /> : <IconLockOpen size={18} />}
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={t('superAdminPage.impersonateTooltip', "Iniciar sesi√≥n como este administrador")}>
                             <ActionIcon variant="subtle" color="grape" onClick={() => handleImpersonate(business)}>
                                <IconSpy size={18} />
                            </ActionIcon>
                        </Tooltip>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    return (
        <>
            <Container size="xl" py="xl">
                <Stack gap="lg">
                    <Title order={2}>
                        <IconBuildingCommunity style={{ marginRight: '10px', verticalAlign: 'middle' }} />
                        {t('superAdminPage.title')}
                    </Title>
                    
                    <Group justify="space-between">
                        <TextInput
                            placeholder={t('superAdminPage.searchPlaceholder')}
                            leftSection={<IconSearch size={16} />}
                            value={searchTerm}
                            onChange={(event) => setSearchTerm(event.currentTarget.value)}
                            style={{ flex: 1 }}
                        />
                        <SegmentedControl
                            value={statusFilter}
                            onChange={setStatusFilter}
                            data={[
                                { label: t('superAdminPage.filterAll', 'Todos'), value: 'ALL' },
                                { label: t('superAdminPage.statusPaid', 'Al d√≠a'), value: 'PAID' },
                                { label: t('superAdminPage.statusPending', 'Pendientes'), value: 'PENDING' },
                                { label: t('superAdminPage.statusOverdue', 'Atrasados'), value: 'OVERDUE' },
                            ]}
                        />
                    </Group>

                    {loading && <Group justify="center" mt="xl"><Loader /></Group>}
                    {error && !loading && <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{error}</Alert>}
                    
                    {!loading && !error && (
                        <Table.ScrollContainer minWidth={900}>
                            <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                                <Table.Thead>
                                    <Table.Tr>
                                        <Table.Th>{t('superAdminPage.tableHeaderBusiness')}</Table.Th>
                                        <Table.Th ta="right">{t('superAdminPage.tableHeaderPrice', 'Precio/mes')}</Table.Th>
                                        <Table.Th>{t('superAdminPage.tableHeaderPaymentStatus', 'Estado de Pago')}</Table.Th>
                                        <Table.Th>{t('superAdminPage.tableHeaderLoyalty')}</Table.Th>
                                        <Table.Th>{t('superAdminPage.tableHeaderCamarero')}</Table.Th>
                                        <Table.Th ta="right">{t('common.actions', 'Acciones')}</Table.Th>
                                    </Table.Tr>
                                </Table.Thead>
                                <Table.Tbody>
                                    {rows.length > 0 ? rows : (
                                        <Table.Tr>
                                            <Table.Td colSpan={6} align="center">
                                                <Text c="dimmed">{searchTerm || statusFilter !== 'ALL' ? t('common.noResults') : t('superAdminPage.noBusinesses')}</Text>
                                            </Table.Td>
                                        </Table.Tr>
                                    )}
                                </Table.Tbody>
                            </Table>
                        </Table.ScrollContainer>
                    )}
                </Stack>
            </Container>

            <SubscriptionManagementModal
                opened={subscriptionModalOpened}
                onClose={() => {
                    closeSubscriptionModal();
                    setSelectedBusiness(null);
                }}
                business={selectedBusiness}
                onSuccess={() => {
                    fetchBusinesses();
                    closeSubscriptionModal();
                    setSelectedBusiness(null);
                }}
            />
        </>
    );
};

export default SuperAdminPage;


// ====== [225] frontend/src/modules/superadmin/services/superAdminService.ts ======
// frontend/src/services/superAdminService.ts

import axiosInstance from '../../../shared/services/axiosInstance';

// --- Tipos de Datos para Payloads y Respuestas ---

interface SetPricePayload {
    price: number;
    currency: string;
}

interface RecordPaymentPayload {
    amountPaid: number;
    month: number;
    year: number;
    notes?: string;
    paymentMethod?: string;
}

export interface BusinessPayment {
    id: string;
    paymentDate: string;
    amountPaid: number;
    month: number;
    year: number;
    paymentMethod: string | null;
    notes: string | null;
}

export interface UpdatedBusinessResponse {
    id: string;
    monthlyPrice: number | null;
    currency: string;
}

// --- NUEVO TIPO A√ëADIDO ---
// El tipo de dato para cada periodo pendiente que devuelve la API
export interface PendingPeriod {
    year: number;
    month: number;
    label: string; // ej. "Junio 2025"
}


// --- Funciones del Servicio ---

/**
 * Llama a la API para establecer el precio de suscripci√≥n de un negocio.
 */
export const setSubscriptionPrice = async (businessId: string, payload: SetPricePayload): Promise<UpdatedBusinessResponse> => {
    try {
        const response = await axiosInstance.put<UpdatedBusinessResponse>(`/superadmin/businesses/${businessId}/subscription`, payload);
        return response.data;
    } catch (error) {
        console.error(`[SuperAdminService] Error setting subscription price for business ${businessId}:`, error);
        throw error;
    }
};

/**
 * Llama a la API para registrar un nuevo pago manual.
 */
export const recordPayment = async (businessId: string, payload: RecordPaymentPayload): Promise<BusinessPayment> => {
    try {
        const response = await axiosInstance.post<BusinessPayment>(`/superadmin/businesses/${businessId}/payments`, payload);
        return response.data;
    } catch (error) {
        console.error(`[SuperAdminService] Error recording payment for business ${businessId}:`, error);
        throw error;
    }
};

/**
 * Llama a la API para obtener el historial de pagos de un negocio.
 */
export const getPaymentHistory = async (businessId: string): Promise<BusinessPayment[]> => {
    try {
        const response = await axiosInstance.get<BusinessPayment[]>(`/superadmin/businesses/${businessId}/payments`);
        return response.data || [];
    } catch (error) {
        console.error(`[SuperAdminService] Error fetching payment history for business ${businessId}:`, error);
        throw error;
    }
};

// --- NUEVA FUNCI√ìN A√ëADIDA ---
/**
 * Llama a la API para obtener los periodos de pago pendientes para un negocio.
 * @param businessId - El ID del negocio.
 * @returns Una lista de los periodos pendientes.
 */
export const getPendingPaymentPeriods = async (businessId: string): Promise<PendingPeriod[]> => {
    try {
        const response = await axiosInstance.get<PendingPeriod[]>(`/superadmin/businesses/${businessId}/pending-payments`);
        return response.data || [];
    } catch (error) {
        console.error(`[SuperAdminService] Error fetching pending payment periods for business ${businessId}:`, error);
        throw error;
    }
};


// ====== [226] frontend/src/pages/ForgotPasswordPage.tsx ======
// filename: frontend/src/pages/ForgotPasswordPage.tsx
// Version: 1.5.1 (Remove unused imports)

import { useState, FormEvent } from 'react';
// import { useNavigate, Link } from 'react-router-dom'; // Quitamos useNavigate
import { Link } from 'react-router-dom'; // Mantenemos Link
import axios from 'axios';
import {
    Container, Paper, Title, Text, Stack, TextInput, Button, Anchor
} from '@mantine/core';
import { notifications } from '@mantine/notifications';
// import { IconCheck, IconX, IconAlertCircle } from '@tabler/icons-react'; // Quitamos IconX
import { IconCheck, IconAlertCircle } from '@tabler/icons-react'; // Mantenemos los otros
import { useTranslation } from 'react-i18next';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000';

const ForgotPasswordPage: React.FC = () => {
    const { t } = useTranslation();
    // const navigate = useNavigate(); // Eliminado
    const [email, setEmail] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [messageSent, setMessageSent] = useState(false);

    const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        setIsLoading(true);
        setMessageSent(false);
        if (!email) {
             notifications.show({
                title: t('forgotPasswordPage.errorTitle'),
                message: t('forgotPasswordPage.errorMissingEmail'),
                color: 'orange',
                icon: <IconAlertCircle size={18}/>
            });
             setIsLoading(false);
             return;
        }
        try {
            await axios.post(`${API_BASE_URL}/api/auth/forgot-password`, { email });
             notifications.show({
                title: t('forgotPasswordPage.successTitle'),
                message: t('forgotPasswordPage.successMessage'),
                color: 'green',
                icon: <IconCheck size={18} />,
                autoClose: 7000
            });
            setMessageSent(true);
            setEmail('');
        } catch (error: any) {
            console.error('Error requesting password reset:', error);
             notifications.show({
                 title: t('forgotPasswordPage.errorGenericTitle'),
                 message: t('forgotPasswordPage.errorGenericMessage'),
                 color: 'blue',
                 autoClose: 7000
             });
             setMessageSent(true);
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Container size={480} my={40}>
             <Title ta="center" style={{ fontWeight: 900 }}>{t('forgotPasswordPage.title')}</Title>
             <Text c="dimmed" size="sm" ta="center" mt={5}>
                {t('forgotPasswordPage.subtitle')}{' '}
                <Anchor component={Link} to="/login" size="sm">{t('forgotPasswordPage.loginLink')}</Anchor>
             </Text>
            <Paper withBorder shadow="md" p={30} mt={30} radius="lg">
                <form onSubmit={handleSubmit}>
                    <Stack>
                        <Text size="sm" ta="center">{t('forgotPasswordPage.instructions')}</Text>
                        <TextInput
                            label={t('forgotPasswordPage.emailLabel')}
                            placeholder={t('forgotPasswordPage.emailPlaceholder')}
                            value={email}
                            onChange={(event) => setEmail(event.currentTarget.value)}
                            required
                            type="email"
                            disabled={isLoading || messageSent}
                        />
                        {messageSent && (
                           <Text c="green" ta="center" size="sm" mt="md">
                               {t('forgotPasswordPage.successTitle')}
                           </Text>
                         )}
                        <Button
                            type="submit"
                            loading={isLoading}
                            fullWidth
                            mt="xl"
                            radius="lg"
                            disabled={messageSent}
                        >
                            {t('forgotPasswordPage.buttonText')}
                        </Button>
                    </Stack>
                </form>
            </Paper>
         </Container>
    );
};

export default ForgotPasswordPage;

// End of File: frontend/src/pages/ForgotPasswordPage.tsx


// ====== [227] frontend/src/pages/HomePage.tsx ======
// frontend/src/pages/HomePage.tsx (CORREGIDO)
import React from 'react';
import { Container, Title, Text, Stack, Button, Group, Paper, ThemeIcon, SimpleGrid, useMantineTheme, useMantineColorScheme } from '@mantine/core';
import { Link } from 'react-router-dom';
import { useTranslation } from 'react-i18next';
// --- CAMBIO 1: Corregir importaci√≥n de iconos ---
import { IconBuildingStore, IconUserPlus, IconHeartHandshake, IconToolsKitchen2, IconChartArrowsVertical, IconArrowRight } from '@tabler/icons-react';
// --- FIN CAMBIO 1 ---

// Un peque√±o componente para las tarjetas de caracter√≠sticas
const FeatureCard: React.FC<{ icon: React.ReactNode; title: string; description: string }> = ({ icon, title, description }) => {
    const theme = useMantineTheme();
    return (
        <Paper withBorder radius="md" p="lg">
            <Stack align="center" ta="center">
                <ThemeIcon size={48} radius="xl" variant="light" color={theme.primaryColor}>
                    {icon}
                </ThemeIcon>
                <Title order={4} mt="sm">{title}</Title>
                <Text size="sm" c="dimmed">{description}</Text>
            </Stack>
        </Paper>
    );
};

const HomePage: React.FC = () => {
    const { t } = useTranslation();
    const theme = useMantineTheme();
    // --- CAMBIO 2: Usar el hook useMantineColorScheme ---
    const { colorScheme } = useMantineColorScheme();
    // --- FIN CAMBIO 2 ---

    return (
        <Container fluid p={0} style={{ backgroundColor: colorScheme === 'dark' ? theme.colors.dark[8] : theme.colors.gray[0] }}>
            {/* --- SECCI√ìN HERO (PRINCIPAL) --- */}
            <Container size="lg" py={{ base: 'xl', md: '5rem' }}>
                <Stack align="center" gap="xl">
                    <img
                        src="/loyalpymelogo.jpg"
                        alt="LoyalPyME Logo"
                        style={{ height: '90px', width: 'auto' }}
                    />
                    <Title order={1} ta="center" maw={700}>
                        {t('homePage.heroTitle', 'Fideliza Clientes y Digitaliza tu Servicio. Todo en un Mismo Lugar.')}
                    </Title>
                    <Text size="xl" c="dimmed" ta="center" maw={600}>
                        {t('homePage.heroSubtitle', 'LoyalPyME es la plataforma definitiva para que restaurantes, cafeter√≠as y PYMES creen programas de lealtad y optimicen su operativa con una carta digital inteligente.')}
                    </Text>

                    <Group mt="xl" justify="center">
                        <Button
                            component={Link}
                            to="/register-business"
                            size="lg"
                            radius="xl"
                            leftSection={<IconBuildingStore size={20} />}
                        >
                            {t('homePage.ctaBusiness', 'Crear Cuenta de Negocio')}
                        </Button>
                        <Button
                            component={Link}
                            to="/login"
                            size="lg"
                            radius="xl"
                            variant="default"
                            // --- CAMBIO 1 (Continuaci√≥n): Usar el nombre correcto del icono ---
                            leftSection={<IconUserPlus size={20} />}
                            // --- FIN CAMBIO 1 ---
                        >
                            {t('homePage.ctaLogin', 'Ya tengo una cuenta')}
                        </Button>
                    </Group>
                </Stack>
            </Container>

            {/* --- SECCI√ìN DE CARACTER√çSTICAS --- */}
            <Container size="lg" py={{ base: 'xl', md: '5rem' }}>
                <Stack align="center" gap="xs">
                    <Text c={theme.primaryColor} fw={700} tt="uppercase">
                        {t('homePage.featuresSection.superTitle', 'Potencia Tu Negocio')}
                    </Text>
                    <Title order={2} ta="center">
                        {t('homePage.featuresSection.title', 'Una Soluci√≥n, M√∫ltiples Beneficios')}
                    </Title>
                </Stack>
                <SimpleGrid cols={{ base: 1, sm: 2, lg: 3 }} spacing="xl" mt="xl">
                    <FeatureCard
                        icon={<IconHeartHandshake size={24} />}
                        title={t('homePage.features.loyalty.title', 'Programas de Lealtad')}
                        description={t('homePage.features.loyalty.desc', 'Crea un sistema de puntos y niveles para que tus clientes vuelvan una y otra vez. Recompensa su fidelidad con productos y beneficios exclusivos.')}
                    />
                    <FeatureCard
                        icon={<IconToolsKitchen2 size={24} />}
                        title={t('homePage.features.waiter.title', 'M√≥dulo Camarero Digital')}
                        description={t('homePage.features.waiter.desc', 'Digitaliza tu carta, permite que los clientes pidan desde su m√≥vil y optimiza la comunicaci√≥n con cocina a trav√©s de nuestro sistema KDS.')}
                    />
                    <FeatureCard
                        icon={<IconChartArrowsVertical size={24} />}
                        title={t('homePage.features.synergy.title', 'Sinergia Total')}
                        description={t('homePage.features.synergy.desc', 'Cuando un cliente pide desde la carta, ¬°autom√°ticamente gana puntos! Los dos m√≥dulos trabajan juntos para maximizar el engagement y las ventas.')}
                    />
                </SimpleGrid>
            </Container>

             {/* --- SECCI√ìN FINAL DE LLAMADA A LA ACCI√ìN --- */}
            <Container size="lg" py={{ base: 'xl', md: '5rem' }}>
                 <Paper withBorder p="xl" radius="lg" shadow="md" style={{
                     // --- CAMBIO 2 (Continuaci√≥n): Usar la variable del hook ---
                     backgroundColor: colorScheme === 'dark' ? theme.colors.dark[6] : theme.primaryColor,
                     // --- FIN CAMBIO 2 ---
                     color: theme.white,
                 }}>
                     <Group justify="space-between" align="center">
                         <Stack gap={0} style={{ flex: 1, minWidth: 0 }}>
                             <Title order={3}>
                                 {t('homePage.finalCta.title', '¬øListo para empezar?')}
                             </Title>
                             <Text maw={500}>
                                 {t('homePage.finalCta.desc', 'Crea tu cuenta hoy mismo y descubre c√≥mo LoyalPyME puede transformar tu negocio.')}
                             </Text>
                         </Stack>
                         <Button
                            component={Link}
                            to="/register-business"
                            size="lg"
                            variant="white"
                            color="dark"
                            radius="xl"
                            rightSection={<IconArrowRight size={18} />}
                         >
                            {t('homePage.ctaBusiness', 'Crear Cuenta de Negocio')}
                         </Button>
                     </Group>
                 </Paper>
            </Container>
        </Container>
    );
};

export default HomePage;


// ====== [228] frontend/src/pages/LoginPage.module.css ======
/* File: frontend/src/pages/LoginPage.module.css */
/* Version: 1.0.2 (Debug Styles) */

.loginPage {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    min-height: 90vh; /* Aumentar un poco la altura m√≠nima */
    padding: 20px;
    background-color: var(--color-background);
  }
  
  .card {
    background-color: var(--color-secondary);
    padding: 2rem 2.5rem;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    max-width: 450px;
    width: 100%;
    text-align: center;
    /* --- DEBUG: Forzar fuente --- */
    font-family: var(--font-family-sans);
  }
  
  .pageTitle {
      color: var(--color-primary);
      margin-bottom: 2rem;
      font-size: 2.2em;
  }
  
  .title {
    margin-bottom: 1.5rem;
    font-size: 1.8em;
    color: var(--color-text);
    border-bottom: none;
    font-family: var(--font-family-sans); /* Forzar fuente tambi√©n aqu√≠ */
  }
  
  .form {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    text-align: left;
    font-family: var(--font-family-sans); /* Forzar fuente en todo el form */
  }
  
  /* Bot√≥n de submit principal - con estilos de DEBUG */
  .button {
    /* Estilos originales comentados temporalmente
    background-color: var(--color-primary);
    color: white;
    border: none;
    */
    /* --- DEBUG: Estilos muy visibles --- */
    background-color: red !important;
    color: yellow !important;
    border: 3px solid black !important;
    display: block !important; /* Asegurar que sea bloque */
    width: 100%; /* Ocupar todo el ancho */
    /* --- FIN DEBUG --- */
  
    margin-top: 0.5rem;
    padding: 0.8em 1.2em;
    transition: background-color 0.2s ease;
    border-radius: 8px; /* Heredado de index.css, pero lo ponemos por si acaso */
    font-size: 1em; /* Heredado */
    font-weight: 500; /* Heredado */
    font-family: inherit; /* Heredado */
    cursor: pointer; /* Heredado */
  }
  .button:hover:not(:disabled) {
    /* background-color: var(--color-primary-light); */
    border-color: yellow !important; /* Borde amarillo en hover */
  }
  .button:disabled {
      background-color: grey !important; /* Gris si est√° deshabilitado */
      opacity: 0.7;
  }
  
  /* Mensaje de error */
  .error {
    color: var(--color-error);
    font-size: 0.9em;
    text-align: center;
    min-height: 1.2em;
    margin-top: 0.5rem;
  }
  
  /* End of File: frontend/src/pages/LoginPage.module.css */


// ====== [229] frontend/src/pages/LoginPage.tsx ======
// frontend/src/pages/LoginPage.tsx (MODIFICADO)
import { useState, FormEvent } from 'react';
import { useNavigate, Link } from 'react-router-dom'; // <-- useLocation ya no es necesario aqu√≠
import axiosInstance from '../shared/services/axiosInstance';
import { UserRole } from '../shared/types/user.types';
import type { UserData } from '../shared/types/user.types';
import { AxiosError } from 'axios';
import {
    TextInput, PasswordInput, Button, Paper, Title, Stack, Container,
    Alert, LoadingOverlay, Anchor, Group, Text, Divider
} from '@mantine/core';
import { IconAlertCircle } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

function LoginPage() {
    const { t } = useTranslation();
    const [email, setEmail] = useState<string>('');
    const [password, setPassword] = useState<string>('');
    const [error, setError] = useState<string | null>(null);
    const [loading, setLoading] = useState<boolean>(false);
    
    const navigate = useNavigate();
    // const location = useLocation(); // <-- YA NO ES NECESARIO

    const [slugInput, setSlugInput] = useState('');

    const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        setLoading(true);
        setError(null);
        const loginPath = '/auth/login'; 
        try {
            const response = await axiosInstance.post<{ user: UserData; token: string }>(
                loginPath, { email, password }
            );
            const { user, token } = response.data;

            if (user && token) {
                localStorage.setItem('token', token);
                localStorage.setItem('user', JSON.stringify(user));

                // --- CAMBIO PRINCIPAL: L√ìGICA DE REDIRECCI√ìN SIMPLIFICADA ---
                // Se elimina la comprobaci√≥n de 'location.state.from'.
                // Cada rol ahora tiene un destino fijo y √∫nico despu√©s del login.
                
                if (user.role === UserRole.CUSTOMER_FINAL) {
                    navigate('/customer/dashboard', { replace: true });
                } else if (user.role === UserRole.BUSINESS_ADMIN) {
                    navigate('/admin/dashboard', { replace: true });
                } else if (user.role === UserRole.SUPER_ADMIN) {
                    navigate('/superadmin', { replace: true });
                } else if (user.role === UserRole.WAITER) {
                    navigate('/admin/camarero/pickup', { replace: true });
                } else if (user.role === UserRole.KITCHEN_STAFF || user.role === UserRole.BAR_STAFF) {
                    navigate('/admin/kds', { replace: true });
                } else {
                    // Fallback de seguridad, deber√≠a redirigir a una p√°gina de inicio o de error.
                    navigate('/', { replace: true });
                }
                // --- FIN DEL CAMBIO ---

            } else {
                setError(t('loginPage.errorServer'));
            }
        } catch (err: unknown) {
            if (err instanceof AxiosError && err.response?.status === 401) {
                setError(t('loginPage.errorCredentials'));
            } else if (err instanceof AxiosError && err.response) {
                setError(err.response.data?.message || t('loginPage.errorServer'));
            } else if (err instanceof Error) {
                setError(err.message);
            } else {
                setError(t('loginPage.errorUnknown'));
            }
        } finally {
            setLoading(false);
        }
    };

    const handleGoToMenu = () => {
        if (slugInput.trim()) {
            navigate(`/m/${slugInput.trim()}`);
        }
    };

    return (
        <Container size="xs" p="md" style={{ minHeight: '90vh', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            <Paper shadow="md" p="xl" radius="lg" withBorder style={{ position: 'relative', width: '100%' }}>
                <LoadingOverlay visible={loading} zIndex={1000} overlayProps={{ radius: "sm", blur: 2 }} />
                <Title order={2} ta="center" mb="xl">{t('loginPage.title')}</Title>
                <form onSubmit={handleSubmit}>
                    <Stack gap="lg">
                        <TextInput
                            required
                            label={t('loginPage.emailLabel')}
                            placeholder={t('loginPage.emailPlaceholder')}
                            value={email}
                            onChange={(event) => setEmail(event.currentTarget.value)}
                            error={!!error}
                            radius="lg"
                        />
                        <PasswordInput
                            required
                            label={t('loginPage.passwordLabel')}
                            placeholder={t('loginPage.passwordPlaceholder')}
                            value={password}
                            onChange={(event) => setPassword(event.currentTarget.value)}
                            error={!!error}
                            radius="lg"
                        />
                        {error && (
                            <Alert icon={<IconAlertCircle size={16} />} title={t('common.error')} color="red" radius="lg" mt="md">
                                {error}
                            </Alert>
                        )}
                        <Group justify="space-between" mt="xl">
                            <Anchor component={Link} to="/forgot-password" c="dimmed" size="sm">
                                {t('loginPage.forgotPasswordLink')}
                            </Anchor>
                            <Button type="submit" loading={loading} radius="lg">
                                {t('loginPage.loginButton')}
                            </Button>
                        </Group>
                    </Stack>
                </form>
                <Text ta="center" mt="md">
                    {t('loginPage.subtitle')}{' '}
                    <Anchor component={Link} to="/register" size="sm">
                        {t('loginPage.registerLink')}
                    </Anchor>
                </Text>

                <Divider label="O" labelPosition="center" my="lg" />
                <Stack>
                    <TextInput
                        label={t('loginPage.accessMenuDirectlyTitle')}
                        placeholder={t('loginPage.businessSlugPlaceholder')}
                        value={slugInput}
                        onChange={(event) => setSlugInput(event.currentTarget.value)}
                        radius="lg"
                    />
                    <Button
                        variant="light"
                        onClick={handleGoToMenu}
                        disabled={!slugInput.trim()}
                        radius="lg"
                    >
                        {t('loginPage.goToMenuButton')}
                    </Button>
                </Stack>
            </Paper>
        </Container>
    );
}
export default LoginPage;


// ====== [230] frontend/src/pages/RegisterBusinessPage.tsx ======
// filename: frontend/src/pages/RegisterBusinessPage.tsx
// Version: 1.1.0 (Implement i18n using useTranslation)

import { useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import axios from 'axios';
import { notifications } from '@mantine/notifications';
import {
    Container, Paper, Title, Text, TextInput, PasswordInput, Button,
    LoadingOverlay, Alert, Stack, Anchor
} from '@mantine/core';
import { IconAlertCircle, IconCircleCheck } from '@tabler/icons-react';
// --- NUEVO: Importar useTranslation ---
import { useTranslation } from 'react-i18next';
// --- FIN NUEVO ---

// Esquema Zod (usando t() para mensajes, aunque requerir√≠a pasar t al schema o usar llaves fijas)
// Por simplicidad ahora, dejamos los mensajes fijos en espa√±ol aqu√≠, pero idealmente se usar√≠an claves
const registerBusinessSchema = z.object({
    businessName: z.string().min(2, { message: 'El nombre del negocio debe tener al menos 2 caracteres' }), // TODO: i18n key
    adminName: z.string().optional(),
    adminEmail: z.string().email({ message: 'Email inv√°lido' }), // TODO: i18n key
    adminPassword: z.string().min(6, { message: 'La contrase√±a debe tener al menos 6 caracteres' }), // TODO: i18n key
    confirmPassword: z.string().min(6, { message: 'La confirmaci√≥n de contrase√±a debe tener al menos 6 caracteres' }), // TODO: i18n key
}).refine((data) => data.adminPassword === data.confirmPassword, {
    message: "Las contrase√±as no coinciden", // TODO: i18n key
    path: ["confirmPassword"],
});

type RegisterBusinessFormValues = z.infer<typeof registerBusinessSchema>;
const REGISTER_BUSINESS_URL = `${import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000'}/api/auth/register-business`;

function RegisterBusinessPage() {
    // --- NUEVO: Hook useTranslation ---
    const { t } = useTranslation();
    // --- FIN NUEVO ---

    const navigate = useNavigate();
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const form = useForm<RegisterBusinessFormValues>({
        initialValues: { businessName: '', adminName: '', adminEmail: '', adminPassword: '', confirmPassword: '', },
        // TODO: Pasar la funci√≥n t al resolver si queremos traducir errores de Zod din√°micamente
        validate: zodResolver(registerBusinessSchema),
    });

    const handleSubmit = async (values: RegisterBusinessFormValues) => {
        setLoading(true);
        setError(null);
        const { confirmPassword, ...dataToSend } = values;
        if (!dataToSend.adminName?.trim()) { delete dataToSend.adminName; }

        try {
            const response = await axios.post(REGISTER_BUSINESS_URL, dataToSend);
            if (response.data.token && response.data.user) {
                 localStorage.setItem('token', response.data.token);
                 localStorage.setItem('user', JSON.stringify(response.data.user));
            }
            // --- CAMBIO: Usar t() en notificaciones ---
            notifications.show({
                 title: t('registerBusinessPage.successTitle'),
                 message: t('registerBusinessPage.successMessage', { businessName: values.businessName, adminEmail: values.adminEmail }), // Pasar variables
                 color: 'green',
                 icon: <IconCircleCheck />,
            });
             // --- FIN CAMBIO ---
            navigate('/admin/dashboard');
        } catch (err: unknown) {
            console.error("Registration error:", err);
            let errorMsg = t('registerBusinessPage.errorRegistration', 'No se pudo completar el registro. Int√©ntalo de nuevo.'); // Usar clave gen√©rica
            if (axios.isAxiosError(err) && err.response?.data?.message) { errorMsg = err.response.data.message; }
            else if (err instanceof Error) { errorMsg = err.message; }
            setError(errorMsg);
             // --- CAMBIO: Usar t() en notificaciones ---
             notifications.show({
                 title: t('registerBusinessPage.errorTitle'), message: errorMsg, color: 'red',
                 icon: <IconAlertCircle />,
             });
              // --- FIN CAMBIO ---
        } finally {
            setLoading(false);
        }
    };

    // --- JSX MODIFICADO ---
    return (
        <Container size={460} my={40}>
            <Paper withBorder shadow="md" p={30} radius="md" mt="xl" style={{ position: 'relative' }}>
                <LoadingOverlay visible={loading} overlayProps={{ radius: "sm", blur: 2 }} />
                {/* T√≠tulos y textos traducidos */}
                <Title ta="center" order={2}>{t('registerBusinessPage.title')}</Title>
                <Text c="dimmed" size="sm" ta="center" mt={5} mb={30}>
                    {t('registerBusinessPage.subtitle')}
                </Text>

                <form onSubmit={form.onSubmit(handleSubmit)}>
                    <Stack>
                        {/* Inputs con labels y placeholders traducidos */}
                        <TextInput
                            required
                            label={t('registerBusinessPage.businessNameLabel')}
                            placeholder={t('registerBusinessPage.businessNamePlaceholder')}
                            {...form.getInputProps('businessName')} />
                        <TextInput
                            label={t('registerBusinessPage.adminNameLabel')}
                            placeholder={t('registerBusinessPage.adminNamePlaceholder')}
                            {...form.getInputProps('adminName')} />
                        <TextInput
                            required
                            label={t('registerBusinessPage.adminEmailLabel')}
                            placeholder={t('registerBusinessPage.adminEmailPlaceholder')}
                            {...form.getInputProps('adminEmail')} />
                        <PasswordInput
                            required
                            label={t('registerBusinessPage.adminPasswordLabel')}
                            placeholder={t('registerBusinessPage.adminPasswordPlaceholder')}
                            {...form.getInputProps('adminPassword')} />
                        <PasswordInput
                            required
                            label={t('registerBusinessPage.confirmPasswordLabel')}
                            placeholder={t('registerBusinessPage.confirmPasswordPlaceholder')}
                            {...form.getInputProps('confirmPassword')} />

                        {/* Alert de error (sin cambios, usa estado 'error') */}
                        {error && (
                             <Alert title={t('common.error')} color="red" icon={<IconAlertCircle size="1rem" />} mt="md">
                                {error}
                            </Alert>
                         )}
                        {/* Bot√≥n traducido */}
                        <Button type="submit" fullWidth mt="xl" disabled={loading}>
                            {t('registerBusinessPage.registerButton')}
                        </Button>
                     </Stack>
                </form>

                 {/* Enlace traducido */}
                 <Text c="dimmed" size="sm" ta="center" mt="md">
                     {t('registerBusinessPage.loginLinkSubtitle')}{' '}
                     <Anchor component={Link} to="/login" size="sm">
                         {t('registerBusinessPage.loginLink')}
                     </Anchor>
                 </Text>
            </Paper>
        </Container>
    );
    // --- FIN JSX MODIFICADO ---
}

export default RegisterBusinessPage;

// End of File: frontend/src/pages/RegisterBusinessPage.tsx


// ====== [231] frontend/src/pages/RegisterPage.tsx ======
// frontend/src/pages/RegisterPage.tsx (MODIFICADO)
import { useState, useEffect } from 'react';
import { useNavigate, Link, useLocation } from 'react-router-dom'; // <-- A√ëADIDO useLocation
import axiosInstance from '../shared/services/axiosInstance';
import { getPublicBusinessList, BusinessOption } from '../shared/services/businessService';
import { AxiosError } from 'axios';
import {
    Container, Paper, Title, Text, Stack, TextInput, PasswordInput,
    Button, Select, Anchor, Loader, Group
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

// Los enums y la interfaz de formulario se quedan igual
enum DocumentType { DNI = 'DNI', NIE = 'NIE', PASSPORT = 'PASSPORT', OTHER = 'OTHER' }
enum UserRole { BUSINESS_ADMIN = 'BUSINESS_ADMIN', CUSTOMER_FINAL = 'CUSTOMER_FINAL' }

interface RegisterFormValues {
    email: string; password: string; confirmPassword: string; name: string; phone: string;
    documentType: DocumentType | null; documentId: string; businessId: string;
}

const RegisterPage: React.FC = () => {
    const { t } = useTranslation();
    const navigate = useNavigate();
    const location = useLocation(); // <-- Hook para obtener la ubicaci√≥n actual
    const role: UserRole = UserRole.CUSTOMER_FINAL;
    const [isLoading, setIsLoading] = useState(false);
    const documentTypeOptions = Object.values(DocumentType).map(value => ({ value, label: value }));
    const [businesses, setBusinesses] = useState<BusinessOption[]>([]);
    const [loadingBusinesses, setLoadingBusinesses] = useState<boolean>(true);
    const [errorBusinesses, setErrorBusinesses] = useState<string | null>(null);

    const form = useForm<RegisterFormValues>({
        initialValues: {
            email: '', password: '', confirmPassword: '', name: '', phone: '',
            documentType: null, documentId: '', businessId: '',
        },
        validate: {
            email: (value) => (!value ? t('common.requiredField') : !/^\S+@\S+\.\S+$/.test(value) ? t('registerPage.errorInvalidEmail') : null),
            password: (value) => (!value ? t('common.requiredField') : value.length < 6 ? t('registerPage.errorPasswordLength') : null),
            confirmPassword: (value, values) => (!value ? t('registerPage.errorConfirmPassword') : value !== values.password ? t('registerPage.errorPasswordsDontMatch') : null),
            phone: (value) => (!value ? t('common.requiredField') : !/^\+\d{9,15}$/.test(value) ? t('registerPage.errorPhoneFormat') : null),
            documentType: (value) => (value ? null : t('registerPage.errorDocType')),
            documentId: (value, values) => {
                 if (!value) return t('common.requiredField');
                 if (values.documentType === DocumentType.DNI && !/^\d{8}[A-Z]$/i.test(value)) return t('registerPage.errorDNIFormat');
                 if (values.documentType === DocumentType.NIE && !/^[XYZ]\d{7}[A-Z]$/i.test(value)) return t('registerPage.errorNIEFormat');
                 return null;
            },
            businessId: (value) => (value ? null : t('registerPage.errorBusinessRequired')),
        },
    });

    useEffect(() => {
        const fetchBusinesses = async () => {
            setLoadingBusinesses(true); setErrorBusinesses(null);
            try { const data = await getPublicBusinessList(); setBusinesses(data); }
            catch (err: any) { console.error("Error fetching businesses:", err); setErrorBusinesses(t('registerPage.errorLoadingBusinesses')); }
            finally { setLoadingBusinesses(false); }
        };
        fetchBusinesses();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    const handleSubmit = async (values: RegisterFormValues) => {
        setIsLoading(true);
        const registrationData = {
            email: values.email.trim(), password: values.password, name: values.name.trim() || undefined,
            phone: values.phone.trim(), documentId: values.documentId.trim().toUpperCase(), documentType: values.documentType,
            businessId: values.businessId, role,
         };
        const registerPath = '/auth/register';
        try {
            const response = await axiosInstance.post(registerPath, registrationData);
            console.log('Registration successful:', response.data);
            notifications.show({
                title: t('common.success'),
                message: t('registerPage.successMessage'),
                color: 'green', icon: <IconCheck size={18} />, autoClose: 4000,
            });
            
            // --- CAMBIO PRINCIPAL: L√ìGICA DE REDIRECCI√ìN ---
            // Despu√©s del registro exitoso, en lugar de ir siempre a login,
            // intentamos volver a la p√°gina anterior (la carta).
            // Si el registro fallara, no se llega a este punto.
            // Para una experiencia fluida, podr√≠amos incluso auto-loguear al usuario
            // y luego redirigirlo, pero por ahora, lo enviamos a loguearse con la redirecci√≥n correcta.
            setTimeout(() => {
                const fromPath = location.state?.from?.pathname;
                const fromSearch = location.state?.from?.search;
                const from = fromPath ? `${fromPath}${fromSearch || ''}` : null;
                
                // Le pasamos el 'from' a la p√°gina de login para que ella sepa a d√≥nde volver.
                navigate('/login', { state: { registrationSuccess: true, from: from ? { pathname: from } : null } });
            }, 1500);
            // --- FIN DEL CAMBIO ---

        } catch (err: unknown) {
            console.error('Error during registration:', err);
             let message = t('registerPage.errorRegistration');
            if (err instanceof AxiosError && err.response?.data?.message) { message = err.response.data.message; }
            else if (err instanceof Error) { message = err.message; }
             notifications.show({
                  title: t('common.error'), message: message, color: 'red', icon: <IconX size={18} />, autoClose: 6000,
             });
        } finally { setIsLoading(false); }
    };

    const businessSelectOptions = businesses.map(b => ({ value: b.id, label: b.name }));

    return (
        <Container size={480} my={40}>
             <Title ta="center" style={{ fontWeight: 900 }}>{t('registerPage.welcomeTitle')}</Title>
             <Text c="dimmed" size="sm" ta="center" mt={5}>
                 {t('registerPage.subtitle')}{' '}
                 <Anchor size="sm" component={Link} to="/login">{t('registerPage.loginLink')}</Anchor>
             </Text>
             <Paper withBorder shadow="md" p={30} mt={30} radius="lg">
                 <Title order={2} ta="center" mb="lg">{t('registerPage.title')}</Title>
                 <form onSubmit={form.onSubmit(handleSubmit)}>
                     <Stack>
                         <TextInput
                             label={t('registerPage.emailLabel')}
                             placeholder={t('registerPage.emailPlaceholder')}
                             required disabled={isLoading} {...form.getInputProps('email')} />
                         <PasswordInput
                             label={t('registerPage.passwordLabel')}
                             placeholder={t('registerPage.passwordPlaceholder')}
                             required disabled={isLoading} {...form.getInputProps('password')} />
                         <PasswordInput
                             label={t('registerPage.confirmPasswordLabel')}
                             placeholder={t('registerPage.confirmPasswordPlaceholder')}
                             required disabled={isLoading} {...form.getInputProps('confirmPassword')} />
                         <TextInput
                             label={t('registerPage.nameLabel')}
                             placeholder={t('registerPage.namePlaceholder')}
                             disabled={isLoading} {...form.getInputProps('name')} />
                         <TextInput
                             label={t('registerPage.phoneLabel')}
                             placeholder={t('registerPage.phonePlaceholder')}
                             required disabled={isLoading} {...form.getInputProps('phone')} />
                         <Select
                             label={t('registerPage.docTypeLabel')}
                             placeholder={t('registerPage.docTypePlaceholder')}
                             data={documentTypeOptions} required disabled={isLoading} clearable={false} {...form.getInputProps('documentType')} />
                         <TextInput
                             label={t('registerPage.docIdLabel')}
                             placeholder={t('registerPage.docIdPlaceholder')}
                             required disabled={isLoading} {...form.getInputProps('documentId')} />
                         <Select
                             label={t('registerPage.businessLabel')}
                             placeholder={loadingBusinesses ? t('registerPage.businessSelectLoading') : t('registerPage.businessSelectPlaceholder')}
                             data={businessSelectOptions}
                             required
                             disabled={isLoading || loadingBusinesses || businesses.length === 0}
                             searchable
                             nothingFoundMessage={errorBusinesses ? t('registerPage.businessSelectError') : t('registerPage.businessSelectNotFound')}
                             clearable={false}
                             error={errorBusinesses}
                             {...form.getInputProps('businessId')}
                         />
                         {loadingBusinesses && <Group justify='center'><Loader size="xs" /></Group>}
                         <Button type="submit" loading={isLoading} fullWidth mt="xl" radius="lg">
                             {t('registerPage.registerButton')}
                         </Button>
                      </Stack>
                 </form>
             </Paper>
        </Container>
    );
};

export default RegisterPage;


// ====== [232] frontend/src/pages/ResetPasswordPage.tsx ======
// filename: frontend/src/pages/ResetPasswordPage.tsx
// Version: 1.1.0 (Implement i18n using useTranslation)

import { useState, useEffect, FormEvent } from 'react';
import { useNavigate, useParams, Link } from 'react-router-dom';
import axios from 'axios';
import {
    Container, Paper, Title, Text, Stack, PasswordInput, Button, Anchor
} from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX, IconAlertCircle } from '@tabler/icons-react';
// --- NUEVO: Importar useTranslation ---
import { useTranslation } from 'react-i18next';
// --- FIN NUEVO ---


const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000';

const ResetPasswordPage: React.FC = () => {
    // --- NUEVO: Hook useTranslation ---
    const { t } = useTranslation();
    // --- FIN NUEVO ---

    const navigate = useNavigate();
    const { token } = useParams<{ token: string }>();

    const [password, setPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [isLoading, setIsLoading] = useState(false);

    useEffect(() => {
        if (!token) {
            console.error('No reset token found in URL parameters.');
            // --- CAMBIO: Usar t() en notificaci√≥n ---
            notifications.show({
                title: t('resetPasswordPage.errorTitle'),
                message: t('resetPasswordPage.errorMissingToken'),
                color: 'red',
                icon: <IconX size={18} />,
                autoClose: false,
            });
            // --- FIN CAMBIO ---
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [token]); // t() no necesita ser dependencia aqu√≠ generalmente


    const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
        event.preventDefault();

        if (!token) {
             // --- CAMBIO: Usar t() en notificaci√≥n ---
             notifications.show({
                title: t('resetPasswordPage.errorTitle'),
                message: t('resetPasswordPage.errorMissingToken'),
                color: 'red',
                icon: <IconX size={18} />
            });
            // --- FIN CAMBIO ---
            return;
        }
        if (!password || !confirmPassword) {
             // --- CAMBIO: Usar t() en notificaci√≥n ---
             notifications.show({
                title: t('common.error'), // Usar clave com√∫n
                message: t('resetPasswordPage.errorPasswordsRequired'),
                color: 'orange',
                icon: <IconAlertCircle size={18}/>
            });
             // --- FIN CAMBIO ---
            return;
        }
        if (password !== confirmPassword) {
             // --- CAMBIO: Usar t() en notificaci√≥n ---
             notifications.show({
                title: t('common.error'),
                message: t('resetPasswordPage.errorPasswordsDontMatch'),
                color: 'orange',
                icon: <IconAlertCircle size={18}/>
            });
             // --- FIN CAMBIO ---
            return;
        }
        if (password.length < 6) {
             // --- CAMBIO: Usar t() en notificaci√≥n ---
            notifications.show({
                title: t('resetPasswordPage.errorTitle'), // T√≠tulo espec√≠fico? O com√∫n?
                message: t('resetPasswordPage.errorPasswordLength'),
                color: 'orange',
                icon: <IconAlertCircle size={18}/>
            });
            // --- FIN CAMBIO ---
            return;
        }

        setIsLoading(true);

        try {
            const resetUrl = `${API_BASE_URL}/api/auth/reset-password/${token}`;
            await axios.post(resetUrl, { password });

            // --- CAMBIO: Usar t() en notificaci√≥n ---
            notifications.show({
                title: t('resetPasswordPage.successTitle'),
                message: t('resetPasswordPage.successMessage'),
                color: 'green', icon: <IconCheck size={18} />, autoClose: 5000,
            });
            // --- FIN CAMBIO ---

            setTimeout(() => {
                navigate('/login', { state: { passwordResetSuccess: true } });
            }, 2000);
        } catch (error: any) {
            console.error('Error resetting password:', error);
            const message = error.response?.data?.message || t('resetPasswordPage.errorInvalidToken');
            // --- CAMBIO: Usar t() en notificaci√≥n ---
            notifications.show({
                title: t('resetPasswordPage.errorTitle'),
                message: message,
                color: 'red',
                icon: <IconX size={18} />,
                autoClose: 6000,
            });
            // --- FIN CAMBIO ---
        } finally {
            setIsLoading(false);
        }
    };

    // --- JSX MODIFICADO ---
    return (
         <Container size={480} my={40}>
             <Title ta="center" style={{ fontWeight: 900 }}>{t('resetPasswordPage.title')}</Title>
             <Text c="dimmed" size="sm" ta="center" mt={5}>{t('resetPasswordPage.subtitle')}</Text>

             <Paper withBorder shadow="md" p={30} mt={30} radius="lg">
                 {token ? (
                     <form onSubmit={handleSubmit}>
                         <Stack>
                             <PasswordInput
                                 label={t('resetPasswordPage.passwordLabel')}
                                 placeholder={t('resetPasswordPage.passwordPlaceholder')}
                                 value={password}
                                 onChange={(event) => setPassword(event.currentTarget.value)}
                                 required
                                 disabled={isLoading} />
                             <PasswordInput
                                 label={t('resetPasswordPage.confirmPasswordLabel')}
                                 placeholder={t('resetPasswordPage.confirmPasswordPlaceholder')}
                                 value={confirmPassword}
                                 onChange={(event) => setConfirmPassword(event.currentTarget.value)}
                                 required
                                 disabled={isLoading} />
                             <Button
                                 type="submit"
                                 loading={isLoading}
                                 fullWidth
                                 mt="xl"
                                 radius="lg"
                             >
                                 {t('resetPasswordPage.buttonText')}
                             </Button>
                         </Stack>
                     </form>
                  ) : (
                      <Text color="red" ta="center">{t('resetPasswordPage.errorMissingToken')}</Text>
                  )}
                  <Text ta="center" mt="md">
                      <Anchor component={Link} to="/login" size="sm">{t('resetPasswordPage.loginLink')}</Anchor>
                  </Text>
            </Paper>
         </Container>
    );
    // --- FIN JSX MODIFICADO ---
};

export default ResetPasswordPage;

// End of File: frontend/src/pages/ResetPasswordPage.tsx


// ====== [233] frontend/src/routes/index.tsx ======
// frontend/src/routes/index.tsx (MODIFICADO)
import { Routes, Route, Navigate, Outlet } from 'react-router-dom';

// --- SHARED ---
import PrivateRoute from '../shared/components/PrivateRoute';
import MainLayout from '../shared/components/layout/MainLayout';
import PublicLayout from '../shared/components/layout/PublicLayout';
import PublicRouteOnly from '../shared/components/PublicRouteOnly'; // <-- NUEVA IMPORTACI√ìN
import { UserRole } from '../shared/types/user.types';

// --- P√ÅGINAS P√öBLICAS ---
import LoginPage from '../pages/LoginPage';
import RegisterPage from '../pages/RegisterPage';
import ForgotPasswordPage from '../pages/ForgotPasswordPage';
import ResetPasswordPage from '../pages/ResetPasswordPage';
import RegisterBusinessPage from '../pages/RegisterBusinessPage';
import HomePage from '../pages/HomePage';

// --- P√ÅGINAS DE M√ìDULOS ---
// M√≥dulo Camarero
import PublicMenuViewPage from '../modules/camarero/pages/PublicMenuViewPage';
import OrderStatusPage from '../modules/camarero/pages/OrderStatusPage';
import KitchenDisplayPage from '../modules/camarero/pages/admin/camarero/KitchenDisplayPage';
import MenuManagementPage from '../modules/camarero/pages/admin/camarero/MenuManagementPage';
import WaiterOrderManagementPage from '../modules/camarero/pages/admin/camarero/WaiterOrderManagementPage';
import WaiterPickupPage from '../modules/camarero/pages/admin/camarero/WaiterPickupPage';
// M√≥dulo LoyalPyME
import CustomerDashboardPage from '../modules/loyalpyme/pages/CustomerDashboardPage';
import AdminOverview from '../modules/loyalpyme/pages/admin/AdminOverview';
import AdminRewardsManagement from '../modules/loyalpyme/pages/admin/AdminRewardsManagement';
import AdminGenerateQr from '../modules/loyalpyme/pages/admin/AdminGenerateQr';
import TierSettingsPage from '../modules/loyalpyme/pages/admin/tiers/TierSettingsPage';
import TierManagementPage from '../modules/loyalpyme/pages/admin/tiers/TierManagementPage';
import AdminCustomerManagementPage from '../modules/loyalpyme/pages/admin/AdminCustomerManagementPage';
// M√≥dulo SuperAdmin
import SuperAdminPage from '../modules/superadmin/pages/SuperAdminPage';


function AppRoutes() {
  return (
    <Routes>
      {/* Rutas P√∫blicas */}
      <Route element={<PublicLayout />}>
        {/* --- CAMBIO: ENVOLVER RUTAS DE AUTH EN PublicRouteOnly --- */}
        <Route element={<PublicRouteOnly />}>
          {/* Estas rutas solo ser√°n accesibles si el usuario NO est√° logueado */}
          <Route path="/login" element={<LoginPage />} />
          <Route path="/register" element={<RegisterPage />} />
          <Route path="/register-business" element={<RegisterBusinessPage />} />
          <Route path="/forgot-password" element={<ForgotPasswordPage />} />
          <Route path="/reset-password/:token" element={<ResetPasswordPage />} />
        </Route>
        {/* --- FIN DEL CAMBIO --- */}
        
        {/* Estas rutas son siempre p√∫blicas, para usuarios logueados o no */}
        <Route path="/" element={<HomePage />} />
        <Route path="/m/:businessSlug/:tableIdentifier?" element={<PublicMenuViewPage />} />
        <Route path="/order-status/:orderId" element={<OrderStatusPage />} />
      </Route>

      {/* Rutas Protegidas (sin cambios) */}
      <Route element={<MainLayout />}>
        <Route
            path="/superadmin"
            element={ <PrivateRoute allowedRoles={[UserRole.SUPER_ADMIN]}><SuperAdminPage /></PrivateRoute> }
        />
        <Route path="/admin" element={<Outlet />}>
            <Route path="dashboard" element={<PrivateRoute allowedRoles={[UserRole.BUSINESS_ADMIN]}><Outlet /></PrivateRoute>}>
                <Route index element={<AdminOverview />} />
                <Route path="rewards" element={<AdminRewardsManagement />} />
                <Route path="generate-qr" element={<AdminGenerateQr />} />
                <Route path="tiers/settings" element={<TierSettingsPage />} />
                <Route path="tiers/manage" element={<TierManagementPage />} />
                <Route path="customers" element={<AdminCustomerManagementPage />} />
                <Route path="camarero/menu-editor" element={<MenuManagementPage />} />
            </Route>
            <Route path="kds" element={<PrivateRoute allowedRoles={[UserRole.KITCHEN_STAFF, UserRole.BAR_STAFF, UserRole.BUSINESS_ADMIN]}><KitchenDisplayPage /></PrivateRoute>} />
            <Route path="camarero/pickup" element={<PrivateRoute allowedRoles={[UserRole.WAITER, UserRole.BUSINESS_ADMIN]}><WaiterPickupPage /></PrivateRoute>} />
            <Route path="camarero/orders" element={<PrivateRoute allowedRoles={[UserRole.WAITER, UserRole.BUSINESS_ADMIN]}><WaiterOrderManagementPage /></PrivateRoute>} />
            <Route index element={<PrivateRoute allowedRoles={[UserRole.BUSINESS_ADMIN, UserRole.KITCHEN_STAFF, UserRole.BAR_STAFF, UserRole.WAITER]}><Navigate to="dashboard" replace /></PrivateRoute>} />
        </Route>
        <Route
            path="/customer/dashboard"
            element={ <PrivateRoute allowedRoles={[UserRole.CUSTOMER_FINAL]}><CustomerDashboardPage /></PrivateRoute> }
        />
      </Route>
    </Routes>
  );
}

export default AppRoutes;


// ====== [234] frontend/src/shared/components/PrivateRoute.tsx ======
// frontend/src/shared/components/PrivateRoute.tsx (CORREGIDO)
import React from 'react';
import { Navigate, Outlet, useLocation } from 'react-router-dom';

// --- RUTA Y NOMBRE CORREGIDOS ---
import { UserRole } from '../types/user.types';
// --- FIN CORRECCI√ìN ---


interface PrivateRouteProps {
  allowedRoles?: UserRole[];
  children?: React.ReactNode;
}

function PrivateRoute({ allowedRoles, children }: PrivateRouteProps) {
  const location = useLocation();

  const token = localStorage.getItem('token');
  if (!token) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  const userJson = localStorage.getItem('user');
  let user = null;
  try {
      if(userJson) user = JSON.parse(userJson);
  } catch (e) {
      console.error("[PrivateRoute] Failed to parse user from localStorage", e);
      localStorage.removeItem('token');
      localStorage.removeItem('user');
      return <Navigate to="/login" state={{ from: location }} replace />;
  }

  if (!user || (allowedRoles && allowedRoles.length > 0 && (!user.role || !allowedRoles.includes(user.role as UserRole)))) {
    const fallbackPath = user?.role === UserRole.BUSINESS_ADMIN ? '/admin/dashboard'
                       : user?.role === UserRole.CUSTOMER_FINAL ? '/customer/dashboard'
                       : user?.role === UserRole.SUPER_ADMIN ? '/superadmin'
                       // --- A√ëADIDO: Redirecci√≥n para roles de staff ---
                       : user?.role === UserRole.WAITER ? '/admin/camarero/pickup'
                       : user?.role === UserRole.KITCHEN_STAFF || user.role === UserRole.BAR_STAFF ? '/admin/kds'
                       // --- FIN A√ëADIDO ---
                       : '/login';
    return <Navigate to={fallbackPath} replace />;
  }

  return <>{children || <Outlet />}</>;
}

export default PrivateRoute;


// ====== [235] frontend/src/shared/components/PublicRouteOnly.tsx ======
// frontend/src/shared/components/PublicRouteOnly.tsx (NUEVO ARCHIVO)
import React from 'react';
import { Navigate, Outlet } from 'react-router-dom';
import { useLayoutUserData } from '../hooks/useLayoutUserData';
import { UserRole } from '../types/user.types';
import { Loader, Center } from '@mantine/core';

const PublicRouteOnly: React.FC = () => {
    const { userData, loadingUser } = useLayoutUserData();

    // Muestra un loader mientras se verifica el estado de autenticaci√≥n.
    // Esto previene un "parpadeo" donde se muestra la p√°gina de login por un instante
    // antes de que se carguen los datos del usuario y se produzca la redirecci√≥n.
    if (loadingUser) {
        return (
            <Center style={{ height: '100vh' }}>
                <Loader />
            </Center>
        );
    }

    // Si, una vez terminada la carga, hay datos de usuario...
    if (userData) {
        // Determina a d√≥nde redirigir bas√°ndose en el rol del usuario.
        let redirectTo = '/'; // Fallback por si hay un rol no manejado

        switch (userData.role) {
            case UserRole.CUSTOMER_FINAL:
                redirectTo = '/customer/dashboard';
                break;
            case UserRole.BUSINESS_ADMIN:
                redirectTo = '/admin/dashboard';
                break;
            case UserRole.SUPER_ADMIN:
                redirectTo = '/superadmin';
                break;
            case UserRole.WAITER:
                redirectTo = '/admin/camarero/pickup';
                break;
            case UserRole.KITCHEN_STAFF:
            case UserRole.BAR_STAFF:
                redirectTo = '/admin/kds';
                break;
        }
        
        // Redirige al usuario a su p√°gina principal. 'replace' evita que pueda
        // volver a la p√°gina de login con el bot√≥n de "atr√°s" del navegador.
        return <Navigate to={redirectTo} replace />;
    }

    // Si no hay datos de usuario (y la carga ha terminado), significa que no est√°
    // autenticado, por lo que se le permite ver la ruta p√∫blica anidada (login, register, etc.).
    return <Outlet />;
};

export default PublicRouteOnly;


// ====== [236] frontend/src/shared/components/layout/AdminNavbar.tsx ======
// frontend/src/components/layout/AdminNavbar.tsx
// Version: 1.2.1 (Add debug logs for WAITER role)

import React from 'react';
import { Link } from 'react-router-dom';
import { NavLink } from '@mantine/core';
import {
    IconGauge,
    IconGift,
    IconQrcode,
    IconUsers,
    IconStairsUp,
    IconSettings,
    IconToolsKitchen,
    IconClipboardText,
    IconFileInvoice
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import type { UserData } from '../../../shared/types/user.types';
import { UserRole } from '../../../shared/types/user.types';

interface AdminNavbarProps {
    pathname: string;
    closeNavbar: () => void;
    userData: UserData | null;
}

const AdminNavbar: React.FC<AdminNavbarProps> = ({ pathname, closeNavbar, userData }) => {
    const { t } = useTranslation();

    // ---- DEBUG LOG ----
    // Loguear siempre que userData cambie o el componente se renderice con userData
    if (userData) {
        console.log("[AdminNavbar DEBUG] UserData received in props:", JSON.stringify(userData, null, 2));
        console.log(`[AdminNavbar DEBUG] Current Role: ${userData.role}, IsCamareroActive: ${userData.isCamareroActive}`);

        if (userData.role === UserRole.WAITER) {
            console.log("[AdminNavbar DEBUG - WAITER CONTEXT] Role matches WAITER.");
            const conditionForPickup = userData?.isCamareroActive === true && (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN);
            console.log("[AdminNavbar DEBUG - WAITER CONTEXT] ShowCondition for '/admin/camarero/pickup':", conditionForPickup);

            const conditionForOrders = userData?.isCamareroActive === true && (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN);
            console.log("[AdminNavbar DEBUG - WAITER CONTEXT] ShowCondition for '/admin/camarero/orders':", conditionForOrders);
        }
    } else {
        console.log("[AdminNavbar DEBUG] UserData is null.");
    }
    // ---- FIN DEBUG LOG ----

    const allPossibleNavLinks = [
        {
            to: "/admin/dashboard",
            labelKey: 'adminCommon.dashboard',
            icon: IconGauge,
            showCondition: userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/rewards",
            labelKey: 'adminCommon.rewards',
            icon: IconGift,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/generate-qr",
            labelKey: 'adminCommon.generateQr',
            icon: IconQrcode,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/customers",
            labelKey: 'adminCommon.customers',
            icon: IconUsers,
            showCondition: (userData?.isLoyaltyCoreActive === true || userData?.isCamareroActive === true) && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/tiers/manage",
            labelKey: 'adminCommon.manageTiers',
            icon: IconStairsUp,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/tiers/settings",
            labelKey: 'adminCommon.tierSettings',
            icon: IconSettings,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/camarero/menu-editor",
            labelKey: 'adminCamarero.manageMenu.title',
            icon: IconToolsKitchen,
            showCondition: userData?.isCamareroActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/camarero/pickup",
            labelKey: 'waiterInterface.navLinkPickup',
            icon: IconClipboardText,
            showCondition: userData?.isCamareroActive === true &&
                           (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN)
        },
        {
            to: "/admin/camarero/orders",
            labelKey: 'waiterOrderManagement.navLinkTitle',
            icon: IconFileInvoice,
            showCondition: userData?.isCamareroActive === true &&
                           (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN)
        },
    ];

    const navLinksToShow = allPossibleNavLinks.filter(link => link.showCondition);
    
    // ---- DEBUG LOG ----
    if (userData?.role === UserRole.WAITER) {
      console.log("[AdminNavbar DEBUG - WAITER CONTEXT] Final navLinksToShow for WAITER:", navLinksToShow.map(l => ({ to: l.to, labelKey: l.labelKey })));
    }
    // ---- FIN DEBUG LOG ----


    return (
        <>
            {navLinksToShow.map((link) => (
                <NavLink
                    key={link.to}
                    label={t(link.labelKey)}
                    leftSection={<link.icon size="1rem" stroke={1.5} />}
                    component={Link}
                    to={link.to}
                    active={pathname.startsWith(link.to) && (pathname === link.to || pathname.startsWith(link.to + '/'))}
                    onClick={closeNavbar}
                />
            ))}
        </>
    );
};

export default AdminNavbar;


// ====== [237] frontend/src/shared/components/layout/AppHeader.tsx ======
// frontend/src/shared/components/layout/AppHeader.tsx (REVISADO)

import React from 'react';
import {
    Group, Burger, Skeleton, Button, Menu, UnstyledButton, Box, Text,
    Container
} from '@mantine/core';
import {
    IconUserCircle,
    IconLogout,
    IconChevronDown,
} from '@tabler/icons-react';
import { useDisclosure } from '@mantine/hooks';
import { useTranslation } from 'react-i18next';
import ReactCountryFlag from 'react-country-flag';
import { Link } from 'react-router-dom';

import { UserRole } from '../../../shared/types/user.types';

interface LayoutUserData {
    id: string;
    name?: string | null;
    email: string;
    role: UserRole;
}

interface AppHeaderProps {
    userData: LayoutUserData | null;
    loadingUser: boolean;
    handleLogout: () => void;
    navbarOpened?: boolean;
    toggleNavbar?: () => void;
    showAdminNavbar?: boolean;
}

const Logo: React.FC<{ homePath: string }> = ({ homePath }) => (
    <Link
        to={homePath}
        style={{ textDecoration: 'none', color: 'inherit', display: 'flex', alignItems: 'center' }}
        aria-label={homePath === "/" || homePath === "/login" ? "Ir a la p√°gina de inicio de sesi√≥n" : "Ir a mi panel principal"}
    >
        <img
            src="/loyalpymelogo.jpg"
            alt="LoyalPyME Logo"
            style={{ height: '40px', width: 'auto', display: 'block' }}
        />
    </Link>
);

const AppHeader: React.FC<AppHeaderProps> = ({
    userData, loadingUser, handleLogout, navbarOpened, toggleNavbar, showAdminNavbar = false,
}) => {
    const { i18n, t } = useTranslation();
    const [mobileMenuOpened, { toggle: toggleMobileMenu, close: closeMobileMenu }] = useDisclosure(false);

    let logoLinkPath = "/";

    if (userData) {
        if (userData.role === UserRole.CUSTOMER_FINAL) {
            logoLinkPath = "/customer/dashboard";
        } else if (userData.role === UserRole.BUSINESS_ADMIN) {
            logoLinkPath = "/admin/dashboard";
        } else if (userData.role === UserRole.SUPER_ADMIN) {
            logoLinkPath = "/superadmin";
        } else if (userData.role === UserRole.WAITER) {
            logoLinkPath = "/admin/camarero/pickup";
        } else if (userData.role === UserRole.KITCHEN_STAFF || userData.role === UserRole.BAR_STAFF) {
            logoLinkPath = "/admin/kds";
        }
    }

    const changeLanguage = (lang: string) => { i18n.changeLanguage(lang); closeMobileMenu(); };
    const currentCountryCode = i18n.resolvedLanguage === 'es' ? 'ES' : 'GB';
    const languages = [ { code: 'es', name: 'Espa√±ol', country: 'ES' }, { code: 'en', name: 'English', country: 'GB' }, ];

    const onLogoutClick = () => {
        handleLogout();
        closeMobileMenu();
    };

    const LogoutButtonInternal = () => ( <Button onClick={onLogoutClick} variant="light" color="red" size="sm" leftSection={<IconLogout size={16}/>}>{t('header.logoutButton')}</Button> );

    const LanguageSwitcherDesktop = () => (
         <Menu shadow="md" width={150} trigger="hover" openDelay={100} closeDelay={200}>
            <Menu.Target>
                 <UnstyledButton style={{ display: 'flex', alignItems: 'center', padding: '5px', borderRadius: 'var(--mantine-radius-sm)'}}>
                    <ReactCountryFlag countryCode={currentCountryCode} svg style={{ display: 'block', width: '1.4em', height: '1.4em' }} aria-label={currentCountryCode} />
                    <IconChevronDown size={16} stroke={1.5} style={{ marginLeft: '4px', color: 'var(--mantine-color-dimmed)' }} />
                 </UnstyledButton>
            </Menu.Target>
            <Menu.Dropdown>
                <Menu.Label>{t('header.languageLabel')}</Menu.Label>
                {languages.map((lang) => ( <Menu.Item key={lang.code} leftSection={<ReactCountryFlag countryCode={lang.country} svg style={{ fontSize: '1.1em', display:'block' }} />} onClick={() => changeLanguage(lang.code)} disabled={i18n.resolvedLanguage === lang.code}>{lang.name}</Menu.Item> ))}
            </Menu.Dropdown>
        </Menu>
    );

    return (
        <Box component="header" h="100%">
            <Container size="lg" h="100%" style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                <Group gap="xs">
                    {showAdminNavbar && toggleNavbar && ( <Burger opened={navbarOpened ?? false} onClick={toggleNavbar} hiddenFrom="sm" size="sm"/> )}
                    <Logo homePath={logoLinkPath} />
                </Group>

                {loadingUser ? ( <Skeleton height={30} width={120} /> )
                 : userData ? (
                    <Group gap="sm">
                        <Group visibleFrom="sm" gap="sm">
                            <Text size="sm" truncate>
                                <IconUserCircle size={18} style={{ verticalAlign: 'middle', marginRight: '4px' }} />
                                {t('header.greeting', { name: userData.name || userData.email })}
                            </Text>
                            <LanguageSwitcherDesktop />
                            <LogoutButtonInternal />
                        </Group>
                         <Box hiddenFrom="sm">
                             <Menu shadow="md" width={200} opened={mobileMenuOpened} onChange={toggleMobileMenu} position="bottom-end">
                                <Menu.Target>
                                     <Burger opened={mobileMenuOpened} onClick={toggleMobileMenu} aria-label={t('header.toggleNavigation', 'Toggle navigation')} size="sm"/>
                                </Menu.Target>
                                <Menu.Dropdown>
                                     <Menu.Label>{userData.name || userData.email}</Menu.Label>
                                    <Menu.Divider />
                                    <Menu.Label>{t('header.languageLabel')}</Menu.Label>
                                    {languages.map((lang) => (
                                        <Menu.Item key={lang.code} leftSection={<ReactCountryFlag countryCode={lang.country} svg style={{ fontSize: '1.1em', display:'block' }} />} onClick={() => changeLanguage(lang.code)} disabled={i18n.resolvedLanguage === lang.code}>
                                            {lang.name}
                                         </Menu.Item>
                                    ))}
                                    <Menu.Divider />
                                     <Menu.Item color="red" leftSection={<IconLogout size={14} />} onClick={onLogoutClick}>
                                         {t('header.logoutButton')}
                                     </Menu.Item>
                                </Menu.Dropdown>
                            </Menu>
                         </Box>
                    </Group>
                ) : (
                    <Group>
                        <LanguageSwitcherDesktop />
                    </Group>
                )}
            </Container>
        </Box>
    );
};

export default AppHeader;


// ====== [238] frontend/src/shared/components/layout/MainLayout.tsx ======
// frontend/src/components/layout/MainLayout.tsx
// Version 1.0.1 (Correct logic for showing AdminNavbar for WAITER and other staff roles)

import React from 'react';
import { Outlet, useLocation } from 'react-router-dom';
import { AppShell } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { useLayoutUserData } from '../../hooks/useLayoutUserData';
import AppHeader from './AppHeader';
import AdminNavbar from './AdminNavbar';
import { UserRole } from '../../types/user.types';

const MainLayout: React.FC = () => {
    const { userData, loadingUser, handleLogout } = useLayoutUserData();
    const location = useLocation();
    const [navbarOpened, { toggle: toggleNavbar, close: closeNavbar }] = useDisclosure();

    // ---- L√ìGICA MODIFICADA PARA MOSTRAR AdminNavbar ----
    // Determinar si la ruta actual es una ruta de "admin" en general
    const isAnyAdminRoute = location.pathname.startsWith('/admin/');

    // Definir qu√© roles deben ver la AdminNavbar en las rutas /admin/*
    const rolesThatSeeAdminNavbar: UserRole[] = [
        UserRole.BUSINESS_ADMIN,
        UserRole.WAITER,
        UserRole.KITCHEN_STAFF,
        UserRole.BAR_STAFF
        // SUPER_ADMIN tiene su propia ruta /superadmin y no usa esta navbar
    ];

    // AdminNavbar se muestra si el usuario tiene uno de los roles permitidos Y est√° en una ruta /admin/*
    const showAdminNavbar = userData?.role &&
                            rolesThatSeeAdminNavbar.includes(userData.role) &&
                            isAnyAdminRoute;
    // ---- FIN L√ìGICA MODIFICADA ----


    // Debug log para la condici√≥n de la navbar
    // console.log(`[MainLayout] Path: ${location.pathname}, Role: ${userData?.role}, isAnyAdminRoute: ${isAnyAdminRoute}, showAdminNavbar: ${showAdminNavbar}`);

    return (
        <AppShell
            header={{ height: 60 }}
            navbar={{
                width: 250,
                breakpoint: 'sm',
                // Mostrar/ocultar navbar si showAdminNavbar es true y navbarOpened es true (para m√≥vil)
                collapsed: { mobile: !navbarOpened || !showAdminNavbar, desktop: !showAdminNavbar }
            }}
            padding="md"
        >
            <AppShell.Header>
                <AppHeader
                    userData={userData}
                    loadingUser={loadingUser}
                    handleLogout={handleLogout}
                    navbarOpened={navbarOpened}
                    toggleNavbar={toggleNavbar}
                    // El burger del header debe aparecer si showAdminNavbar es true,
                    // independientemente de si la navbar est√° colapsada o no en desktop.
                    showAdminNavbar={showAdminNavbar}
                />
            </AppShell.Header>

            {/* Mostrar AdminNavbar solo si showAdminNavbar es true */}
            {showAdminNavbar && (
                <AppShell.Navbar p="md">
                    <AdminNavbar
                        pathname={location.pathname}
                        closeNavbar={closeNavbar}
                        userData={userData}
                    />
                </AppShell.Navbar>
            )}

            <AppShell.Main>
                <Outlet />
            </AppShell.Main>
        </AppShell>
    );
};

export default MainLayout;


// ====== [239] frontend/src/shared/components/layout/PublicLayout.tsx ======
// filename: frontend/src/components/layout/PublicLayout.tsx
// Nuevo layout simple para p√°ginas p√∫blicas, solo incluye el Header.

import React from 'react';
import { Outlet } from 'react-router-dom';
import { AppShell } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks'; // Necesario para AppHeader
import { useLayoutUserData } from '../../hooks/useLayoutUserData'; // Necesario para AppHeader
import AppHeader from './AppHeader'; // Importamos el header existente

const PublicLayout: React.FC = () => {
    // Necesitamos obtener los datos y el estado de la navbar para pasarlos al AppHeader
    const { userData, loadingUser, handleLogout } = useLayoutUserData();
    // Aunque no mostramos la navbar aqu√≠, AppHeader necesita el estado y el toggle para el Burger en m√≥vil
    const [navbarOpened, { toggle: toggleNavbar }] = useDisclosure();

    return (
        <AppShell
            header={{ height: 60 }}
            // NO definimos navbar aqu√≠
            padding="md" // Mantenemos padding general
        >
            {/* Cabecera (la misma que en MainLayout) */}
            <AppShell.Header>
                <AppHeader
                    userData={userData}
                    loadingUser={loadingUser}
                    handleLogout={handleLogout}
                    navbarOpened={navbarOpened}
                    toggleNavbar={toggleNavbar}
                    showAdminNavbar={false} // Nunca mostramos navbar admin en layout p√∫blico
                />
            </AppShell.Header>

            {/* Contenido principal de la p√°gina p√∫blica actual */}
            <AppShell.Main>
                <Outlet /> {/* Aqu√≠ se renderiza LoginPage, RegisterPage, etc. */}
            </AppShell.Main>
        </AppShell>
    );
};

export default PublicLayout;

// End of File: frontend/src/components/layout/PublicLayout.tsx


// ====== [240] frontend/src/shared/components/utils/ImageUploadCropper.tsx ======
// frontend/src/shared/components/utils/ImageUploadCropper.tsx
import React, { useState, useRef, SyntheticEvent, useEffect } from 'react';
import {
    FileInput, Button, Group, AspectRatio, Image as MantineImage,
    Center, Text, Alert, Box, Stack, LoadingOverlay
} from '@mantine/core';
import {
    IconUpload, IconPhoto, IconX, IconAlertCircle, IconCrop, IconCameraRotate
} from '@tabler/icons-react';
import ReactCrop, {
    centerCrop,
    makeAspectCrop,
    type Crop,
    type PixelCrop,
} from 'react-image-crop';
import 'react-image-crop/dist/ReactCrop.css';
import { canvasPreview, canvasToBlob } from './canvasPreview';
import { useTranslation } from 'react-i18next';
import axiosInstance from '../../services/axiosInstance';

export interface ImageUploadCropperProps {
    aspectRatio: number;
    minDimension: number;
    initialImageUrl: string | null;
    onUploadSuccess: (imageUrl: string) => void;
    onUploadError: (errorMessage: string) => void;
    onClearImage: () => void; // AUNQUE NO SE USA, la mantenemos por consistencia con otros componentes
    folderName?: string;
    disabled?: boolean;
    imagePreviewAltText?: string;
    imageToCropAltText?: string;
}

const DEFAULT_CLOUDINARY_FOLDER = 'loyalpyme/uploads';

const ImageUploadCropper: React.FC<ImageUploadCropperProps> = ({
    aspectRatio,
    minDimension,
    initialImageUrl,
    onUploadSuccess,
    onUploadError,
    onClearImage, // Recibimos la prop aunque no la usemos aqu√≠ directamente
    folderName = DEFAULT_CLOUDINARY_FOLDER,
    disabled = false,
    imagePreviewAltText,
    imageToCropAltText,
}) => {
    const { t } = useTranslation();
    const imgRef = useRef<HTMLImageElement>(null);
    const [imgSrcForCropper, setImgSrcForCropper] = useState('');
    const [crop, setCrop] = useState<Crop>();
    const [completedCrop, setCompletedCrop] = useState<PixelCrop>();
    const [isUploading, setIsUploading] = useState<boolean>(false);
    const [internalError, setInternalError] = useState<string | null>(null);
    const [selectedFile, setSelectedFile] = useState<File | null>(null);

    useEffect(() => {
        if (initialImageUrl) {
            setImgSrcForCropper('');
            setSelectedFile(null);
        }
    }, [initialImageUrl]);

    const handleFileSelect = (file: File | null) => {
        setInternalError(null);
        onUploadError('');
        setSelectedFile(file);
        if (file) {
            setCrop(undefined);
            const reader = new FileReader();
            reader.addEventListener('load', () => setImgSrcForCropper(reader.result?.toString() || ''));
            reader.readAsDataURL(file);
        } else {
            setImgSrcForCropper('');
        }
    };

    const onImageLoad = (e: SyntheticEvent<HTMLImageElement>) => {
        const { naturalWidth, naturalHeight } = e.currentTarget;
        if (naturalWidth < minDimension || naturalHeight < minDimension) {
            const errorMsg = t('common.errorImageTooSmall', { minSize: minDimension });
            setInternalError(errorMsg);
            onUploadError(errorMsg);
            setImgSrcForCropper('');
            return;
        }
        const newCrop = centerCrop(makeAspectCrop({ unit: '%', width: 100 }, aspectRatio, naturalWidth, naturalHeight), naturalWidth, naturalHeight);
        setCrop(newCrop);
    };

    const handleConfirmCropAndUpload = async () => {
        if (!imgRef.current || !completedCrop || completedCrop.width === 0) {
            const errorMsg = "Recorte de imagen inv√°lido.";
            setInternalError(errorMsg);
            onUploadError(errorMsg);
            return;
        }
        setIsUploading(true);
        setInternalError(null);
        onUploadError('');
        try {
            const canvas = document.createElement('canvas');
            canvasPreview(imgRef.current, canvas, completedCrop, 1, 0, completedCrop.width, completedCrop.height);
            const blob = await canvasToBlob(canvas);
            if (!blob) throw new Error("No se pudo crear el archivo de imagen.");
            
            const formData = new FormData();
            formData.append('image', blob, selectedFile?.name || `cropped.png`);
            
            const response = await axiosInstance.post<{ url: string }>('/uploads/image', formData, {
                headers: { 'Content-Type': 'multipart/form-data', 'X-Upload-Folder': folderName }
            });

            if (response.data && response.data.url) {
                onUploadSuccess(response.data.url);
                setImgSrcForCropper('');
            } else {
                throw new Error("La API no devolvi√≥ una URL de imagen v√°lida.");
            }
        } catch (err: any) {
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
            setInternalError(apiError);
            onUploadError(apiError);
        } finally {
            setIsUploading(false);
        }
    };

    const handleRemoveImage = () => {
        setImgSrcForCropper('');
        setSelectedFile(null);
        onClearImage(); // Usamos la prop aqu√≠
    };
    
    const showCropper = !!imgSrcForCropper;
    const effectiveImagePreviewAlt = imagePreviewAltText || 'Preview';

    return (
        <Stack gap="sm">
            <LoadingOverlay visible={isUploading} />
            
            {showCropper ? (
                <Box>
                    <ReactCrop
                        crop={crop} onChange={(_, percentCrop) => setCrop(percentCrop)} onComplete={(c) => setCompletedCrop(c)}
                        aspect={aspectRatio} minWidth={minDimension} minHeight={minDimension / aspectRatio} >
                        <img ref={imgRef} src={imgSrcForCropper} onLoad={onImageLoad} alt={imageToCropAltText || 'Crop'} style={{ maxHeight: 300 }} />
                    </ReactCrop>
                </Box>
            ) : (
                <AspectRatio ratio={aspectRatio} maw={300} mx="auto">
                    <Center bg="gray.1" style={{ borderRadius: 'var(--mantine-radius-md)', border: `1px dashed var(--mantine-color-gray-4)` }}>
                        {initialImageUrl ? (
                            <MantineImage src={initialImageUrl} alt={effectiveImagePreviewAlt} radius="sm" fit="contain" style={{ maxHeight: '100%', maxWidth: '100%' }} fallbackSrc="/placeholder-image.png" />
                        ) : ( <IconPhoto size={48} color="var(--mantine-color-gray-5)" stroke={1.5} /> )}
                    </Center>
                </AspectRatio>
            )}

            <Group justify="center" mt="xs" wrap="nowrap">
                <FileInput
                    placeholder={t('component.rewardForm.selectImageButton')}
                    leftSection={<IconUpload size={16} />}
                    accept="image/png,image/jpeg,image/webp"
                    onChange={handleFileSelect}
                    value={selectedFile}
                    clearable
                    disabled={disabled || isUploading}
                    style={{ flexGrow: 1 }}
                />
                {showCropper && (
                    <Button onClick={handleConfirmCropAndUpload} loading={isUploading} disabled={!completedCrop || disabled} leftSection={<IconCrop size={16} />}>
                        {t('component.rewardForm.confirmCropButton')}
                    </Button>
                )}
            </Group>

            {(initialImageUrl && !showCropper) && (
                <Button variant="subtle" color="red" size="xs" mt="xs" onClick={handleRemoveImage} leftSection={<IconX size={14} />} disabled={disabled || isUploading}>
                    {t('component.rewardForm.removeImageButton')}
                </Button>
            )}

            {showCropper && (
                 <Button variant="outline" color="gray" size="xs" mt="xs" onClick={() => { setImgSrcForCropper(''); setSelectedFile(null); }} leftSection={<IconCameraRotate size={14}/>} disabled={isUploading || disabled} fullWidth >
                    {t('common.cancel')}
                 </Button>
            )}

            {internalError && (
                <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />} mt="sm" withCloseButton onClose={() => setInternalError(null)}>
                    <Text size="sm">{internalError}</Text>
                </Alert>
            )}
        </Stack>
    );
};

export default ImageUploadCropper;


// ====== [241] frontend/src/shared/components/utils/canvasPreview.ts ======
// frontend/src/utils/canvasPreview.ts
// Version 1.0.2 (Removed unused centerX, centerY for current logic)
import { PixelCrop } from 'react-image-crop';

const TO_RADIANS = Math.PI / 180;

export async function canvasPreview(
  image: HTMLImageElement,
  canvas: HTMLCanvasElement,
  crop: PixelCrop,
  scale = 1,
  rotate = 0,
  outputWidth?: number,
  outputHeight?: number
) {
  const ctx = canvas.getContext('2d');

  if (!ctx) {
    throw new Error('No 2d context');
  }

  const scaleX = image.naturalWidth / image.width;  // Relaci√≥n entre tama√±o natural y tama√±o mostrado
  const scaleY = image.naturalHeight / image.height; // Usado para convertir crop de % a px si fuera el caso

  canvas.width = Math.floor(outputWidth || crop.width);   // Usar outputWidth o el ancho del crop en p√≠xeles
  canvas.height = Math.floor(outputHeight || crop.height); // Usar outputHeight o el alto del crop en p√≠xeles

  ctx.imageSmoothingQuality = 'high';

  const cropXInOriginal = crop.x * scaleX; // Coordenada X del crop en la imagen original
  const cropYInOriginal = crop.y * scaleY; // Coordenada Y del crop en la imagen original
  const cropWidthInOriginal = crop.width * scaleX; // Ancho del crop en la imagen original
  const cropHeightInOriginal = crop.height * scaleY; // Alto del crop en la imagen original

  const rotateRads = rotate * TO_RADIANS;

  ctx.save();
  // Mover el origen del canvas al centro del canvas para la rotaci√≥n/escalado
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.rotate(rotateRads);
  ctx.scale(scale, scale);
  // Mover el origen de nuevo para que (0,0) del drawImage sea la esquina superior izquierda del √°rea de destino
  ctx.translate(-canvas.width / 2, -canvas.height / 2);

  // Dibujar la porci√≥n recortada de la imagen original,
  // y que se ajuste a las dimensiones completas del canvas (que son outputWidth/Height o el tama√±o del crop).
  ctx.drawImage(
    image,
    cropXInOriginal,
    cropYInOriginal,
    cropWidthInOriginal,
    cropHeightInOriginal,
    0, // Dibujar en la esquina (0,0) del canvas (ya transformado)
    0,
    canvas.width,  // Estirar/encoger a todo el ancho del canvas
    canvas.height  // Estirar/encoger a todo el alto del canvas
  );

  ctx.restore();
}

// canvasToBlob (sin cambios)
export function canvasToBlob(
  canvas: HTMLCanvasElement,
  type = 'image/png',
  quality = 0.9
): Promise<Blob | null> {
    return new Promise((resolve) => {
        canvas.toBlob(
            (blob) => { resolve(blob); },
            type,
            quality
        );
    });
}


// ====== [242] frontend/src/shared/hooks/useLayoutUserData.ts ======
// frontend/src/shared/hooks/useLayoutUserData.ts
// Version 1.0.1 - Corrected type import path

import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import axiosInstance from '../services/axiosInstance';

// --- CORRECCI√ìN DE RUTA ---
import type { UserData } from '../types/user.types';
// --- FIN CORRECCI√ìN ---

interface UseLayoutUserDataReturn {
    userData: UserData | null;
    loadingUser: boolean;
    handleLogout: () => void;
}

export const useLayoutUserData = (): UseLayoutUserDataReturn => {
    const navigate = useNavigate();
    const [userData, setUserData] = useState<UserData | null>(null);
    const [loadingUser, setLoadingUser] = useState(true);

    const handleLogout = useCallback(() => {
        console.log("[useLayoutUserData] Executing logout...");
        localStorage.removeItem('token');
        localStorage.removeItem('user');
        setUserData(null);
        if (window.location.pathname !== '/login') {
            navigate('/login', { replace: true });
        }
    }, [navigate]);

    useEffect(() => {
        const fetchAndSetUserData = async () => {
            console.log("[useLayoutUserData] Starting user data check/fetch...");
            setLoadingUser(true);
            const token = localStorage.getItem('token');

            if (!token) {
                console.log("[useLayoutUserData] No token found. Ensuring user is null.");
                if (userData !== null) setUserData(null);
                setLoadingUser(false);
                return;
            }

            console.log("[useLayoutUserData] Token found. Fetching user profile from API...");
            try {
                const response = await axiosInstance.get<UserData>('/profile');
                if (response.data && response.data.id && response.data.email && response.data.role) {
                    setUserData(response.data);
                    localStorage.setItem('user', JSON.stringify(response.data));
                    console.log("[useLayoutUserData] User data fetched from API and saved to localStorage:", response.data);
                } else {
                    console.error("[useLayoutUserData] Invalid or incomplete data received from API /profile endpoint. Logging out.");
                    handleLogout();
                }
            } catch (apiError: any) {
                console.error("[useLayoutUserData] Error fetching user profile from API:", apiError);
                if (apiError.response?.status === 401 || apiError.response?.status === 403) {
                    console.log("[useLayoutUserData] API /profile returned 401/403, logging out.");
                    handleLogout();
                } else {
                    console.warn("[useLayoutUserData] API /profile fetch failed with other error. Attempting to load from localStorage if available.");
                    const storedUserJson = localStorage.getItem('user');
                    if (storedUserJson) {
                        try {
                            const parsed = JSON.parse(storedUserJson) as UserData;
                            if (parsed && parsed.id && parsed.email && parsed.role) {
                                setUserData(parsed);
                                console.log("[useLayoutUserData] Loaded stale data from localStorage due to API error.");
                            } else {
                                handleLogout();
                            }
                        } catch (e) {
                            handleLogout();
                        }
                    } else {
                        handleLogout();
                    }
                }
            } finally {
                setLoadingUser(false);
                console.log("[useLayoutUserData] User data fetch/check process finished.");
            }
        };

        fetchAndSetUserData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [navigate]);

    useEffect(() => {
        const handleStorageChange = (event: StorageEvent) => {
            if (event.key === 'token' || event.key === 'user') {
                console.log('[useLayoutUserData] localStorage changed in another tab. Re-evaluating auth state.');
                const token = localStorage.getItem('token');
                if (!token && userData !== null) {
                    handleLogout();
                }
            }
        };

        window.addEventListener('storage', handleStorageChange);
        return () => {
            window.removeEventListener('storage', handleStorageChange);
        };
    }, [userData, handleLogout]);

    return { userData, loadingUser, handleLogout };
};


// ====== [243] frontend/src/shared/services/axiosInstance.ts ======
// filename: frontend/src/services/axiosInstance.ts
// Version: 1.1.1 (Remove meta-comments)

import axios from 'axios';

// Usar ruta relativa para baseURL
// El proxy de Vite redirigir√° /api a http://localhost:3000/api
const API_BASE_URL = '/api'; // Ruta relativa para que funcione el proxy

// Crea una instancia de Axios con la configuraci√≥n base
const axiosInstance = axios.create({
  baseURL: API_BASE_URL,
});

// A√±ade un interceptor de peticiones (request interceptor)
axiosInstance.interceptors.request.use(
  (config) => {
    // Obtener el token de localStorage
    const token = localStorage.getItem('token');
    if (token) {
      // A√±adir la cabecera Authorization si existe el token
      config.headers.set('Authorization', `Bearer ${token}`);
    }
    return config; // Devolver la configuraci√≥n modificada (o la original si no hay token)
  },
  (error) => {
    // Manejar errores que ocurran durante la configuraci√≥n de la petici√≥n
    console.error('Error in request interceptor:', error);
    return Promise.reject(error); // Rechazar la promesa con el error
  }
);

// Opcional: A√±adir interceptor de respuestas aqu√≠ si fuera necesario
/*
axiosInstance.interceptors.response.use(
  (response) => {
    // Cualquier c√≥digo de estado que este dentro del rango de 2xx causa la ejecuci√≥n de esta funci√≥n
    // Haz algo con los datos de la respuesta
    return response;
  },
  (error) => {
    // Cualquier c√≥digo de estado que caiga fuera del rango de 2xx causa la ejecuci√≥n de esta funci√≥n
    // Por ejemplo, manejar errores 401/403 globales aqu√≠
    if (error.response?.status === 401) {
      // Podr√≠amos hacer logout autom√°tico aqu√≠
      console.error("Unauthorized (401) response detected by interceptor.");
      // localStorage.removeItem('token');
      // localStorage.removeItem('user');
      // window.location.href = '/login'; // Redirecci√≥n forzada
    }
    return Promise.reject(error); // Rechazar la promesa con el error
  }
);
*/

// Exporta la instancia configurada para usarla en otros servicios
export default axiosInstance;

// End of File: frontend/src/services/axiosInstance.ts


// ====== [244] frontend/src/shared/services/businessService.ts ======
// filename: frontend/src/services/businessService.ts
// Version: 1.1.1 (Remove meta-comments, fix encoding)

import axios from 'axios'; // Usamos axios base, NO axiosInstance, porque es una ruta p√∫blica

/**
 * Interface para la estructura de datos de cada negocio en la lista p√∫blica.
 * Contiene lo necesario para un desplegable (valor y etiqueta).
 */
export interface BusinessOption {
  id: string;
  name: string;
}

// Usar ruta relativa para que funcione con el proxy de Vite
// El proxy definido en vite.config.ts para '/public' redirigir√° esto
const PUBLIC_BUSINESS_LIST_URL = '/public/businesses/public-list';


/**
 * Obtiene la lista p√∫blica de negocios (ID y Nombre) desde la API.
 * @returns Una promesa que resuelve con un array de objetos BusinessOption.
 * @throws Lanza un error si la petici√≥n a la API falla.
 */
export const getPublicBusinessList = async (): Promise<BusinessOption[]> => {
  console.log('[BusinessService] Fetching public business list...');
  try {
    // La llamada ahora usa la URL relativa
    const response = await axios.get<BusinessOption[]>(PUBLIC_BUSINESS_LIST_URL);

    console.log(`[BusinessService] Received ${response.data?.length ?? 0} businesses.`);
    return response.data || []; // Devolver array vac√≠o si la data es null/undefined

  } catch (error: any) {
    console.error('[BusinessService] Error fetching public business list:', error);
    const errorMessage = error.response?.data?.message ||
                           error.message ||
                           'Error desconocido al obtener la lista de negocios.'; // Corregido: desconocido
    // Relanzar el error para que el componente que llama lo maneje (ej: en RegisterPage)
    throw new Error(errorMessage);
  }
};

// End of file: frontend/src/services/businessService.ts


// ====== [245] frontend/src/shared/types/enums.ts ======
// frontend/src/shared/types/enums.ts

export enum RewardType {
  MENU_ITEM = 'MENU_ITEM',
  DISCOUNT_ON_ITEM = 'DISCOUNT_ON_ITEM',
  DISCOUNT_ON_TOTAL = 'DISCOUNT_ON_TOTAL',
  GENERIC_FREE_PRODUCT = 'GENERIC_FREE_PRODUCT', // <-- L√çNEA A√ëADIDA
}

export enum DiscountType {
  PERCENTAGE = 'PERCENTAGE',
  FIXED_AMOUNT = 'FIXED_AMOUNT',
}


// ====== [246] frontend/src/shared/types/superadmin.types.ts ======
// frontend/src/types/superadmin.types.ts

// El tipo de dato que la API /superadmin/businesses devuelve para cada negocio
export interface SuperAdminBusiness {
    id: string;
    name: string;
    slug: string;
    isActive: boolean;
    isLoyaltyCoreActive: boolean;
    isCamareroActive: boolean;
    createdAt: string;
    monthlyPrice: string | number | null; // La API puede enviar Decimal como string
    currency: string;
    paymentStatus: 'PAID' | 'PENDING' | 'OVERDUE';
    lastPayment?: { month: number; year: number };
    pendingMonths: number;
}

// El tipo de dato para un registro de pago individual
export interface BusinessPayment {
    id: string;
    paymentDate: string;
    amountPaid: number;
    month: number;
    year: number;
    paymentMethod: string | null;
    notes: string | null;
}


// ====== [247] frontend/src/shared/types/user.types.ts ======
// frontend/src/shared/types/user.types.ts
// VERSI√ìN 2.0.2: `discountValue` ahora es `any` para m√°xima flexibilidad en la deserializaci√≥n.

import React from 'react';
import { RewardType, DiscountType } from './enums';

export enum UserRole {
    SUPER_ADMIN = 'SUPER_ADMIN',
    BUSINESS_ADMIN = 'BUSINESS_ADMIN',
    CUSTOMER_FINAL = 'CUSTOMER_FINAL',
    WAITER = 'WAITER',
    KITCHEN_STAFF = 'KITCHEN_STAFF',
    BAR_STAFF = 'BAR_STAFF'
}

export enum OrderItemStatus {
    PENDING_KDS = 'PENDING_KDS', PREPARING = 'PREPARING', READY = 'READY',
    SERVED = 'SERVED', CANCELLED = 'CANCELLED', CANCELLATION_REQUESTED = 'CANCELLATION_REQUESTED',
}

export enum OrderStatus {
    RECEIVED = 'RECEIVED', IN_PROGRESS = 'IN_PROGRESS', PARTIALLY_READY = 'PARTIALLY_READY',
    ALL_ITEMS_READY = 'ALL_ITEMS_READY', COMPLETED = 'COMPLETED', PENDING_PAYMENT = 'PENDING_PAYMENT',
    PAID = 'PAID', CANCELLED = 'CANCELLED', PAYMENT_FAILED = 'PAYMENT_FAILED',
}

export enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKE_AWAY = 'TAKE_AWAY',
  DELIVERY = 'DELIVERY',
}

export enum TierCalculationBasis {
    SPEND = 'SPEND',
    VISITS = 'VISITS',
    POINTS_EARNED = 'POINTS_EARNED'
}

export interface CustomerBusinessConfig {
    tierCalculationBasis: TierCalculationBasis | null;
}

export interface TierBenefitData {
  id: string;
  type: string;
  value: string;
  description: string | null;
  isActive?: boolean;
}

export interface TierData {
    id: string;
    name: string;
    level: number;
    minValue: number;
    isActive: boolean;
    benefits?: TierBenefitData[];
}

export interface UserData {
    id: string;
    email: string;
    name?: string | null;
    phone?: string | null;
    imageUrl?: string | null;
    role: UserRole;
    businessId: string | null;
    isActive: boolean;
    points?: number;
    totalSpend?: number;
    totalVisits?: number;
    currentTier?: {
        id: string;
        name: string;
        benefits: TierBenefitData[];
    } | null;
    businessIsActive?: boolean;
    isLoyaltyCoreActive?: boolean;
    isCamareroActive?: boolean;
    businessName?: string | null;
    businessSlug?: string | null;
    businessLogoUrl?: string | null;
}

export interface Reward {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es?: string | null;
    description_en?: string | null;
    pointsCost: number;
    isActive: boolean;
    businessId?: string;
    imageUrl?: string | null;
    createdAt?: string;
    updatedAt?: string;
    type: RewardType;
    linkedMenuItemId: string | null;
    discountType: DiscountType | null;
    // --- CORRECCI√ìN CLAVE ---
    // Aceptamos CUALQUIER tipo que venga de la API (string, number, objeto Decimal serializado)
    // para evitar errores de tipado en la deserializaci√≥n. La conversi√≥n a n√∫mero se har√°
    // en el componente que lo necesite (ApplyRewardModal).
    discountValue: any;
    // --- FIN CORRECCI√ìN ---
    validFrom: string | null;
    validUntil: string | null;
    usageLimit: number | null;
    usageLimitPerUser: number | null;
    requiredTierId: string | null;
    isStackable: boolean;
    kdsDestination?: string | null;
}

export interface GrantedReward {
    id: string;
    status: string;
    assignedAt: string;
    redeemedAt: string | null;
    expiresAt: string | null;
    reward: Reward; 
    assignedBy?: { name?: string | null; email: string; } | null;
    business?: { name: string; } | null;
}

export type DisplayReward =
    ({
        isGift: false;
        id: string;
        name_es: string | null;
        name_en: string | null;
        description_es?: string | null;
        description_en?: string | null;
        pointsCost: number;
        imageUrl?: string | null;
        grantedRewardId?: undefined;
        assignedByString?: undefined;
        assignedAt?: undefined;
        type: RewardType;
        linkedMenuItemId: string | null;
        discountType: DiscountType | null;
        discountValue: number | null;
    }) |
    {
        isGift: true;
        grantedRewardId: string;
        id: string;
        name_es: string | null;
        name_en: string | null;
        description_es?: string | null;
        description_en?: string | null;
        pointsCost: 0;
        imageUrl?: string | null;
        assignedByString: string;
        assignedAt: string;
        type: RewardType; 
        linkedMenuItemId: string | null; 
        discountType: DiscountType | null; 
        discountValue: number | null;
    };

export interface UseProfileResult {
    userData: UserData | null;
    loading: boolean;
    error: string | null;
    refetch: () => Promise<void>;
    setUserData: React.Dispatch<React.SetStateAction<UserData | null>>;
}

export interface UseCustomerTierDataResult {
    allTiers: TierData[] | null;
    businessConfig: CustomerBusinessConfig | null;
    loading: boolean;
    error: string | null;
    refetch: () => Promise<void>;
}

export type ActivityType =
    | 'POINTS_EARNED_QR'
    | 'POINTS_REDEEMED_REWARD'
    | 'GIFT_REDEEMED'
    | 'POINTS_ADJUSTED_ADMIN'
    | 'POINTS_EARNED_ORDER_LC'
    | 'REWARD_ACQUIRED'
    | 'REWARD_APPLIED_TO_ORDER';

export interface ActivityLogItem {
  id: string;
  type: ActivityType;
  pointsChanged: number | null;
  description: string | null;
  createdAt: string;
}

export interface PaginatedActivityResponse {
  logs: ActivityLogItem[];
  totalPages: number;
  currentPage: number;
  totalItems: number;
}


// ====== [248] frontend/src/test/setup.ts ======
// filename: frontend/src/test/setup.ts
// Configuraci√≥n inicial para tests de Vitest en Frontend

// Importa los matchers de jest-dom para que est√©n disponibles globalmente en 'expect'
import '@testing-library/jest-dom';

// Aqu√≠ podr√≠as a√±adir otras configuraciones globales para tests en el futuro si fuera necesario
// (Ej: Limpiar localStorage antes de cada test, configurar mocks globales, etc.)



// ====== [249] frontend/src/theme.ts ======
// filename: frontend/src/theme.ts
// Version: 1.0.3 (Clean up comments and commented code)

import { createTheme } from '@mantine/core';

// Crear el objeto del tema
export const theme = createTheme({
  /* Aqu√≠ puedes a√±adir tus personalizaciones del tema de Mantine */

  // Color primario establecido a azul
  primaryColor: 'blue',

  // Radio de borde por defecto para componentes
  defaultRadius: 'lg', // Opciones: 'xs', 'sm', 'md', 'lg', 'xl'

  // Fuente por defecto
  fontFamily: 'Verdana, sans-serif',

  // Ejemplo de c√≥mo personalizar componentes espec√≠ficos (descomentar y ajustar si es necesario):
  /*
  components: {
    Button: {
      defaultProps: {
        // Ejemplo: hacer todos los botones un poco m√°s grandes por defecto
        // size: 'md',
      }
    }
  }
  */
});

// End of File: frontend/src/theme.ts


// ====== [250] frontend/src/vite-env.d.ts ======
/// <reference types="vite/client" />



// ====== [251] frontend/tsconfig.app.json ======
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}



// ====== [252] frontend/tsconfig.json ======
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



// ====== [253] frontend/tsconfig.node.json ======
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}



// ====== [254] frontend/vite.config.ts ======
// filename: frontend/vite.config.ts
// Version: 1.1.3 (Use mergeConfig to combine Vite and Vitest configs)

// Importar defineConfig y mergeConfig de Vite
import { defineConfig, mergeConfig } from 'vite';
// Importar defineConfig de Vitest con un alias
import { defineConfig as defineVitestConfig } from 'vitest/config';

import react from '@vitejs/plugin-react';
import mkcert from 'vite-plugin-mkcert';

// Configuraci√≥n espec√≠fica de Vite
const viteConfig = defineConfig({
  plugins: [react(), mkcert()],
  server: {
    host: true,
    port: 5173,
    https: true,
    proxy: {
      '/api': { target: 'http://localhost:3000', changeOrigin: true },
      '/public': { target: 'http://localhost:3000', changeOrigin: true }
    }
  },
  // Aqu√≠ ir√≠an otras opciones espec√≠ficas de Vite si las tuvieras
});

// Configuraci√≥n espec√≠fica de Vitest
const vitestConfig = defineVitestConfig({
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts', // Seguimos necesitando este archivo
    css: true,
  },
  // Aqu√≠ ir√≠an otras opciones espec√≠ficas de Vitest si las tuvieras
});

// Exportar la configuraci√≥n combinada
export default mergeConfig(viteConfig, vitestConfig);

// End of File: frontend/vite.config.ts

