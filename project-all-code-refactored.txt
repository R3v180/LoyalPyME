# √çNDICE DE ARCHIVOS (ESTRUCTURA REFACTORIZADA)

1. DEVELOPMENT_PLAN.md
2. LICENSE.md
3. LOYALPYME_CAMARERO_WORKFLOW.md
4. LOYALPYME_CORE_WORKFLOW.md
5. LOYALPYME_MODULE_INTEGRATION_WORKFLOW.md
6. PROJECT_STATUS.md
7. README.md
8. SETUP_GUIDE.md
9. TROUBLESHOOTING_GUIDE.md
10. backend/nodemon.json
11. backend/package-lock.json
12. backend/package.json
13. backend/prisma/seed.ts
14. backend/scripts/create-superadmin.ts
15. backend/scripts/hash-customer-password.ts
16. backend/src/config/swagger.config.ts
17. backend/src/index.ts
18. backend/src/modules/camarero/admin-menu-category.controller.ts
19. backend/src/modules/camarero/admin-menu-category.service.ts
20. backend/src/modules/camarero/admin-menu-item.controller.ts
21. backend/src/modules/camarero/admin-menu-item.service.ts
22. backend/src/modules/camarero/admin-modifier.controller.ts
23. backend/src/modules/camarero/admin-modifier.service.ts
24. backend/src/modules/camarero/camarero.dto.ts
25. backend/src/modules/camarero/kds.controller.ts
26. backend/src/modules/camarero/kds.service.ts
27. backend/src/modules/camarero/public/OrderValidationService.ts
28. backend/src/modules/camarero/public/menu.controller.ts
29. backend/src/modules/camarero/public/menu.service.ts
30. backend/src/modules/camarero/public/order-creation.service.ts
31. backend/src/modules/camarero/public/order-item-processor.service.ts
32. backend/src/modules/camarero/public/order-modification.service.ts
33. backend/src/modules/camarero/public/order-payment.service.ts
34. backend/src/modules/camarero/public/order.controller.ts
35. backend/src/modules/camarero/public/order.dto.ts
36. backend/src/modules/camarero/public/order.service.ts
37. backend/src/modules/camarero/public/order.types.ts
38. backend/src/modules/camarero/waiter.controller.ts
39. backend/src/modules/camarero/waiter.service.ts
40. backend/src/modules/loyalpyme/activity/activity.controller.ts
41. backend/src/modules/loyalpyme/activity/activity.service.ts
42. backend/src/modules/loyalpyme/admin/admin-customer-bulk.controller.ts
43. backend/src/modules/loyalpyme/admin/admin-customer-bulk.service.ts
44. backend/src/modules/loyalpyme/admin/admin-customer-individual.controller.ts
45. backend/src/modules/loyalpyme/admin/admin-customer-individual.service.ts
46. backend/src/modules/loyalpyme/admin/admin-customer-list.controller.ts
47. backend/src/modules/loyalpyme/admin/admin-customer-list.service.ts
48. backend/src/modules/loyalpyme/admin/admin-stats.controller.ts
49. backend/src/modules/loyalpyme/admin/admin-stats.service.ts
50. backend/src/modules/loyalpyme/customer/customer.controller.ts
51. backend/src/modules/loyalpyme/customer/customer.service.ts
52. backend/src/modules/loyalpyme/points/points.controller.ts
53. backend/src/modules/loyalpyme/points/points.service.ts
54. backend/src/modules/loyalpyme/rewards/rewards.controller.ts
55. backend/src/modules/loyalpyme/rewards/rewards.service.ts
56. backend/src/modules/loyalpyme/tiers/__tests__/tier-logic.helpers.test.ts
57. backend/src/modules/loyalpyme/tiers/tier-benefit.controller.ts
58. backend/src/modules/loyalpyme/tiers/tier-benefit.service.ts
59. backend/src/modules/loyalpyme/tiers/tier-config.controller.ts
60. backend/src/modules/loyalpyme/tiers/tier-config.service.ts
61. backend/src/modules/loyalpyme/tiers/tier-crud.controller.ts
62. backend/src/modules/loyalpyme/tiers/tier-logic.helpers.ts
63. backend/src/modules/loyalpyme/tiers/tier-logic.service.ts
64. backend/src/modules/loyalpyme/tiers/tiers.controller.ts
65. backend/src/modules/loyalpyme/tiers/tiers.service.ts
66. backend/src/modules/superadmin/superadmin.controller.ts
67. backend/src/modules/superadmin/superadmin.service.ts
68. backend/src/routes/activity.routes.ts
69. backend/src/routes/admin.routes.ts
70. backend/src/routes/auth.routes.ts
71. backend/src/routes/businesses.routes.ts
72. backend/src/routes/camarero-admin.routes.ts
73. backend/src/routes/camarero-kds.routes.ts
74. backend/src/routes/customer.routes.ts
75. backend/src/routes/index.ts
76. backend/src/routes/points.routes.ts
77. backend/src/routes/protected.routes.ts
78. backend/src/routes/public-menu.routes.ts
79. backend/src/routes/public-order.routes.ts
80. backend/src/routes/rewards.routes.ts
81. backend/src/routes/superadmin.routes.ts
82. backend/src/routes/tiers.routes.ts
83. backend/src/routes/uploads.routes.ts
84. backend/src/routes/waiter.routes.ts
85. backend/src/shared/auth/__tests__/auth.service.test.ts
86. backend/src/shared/auth/auth.controller.ts
87. backend/src/shared/auth/auth.dto.ts
88. backend/src/shared/auth/auth.service.ts
89. backend/src/shared/auth/password-reset.controller.ts
90. backend/src/shared/auth/password-reset.service.ts
91. backend/src/shared/auth/registration.controller.ts
92. backend/src/shared/auth/registration.service.ts
93. backend/src/shared/businesses/businesses.controller.ts
94. backend/src/shared/businesses/businesses.service.ts
95. backend/src/shared/middleware/auth.middleware.ts
96. backend/src/shared/middleware/module.middleware.ts
97. backend/src/shared/middleware/multer.config.ts
98. backend/src/shared/middleware/role.middleware.ts
99. backend/src/shared/services/loyalty-points.service.ts
100. backend/src/shared/services/table.service.ts
101. backend/src/shared/uploads/uploads.controller.ts
102. backend/src/shared/uploads/uploads.service.ts
103. backend/src/shared/utils/cloudinary.config.ts
104. backend/src/shared/utils/validation.ts
105. backend/test-server.js
106. backend/tests/integration/auth.test.ts
107. backend/tests/integration/points.test.ts
108. backend/tests/integration/rewards.test.ts
109. backend/tests/integration/tiers.test.ts
110. backend/tsconfig.json
111. backend/vitest.config.ts
112. frontend/eslint.config.js
113. frontend/index.html
114. frontend/package.json
115. frontend/public/locales/en/translation.json
116. frontend/public/locales/es/translation.json
117. frontend/src/App.tsx
118. frontend/src/i18n.ts
119. frontend/src/index.css
120. frontend/src/main.tsx
121. frontend/src/modules/camarero/components/admin/menu/MenuCategoryFormModal.tsx
122. frontend/src/modules/camarero/components/admin/menu/MenuCategoryManager.tsx
123. frontend/src/modules/camarero/components/admin/menu/MenuItemFormModal.tsx
124. frontend/src/modules/camarero/components/admin/menu/MenuItemManager.tsx
125. frontend/src/modules/camarero/components/admin/menu/ModifierGroupsManagementModal.tsx
126. frontend/src/modules/camarero/components/admin/menu/ModifierOptionsManagementModal.tsx
127. frontend/src/modules/camarero/components/public/menu/CategoryAccordion.tsx
128. frontend/src/modules/camarero/components/public/menu/MenuItemCard.tsx
129. frontend/src/modules/camarero/components/public/menu/ModifierGroupInteractiveRenderer.tsx
130. frontend/src/modules/camarero/components/public/menu/ShoppingCartModal.tsx
131. frontend/src/modules/camarero/hooks/useActiveOrderState.ts
132. frontend/src/modules/camarero/hooks/useAdminMenuCategories.ts
133. frontend/src/modules/camarero/hooks/useAdminMenuItems.ts
134. frontend/src/modules/camarero/hooks/useAdminModifierGroups.ts
135. frontend/src/modules/camarero/hooks/useAdminModifierOptions.ts
136. frontend/src/modules/camarero/hooks/useMenuItemConfigurator.ts
137. frontend/src/modules/camarero/hooks/usePublicMenuData.ts
138. frontend/src/modules/camarero/hooks/usePublicOrderCart.ts
139. frontend/src/modules/camarero/hooks/useWaiterPickupItems.ts
140. frontend/src/modules/camarero/pages/OrderStatusPage.tsx
141. frontend/src/modules/camarero/pages/PublicMenuViewPage.tsx
142. frontend/src/modules/camarero/pages/admin/camarero/KitchenDisplayPage.tsx
143. frontend/src/modules/camarero/pages/admin/camarero/MenuManagementPage.tsx
144. frontend/src/modules/camarero/pages/admin/camarero/WaiterOrderManagementPage.tsx
145. frontend/src/modules/camarero/pages/admin/camarero/WaiterPickupPage.tsx
146. frontend/src/modules/camarero/services/kdsService.ts
147. frontend/src/modules/camarero/services/publicOrderApiService.ts
148. frontend/src/modules/camarero/services/waiterService.ts
149. frontend/src/modules/camarero/types/camarero.types.ts
150. frontend/src/modules/camarero/types/menu.types.ts
151. frontend/src/modules/camarero/types/publicOrder.types.ts
152. frontend/src/modules/loyalpyme/components/AddRewardForm.tsx
153. frontend/src/modules/loyalpyme/components/GenerateQrCode.tsx
154. frontend/src/modules/loyalpyme/components/admin/AdjustPointsModal.tsx
155. frontend/src/modules/loyalpyme/components/admin/AssignRewardModal.tsx
156. frontend/src/modules/loyalpyme/components/admin/BulkAdjustPointsModal.tsx
157. frontend/src/modules/loyalpyme/components/admin/ChangeTierModal.tsx
158. frontend/src/modules/loyalpyme/components/admin/CustomerBulkActionsBar.tsx
159. frontend/src/modules/loyalpyme/components/admin/CustomerDetailsModal.tsx
160. frontend/src/modules/loyalpyme/components/admin/CustomerFiltersBar.tsx
161. frontend/src/modules/loyalpyme/components/admin/CustomerTable.tsx
162. frontend/src/modules/loyalpyme/components/admin/StatCard.module.css
163. frontend/src/modules/loyalpyme/components/admin/StatCard.test.tsx
164. frontend/src/modules/loyalpyme/components/admin/StatCard.tsx
165. frontend/src/modules/loyalpyme/components/admin/rewards/RewardForm.tsx
166. frontend/src/modules/loyalpyme/components/admin/tiers/AddTierBenefitForm.tsx
167. frontend/src/modules/loyalpyme/components/admin/tiers/CreateTierModal.tsx
168. frontend/src/modules/loyalpyme/components/admin/tiers/DeleteTierModal.tsx
169. frontend/src/modules/loyalpyme/components/admin/tiers/EditTierModal.tsx
170. frontend/src/modules/loyalpyme/components/admin/tiers/TierBenefitsModal.tsx
171. frontend/src/modules/loyalpyme/components/admin/tiers/TierForm.tsx
172. frontend/src/modules/loyalpyme/components/admin/tiers/TierTable.tsx
173. frontend/src/modules/loyalpyme/components/customer/NextTierPreview.tsx
174. frontend/src/modules/loyalpyme/components/customer/QrValidationSection.tsx
175. frontend/src/modules/loyalpyme/components/customer/RewardList.tsx
176. frontend/src/modules/loyalpyme/components/customer/TierBenefitsDisplay.tsx
177. frontend/src/modules/loyalpyme/components/customer/UserInfoDisplay.tsx
178. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/ActivityTab.tsx
179. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/OffersTab.tsx
180. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/ProfileTab.tsx
181. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/RewardsTab.tsx
182. frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/SummaryTab.tsx
183. frontend/src/modules/loyalpyme/hooks/useAdminCustomersData.ts
184. frontend/src/modules/loyalpyme/hooks/useAdminOverviewStats.ts
185. frontend/src/modules/loyalpyme/hooks/useAdminRewards.ts
186. frontend/src/modules/loyalpyme/hooks/useCustomerActivity.ts
187. frontend/src/modules/loyalpyme/hooks/useCustomerRewardsData.ts
188. frontend/src/modules/loyalpyme/hooks/useCustomerTierData.ts
189. frontend/src/modules/loyalpyme/hooks/useQrScanner.ts
190. frontend/src/modules/loyalpyme/hooks/useUserProfileData.ts
191. frontend/src/modules/loyalpyme/pages/CustomerDashboardPage.tsx
192. frontend/src/modules/loyalpyme/pages/admin/AdminCustomerManagementPage.module.css
193. frontend/src/modules/loyalpyme/pages/admin/AdminCustomerManagementPage.tsx
194. frontend/src/modules/loyalpyme/pages/admin/AdminGenerateQr.tsx
195. frontend/src/modules/loyalpyme/pages/admin/AdminOverview.tsx
196. frontend/src/modules/loyalpyme/pages/admin/AdminRewardsManagement.tsx
197. frontend/src/modules/loyalpyme/pages/admin/tiers/TierManagementPage.tsx
198. frontend/src/modules/loyalpyme/pages/admin/tiers/TierSettingsPage.tsx
199. frontend/src/modules/loyalpyme/services/adminCustomerService.ts
200. frontend/src/modules/loyalpyme/services/adminService.ts
201. frontend/src/modules/superadmin/components/SubscriptionManagementModal.tsx
202. frontend/src/modules/superadmin/pages/SuperAdminPage.tsx
203. frontend/src/modules/superadmin/services/superAdminService.ts
204. frontend/src/pages/ForgotPasswordPage.tsx
205. frontend/src/pages/LoginPage.module.css
206. frontend/src/pages/LoginPage.tsx
207. frontend/src/pages/RegisterBusinessPage.tsx
208. frontend/src/pages/RegisterPage.tsx
209. frontend/src/pages/ResetPasswordPage.tsx
210. frontend/src/routes/index.tsx
211. frontend/src/shared/components/PrivateRoute.tsx
212. frontend/src/shared/components/layout/AdminNavbar.tsx
213. frontend/src/shared/components/layout/AppHeader.tsx
214. frontend/src/shared/components/layout/MainLayout.tsx
215. frontend/src/shared/components/layout/PublicLayout.tsx
216. frontend/src/shared/components/utils/ImageUploadCropper.tsx
217. frontend/src/shared/components/utils/canvasPreview.ts
218. frontend/src/shared/hooks/useLayoutUserData.ts
219. frontend/src/shared/services/axiosInstance.ts
220. frontend/src/shared/services/businessService.ts
221. frontend/src/shared/types/superadmin.types.ts
222. frontend/src/shared/types/user.types.ts
223. frontend/src/test/setup.ts
224. frontend/src/theme.ts
225. frontend/src/vite-env.d.ts
226. frontend/tsconfig.app.json
227. frontend/tsconfig.json
228. frontend/tsconfig.node.json
229. frontend/vite.config.ts


# CONTENIDO DE ARCHIVOS


// ====== [1] DEVELOPMENT_PLAN.md ======
# LoyalPyME - Plan de Desarrollo y Futuras Funcionalidades

**√öltima Actualizaci√≥n:** 17 de Junio de 2025 (Refleja el ciclo completo de pedido LC (pago incluido) como COMPLETADO. Establece "Dividir la Cuenta" como la nueva prioridad CR√çTICA para el desarrollo de LC.)

Este documento detalla las tareas pendientes inmediatas, el alcance definido para las pr√≥ximas versiones operativas (con √©nfasis en el M√≥dulo Camarero - LC), la deuda t√©cnica y las ideas para la evoluci√≥n futura. Se busca un m√°ximo detalle para guiar el desarrollo, incluyendo consideraciones de UX, modelos de datos implicados, y flujos de trabajo.

---

## A. TRABAJO RECIENTEMENTE COMPLETADO / EN PROGRESO / CORRECCIONES ‚úÖ

‚≠ê **[COMPLETADO - MVP Base Plataforma] Panel Super Admin y Gesti√≥n de Negocios/M√≥dulos (backend, frontend)**

‚≠ê **[COMPLETADO - M√≥dulo Camarero - Gesti√≥n de Carta Digital] LC - Backend (Modelos BD y API) y Frontend (UI Admin) para Gesti√≥n Completa de Carta Digital.**

‚≠ê **[COMPLETADO - M√≥dulo Camarero - Vista Cliente y Flujo de Pedido con Modificadores] LC - Backend y Frontend: Visualizaci√≥n de Carta, Configuraci√≥n de √çtems, Carrito y Env√≠o de Pedido por Cliente Final.**

‚≠ê **[COMPLETADO - M√≥dulo Camarero - KDS Funcional (Backend API, L√≥gica de Estados y Frontend con Acciones)]**

‚≠ê **[COMPLETADO - M√≥dulo Camarero - Ciclo de Servicio de Camarero (Entrega de √çtems)]**

‚≠ê **[COMPLETADO - M√≥dulo Camarero - Ciclo Financiero Completo del Pedido]**

- **Detalles Alcanzados:**
  - **Pedir la Cuenta:** Funcionalidad implementada y validada en backend y frontend (`OrderStatusPage`) para que el cliente solicite la cuenta, cambiando el estado del pedido a `PENDING_PAYMENT`.
  - **Marcar Como Pagado:** Funcionalidad implementada y validada en backend y la interfaz del camarero (`WaiterOrderManagementPage`). El camarero puede marcar un pedido como `PAID`, lo que libera la mesa asociada y dispara la asignaci√≥n de puntos de fidelidad LCo al cliente correcto.
  - **A√±adir √çtems a Pedido Existente:** La l√≥gica para que un cliente a√±ada m√°s productos a un pedido en curso (`IN_PROGRESS` o `COMPLETED`) est√° implementada y validada en el backend y frontend.

---

## B. PRIORIDADES ACTUALES: M√≥dulo "LoyalPyME Camarero" (LC) - Funcionalidades Avanzadas de Cuenta üöÄ

Con el ciclo de vida completo del pedido ya implementado, el objetivo inmediato es a√±adir funcionalidades avanzadas que aporten gran valor a la operativa del restaurante, como la divisi√≥n de cuentas.

**BLOQUE 1: FUNCIONALIDADES AVANZADAS DE GESTI√ìN DE CUENTA**

**B1.1. ‚≠ê [CR√çTICO - PENDIENTE] LC - Dividir la Cuenta (Split Bill)**

- **Objetivo Detallado:** Implementar la capacidad para que un camarero divida la cuenta de un pedido pendiente de pago, ya sea asignando √≠tems espec√≠ficos a diferentes personas/pagos, o dividiendo el total en partes iguales.
- **Sub-Tareas Detalladas (Backend):**
  1.  **Dise√±o de Datos (`schema.prisma`):**
      - Considerar un nuevo modelo `PartialPayment` o `SubOrder` relacionado con el `Order` principal. Este modelo podr√≠a contener campos como `amount`, `paymentMethod`, `status`, `paidByStaffId`, y una relaci√≥n a los `OrderItem`s que incluye.
      - El `Order` principal podr√≠a tener un nuevo estado `PARTIALLY_PAID` en su enum `OrderStatus`.
  2.  **L√≥gica de Servicio (`split-bill.service.ts`):**
      - Crear un nuevo servicio que encapsule la l√≥gica compleja de la divisi√≥n.
      - M√©todo `splitOrderByItems(orderId, splits: { items: orderItemIds[], paymentDetails: ... }[])`: Recibe un array de "divisiones", cada una con sus √≠tems y detalles de pago.
      - M√©todo `splitByAmount(orderId, numberOfWays: number)`: Divide `finalAmount` entre el n√∫mero de partes.
      - Debe validar que la suma de las partes coincida con el total del pedido antes de procesar los pagos.
  3.  **Controladores y Rutas:**
      - Nuevos endpoints protegidos en `/api/camarero/staff/order/:orderId/split-bill`. Por ejemplo, uno para iniciar la divisi√≥n y otro para procesar cada pago parcial.
- **Sub-Tareas Detalladas (Frontend - Camarero):**
  1.  **Dise√±o de UI/UX:**
      - En la vista de gesti√≥n de un pedido, un bot√≥n "Dividir Cuenta".
      - Esto abrir√° un modal o una nueva vista dedicada. La UI debe ser muy clara, mostrando todos los √≠tems del pedido a la izquierda y varias "columnas" o "cestas" a la derecha, representando a cada persona que va a pagar.
      - El camarero debe poder arrastrar y soltar √≠tems a cada cesta. La UI recalcular√° los subtotales de cada cesta en tiempo real.
      - Debe haber una opci√≥n para "dividir equitativamente" que distribuya el total autom√°ticamente.
  2.  **Integraci√≥n con API:**
      - Conectar la nueva UI con los endpoints del backend para procesar cada pago parcial de forma individual.
      - La vista principal del pedido debe reflejar los pagos parciales realizados y el saldo restante.

---

## C. FUNDAMENTOS T√âCNICOS ESENCIALES LC (Paralelo y Continuo)

**C1. [ALTA] Testing Backend:**

- **PENDIENTE (Prioridad Alta):**
  - Tests unitarios y de integraci√≥n para la l√≥gica de "Dividir la Cuenta" (`split-bill.service.ts`).
  - Tests para la API de gesti√≥n de personal y PINs cuando se desarrolle.

**C2. [CR√çTICA - EN PROGRESO] Validaci√≥n Robusta Backend (Zod o `class-validator`):**

- **PENDIENTE:**
  - Crear y validar DTOs para los nuevos endpoints de "Dividir la Cuenta".

**C3. [ALTA - PENDIENTE] Seguridad LC:**

- **PENDIENTE:**
  - Implementar l√≥gica de autenticaci√≥n para `StaffPin` si se decide usarla para login r√°pido del camarero.
  - Planificar c√≥mo se integrar√° el futuro sistema de permisos granulares.

**C4. [ALTA - EN PROGRESO] Logging y Monitoring B√°sico LC:**

- **PENDIENTE:**
  - A√±adir logs detallados para el nuevo flujo de "Dividir la Cuenta".

**C5. [MEDIA - PENDIENTE] Internacionalizaci√≥n (i18n) Completa LC:**

- **PENDIENTE:**
  - Traducir todos los textos de las nuevas interfaces (ej. modal de "Dividir la Cuenta").

---

## D. FUNCIONALIDADES LOYALPYME CORE (LCo) Y MEJORAS PLATAFORMA - (Prioridad Re-evaluada Post-LC MVP Cierre de Pedido)

- **D1. [MEDIA] LCo - Mejoras UX/UI Panel Cliente**
- **D2. [BAJA/MEDIA] LCo - Gesti√≥n de Notificaciones al Cliente (Email/Push)**
- **D3. [BAJA/MEDIA] LCo - Estad√≠sticas Avanzadas para Admin**
- **D4. [MEDIA] Plataforma - Mejoras UI/UX Panel Admin General**
- **D5. [BAJA/MEDIA] Plataforma - Documentaci√≥n API Swagger/OpenAPI m√°s Detallada**
- **D6. [BAJA] Plataforma - Configuraci√≥n Adicional del Negocio por el Admin**
- **D7. [ALTA - POST LC MVP] LC - Integraci√≥n Completa con Fidelizaci√≥n LCo**
- **D8. [BAJA] Plataforma - Onboarding y Ayuda (Gu√≠as y Tooltips)**
- **D9. [BAJA/MEDIA] Plataforma - Optimizaci√≥n y Rendimiento General**

---

## E. DEUDA T√âCNICA Y MEJORAS CONTINUAS (Transversales) üõ†Ô∏è

- **E1. [ALTA] Refactorizaci√≥n y Reorganizaci√≥n de C√≥digo Continuo**
- **E2. [MEDIA] Mejorar la Gesti√≥n y Presentaci√≥n de Errores (Backend y Frontend)**
- **E3. [MEDIA] Actualizaci√≥n de Dependencias Peri√≥dica y Gesti√≥n de Vulnerabilidades**
- **E4. [EN PROGRESO - LC] Validaci√≥n Robusta Backend (`class-validator` y `class-transformer`)**
- **E5. [BAJA/MEDIA] Optimizaci√≥n de Consultas a Base de Datos (Continuo)**
- **E6. [MEDIA] Documentaci√≥n Interna del C√≥digo (JSDoc/TSDoc)**
- **E7. [ALTA] Variables de Entorno y Configuraci√≥n Centralizada**
- **E8. [MEDIA] Accesibilidad (a11y) Frontend (Continuo)**
- **E9. [BAJA/MEDIA] CI/CD (Integraci√≥n Continua / Despliegue Continuo) B√°sico**

---

## F. VISI√ìN FUTURA / M√ìDULOS ADICIONALES (Post-LC MVP y Mejoras LCo) üöÄ

- **F1. LC - Funcionalidades Muy Avanzadas de Hosteler√≠a** (Pago Online, **[PRIORIDAD ACTUAL: Divisi√≥n de Cuentas]**, Reservas, Inventario B√°sico, Informes Avanzados)
- **F2. M√≥dulo Pedidos Online / Take Away / Delivery (Extensi√≥n de LC)**
- **F3. App M√≥vil Dedicada (PWA Progresiva y/o Nativa)**
- **F4. Pruebas Automatizadas E2E (End-to-End)**
- **F5. Monetizaci√≥n Avanzada y Planes de Suscripci√≥n Detallados (Plataforma)**
- **F6. Personalizaci√≥n y CRM Avanzado (Transversal LCo/LC)**
- **F7. Gamificaci√≥n Avanzada (LCo)**
- **F8. (VISI√ìN A LARGO PLAZO) M√≥dulo TPV (Terminal Punto de Venta) Integrado**
- **F9. (VISI√ìN A MUY LARGO PLAZO) M√≥dulo Contabilidad / Integraciones Contables**



// ====== [2] LICENSE.md ======
# LoyalPyME - Software Propietario

Copyright (c) 2024-2025 Olivier Hottelet. Todos los derechos reservados.

Este software y su c√≥digo fuente son propiedad exclusiva de Olivier Hottelet.
Este software es confidencial y se considera un secreto comercial.

Queda estrictamente prohibida la copia, reproducci√≥n, modificaci√≥n, distribuci√≥n,
descompilaci√≥n, ingenier√≠a inversa, creaci√≥n de trabajos derivados, o cualquier
otro uso no autorizado de este software, en su totalidad o en parte, sin el
permiso previo, expl√≠cito y por escrito del propietario de los derechos de autor.

El uso de este software est√° sujeto a los t√©rminos y condiciones establecidos
en el acuerdo de licencia aplicable que se proporcionar√° a los usuarios autorizados.

Para consultas sobre licencias, adquisici√≥n, o cualquier otro asunto relacionado
con este software, por favor contacte a: olivierhottelet1980@gmail.com

---

# LoyalPyME - Proprietary Software

Copyright (c) 2024-2025 Olivier Hottelet. All rights reserved.

This software and its source code are the exclusive property of Olivier Hottelet.
This software is confidential and considered a trade secret.

Copying, reproduction, modification, distribution, decompilation, reverse engineering,
creation of derivative works, or any other unauthorized use of this software,
in whole or in part, is strictly prohibited without the prior, explicit,
and written permission of the copyright owner.

Use of this software is subject to the terms and conditions set forth in the
applicable license agreement to be provided to authorized users.

For licensing inquiries, acquisition, or any other matters related to this software,
please contact: olivierhottelet1980@gmail.com



// ====== [3] LOYALPYME_CAMARERO_WORKFLOW.md ======
# LoyalPyME Camarero: ¬°Tu Experiencia Gastron√≥mica, Digitalizada y Eficiente! üßë‚Äçüç≥üì±‚ú®

**√öltima Actualizaci√≥n:** 17 de Junio de 2025 (Refleja el ciclo de vida completo del pedido, incluyendo creaci√≥n, adici√≥n de √≠tems, KDS, servicio, solicitud de cuenta y pago final como funcionalidades completadas y validadas.)

Bienvenido a la experiencia moderna de pedir y disfrutar en tu establecimiento favorito con **LoyalPyME Camarero**. Dise√±ado para agilizar el servicio, personalizar tu pedido y mejorar la comunicaci√≥n, todo directamente desde tu m√≥vil o gestionado eficientemente por el personal del restaurante.

---

## üöÄ **I. El Viaje del Cliente Final: Control y Comodidad en Tu Mano**

Este flujo describe la experiencia del cliente desde su llegada hasta la finalizaci√≥n y pago de su pedido, incluyendo las interacciones con el personal de cocina/barra (KDS) y de sala (Camarero).

### 1. üì≤ **Llegada y Escaneo M√°gico del QR de Mesa**

- **Bienvenida:** Al llegar, el cliente encuentra un c√≥digo QR √∫nico en su mesa, provisto por el establecimiento. Este QR contiene el `tableIdentifier` √∫nico de esa mesa.
- **Escaneo Instant√°neo:** Usando la c√°mara de su smartphone (o una app de lectura de QR), el cliente escanea el c√≥digo. El QR lo redirige a una URL del tipo `https://[tuDominio.com]/m/[businessSlug]/[tableIdentifier]`.
- **Estado: [COMPLETADO]**

### 2. üßæ **Explora la Carta Digital Interactiva (`PublicMenuViewPage.tsx`)**

- **Acceso Inmediato:** Al acceder a la URL, se carga la carta digital del negocio (`businessSlug`), contextualizada para la mesa (`tableIdentifier`).
- **Verificaci√≥n de Pedido Activo (Fundamental):**
  - Al cargar la p√°gina, el sistema revisa `localStorage` buscando una entrada con la clave `activeOrderInfo_BUSINESSSLUG_TABLEIDENTIFIER`.
  - **Si existe un pedido activo (`activeOrderIdForTable`, `activeOrderNumberForTable`):**
    - La UI muestra un mensaje destacado: "Tienes el pedido #{{orderNumber}} en curso para esta mesa."
    - **Opciones Clave:**
      - "Ver Estado del Pedido": Enlaza directamente a `/order-status/:activeOrderId`.
      - **"[COMPLETADO Y VALIDADO]" A√±adir m√°s √çtems a este Pedido:** La carta se mantiene interactiva, permitiendo al cliente a√±adir nuevos productos al pedido en curso. El carrito y el bot√≥n de env√≠o se adaptan para esta funcionalidad.
  - **Si NO existe pedido activo:** La p√°gina funciona en modo "crear nuevo pedido", con el carrito vac√≠o.
- **Navegaci√≥n y Detalle del √çtem (`MenuItemCard.tsx`):**
  - Categor√≠as del men√∫ presentadas en componentes tipo acorde√≥n (`CategoryAccordion.tsx`).
  - Cada √≠tem se muestra en una tarjeta (`MenuItemCard.tsx`) con su imagen, nombre (i18n), descripci√≥n (i18n), precio base, lista de al√©rgenos y etiquetas.
- **Estado: [COMPLETADO Y VALIDADO]**

### 3. üé® **Personaliza tu Plato (`MenuItemCard.tsx`, `ModifierGroupInteractiveRenderer.tsx`)**

- Al seleccionar un √≠tem, se abre un modal o secci√≥n para la configuraci√≥n de modificadores.
- **Selecci√≥n de Modificadores:**
  - Se presentan los `ModifierGroup`s asociados al √≠tem.
  - Cada grupo muestra sus `ModifierOption`s seg√∫n el `uiType` (RADIO para selecci√≥n √∫nica, CHECKBOX para m√∫ltiple).
  - **Validaci√≥n en Tiempo Real Frontend:** Se aplican las reglas `minSelections`, `maxSelections`, y `isRequired`.
  - **C√°lculo de Precio Din√°mico:** El precio del √≠tem se actualiza instant√°neamente en la UI.
- **Cantidad y Notas:** El cliente puede ajustar la cantidad del √≠tem y a√±adir instrucciones especiales.
- **Estado: [COMPLETADO Y VALIDADO]**

### 4. üõí **Tu Carrito de Pedido (`ShoppingCartModal.tsx` en `PublicMenuViewPage.tsx`)**

- **Acumulaci√≥n de √çtems:** Los √≠tems configurados se a√±aden al estado local `currentOrderItems` y se persisten en `localStorage`.
- **Modal del Carrito:** Permite la revisi√≥n detallada del pedido, modificaci√≥n de cantidades, eliminaci√≥n de √≠tems y edici√≥n de notas generales (`orderNotes`).
- **Estado: [COMPLETADO Y VALIDADO]**

### 5. ‚≠ê **Opcional: Identif√≠cate para Beneficios LCo (Integraci√≥n con LoyalPyME Core)**

- **Contexto:** Si el `Business` tiene el m√≥dulo LCo activo.
- **Flujo:** Si el cliente est√° logueado, su `customerId` se obtiene del `localStorage` o de un contexto de autenticaci√≥n y se asocia al pedido al enviarlo.
- **Impacto:** Al pagar el pedido, el backend asociar√° los puntos de fidelidad a esta cuenta de cliente.
- **Estado: [COMPLETADO Y VALIDADO]**

### 6. ‚û°Ô∏è **Env√≠a tu Pedido o A√±ade a uno Existente**

- Desde el `ShoppingCartModal`, el cliente pulsa "Enviar Pedido" o "A√±adir al Pedido".
- **Payload:** Se construye un DTO que incluye el array de `items`, `orderNotes?`, `tableIdentifier`, y `customerId?`.
- **Endpoint:** La l√≥gica del frontend (`handleOrderSubmission`) decide si llamar a `POST /public/order/:businessSlug` (para crear) o a `POST /public/order/:orderId/items` (para a√±adir).
- **Backend:** Valida exhaustivamente la petici√≥n (disponibilidad, reglas de modificadores), recalcula precios y crea o actualiza los registros en la base de datos de forma transaccional.
- **Frontend Post-Env√≠o:** Muestra notificaci√≥n de √©xito, guarda `activeOrderInfo` en `localStorage` (si es nuevo), limpia el carrito y redirige a `/order-status/:orderId`.
- **Estado: [COMPLETADO Y VALIDADO]**

### 7. ‚è≥ **P√°gina de Estado del Pedido (`OrderStatusPage.tsx`)**

- **Acceso y Visualizaci√≥n:** Muestra `orderNumber`, `tableIdentifier`, estado general del `Order` y estado individual de cada `OrderItem`.
- **Polling Autom√°tico:** Refresca datos llamando a `GET /public/order/:orderId/status` cada ~10 segundos.
- **L√≥gica de Pedido Finalizado:** Si `orderStatus` es `PAID` o `CANCELLED`, detiene el polling, muestra un mensaje final y permite iniciar un nuevo pedido (limpiando `localStorage`).
- **Botones de Acci√≥n:**
  - "Volver al Men√∫": Enlaza de vuelta a la carta para poder a√±adir m√°s √≠tems al pedido activo.
  - **"[COMPLETADO Y VALIDADO]" Bot√≥n "Pedir la Cuenta":** Se muestra si el pedido est√° en un estado apropiado. Al pulsarlo, llama a `POST /public/order/:orderId/request-bill`, y la UI refleja "Cuenta solicitada..." al actualizarse el estado a `PENDING_PAYMENT`.
- **Estado: [COMPLETADO Y VALIDADO]**

---

## üë®‚Äçüç≥ **II. Flujo del Personal de Cocina/Barra (KDS - Kitchen Display System) - [COMPLETADO Y VALIDADO]**

El KDS (`KitchenDisplayPage.tsx`) es el panel de control digital para la preparaci√≥n eficiente y coordinada de los pedidos.

### 1. üñ•Ô∏è **Acceso y Visualizaci√≥n de Comandas/√çtems**

- El personal se autentica, selecciona su destino KDS ("COCINA", "BARRA") y ve una cola de `OrderItem`s pendientes o en preparaci√≥n, ordenados cronol√≥gicamente.
- **Estado: [COMPLETADO Y VALIDADO]**

### 2. üîÑ **Gesti√≥n del Estado de Preparaci√≥n de √çtems (`PATCH /api/camarero/kds/items/:orderItemId/status`)**

- A trav√©s de botones de acci√≥n, el personal cambia el estado de los √≠tems de `PENDING_KDS` -> `PREPARING` -> `READY`, o los cancela.
- El backend actualiza el estado general del `Order` (`IN_PROGRESS`, `ALL_ITEMS_READY`, etc.) en consecuencia.
- **Estado: [COMPLETADO Y VALIDADO]**

---

## ü§µ **III. Flujo del Personal de Sala/Camareros (Interfaz de Camarero)**

Esta secci√≥n detalla la funcionalidad para el rol `WAITER` a trav√©s de las interfaces de servicio.

### 1. üîë **Acceso y Vista General (Interfaz Camarero)**

- **Autenticaci√≥n:** Login est√°ndar para `UserRole.WAITER` (email/password).
- **Panel Principal:** Actualmente compuesto por `WaiterPickupPage.tsx` y `WaiterOrderManagementPage.tsx`.

### 2. üçΩÔ∏è **Recogida y Entrega de Pedidos (`WaiterPickupPage.tsx`)**

- El camarero ve una lista de `OrderItem`s que est√°n en estado `READY`.
- Al entregar un √≠tem, lo marca como "Servido" (`SERVED`). El √≠tem desaparece de la lista.
- Cuando todos los √≠tems de un pedido est√°n servidos, el `Order.status` general cambia a `COMPLETED`.
- **Estado: [COMPLETADO Y VALIDADO]**

### 3. üí∏ **Gesti√≥n de Cuentas y Pago (`WaiterOrderManagementPage.tsx`)**

- **Visualizar Pedidos para Cobro:** En la lista de pedidos, se destacan aquellos con `Order.status = PENDING_PAYMENT`.
- **Procesar Pago y Marcar como Pagado:**
  - El camarero tiene una acci√≥n "Marcar Como Pagada" para un pedido `PENDING_PAYMENT`.
  - Al usarla, se llama a `POST /api/camarero/staff/order/:orderId/mark-as-paid`.
  - El backend (`OrderService.markOrderAsPaid`) actualiza `Order.status = PAID`, registra `paidAt` y el `paidByUserId`.
- **Liberar Mesa e Integraci√≥n LCo:**
  - **Backend:** Autom√°ticamente, tras marcar como `PAID`, el servicio actualiza el `Table.status` a `AVAILABLE`. Si el pedido ten√≠a un `customerLCoId` y el m√≥dulo LCo est√° activo, se dispara la asignaci√≥n de puntos.
  - **Frontend:** La UI del camarero y del cliente reflejan el cambio de estado.
- **Estado: [COMPLETADO Y VALIDADO]**

---

## üëë **IV. Flujo del Administrador del Negocio (LC) - Configuraci√≥n y Supervisi√≥n**

### 1. ‚öôÔ∏è **Gesti√≥n de Carta Digital**

- CRUD completo de `MenuCategory`, `MenuItem`, `ModifierGroup`, `ModifierOption` funcional.
- **Estado: [COMPLETADO Y VALIDADO]**

### 2. ü™ë **Gesti√≥n de Mesas y Personal**

- Funcionalidades b√°sicas para la gesti√≥n de mesas y personal est√°n implementadas, permitiendo el flujo actual.
- **Estado: [FUNCIONALIDAD BASE COMPLETADA]**

---

‚ú® **Beneficios para el Negocio con LoyalPyME Camarero (Visi√≥n Actual):**

- **Eficiencia Operativa:** Reducci√≥n de errores en la toma de comandas, comunicaci√≥n directa y clara con cocina/barra.
- **Mejora de la Experiencia del Cliente:** Autonom√≠a para pedir, personalizar, y seguir el estado del pedido.
- **Optimizaci√≥n de Tiempos:** Agilizaci√≥n del proceso de pedido, preparaci√≥n, servicio y pago.
- **Incremento Potencial de Ventas:** Facilidad para a√±adir √≠tems a un pedido existente.
- **Recopilaci√≥n de Datos:** Informaci√≥n valiosa sobre √≠tems populares, tiempos de preparaci√≥n, flujo de pedidos.
- **Imagen Moderna y Profesional:** Adopci√≥n de tecnolog√≠a para mejorar el servicio.
- **Integraci√≥n con Fidelizaci√≥n (LCo):** Cada pedido pagado se convierte autom√°ticamente en una oportunidad para fidelizar.



// ====== [4] LOYALPYME_CORE_WORKFLOW.md ======
# LoyalPyME Core: ¬°Fidelidad que Premia tu Pasi√≥n por el Negocio! üíñüèÜ‚ú®

Con **LoyalPyME Core**, transforma a tus clientes habituales en embajadores de tu marca. Ofrece un programa de lealtad digital, moderno y f√°cil de gestionar que incentiva la recurrencia, aumenta el ticket medio y te permite conocer mejor a quienes eligen tu negocio d√≠a a d√≠a.

---

## üëë **I. El Viaje del Cliente VIP: Acumulando Beneficios y Sintiendo el Reconocimiento**

La experiencia del cliente con el programa de fidelizaci√≥n de LoyalPyME Core est√° dise√±ada para ser intuitiva, atractiva y gratificante.

### 1. ‚úçÔ∏è **Registro Sencillo y Vinculaci√≥n al Negocio**

- **M√∫ltiples Puntos de Entrada al Registro:**
  - **Desde la Plataforma General:** Si un cliente descubre LoyalPyME, puede registrarse y buscar/seleccionar el negocio espec√≠fico al que desea unirse (si el negocio est√° listado p√∫blicamente en la plataforma).
  - **Invitaci√≥n Directa del Negocio:** El negocio puede promocionar su programa de fidelizaci√≥n con un enlace directo o un c√≥digo QR espec√≠fico que lleve al cliente a una p√°gina de registro ya pre-seleccionada para ese negocio.
  - **(Integraci√≥n con LC)** Durante el proceso de pedido en el M√≥dulo Camarero, se le puede ofrecer la opci√≥n de registrarse para asociar su consumo y ganar puntos.
- **Proceso de Creaci√≥n de Cuenta:**
  - El cliente completa un formulario simple con:
    - Email (ser√° su identificador √∫nico).
    - Contrase√±a segura.
    - Nombre (opcional, pero recomendado para personalizaci√≥n).
    - N√∫mero de tel√©fono (para contacto y posibles futuras funcionalidades como notificaciones SMS).
    - Tipo y N√∫mero de Documento (DNI/NIE/Pasaporte, para evitar duplicados y para la gesti√≥n del negocio).
  - Si no vino de un enlace directo, selecciona el `Business` al que se une.
  - El rol asignado ser√° `CUSTOMER_FINAL`.
- **Confirmaci√≥n y Bienvenida:** Tras el registro, recibe una confirmaci√≥n (y opcionalmente un email de bienvenida del negocio).

  ```
  Interfaz de Registro de Cliente (Ejemplo):
  +-------------------------------------------+
  | **√önete a [Nombre del Negocio] y Gana!**   |
  | O **Crea tu Cuenta LoyalPyME**            |
  |-------------------------------------------|
  | Email:         [ tu@email.com         ]  * |
  | Contrase√±a:    [ ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢           ]  * |
  | Confirmar Cont.:[ ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢           ]  * |
  | Nombre:        [ Tu Nombre Completo     ]    |
  | Tel√©fono:      [ +34 6XX XXX XXX      ]  * |
  | Documento:                                |
  |   Tipo: [ DNI/NIE/Pasaporte ‚ñº ]         * |
  |   N¬∫:   [ XXXXXXXXXL             ]  * |
  | Negocio (si aplica): [ [Negocio X] ‚ñº ]   * |
  |-------------------------------------------|
  |         [ Crear Mi Cuenta ]               |
  |                                           |
  |   ¬øYa tienes cuenta? [ Iniciar Sesi√≥n ]   |
  +-------------------------------------------+
  ```

### 2. üöÄ **Acceso a su Panel de Cliente Personalizado (`CustomerDashboardPage.tsx`)**

- **Login Seguro:** El cliente inicia sesi√≥n con su email y contrase√±a.
- **Dashboard Intuitivo:** Accede a su panel personal, que es el centro de control de su actividad y beneficios en el programa de fidelizaci√≥n del negocio.

  - **Pesta√±as Claras:**
    - **Resumen:** Vista general de su estado.
    - **Recompensas:** Cat√°logo de recompensas y regalos.
    - **Mi Actividad:** Historial detallado de transacciones.
    - **(Futuro) Ofertas y Noticias:** Comunicaciones del negocio.
    - **(Futuro) Mi Perfil:** Gesti√≥n de sus datos personales.

  ```
  Dashboard del Cliente - Pesta√±a Resumen (Ejemplo):
  +----------------------------------------------------+
  | Hola, [Nombre Cliente]! üëã  [Logo/Nombre Negocio]  |
  |----------------------------------------------------|
  | [Resumen] [Recompensas] [Actividad] [...]          |
  |====================================================|
  | **Puntos Actuales:**                               |
  |          # XXXX Puntos ‚ú®                         |
  |----------------------------------------------------|
  | **Nivel Actual:** **[Nombre del Nivel]** üèÖ          |
  |   [ Ver Beneficios de mi Nivel ]                   |
  |----------------------------------------------------|
  | **Progreso al Pr√≥ximo Nivel: [Nombre Pr√≥ximo Nivel]** |
  |   [|||||||||||||           ]  XX% Completado      |
  |   (Te faltan YY [m√©tricas] para alcanzarlo)        |
  |   [ Ver Beneficios del Pr√≥ximo Nivel ] (Popover)   |
  |----------------------------------------------------|
  | **Recompensas y Regalos Destacados:**              |
  |   [ Grid con algunas recompensas/regalos ]         |
  |   [ Ver Todas las Recompensas y Regalos ]          |
  |----------------------------------------------------|
  | **Validar C√≥digo QR / Ticket:**                    |
  |   [____________________] [Validar] [üì∑ Escanear]   |
  |----------------------------------------------------|
  | (Opcional) **Tarjeta de Acceso al M√≥dulo Camarero** |
  |   [ Bot√≥n para ir a /m/{slugDelNegocio} ]          |
  +----------------------------------------------------+
  ```

### 3. üí∞ **Acumulaci√≥n de Puntos (`QrValidationSection.tsx`)**

- **Proceso en el Punto de Venta F√≠sico (para negocios sin LC o para compras no hechas v√≠a LC):**
  - Tras realizar una compra o consumir un servicio, el `BUSINESS_ADMIN` o personal autorizado del negocio genera un **c√≥digo QR √∫nico** (o un token alfanum√©rico) desde su panel de LoyalPyME.
  - Este QR/token est√° asociado al **importe de la transacci√≥n** y a un **n√∫mero de ticket/factura** para referencia.
- **Validaci√≥n por el Cliente en su Dashboard LCo:**
  - El cliente accede a la secci√≥n "Validar QR" en su panel.
  - **Opci√≥n 1: Escaneo con C√°mara:** Si accede desde un dispositivo m√≥vil con c√°mara, puede usar la funci√≥n "Escanear QR" para capturar el c√≥digo directamente.
  - **Opci√≥n 2: Introducci√≥n Manual:** Puede teclear el token alfanum√©rico del QR o del ticket en el campo provisto.
- **Resultado:**
  - El sistema valida el token (que no haya sido usado, que no haya expirado, que pertenezca al negocio correcto).
  - Si es v√°lido, se calculan los puntos a otorgar (basado en `Business.pointsPerEuro` y el importe del QR).
  - Los puntos se suman al saldo del cliente.
  - Se registra una entrada en su `ActivityLog` (ej. "Puntos Ganados (QR) - Ticket #12345: +50 Puntos").
  - Esta transacci√≥n (gasto y visita) contribuye al c√°lculo para subir de nivel.
- **(Integraci√≥n con LC)** Si el cliente est√° logueado y realiza un pedido a trav√©s del M√≥dulo Camarero que es posteriormente marcado como pagado, los puntos se pueden sumar autom√°ticamente (ver `MODULE_INTEGRATION_WORKFLOW.md`).

### 4. üìà **Ascenso de Nivel y Desbloqueo de Beneficios (`UserInfoDisplay.tsx`, `TierBenefitsDisplay.tsx`)**

- **Sistema de Niveles Progresivo:** Los negocios configuran m√∫ltiples niveles de lealtad (ej. Bronce, Plata, Oro, Platino), cada uno requiriendo alcanzar un umbral mayor de la m√©trica definida (gasto, visitas, o puntos acumulados hist√≥ricamente).
- **C√°lculo de Nivel:**
  - El sistema recalcula peri√≥dicamente (o tras cada actividad relevante) el nivel del cliente basado en la configuraci√≥n del negocio:
    - `TierCalculationBasis`: SPEND, VISITS, POINTS_EARNED.
    - `TierCalculationPeriodMonths`: 0 para m√©tricas de por vida, o un n√∫mero de meses para un periodo m√≥vil.
  - Cuando el cliente alcanza el `minValue` de un nuevo nivel, su `currentTierId` se actualiza.
- **Visualizaci√≥n del Progreso:**
  - El cliente ve claramente en su dashboard su nivel actual y una barra de progreso hacia el siguiente nivel, indicando cu√°nto le falta.
  - Puede ver los beneficios asociados a su nivel actual y los del siguiente nivel (como incentivo).
- **Beneficios Exclusivos por Nivel (`TierBenefitData`):**
  - **Multiplicador de Puntos:** (ej. "Nivel Oro: Gana Puntos x1.5").
  - **Acceso a Recompensas Exclusivas:** Recompensas que solo est√°n visibles o canjeables para clientes de cierto nivel.
  - **Beneficios Personalizados:** Textos descriptivos de otras ventajas (ej. "Env√≠o Gratis", "Regalo de Cumplea√±os", "Acceso Preferente a Eventos").
- **Pol√≠tica de Descenso:** Seg√∫n la configure el negocio (`TierDowngradePolicy`), el cliente podr√≠a bajar de nivel si no mantiene la actividad requerida o tras una revisi√≥n peri√≥dica.

### 5. üéÅ **Canje de Recompensas y Regalos (`RewardsTab.tsx`, `RewardList.tsx`)**

- **Cat√°logo de Recompensas:**
  - En la pesta√±a "Recompensas" del dashboard, el cliente visualiza todas las recompensas `isActive: true` que el negocio ha configurado para ser canjeadas con puntos.
  - Cada recompensa muestra su nombre (i18n), descripci√≥n (i18n), imagen y el `pointsCost` necesario.
- **Regalos Otorgados:**
  - En la misma secci√≥n (o una subsecci√≥n), el cliente ve los `GrantedReward` con estado `PENDING` que el administrador del negocio le ha asignado directamente (sin coste de puntos).
  - Se muestra qui√©n lo asign√≥ (si es admin) y la fecha de asignaci√≥n.
- **Proceso de Canje:**
  - **Recompensas por Puntos:** Si el cliente tiene suficientes puntos, el bot√≥n "Canjear Recompensa" est√° activo. Al pulsarlo:
    - Se descuentan los `pointsCost` del saldo del cliente.
    - Se crea un registro en `ActivityLog` (ej. "Recompensa Canjeada - Caf√© Gratis: -50 Puntos").
    - El negocio define c√≥mo se materializa el canje (ej. mostrar un c√≥digo al personal, env√≠o autom√°tico de un cup√≥n digital, etc.).
  - **Regalos:** El cliente pulsa "Canjear Regalo".
    - El `GrantedReward` cambia su estado a `REDEEMED` y se registra `redeemedAt`.
    - Se crea un registro en `ActivityLog` (ej. "Regalo Canjeado - Descuento Bienvenida").
- **Notificaciones:** Se informa al cliente del √©xito del canje.

### 6. üìú **Consulta de Historial de Actividad (`ActivityTab.tsx`)**

- El cliente puede ver un listado paginado y cronol√≥gico de todas las transacciones de puntos y canjes:
  - `POINTS_EARNED_QR`: Puntos sumados por validar un QR (con descripci√≥n del ticket).
  - `POINTS_REDEEMED_REWARD`: Puntos restados por canjear una recompensa (con nombre de la recompensa).
  - `GIFT_REDEEMED`: Regalo canjeado (con nombre de la recompensa/regalo).
  - `POINTS_ADJUSTED_ADMIN`: Ajustes manuales de puntos hechos por el admin (con motivo si lo hay).
  - **(Futuro)** `POINTS_EARNED_ORDER_LC`: Puntos ganados por pedidos en el M√≥dulo Camarero.

### 7. üë§ **Gesti√≥n de Perfil (Futuro - `ProfileTab.tsx`)**

- Visualizar y editar sus datos personales (nombre, tel√©fono, email).
- Cambiar contrase√±a.
- (Opcional) Subir una foto de perfil.
- Gestionar preferencias de comunicaci√≥n.

---

## üõ†Ô∏è **II. La Visi√≥n del Negocio: Administrando la Lealtad con Estrategia y Facilidad (`BUSINESS_ADMIN`)**

El panel de administraci√≥n de LoyalPyME Core proporciona al `BUSINESS_ADMIN` todas las herramientas para dise√±ar, implementar y gestionar su programa de fidelizaci√≥n.

### 1. ‚öôÔ∏è **Configuraci√≥n General del Sistema de Tiers (`TierSettingsPage.tsx`)**

- **Habilitaci√≥n del Sistema:** Activar o desactivar completamente el sistema de niveles. Si est√° desactivado, los clientes no progresan por niveles ni obtienen beneficios de tier.
- **Base de C√°lculo de Nivel (`TierCalculationBasis`):**
  - `SPEND`: El nivel se determina por el gasto total acumulado del cliente (suma de los `amount` de los `QrCode` validados).
  - `VISITS`: El nivel se determina por el n√∫mero total de visitas (cada `QrCode` validado cuenta como una visita).
  - `POINTS_EARNED`: El nivel se determina por el total hist√≥rico de puntos ganados por el cliente (sin contar los gastados).
- **Periodo de C√°lculo de Nivel (`tierCalculationPeriodMonths`):**
  - N√∫mero de meses hacia atr√°s desde la fecha actual para considerar las m√©tricas (gasto, visitas, puntos).
  - Si es `0` o `null`, se consideran las m√©tricas de toda la vida del cliente en el programa.
- **Pol√≠tica de Descenso de Nivel (`TierDowngradePolicy`):**
  - `NEVER`: Los clientes nunca bajan de nivel una vez alcanzado.
  - `PERIODIC_REVIEW`: El sistema revisa peri√≥dicamente (ej. en un cron job `processTierUpdatesAndDowngrades`) si los clientes a√∫n cumplen los requisitos de su nivel actual seg√∫n el `tierCalculationBasis` y `tierCalculationPeriodMonths`. Si no, bajan al nivel que les corresponda (o a ninguno).
  - `AFTER_INACTIVITY`: Los clientes bajan a ning√∫n nivel (o al nivel base) si no tienen actividad (`QrCode` validado o, futuramente, pedido LC) durante un periodo espec√≠fico.
- **Periodo de Inactividad para Descenso (`inactivityPeriodMonths`):**
  - N√∫mero de meses de inactividad para aplicar la pol√≠tica `AFTER_INACTIVITY`.

### 2. üåü **Gesti√≥n de Niveles de Fidelizaci√≥n (Tiers) (`TierManagementPage.tsx`)**

- **Creaci√≥n de Niveles (`CreateTierModal.tsx`):**
  - **Nombre del Nivel:** Identificador del nivel (ej. "Bronce", "Miembro VIP").
  - **Nivel (Orden):** Un n√∫mero entero (`level`, ej. 0, 1, 2...) que determina el orden jer√°rquico. Niveles m√°s altos suelen requerir m√°s. El nivel 0 puede ser el base sin requisitos.
  - **Valor M√≠nimo (`minValue`):** El umbral de la m√©trica (definida en `TierCalculationBasis`) que el cliente debe alcanzar para pertenecer a este nivel.
  - **Descripci√≥n (Opcional):** Texto interno para el admin.
  - **Resumen de Beneficios (Opcional - `benefitsDescription`):** Un texto corto que se muestra al cliente para resumir las ventajas del nivel.
  - **Estado Activo (`isActive`):** Solo los niveles activos son considerados para la asignaci√≥n a clientes y visibles para ellos.
- **Edici√≥n y Listado de Niveles (`EditTierModal.tsx`, `TierTable.tsx`):** Modificar cualquiera de los campos anteriores. Ver todos los niveles definidos.
- **Eliminaci√≥n de Niveles:** Se puede eliminar un nivel si no tiene clientes actualmente asignados a √©l.
- **Gesti√≥n de Beneficios por Nivel (`TierBenefitsModal.tsx`, `AddTierBenefitForm.tsx`):**
  - Para cada `Tier` creado, se pueden a√±adir m√∫ltiples `TierBenefit`.
  - **Tipo de Beneficio (`BenefitType`):**
    - `POINTS_MULTIPLIER`: Ej. "1.5" (el cliente gana 1.5 veces los puntos normales).
    - `EXCLUSIVE_REWARD_ACCESS`: El `value` ser√≠a el ID de una `Reward` espec√≠fica que solo los miembros de este tier pueden ver/canjear.
    - `CUSTOM_BENEFIT`: Un texto descriptivo para cualquier otro beneficio (ej. "Acceso prioritario a rebajas", "Bebida de cortes√≠a al mes").
  - **Valor del Beneficio (`value`):** El valor asociado al tipo (el multiplicador, el ID de la recompensa, el texto del beneficio).
  - **Descripci√≥n del Beneficio (Opcional):** M√°s detalles sobre el beneficio.
  - **Estado Activo del Beneficio:** Un beneficio puede estar temporalmente inactivo sin eliminarlo del tier.

### 3. üéÅ **Gesti√≥n de Recompensas Canjeables (`AdminRewardsManagement.tsx`, `RewardForm.tsx`)**

- **Creaci√≥n de Recompensas:**
  - **Nombre (ES y EN):** Para internacionalizaci√≥n.
  - **Descripci√≥n (ES y EN, Opcional):** Detalles sobre la recompensa.
  - **Coste en Puntos (`pointsCost`):** Cu√°ntos puntos necesita el cliente para canjearla.
  - **Imagen:** Subida de imagen (Cloudinary) para hacerla visualmente atractiva.
  - **Estado Activo (`isActive`):** Solo las recompensas activas son visibles y canjeables por los clientes.
- **Listado, Edici√≥n y Eliminaci√≥n:** Gestionar el cat√°logo de recompensas. Una recompensa no se puede eliminar si ha sido otorgada como regalo (`GrantedReward`) y est√° pendiente, o si hay registros de canje asociados (dependiendo de las restricciones de BD).

### 4. üë• **Administraci√≥n Avanzada de Clientes (`AdminCustomerManagementPage.tsx` y Modales Asociados)**

- **Listado y Filtros:**
  - Ver una tabla paginada de todos los clientes (`CUSTOMER_FINAL`) del negocio.
  - Buscar por nombre o email.
  - Filtrar por estado (Activo/Inactivo), si es Favorito, o por Nivel actual.
  - Ordenar por diversas columnas (nombre, puntos, fecha de registro, etc.).
- **Acciones sobre Clientes Individuales:**
  - **Ver Detalles (`CustomerDetailsModal.tsx`):** Acceder a una vista completa del perfil del cliente, incluyendo puntos, nivel, fecha de consecuci√≥n del nivel, historial de actividad reciente (opcional), y notas administrativas.
  - **Editar Notas Administrativas:** A√±adir/modificar comentarios internos sobre un cliente, visibles solo para los administradores.
  - **Ajustar Puntos Manualmente (`AdjustPointsModal.tsx`):** Sumar o restar puntos al saldo de un cliente, con un campo opcional para indicar el motivo (ej. "Bonificaci√≥n por cumplea√±os", "Correcci√≥n de error"). Esta acci√≥n genera un `ActivityLog`.
  - **Cambiar Nivel Manualmente (`ChangeTierModal.tsx`):** Forzar la asignaci√≥n de un cliente a un nivel espec√≠fico, o quitarle el nivel (volver a b√°sico). Esto sobrescribe el c√°lculo autom√°tico para esa instancia. `tierAchievedAt` se actualiza.
  - **Asignar Recompensa como Regalo (`AssignRewardModal.tsx`):** Otorgar una recompensa del cat√°logo al cliente sin que este gaste puntos. Se crea un registro `GrantedReward` con estado `PENDING`.
  - **Marcar/Desmarcar como Favorito:** Para destacar clientes importantes.
  - **Activar/Desactivar Cuenta de Cliente:** Un cliente inactivo no puede loguearse ni acumular/canjear puntos.
- **Acciones Masivas sobre Clientes Seleccionados:**
  - Activar/Desactivar m√∫ltiples clientes a la vez.
  - Eliminar m√∫ltiples clientes (con precauci√≥n y validaciones si tienen datos asociados).
  - Ajustar puntos (sumar/restar la misma cantidad) a un grupo de clientes, con un motivo general.

### 5. üéüÔ∏è **Generaci√≥n de QR de Puntos para Transacciones (`AdminGenerateQr.tsx`)**

- **Interfaz Simple:** El admin introduce:
  - **Importe de la Venta (‚Ç¨):** El valor de la compra que el cliente acaba de realizar.
  - **N√∫mero de Ticket/Referencia:** Un identificador √∫nico para esa transacci√≥n (para evitar duplicados y para auditor√≠a).
- **Generaci√≥n:** El sistema crea un registro `QrCode` en la BD con:
  - Un `token` UUID √∫nico.
  - El `businessId`.
  - El `amount` y `ticketNumber` introducidos.
  - Una `expiresAt` (ej. 30 minutos) para limitar su validez.
  - Estado inicial `PENDING`.
- **Visualizaci√≥n:** Se muestra el c√≥digo QR (generado a partir del `token`) en pantalla para que el cliente lo escanee, o se muestra el `token` alfanum√©rico para que el cliente lo introduzca manualmente.

### 6. üìä **Visualizaci√≥n de Estad√≠sticas del Programa de Fidelizaci√≥n (`AdminOverview.tsx`)**

- **Panel Resumen:**
  - Total de clientes activos.
  - Nuevos clientes registrados en los √∫ltimos 7 d√≠as (y comparaci√≥n con los 7 d√≠as anteriores).
  - Total de puntos emitidos (v√≠a QR) en los √∫ltimos 7 d√≠as (y comparaci√≥n).
  - Total de recompensas canjeadas (por puntos y regalos) en los √∫ltimos 7 d√≠as (y comparaci√≥n).
- **(Futuro)** Gr√°ficos de evoluci√≥n, distribuci√≥n de clientes por nivel, recompensas m√°s populares, etc.

---

**LoyalPyME Core** es la base para construir relaciones a largo plazo, entender el comportamiento de tus clientes y recompensar su preferencia de una manera medible y efectiva.

---



// ====== [5] LOYALPYME_MODULE_INTEGRATION_WORKFLOW.md ======
# LoyalPyME: Fidelizaci√≥n y Servicio, ¬°Una Alianza Estrat√©gica para tu Negocio! ü§ùüåüüçΩÔ∏è

**√öltima Actualizaci√≥n:** 28 de Mayo de 2025 (Refleja el rol del camarero en el ciclo de pedido LC y su impacto en el futuro trigger de integraci√≥n con LCo)

Cuando un negocio decide activar tanto el m√≥dulo de fidelizaci√≥n **LoyalPyME Core (LCo)** para la gesti√≥n de la lealtad de sus clientes, como el m√≥dulo de operativa de servicio **LoyalPyME Camarero (LC)** para digitalizar la experiencia en el local, se desbloquea un potencial extraordinario. La integraci√≥n fluida y pensada entre ambos m√≥dulos crea una experiencia de cliente superior, cohesiva y gratificante, al mismo tiempo que proporciona al negocio herramientas m√°s potentes para la gesti√≥n, el an√°lisis y el crecimiento.

Este documento detalla los puntos de contacto, las sinergias y los flujos de trabajo espec√≠ficos que surgen cuando LCo y LC operan conjuntamente, considerando el ciclo completo del pedido en LC, incluyendo la intervenci√≥n del personal (KDS y Camarero).

---

## ‚ú® **I. La Experiencia del Cliente Potenciada: Pedidos que Suman, Beneficios que Impactan**

Para un cliente que interact√∫a con un establecimiento que ha activado y sincronizado LoyalPyME Core y LoyalPyME Camarero, el recorrido se enriquece, ofreciendo conveniencia operativa y recompensas por su lealtad de manera integrada.

### 1. üì≤ **Acceso a la Carta LC con Identidad LCo (Opcional pero Clave para Beneficios Futuros)**

    *   **Punto de Entrada Principal (LC):** El cliente escanea el QR de mesa (`/m/:businessSlug/:tableIdentifier`), explora la carta, personaliza √≠tems y prepara su pedido. Este flujo es gestionado por `PublicMenuViewPage.tsx`.
    *   **Integraci√≥n Visible de LCo (Opcional, configurable por el negocio):**
        *   En la interfaz de la carta LC, se pueden presentar opciones para "Iniciar Sesi√≥n" (si ya tiene cuenta LCo en ese negocio) o "Registrarse" (para crear una nueva cuenta LCo).
        *   **Objetivo:** Asociar un `customerId` de LCo al `Order` que se cree en LC.
        *   **Incentivo:** Mensajes como "¬øYa eres miembro? ¬°Inicia sesi√≥n para que este pedido sume a tus beneficios!" o "Reg√≠strate y este pedido podr√≠a ayudarte a alcanzar tu primer nivel."
    *   _(La UI para esta promoci√≥n de LCo en LC es una mejora futura; la funcionalidad de asociar `customerId` al `Order` si el cliente se loguea por otros medios (ej. desde dashboard LCo y luego va a la carta) ya est√° implementada en el backend de creaci√≥n de `Order` LC)._

### 2. üí≥ **Proceso de Identificaci√≥n LCo Durante el Flujo de Pedido LC**

    *   **Flujo de Login/Registro (Idealmente No Intrusivo):** Si se implementa el punto anterior, al seleccionar "Iniciar Sesi√≥n" o "Registrarse" desde LC, se usar√≠an modales o vistas superpuestas para los formularios de LCo, manteniendo al cliente en el contexto del pedido.
    *   **Sincronizaci√≥n de Sesi√≥n:** Tras una autenticaci√≥n/registro exitoso, el frontend (ej. `PublicMenuViewPage.tsx` o un contexto global) almacena el `customerId` y token JWT de LCo.
    *   El cliente finaliza su pedido LC (o a√±ade √≠tems) como un usuario LCo identificado.
    *   _(La l√≥gica de login/registro de LCo es funcional. Su integraci√≥n visual directa en el flujo de pedido LC es una mejora de UX futura)._

### 3. üõçÔ∏è **Env√≠o de Pedido LC (Nuevo o Adici√≥n) y Asociaci√≥n al Cliente LCo**

    *   El cliente configura su pedido en la interfaz LC y procede al env√≠o.
    *   **Payload del Pedido LC:** Si el cliente se identific√≥ con LCo, el `customerId` se incluye en el `CreateOrderPayloadDto` (o en el DTO de "A√±adir √çtems").
    *   **Procesamiento Backend (LC):** El servicio `public/order.service.ts` asocia este `customerId` al campo `Order.customerLCoId`. Este enlace es fundamental para la integraci√≥n.
    *   _(Esta asociaci√≥n ya est√° implementada en el backend de creaci√≥n de `Order` LC)._

### 4. üíØ **[FUTURO - POST-MVP LC COMPLETO] Acumulaci√≥n Autom√°tica de Puntos LCo por Consumo en LC (Post-Pago)**

    *   **Evento Disparador Clave:** La acumulaci√≥n de puntos LCo se producir√° cuando un `Order` del M√≥dulo Camarero, que tiene un `customerLCoId` asociado, cambie su `OrderStatus` a **`PAID`**.
    *   **¬øQui√©n marca el pedido como `PAID`?**
        1.  **Camarero (Flujo Actual en Desarrollo):** Desde su interfaz de gesti√≥n de mesas/pedidos (a√∫n por implementar), el camarero, despu√©s de que el cliente haya pagado f√≠sicamente (efectivo, tarjeta externa), marcar√° el/los `Order`(s) correspondientes como `PAID`.
        2.  **(Futuro) Sistema de TPV Integrado:** Si se desarrolla un TPV LoyalPyME o se integra con uno existente, el cierre y pago de la cuenta en el TPV actualizar√≠a el `Order.status` a `PAID`.
        3.  **(Futuro Muy Avanzado) Pago Online por Cliente:** Si se implementa pago online directamente en la app/vista web del cliente LC, un pago exitoso a trav√©s de la pasarela cambiar√≠a el `Order.status` a `PAID`.
    *   **L√≥gica de Backend para la Integraci√≥n LCo-LC (a implementar cuando el estado `PAID` sea gestionable):**
        1.  **Detecci√≥n del Evento:** Un listener de eventos de cambio de estado en `Order` o una l√≥gica dentro del servicio que actualiza el `Order.status` a `PAID`.
        2.  **Verificaci√≥n:** Comprobar que `Order.customerLCoId` no es nulo.
        3.  **C√°lculo de Puntos:**
            *   Obtener `Order.finalAmount`.
            *   Consultar `Business.pointsPerEuro` (o `Business.pointsPerEuroCamarero` si se diferencia).
            *   Aplicar multiplicadores de puntos del `Tier` actual del cliente LCo (obtenido de `User.currentTier.benefits`).
            *   Calcular puntos LCo (`Math.floor(...)`).
        4.  **Actualizaci√≥n de Datos en LCo (Transaccional o como efecto secundario robusto):**
            *   Crear registro en `ActivityLog` (LCo): `type: POINTS_EARNED_ORDER_LC`, `pointsChanged: +XX`, `description: "Puntos por pedido LC #P-XXXXXX"`, `relatedOrderId: order.id`.
            *   Actualizar `User.points` (LCo).
            *   Actualizar `User.lastActivityAt` (LCo).
            *   Incrementar `User.totalSpend` y `User.totalVisits` (LCo).
            *   Disparar `updateUserTier(customerLCoId)` para recalcular el nivel del cliente en LCo.
    *   **Notificaci√≥n al Cliente (LCo):** Email o notificaci√≥n push (si hay app) informando los puntos ganados.

### 5. üåü **[FUTURO - POST-MVP LC COMPLETO E INTEGRACI√ìN B√ÅSICA LCo] Aplicaci√≥n de Beneficios de Nivel LCo y Canje de Recompensas LCo en Pedidos LC**

    *   Esta es una funcionalidad avanzada que se construir√° sobre la acumulaci√≥n de puntos.
    *   **Visualizaci√≥n de Beneficios LCo en Interfaz LC (`PublicMenuViewPage.tsx`):**
        *   Si el cliente est√° identificado con LCo, la UI de LC podr√≠a mostrar sutilmente los beneficios de su nivel aplicables a pedidos LC (ej. "¬°Nivel Oro! Disfruta de un 10% de descuento.").
    *   **Aplicaci√≥n de Descuentos de Nivel LCo:**
        *   **Configuraci√≥n LCo:** `TierBenefit` de tipo `PERCENTAGE_DISCOUNT` o `FIXED_AMOUNT_DISCOUNT` marcado como "Aplicable en M√≥dulo Camarero".
        *   **L√≥gica LC (Backend/Frontend):** Al calcular el total del pedido LC, si el cliente tiene un descuento de nivel aplicable, √©ste se resta del `Order.totalAmount`, actualizando `Order.discountAmount` y `Order.finalAmount`. Visible en carrito y confirmaci√≥n.
    *   **Canje de Recompensas LCo (ej. "Producto Gratis", "Descuento X‚Ç¨") en Flujo LC:**
        *   **Configuraci√≥n LCo:** `Reward` marcada como "Canjeable en M√≥dulo Camarero". Mapeo de "Producto Gratis" a `MenuItem.id` de LC.
        *   **Interfaz Cliente LC (`ShoppingCartModal.tsx`):** Secci√≥n "Aplicar Recompensas LoyalPyME" para que el cliente seleccione una recompensa LCo canjeable.
        *   **L√≥gica LC:** Si es producto gratis, se a√±ade al carrito LC con precio 0. Si es descuento, se aplica al total.
        *   **Sincronizaci√≥n Backend:** El pedido LC enviado incluye `appliedLcoRewardId`. El backend de LC se comunica con LCo para marcar la `Reward` como `REDEEMED` y crear el `ActivityLog` en LCo.
    *   _(Tarea D7 en `DEVELOPMENT_PLAN.md`)._

### 6. üìú **[PARCIALMENTE IMPLEMENTADO - SE COMPLETAR√Å CON INTEGRACI√ìN] Historial de Actividad Unificado (Visi√≥n Cliente en Dashboard LCo)**

    *   El `ActivityLog` del cliente en su dashboard LCo (`ActivityTab.tsx`) ser√° la fuente central.
    *   **Actualmente Muestra:** `POINTS_EARNED_QR`, `POINTS_REDEEMED_REWARD` (canje desde dashboard LCo), `GIFT_REDEEMED`, `POINTS_ADJUSTED_ADMIN`.
    *   **Futuras Entradas de Integraci√≥n LC+LCo:**
        *   `POINTS_EARNED_ORDER_LC`: Detallando puntos ganados por pedidos LC.
        *   `REWARD_REDEEMED_IN_LC_ORDER`: Detallando recompensas LCo canjeadas en pedidos LC.

---

## ‚öôÔ∏è **II. La Visi√≥n del Negocio (`BUSINESS_ADMIN`): Gesti√≥n Integrada, Datos Enriquecidos y Sinergias**

### 1. üîó **[PENDIENTE] Configuraci√≥n de la Integraci√≥n LCo <-> LC (Panel Admin)**

    *   **Ubicaci√≥n:** Nueva secci√≥n en el panel de admin "Configuraci√≥n de M√≥dulos" o sub-secciones en LCo/LC.
    *   **Par√°metros Configurables por el `BUSINESS_ADMIN`:**
        *   **Acumulaci√≥n de Puntos:**
            *   Interruptor: "Habilitar/Deshabilitar Acumulaci√≥n de Puntos LCo desde Pedidos LC".
            *   Campo (opcional): "Ratio de Puntos Espec√≠fico para Pedidos LC" (si es diferente de `Business.pointsPerEuro` global).
            *   (Informativo, no editable por admin) "Estado del Pedido LC que Otorga Puntos": Se fijar√° a `PAID`.
        *   **Canje de Recompensas/Beneficios LCo en LC (Avanzado):**
            *   Interruptor: "Habilitar/Deshabilitar Canje de Recompensas/Beneficios LCo en el M√≥dulo Camarero".
            *   **Mapeo de Recompensas LCo:** UI para que el admin marque qu√© `Reward`s de LCo son "Canjeables en M√≥dulo Camarero". Si la recompensa es tipo "Producto Gratis", permitir seleccionar el `MenuItem.id` (o categor√≠a/tag) de LC al que corresponde.
            *   **Configuraci√≥n de Beneficios de Nivel LCo:** UI para que el admin marque qu√© `TierBenefit`s (ej. descuentos porcentuales) son "Aplicables en M√≥dulo Camarero" y si se aplican autom√°ticamente o requieren una acci√≥n del cliente en la UI de LC.

### 2. üìä **[PENDIENTE - POST-MVP LC COMPLETO E INTEGRACI√ìN] Visi√≥n 360¬∫ del Cliente y Reportes Combinados**

    *   **Perfil de Cliente Unificado (Admin LCo - `AdminCustomerManagementPage`):**
        *   Al ver un cliente LCo, mostrar una nueva pesta√±a/secci√≥n "Actividad en M√≥dulo Camarero":
            *   Resumen: N¬∫ total de pedidos LC, gasto total LC, fecha √∫ltimo pedido LC.
            *   (Opcional) Lista de los N √∫ltimos pedidos LC con enlace a sus detalles (si se implementa un panel de admin para ver `Order`s individuales de LC).
    *   **Sincronizaci√≥n de M√©tricas Clave LCo:** `User.totalSpend` y `User.totalVisits` (LCo) se actualizar√°n no solo por QR LCo, sino tambi√©n por `Order`s LC pagados y asociados al cliente.
    *   **Reportes de LCo Enriquecidos:**
        *   Posibilidad de segmentar/filtrar informes LCo (clientes valiosos, actividad de puntos) por origen de la actividad (QR LCo vs. Pedido LC).
        *   An√°lisis del impacto de LC en la progresi√≥n de niveles LCo.
    *   **Reportes de LC con Perspectiva LCo:**
        *   Informes de LC (ventas por √≠tem, ticket medio) podr√≠an incluir: % de ventas de clientes LCo, distribuci√≥n de ventas por nivel LCo, impacto de descuentos/recompensas LCo en totales LC.

### 3. üì¢ **[PENDIENTE - POST-MVP LC COMPLETO E INTEGRACI√ìN] Estrategias de Marketing y Promoci√≥n Cruzada Mejoradas**

    *   **Incentivos Dirigidos:** Crear Recompensas LCo espec√≠ficas (ej. "Doble Puntos en tu primer pedido LC") o Beneficios de Nivel LCo atractivos para usar con LC.
    *   **Promoci√≥n de LCo dentro de la Experiencia LC:** Mensajes/banners configurables por el admin en `PublicMenuViewPage` para incentivar registro/login en LCo.
    *   **Campa√±as Segmentadas:** Usar datos combinados LCo+LC para enviar comunicaciones m√°s efectivas.

### 4. ‚öôÔ∏è **Operativa y Sincronizaci√≥n de Estados Clave (Flujo Backend - Consideraciones Importantes)**

    *   **Estado `PAID` en `Order` LC (CRUCIAL):** El mecanismo para marcar un `Order` LC como `PAID` (sea por camarero, TPV futuro, o pago online futuro) debe ser extremadamente robusto y preciso, ya que es el disparador principal para la integraci√≥n con LCo.
        *   **Actualmente:** Esta funcionalidad depende de la implementaci√≥n de la interfaz de camarero (Bloque B1 del `DEVELOPMENT_PLAN.md`).
    *   **Transaccionalidad en Canjes LCo en Pedidos LC:** Si se implementa el canje de recompensas/beneficios LCo en el flujo LC, la comunicaci√≥n entre los servicios de LC y LCo para marcar la recompensa como canjeada y ajustar datos en LCo debe ser transaccional o, como m√≠nimo, idempotente con mecanismos de reintento/compensaci√≥n para asegurar la consistencia de datos entre m√≥dulos.
    *   **Consistencia de Datos del Cliente:** Si un cliente actualiza sus datos personales en LCo (a trav√©s de la futura `ProfileTab.tsx`), y ese cliente est√° asociado a `Order`s en LC, se debe considerar c√≥mo se refleja esta informaci√≥n si se visualizan datos hist√≥ricos de pedidos LC (los snapshots en `Order` y `OrderItem` son clave para esto).

---

**La Sinergia Estrat√©gica:**

La integraci√≥n de **LoyalPyME Camarero (LC)** con **LoyalPyME Core (LCo)** no es solo una suma de funcionalidades, sino una **multiplicaci√≥n de valor** para el negocio y sus clientes. LC moderniza y agiliza la experiencia de servicio en el local, capturando datos de consumo y comportamiento detallados. LCo utiliza estos datos (y los datos de otras interacciones de fidelizaci√≥n) para construir programas de lealtad personalizados y efectivos que incentivan la recurrencia, aumentan el valor de vida del cliente y fortalecen la relaci√≥n.

Esta combinaci√≥n permitir√° a los negocios:

- **Mejorar la satisfacci√≥n del cliente:** Con un servicio m√°s r√°pido, personalizado, aut√≥nomo y con opciones de recompensa integradas y visibles.
- **Aumentar la frecuencia de visitas y el gasto promedio:** Mediante incentivos de lealtad contextuales (ej. "Gana puntos con este pedido") y la aplicaci√≥n directa de beneficios en el punto de servicio.
- **Obtener una comprensi√≥n 360¬∫ del cliente:** Al unificar datos de servicio en el local (qu√©, cu√°ndo y c√≥mo piden) con datos de su actividad en el programa de fidelizaci√≥n (nivel, puntos, recompensas canjeadas, interacciones con QR).
- **Optimizar la operativa del personal:** El flujo digital reduce la carga de trabajo manual en la toma de pedidos (cliente), comunicaci√≥n con cocina/barra (KDS), y (futuramente) aplicaci√≥n de promociones de lealtad o cobros.
- **Diferenciarse de la competencia:** Ofreciendo una experiencia digital integrada, moderna, eficiente y que premia la fidelidad de forma transparente y atractiva.

El √©xito de esta integraci√≥n reside en una **comunicaci√≥n l√≥gica, robusta y potencialmente transaccional** entre los datos y procesos de ambos m√≥dulos. Esto implica una arquitectura backend bien dise√±ada (servicios cohesivos, posible uso de eventos o colas de mensajes para desacoplar procesos cr√≠ticos como la asignaci√≥n de puntos post-pago) y una presentaci√≥n de una experiencia de usuario cohesiva y sin fricciones en el frontend.



// ====== [6] PROJECT_STATUS.md ======
# LoyalPyME - Estado del Proyecto y Decisiones Clave

**Versi√≥n Actual:** 1.21.0 (LC: Ciclo Completo de Pedido (Creaci√≥n, Servicio, Pago) y Adici√≥n de √çtems a Pedido Existente COMPLETADOS Y VALIDADOS)
**Fecha de √öltima Actualizaci√≥n:** 17 de Junio de 2025

---

## 1. Resumen General del Proyecto LoyalPyME üéØ

- **Concepto:** LoyalPyME es una plataforma web integral, dise√±ada como una soluci√≥n Software as a Service (SaaS) modular, orientada a Peque√±as y Medianas Empresas (PyMEs). Su arquitectura full-stack se basa en tecnolog√≠as modernas:
  - **Frontend:** React con TypeScript, utilizando Vite como herramienta de construcci√≥n y Mantine UI para la biblioteca de componentes, asegurando una experiencia de usuario responsive y moderna. La navegaci√≥n se gestiona con React Router DOM y la internacionalizaci√≥n (i18n) con `i18next`.
  - **Backend:** Node.js con Express.js y TypeScript, interactuando con una base de datos PostgreSQL a trav√©s del ORM Prisma. La autenticaci√≥n se maneja con JSON Web Tokens (JWT).
    La plataforma ofrece dos m√≥dulos principales que los negocios pueden activar seg√∫n sus necesidades:
  - **LoyalPyME Core (LCo):** Un sistema de fidelizaci√≥n digital robusto y completo. **[Funcionalmente Completo para MVP]**.
    - **Caracter√≠sticas Clave LCo:** Gesti√≥n integral de clientes (con roles), sistema de acumulaci√≥n de puntos (configurable por negocio), niveles de fidelizaci√≥n (tiers) con beneficios personalizables (multiplicadores de puntos, acceso a recompensas exclusivas, beneficios textuales), cat√°logo de recompensas canjeables (con soporte i18n para nombres/descripciones e im√°genes individuales), generaci√≥n de c√≥digos QR √∫nicos para la asignaci√≥n de puntos en transacciones f√≠sicas, y un panel de cliente interactivo donde pueden visualizar su progreso, saldo de puntos, recompensas disponibles, regalos asignados por el administrador, y el historial de su actividad en el programa.
  - **LoyalPyME Camarero (LC):** Un m√≥dulo avanzado, **[FLUJO DE PEDIDO PRINCIPAL COMPLETADO. Pr√≥ximo paso: Funcionalidades avanzadas de gesti√≥n de cuenta (Dividir Cuenta)]**, dise√±ado para digitalizar y optimizar la operativa de servicio en el sector de la hosteler√≠a (restaurantes, bares, cafeter√≠as).
    - **Funcionalidades Clave LC Implementadas y Validadas:**
      1.  **Gesti√≥n Completa de Carta Digital (Admin):** Interfaz administrativa para crear, editar y organizar la carta, √≠tems y modificadores complejos.
      2.  **Visualizaci√≥n de Carta y Toma de Pedidos por Cliente (con Modificadores):** Interfaz interactiva para explorar la carta, personalizar √≠tems con modificadores, con c√°lculo de precio din√°mico y validaci√≥n de reglas.
      3.  **Backend Robusto para Creaci√≥n de Pedidos:** El backend procesa y valida correctamente los pedidos p√∫blicos, incluyendo modificadores y precios. El bug cr√≠tico de modificadores ha sido **SOLUCIONADO.**
      4.  **Gesti√≥n de Pedido Activo por Cliente:** La `PublicMenuViewPage` detecta pedidos activos y adapta la UI, permitiendo **a√±adir nuevos √≠tems a un pedido existente**.
      5.  **Visualizaci√≥n del Estado del Pedido por Cliente:** La `OrderStatusPage` muestra el estado del pedido y de cada √≠tem en tiempo real (con polling).
      6.  **Ciclo KDS (Cocina/Barra):** API e Interfaz de KDS funcionales para que el personal vea y actualice el estado de preparaci√≥n de los √≠tems (`PENDING_KDS` -> `PREPARING` -> `READY`).
      7.  **Ciclo de Servicio del Camarero:** API e Interfaz para que el camarero vea los √≠tems listos para recoger (`READY`) y los marque como `SERVED`.
      8.  **Ciclo Financiero Completo:** API e Interfaces para que el cliente **pida la cuenta** (cambiando el pedido a `PENDING_PAYMENT`) y para que el camarero **marque el pedido como `PAID`**, lo cual **libera la mesa** y **asigna los puntos de fidelidad LCo** correspondientes.
- **Componentes Tecnol√≥gicos Clave Detallados:**
  - **Backend:** Node.js (runtime JavaScript), Express.js (framework web), TypeScript (tipado est√°tico), Prisma ORM (interacci√≥n con base de datos PostgreSQL, versi√≥n 6+), PostgreSQL (base de datos relacional), JSON Web Tokens (JWT) (para autenticaci√≥n stateless basada en tokens), `bcryptjs` (hashing de contrase√±as), Cloudinary SDK (almacenamiento y gesti√≥n de im√°genes en la nube), Multer (middleware para manejo de subidas de archivos multipart/form-data), Swagger/OpenAPI (`swagger-jsdoc`, `swagger-ui-express`) (para documentaci√≥n interactiva de la API), `node-cron` (para ejecuci√≥n de tareas programadas), `class-validator` y `class-transformer` (para validaci√≥n y transformaci√≥n robusta de DTOs, crucial para el correcto parseo de payloads anidados).
  - **Frontend:** React (biblioteca para construir interfaces de usuario, versi√≥n 19+ con Hooks), TypeScript (tipado est√°tico), Vite (herramienta de construcci√≥n y servidor de desarrollo r√°pido, versi√≥n 5+), Mantine UI (biblioteca de componentes React, versi√≥n 7+), Axios (cliente HTTP para peticiones a la API), React Router DOM (gesti√≥n de rutas en la aplicaci√≥n de p√°gina √∫nica, versi√≥n 6+), `i18next` y `react-i18next` (para internacionalizaci√≥n completa ES/EN con archivos JSON de traducci√≥n), `html5-qrcode` (para la funcionalidad de escaneo de QR por el cliente en LCo), `react-image-crop` (para la funcionalidad de recorte de im√°genes en los paneles de administraci√≥n).
  - **Testing:** Vitest (framework de testing unitario y de integraci√≥n para backend y frontend, compatible con el ecosistema Vite).
- **Licencia:** Software Propietario. Copyright (c) 2024-2025 Olivier Hottelet. Todos los derechos reservados. (Ver `LICENSE.md`).
- **√Åreas Funcionales Principales de la Plataforma (Detallado):**
  - **Panel Super Admin (`/superadmin`):** Interfaz exclusiva para el rol `SUPER_ADMIN`. Permite la administraci√≥n global de todas las instancias de negocios clientes registradas en la plataforma. Funcionalidades: listar negocios, ver su estado general (`isActive`), y activar/desactivar individualmente los m√≥dulos principales (LoyalPyME Core - `isLoyaltyCoreActive`, LoyalPyME Camarero - `isCamareroActive`) para cada negocio.
  - **Panel de Administraci√≥n del Negocio (`/admin/dashboard/*`):** Interfaz para el rol `BUSINESS_ADMIN` de cada negocio. Las funcionalidades visibles y accesibles se adaptan seg√∫n los m√≥dulos activados para su negocio.
    - **LCo (si `isLoyaltyCoreActive`):** Gesti√≥n completa de clientes del programa de fidelizaci√≥n (listado, filtros, b√∫squeda, ver detalles, editar notas, ajustar puntos, cambiar nivel manualmente, asignar recompensas como regalo, activar/desactivar cuentas), gesti√≥n de recompensas (CRUD con i18n e im√°genes), gesti√≥n de niveles/tiers (CRUD de tiers y sus beneficios asociados), configuraci√≥n global del programa de fidelizaci√≥n (base y periodo de c√°lculo de tiers, pol√≠ticas de descenso), generaci√≥n de QR de puntos para transacciones.
    - **LC (si `isCamareroActive` - `/admin/dashboard/camarero/*`):** Gesti√≥n completa de la carta digital (CRUD de categor√≠as, √≠tems, grupos de modificadores y opciones de modificadores, con soporte i18n, im√°genes, precios, etc.). Gesti√≥n de Mesas (`TableManager.tsx` para CRUD de mesas). Interfaz de Camarero para recogida de √≠tems listos (`WaiterPickupPage.tsx`). (Futuro: gesti√≥n de personal, PINs, configuraci√≥n de destinos KDS, asignaci√≥n de permisos granulares a staff).
  - **Interfaz KDS (M√≥dulo LC - `/admin/kds`):** Interfaz para roles de staff de cocina/barra (`KITCHEN_STAFF`, `BAR_STAFF`) y `BUSINESS_ADMIN`. Permite visualizar los `OrderItem`s pendientes y en preparaci√≥n para un `kdsDestination` espec√≠fico, y cambiar su estado de preparaci√≥n.
  - **Portal de Cliente Final (LCo - `/customer/dashboard`):** Dashboard personalizado para el rol `CUSTOMER_FINAL`. Muestra saldo de puntos, nivel actual y progreso al siguiente, cat√°logo de recompensas canjeables y regalos pendientes (con im√°genes y descripciones i18n), historial detallado de actividad de puntos (paginado), y funcionalidad para validar QR de puntos (escaneo o manual). Si el m√≥dulo LC est√° activo para el negocio, incluye una tarjeta de acceso directo a la carta digital del negocio.
  - **Interfaces P√∫blicas del M√≥dulo Camarero (LC):**
    - **Carta Digital P√∫blica (`/m/:businessSlug/:tableIdentifier?`):** P√°gina accesible sin login. Muestra la carta del negocio de forma interactiva. Permite al cliente seleccionar √≠tems, personalizarlos con modificadores (c√°lculo de precio din√°mico), a√±adir a un carrito local, revisar el pedido, a√±adir notas generales y enviar la comanda. Detecta si ya hay un pedido activo para esa mesa/navegador y adapta la UI.
    - **Visualizaci√≥n Estado del Pedido Cliente (`/order-status/:orderId`):** P√°gina accesible sin login. Muestra el estado general del pedido y el estado individual de cada `OrderItem`, con actualizaciones autom√°ticas por polling. Gestiona la l√≥gica de "pedido finalizado" (`PAID` o `CANCELLED`) para limpiar el `localStorage` y permitir al cliente iniciar un nuevo pedido.
- **Prop√≥sito y Visi√≥n:** Convertirse en la herramienta digital de referencia, modular y altamente adaptable, que impulse la fidelizaci√≥n de clientes (LCo) y optimice dr√°sticamente la operativa de servicio en PyMEs (LC), con un foco especial en el sector hostelero. El objetivo es mejorar la recurrencia de clientes, aumentar el ticket promedio, facilitar la gesti√≥n del negocio y enriquecer la relaci√≥n cliente-negocio a trav√©s de experiencias digitales eficientes y gratificantes.

---

## 2. Estado Actual Detallado (Hitos Completados y En Progreso - v1.21.0) üìù

- **Fase 1 (N√∫cleo Operativo LCo + Pulido Inicial): [COMPLETADO]**

  - Autenticaci√≥n Completa (Registro negocios y clientes, Login JWT, Reseteo de contrase√±a).
  - Panel de Administraci√≥n LCo - CRUDs Completos:
    - Gesti√≥n de Recompensas (CRUD, i18n, im√°genes Cloudinary).
    - Gesti√≥n de Niveles (Tiers) y Beneficios (CRUD, umbrales, asignaci√≥n).
    - Configuraci√≥n Global del Sistema de Tiers (Base c√°lculo, periodo, descenso, inactividad).
    - Gesti√≥n Avanzada de Clientes (Listado, filtros, b√∫squeda, detalles, notas admin, ajuste puntos, cambio nivel manual, asignaci√≥n regalos, activar/desactivar, favoritos, acciones masivas).
  - Flujo Completo de Puntos y QR en LCo (Generaci√≥n QR por Admin, Validaci√≥n QR por Cliente, c√°lculo y asignaci√≥n de puntos considerando multiplicadores de nivel).
  - L√≥gica de Tiers Autom√°tica (Backend LCo - `node-cron` para rec√°lculo y descenso).
  - Panel de Cliente Completo LCo (`CustomerDashboardPage.tsx` con pesta√±as Resumen, Recompensas, Actividad).
  - Mejoras UI/UX Iniciales (Consistencia, usabilidad).
  - Internacionalizaci√≥n (i18n) Frontend (Base `i18next` y archivos JSON ES/EN).
  - Documentaci√≥n API Backend (Swagger/OpenAPI) para servicios LCo.

- **Fase 2 (Fundamentos Multi-M√≥dulo y Panel Super Admin): [COMPLETADO]**

  - Implementaci√≥n del Panel Super Admin (`/superadmin`) para gesti√≥n de negocios y activaci√≥n de m√≥dulos.
  - Middleware `checkModuleActive` (Backend) para proteger endpoints de m√≥dulos espec√≠ficos.
  - L√≥gica Condicional en UI Frontend (`AdminNavbar`, `CustomerDashboardPage`) basada en m√≥dulos activos.
  - Payload de Perfil de Usuario (`/api/profile`) enriquecido con flags de m√≥dulos activos y detalles del negocio.
  - Script de Seed (`prisma/seed.ts`) actualizado (v7) y funcional, creando datos demo exhaustivos para LCo y LC (negocio, admin, clientes, tiers, recompensas, carta completa con modificadores, mesas, personal, pedidos de ejemplo con √≠tems KDS).

- **Fase 3 (Desarrollo M√≥dulo "LoyalPyME Camarero" - LC): [FLUJO PRINCIPAL COMPLETO]**
  - **LC - Fundamentos Backend (Modelos BD y API Gesti√≥n Carta): [COMPLETADO Y VALIDADO]**
    - Modelos Prisma detallados y migrados para `Table`, `MenuCategory`, `MenuItem`, `ModifierGroup`, `ModifierOption`, `Order`, `OrderItem`, `OrderItemModifierOption`, `StaffPin`. Enums `OrderStatus`, `OrderItemStatus`, etc. definidos.
    - API CRUD Admin Carta (`/api/camarero/admin/*`) completa y protegida para `MenuCategory`, `MenuItem` (con `ModifierGroup`s), y `ModifierOption`s.
  - **LC - Frontend: UI Admin para Gesti√≥n de Carta Digital: [COMPLETADO Y VALIDADO]**
    - P√°gina `/admin/dashboard/camarero/menu-editor` (`MenuManagementPage.tsx`) y componentes asociados (`MenuCategoryManager.tsx`, `MenuItemManager.tsx`, `MenuItemFormModal.tsx`, `ModifierGroupsManagementModal.tsx`, `ModifierOptionsManagementModal.tsx`) funcionales para CRUD completo de la carta, incluyendo subida de im√°genes.
    - Hooks de datos y tipos para gesti√≥n de men√∫ implementados. Bot√≥n "Previsualizar Carta P√∫blica".
  - **LC - Backend y Frontend: Visualizaci√≥n de Carta P√∫blica y Flujo de Pedido por Cliente (con Modificadores): [COMPLETADO Y VALIDADO]**
    - **Backend (API P√∫blica de Men√∫ - `/public/menu/business/:businessSlug`):** Funcional, sirve la carta completa y activa para el cliente.
    - **Frontend (Visualizaci√≥n de Carta - `/m/:businessSlug/:tableIdentifier?` - `PublicMenuViewPage.tsx`):**
      - Muestra interactiva de la carta, personalizaci√≥n de √≠tems con modificadores y c√°lculo de precio din√°mico **validado y funcionando correctamente**.
      - Funcionalidad "A√±adir al Carrito" y persistencia del carrito no enviado en `localStorage` operativa.
    - **Frontend (Modal del Carrito y Env√≠o - `ShoppingCartModal.tsx`):** Funcional para revisi√≥n, modificaci√≥n de cantidades, notas y env√≠o.
    - **Backend (Creaci√≥n de Pedido - `POST /public/order/:businessSlug`):**
      - **SOLUCIONADO BUG CR√çTICO:** El servicio (`OrderService`) ahora procesa y valida correctamente los `selectedModifierOptions`.
      - Rec√°lculo de precios en backend y creaci√≥n transaccional de `Order`, `OrderItem`s, y `OrderItemModifierOption`s funcionando como se espera.
    - **Frontend (Post-Env√≠o Pedido en `PublicMenuViewPage.tsx`):** Guardado de `activeOrderInfo` en `localStorage` y redirecci√≥n a `OrderStatusPage` operativos.
  - **LC - Cliente: Visualizaci√≥n del Estado del Pedido: [COMPLETADO Y VALIDADO]**
    - **Backend (`public/order.service.ts`):** Endpoint `GET /public/order/:orderId/status` (`PublicOrderStatusInfo`) funcional.
    - **Frontend (`PublicMenuViewPage.tsx` - Detecci√≥n Pedido Activo):** Funcionalidad de detecci√≥n, UI condicional y **adici√≥n de √≠tems a pedido existente** operativa.
    - **Frontend (`OrderStatusPage.tsx`):** Muestra informaci√≥n del pedido y estado de √≠tems con polling. L√≥gica de "Pedido Finalizado" (`PAID` o `CANCELLED`) para limpiar `localStorage` y permitir nuevo pedido est√° implementada. Bot√≥n "Volver al Men√∫" funcional.
  - **LC - KDS Backend (API y L√≥gica de Estados): [COMPLETADO Y VALIDADO]**
    - Endpoints `GET /api/camarero/kds/items` y `PATCH /api/camarero/kds/items/:orderItemId/status` funcionales y protegidos.
    - L√≥gica de `Order.status` en `kds.service.ts` (actualizaci√≥n a `IN_PROGRESS`, `PARTIALLY_READY`, `ALL_ITEMS_READY`) basada en estados de `OrderItem`s **validada**.
  - **LC - KDS Frontend (Visualizaci√≥n y Acciones): [COMPLETADO Y VALIDADO]**
    - `KitchenDisplayPage.tsx` funcional: selecci√≥n de destino KDS, visualizaci√≥n de √≠tems, polling, y acciones de cambio de estado (`PENDING_KDS` -> `PREPARING` -> `READY`; `CANCELLED`) con notificaciones.
  - **LC - Camarero Backend (Servicio y Entrega de √çtems): [COMPLETADO Y VALIDADO]**
    - Endpoints `GET /api/camarero/staff/ready-for-pickup` y `PATCH /api/camarero/staff/order-items/:orderItemId/status` (para marcar como `SERVED`) implementados y funcionales.
    - L√≥gica en `waiter.service.ts` para actualizar `OrderItem.status` a `SERVED` y `Order.status` a `COMPLETED` (si todos los √≠tems est√°n servidos) **validada**.
  - **LC - Camarero Frontend (Recogida y Servicio de √çtems): [COMPLETADO Y VALIDADO]**
    - P√°gina `WaiterPickupPage.tsx` (`/admin/camarero/pickup-station`) funcional: visualizaci√≥n de √≠tems `READY` y acci√≥n "Marcar como Servido" con actualizaci√≥n de la lista y notificaciones.
  - **LC - Flujo Financiero Completo del Pedido: [COMPLETADO Y VALIDADO]**
    - **Pedir la Cuenta:** Funcionalidad implementada en el backend y frontend (`OrderStatusPage`) para que el cliente solicite la cuenta, cambiando `Order.status` a `PENDING_PAYMENT`.
    - **Marcar Como Pagado:** Funcionalidad implementada en el backend y frontend (`WaiterOrderManagementPage`) para que el camarero marque el pedido como `PAID`, lo cual libera la mesa asociada en el `TableManager` y dispara la l√≥gica de asignaci√≥n de puntos de LCo.

---

## 3. Key Concepts & Design Decisions üîë

- **Arquitectura Modular y Activaci√≥n por Negocio:** La plataforma est√° dise√±ada para ser multi-tenant, donde cada `Business` es una entidad independiente. La modularidad se logra a nivel de base de datos con flags booleanos en el modelo `Business` (ej. `isLoyaltyCoreActive`, `isCamareroActive`). En el backend, un middleware personalizado (`checkModuleActive`) protege rutas de API espec√≠ficas, denegando el acceso si el negocio del usuario autenticado no tiene el m√≥dulo correspondiente activo. En el frontend, la UI se adapta din√°micamente: componentes como `AdminNavbar` y los dashboards de cliente y administrador leen estas flags del perfil del usuario y renderizan condicionalmente los men√∫s, botones y secciones relevantes para los m√≥dulos activos.

- **Estructura de Datos Detallada para M√≥dulo Camarero (LC):** La base de datos, gestionada por Prisma, se ha dise√±ado para ser robusta y escalable. `Order` es la entidad central que agrupa los `OrderItem`s. Crucialmente, cada `OrderItem` almacena un _snapshot_ del precio y nombre del producto en el momento del pedido (`priceAtTimeOfOrder`, `itemNameSnapshot_es`), garantizando la integridad de los datos hist√≥ricos aunque el producto cambie en el men√∫. Los modificadores se enlazan a trav√©s de `OrderItemModifierOption`, que conecta un `OrderItem` con una `ModifierOption` espec√≠fica. El modelo `Table` se asocia a un `Order` para gestionar la ocupaci√≥n y liberaci√≥n del espacio f√≠sico.

- **Flujo de Pedido LC - Cliente (Detallado):** El proceso completo desde que un cliente se sienta en la mesa hasta que env√≠a su pedido est√° meticulosamente orquestado:

  1.  **Acceso y Carga:** El cliente escanea un QR o accede a una URL (`/m/:slug/:table`). La p√°gina `PublicMenuViewPage` se inicializa y el hook `usePublicMenuData` se dispara para obtener la carta digital del negocio.
  2.  **Configuraci√≥n de √çtem:** Al seleccionar un producto, se activa el hook `useMenuItemConfigurator`, que presenta una UI para seleccionar modificadores. Este hook valida en tiempo real las reglas del grupo (m√≠nimos/m√°ximos, obligatorios) y recalcula el precio final del √≠tem din√°micamente, proporcionando feedback instant√°neo al usuario.
  3.  **Gesti√≥n del Carrito:** Los √≠tems, ya sean simples o configurados, se a√±aden al carrito, cuyo estado es gestionado por el hook `usePublicOrderCart`. Este hook genera un ID √∫nico para cada configuraci√≥n de √≠tem (`cartItemId`) para poder agruparlos correctamente y persiste el estado del carrito en el `localStorage` del navegador, permitiendo al cliente cerrar la pesta√±a y no perder su selecci√≥n.
  4.  **Detecci√≥n de Pedido Activo:** Simult√°neamente, el hook `useActiveOrderState` comprueba el `localStorage` para ver si ya existe un `activeOrderId` para esa mesa. Si lo encuentra, adapta la UI para informar al cliente que puede a√±adir m√°s √≠tems a su pedido en curso.
  5.  **Env√≠o y Orquestaci√≥n:** Al enviar el pedido, se invoca la funci√≥n `handleOrderSubmission` del servicio `publicOrderApiService`. Esta funci√≥n orquesta toda la l√≥gica: construye el payload (DTO), determina si debe llamar a la API de "crear nuevo pedido" o "a√±adir a pedido existente", y maneja la respuesta.
  6.  **Recepci√≥n y Validaci√≥n en Backend:** El controlador de Express recibe la petici√≥n, utiliza `plainToInstance` para transformar el JSON en una instancia de clase DTO anidada, y luego `validate` para asegurar que todos los datos (incluyendo cada modificador) son correctos antes de pasar la petici√≥n al servicio de backend (`OrderCreationService` o `OrderModificationService`) para su procesamiento en la base de datos.

- **Flujo KDS (LC - Detallado):** La comunicaci√≥n entre el cliente y la cocina es as√≠ncrona. Cuando se crea un `OrderItem`, su estado inicial es `PENDING_KDS`. La interfaz del KDS (`KitchenDisplayPage.tsx`) realiza un polling al endpoint `/api/camarero/kds/items` para mostrar los √≠tems pendientes. El personal de cocina interact√∫a con la UI para cambiar el estado a `PREPARING` y luego a `READY`, actualizando la base de datos a trav√©s de la API. El `kds.service.ts` contiene la l√≥gica para, por ejemplo, actualizar el estado general del `Order` a `PARTIALLY_READY` o `ALL_ITEMS_READY` basado en el estado de sus √≠tems.

- **Flujo Camarero (LC - Servicio y Pago Detallado):**

  1.  **Recogida:** La interfaz del camarero (`WaiterPickupPage.tsx`) hace polling al endpoint `/api/camarero/staff/ready-for-pickup` para mostrar solo los √≠tems en estado `READY`. Al entregarlos, el camarero los marca como `SERVED`. Cuando todos los √≠tems de un pedido est√°n servidos, el `waiter.service.ts` cambia el estado del `Order` a `COMPLETED`.
  2.  **Pago:** El cliente, desde `OrderStatusPage.tsx`, puede "Pedir la Cuenta", lo que cambia el estado del `Order` a `PENDING_PAYMENT`. Los camareros ven estos pedidos en su interfaz de gesti√≥n. Usando esta interfaz, seleccionan el pedido y lo marcan como `PAID`. Esta acci√≥n, manejada por `order-payment.service.ts`, actualiza el estado del pedido, libera la `Table` asociada, y crucialmente, invoca al `loyaltyPointsService` para asignar los puntos LCo si el cliente estaba identificado.

- **Internacionalizaci√≥n (i18n):** La estrategia es dual. La UI est√°tica se traduce usando `react-i18next` con archivos de recursos `translation.json`. El contenido din√°mico de la base de datos (como nombres de √≠tems o recompensas) se gestiona con campos duplicados en el schema (ej. `name_es`, `name_en`). El frontend selecciona el campo apropiado bas√°ndose en el idioma activo.

- **Almacenamiento de Im√°genes:** El componente `ImageUploadCropper` permite al administrador seleccionar y recortar una imagen. Al confirmar, la imagen recortada (como un `Blob`) se env√≠a a la API de subida (`/api/uploads/image`). El backend usa `Multer` para procesar el `multipart/form-data`, y el `uploads.service.ts` utiliza el SDK de Cloudinary para subir la imagen a la nube, devolviendo la URL segura, que luego se guarda en la base de datos en el campo `imageUrl` de la entidad correspondiente (ej. `Reward`, `MenuCategory`).

- **Arquitectura de Backend (Refactorizada):** Se ha adoptado una estructura m√°s limpia y escalable. El archivo principal `index.ts` ahora se encarga √∫nicamente de la configuraci√≥n del servidor Express y los middlewares globales. La configuraci√≥n de Swagger, que es muy extensa, se ha aislado en su propio archivo (`config/swagger.config.ts`). M√°s importante, todo el montaje de rutas se ha centralizado en `routes/index.ts`, que exporta un `apiRouter` y un `publicRouter`. Esto desacopla la definici√≥n de rutas de la inicializaci√≥n del servidor.

- **Hooks Personalizados (Frontend):** La arquitectura del frontend se basa en gran medida en hooks personalizados para encapsular la l√≥gica de estado y los efectos secundarios. Hooks como `useAdminCustomersData`, `usePublicMenuData`, `usePublicOrderCart`, `useActiveOrderState` y `useMenuItemConfigurator` act√∫an como "cerebros" para sus respectivos dominios de funcionalidad, haciendo que los componentes de la p√°gina (`PublicMenuViewPage`, `AdminCustomerManagementPage`, etc.) sean m√°s limpios, declarativos y centrados en la presentaci√≥n.

---

## 4. Lecciones Aprendidas & Troubleshooting Clave üí°

- **Configuraci√≥n de Seed y Prisma CLI:** La correcta configuraci√≥n en `package.json` y el uso de `npx prisma generate` son esenciales.
- **Sincronizaci√≥n de Tipos Prisma y TypeScript (VS Code):** Reiniciar el servidor TS es a veces necesario.
- **Errores P2002 (Unique Constraint Failed) en `seed.ts`**: Mitigado con el uso de `upsert` donde es aplicable.
- **Gesti√≥n de Estado Complejo en Frontend (LC - `PublicMenuViewPage.tsx`):** La gesti√≥n actual es funcional para el flujo de creaci√≥n. Se requerir√° atenci√≥n al implementar "A√±adir a Pedido".
- **Rec√°lculo de Precios y Validaci√≥n en Backend (LC - Pedidos):** Implementado y validado.
- **Errores de Tipo y L√≥gica en Backend (Transacciones, Creaci√≥n Anidada Prisma):** Transacciones Prisma son clave.
- **Internacionalizaci√≥n (i18n) Frontend:** Depuraci√≥n de `missingKey` y carga de namespaces.
- **Manejo de Archivos (Multer/Cloudinary):** Flujo robusto.
- **Testing (KDS y Servicio Camarero):** Validaci√≥n de l√≥gica de estados mediante pruebas manuales y con Postman ha sido efectiva. Se necesita expandir tests automatizados.
- **Sincronizaci√≥n Estado KDS/Camarero Frontend y Polling:** Estrategias de polling implementadas.
- **Gesti√≥n de Dependencias en Hooks `useEffect` y `useCallback`:** Pr√°ctica continua.
- ‚≠ê **[CLAVE PARA BUG MODIFICADORES] Deserializaci√≥n de DTOs Anidados en Backend (Express/NestJS):**
  - **Problema Identificado:** El `req.body` JSON con arrays de objetos anidados (ej. `selectedModifierOptions`) no se transformaba correctamente a instancias de las clases DTO anidadas, llegando como `undefined` o plain objects al `OrderService`.
  - **Soluci√≥n Aplicada y Validada:**
    1.  Uso de decoradores `@ValidateNested({ each: true })` y `@Type(() => ClaseAnidadaDto)` en las propiedades de array de objetos dentro de los DTOs del backend (`order.dto.ts`).
    2.  Para los handlers de Express (como `createPublicOrderHandler` en `order.controller.ts`): Implementaci√≥n de transformaci√≥n manual usando `const dtoInstance = plainToInstance(CreateOrderDto, req.body as Record<string, any>);` antes de pasar `dtoInstance` al servicio. Esto asegura que `class-transformer` instancie correctamente los objetos anidados.
    3.  Para controladores NestJS puros (la clase `OrderController`): Se depender√≠a del `ValidationPipe` global con `transform: true` (cuya configuraci√≥n en `index.ts` / `main.ts` se verific√≥).
- ‚≠ê **[CLAVE PARA BUG MODIFICADORES] Consistencia de Nombres de Campos (Prisma Schema vs. Service Logic):**
  - **Problema Identificado:** Uso inconsistente de nombres de campos entre el `schema.prisma` (ej. `ModifierOption.groupId`) y la l√≥gica del servicio o las consultas Prisma (ej. intento de usar `modifierGroupId` como campo directo de `ModifierOption`).
  - **Soluci√≥n Aplicada y Validada:** Revisi√≥n y correcci√≥n en `OrderService` para usar los nombres de campos exactos (`groupId`) definidos en `schema.prisma`, especialmente en los `select` de Prisma y en la l√≥gica de acceso a propiedades. Ejecutar `npx prisma generate` despu√©s de cualquier cambio en el schema fue vital.
- ‚≠ê **[NUEVA LECCI√ìN APRENDIDA] Sincronizaci√≥n de Documentaci√≥n:** Se ha identificado como un punto cr√≠tico mantener los archivos `.md` (especialmente `PROJECT_STATUS.md` y `DEVELOPMENT_PLAN.md`) sincronizados con el c√≥digo para evitar confusiones y retrabajo. Actualizar la documentaci√≥n es ahora un paso obligatorio al finalizar un bloque de funcionalidades.

---

## 5. Pr√≥ximos Pasos Inmediatos / Prioridades ‚è≥üìå

Con el ciclo completo de pedido finalizado (creaci√≥n, servicio y pago), el siguiente bloque se enfoca en funcionalidades avanzadas para mejorar la gesti√≥n y la flexibilidad del servicio.

1.  ‚≠ê **LC - Dividir la Cuenta (Split Bill): [CR√çTICO - SIGUIENTE BLOQUE FUNDAMENTAL]**

    - **Objetivo:** Implementar la capacidad para que un camarero divida la cuenta de un pedido pendiente de pago, ya sea por √≠tems o en partes iguales.
    - **Backend:**
      1.  **Dise√±o de Datos:** Se deber√° decidir c√≥mo representar los pagos parciales. Una opci√≥n es un nuevo modelo `PartialPayment` relacionado con `Order`, que contenga el `amount`, `method` y `status`.
      2.  **L√≥gica de Servicio:** Crear un nuevo servicio (`SplitBillService`?) que maneje la l√≥gica de divisi√≥n, cree los registros de pago parcial y actualice el estado del pedido principal (ej. a `PARTIALLY_PAID`) hasta que est√© completamente saldado.
      3.  **Endpoints API:** Dise√±ar y crear nuevas rutas en `/api/camarero/staff/order/:orderId/split-bill` para iniciar el proceso y registrar los pagos parciales.
    - **Frontend (Camarero):**
      1.  **Dise√±o de UI/UX:** Crear una nueva interfaz o modal para la divisi√≥n de cuentas. Deber√° mostrar los √≠tems del pedido y permitir al camarero asignarlos a diferentes "cestas" o "personas", o simplemente dividir el total.
      2.  **Integraci√≥n:** Conectar la nueva UI con los nuevos endpoints del backend, manejando los estados de carga y error.

2.  ‚≠ê **LC - Gesti√≥n de Personal (PINs y Permisos): [ALTA PRIORIDAD - Despu√©s de Split Bill]**

    - **Objetivo:** Crear un sistema para que el `BUSINESS_ADMIN` pueda gestionar a su personal (camareros, cocina), asignarles roles (`WAITER`, `KITCHEN_STAFF`) y un PIN de 4 d√≠gitos para un inicio de sesi√≥n r√°pido en las interfaces de servicio (KDS, TPV de camarero).

3.  ‚≠ê **LC - Mejoras en la Interfaz de Camarero (TPV): [MEDIA PRIORIDAD]**
    - **Objetivo:** Unificar y mejorar las vistas del camarero. Pasar de p√°ginas separadas (`pickup-station`, `order-management`) a un TPV (Terminal Punto de Venta) m√°s cohesivo que incluya un plano de mesas (`TableManager`), listado de pedidos por estado, y acceso a las nuevas funcionalidades como "Dividir Cuenta".

---

## 6. Informaci√≥n Adicional ‚ÑπÔ∏è

- **Licencia:** Software Propietario. Copyright (c) 2024-2025 Olivier Hottelet. Todos los derechos reservados. Consulta [LICENSE.md](./LICENSE.md) para m√°s detalles.
- **Flujos de Trabajo Detallados:** Para una comprensi√≥n profunda de c√≥mo operan los m√≥dulos y su integraci√≥n, consultar:
  - `LOYALPYME_CORE_WORKFLOW.md`
  - `LOYALPYME_CAMARERO_WORKFLOW.md` (requerir√° una actualizaci√≥n significativa despu√©s de implementar el ciclo completo de pedido y pago)
  - `MODULE_INTEGRATION_WORKFLOW.md`



// ====== [7] README.md ======
# LoyalPyME üá™üá∏ (v1.21.0)

**LoyalPyME** es una plataforma web integral y modular, desarrollada con un stack **Frontend React (TypeScript, Mantine UI, Vite)** y **Backend Node.js (TypeScript, Express, Prisma, PostgreSQL)**, dise√±ada espec√≠ficamente para Peque√±as y Medianas Empresas (PyMEs). La plataforma se estructura en m√≥dulos activables individualmente por cada negocio cliente, permitiendo una soluci√≥n a medida y adaptada a sus necesidades operativas y de marketing.

- ‚≠ê **LoyalPyME Core (LCo) - M√≥dulo de Fidelizaci√≥n [Estable y Funcional]:**
  Un sistema robusto y completo para la gesti√≥n de programas de lealtad digitales.

  - **Gesti√≥n de Clientes:** Administraci√≥n detallada de clientes, incluyendo su historial de puntos, nivel de fidelizaci√≥n, y actividad.
  - **Sistema de Puntos:** Configuraci√≥n de ratio de puntos por gasto, generaci√≥n de QR para acumulaci√≥n en punto de venta f√≠sico.
  - **Niveles de Fidelizaci√≥n (Tiers):** Creaci√≥n de m√∫ltiples niveles con umbrales personalizables (basados en gasto, visitas, o puntos acumulados) y asignaci√≥n de beneficios exclusivos por nivel (ej. multiplicadores de puntos, acceso a recompensas especiales).
  - **Cat√°logo de Recompensas:** Gesti√≥n de un cat√°logo de recompensas canjeables por puntos, con soporte completo para internacionalizaci√≥n (nombres y descripciones en ES/EN) e im√°genes individuales por recompensa.
  - **Panel de Cliente Interactivo:** Un dashboard personalizado para que los clientes finales consulten su saldo de puntos, nivel actual y progreso hacia el siguiente, visualicen las recompensas disponibles y regalos asignados, canjeen beneficios, y revisen su historial completo de transacciones de fidelizaci√≥n.

- üöÄ **LoyalPyME Camarero (LC) - M√≥dulo de Hosteler√≠a [Ciclo Completo de Pedido y Servicio Validado]:**
  Un m√≥dulo avanzado enfocado en la digitalizaci√≥n y optimizaci√≥n integral del servicio en el sector hostelero (restaurantes, bares, cafeter√≠as), mejorando la eficiencia operativa y la experiencia del cliente.
  - **Funcionalidad Actual Clave:**
    1.  **Gesti√≥n de Carta Digital por el Administrador:** Interfaz administrativa completa y detallada (`/admin/dashboard/camarero/menu-editor`) para crear, editar y organizar:
        - **Categor√≠as del Men√∫:** Con nombre (ES/EN), descripci√≥n (ES/EN), imagen (con recorte), posici√≥n y estado de activaci√≥n.
        - **√çtems del Men√∫:** Dentro de cada categor√≠a, con nombre (ES/EN), descripci√≥n (ES/EN), precio, imagen (con recorte), listado de al√©rgenos, etiquetas (ej. "Vegano", "Popular"), disponibilidad, posici√≥n, tiempo de preparaci√≥n estimado, calor√≠as, SKU y destino KDS.
        - **Grupos de Modificadores:** Asociados a cada √≠tem, con nombre (ES/EN), tipo de interfaz de usuario (`RADIO` para selecci√≥n √∫nica, `CHECKBOX` para m√∫ltiple), y reglas de selecci√≥n (m√≠nimo/m√°ximo, obligatorio).
        - **Opciones de Modificador:** Dentro de cada grupo, con nombre (ES/EN) y ajuste de precio.
    2.  **Visualizaci√≥n de Carta P√∫blica por el Cliente Final:** Acceso mediante URL directa (`/m/:businessSlug/:tableIdentifier?`). Los clientes pueden:
        - Navegar por categor√≠as y ver detalles de cada √≠tem.
        - Personalizar √≠tems seleccionando opciones de los modificadores, con el precio actualiz√°ndose din√°micamente.
    3.  **Flujo de Pedido Completo por el Cliente Final:**
        - **Carrito de Compra Local:** Los √≠tems configurados se a√±aden a un carrito que persiste en el `localStorage`.
        - **Modal de Carrito (`ShoppingCartModal.tsx`):** Permite revisar el pedido, modificar cantidades, eliminar √≠tems y a√±adir notas generales.
        - **Env√≠o y Adici√≥n a Pedido:** Al confirmar, el sistema env√≠a un `CreateOrderPayloadDto` al backend, gestionando inteligentemente si se debe crear un pedido nuevo o a√±adir los √≠tems a uno ya existente.
        - **Procesamiento Backend:** Validaci√≥n exhaustiva de disponibilidad, reglas y precios, con creaci√≥n transaccional en la base de datos.
        - **Feedback al Cliente:** Notificaci√≥n de √©xito y redirecci√≥n a la p√°gina de estado del pedido.
    4.  **Visualizaci√≥n del Estado del Pedido por el Cliente (`OrderStatusPage.tsx`):**
        - Muestra el estado general del pedido y de cada √≠tem (`En preparaci√≥n`, `Listo`, `Servido`).
        - Se actualiza autom√°ticamente mediante polling.
        - Permite al cliente **solicitar la cuenta** para iniciar el proceso de pago.
    5.  **Kitchen Display System (KDS) - Backend y Frontend (Funcional):**
        - **API KDS Backend:** Endpoints validados para obtener y actualizar el estado de los √≠tems de preparaci√≥n.
        - **Interfaz KDS Frontend:** Permite al personal de cocina/barra visualizar los √≠tems por destino y cambiar su estado (`PENDING_KDS` -> `PREPARING` -> `READY`).
    6.  **Interfaz de Camarero y Ciclo de Pago Completo (Funcional):**
        - **Recogida y Entrega:** La interfaz de camarero (`WaiterPickupPage.tsx`) muestra los √≠tems listos para recoger, permitiendo marcarlos como servidos.
        - **Gesti√≥n de Pago:** La interfaz de gesti√≥n (`WaiterOrderManagementPage.tsx`) muestra los pedidos pendientes de pago, permitiendo al camarero marcarlos como `PAID`.
        - **Automatizaci√≥n:** Al marcar como pagado, el sistema libera la mesa y asigna puntos de fidelidad LCo al cliente de forma autom√°tica.

La plataforma LoyalPyME est√° dise√±ada con un enfoque en la **mantenibilidad**, **escalabilidad** y **adaptabilidad**, buscando ser el socio tecnol√≥gico que impulse la eficiencia operativa y el crecimiento sostenible de las PyMEs.

## Visi√≥n y Prop√≥sito ‚ú®

LoyalPyME aspira a ser el **aliado tecnol√≥gico integral de las Peque√±as y Medianas Empresas (PyMEs)**, proporcionando herramientas digitales sofisticadas pero intuitivas y f√°ciles de usar, integradas en una √∫nica plataforma modular que se adapta a las necesidades espec√≠ficas de cada negocio.

Con **LoyalPyME Core (LCo)**, buscamos empoderar a las empresas para que puedan cultivar relaciones m√°s profundas, significativas y duraderas con sus clientes. El objetivo es fomentar la lealtad y la recurrencia a trav√©s de programas de recompensas personalizados, comunicaci√≥n efectiva y una experiencia de cliente gratificante que los haga sentir valorados.

Con el m√≥dulo **LoyalPyME Camarero (LC)**, nuestra visi√≥n es transformar y modernizar la operativa en el sector de la hosteler√≠a. Queremos que los negocios puedan:

- **Modernizar su servicio:** Ofreciendo una experiencia de pedido digital √°gil y sin fricciones directamente desde la mesa del cliente.
- **Reducir errores manuales:** Minimizando las imprecisiones en la toma de comandas y la comunicaci√≥n con cocina/barra.
- **Agilizar la comunicaci√≥n interna:** Optimizando el flujo de informaci√≥n entre el personal de sala, la cocina y la barra a trav√©s del KDS y la interfaz de camarero.
- **Mejorar significativamente la experiencia del cliente final:** Permiti√©ndole explorar la carta a su ritmo, personalizar sus pedidos con total control y transparencia, y seguir el estado de su comanda en tiempo real.
- **Obtener datos operativos valiosos:** Recopilando informaci√≥n sobre ventas, popularidad de √≠tems, y tiempos de preparaci√≥n para la toma de decisiones estrat√©gicas y la optimizaci√≥n continua del negocio.

La plataforma es inherentemente vers√°til: **LoyalPyME Core** es aplicable a una amplia gama de sectores empresariales (retail, servicios profesionales, bienestar, etc.) que busquen implementar programas de fidelizaci√≥n. Por su parte, **LoyalPyME Camarero** ofrece una soluci√≥n especializada, potente y adaptada a las particularidades del sector de la restauraci√≥n, desde peque√±as cafeter√≠as hasta restaurantes con mayor volumen de operaciones. La sinergia entre ambos m√≥dulos permite una experiencia de cliente altamente integrada y datos de negocio enriquecidos.

_(Para un an√°lisis exhaustivo del estado actual del proyecto, incluyendo la versi√≥n actual, los hitos completados en detalle, las decisiones de dise√±o clave y las lecciones aprendidas, consulta nuestro [**PROJECT_STATUS.md**](./PROJECT_STATUS.md). La hoja de ruta completa, el backlog de funcionalidades futuras para ambos m√≥dulos, y la visi√≥n a largo plazo se encuentran detallados en [**DEVELOPMENT_PLAN.md**](./DEVELOPMENT_PLAN.md))._

## Caracter√≠sticas Principales Implementadas ‚úÖ

**Plataforma Base y Gesti√≥n Multi-M√≥dulo:**

- **Panel Super Admin:** Interfaz dedicada (`/superadmin`) para el rol `SUPER_ADMIN`, permitiendo la administraci√≥n global de los negocios clientes registrados. Funcionalidades: listar negocios, ver su estado general (`isActive`), y **activar/desactivar individualmente los m√≥dulos LoyalPyME Core (`isLoyaltyCoreActive`) y LoyalPyME Camarero (`isCamareroActive`)** para cada negocio.
- **Gesti√≥n de M√≥dulos por Negocio:** La funcionalidad de cada m√≥dulo (LCo, LC) se habilita o deshabilita a nivel de la entidad `Business` en la base de datos. El perfil de usuario (`/api/profile`) que se obtiene tras el login incluye estos flags de activaci√≥n para el negocio asociado, permitiendo al frontend adaptar la UI din√°micamente.
- **Control de Acceso Basado en M√≥dulos y Roles (RBAC + MBAC):**
  - **RBAC (Role-Based Access Control):** El acceso a las funcionalidades (APIs backend y componentes UI frontend) est√° condicionado por el rol del usuario (`SUPER_ADMIN`, `BUSINESS_ADMIN`, `CUSTOMER_FINAL`, `KITCHEN_STAFF`, `BAR_STAFF`, y futuro `WAITER`).
  - **MBAC (Module-Based Access Control):** Un middleware backend (`checkModuleActive`) y l√≥gica en frontend verifican que el m√≥dulo requerido est√© activo para el negocio del usuario antes de permitir el acceso a funcionalidades espec√≠ficas de dicho m√≥dulo.

**LoyalPyME Core (LCo) - M√≥dulo de Fidelizaci√≥n [Estable y Funcional]:**

- **Autenticaci√≥n Completa y Segura:**
  - Registro de Negocios con su primer `BUSINESS_ADMIN`.
  - Registro de `CUSTOMER_FINAL` asociados a un negocio espec√≠fico.
  - Login robusto con email/contrase√±a, utilizando JWT para la gesti√≥n de sesiones.
  - Funcionalidad completa de Reseteo de Contrase√±a.
- **Gesti√≥n Avanzada de Clientes (Panel Admin LCo):**
  - Listado paginado con b√∫squeda por nombre/email, filtros y ordenaci√≥n.
  - Funcionalidades CRUD para clientes, incluyendo: notas internas, ajuste manual de puntos, cambio manual de nivel, asignaci√≥n de regalos, activaci√≥n/desactivaci√≥n y marcado como favoritos.
  - Acciones Masivas sobre clientes seleccionados: activar/desactivar, eliminar y ajustar puntos.
- **Sistema de Niveles/Tiers Din√°mico y Configurable (Panel Admin LCo):**
  - CRUD completo para niveles de fidelizaci√≥n y sus beneficios asociados.
  - Configuraci√≥n global del sistema de tiers: base de c√°lculo, periodo y pol√≠ticas de descenso.
- **Gesti√≥n Integral de Recompensas (Panel Admin LCo):**
  - CRUD completo para recompensas canjeables por puntos, con soporte i18n y subida de im√°genes.
- **Flujo de Acumulaci√≥n de Puntos y QR (LCo):**
  - Generaci√≥n de QR √∫nicos y temporales por parte del administrador.
  - Validaci√≥n de QR por parte del cliente mediante escaneo con la c√°mara o introducci√≥n manual.
- **L√≥gica de Tiers y Actualizaci√≥n Autom√°tica (LCo - Backend):** Tarea programada (Cron Job) para recalcular y actualizar el nivel de los clientes.
- **Panel de Cliente Completo (LCo - Frontend - `CustomerDashboardPage.tsx`):**
  - Interfaz organizada en pesta√±as:
    - **Resumen (`SummaryTab.tsx`):** Informaci√≥n clave, barra de progreso al siguiente nivel, y secci√≥n para validar QR.
    - **Recompensas (`RewardsTab.tsx`):** Listado de recompensas canjeables y regalos pendientes.
    - **Actividad (`ActivityTab.tsx`):** Historial paginado de todas las transacciones de puntos.

**M√≥dulo LoyalPyME Camarero (LC) [Ciclo de Pedido Completo Validado]:**

- **Modelo de Datos Robusto para Hosteler√≠a (Backend - Prisma):**
  - Definici√≥n detallada de entidades como `MenuCategory`, `MenuItem`, `ModifierGroup`, `Order`, `OrderItem`, `Table`, `StaffPin`.
- **API de Gesti√≥n de Carta por el Administrador (Backend):**
  - Endpoints CRUD completos y protegidos para gestionar toda la carta digital.
- **Interfaz de Usuario para Gesti√≥n de Carta (Admin Frontend):**
  - Componentes dedicados para un CRUD intuitivo de la estructura de la carta, incluyendo subida y recorte de im√°genes.
- **Visualizaci√≥n de Carta P√∫blica y Flujo de Pedido por Cliente Final:**
  - **Frontend:** P√°gina responsive para visualizaci√≥n y personalizaci√≥n de √≠tems con precios din√°micos.
  - **Carrito de Compra Local:** Con persistencia en `localStorage` y funcionalidades de edici√≥n.
  - **Env√≠o y Adici√≥n de √çtems:** El sistema gestiona inteligentemente si crear un nuevo pedido o a√±adir √≠tems a uno ya existente.
- **Visualizaci√≥n del Estado del Pedido por el Cliente:**
  - P√°gina con polling autom√°tico que muestra el estado del `Order` y de cada `OrderItem`.
  - Incluye la funcionalidad para "Pedir la Cuenta".
- **Kitchen Display System (KDS) - Backend y Frontend:**
  - **API KDS:** Endpoints validados para obtener y actualizar el estado de los √≠tems de preparaci√≥n.
  - **Interfaz KDS:** Permite al personal de cocina/barra visualizar los √≠tems y cambiar su estado de preparaci√≥n.
- **Ciclo de Servicio y Pago Completo (Camarero):**
  - **Recogida:** Interfaz para que el personal de sala vea los √≠tems listos y los marque como servidos.
  - **Pago:** Interfaz para ver los pedidos pendientes de pago y marcarlos como `PAID`.
  - **Automatizaci√≥n:** El marcado como pagado libera la mesa y asigna puntos LCo.

## Estado Actual y Pr√≥ximos Pasos üó∫Ô∏è

La plataforma ha alcanzado la **versi√≥n v1.21.0**.

- **LoyalPyME Core (LCo):** Estable, completamente funcional y probado.
- **Arquitectura Multi-M√≥dulo y Panel Super Admin:** Implementada y operativa.
- **M√≥dulo Camarero (LC):** El ciclo de vida completo de un pedido est√° **completo y validado.**

El **enfoque principal de desarrollo inmediato** es a√±adir funcionalidades avanzadas de gesti√≥n al M√≥dulo Camarero (LC):

1.  ‚≠ê **LC - Dividir la Cuenta (Split Bill):**
    - **Objetivo:** Permitir al personal de sala dividir una cuenta entre m√∫ltiples clientes.

Posteriormente, se abordar√°n funcionalidades como la gesti√≥n de personal con PINs, mejoras en la interfaz del camarero (TPV), y un sistema de reservas.

- Consulta **[PROJECT_STATUS.md](./PROJECT_STATUS.md)** para un an√°lisis detallado.
- Revisa **[DEVELOPMENT_PLAN.md](./DEVELOPMENT_PLAN.md)** para la hoja de ruta completa.

## Tecnolog√≠as Utilizadas üõ†Ô∏è

**Frontend:**
React (v19+, Hooks, Context API), TypeScript, Vite (v5+, bundler y servidor de desarrollo HMR), Mantine UI (v7+, biblioteca de componentes y hooks), Axios (cliente HTTP), React Router DOM (v6+, para enrutamiento SPA), `html5-qrcode` (para escaneo de c√≥digos QR por el cliente en LCo), `react-image-crop` (para recorte de im√°genes en interfaces de administraci√≥n), `i18next` y `react-i18next` (para internacionalizaci√≥n ES/EN con archivos JSON), `zod` (para validaci√≥n de formularios, implementaci√≥n progresiva).

**Backend:**
Node.js (runtime), Express.js (framework web), TypeScript (lenguaje principal), Prisma ORM (v6+, para acceso a base de datos PostgreSQL, gesti√≥n de migraciones y generaci√≥n de cliente tipado), PostgreSQL (sistema de gesti√≥n de base deatos relacional), JSON Web Tokens (JWT) (para autenticaci√≥n stateless), `bcryptjs` (para hashing seguro de contrase√±as), Cloudinary SDK (para almacenamiento y gesti√≥n de im√°genes en la nube), Multer (middleware para manejo de subidas de archivos `multipart/form-data`), Vitest (para testing unitario y de integraci√≥n), Supertest (para testing de API HTTP), Swagger/OpenAPI (`swagger-jsdoc`, `swagger-ui-express`) (para documentaci√≥n interactiva de la API RESTful), `node-cron` (para la ejecuci√≥n de tareas programadas, ej. actualizaci√≥n de tiers en LCo).

## Inicio R√°pido (Desarrollo Local) üöÄ

1.  **Clonar el Repositorio:**
    ```bash
    git clone <URL_DEL_REPOSITORIO_GIT> LoyalPyME
    cd LoyalPyME
    ```
2.  **Configuraci√≥n del Backend (`backend/`):**
    - Instalar dependencias: `yarn install` (o `npm install`).
    - Configurar Variables de Entorno: Copiar `backend/.env.example` a `backend/.env` y rellenar todas las variables.
    - Base de Datos (PostgreSQL debe estar corriendo):
      1.  Crear la base de datos (ej. `loyalpymedb`).
      2.  Desde `backend/`, ejecutar `npx prisma migrate reset`.
      3.  Ejecutar `npx prisma db seed` para poblar con datos de demostraci√≥n.
      4.  Ejecutar `npx ts-node ./scripts/create-superadmin.ts` para crear el Super Administrador.
    - Ejecutar el Backend (desde `backend/`, en dos terminales separadas):
      1.  `yarn dev:build` (o `npx tsc --watch`): Compilaci√≥n continua de TypeScript.
      2.  `yarn dev:run` (o `npx nodemon dist/index.js`): Iniciar servidor Node.js con Nodemon.
3.  **Configuraci√≥n del Frontend (`frontend/`):**
    - Instalar dependencias: `yarn install` (o `npm install`).
    - Ejecutar el Frontend (desde `frontend/`): `yarn dev`.
4.  **Acceso a las Aplicaciones (URLs por defecto):**
    - **Carta P√∫blica:** `https://localhost:5173/m/restaurante-demo-loyalpyme`
    - **Login / Dashboards:** `https://localhost:5173`
    - **Documentaci√≥n API (Swagger):** `http://localhost:3000/api-docs`

**¬°Importante!** Para instrucciones **exhaustivas y detalladas**, consulta la gu√≠a **[SETUP_GUIDE.md](./SETUP_GUIDE.md)**. Para soluciones a problemas comunes, revisa la **[TROUBLESHOOTING_GUIDE.md](./TROUBLESHOOTING_GUIDE.md)**.

---

## Contribuciones ü§ù

Este proyecto es software propietario desarrollado por Olivier Hottelet. No se aceptan contribuciones externas directas en este momento. Si se detectan errores o se tienen sugerencias de mejora, pueden ser comunicadas al propietario. Si el repositorio fuera p√∫blico y permitiera la creaci√≥n de "Issues" en la plataforma de hosting de c√≥digo (ej. GitHub, GitLab), esa ser√≠a la v√≠a formal para reportar bugs o proponer nuevas funcionalidades.

## Licencia üìú

Este proyecto es software propietario.
**Copyright (c) 2024-2025 Olivier Hottelet. Todos los derechos reservados.**

El uso, copia, reproducci√≥n, distribuci√≥n, modificaci√≥n, descompilaci√≥n, ingenier√≠a inversa o cualquier otra forma de explotaci√≥n de este software o su c√≥digo fuente, en su totalidad o en parte, est√° estrictamente prohibido sin el permiso previo, expl√≠cito y por escrito del propietario de los derechos de autor. Este software se considera informaci√≥n confidencial y un secreto comercial.

Para m√°s detalles sobre los t√©rminos de la licencia, consulta el archivo [LICENSE.md](./LICENSE.MD) en el directorio ra√≠z del proyecto.

## Contacto üìß

Para consultas sobre el proyecto, licencias, adquisici√≥n, o cualquier otro asunto relacionado:

- **Olivier Hottelet**
- [olivierhottelet1980@gmail.com](mailto:olivierhottelet1980@gmail.com)



// ====== [8] SETUP_GUIDE.md ======
# LoyalPyME - Gu√≠a Completa de Instalaci√≥n y Ejecuci√≥n Local

**√öltima Actualizaci√≥n:** 09 de Mayo de 2025

Esta gu√≠a describe los pasos necesarios para instalar, configurar y ejecutar el proyecto LoyalPyME en un entorno de desarrollo local. Es crucial seguir los pasos en orden para asegurar una configuraci√≥n correcta.

---

## 1. Prerrequisitos

Antes de empezar, aseg√∫rate de tener instalado lo siguiente en tu sistema:

- **Node.js:** Se recomienda una versi√≥n LTS reciente (v18 o v20+ al momento de escribir esto). Puedes descargarlo desde [nodejs.org](https://nodejs.org/). Node.js incluye npm (Node Package Manager).
- **Yarn (Opcional, pero usado en los ejemplos de scripts):** Gestor de paquetes para Node.js (v1.x recomendada si se usa). Si tienes Node.js/npm, puedes instalarlo con `npm install --global yarn`. Si prefieres usar `npm` para todos los comandos, puedes adaptar los ejemplos (`yarn install` -> `npm install`, `yarn dev` -> `npm run dev`).
- **PostgreSQL:** Sistema de base de datos relacional. Necesitas tener un servidor PostgreSQL instalado y **corriendo** localmente o accesible en tu red.
  - Puedes descargarlo desde [postgresql.org/download](https://www.postgresql.org/download/).
  - Durante la instalaci√≥n, se te pedir√° configurar una contrase√±a para el usuario `postgres` (o el usuario administrador por defecto). An√≥tala.
  - Necesitar√°s crear una base de datos para el proyecto. Usando una herramienta como `psql` (cliente de l√≠nea de comandos de PostgreSQL) o pgAdmin (GUI), puedes crearla con: `CREATE DATABASE loyalpymedb;` (o el nombre que prefieras, pero deber√°s ajustarlo en el `.env`).
- **Git:** Sistema de control de versiones para clonar el repositorio. [git-scm.com/downloads](https://git-scm.com/downloads).
- **`npx`:** Es una herramienta que viene con `npm` (desde la versi√≥n 5.2+). Permite ejecutar paquetes de Node.js sin necesidad de instalarlos globalmente. La usaremos para comandos de Prisma y `ts-node`.
- **(Opcional) NVM (Node Version Manager):** √ötil para gestionar m√∫ltiples versiones de Node.js si trabajas en varios proyectos ([Linux/Mac](https://github.com/nvm-sh/nvm), [Windows](https://github.com/coreybutler/nvm-windows)).
- **(Opcional) Editor de C√≥digo:** Se recomienda VS Code con extensiones para Prisma, TypeScript, ESLint.

---

## 2. Instalaci√≥n del Backend

La configuraci√≥n del backend implica clonar el proyecto, instalar dependencias, configurar el entorno y preparar la base de datos.

1.  **Clonar Repositorio:**
    Si a√∫n no lo tienes, clona el repositorio del proyecto desde su URL y navega a la carpeta ra√≠z del proyecto.

    ```bash
    git clone <URL_DEL_REPOSITORIO_GIT> LoyalPyME
    cd LoyalPyME
    ```

2.  **Navegar a la Carpeta del Backend:**
    Todos los comandos siguientes para el backend se ejecutar√°n desde esta carpeta.

    ```bash
    cd backend
    ```

3.  **Instalar Dependencias del Backend:**
    Esto instalar√° todos los paquetes listados en `package.json` (Express, Prisma, etc.).

    ```bash
    yarn install
    # Alternativamente, si usas npm:
    # npm install
    ```

4.  **Configurar Variables de Entorno (`.env`):**
    Las variables de entorno son cruciales para configurar la conexi√≥n a la base de datos, secretos JWT, y credenciales de servicios externos como Cloudinary.

    - Copia el archivo de ejemplo `.env.example` a un nuevo archivo llamado `.env`:
      ```bash
      cp .env.example .env
      # En Windows, puedes usar: copy .env.example .env
      ```
    - Abre el archivo `.env` reci√©n creado con un editor de texto.
    - **Edita las siguientes variables obligatorias:**
      - `DATABASE_URL`: La cadena de conexi√≥n a tu base de datos PostgreSQL. El formato es: `postgresql://<DB_USER>:<DB_PASSWORD>@<DB_HOST>:<DB_PORT>/<DB_NAME>?schema=public`.
        - Ejemplo para una instalaci√≥n local com√∫n de PostgreSQL (reemplaza `<DB_PASSWORD>` con la contrase√±a que configuraste para tu usuario `postgres`, y `<DB_NAME>` con el nombre de la base de datos que creaste, ej: `loyalpymedb`):
          `postgresql://postgres:tu_contrase√±a_postgres@localhost:5432/loyalpymedb?schema=public`
        - Aseg√∫rate que el usuario de la BD tiene permisos para crear tablas en el schema `public` de esa base de datos.
      - `JWT_SECRET`: Una cadena larga, secreta y aleatoria utilizada para firmar los tokens de autenticaci√≥n (JWT). **¬°No uses el valor de ejemplo en un entorno de producci√≥n!** Puedes generar una con un generador de contrase√±as online.
      - `CLOUDINARY_CLOUD_NAME`: El "Cloud Name" de tu cuenta de Cloudinary (para almacenamiento de im√°genes).
      - `CLOUDINARY_API_KEY`: La "API Key" de tu cuenta de Cloudinary.
      - `CLOUDINARY_API_SECRET`: El "API Secret" de tu cuenta de Cloudinary.
    - **(Opcional) Variables para Tests de Integraci√≥n:** Si planeas ejecutar los tests de integraci√≥n del backend, podr√≠as necesitar definir:
      - `TEST_ADMIN_EMAIL`: Email para el admin en los tests.
      - `TEST_ADMIN_PASSWORD`: Contrase√±a para el admin en los tests.
        _(Nota: Actualmente, los tests podr√≠an tener credenciales hardcodeadas. Idealmente, deber√≠an usar estas variables de entorno.)_
    - **(Opcional) Variables para Creaci√≥n de Super Admin (si se leen desde .env en el script):**
      - `SUPERADMIN_EMAIL`
      - `SUPERADMIN_PASSWORD`
    - Guarda los cambios en el archivo `.env`.

5.  **Preparar la Base de Datos y Cargar Datos Iniciales:**
    Estos pasos inicializar√°n tu base de datos con el esquema definido y datos de prueba.
    - **Paso 5.1: Resetear y Aplicar Migraciones:**
      Este comando es fundamental para el desarrollo. **Eliminar√° todos los datos de tu base de datos `loyalpymedb` (si existe y tiene datos)**, aplicar√° todas las migraciones desde el principio y crear√° las tablas seg√∫n tu archivo `prisma/schema.prisma`. Es la forma m√°s limpia de asegurar que tu BD est√° sincronizada con el schema durante el desarrollo.
      ```bash
      npx prisma migrate reset
      ```
      Prisma te pedir√° confirmaci√≥n. Escribe `y` o `yes` y presiona Enter.
    - **Paso 5.2: Generar Cliente Prisma:**
      Despu√©s de cualquier cambio en el schema (como el que ocurre con `migrate reset` o `migrate dev`), debes regenerar el Cliente Prisma. Esto actualiza los tipos de TypeScript en `node_modules/.prisma/client` para que coincidan con tu schema.
      ```bash
      npx prisma generate
      ```
    - **Paso 5.3: Poblar con Datos de Demostraci√≥n (Seed):**
      Este comando ejecuta el script `prisma/seed.ts`. Este script est√° dise√±ado para crear:
      - Un negocio de demostraci√≥n llamado "Restaurante Demo LoyalPyME".
      - Un usuario administrador (`BUSINESS_ADMIN`) para ese negocio con credenciales: `admin@demo.com` / `password`.
      - Un usuario cliente (`CUSTOMER_FINAL`) para ese negocio con credenciales: `cliente@demo.com` / `password`.
      - Algunos Tiers y Recompensas de ejemplo para el negocio demo.
      - Los m√≥dulos LoyalPyME Core y LoyalPyME Camarero se activan por defecto para este negocio demo.
        Ejecuta:
      ```bash
      npx prisma db seed
      ```
      Deber√≠as ver en la consola los logs del script indicando la creaci√≥n de estos datos.
    - **Paso 5.4: Crear Usuario Super Administrador Global:**
      La plataforma tiene un rol de Super Administrador para gestionar todos los negocios. Este script crea el primer (y posiblemente √∫nico) Super Admin.
      Por defecto (seg√∫n el script `scripts/create-superadmin.ts`), las credenciales son: `superadmin@loyalpyme.com` / `superadminpassword`.
      **¬°Es crucial que cambies la contrase√±a por defecto en el script `create-superadmin.ts` si vas a usar esto en un entorno m√°s all√° de tu m√°quina local!**
      Ejecuta:
      ```bash
      npx ts-node ./scripts/create-superadmin.ts
      ```
      Guarda estas credenciales del Super Admin en un lugar seguro.

---

## 3. Instalaci√≥n del Frontend

1.  **Navegar a la Carpeta del Frontend:**
    Desde la ra√≠z del proyecto (`LoyalPyME/`):

    ```bash
    cd frontend
    ```

    (O `cd ../frontend` si est√°s en la carpeta `backend/`).

2.  **Instalar Dependencias del Frontend:**
    Esto instalar√° React, Mantine, y otras librer√≠as necesarias.
    ```bash
    yarn install
    # Alternativamente, si usas npm:
    # npm install
    ```
    _(No se requiere archivo `.env` en la carpeta `frontend/` por defecto, ya que la URL de la API se configura en `vite.config.ts` para el proxy o se usa directamente en `axiosInstance` si es una URL completa)._

---

## 4. Ejecuci√≥n en Modo Desarrollo

**¬°Aseg√∫rate de que tu servidor PostgreSQL est√© corriendo localmente!**

Se recomienda usar **dos terminales separadas** para el backend para una mejor experiencia de desarrollo.

- **Terminal 1 (Backend - Compilador TypeScript en modo "watch"):**

  - Navega a la carpeta `backend/`.
  - Ejecuta el script `dev:build` de tu `package.json` (o el comando directo):
    ```bash
    yarn dev:build
    # o npx tsc --watch
    ```
  - Esto vigilar√° cambios en tus archivos `.ts` dentro de `src/` y los compilar√° autom√°ticamente a JavaScript en la carpeta `dist/`. D√©jalo corriendo.

- **Terminal 2 (Backend - Servidor Node.js con Nodemon):**

  - Navega a la carpeta `backend/`.
  - Ejecuta el script `dev:run` de tu `package.json` (o el comando directo):
    ```bash
    yarn dev:run
    # o npx nodemon dist/index.js
    ```
  - Esto iniciar√° el servidor Express (`http://localhost:3000` por defecto) usando los archivos compilados en `dist/`. Nodemon reiniciar√° el servidor autom√°ticamente si detecta cambios en `dist/` (causados por `tsc --watch`). D√©jalo corriendo.

- **Terminal 3 (Frontend - Servidor de Desarrollo Vite):**
  - Navega a la carpeta `frontend/`.
  - Ejecuta el script `dev`:
    ```bash
    yarn dev
    # Si necesitas que el frontend sea accesible desde otros dispositivos en tu red local (ej: m√≥vil):
    # yarn dev --host
    ```
  - Esto iniciar√° el servidor de desarrollo de Vite. Por defecto (con `mkcert`), intentar√° usar `https://localhost:5173`. Si no usas HTTPS, ser√° `http://localhost:5173`. La terminal te mostrar√° la URL exacta. D√©jalo corriendo.

---

## 5. Acceso a la Aplicaci√≥n y Paneles

Una vez que todos los servidores est√©n corriendo:

- **Aplicaci√≥n Principal (Login, Registro Cliente, Dashboard Cliente, Panel Admin Negocio):**
  - Abre tu navegador y ve a `https://localhost:5173` (o la URL que te haya dado Vite).
  - **Credenciales del Negocio Demo (creadas por el seed):**
    - Email: `admin@demo.com`
    - Contrase√±a: `password`
  - **Credenciales del Cliente Demo (creadas por el seed):**
    - Email: `cliente@demo.com`
    - Contrase√±a: `password`
- **Panel Super Administrador:**
  - Navega a `https://localhost:5173/superadmin`
  - **Credenciales Super Admin (creadas por el script `create-superadmin.ts`):**
    - Email: `superadmin@loyalpyme.com` (o el que configuraste)
    - Contrase√±a: `superadminpassword` (¬°o la que configuraste!)
- **API Backend Directa:**
  - La API est√° disponible en `http://localhost:3000`.
- **Documentaci√≥n API (Swagger UI):**
  - Accede a `http://localhost:3000/api-docs` en tu navegador para ver y probar los endpoints de la API.

**Acceso desde M√≥vil (Red Local):**
Si ejecutaste el frontend con `yarn dev --host`, Vite te mostrar√° una URL de "Network" (ej: `https://192.168.1.XX:5173`).

1.  Aseg√∫rate que tu PC y tu dispositivo m√≥vil est√°n en la misma red WiFi.
2.  Abre el navegador en tu m√≥vil y escribe esa URL de red.
3.  Si usas HTTPS (recomendado), es probable que el m√≥vil muestre una advertencia de seguridad por el certificado autofirmado de `mkcert`. Deber√°s aceptarla para continuar (generalmente hay una opci√≥n de "Avanzado" o "Continuar de todas formas").
4.  Verifica que tu firewall en la PC permite conexiones entrantes en el puerto `5173` (para Vite) y `3000` (para el backend API) en redes privadas.

---

## 6. Build para Producci√≥n

Para crear las versiones optimizadas para despliegue:

- **Backend:**
  Desde la carpeta `backend/`:
  ```bash
  yarn build
  # o npm run build
  ```
  Esto generar√° la carpeta `dist/` con el c√≥digo JavaScript transpilado.
- **Frontend:**
  Desde la carpeta `frontend/`:
  ```bash
  yarn build
  # o npm run build
  ```
  Esto generar√° la carpeta `dist/` (dentro de `frontend/`) con los assets est√°ticos optimizados.

---

## 7. Ejecuci√≥n en Producci√≥n (Conceptual)

El despliegue a un entorno de producci√≥n es un tema m√°s amplio y depende del proveedor de hosting/plataforma elegido. Conceptualmente, implicar√≠a:

1.  Construir el backend y frontend (ver secci√≥n anterior).
2.  Configurar un servidor de producci√≥n (VPS, PaaS como Render, Heroku, etc.).
3.  Configurar una base de datos PostgreSQL de producci√≥n.
4.  Establecer todas las variables de entorno (`.env`) necesarias en el servidor de producci√≥n (DB_URL, JWT_SECRET, credenciales Cloudinary, etc.).
5.  Subir los archivos de `backend/dist/`, `backend/node_modules/` (solo producci√≥n), y `frontend/dist/`.
6.  Ejecutar las migraciones de Prisma en la base de datos de producci√≥n: `npx prisma migrate deploy`.
7.  Iniciar el servidor Node.js del backend (ej: `node dist/index.js`, idealmente usando un gestor de procesos como PM2).
8.  Configurar un servidor web (como Nginx o Apache) para servir los archivos est√°ticos del frontend y actuar como proxy inverso para las peticiones `/api` hacia el backend Node.js.
9.  Asegurar HTTPS con certificados SSL v√°lidos.

_(El plan de desarrollo menciona una "Estrategia Deployment & CI/CD (Avanzada)" como tarea futura)._

---

## 8. Comandos y Herramientas √ötiles (Ampliados)

Ejecuta estos comandos desde la carpeta correspondiente (`backend/` o `frontend/` seg√∫n aplique).

- **Base de Datos (Backend - Prisma):**

  - `npx prisma studio`: Abre una interfaz gr√°fica en el navegador para ver y editar los datos de tu base de datos. ¬°Muy √∫til para desarrollo!
  - `npx prisma migrate dev`: Aplica migraciones pendientes, crea la BD si no existe (en desarrollo). Te pedir√° un nombre para la nueva migraci√≥n si hay cambios en el schema.
  - `npx prisma migrate reset`: **¬°CUIDADO!** Borra la base de datos y vuelve a aplicar todas las migraciones. √ötil para empezar de cero si las migraciones dan problemas irrecuperables en desarrollo.
  - `npx prisma generate`: Regenera el Cliente Prisma (`@prisma/client`) despu√©s de cambios en `schema.prisma`. **Esencial despu√©s de cualquier migraci√≥n.**
  - `npx prisma format`: Formatea autom√°ticamente tu archivo `schema.prisma` para mantenerlo ordenado.
  - `npx prisma validate`: Comprueba si tu `schema.prisma` es v√°lido sint√°cticamente.
  - `npx prisma db seed`: Ejecuta el script `prisma/seed.ts` para poblar la BD con datos iniciales/demo.

- **Testing (Backend - Vitest):**

  - `yarn test` (o `npm run test`): Ejecuta todos los tests (`*.test.ts`) una vez.
  - `yarn test:watch` (o `npm run test:watch`): Ejecuta los tests y se queda vigilando cambios para volver a ejecutarlos.
  - `yarn test --coverage` (o `npm run test -- --coverage`): Ejecuta los tests y genera un informe de cobertura de c√≥digo.
  - `yarn test <nombre_archivo_o_patron>`: Ejecuta solo tests espec√≠ficos.

- **Testing (Frontend - Vitest):**

  - `yarn test` (o `npm run test`): Ejecuta todos los tests una vez.
  - `yarn test:watch` (o `npm run test:watch`): Ejecuta en modo vigilancia.
  - `yarn test:ui` (o `npm run test:ui`): Abre una interfaz gr√°fica en el navegador para explorar los resultados de los tests de Vitest.
  - `yarn test --coverage` (o `npm run test -- --coverage`): Ejecuta con informe de cobertura.

- **Scripts Personalizados (Backend - ejecutados con `ts-node`):**

  - `npx ts-node ./scripts/create-superadmin.ts`: Crea el usuario Super Administrador global.
  - `npx ts-node ./scripts/hash-customer-password.ts`: (Ejemplo) Script para actualizar hash de contrase√±a de un usuario espec√≠fico. Adaptar seg√∫n necesidad.
    _(Para ejecutar scripts `ts-node`, aseg√∫rate de estar en la carpeta `backend/` y que `ts-node` est√© en `devDependencies`)_.

- **Otros Comandos Frontend:**

  - `yarn lint` (o `npm run lint`): Ejecuta ESLint para comprobar la calidad y estilo del c√≥digo.
  - `yarn preview` (o `npm run preview`): Construye la app para producci√≥n y la sirve localmente para previsualizarla.

- **Herramientas Externas Recomendadas:**
  - **Clientes Gr√°ficos de PostgreSQL:** pgAdmin (oficial), DBeaver (universal), DataGrip (de JetBrains, de pago). Muy √∫tiles para inspeccionar el schema, los datos, y ejecutar SQL directamente.
  - **psql:** Cliente de l√≠nea de comandos para PostgreSQL. Potente para usuarios avanzados.
  - **Postman / Insomnia / Bruno:** Herramientas para probar la API backend directamente enviando peticiones HTTP (GET, POST, etc.) y viendo las respuestas. Esencial para depurar APIs.
  - **Navegador (Herramientas de Desarrollador - F12):** Indispensable para depurar el frontend:
    - **Consola:** Ver logs de JavaScript, errores.
    - **Red (Network):** Inspeccionar peticiones API, sus cabeceras, cuerpos y respuestas.
    - **Elementos (Elements):** Inspeccionar y modificar el DOM y CSS.
    - **Aplicaci√≥n (Application):** Ver y modificar `localStorage`, `sessionStorage`, cookies.
  - **Navegador (Depuraci√≥n Remota M√≥vil):** Si necesitas depurar la vista m√≥vil, los navegadores de escritorio ofrecen herramientas para conectar con el navegador de un dispositivo m√≥vil (o emulador) y ver su consola/inspector. (Ver secci√≥n 5 y `TROUBLESHOOTING_GUIDE.md`).

---

## 9. ¬øProblemas?

Si encuentras problemas durante la instalaci√≥n o ejecuci√≥n, consulta primero la [TROUBLESHOOTING_GUIDE.md](./TROUBLESHOOTING_GUIDE.md) para ver soluciones a errores comunes ya documentados.

---

_(Fin de la Gu√≠a de Setup)_



// ====== [9] TROUBLESHOOTING_GUIDE.md ======
# Gu√≠a R√°pida de Troubleshooting - LoyalPyME

**Fecha de √öltima Actualizaci√≥n:** 09 de Mayo de 2025

---

Esta gu√≠a recopila problemas t√©cnicos significativos o no obvios encontrados durante el desarrollo de LoyalPyME, sus causas y soluciones, para agilizar futuras depuraciones.

---

## Problemas Comunes y Soluciones

**NUEVO: Problemas con el Script de Seed (`npx prisma db seed`)**

**A. `npx prisma db seed` no ejecuta el script `prisma/seed.ts` o no muestra `console.log`s:**

- **S√≠ntomas:** El comando `npx prisma db seed` se completa r√°pidamente sin mostrar los `console.log` del script `seed.ts`, y la base de datos no se puebla. Sin embargo, ejecutar `npx ts-node ./prisma/seed.ts` directamente S√ç funciona y muestra los logs.
- **Causa M√°s Probable:** Prisma CLI (v5+) no est√° encontrando o interpretando correctamente la configuraci√≥n para ejecutar el script de seed TypeScript.
- **Soluci√≥n Cr√≠tica:**
  1.  **Asegurar `package.json` (en `backend/`):** Dentro de tu `backend/package.json`, a√±ade o verifica una secci√≥n `"prisma"` que defina el comando de seed:
      ```json
      {
        // ... otras secciones ...
        "prisma": {
          "seed": "ts-node prisma/seed.ts"
          // La opci√≥n --compiler-options "{\"module\":\"commonjs\"}" puede causar errores TS5023
          // Es mejor confiar en el tsconfig.json del proyecto si est√° configurado para commonjs.
        }
      }
      ```
  2.  Aseg√∫rate de que `ts-node` est√° en tus `devDependencies`.
  3.  Ejecuta `npx prisma db seed` desde la misma carpeta donde est√° el `package.json` que contiene la secci√≥n `"prisma"` (normalmente `backend/`).

**B. Error `TSError: ‚®Ø Unable to compile TypeScript: error TS5023: Unknown compiler option 'X'` al ejecutar `npx prisma db seed`:**

- **S√≠ntomas:** El comando `npx prisma db seed` falla con errores `TS5023` indicando opciones de compilador desconocidas (a menudo n√∫meros o caracteres sueltos).
- **Causa:** El comando definido en `package.json` para el seed (bajo `"prisma": { "seed": "..." }`) tiene una sintaxis incorrecta para pasar argumentos como `--compiler-options` a `ts-node`, usualmente debido a problemas con el escapado de comillas dentro del JSON del `package.json`.
- **Soluci√≥n:** Simplifica el comando de seed en `package.json` a:
  ```json
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  }
  ```
  Aseg√∫rate que tu `backend/tsconfig.json` tiene `"module": "commonjs"` (o el m√≥dulo que est√©s usando para tu backend).

**C. Errores de TypeScript en `seed.ts` (ej: `Property 'X' does not exist on type 'BusinessCreateInput'`) despu√©s de modificar `schema.prisma`:**

- **S√≠ntomas:** El editor o la compilaci√≥n de `ts-node` muestra errores de TypeScript en `seed.ts` indicando que campos reci√©n a√±adidos al schema no existen en los tipos de entrada generados por Prisma (ej: `BusinessCreateInput`).
- **Causa:** El Cliente Prisma (`node_modules/.prisma/client`) no se ha regenerado despu√©s de la √∫ltima migraci√≥n exitosa de `schema.prisma` (`migrate dev` o `migrate reset`).
- **Soluci√≥n Cr√≠tica:** **SIEMPRE** ejecuta `npx prisma generate` en `backend/` despu√©s de cada `npx prisma migrate dev` o `npx prisma migrate reset` exitoso. Si el editor sigue mostrando errores, reinicia el servidor TypeScript de tu editor (ej: en VS Code, Ctrl+Shift+P -> "TypeScript: Restart TS server").

**D. Error `P3018` (Migration failed to apply) con `DETAIL: La llave (businessId)=... no est√° presente en la tabla ¬´Business¬ª` al intentar migrar `schema.prisma` despu√©s de cambios estructurales:**

- **S√≠ntomas:** `npx prisma migrate dev` falla con `P3018` y un error de base de datos sobre violaci√≥n de clave for√°nea (usualmente `ERROR: inserci√≥n o actualizaci√≥n en la tabla ¬´YYY¬ª viola la llave for√°nea ¬´YYY_businessId_fkey¬ª`). Prisma tambi√©n puede advertir sobre `DROP` de tablas no vac√≠as antes de intentar la migraci√≥n.
- **Causa:** Un cambio estructural grande (ej: hacer opcional un campo que era parte de una relaci√≥n obligatoria, cambiar tipos de campos relacionados, etc.) hace que Prisma determine que necesita recrear tablas. Si tienes datos existentes, Prisma intenta aplicar los cambios, pero si los datos se reinsertan en un orden incorrecto (ej: un `Tier` antes que su `Business` asociado si la tabla `Business` fue recreada) o si los datos referenciados se pierden temporalmente durante la migraci√≥n, las restricciones de claves for√°neas pueden fallar.
- **Soluci√≥n (Para Desarrollo donde los datos NO son cr√≠ticos):** La forma m√°s limpia y r√°pida es resetear la base de datos. Esto eliminar√° todos los datos existentes y aplicar√° todas las migraciones desde cero sobre una BD limpia.
  ```bash
  npx prisma migrate reset
  ```
  Confirma la acci√≥n cuando se te pregunte. Luego, no olvides ejecutar `npx prisma generate` y, si tienes un script de seed, `npx prisma db seed`.
- **Soluci√≥n (Para Producci√≥n o datos cr√≠ticos - ¬°CON MUCHO CUIDADO!):** Esto es mucho m√°s complejo. Implica analizar el SQL generado por la migraci√≥n fallida (en `prisma/migrations/.../migration.sql`), entender por qu√© falla, y potencialmente editar ese SQL o realizar operaciones manuales en la BD para preparar los datos ANTES de reintentar la migraci√≥n. A menudo es preferible hacer cambios m√°s peque√±os e incrementales en producci√≥n o tener una estrategia de backup/restore robusta. Consulta la documentaci√≥n de Prisma sobre "Resolving failed migrations".

---

_(Aqu√≠ contin√∫a el resto de tu contenido original de TROUBLESHOOTING_GUIDE.md)_
_(Me aseguro de incluir los puntos que ya ten√≠as)_

---

**1. Backend: Inestabilidad con `yarn dev` (nodemon + ts-node)**

- **S√≠ntomas:** Reinicios inesperados, errores `SyntaxError`, cambios no reflejados.
- **Causa:** Conflictos/inestabilidad de `ts-node-dev`/`nodemon` con m√≥dulos ES/CJS en el entorno.
- **Soluci√≥n Estable:** Usar **dos terminales** en `backend/`:
  1. `npx tsc --watch` (Compilaci√≥n continua)
  2. `npx nodemon dist/index.js` (Ejecuci√≥n con reinicio autom√°tico al cambiar `dist/`)

**2. Backend: Cambios en `.ts` No Se Reflejan / Ruta Nueva da 404 / L√≥gica Antigua se Ejecuta**

- **S√≠ntomas:** Modificas c√≥digo en un archivo `.ts` (ej: un servicio), pero la API sigue comport√°ndose como antes (ej: no guarda un campo nuevo, usa l√≥gica vieja). O creas una ruta nueva y da 404.
- **Causa:** El proceso `node` que ejecuta `nodemon` solo vigila cambios en la carpeta `dist/`. Si no tienes `npx tsc --watch` corriendo o no has ejecutado `yarn build` manualmente despu√©s de guardar el `.ts`, los cambios no se compilan a JavaScript en `dist/`. Adem√°s, si a√±ades una nueva ruta, debes asegurarte de montarla con `app.use()` en `index.ts`.
- **Soluci√≥n Cr√≠tica:** **SIEMPRE** aseg√∫rate de que los cambios en `.ts` se compilen a `dist/` (`tsc --watch` o `yarn build`). Si a√±ades rutas, aseg√∫rate de que `index.ts` las importa y las monta (`app.use(...)`). **Reinicia `nodemon`** despu√©s de cambiar `index.ts`. Si persiste, forzar limpieza: `rm -rf dist && yarn build && npx nodemon dist/index.js`. _(Visto con rutas /api/customer/activity y /api/uploads/image)_

**3. Frontend: Cambios No Se Aplican (Vite HMR)**

- **S√≠ntomas:** Funcionalidad no cambia, estilos viejos, etc., tras guardar archivo.
- **Soluci√≥n:** 1. Verificar terminal `yarn dev` por errores. 2. Refresco forzado navegador (Ctrl+Shift+R). 3. **Reiniciar `yarn dev`** (`Ctrl+C` y `yarn dev --host`), especialmente tras cambios en `vite.config.ts`.

**4. Backend: Errores `TS2305` (`Module '"@prisma/client"' has no exported member 'User', 'Reward', etc.`)**

- **S√≠ntomas:** TypeScript no encuentra **ninguno** de los tipos/enums generados por Prisma al importar desde `@prisma/client`, incluso despu√©s de una migraci√≥n exitosa. Ocurre al compilar (`npx tsc`).
- **Causa:** La generaci√≥n del Cliente Prisma (`node_modules/.prisma/client`) est√° incompleta, corrupta, o no se ejecut√≥/termin√≥ correctamente despu√©s de la √∫ltima migraci√≥n (`prisma migrate`). `tsc` no puede encontrar las definiciones de tipos necesarias.
- **Soluci√≥n Cr√≠tica:** Ejecutar expl√≠citamente **`npx prisma generate`** en `backend/` despu√©s de cada `prisma migrate dev` exitoso. Asegurarse de que `prisma generate` termina sin errores. Reiniciar el servidor TS del editor si es necesario. Si persiste, borrar `node_modules/.prisma/client` manualmente y regenerar.

**5. Backend: Dependencias Circulares (TS)**

- **S√≠ntomas:** Errores de ciclo de importaci√≥n entre archivos.
- **Soluci√≥n:** Mover definiciones (interfaces, tipos) a archivos independientes e importar desde all√≠.

**6. Backend: API no se conecta a Base de Datos (`PrismaClientInitializationError`)**

- **S√≠ntomas:** Endpoints fallan con 500, logs muestran error de conexi√≥n a DB. Frecuente tras reinicios del sistema.
- **Soluci√≥n:** 1. Verificar que servicio PostgreSQL corre. 2. Verificar `DATABASE_URL` en `.env`. 3. Ejecutar `npx prisma migrate dev` si la BD est√° vac√≠a/corrupta (o `npx prisma migrate reset` en desarrollo).

**7. Frontend: Error 401 al llamar a Rutas P√∫blicas Backend desde `axiosInstance`**

- **Estado:** Resuelto (Backend v1.3.0+).
- **Causa Antigua:** Middleware `authenticateToken` aplicado globalmente a `/api`.
- **Soluci√≥n Aplicada:** Middlewares aplicados individualmente a rutas protegidas en `backend/src/index.ts`. Rutas p√∫blicas (`/api/auth/*`, `/public/*`) no llevan middleware global. Usar `axiosInstance` para `/api/*` (incl. `/api/auth`) y `axios` base para `/public/*`.

**8. Frontend: Formulario Mantine parece vac√≠o tras cargar datos**

- **Estado:** Resuelto (en `TierSettingsPage.tsx`).
- **Causa Antigua:** Llamada incorrecta a `form.reset()` despu√©s de `form.setValues()` en la carga.
- **Soluci√≥n Aplicada:** Eliminar `form.reset()` de la funci√≥n de carga inicial. Usar `form.setValues()` y luego `form.reset()` _despu√©s_ de un guardado exitoso para actualizar valores base y limpiar estado 'dirty'.

**9. Mobile: Esc√°ner QR falla (`setPhotoOptions failed`)**

- **Estado:** Resuelto (Obsoleto).
- **Causa Antigua:** Bug/incompatibilidad en `react-qr-reader`.
- **Soluci√≥n Aplicada:** Reemplazo por `html5-qrcode` y uso del hook `useQrScanner`.

**10. Git: Error `Deletion of directory '...' failed` (Windows)**

- **Causa:** Bloqueo de archivo/carpeta por otro programa.
- **Soluci√≥n:** Cerrar programas -> `git merge --abort` / `git reset --hard HEAD` (si necesario) -> `git pull`.

**11. Testing Backend (Vitest): Test file no se descubre**

- **S√≠ntomas:** Tests en archivo `.ts` no se ejecutan.
- **Causa:** Nombre de archivo no termina en `.test.ts` o `.spec.ts`.
- **Soluci√≥n:** Renombrar archivo correctamente.

**12. Testing Backend (Vitest): Mocking de Prisma falla (`Cannot read properties of undefined`, spy not called)**

- **S√≠ntomas:** Tests unitarios de funciones que usan `new PrismaClient()` internamente fallan al intentar mockear Prisma.
- **Causa:** Instancia interna de Prisma ignora mocks globales (`vi.mock`).
- **Soluci√≥n Aplicada:** **Inyecci√≥n de Dependencias**. 1. Refactorizar funci√≥n/helper para aceptar `prismaClient` como argumento. 2. En el test, crear mock simple y pasarlo como argumento.

**13. Testing Backend (Vitest/TS): Errores TS2352/TS2554 persistentes (Mock vs Type)**

- **S√≠ntomas:** `tsc` se queja de incompatibilidad de tipos entre el mock simple pasado por DI y el tipo esperado (`Pick<PrismaClient,...>`) o de n√∫mero incorrecto de argumentos.
- **Causa:** Discrepancia estructural grande entre mock y tipo real, o TS server cache/resoluci√≥n incorrecta de firmas tras refactor.
- **Soluci√≥n Aplicada:** 1. Asegurar archivo fuente (`.ts`) guardado y compilado (`yarn build`). 2. Reiniciar servidor TS en VS Code. 3. Si persiste, usar `// @ts-expect-error` en la l√≠nea anterior a la llamada dentro del archivo `.test.ts`.

**14. Testing Integraci√≥n (Supertest): Error 401 devuelve `text/plain`, no JSON**

- **S√≠ntomas:** Test que espera 401 por falta de token falla por `Content-Type`.
- **Causa:** Middleware `authenticateToken` usa `res.sendStatus(401)` que responde con `text/plain`.
- **Soluci√≥n:** En esos tests espec√≠ficos, eliminar la aserci√≥n `.expect('Content-Type', /json/)`.

**15. Testing Integraci√≥n (Supertest): Test Login 401 (√âxito esperado)**

- **Causa:** Credenciales hardcodeadas en el test no coinciden con las de la BD de prueba.
- **Soluci√≥n:** Verificar/corregir usuario admin de test en BD. Considerar usar variables de entorno para credenciales de test.

**16. Testing Integraci√≥n (Supertest): Setup Falla - Registro Cliente (DNI Inv√°lido)**

- **Causa:** DNI generado aleatoriamente en `beforeAll` no ten√≠a letra de control v√°lida.
- **Soluci√≥n:** A√±adir funci√≥n helper `generateValidDni()` al test setup para crear DNIs v√°lidos.

**17. Testing Integraci√≥n (Supertest): Ruta `PATCH` devuelve HTML/404**

- **Causa:** Olvido de definir la ruta `router.patch(...)` en el archivo `.routes.ts`.
- **Soluci√≥n:** A√±adir la definici√≥n de la ruta PATCH en el router.

**18. Testing Integraci√≥n (Supertest): Error 500 en lugar de 400 (Validaci√≥n) o 409 (Conflicto)**

- **Causa:** Falta validaci√≥n de entrada en controlador; Error P2002 (Unique Constraint) de Prisma no manejado espec√≠ficamente en el `catch` del controlador.
- **Soluci√≥n:** A√±adir validaciones en controlador; A√±adir `if (error instanceof Error && error.message.includes(...))` espec√≠fico para unicidad en `catch` para devolver 409.

**19. Frontend (i18n): Claves (`loginPage.title`, `desc_REDEEMED`) se muestran en lugar de texto traducido**

- **Causa:** Clave no encontrada en el archivo de idioma (`translation.json`) cargado para el idioma actual (ej: `en`). Puede ser por error tipogr√°fico en la clave (c√≥digo vs JSON), error de sintaxis en el archivo JSON que impide su carga completa, o clave no a√±adida a **todos** los archivos de idioma necesarios.
- **Soluci√≥n:** Verificar coincidencia exacta de claves. Validar sintaxis JSON. Asegurar que la clave existe en los archivos de _todos_ los idiomas soportados (`es`, `en`). Usar `debug: true` en `i18n.ts` y revisar consola por `i18next: missingKey ...`.

**20. Frontend: Banderas de Idioma (Emoji Unicode) no se renderizan**

- **Causa:** Falta de soporte de fuente en el sistema/navegador.
- **Soluci√≥n:** Usar una librer√≠a como `react-country-flag` que utiliza SVG.

**21. Frontend: Navbar M√≥vil Admin no se cierra autom√°ticamente**

- **Causa:** Componente Navbar no ten√≠a acceso a funci√≥n `close`.
- **Soluci√≥n:** Pasar `close` (de `useDisclosure`) como prop desde Layout a Navbar y llamarla en `onClick` del enlace.

**22. PowerShell: Sintaxis para `curl` y JSON**

- **Soluci√≥n:** Usar `Invoke-RestMethod` con par√°metros PowerShell (`-Method`, `-Headers @{}`, `-Body ($obj | ConvertTo-Json -Depth N)`).

**23. Backend: Subida de Im√°genes Cloudinary Falla (Error 500 o 401)**

- **S√≠ntomas:** Error 500/401 desde backend al subir, logs indican `Invalid cloud_name` o `Unknown API key`.
- **Causas:** Credenciales (`.env`) incorrectas/mezcladas, backend no reiniciado tras cambiar `.env`, error lectura `.env`, problema cuenta Cloudinary.
- **Soluci√≥n Aplicada:** Crear cuenta Cloudinary nueva, obtener credenciales nuevas, ponerlas correctamente en `.env` (`CLOUDINARY_CLOUD_NAME`, `_API_KEY`, `_API_SECRET`), reiniciar backend.

**24. Backend/Frontend: Campo Nuevo (ej: `imageUrl`, `name_es`) Se Guarda/Recibe Como `null` o Da Error de Tipo**

- **S√≠ntomas:** Campo nuevo no se guarda en BD, o el frontend da error de tipo (ej: `Property 'name_es' does not exist on type 'Reward'`) al intentar usar datos de la API.
- **Causas:**
  - **Backend:** Controlador no extrae/pasa el campo al servicio; Servicio no incluye campo en `prisma.create/update`; Servicio no incluye campo en `select` al leer; `tsc` no recompil√≥ `dist/`.
  - **Frontend:** Tipo/Interfaz (`types/customer.ts`) no actualizado; Hook que obtiene datos no usa/devuelve el tipo actualizado; Componente que muestra datos usa el nombre de campo antiguo.
- **Soluci√≥n:** Verificar/corregir **toda** la cadena: Controlador (extracci√≥n/paso) -> Servicio (guardado) -> Servicio (lectura `select`) -> Backend Compilaci√≥n (`tsc`) -> Frontend Tipo (`types/customer.ts`) -> Frontend Hook (estado/retorno) -> Frontend Componente (acceso a propiedad correcta, ej: `reward.name_es`).

**25. Mobile: Esc√°ner QR (`html5-qrcode`) No Se Inicia / Error "Element ... not found"**

- **S√≠ntomas:** Al abrir modal de esc√°ner en m√≥vil, la c√°mara no inicia, consola muestra `Element with ID '...' not found`.
- **Causa:** Timing: `useEffect` del hook `useQrScanner` intenta inicializar `Html5Qrcode` antes de que el DOM del modal est√© completamente listo.
- **Soluci√≥n/Workaround Aplicado:** En `useQrScanner.ts`, envolver la inicializaci√≥n (`new Html5Qrcode`, `scannerInstance.start`) dentro de un `setTimeout(() => { ... }, 500)`. Limpiar timeout en cleanup. Corregir tipo de `useRef` para timeout a `number | null`.

**26. Backend: Error TS2307 (`Cannot find module '...'`) Persistente**

- **S√≠ntomas:** `npx tsc` sigue fallando al importar un m√≥dulo (ej: `./uploads.service` desde `uploads.controller`) incluso despu√©s de verificar exportaciones y limpiar `dist`.
- **Causa Probable:** Nombre de archivo incorrecto en el disco (ej: `upload.controller.ts` vs `uploads.controller.ts`); Error interno en el archivo que se intenta importar (`uploads.service.ts`) que impide a `tsc` analizarlo; Problema cach√© `tsc`.
- **Soluci√≥n:** Verificar **exactamente** el nombre del archivo en disco y en la importaci√≥n. Revisar el c√≥digo del archivo importado en busca de errores. Forzar recompilaci√≥n limpia (`rm -rf dist && npx tsc`).

**27. Frontend: Error TS2322 (`Type '... | TFunctionDetailedResult' is not assignable to type 'string'/'ReactNode'`) Persistente**

- **S√≠ntomas:** Error de tipo al asignar el resultado de `t()` (de i18next) a una prop que espera `string` o `ReactNode` (ej: `title` en `Timeline.Item`), incluso despu√©s de intentar conversiones (`String()`, template literals).
- **Causa Probable:** Inferencia de tipos compleja de `t()` con interpolaci√≥n; Problema de tipos espec√≠fico de la versi√≥n de Mantine/i18next/TS; Cach√©/Entorno.
- **Soluci√≥n Aplicada:** Usar aserci√≥n de tipo `as string` (`prop={resultado_t as string}`) o variable intermedia tipada expl√≠citamente (`const titulo: string = String(resultado_t); prop={titulo}`). Si persiste, resetear entorno (`rm -rf node_modules yarn.lock && yarn install`).

**28. Frontend: Error Runtime Mantine (`Tooltip component children should be an element or component that accepts ref...`)**

- **S√≠ntomas:** La aplicaci√≥n falla en runtime al renderizar un `Tooltip`.
- **Causa:** El hijo directo del `Tooltip` no es un elemento/componente v√°lido que acepte `ref` (ej: Fragment `<>...</>`, texto suelto, o componente complejo anidado). A veces relacionado con advertencias de hidrataci√≥n por whitespace.
- **Soluci√≥n:** Asegurar que el hijo directo del `Tooltip` sea un √∫nico elemento v√°lido (ej: `<ActionIcon>`, `<Button>`). Si es necesario, envolver el contenido en un `<Box>`. Limpiar espacios en blanco en JSX de tablas (`Table`, `Thead`, `Tr`, etc.).

---

_(Fin de la Gu√≠a)_



// ====== [10] backend/nodemon.json ======
{
    "watch": ["dist"],
    "ext": "js,json",
    "ignore": [
      "src/",
      "node_modules/",
      "prisma/",
      "tests/",
      ".git/",
      "*.test.ts",
      "*.spec.ts"
    ],
    "exec": "node dist/index.js",
    "delay": "1500ms"
  }


// ====== [11] backend/package-lock.json ======
{
  "name": "backend",
  "version": "1.15.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "backend",
      "version": "1.15.0",
      "license": "SEE LICENSE IN ../LICENSE.md",
      "dependencies": {
        "@nestjs/common": "^11.1.2",
        "@nestjs/core": "^11.1.2",
        "@prisma/client": "^6.6.0",
        "@types/multer": "^1.4.12",
        "@types/node-cron": "^3.0.11",
        "@types/streamifier": "^0.1.2",
        "bcryptjs": "^2.4.3",
        "class-transformer": "^0.5.1",
        "class-validator": "^0.14.2",
        "cloudinary": "^2.6.0",
        "cors": "^2.8.5",
        "date-fns": "^3.6.0",
        "dotenv": "^16.4.5",
        "express": "^4.19.2",
        "jsonwebtoken": "^9.0.2",
        "multer": "^1.4.5-lts.2",
        "node-cron": "^3.0.3",
        "reflect-metadata": "^0.2.2",
        "rxjs": "^7.8.2",
        "streamifier": "^0.1.1",
        "swagger-jsdoc": "^6.2.8",
        "swagger-ui-express": "^5.0.1",
        "uuid": "^10.0.0"
      },
      "devDependencies": {
        "@types/bcryptjs": "^2.4.6",
        "@types/cors": "^2.8.17",
        "@types/date-fns": "^2.6.0",
        "@types/dotenv": "^8.2.0",
        "@types/express": "^4.17.21",
        "@types/jsonwebtoken": "^9.0.6",
        "@types/node": "^20.14.10",
        "@types/supertest": "^6.0.2",
        "@types/swagger-jsdoc": "^6.0.4",
        "@types/swagger-ui-express": "^4.1.8",
        "@types/uuid": "^10.0.0",
        "@vitest/coverage-v8": "^2.0.4",
        "nodemon": "^3.1.4",
        "prisma": "^6.6.0",
        "supertest": "^7.0.0",
        "ts-node": "^10.9.2",
        "ts-node-dev": "^2.0.0",
        "typescript": "^5.5.3",
        "vitest": "^2.0.4"
      }
    },
    "node_modules/@ampproject/remapping": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.3.0.tgz",
      "integrity": "sha512-30iZtAPgz+LTIYoeivqYo853f02jBYSd5uGnGpkFV0M3xOt9aN73erkgYAmZU43x4VfqcnLxW9Kpg3R5LC4YYw==",
      "dev": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@jridgewell/gen-mapping": "^0.3.5",
        "@jridgewell/trace-mapping": "^0.3.24"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@apidevtools/json-schema-ref-parser": {
      "version": "9.1.2",
      "resolved": "https://registry.npmjs.org/@apidevtools/json-schema-ref-parser/-/json-schema-ref-parser-9.1.2.tgz",
      "integrity": "sha512-r1w81DpR+KyRWd3f+rk6TNqMgedmAxZP5v5KWlXQWlgMUUtyEJch0DKEci1SorPMiSeM8XPl7MZ3miJ60JIpQg==",
      "license": "MIT",
      "dependencies": {
        "@jsdevtools/ono": "^7.1.3",
        "@types/json-schema": "^7.0.6",
        "call-me-maybe": "^1.0.1",
        "js-yaml": "^4.1.0"
      }
    },
    "node_modules/@apidevtools/openapi-schemas": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/@apidevtools/openapi-schemas/-/openapi-schemas-2.1.0.tgz",
      "integrity": "sha512-Zc1AlqrJlX3SlpupFGpiLi2EbteyP7fXmUOGup6/DnkRgjP9bgMM/ag+n91rsv0U1Gpz0H3VILA/o3bW7Ua6BQ==",
      "license": "MIT",
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/@apidevtools/swagger-methods": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/@apidevtools/swagger-methods/-/swagger-methods-3.0.2.tgz",
      "integrity": "sha512-QAkD5kK2b1WfjDS/UQn/qQkbwF31uqRjPTrsCs5ZG9BQGAkjwvqGFjjPqAuzac/IYzpPtRzjCP1WrTuAIjMrXg==",
      "license": "MIT"
    },
    "node_modules/@apidevtools/swagger-parser": {
      "version": "10.0.3",
      "resolved": "https://registry.npmjs.org/@apidevtools/swagger-parser/-/swagger-parser-10.0.3.tgz",
      "integrity": "sha512-sNiLY51vZOmSPFZA5TF35KZ2HbgYklQnTSDnkghamzLb3EkNtcQnrBQEj5AOCxHpTtXpqMCRM1CrmV2rG6nw4g==",
      "license": "MIT",
      "dependencies": {
        "@apidevtools/json-schema-ref-parser": "^9.0.6",
        "@apidevtools/openapi-schemas": "^2.0.4",
        "@apidevtools/swagger-methods": "^3.0.2",
        "@jsdevtools/ono": "^7.1.3",
        "call-me-maybe": "^1.0.1",
        "z-schema": "^5.0.1"
      },
      "peerDependencies": {
        "openapi-types": ">=7"
      }
    },
    "node_modules/@babel/helper-string-parser": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-string-parser/-/helper-string-parser-7.27.1.tgz",
      "integrity": "sha512-qMlSxKbpRlAridDExk92nSobyDdpPijUq2DW6oDnUqd0iOGxmQjyqhMIihI9+zv4LPyZdRje2cavWPbCbWm3eA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/helper-validator-identifier": {
      "version": "7.27.1",
      "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.27.1.tgz",
      "integrity": "sha512-D2hP9eA+Sqx1kBZgzxZh0y1trbuU+JoDkiEwqhQ36nodYqJwyEIhPSdMNd7lOm/4io72luTPWH20Yda0xOuUow==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@babel/parser": {
      "version": "7.27.5",
      "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.27.5.tgz",
      "integrity": "sha512-OsQd175SxWkGlzbny8J3K8TnnDD0N3lrIUtB92xwyRpzaenGZhxDvxN/JgU00U3CDZNj9tPuDJ5H0WS4Nt3vKg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/types": "^7.27.3"
      },
      "bin": {
        "parser": "bin/babel-parser.js"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@babel/types": {
      "version": "7.27.6",
      "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.27.6.tgz",
      "integrity": "sha512-ETyHEk2VHHvl9b9jZP5IHPavHYk57EhanlRRuae9XCpb/j5bDCbPPMOBfCWhnl/7EDJz0jEMCi/RhccCE8r1+Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/helper-string-parser": "^7.27.1",
        "@babel/helper-validator-identifier": "^7.27.1"
      },
      "engines": {
        "node": ">=6.9.0"
      }
    },
    "node_modules/@bcoe/v8-coverage": {
      "version": "0.2.3",
      "resolved": "https://registry.npmjs.org/@bcoe/v8-coverage/-/v8-coverage-0.2.3.tgz",
      "integrity": "sha512-0hYQ8SB4Db5zvZB4axdMHGwEaQjkZzFjQiN9LVYvIFB2nSUHW9tYpxWriPrWDASIxiaXax83REcLxuSdnGPZtw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@cspotcode/source-map-support": {
      "version": "0.8.1",
      "resolved": "https://registry.npmjs.org/@cspotcode/source-map-support/-/source-map-support-0.8.1.tgz",
      "integrity": "sha512-IchNf6dN4tHoMFIn/7OE8LWZ19Y6q/67Bmf6vnGREv8RSbBVb9LPJxEcnwrcwX6ixSvaiGoomAUvu4YSxXrVgw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/trace-mapping": "0.3.9"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@cspotcode/source-map-support/node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.9",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.9.tgz",
      "integrity": "sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.0.3",
        "@jridgewell/sourcemap-codec": "^1.4.10"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-x64/-/win32-x64-0.21.5.tgz",
      "integrity": "sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@isaacs/cliui": {
      "version": "8.0.2",
      "resolved": "https://registry.npmjs.org/@isaacs/cliui/-/cliui-8.0.2.tgz",
      "integrity": "sha512-O8jcjabXaleOG9DQ0+ARXWZBTfnP4WNAqzuiJK7ll44AmxGKv/J2M4TPjxjY3znBCfvBXFzucm1twdyFybFqEA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "string-width": "^5.1.2",
        "string-width-cjs": "npm:string-width@^4.2.0",
        "strip-ansi": "^7.0.1",
        "strip-ansi-cjs": "npm:strip-ansi@^6.0.1",
        "wrap-ansi": "^8.1.0",
        "wrap-ansi-cjs": "npm:wrap-ansi@^7.0.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/@isaacs/cliui/node_modules/ansi-regex": {
      "version": "6.1.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.1.0.tgz",
      "integrity": "sha512-7HSX4QQb4CspciLpVFwyRe79O3xsIZDDLER21kERQ71oaPodF8jL725AgJMFAYbooIqolJoRLuM81SpeUkpkvA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
      }
    },
    "node_modules/@isaacs/cliui/node_modules/strip-ansi": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.0.tgz",
      "integrity": "sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^6.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
      }
    },
    "node_modules/@istanbuljs/schema": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/@istanbuljs/schema/-/schema-0.1.3.tgz",
      "integrity": "sha512-ZXRY4jNvVgSVQ8DL3LTcakaAtXwTVUxE81hslsyD2AtoXW/wVob10HkOJ1X/pAlcI7D+2YoZKg5do8G/w6RYgA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@jridgewell/gen-mapping": {
      "version": "0.3.8",
      "resolved": "https://registry.npmjs.org/@jridgewell/gen-mapping/-/gen-mapping-0.3.8.tgz",
      "integrity": "sha512-imAbBGkb+ebQyxKgzv5Hu2nmROxoDOXHh80evxdoXNOrvAnVx7zimzc1Oo5h9RlfV4vPXaE2iM5pOFbvOCClWA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/set-array": "^1.2.1",
        "@jridgewell/sourcemap-codec": "^1.4.10",
        "@jridgewell/trace-mapping": "^0.3.24"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/resolve-uri": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.1.2.tgz",
      "integrity": "sha512-bRISgCIjP20/tbWSPWMEi54QVPRZExkuD9lJL+UIxUKtwVJA8wW1Trb1jMs1RFXo1CBTNZ/5hpC9QvmKWdopKw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/set-array": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/@jridgewell/set-array/-/set-array-1.2.1.tgz",
      "integrity": "sha512-R8gLRTZeyp03ymzP/6Lil/28tGeGEzhx1q2k703KGWRAI1VdvPIXdG70VJc2pAMw3NA6JKL5hhFu1sJX0Mnn/A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.5.0.tgz",
      "integrity": "sha512-gv3ZRaISU3fjPAgNsriBRqGWQL6quFx04YMPW/zD8XMLsU32mhCCbfbO6KZFLjvYpCZ8zyDEgqsgf+PwPaM7GQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@jridgewell/trace-mapping": {
      "version": "0.3.25",
      "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.25.tgz",
      "integrity": "sha512-vNk6aEwybGtawWmy/PzwnGDOjCkLWSD2wqvjGGAgOAwCGWySYXfYoxt00IJkTF+8Lb57DwOb3Aa0o9CApepiYQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/resolve-uri": "^3.1.0",
        "@jridgewell/sourcemap-codec": "^1.4.14"
      }
    },
    "node_modules/@jsdevtools/ono": {
      "version": "7.1.3",
      "resolved": "https://registry.npmjs.org/@jsdevtools/ono/-/ono-7.1.3.tgz",
      "integrity": "sha512-4JQNk+3mVzK3xh2rqd6RB4J46qUR19azEHBneZyTZM+c456qOrbbM/5xcR8huNCCcbVt7+UmizG6GuUvPvKUYg==",
      "license": "MIT"
    },
    "node_modules/@lukeed/csprng": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/@lukeed/csprng/-/csprng-1.1.0.tgz",
      "integrity": "sha512-Z7C/xXCiGWsg0KuKsHTKJxbWhpI3Vs5GwLfOean7MGyVFGqdRgBbAjOCh6u4bbjPc/8MJ2pZmK/0DLdCbivLDA==",
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/@nestjs/common": {
      "version": "11.1.2",
      "resolved": "https://registry.npmjs.org/@nestjs/common/-/common-11.1.2.tgz",
      "integrity": "sha512-cHh4OPH44PjaHM93D1jgE1HO/B7XTZVRDxy/cPuGgyMEA4p2zXO+qqcOgTMC5FYcp7dX9jLeCjXAU0ToFAnODw==",
      "license": "MIT",
      "dependencies": {
        "file-type": "21.0.0",
        "iterare": "1.2.1",
        "load-esm": "1.0.2",
        "tslib": "2.8.1",
        "uid": "2.0.2"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/nest"
      },
      "peerDependencies": {
        "class-transformer": ">=0.4.1",
        "class-validator": ">=0.13.2",
        "reflect-metadata": "^0.1.12 || ^0.2.0",
        "rxjs": "^7.1.0"
      },
      "peerDependenciesMeta": {
        "class-transformer": {
          "optional": true
        },
        "class-validator": {
          "optional": true
        }
      }
    },
    "node_modules/@nestjs/core": {
      "version": "11.1.2",
      "resolved": "https://registry.npmjs.org/@nestjs/core/-/core-11.1.2.tgz",
      "integrity": "sha512-QRuyxwu0BjNfmmmunsw1ylX7RSyfDQHt+xD+tKncdtgiMOOzAu+LA1gB4WoZnw4frQkk+qZbhEbM61cIjOxD3w==",
      "hasInstallScript": true,
      "license": "MIT",
      "dependencies": {
        "@nuxt/opencollective": "0.4.1",
        "fast-safe-stringify": "2.1.1",
        "iterare": "1.2.1",
        "path-to-regexp": "8.2.0",
        "tslib": "2.8.1",
        "uid": "2.0.2"
      },
      "engines": {
        "node": ">= 20"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/nest"
      },
      "peerDependencies": {
        "@nestjs/common": "^11.0.0",
        "@nestjs/microservices": "^11.0.0",
        "@nestjs/platform-express": "^11.0.0",
        "@nestjs/websockets": "^11.0.0",
        "reflect-metadata": "^0.1.12 || ^0.2.0",
        "rxjs": "^7.1.0"
      },
      "peerDependenciesMeta": {
        "@nestjs/microservices": {
          "optional": true
        },
        "@nestjs/platform-express": {
          "optional": true
        },
        "@nestjs/websockets": {
          "optional": true
        }
      }
    },
    "node_modules/@nestjs/core/node_modules/path-to-regexp": {
      "version": "8.2.0",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-8.2.0.tgz",
      "integrity": "sha512-TdrF7fW9Rphjq4RjrW0Kp2AW0Ahwu9sRGTkS6bvDi0SCwZlEZYmcfDbEsTz8RVk0EHIS/Vd1bv3JhG+1xZuAyQ==",
      "license": "MIT",
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/@noble/hashes": {
      "version": "1.8.0",
      "resolved": "https://registry.npmjs.org/@noble/hashes/-/hashes-1.8.0.tgz",
      "integrity": "sha512-jCs9ldd7NwzpgXDIf6P3+NrHh9/sD6CQdxHyjQI+h/6rDNo88ypBxxz45UDuZHz9r3tNz7N/VInSVoVdtXEI4A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^14.21.3 || >=16"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      }
    },
    "node_modules/@nuxt/opencollective": {
      "version": "0.4.1",
      "resolved": "https://registry.npmjs.org/@nuxt/opencollective/-/opencollective-0.4.1.tgz",
      "integrity": "sha512-GXD3wy50qYbxCJ652bDrDzgMr3NFEkIS374+IgFQKkCvk9yiYcLvX2XDYr7UyQxf4wK0e+yqDYRubZ0DtOxnmQ==",
      "license": "MIT",
      "dependencies": {
        "consola": "^3.2.3"
      },
      "bin": {
        "opencollective": "bin/opencollective.js"
      },
      "engines": {
        "node": "^14.18.0 || >=16.10.0",
        "npm": ">=5.10.0"
      }
    },
    "node_modules/@paralleldrive/cuid2": {
      "version": "2.2.2",
      "resolved": "https://registry.npmjs.org/@paralleldrive/cuid2/-/cuid2-2.2.2.tgz",
      "integrity": "sha512-ZOBkgDwEdoYVlSeRbYYXs0S9MejQofiVYoTbKzy/6GQa39/q5tQU2IX46+shYnUkpEl3wc+J6wRlar7r2EK2xA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@noble/hashes": "^1.1.5"
      }
    },
    "node_modules/@pkgjs/parseargs": {
      "version": "0.11.0",
      "resolved": "https://registry.npmjs.org/@pkgjs/parseargs/-/parseargs-0.11.0.tgz",
      "integrity": "sha512-+1VkjdD0QBLPodGrJUeqarH8VAIvQODIbwh9XpP5Syisf7YoQgsJKPNFoqqLQlu+VQ/tVSshMR6loPMn8U+dPg==",
      "dev": true,
      "license": "MIT",
      "optional": true,
      "engines": {
        "node": ">=14"
      }
    },
    "node_modules/@prisma/client": {
      "version": "6.9.0",
      "resolved": "https://registry.npmjs.org/@prisma/client/-/client-6.9.0.tgz",
      "integrity": "sha512-Gg7j1hwy3SgF1KHrh0PZsYvAaykeR0PaxusnLXydehS96voYCGt1U5zVR31NIouYc63hWzidcrir1a7AIyCsNQ==",
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18.18"
      },
      "peerDependencies": {
        "prisma": "*",
        "typescript": ">=5.1.0"
      },
      "peerDependenciesMeta": {
        "prisma": {
          "optional": true
        },
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/@prisma/config": {
      "version": "6.9.0",
      "resolved": "https://registry.npmjs.org/@prisma/config/-/config-6.9.0.tgz",
      "integrity": "sha512-Wcfk8/lN3WRJd5w4jmNQkUwhUw0eksaU/+BlAJwPQKW10k0h0LC9PD/6TQFmqKVbHQL0vG2z266r0S1MPzzhbA==",
      "devOptional": true,
      "license": "Apache-2.0",
      "dependencies": {
        "jiti": "2.4.2"
      }
    },
    "node_modules/@prisma/debug": {
      "version": "6.9.0",
      "resolved": "https://registry.npmjs.org/@prisma/debug/-/debug-6.9.0.tgz",
      "integrity": "sha512-bFeur/qi/Q+Mqk4JdQ3R38upSYPebv5aOyD1RKywVD+rAMLtRkmTFn28ZuTtVOnZHEdtxnNOCH+bPIeSGz1+Fg==",
      "devOptional": true,
      "license": "Apache-2.0"
    },
    "node_modules/@prisma/engines": {
      "version": "6.9.0",
      "resolved": "https://registry.npmjs.org/@prisma/engines/-/engines-6.9.0.tgz",
      "integrity": "sha512-im0X0bwDLA0244CDf8fuvnLuCQcBBdAGgr+ByvGfQY9wWl6EA+kRGwVk8ZIpG65rnlOwtaWIr/ZcEU5pNVvq9g==",
      "devOptional": true,
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.9.0",
        "@prisma/engines-version": "6.9.0-10.81e4af48011447c3cc503a190e86995b66d2a28e",
        "@prisma/fetch-engine": "6.9.0",
        "@prisma/get-platform": "6.9.0"
      }
    },
    "node_modules/@prisma/engines-version": {
      "version": "6.9.0-10.81e4af48011447c3cc503a190e86995b66d2a28e",
      "resolved": "https://registry.npmjs.org/@prisma/engines-version/-/engines-version-6.9.0-10.81e4af48011447c3cc503a190e86995b66d2a28e.tgz",
      "integrity": "sha512-Qp9gMoBHgqhKlrvumZWujmuD7q4DV/gooEyPCLtbkc13EZdSz2RsGUJ5mHb3RJgAbk+dm6XenqG7obJEhXcJ6Q==",
      "devOptional": true,
      "license": "Apache-2.0"
    },
    "node_modules/@prisma/fetch-engine": {
      "version": "6.9.0",
      "resolved": "https://registry.npmjs.org/@prisma/fetch-engine/-/fetch-engine-6.9.0.tgz",
      "integrity": "sha512-PMKhJdl4fOdeE3J3NkcWZ+tf3W6rx3ht/rLU8w4SXFRcLhd5+3VcqY4Kslpdm8osca4ej3gTfB3+cSk5pGxgFg==",
      "devOptional": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.9.0",
        "@prisma/engines-version": "6.9.0-10.81e4af48011447c3cc503a190e86995b66d2a28e",
        "@prisma/get-platform": "6.9.0"
      }
    },
    "node_modules/@prisma/get-platform": {
      "version": "6.9.0",
      "resolved": "https://registry.npmjs.org/@prisma/get-platform/-/get-platform-6.9.0.tgz",
      "integrity": "sha512-/B4n+5V1LI/1JQcHp+sUpyRT1bBgZVPHbsC4lt4/19Xp4jvNIVcq5KYNtQDk5e/ukTSjo9PZVAxxy9ieFtlpTQ==",
      "devOptional": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/debug": "6.9.0"
      }
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.41.1",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-x64-msvc/-/rollup-win32-x64-msvc-4.41.1.tgz",
      "integrity": "sha512-Wq2zpapRYLfi4aKxf2Xff0tN+7slj2d4R87WEzqw7ZLsVvO5zwYCIuEGSZYiK41+GlwUo1HiR+GdkLEJnCKTCw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@scarf/scarf": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/@scarf/scarf/-/scarf-1.4.0.tgz",
      "integrity": "sha512-xxeapPiUXdZAE3che6f3xogoJPeZgig6omHEy1rIY5WVsB3H2BHNnZH+gHG6x91SCWyQCzWGsuL2Hh3ClO5/qQ==",
      "hasInstallScript": true,
      "license": "Apache-2.0"
    },
    "node_modules/@tokenizer/inflate": {
      "version": "0.2.7",
      "resolved": "https://registry.npmjs.org/@tokenizer/inflate/-/inflate-0.2.7.tgz",
      "integrity": "sha512-MADQgmZT1eKjp06jpI2yozxaU9uVs4GzzgSL+uEq7bVcJ9V1ZXQkeGNql1fsSI0gMy1vhvNTNbUqrx+pZfJVmg==",
      "license": "MIT",
      "dependencies": {
        "debug": "^4.4.0",
        "fflate": "^0.8.2",
        "token-types": "^6.0.0"
      },
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/Borewit"
      }
    },
    "node_modules/@tokenizer/token": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/@tokenizer/token/-/token-0.3.0.tgz",
      "integrity": "sha512-OvjF+z51L3ov0OyAU0duzsYuvO01PH7x4t6DJx+guahgTnBHkhJdG7soQeTSFLWN3efnHyibZ4Z8l2EuWwJN3A==",
      "license": "MIT"
    },
    "node_modules/@tsconfig/node10": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node10/-/node10-1.0.11.tgz",
      "integrity": "sha512-DcRjDCujK/kCk/cUe8Xz8ZSpm8mS3mNNpta+jGCA6USEDfktlNvm1+IuZ9eTcDbNk41BHwpHHeW+N1lKCz4zOw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node12": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/@tsconfig/node12/-/node12-1.0.11.tgz",
      "integrity": "sha512-cqefuRsh12pWyGsIoBKJA9luFu3mRxCA+ORZvA4ktLSzIuCUtWVxGIuXigEwO5/ywWFMZ2QEGKWvkZG1zDMTag==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node14": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/@tsconfig/node14/-/node14-1.0.3.tgz",
      "integrity": "sha512-ysT8mhdixWK6Hw3i1V2AeRqZ5WfXg1G43mqoYlM2nc6388Fq5jcXyr5mRsqViLx/GJYdoL0bfXD8nmF+Zn/Iow==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@tsconfig/node16": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/@tsconfig/node16/-/node16-1.0.4.tgz",
      "integrity": "sha512-vxhUy4J8lyeyinH7Azl1pdd43GJhZH/tP2weN8TntQblOY+A0XbT8DJk1/oCPuOOyg/Ja757rG0CgHcWC8OfMA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/bcryptjs": {
      "version": "2.4.6",
      "resolved": "https://registry.npmjs.org/@types/bcryptjs/-/bcryptjs-2.4.6.tgz",
      "integrity": "sha512-9xlo6R2qDs5uixm0bcIqCeMCE6HiQsIyel9KQySStiyqNl2tnj2mP3DX1Nf56MD6KMenNNlBBsy3LJ7gUEQPXQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/body-parser": {
      "version": "1.19.5",
      "resolved": "https://registry.npmjs.org/@types/body-parser/-/body-parser-1.19.5.tgz",
      "integrity": "sha512-fB3Zu92ucau0iQ0JMCFQE7b/dv8Ot07NI3KaZIkIUNXq82k4eBAqUaneXfleGY9JWskeS9y+u0nXMyspcuQrCg==",
      "license": "MIT",
      "dependencies": {
        "@types/connect": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/body-parser/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/body-parser/node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "license": "MIT"
    },
    "node_modules/@types/connect": {
      "version": "3.4.38",
      "resolved": "https://registry.npmjs.org/@types/connect/-/connect-3.4.38.tgz",
      "integrity": "sha512-K6uROf1LD88uDQqJCktA4yzL1YYAK6NgfsI0v/mTgyPKWsX1CnJ0XPSDhViejru1GcRkLWb8RlzFYJRqGUbaug==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/connect/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/connect/node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "license": "MIT"
    },
    "node_modules/@types/cookiejar": {
      "version": "2.1.5",
      "resolved": "https://registry.npmjs.org/@types/cookiejar/-/cookiejar-2.1.5.tgz",
      "integrity": "sha512-he+DHOWReW0nghN24E1WUqM0efK4kI9oTqDm6XmK8ZPe2djZ90BSNdGnIyCLzCPw7/pogPlGbzI2wHGGmi4O/Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/cors": {
      "version": "2.8.18",
      "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.18.tgz",
      "integrity": "sha512-nX3d0sxJW41CqQvfOzVG1NCTXfFDrDWIghCZncpHeWlVFd81zxB/DLhg7avFg6eHLCRX7ckBmoIIcqa++upvJA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/cors/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/cors/node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/date-fns": {
      "version": "2.6.3",
      "resolved": "https://registry.npmjs.org/@types/date-fns/-/date-fns-2.6.3.tgz",
      "integrity": "sha512-Ke1lw2Ni1t/wMUoLtKFmSNCLozcTBd6vmMqFP4hRzXn6qzkNt97bPAX0x5Y/c15DP43kKvwW1ycStD5+43jVQA==",
      "deprecated": "This is a stub types definition. date-fns provides its own type definitions, so you do not need this installed.",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "date-fns": "*"
      }
    },
    "node_modules/@types/date-fns/node_modules/date-fns": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/date-fns/-/date-fns-4.1.0.tgz",
      "integrity": "sha512-Ukq0owbQXxa/U3EGtsdVBkR1w7KOQ5gIBqdH2hkvknzZPYvBxb/aa6E8L7tmjFtkwZBu3UXBbjIgPo/Ez4xaNg==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/kossnocorp"
      }
    },
    "node_modules/@types/dotenv": {
      "version": "8.2.3",
      "resolved": "https://registry.npmjs.org/@types/dotenv/-/dotenv-8.2.3.tgz",
      "integrity": "sha512-g2FXjlDX/cYuc5CiQvyU/6kkbP1JtmGzh0obW50zD7OKeILVL0NSpPWLXVfqoAGQjom2/SLLx9zHq0KXvD6mbw==",
      "deprecated": "This is a stub types definition. dotenv provides its own type definitions, so you do not need this installed.",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "dotenv": "*"
      }
    },
    "node_modules/@types/estree": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/@types/estree/-/estree-1.0.7.tgz",
      "integrity": "sha512-w28IoSUCJpidD/TGviZwwMJckNESJZXFu7NBZ5YJ4mEUnNraUn9Pm8HSZm/jDF1pDWYKspWE7oVphigUPRakIQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/express": {
      "version": "4.17.22",
      "resolved": "https://registry.npmjs.org/@types/express/-/express-4.17.22.tgz",
      "integrity": "sha512-eZUmSnhRX9YRSkplpz0N+k6NljUUn5l3EWZIKZvYzhvMphEuNiyyy1viH/ejgt66JWgALwC/gtSUAeQKtSwW/w==",
      "license": "MIT",
      "dependencies": {
        "@types/body-parser": "*",
        "@types/express-serve-static-core": "^4.17.33",
        "@types/qs": "*",
        "@types/serve-static": "*"
      }
    },
    "node_modules/@types/express-serve-static-core": {
      "version": "4.19.6",
      "resolved": "https://registry.npmjs.org/@types/express-serve-static-core/-/express-serve-static-core-4.19.6.tgz",
      "integrity": "sha512-N4LZ2xG7DatVqhCZzOGb1Yi5lMbXSZcmdLDe9EzSndPV2HpWYWzRbaerl2n27irrm94EPpprqa8KpskPT085+A==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "*",
        "@types/qs": "*",
        "@types/range-parser": "*",
        "@types/send": "*"
      }
    },
    "node_modules/@types/express-serve-static-core/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/express-serve-static-core/node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "license": "MIT"
    },
    "node_modules/@types/http-errors": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/@types/http-errors/-/http-errors-2.0.4.tgz",
      "integrity": "sha512-D0CFMMtydbJAegzOyHjtiKPLlvnm3iTZyZRSZoLq2mRhDdmLfIWOCYPfQJ4cu2erKghU++QvjcUjp/5h7hESpA==",
      "license": "MIT"
    },
    "node_modules/@types/json-schema": {
      "version": "7.0.15",
      "resolved": "https://registry.npmjs.org/@types/json-schema/-/json-schema-7.0.15.tgz",
      "integrity": "sha512-5+fP8P8MFNC+AyZCDxrB2pkZFPGzqQWUzpSeuuVLvm8VMcorNYavBqoFcxK8bQz4Qsbn4oUEEem4wDLfcysGHA==",
      "license": "MIT"
    },
    "node_modules/@types/jsonwebtoken": {
      "version": "9.0.9",
      "resolved": "https://registry.npmjs.org/@types/jsonwebtoken/-/jsonwebtoken-9.0.9.tgz",
      "integrity": "sha512-uoe+GxEuHbvy12OUQct2X9JenKM3qAscquYymuQN4fMWG9DBQtykrQEFcAbVACF7qaLw9BePSodUL0kquqBJpQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/ms": "*",
        "@types/node": "*"
      }
    },
    "node_modules/@types/jsonwebtoken/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/jsonwebtoken/node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/methods": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/@types/methods/-/methods-1.1.4.tgz",
      "integrity": "sha512-ymXWVrDiCxTBE3+RIrrP533E70eA+9qu7zdWoHuOmGujkYtzf4HQF96b8nwHLqhuf4ykX61IGRIB38CC6/sImQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/mime": {
      "version": "1.3.5",
      "resolved": "https://registry.npmjs.org/@types/mime/-/mime-1.3.5.tgz",
      "integrity": "sha512-/pyBZWSLD2n0dcHE3hq8s8ZvcETHtEuF+3E7XVt0Ig2nvsVQXdghHVcEkIWjy9A0wKfTn97a/PSDYohKIlnP/w==",
      "license": "MIT"
    },
    "node_modules/@types/ms": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/@types/ms/-/ms-2.1.0.tgz",
      "integrity": "sha512-GsCCIZDE/p3i96vtEqx+7dBUGXrc7zeSK3wwPHIaRThS+9OhWIXRqzs4d6k1SVU8g91DrNRWxWUGhp5KXQb2VA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/multer": {
      "version": "1.4.12",
      "resolved": "https://registry.npmjs.org/@types/multer/-/multer-1.4.12.tgz",
      "integrity": "sha512-pQ2hoqvXiJt2FP9WQVLPRO+AmiIm/ZYkavPlIQnx282u4ZrVdztx0pkh3jjpQt0Kz+YI0YhSG264y08UJKoUQg==",
      "license": "MIT",
      "dependencies": {
        "@types/express": "*"
      }
    },
    "node_modules/@types/node": {
      "version": "20.17.57",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-20.17.57.tgz",
      "integrity": "sha512-f3T4y6VU4fVQDKVqJV4Uppy8c1p/sVvS3peyqxyWnzkqXFJLRU7Y1Bl7rMS1Qe9z0v4M6McY0Fp9yBsgHJUsWQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.19.2"
      }
    },
    "node_modules/@types/node-cron": {
      "version": "3.0.11",
      "resolved": "https://registry.npmjs.org/@types/node-cron/-/node-cron-3.0.11.tgz",
      "integrity": "sha512-0ikrnug3/IyneSHqCBeslAhlK2aBfYek1fGo4bP4QnZPmiqSGRK+Oy7ZMisLWkesffJvQ1cqAcBnJC+8+nxIAg==",
      "license": "MIT"
    },
    "node_modules/@types/qs": {
      "version": "6.14.0",
      "resolved": "https://registry.npmjs.org/@types/qs/-/qs-6.14.0.tgz",
      "integrity": "sha512-eOunJqu0K1923aExK6y8p6fsihYEn/BYuQ4g0CxAAgFc4b/ZLN4CrsRZ55srTdqoiLzU2B2evC+apEIxprEzkQ==",
      "license": "MIT"
    },
    "node_modules/@types/range-parser": {
      "version": "1.2.7",
      "resolved": "https://registry.npmjs.org/@types/range-parser/-/range-parser-1.2.7.tgz",
      "integrity": "sha512-hKormJbkJqzQGhziax5PItDUTMAM9uE2XXQmM37dyd4hVM+5aVl7oVxMVUiVQn2oCQFN/LKCZdvSM0pFRqbSmQ==",
      "license": "MIT"
    },
    "node_modules/@types/send": {
      "version": "0.17.4",
      "resolved": "https://registry.npmjs.org/@types/send/-/send-0.17.4.tgz",
      "integrity": "sha512-x2EM6TJOybec7c52BX0ZspPodMsQUd5L6PRwOunVyVUhXiBSKf3AezDL8Dgvgt5o0UfKNfuA0eMLr2wLT4AiBA==",
      "license": "MIT",
      "dependencies": {
        "@types/mime": "^1",
        "@types/node": "*"
      }
    },
    "node_modules/@types/send/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/send/node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "license": "MIT"
    },
    "node_modules/@types/serve-static": {
      "version": "1.15.7",
      "resolved": "https://registry.npmjs.org/@types/serve-static/-/serve-static-1.15.7.tgz",
      "integrity": "sha512-W8Ym+h8nhuRwaKPaDw34QUkwsGi6Rc4yYqvKFo5rm2FUEhCFbzVWrxXUxuKK8TASjWsysJY0nsmNCGhCOIsrOw==",
      "license": "MIT",
      "dependencies": {
        "@types/http-errors": "*",
        "@types/node": "*",
        "@types/send": "*"
      }
    },
    "node_modules/@types/serve-static/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/serve-static/node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "license": "MIT"
    },
    "node_modules/@types/streamifier": {
      "version": "0.1.2",
      "resolved": "https://registry.npmjs.org/@types/streamifier/-/streamifier-0.1.2.tgz",
      "integrity": "sha512-W53GwxY5Tunz3JUoP1YWDidrAadenSZKOBKMRl6RO3yThOFd03w7yx3HypI8ABGuUCGDHCHUml/5e45FWRt1TQ==",
      "license": "MIT",
      "dependencies": {
        "@types/node": "*"
      }
    },
    "node_modules/@types/streamifier/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/streamifier/node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "license": "MIT"
    },
    "node_modules/@types/strip-bom": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/@types/strip-bom/-/strip-bom-3.0.0.tgz",
      "integrity": "sha512-xevGOReSYGM7g/kUBZzPqCrR/KYAo+F0yiPc85WFTJa0MSLtyFTVTU6cJu/aV4mid7IffDIWqo69THF2o4JiEQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/strip-json-comments": {
      "version": "0.0.30",
      "resolved": "https://registry.npmjs.org/@types/strip-json-comments/-/strip-json-comments-0.0.30.tgz",
      "integrity": "sha512-7NQmHra/JILCd1QqpSzl8+mJRc8ZHz3uDm8YV1Ks9IhK0epEiTw8aIErbvH9PI+6XbqhyIQy3462nEsn7UVzjQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/superagent": {
      "version": "8.1.9",
      "resolved": "https://registry.npmjs.org/@types/superagent/-/superagent-8.1.9.tgz",
      "integrity": "sha512-pTVjI73witn+9ILmoJdajHGW2jkSaOzhiFYF1Rd3EQ94kymLqB9PjD9ISg7WaALC7+dCHT0FGe9T2LktLq/3GQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/cookiejar": "^2.1.5",
        "@types/methods": "^1.1.4",
        "@types/node": "*",
        "form-data": "^4.0.0"
      }
    },
    "node_modules/@types/superagent/node_modules/@types/node": {
      "version": "22.15.29",
      "resolved": "https://registry.npmjs.org/@types/node/-/node-22.15.29.tgz",
      "integrity": "sha512-LNdjOkUDlU1RZb8e1kOIUpN1qQUlzGkEtbVNo53vbrwDg5om6oduhm4SiUaPW5ASTXhAiP0jInWG8Qx9fVlOeQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@types/superagent/node_modules/undici-types": {
      "version": "6.21.0",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.21.0.tgz",
      "integrity": "sha512-iwDZqg0QAGrg9Rav5H4n0M64c3mkR59cJ6wQp+7C4nI0gsmExaedaYLNO44eT4AtBBwjbTiGPMlt2Md0T9H9JQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/supertest": {
      "version": "6.0.3",
      "resolved": "https://registry.npmjs.org/@types/supertest/-/supertest-6.0.3.tgz",
      "integrity": "sha512-8WzXq62EXFhJ7QsH3Ocb/iKQ/Ty9ZVWnVzoTKc9tyyFRRF3a74Tk2+TLFgaFFw364Ere+npzHKEJ6ga2LzIL7w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/methods": "^1.1.4",
        "@types/superagent": "^8.1.0"
      }
    },
    "node_modules/@types/swagger-jsdoc": {
      "version": "6.0.4",
      "resolved": "https://registry.npmjs.org/@types/swagger-jsdoc/-/swagger-jsdoc-6.0.4.tgz",
      "integrity": "sha512-W+Xw5epcOZrF/AooUM/PccNMSAFOKWZA5dasNyMujTwsBkU74njSJBpvCCJhHAJ95XRMzQrrW844Btu0uoetwQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/swagger-ui-express": {
      "version": "4.1.8",
      "resolved": "https://registry.npmjs.org/@types/swagger-ui-express/-/swagger-ui-express-4.1.8.tgz",
      "integrity": "sha512-AhZV8/EIreHFmBV5wAs0gzJUNq9JbbSXgJLQubCC0jtIo6prnI9MIRRxnU4MZX9RB9yXxF1V4R7jtLl/Wcj31g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/express": "*",
        "@types/serve-static": "*"
      }
    },
    "node_modules/@types/uuid": {
      "version": "10.0.0",
      "resolved": "https://registry.npmjs.org/@types/uuid/-/uuid-10.0.0.tgz",
      "integrity": "sha512-7gqG38EyHgyP1S+7+xomFtL+ZNHcKv6DwNaCZmJmo1vgMugyF3TCnXVg4t1uk89mLNwnLtnY3TpOpCOyp1/xHQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/validator": {
      "version": "13.15.1",
      "resolved": "https://registry.npmjs.org/@types/validator/-/validator-13.15.1.tgz",
      "integrity": "sha512-9gG6ogYcoI2mCMLdcO0NYI0AYrbxIjv0MDmy/5Ywo6CpWWrqYayc+mmgxRsCgtcGJm9BSbXkMsmxGah1iGHAAQ==",
      "license": "MIT"
    },
    "node_modules/@vitest/coverage-v8": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/coverage-v8/-/coverage-v8-2.1.9.tgz",
      "integrity": "sha512-Z2cOr0ksM00MpEfyVE8KXIYPEcBFxdbLSs56L8PO0QQMxt/6bDj45uQfxoc96v05KW3clk7vvgP0qfDit9DmfQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@ampproject/remapping": "^2.3.0",
        "@bcoe/v8-coverage": "^0.2.3",
        "debug": "^4.3.7",
        "istanbul-lib-coverage": "^3.2.2",
        "istanbul-lib-report": "^3.0.1",
        "istanbul-lib-source-maps": "^5.0.6",
        "istanbul-reports": "^3.1.7",
        "magic-string": "^0.30.12",
        "magicast": "^0.3.5",
        "std-env": "^3.8.0",
        "test-exclude": "^7.0.1",
        "tinyrainbow": "^1.2.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "@vitest/browser": "2.1.9",
        "vitest": "2.1.9"
      },
      "peerDependenciesMeta": {
        "@vitest/browser": {
          "optional": true
        }
      }
    },
    "node_modules/@vitest/expect": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/expect/-/expect-2.1.9.tgz",
      "integrity": "sha512-UJCIkTBenHeKT1TTlKMJWy1laZewsRIzYighyYiJKZreqtdxSos/S1t+ktRMQWu2CKqaarrkeszJx1cgC5tGZw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/spy": "2.1.9",
        "@vitest/utils": "2.1.9",
        "chai": "^5.1.2",
        "tinyrainbow": "^1.2.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/mocker": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/mocker/-/mocker-2.1.9.tgz",
      "integrity": "sha512-tVL6uJgoUdi6icpxmdrn5YNo3g3Dxv+IHJBr0GXHaEdTcw3F+cPKnsXFhli6nO+f/6SDKPHEK1UN+k+TQv0Ehg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/spy": "2.1.9",
        "estree-walker": "^3.0.3",
        "magic-string": "^0.30.12"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "msw": "^2.4.9",
        "vite": "^5.0.0"
      },
      "peerDependenciesMeta": {
        "msw": {
          "optional": true
        },
        "vite": {
          "optional": true
        }
      }
    },
    "node_modules/@vitest/pretty-format": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/pretty-format/-/pretty-format-2.1.9.tgz",
      "integrity": "sha512-KhRIdGV2U9HOUzxfiHmY8IFHTdqtOhIzCpd8WRdJiE7D/HUcZVD0EgQCVjm+Q9gkUXWgBvMmTtZgIG48wq7sOQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tinyrainbow": "^1.2.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/runner": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/runner/-/runner-2.1.9.tgz",
      "integrity": "sha512-ZXSSqTFIrzduD63btIfEyOmNcBmQvgOVsPNPe0jYtESiXkhd8u2erDLnMxmGrDCwHCCHE7hxwRDCT3pt0esT4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/utils": "2.1.9",
        "pathe": "^1.1.2"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/snapshot": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/snapshot/-/snapshot-2.1.9.tgz",
      "integrity": "sha512-oBO82rEjsxLNJincVhLhaxxZdEtV0EFHMK5Kmx5sJ6H9L183dHECjiefOAdnqpIgT5eZwT04PoggUnW88vOBNQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/pretty-format": "2.1.9",
        "magic-string": "^0.30.12",
        "pathe": "^1.1.2"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/spy": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/spy/-/spy-2.1.9.tgz",
      "integrity": "sha512-E1B35FwzXXTs9FHNK6bDszs7mtydNi5MIfUWpceJ8Xbfb1gBMscAnwLbEu+B44ed6W3XjL9/ehLPHR1fkf1KLQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tinyspy": "^3.0.2"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/utils": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/@vitest/utils/-/utils-2.1.9.tgz",
      "integrity": "sha512-v0psaMSkNJ3A2NMrUEHFRzJtDPFn+/VWZ5WxImB21T9fjucJRmS7xCS3ppEnARb9y11OAzaD+P2Ps+b+BGX5iQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/pretty-format": "2.1.9",
        "loupe": "^3.1.2",
        "tinyrainbow": "^1.2.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/accepts": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
      "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
      "license": "MIT",
      "dependencies": {
        "mime-types": "~2.1.34",
        "negotiator": "0.6.3"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/acorn": {
      "version": "8.14.1",
      "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.14.1.tgz",
      "integrity": "sha512-OvQ/2pUDKmgfCg++xsTX1wGxfTaszcHVcTctW4UJB4hibJx2HXxxO5UmVgyjMa+ZDsiaf5wWLXYpRWMmBI0QHg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "acorn": "bin/acorn"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/acorn-walk": {
      "version": "8.3.4",
      "resolved": "https://registry.npmjs.org/acorn-walk/-/acorn-walk-8.3.4.tgz",
      "integrity": "sha512-ueEepnujpqee2o5aIYnvHU6C0A42MNdsIDeqy5BydrkuC5R1ZuUFnm27EeFJGoEHJQgn3uleRvmTXaJgfXbt4g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "acorn": "^8.11.0"
      },
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/ansi-regex": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
      "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/ansi-styles": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
      "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-convert": "^2.0.1"
      },
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/append-field": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/append-field/-/append-field-1.0.0.tgz",
      "integrity": "sha512-klpgFSWLW1ZEs8svjfb7g4qWY0YS5imI82dTg+QahUvJ8YqAY0P10Uk8tTyh9ZGuYEZEMaeJYCF5BFuX552hsw==",
      "license": "MIT"
    },
    "node_modules/arg": {
      "version": "4.1.3",
      "resolved": "https://registry.npmjs.org/arg/-/arg-4.1.3.tgz",
      "integrity": "sha512-58S9QDqG0Xx27YwPSt9fJxivjYl432YCwfDMfZ+71RAqUrZef7LrKQZ3LHLOwCS4FLNBplP533Zx895SeOCHvA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/argparse": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
      "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
      "license": "Python-2.0"
    },
    "node_modules/array-flatten": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
      "integrity": "sha512-PCVAQswWemu6UdxsDFFX/+gVeYqKAod3D3UVm91jHwynguOwAvYPhx8nNlM++NqRcK6CxxpUafjmhIdKiHibqg==",
      "license": "MIT"
    },
    "node_modules/asap": {
      "version": "2.0.6",
      "resolved": "https://registry.npmjs.org/asap/-/asap-2.0.6.tgz",
      "integrity": "sha512-BSHWgDSAiKs50o2Re8ppvp3seVHXSRM44cdSsT9FfNEUUZLOGWVCsiWaRPWM1Znn+mqZ1OfVZ3z3DWEzSp7hRA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/assertion-error": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/assertion-error/-/assertion-error-2.0.1.tgz",
      "integrity": "sha512-Izi8RQcffqCeNVgFigKli1ssklIbpHnCYc6AknXGYoB6grJqyeby7jv12JUQgmTAnIDnbck1uxksT4dzN3PWBA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/asynckit": {
      "version": "0.4.0",
      "resolved": "https://registry.npmjs.org/asynckit/-/asynckit-0.4.0.tgz",
      "integrity": "sha512-Oei9OH4tRh0YqU3GxhX79dM/mwVgvbZJaSNaRk+bshkj0S5cfHcgYakreBjrHwatXKbz+IoIdYLxrKim2MjW0Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "license": "MIT"
    },
    "node_modules/bcryptjs": {
      "version": "2.4.3",
      "resolved": "https://registry.npmjs.org/bcryptjs/-/bcryptjs-2.4.3.tgz",
      "integrity": "sha512-V/Hy/X9Vt7f3BbPJEi8BdVFMByHi+jNXrYkW3huaybV/kQ0KJg0Y6PkEMbn+zeT+i+SiKZ/HMqJGIIt4LZDqNQ==",
      "license": "MIT"
    },
    "node_modules/binary-extensions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
      "integrity": "sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/body-parser": {
      "version": "1.20.3",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.3.tgz",
      "integrity": "sha512-7rAxByjUMqQ3/bHJy7D6OGXvx/MMc4IqBn/X0fcM1QUcAItpZrBEYhWGem+tzXH90c+G01ypMcYJBO9Y30203g==",
      "license": "MIT",
      "dependencies": {
        "bytes": "3.1.2",
        "content-type": "~1.0.5",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "on-finished": "2.4.1",
        "qs": "6.13.0",
        "raw-body": "2.5.2",
        "type-is": "~1.6.18",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/body-parser/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "license": "MIT",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/body-parser/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "license": "MIT"
    },
    "node_modules/brace-expansion": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/buffer-equal-constant-time": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/buffer-equal-constant-time/-/buffer-equal-constant-time-1.0.1.tgz",
      "integrity": "sha512-zRpUiDwd/xk6ADqPMATG8vc9VPrkck7T07OIx0gnjmJAnHnTVXNQG3vfvWNuiZIkwu9KrKdA1iJKfsfTVxE6NA==",
      "license": "BSD-3-Clause"
    },
    "node_modules/buffer-from": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz",
      "integrity": "sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==",
      "license": "MIT"
    },
    "node_modules/busboy": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/busboy/-/busboy-1.6.0.tgz",
      "integrity": "sha512-8SFQbg/0hQ9xy3UNTB0YEnsNBbWfhf7RtnzpL7TkBiTBRfrQ9Fxcnz7VJsleJpyp6rVLvXiuORqjlHi5q+PYuA==",
      "dependencies": {
        "streamsearch": "^1.1.0"
      },
      "engines": {
        "node": ">=10.16.0"
      }
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/cac": {
      "version": "6.7.14",
      "resolved": "https://registry.npmjs.org/cac/-/cac-6.7.14.tgz",
      "integrity": "sha512-b6Ilus+c3RrdDk+JhLKUAQfzzgLEPy6wcXqS7f/xe1EETvsDP6GORG7SFuOs6cID5YkqchW/LXZbX5bc8j7ZcQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/call-me-maybe": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-me-maybe/-/call-me-maybe-1.0.2.tgz",
      "integrity": "sha512-HpX65o1Hnr9HH25ojC1YGs7HCQLq0GCOibSaWER0eNpgJ/Z1MZv2mTc7+xh6WOPxbRVcmgbv4hGU+uSQ/2xFZQ==",
      "license": "MIT"
    },
    "node_modules/chai": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/chai/-/chai-5.2.0.tgz",
      "integrity": "sha512-mCuXncKXk5iCLhfhwTc0izo0gtEmpz5CtG2y8GiOINBlMVS6v8TMRc5TaLWKS6692m9+dVVfzgeVxR5UxWHTYw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "assertion-error": "^2.0.1",
        "check-error": "^2.1.1",
        "deep-eql": "^5.0.1",
        "loupe": "^3.1.0",
        "pathval": "^2.0.0"
      },
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/check-error": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/check-error/-/check-error-2.1.1.tgz",
      "integrity": "sha512-OAlb+T7V4Op9OwdkjmguYRqncdlx5JiofwOAUkmTF+jNdHwzTaTs4sRAGpzLF3oOz5xAyDGrPgeIDFQmDOTiJw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 16"
      }
    },
    "node_modules/chokidar": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.6.0.tgz",
      "integrity": "sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      },
      "engines": {
        "node": ">= 8.10.0"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/class-transformer": {
      "version": "0.5.1",
      "resolved": "https://registry.npmjs.org/class-transformer/-/class-transformer-0.5.1.tgz",
      "integrity": "sha512-SQa1Ws6hUbfC98vKGxZH3KFY0Y1lm5Zm0SY8XX9zbK7FJCyVEac3ATW0RIpwzW+oOfmHE5PMPufDG9hCfoEOMw==",
      "license": "MIT"
    },
    "node_modules/class-validator": {
      "version": "0.14.2",
      "resolved": "https://registry.npmjs.org/class-validator/-/class-validator-0.14.2.tgz",
      "integrity": "sha512-3kMVRF2io8N8pY1IFIXlho9r8IPUUIfHe2hYVtiebvAzU2XeQFXTv+XI4WX+TnXmtwXMDcjngcpkiPM0O9PvLw==",
      "license": "MIT",
      "dependencies": {
        "@types/validator": "^13.11.8",
        "libphonenumber-js": "^1.11.1",
        "validator": "^13.9.0"
      }
    },
    "node_modules/cloudinary": {
      "version": "2.6.1",
      "resolved": "https://registry.npmjs.org/cloudinary/-/cloudinary-2.6.1.tgz",
      "integrity": "sha512-Dt7o3p4VzxYoTi+EqWkVQmGy6WiXIyMcG5Gbr9kPR/EQ+jZa+3FFzlDKfDx1uDsaB1aTR1gYeO6wZqrgLFaByQ==",
      "license": "MIT",
      "dependencies": {
        "lodash": "^4.17.21",
        "q": "^1.5.1"
      },
      "engines": {
        "node": ">=9"
      }
    },
    "node_modules/color-convert": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
      "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "color-name": "~1.1.4"
      },
      "engines": {
        "node": ">=7.0.0"
      }
    },
    "node_modules/color-name": {
      "version": "1.1.4",
      "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
      "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/combined-stream": {
      "version": "1.0.8",
      "resolved": "https://registry.npmjs.org/combined-stream/-/combined-stream-1.0.8.tgz",
      "integrity": "sha512-FQN4MRfuJeHf7cBbBMJFXhKSDq+2kAArBlmRBvcvFE5BB1HZKXtSFASDhdlz9zOYwxh8lDdnvmMOe/+5cdoEdg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "delayed-stream": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/commander": {
      "version": "6.2.0",
      "resolved": "https://registry.npmjs.org/commander/-/commander-6.2.0.tgz",
      "integrity": "sha512-zP4jEKbe8SHzKJYQmq8Y9gYjtO/POJLgIdKgV7B9qNmABVFVc+ctqSX6iXh4mCpJfRBOabiZ2YKPg8ciDw6C+Q==",
      "license": "MIT",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/component-emitter": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/component-emitter/-/component-emitter-1.3.1.tgz",
      "integrity": "sha512-T0+barUSQRTUQASh8bx02dl+DhF54GtIDY13Y3m9oWTklKbb3Wv974meRpeZ3lp1JpLVECWWNHC4vaG2XHXouQ==",
      "dev": true,
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "license": "MIT"
    },
    "node_modules/concat-stream": {
      "version": "1.6.2",
      "resolved": "https://registry.npmjs.org/concat-stream/-/concat-stream-1.6.2.tgz",
      "integrity": "sha512-27HBghJxjiZtIk3Ycvn/4kbJk/1uZuJFfuPEns6LaEvpvG1f0hTea8lilrouyo9mVc2GWdcEZ8OLoGmSADlrCw==",
      "engines": [
        "node >= 0.8"
      ],
      "license": "MIT",
      "dependencies": {
        "buffer-from": "^1.0.0",
        "inherits": "^2.0.3",
        "readable-stream": "^2.2.2",
        "typedarray": "^0.0.6"
      }
    },
    "node_modules/consola": {
      "version": "3.4.2",
      "resolved": "https://registry.npmjs.org/consola/-/consola-3.4.2.tgz",
      "integrity": "sha512-5IKcdX0nnYavi6G7TtOhwkYzyjfJlatbjMjuLSfE2kYT5pMDOilZ4OvMhi637CcDICTmz3wARPoyhqyX1Y+XvA==",
      "license": "MIT",
      "engines": {
        "node": "^14.18.0 || >=16.10.0"
      }
    },
    "node_modules/content-disposition": {
      "version": "0.5.4",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.4.tgz",
      "integrity": "sha512-FveZTNuGw04cxlAiWbzi6zTAL/lhehaWbTtgluJh4/E95DqMwTmha3KZN1aAWA8cFIhHzMZUvLevkw5Rqk+tSQ==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "5.2.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.7.1",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.1.tgz",
      "integrity": "sha512-6DnInpx7SJ2AK3+CTUE/ZM0vWTUboZCegxhC2xiIydHR9jNuTAASBrfEpHhiGOZw/nX51bHt6YQl8jsGo4y/0w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.6.tgz",
      "integrity": "sha512-QADzlaHc8icV8I7vbaJXJwod9HWYp8uCqf1xa4OfNu1T7JVxQIrUgOWtHdNDtPiywmFbiS12VjotIXLrKM3orQ==",
      "license": "MIT"
    },
    "node_modules/cookiejar": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/cookiejar/-/cookiejar-2.1.4.tgz",
      "integrity": "sha512-LDx6oHrK+PhzLKJU9j5S7/Y3jM/mUHvD/DeI1WQmJn652iPC5Y4TBzC9l+5OMOXlyTTA+SmVUPm0HQUwpD5Jqw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/core-util-is": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/core-util-is/-/core-util-is-1.0.3.tgz",
      "integrity": "sha512-ZQBvi1DcpJ4GDqanjucZ2Hj3wEO5pZDS89BWbkcrvdxksJorwUDDZamX9ldFkp9aw2lmBDLgkObEA4DWNJ9FYQ==",
      "license": "MIT"
    },
    "node_modules/cors": {
      "version": "2.8.5",
      "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
      "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
      "license": "MIT",
      "dependencies": {
        "object-assign": "^4",
        "vary": "^1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/create-require": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/create-require/-/create-require-1.1.1.tgz",
      "integrity": "sha512-dcKFX3jn0MpIaXjisoRvexIJVEKzaq7z2rZKxf+MSr9TkdmHmsU4m2lcLojrj/FHl8mk5VxMmYA+ftRkP/3oKQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/cross-spawn": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/cross-spawn/-/cross-spawn-7.0.6.tgz",
      "integrity": "sha512-uV2QOWP2nWzsy2aMp8aRibhi9dlzF5Hgh5SHaB9OiTGEyDTiJJyx0uy51QXdyWbtAHNua4XJzUKca3OzKUd3vA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "path-key": "^3.1.0",
        "shebang-command": "^2.0.0",
        "which": "^2.0.1"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/date-fns": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/date-fns/-/date-fns-3.6.0.tgz",
      "integrity": "sha512-fRHTG8g/Gif+kSh50gaGEdToemgfj74aRX3swtiouboip5JDLAyDE9F11nHMIcvOaXeOC6D7SpNhi7uFyB7Uww==",
      "license": "MIT",
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/kossnocorp"
      }
    },
    "node_modules/debug": {
      "version": "4.4.1",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.1.tgz",
      "integrity": "sha512-KcKCqiftBJcZr++7ykoDIEwSa3XWowTfNPo92BYxjXiyYEVrUQh2aLyhxBCwww+heortUFxEJYcRzosstTEBYQ==",
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/deep-eql": {
      "version": "5.0.2",
      "resolved": "https://registry.npmjs.org/deep-eql/-/deep-eql-5.0.2.tgz",
      "integrity": "sha512-h5k/5U50IJJFpzfL6nO9jaaumfjO/f2NjK/oYB2Djzm4p9L+3T9qWpZqZ2hAbLPuuYq9wrU08WQyBTL5GbPk5Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/delayed-stream": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/delayed-stream/-/delayed-stream-1.0.0.tgz",
      "integrity": "sha512-ZySD7Nf91aLB0RxL4KGrKHBXl7Eds1DAmEdcoVawXnLD7SDhpNgtuII2aAkg7a7QS41jxPSZ17p4VdGnMHk3MQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.4.0"
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/destroy": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.2.0.tgz",
      "integrity": "sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/dezalgo": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/dezalgo/-/dezalgo-1.0.4.tgz",
      "integrity": "sha512-rXSP0bf+5n0Qonsb+SVVfNfIsimO4HEtmnIpPHY8Q1UCzKlQrDMfdobr8nJOOsRgWCyMRqeSBQzmWUMq7zvVig==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "asap": "^2.0.0",
        "wrappy": "1"
      }
    },
    "node_modules/diff": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/diff/-/diff-4.0.2.tgz",
      "integrity": "sha512-58lmxKSA4BNyLz+HHMUzlOEpg09FV+ev6ZMe3vJihgdxzgcwZ8VoEEPmALCZG9LmqfVoNMMKpttIYTVG6uDY7A==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.3.1"
      }
    },
    "node_modules/doctrine": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
      "integrity": "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
      "license": "Apache-2.0",
      "dependencies": {
        "esutils": "^2.0.2"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/dotenv": {
      "version": "16.5.0",
      "resolved": "https://registry.npmjs.org/dotenv/-/dotenv-16.5.0.tgz",
      "integrity": "sha512-m/C+AwOAr9/W1UOIZUo232ejMNnJAJtYQjUbHoNTBNTJSvqzzDh7vnrei3o3r3m9blf6ZoDkvcw0VmozNRFJxg==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://dotenvx.com"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/dynamic-dedupe": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/dynamic-dedupe/-/dynamic-dedupe-0.3.0.tgz",
      "integrity": "sha512-ssuANeD+z97meYOqd50e04Ze5qp4bPqo8cCkI4TRjZkzAUgIDTrXV1R8QCdINpiI+hw14+rYazvTRdQrz0/rFQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "xtend": "^4.0.0"
      }
    },
    "node_modules/eastasianwidth": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/eastasianwidth/-/eastasianwidth-0.2.0.tgz",
      "integrity": "sha512-I88TYZWc9XiYHRQ4/3c5rjjfgkjhLyW2luGIheGERbNQ6OY7yTybanSpDXZa8y7VUP9YmDcYa+eyq4ca7iLqWA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/ecdsa-sig-formatter": {
      "version": "1.0.11",
      "resolved": "https://registry.npmjs.org/ecdsa-sig-formatter/-/ecdsa-sig-formatter-1.0.11.tgz",
      "integrity": "sha512-nagl3RYrbNv6kQkeJIpt6NJZy8twLB/2vtz6yN9Z4vRKHN4/QZJIEbqohALSgwKdnksuY3k5Addp5lg8sVoVcQ==",
      "license": "Apache-2.0",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
      "license": "MIT"
    },
    "node_modules/emoji-regex": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
      "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/encodeurl": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-module-lexer": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-1.7.0.tgz",
      "integrity": "sha512-jEQoCwk8hyb2AZziIOLhDqpm5+2ww5uIE6lkO/6jcOCusfk6LhMHpXXfBLXTZ7Ydyt0j4VoUQv6uGNYbdW+kBA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-set-tostringtag": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/es-set-tostringtag/-/es-set-tostringtag-2.1.0.tgz",
      "integrity": "sha512-j6vWzfrGVfyXxge+O0x5sh6cvxAog0a/4Rdd2K36zCMV5eJ+/+tOAngRO8cODMNWbVRdVlmGZQL2YS3yR8bIUA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.6",
        "has-tostringtag": "^1.0.2",
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/esbuild": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/esbuild/-/esbuild-0.21.5.tgz",
      "integrity": "sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=12"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.21.5",
        "@esbuild/android-arm": "0.21.5",
        "@esbuild/android-arm64": "0.21.5",
        "@esbuild/android-x64": "0.21.5",
        "@esbuild/darwin-arm64": "0.21.5",
        "@esbuild/darwin-x64": "0.21.5",
        "@esbuild/freebsd-arm64": "0.21.5",
        "@esbuild/freebsd-x64": "0.21.5",
        "@esbuild/linux-arm": "0.21.5",
        "@esbuild/linux-arm64": "0.21.5",
        "@esbuild/linux-ia32": "0.21.5",
        "@esbuild/linux-loong64": "0.21.5",
        "@esbuild/linux-mips64el": "0.21.5",
        "@esbuild/linux-ppc64": "0.21.5",
        "@esbuild/linux-riscv64": "0.21.5",
        "@esbuild/linux-s390x": "0.21.5",
        "@esbuild/linux-x64": "0.21.5",
        "@esbuild/netbsd-x64": "0.21.5",
        "@esbuild/openbsd-x64": "0.21.5",
        "@esbuild/sunos-x64": "0.21.5",
        "@esbuild/win32-arm64": "0.21.5",
        "@esbuild/win32-ia32": "0.21.5",
        "@esbuild/win32-x64": "0.21.5"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
      "license": "MIT"
    },
    "node_modules/estree-walker": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/estree-walker/-/estree-walker-3.0.3.tgz",
      "integrity": "sha512-7RUKfXgSMMkzt6ZuXmqapOurLGPPfgj6l9uRZ7lRGolvk0y2yocc35LdcxKC5PQZdn2DMqioAQ2NoWcrTKmm6g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "^1.0.0"
      }
    },
    "node_modules/esutils": {
      "version": "2.0.3",
      "resolved": "https://registry.npmjs.org/esutils/-/esutils-2.0.3.tgz",
      "integrity": "sha512-kVscqXk4OCp68SZ0dkgEKVi6/8ij300KBWTJq32P/dYeWTSwK41WyTxalN1eRmA5Z9UU/LX9D7FWSmV9SAYx6g==",
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/expect-type": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/expect-type/-/expect-type-1.2.1.tgz",
      "integrity": "sha512-/kP8CAwxzLVEeFrMm4kMmy4CCDlpipyA7MYLVrdJIkV0fYF0UaigQHRsxHiuY/GEea+bh4KSv3TIlgr+2UL6bw==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/express": {
      "version": "4.21.2",
      "resolved": "https://registry.npmjs.org/express/-/express-4.21.2.tgz",
      "integrity": "sha512-28HqgMZAmih1Czt9ny7qr6ek2qddF4FclbMzwhCREB6OFfH+rXAnuNCwo1/wFvrtbgsQDb4kSbX9de9lFbrXnA==",
      "license": "MIT",
      "dependencies": {
        "accepts": "~1.3.8",
        "array-flatten": "1.1.1",
        "body-parser": "1.20.3",
        "content-disposition": "0.5.4",
        "content-type": "~1.0.4",
        "cookie": "0.7.1",
        "cookie-signature": "1.0.6",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "finalhandler": "1.3.1",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "merge-descriptors": "1.0.3",
        "methods": "~1.1.2",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "path-to-regexp": "0.1.12",
        "proxy-addr": "~2.0.7",
        "qs": "6.13.0",
        "range-parser": "~1.2.1",
        "safe-buffer": "5.2.1",
        "send": "0.19.0",
        "serve-static": "1.16.2",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "type-is": "~1.6.18",
        "utils-merge": "1.0.1",
        "vary": "~1.1.2"
      },
      "engines": {
        "node": ">= 0.10.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/express/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "license": "MIT",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/express/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "license": "MIT"
    },
    "node_modules/fast-safe-stringify": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/fast-safe-stringify/-/fast-safe-stringify-2.1.1.tgz",
      "integrity": "sha512-W+KJc2dmILlPplD/H4K9l9LcAHAfPtP6BY84uVLXQ6Evcz9Lcg33Y2z1IVblT6xdY54PXYVHEv+0Wpq8Io6zkA==",
      "license": "MIT"
    },
    "node_modules/fflate": {
      "version": "0.8.2",
      "resolved": "https://registry.npmjs.org/fflate/-/fflate-0.8.2.tgz",
      "integrity": "sha512-cPJU47OaAoCbg0pBvzsgpTPhmhqI5eJjh/JIu8tPj5q+T7iLvW/JAYUqmE7KOB4R1ZyEhzBaIQpQpardBF5z8A==",
      "license": "MIT"
    },
    "node_modules/file-type": {
      "version": "21.0.0",
      "resolved": "https://registry.npmjs.org/file-type/-/file-type-21.0.0.tgz",
      "integrity": "sha512-ek5xNX2YBYlXhiUXui3D/BXa3LdqPmoLJ7rqEx2bKJ7EAUEfmXgW0Das7Dc6Nr9MvqaOnIqiPV0mZk/r/UpNAg==",
      "license": "MIT",
      "dependencies": {
        "@tokenizer/inflate": "^0.2.7",
        "strtok3": "^10.2.2",
        "token-types": "^6.0.0",
        "uint8array-extras": "^1.4.0"
      },
      "engines": {
        "node": ">=20"
      },
      "funding": {
        "url": "https://github.com/sindresorhus/file-type?sponsor=1"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/finalhandler": {
      "version": "1.3.1",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.3.1.tgz",
      "integrity": "sha512-6BN9trH7bp3qvnrRyzsBz+g3lZxTNZTbVO2EV1CS0WIcDbawYVdYvGflME/9QP0h0pYlCDBCTjYa9nZzMDpyxQ==",
      "license": "MIT",
      "dependencies": {
        "debug": "2.6.9",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "on-finished": "2.4.1",
        "parseurl": "~1.3.3",
        "statuses": "2.0.1",
        "unpipe": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/finalhandler/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "license": "MIT",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/finalhandler/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "license": "MIT"
    },
    "node_modules/foreground-child": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/foreground-child/-/foreground-child-3.3.1.tgz",
      "integrity": "sha512-gIXjKqtFuWEgzFRJA9WCQeSJLZDjgJUOMCMzxtvFq/37KojM1BFGufqsCy0r4qSQmYLsZYMeyRqzIWOMup03sw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "cross-spawn": "^7.0.6",
        "signal-exit": "^4.0.1"
      },
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/form-data": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.2.tgz",
      "integrity": "sha512-hGfm/slu0ZabnNt4oaRZ6uREyfCj6P4fT/n6A1rGV+Z0VdGXjfOhVUpkn6qVQONHGIFwmveGXyDs75+nr6FM8w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "asynckit": "^0.4.0",
        "combined-stream": "^1.0.8",
        "es-set-tostringtag": "^2.1.0",
        "mime-types": "^2.1.12"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/formidable": {
      "version": "3.5.4",
      "resolved": "https://registry.npmjs.org/formidable/-/formidable-3.5.4.tgz",
      "integrity": "sha512-YikH+7CUTOtP44ZTnUhR7Ic2UASBPOqmaRkRKxRbywPTe5VxF7RRCck4af9wutiZ/QKM5nME9Bie2fFaPz5Gug==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@paralleldrive/cuid2": "^2.2.2",
        "dezalgo": "^1.0.4",
        "once": "^1.4.0"
      },
      "engines": {
        "node": ">=14.0.0"
      },
      "funding": {
        "url": "https://ko-fi.com/tunnckoCore/commissions"
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
      "integrity": "sha512-zJ2mQYM18rEFOudeV4GShTGIQ7RbzA7ozbU9I/XBpm7kqgMywgmylMwXHxZJmkVoYkna9d2pVXVXPdYTP9ej8Q==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fs.realpath": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
      "integrity": "sha512-OO0pH2lK6a0hZnAdau5ItzHPI6pUlvI7jMVnxUQRtw4owF2wk8lOSabtGDCTP4Ggrg2MbGnWO9X8K1t4+fGMDw==",
      "license": "ISC"
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/glob": {
      "version": "7.1.6",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.1.6.tgz",
      "integrity": "sha512-LwaxwyZ72Lk7vZINtNNrywX0ZuLyStrdDtabefZKAY5ZGJhVtgdznluResxNmPitE0SAO+O26sWTHeKSI2wMBA==",
      "license": "ISC",
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.0.4",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-flag": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
      "integrity": "sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-tostringtag": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/has-tostringtag/-/has-tostringtag-1.0.2.tgz",
      "integrity": "sha512-NqADB8VjPFLM2V0VvHUewwwsw0ZWBaIdgo+ieHtK3hasLz4qeCRjYcqfB6AQrBggRKppKF8L52/VqdVsO47Dlw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-symbols": "^1.0.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/html-escaper": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/html-escaper/-/html-escaper-2.0.2.tgz",
      "integrity": "sha512-H2iMtd0I4Mt5eYiapRdIDjp+XzelXQ0tFE4JS7YFwFevXXMmOp9myNrUvCg0D6ws8iqkRPBfKHgbwig1SmlLfg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/http-errors": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
      "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
      "license": "MIT",
      "dependencies": {
        "depd": "2.0.0",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": "2.0.1",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/ieee754": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
      "integrity": "sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "BSD-3-Clause"
    },
    "node_modules/ignore-by-default": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/ignore-by-default/-/ignore-by-default-1.0.1.tgz",
      "integrity": "sha512-Ius2VYcGNk7T90CppJqcIkS5ooHUZyIQK+ClZfMfMNFEF9VSE73Fq+906u/CWu92x4gzZMWOwfFYckPObzdEbA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/inflight": {
      "version": "1.0.6",
      "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
      "integrity": "sha512-k92I/b08q4wvFscXCLvqfsHCrjrF7yiXsQuIVvVE7N82W3+aqpzuUdBbfhWcy/FZR3/4IgflMgKLOsvPDrGCJA==",
      "license": "ISC",
      "dependencies": {
        "once": "^1.3.0",
        "wrappy": "1"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "license": "ISC"
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "binary-extensions": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-core-module": {
      "version": "2.16.1",
      "resolved": "https://registry.npmjs.org/is-core-module/-/is-core-module-2.16.1.tgz",
      "integrity": "sha512-UfoeMA6fIJ8wTYFEUjelnaGI67v6+N7qXJEvQuIGa99l4xsCruSYOVSQ0uPANn4dAzm8lkYPaKLrrijLq7x23w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "hasown": "^2.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-fullwidth-code-point": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
      "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/isarray": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-1.0.0.tgz",
      "integrity": "sha512-VLghIWNM6ELQzo7zwmcg0NmTVyWKYjvIeM83yjp0wRDTmUnrM678fQbcKBo6n2CJEF0szoG//ytg+TKla89ALQ==",
      "license": "MIT"
    },
    "node_modules/isexe": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
      "integrity": "sha512-RHxMLp9lnKHGHRng9QFhRCMbYAcVpn69smSGcq3f36xjgVVWThj4qqLbTLlq7Ssj8B+fIQ1EuCEGI2lKsyQeIw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/istanbul-lib-coverage": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/istanbul-lib-coverage/-/istanbul-lib-coverage-3.2.2.tgz",
      "integrity": "sha512-O8dpsF+r0WV/8MNRKfnmrtCWhuKjxrq2w+jpzBL5UZKTi2LeVWnWOmWRxFlesJONmc+wLAGvKQZEOanko0LFTg==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/istanbul-lib-report": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/istanbul-lib-report/-/istanbul-lib-report-3.0.1.tgz",
      "integrity": "sha512-GCfE1mtsHGOELCU8e/Z7YWzpmybrx/+dSTfLrvY8qRmaY6zXTKWn6WQIjaAFw069icm6GVMNkgu0NzI4iPZUNw==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "istanbul-lib-coverage": "^3.0.0",
        "make-dir": "^4.0.0",
        "supports-color": "^7.1.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-lib-report/node_modules/has-flag": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
      "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/istanbul-lib-report/node_modules/supports-color": {
      "version": "7.2.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
      "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^4.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/istanbul-lib-source-maps": {
      "version": "5.0.6",
      "resolved": "https://registry.npmjs.org/istanbul-lib-source-maps/-/istanbul-lib-source-maps-5.0.6.tgz",
      "integrity": "sha512-yg2d+Em4KizZC5niWhQaIomgf5WlL4vOOjZ5xGCmF8SnPE/mDWWXgvRExdcpCgh9lLRRa1/fSYp2ymmbJ1pI+A==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "@jridgewell/trace-mapping": "^0.3.23",
        "debug": "^4.1.1",
        "istanbul-lib-coverage": "^3.0.0"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/istanbul-reports": {
      "version": "3.1.7",
      "resolved": "https://registry.npmjs.org/istanbul-reports/-/istanbul-reports-3.1.7.tgz",
      "integrity": "sha512-BewmUXImeuRk2YY0PVbxgKAysvhRPUQE0h5QRM++nVWyubKGV0l8qQ5op8+B2DOmwSe63Jivj0BjkPQVf8fP5g==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "html-escaper": "^2.0.0",
        "istanbul-lib-report": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/iterare": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/iterare/-/iterare-1.2.1.tgz",
      "integrity": "sha512-RKYVTCjAnRthyJes037NX/IiqeidgN1xc3j1RjFfECFp28A1GVwK9nA+i0rJPaHqSZwygLzRnFlzUuHFoWWy+Q==",
      "license": "ISC",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/jackspeak": {
      "version": "3.4.3",
      "resolved": "https://registry.npmjs.org/jackspeak/-/jackspeak-3.4.3.tgz",
      "integrity": "sha512-OGlZQpz2yfahA/Rd1Y8Cd9SIEsqvXkLVoSw/cgwhnhFMDbsQFeZYoJJ7bIZBS9BcamUW96asq/npPWugM+RQBw==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "@isaacs/cliui": "^8.0.2"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      },
      "optionalDependencies": {
        "@pkgjs/parseargs": "^0.11.0"
      }
    },
    "node_modules/jiti": {
      "version": "2.4.2",
      "resolved": "https://registry.npmjs.org/jiti/-/jiti-2.4.2.tgz",
      "integrity": "sha512-rg9zJN+G4n2nfJl5MW3BMygZX56zKPNVEYYqq7adpmMh4Jn2QNEwhvQlFy6jPVdcod7txZtKHWnyZiA3a0zP7A==",
      "devOptional": true,
      "license": "MIT",
      "bin": {
        "jiti": "lib/jiti-cli.mjs"
      }
    },
    "node_modules/js-yaml": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
      "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
      "license": "MIT",
      "dependencies": {
        "argparse": "^2.0.1"
      },
      "bin": {
        "js-yaml": "bin/js-yaml.js"
      }
    },
    "node_modules/jsonwebtoken": {
      "version": "9.0.2",
      "resolved": "https://registry.npmjs.org/jsonwebtoken/-/jsonwebtoken-9.0.2.tgz",
      "integrity": "sha512-PRp66vJ865SSqOlgqS8hujT5U4AOgMfhrwYIuIhfKaoSCZcirrmASQr8CX7cUg+RMih+hgznrjp99o+W4pJLHQ==",
      "license": "MIT",
      "dependencies": {
        "jws": "^3.2.2",
        "lodash.includes": "^4.3.0",
        "lodash.isboolean": "^3.0.3",
        "lodash.isinteger": "^4.0.4",
        "lodash.isnumber": "^3.0.3",
        "lodash.isplainobject": "^4.0.6",
        "lodash.isstring": "^4.0.1",
        "lodash.once": "^4.0.0",
        "ms": "^2.1.1",
        "semver": "^7.5.4"
      },
      "engines": {
        "node": ">=12",
        "npm": ">=6"
      }
    },
    "node_modules/jwa": {
      "version": "1.4.2",
      "resolved": "https://registry.npmjs.org/jwa/-/jwa-1.4.2.tgz",
      "integrity": "sha512-eeH5JO+21J78qMvTIDdBXidBd6nG2kZjg5Ohz/1fpa28Z4CcsWUzJ1ZZyFq/3z3N17aZy+ZuBoHljASbL1WfOw==",
      "license": "MIT",
      "dependencies": {
        "buffer-equal-constant-time": "^1.0.1",
        "ecdsa-sig-formatter": "1.0.11",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/jws": {
      "version": "3.2.2",
      "resolved": "https://registry.npmjs.org/jws/-/jws-3.2.2.tgz",
      "integrity": "sha512-YHlZCB6lMTllWDtSPHz/ZXTsi8S00usEV6v1tjq8tOUZzw7DpSDWVXjXDre6ed1w/pd495ODpHZYSdkRTsa0HA==",
      "license": "MIT",
      "dependencies": {
        "jwa": "^1.4.1",
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/libphonenumber-js": {
      "version": "1.12.9",
      "resolved": "https://registry.npmjs.org/libphonenumber-js/-/libphonenumber-js-1.12.9.tgz",
      "integrity": "sha512-VWwAdNeJgN7jFOD+wN4qx83DTPMVPPAUyx9/TUkBXKLiNkuWWk6anV0439tgdtwaJDrEdqkvdN22iA6J4bUCZg==",
      "license": "MIT"
    },
    "node_modules/load-esm": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/load-esm/-/load-esm-1.0.2.tgz",
      "integrity": "sha512-nVAvWk/jeyrWyXEAs84mpQCYccxRqgKY4OznLuJhJCa0XsPSfdOIr2zvBZEj3IHEHbX97jjscKRRV539bW0Gpw==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/Borewit"
        },
        {
          "type": "buymeacoffee",
          "url": "https://buymeacoffee.com/borewit"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=13.2.0"
      }
    },
    "node_modules/lodash": {
      "version": "4.17.21",
      "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
      "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
      "license": "MIT"
    },
    "node_modules/lodash.get": {
      "version": "4.4.2",
      "resolved": "https://registry.npmjs.org/lodash.get/-/lodash.get-4.4.2.tgz",
      "integrity": "sha512-z+Uw/vLuy6gQe8cfaFWD7p0wVv8fJl3mbzXh33RS+0oW2wvUqiRXiQ69gLWSLpgB5/6sU+r6BlQR0MBILadqTQ==",
      "license": "MIT"
    },
    "node_modules/lodash.includes": {
      "version": "4.3.0",
      "resolved": "https://registry.npmjs.org/lodash.includes/-/lodash.includes-4.3.0.tgz",
      "integrity": "sha512-W3Bx6mdkRTGtlJISOvVD/lbqjTlPPUDTMnlXZFnVwi9NKJ6tiAk6LVdlhZMm17VZisqhKcgzpO5Wz91PCt5b0w==",
      "license": "MIT"
    },
    "node_modules/lodash.isboolean": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isboolean/-/lodash.isboolean-3.0.3.tgz",
      "integrity": "sha512-Bz5mupy2SVbPHURB98VAcw+aHh4vRV5IPNhILUCsOzRmsTmSQ17jIuqopAentWoehktxGd9e/hbIXq980/1QJg==",
      "license": "MIT"
    },
    "node_modules/lodash.isequal": {
      "version": "4.5.0",
      "resolved": "https://registry.npmjs.org/lodash.isequal/-/lodash.isequal-4.5.0.tgz",
      "integrity": "sha512-pDo3lu8Jhfjqls6GkMgpahsF9kCyayhgykjyLMNFTKWrpVdAQtYyB4muAMWozBB4ig/dtWAmsMxLEI8wuz+DYQ==",
      "license": "MIT"
    },
    "node_modules/lodash.isinteger": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/lodash.isinteger/-/lodash.isinteger-4.0.4.tgz",
      "integrity": "sha512-DBwtEWN2caHQ9/imiNeEA5ys1JoRtRfY3d7V9wkqtbycnAmTvRRmbHKDV4a0EYc678/dia0jrte4tjYwVBaZUA==",
      "license": "MIT"
    },
    "node_modules/lodash.isnumber": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/lodash.isnumber/-/lodash.isnumber-3.0.3.tgz",
      "integrity": "sha512-QYqzpfwO3/CWf3XP+Z+tkQsfaLL/EnUlXWVkIk5FUPc4sBdTehEqZONuyRt2P67PXAk+NXmTBcc97zw9t1FQrw==",
      "license": "MIT"
    },
    "node_modules/lodash.isplainobject": {
      "version": "4.0.6",
      "resolved": "https://registry.npmjs.org/lodash.isplainobject/-/lodash.isplainobject-4.0.6.tgz",
      "integrity": "sha512-oSXzaWypCMHkPC3NvBEaPHf0KsA5mvPrOPgQWDsbg8n7orZ290M0BmC/jgRZ4vcJ6DTAhjrsSYgdsW/F+MFOBA==",
      "license": "MIT"
    },
    "node_modules/lodash.isstring": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/lodash.isstring/-/lodash.isstring-4.0.1.tgz",
      "integrity": "sha512-0wJxfxH1wgO3GrbuP+dTTk7op+6L41QCXbGINEmD+ny/G/eCqGzxyCsh7159S+mgDDcoarnBw6PC1PS5+wUGgw==",
      "license": "MIT"
    },
    "node_modules/lodash.mergewith": {
      "version": "4.6.2",
      "resolved": "https://registry.npmjs.org/lodash.mergewith/-/lodash.mergewith-4.6.2.tgz",
      "integrity": "sha512-GK3g5RPZWTRSeLSpgP8Xhra+pnjBC56q9FZYe1d5RN3TJ35dbkGy3YqBSMbyCrlbi+CM9Z3Jk5yTL7RCsqboyQ==",
      "license": "MIT"
    },
    "node_modules/lodash.once": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/lodash.once/-/lodash.once-4.1.1.tgz",
      "integrity": "sha512-Sb487aTOCr9drQVL8pIxOzVhafOjZN9UU54hiN8PU3uAiSV7lx1yYNpbNmex2PK6dSJoNTSJUUswT651yww3Mg==",
      "license": "MIT"
    },
    "node_modules/loupe": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/loupe/-/loupe-3.1.3.tgz",
      "integrity": "sha512-kkIp7XSkP78ZxJEsSxW3712C6teJVoeHHwgo9zJ380de7IYyJ2ISlxojcH2pC5OFLewESmnRi/+XCDIEEVyoug==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lru-cache": {
      "version": "10.4.3",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-10.4.3.tgz",
      "integrity": "sha512-JNAzZcXrCt42VGLuYz0zfAzDfAvJWW6AfYlDBQyDV5DClI2m5sAmK+OIO7s59XfsRsWHp02jAJrRadPRGTt6SQ==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/magic-string": {
      "version": "0.30.17",
      "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.30.17.tgz",
      "integrity": "sha512-sNPKHvyjVf7gyjwS4xGTaW/mCnF8wnjtifKBEhxfZ7E/S8tQ0rssrwGNn6q8JH/ohItJfSQp9mBtQYuTlH5QnA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.0"
      }
    },
    "node_modules/magicast": {
      "version": "0.3.5",
      "resolved": "https://registry.npmjs.org/magicast/-/magicast-0.3.5.tgz",
      "integrity": "sha512-L0WhttDl+2BOsybvEOLK7fW3UA0OQ0IQ2d6Zl2x/a6vVRs3bAY0ECOSHHeL5jD+SbOpOCUEi0y1DgHEn9Qn1AQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@babel/parser": "^7.25.4",
        "@babel/types": "^7.25.4",
        "source-map-js": "^1.2.0"
      }
    },
    "node_modules/make-dir": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/make-dir/-/make-dir-4.0.0.tgz",
      "integrity": "sha512-hXdUTZYIVOt1Ex//jAQi+wTZZpUpwBj/0QsOzqegb3rGMMeJiSEu5xLHnYfBrRV4RH2+OCSOO95Is/7x1WJ4bw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "semver": "^7.5.3"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/make-error": {
      "version": "1.3.6",
      "resolved": "https://registry.npmjs.org/make-error/-/make-error-1.3.6.tgz",
      "integrity": "sha512-s8UhlNe7vPKomQhC1qFelMokr/Sc3AgNbso3n74mVPA5LTZwkB9NlXf4XPamLxJE8h0gh73rM94xvwRT2CVInw==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/media-typer": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
      "integrity": "sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/merge-descriptors": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.3.tgz",
      "integrity": "sha512-gaNvAS7TZ897/rVaZ0nMtAyxNyi/pdbjbAwUpFQpN70GqnVfOiXpeUUMKRBmzXaSQ8DdTX4/0ms62r2K+hE6mQ==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/methods": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
      "integrity": "sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/mime/-/mime-1.6.0.tgz",
      "integrity": "sha512-x0Vn8spI+wuJ1O6S7gnbaQg8Pxh4NNHb7KSINmEWKiPE4RKOplvijn+NkmYmmRgP68mc70j2EbeTFRsrswaQeg==",
      "license": "MIT",
      "bin": {
        "mime": "cli.js"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/minimist": {
      "version": "1.2.8",
      "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.8.tgz",
      "integrity": "sha512-2yyAR8qBkN3YuheJanUpWC5U3bb5osDywNB8RzDVlDwDHbocAJveqqj1u8+SVD7jkWT4yvsHCpWqqWqAxb0zCA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/minipass": {
      "version": "7.1.2",
      "resolved": "https://registry.npmjs.org/minipass/-/minipass-7.1.2.tgz",
      "integrity": "sha512-qOOzS1cBTWYF4BH8fVePDBOO9iptMnGUEZwNc/cMWnTV2nVLZ7VoNWEPHkYczZA0pdoA7dl6e7FL659nX9S2aw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=16 || 14 >=14.17"
      }
    },
    "node_modules/mkdirp": {
      "version": "0.5.6",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.6.tgz",
      "integrity": "sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw==",
      "license": "MIT",
      "dependencies": {
        "minimist": "^1.2.6"
      },
      "bin": {
        "mkdirp": "bin/cmd.js"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/multer": {
      "version": "1.4.5-lts.2",
      "resolved": "https://registry.npmjs.org/multer/-/multer-1.4.5-lts.2.tgz",
      "integrity": "sha512-VzGiVigcG9zUAoCNU+xShztrlr1auZOlurXynNvO9GiWD1/mTBbUljOKY+qMeazBqXgRnjzeEgJI/wyjJUHg9A==",
      "license": "MIT",
      "dependencies": {
        "append-field": "^1.0.0",
        "busboy": "^1.0.0",
        "concat-stream": "^1.5.2",
        "mkdirp": "^0.5.4",
        "object-assign": "^4.1.1",
        "type-is": "^1.6.4",
        "xtend": "^4.0.0"
      },
      "engines": {
        "node": ">= 6.0.0"
      }
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.11.tgz",
      "integrity": "sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/negotiator": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
      "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/node-cron": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/node-cron/-/node-cron-3.0.3.tgz",
      "integrity": "sha512-dOal67//nohNgYWb+nWmg5dkFdIwDm8EpeGYMekPMrngV3637lqnX0lbUcCtgibHTz6SEz7DAIjKvKDFYCnO1A==",
      "license": "ISC",
      "dependencies": {
        "uuid": "8.3.2"
      },
      "engines": {
        "node": ">=6.0.0"
      }
    },
    "node_modules/node-cron/node_modules/uuid": {
      "version": "8.3.2",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-8.3.2.tgz",
      "integrity": "sha512-+NYs2QeMWy+GWFOEm9xnn6HCDp0l7QBD7ml8zLUmJ+93Q5NF0NocErnwkTkXVFNiX3/fpC6afS8Dhb/gz7R7eg==",
      "license": "MIT",
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/nodemon": {
      "version": "3.1.10",
      "resolved": "https://registry.npmjs.org/nodemon/-/nodemon-3.1.10.tgz",
      "integrity": "sha512-WDjw3pJ0/0jMFmyNDp3gvY2YizjLmmOUQo6DEBY+JgdvW/yQ9mEeSw6H5ythl5Ny2ytb7f9C2nIbjSxMNzbJXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chokidar": "^3.5.2",
        "debug": "^4",
        "ignore-by-default": "^1.0.1",
        "minimatch": "^3.1.2",
        "pstree.remy": "^1.1.8",
        "semver": "^7.5.3",
        "simple-update-notifier": "^2.0.0",
        "supports-color": "^5.5.0",
        "touch": "^3.1.0",
        "undefsafe": "^2.0.5"
      },
      "bin": {
        "nodemon": "bin/nodemon.js"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/nodemon"
      }
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-assign": {
      "version": "4.1.1",
      "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
      "integrity": "sha512-rJgTQnkUnH1sFw8yT6VSU3zD3sWmu6sZhIseY8VX+GRu3P6F7Fu+JNDoXfklElbLJSnc3FUQHVe4cU5hj+BcUg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "license": "MIT",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/once": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
      "integrity": "sha512-lNaJgI+2Q5URQBkccEKHTQOPaXdUxnZZElQTZY0MFUAuaEqe1E+Nyvgdz/aIyNi6Z9MzO5dv1H8n58/GELp3+w==",
      "license": "ISC",
      "dependencies": {
        "wrappy": "1"
      }
    },
    "node_modules/openapi-types": {
      "version": "12.1.3",
      "resolved": "https://registry.npmjs.org/openapi-types/-/openapi-types-12.1.3.tgz",
      "integrity": "sha512-N4YtSYJqghVu4iek2ZUvcN/0aqH1kRDuNqzcycDxhOUpg7GdvLa2F3DgS6yBNhInhv2r/6I0Flkn7CqL8+nIcw==",
      "peer": true
    },
    "node_modules/package-json-from-dist": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/package-json-from-dist/-/package-json-from-dist-1.0.1.tgz",
      "integrity": "sha512-UEZIS3/by4OC8vL3P2dTXRETpebLI2NiI5vIrjaD/5UtrkFX/tNbwjTSRAGC/+7CAo2pIcBaRgWmcBBHcsaCIw==",
      "dev": true,
      "license": "BlueOak-1.0.0"
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-is-absolute": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
      "integrity": "sha512-AVbw3UJ2e9bq64vSaS9Am0fje1Pa8pbGqTTsmXfaIiMpnr5DlDhfJOuLj9Sf95ZPVDAUerDfEk88MPmPe7UCQg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/path-key": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/path-key/-/path-key-3.1.1.tgz",
      "integrity": "sha512-ojmeN0qd+y0jszEtoY48r0Peq5dwMEkIlCOu6Q5f41lfkswXuKtYrhgoTpLnyIcHm24Uhqx+5Tqm2InSwLhE6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/path-parse": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/path-parse/-/path-parse-1.0.7.tgz",
      "integrity": "sha512-LDJzPVEEEPR+y48z93A0Ed0yXb8pAByGWo/k5YYdYgpY2/2EsOsksJrq7lOHxryrVOn1ejG6oAp8ahvOIQD8sw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/path-scurry": {
      "version": "1.11.1",
      "resolved": "https://registry.npmjs.org/path-scurry/-/path-scurry-1.11.1.tgz",
      "integrity": "sha512-Xa4Nw17FS9ApQFJ9umLiJS4orGjm7ZzwUrwamcGQuHSzDyth9boKDaycYdDcZDuqYATXw4HFXgaqWTctW/v1HA==",
      "dev": true,
      "license": "BlueOak-1.0.0",
      "dependencies": {
        "lru-cache": "^10.2.0",
        "minipass": "^5.0.0 || ^6.0.2 || ^7.0.0"
      },
      "engines": {
        "node": ">=16 || 14 >=14.18"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "0.1.12",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
      "integrity": "sha512-RA1GjUVMnvYFxuqovrEqZoxxW5NUZqbwKtYz/Tt7nXerk0LbLblQmrsgdeOxV5SFHf0UDggjS/bSeOZwt1pmEQ==",
      "license": "MIT"
    },
    "node_modules/pathe": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/pathe/-/pathe-1.1.2.tgz",
      "integrity": "sha512-whLdWMYL2TwI08hn8/ZqAbrVemu0LNaNNJZX73O6qaIdCTfXutsLhMkjdENX0qhsQ9uIimo4/aQOmXkoon2nDQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/pathval": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/pathval/-/pathval-2.0.0.tgz",
      "integrity": "sha512-vE7JKRyES09KiunauX7nd2Q9/L7lhok4smP9RZTDeD4MVs72Dp2qNFVz39Nz5a0FVEW0BJR6C0DYrq6unoziZA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 14.16"
      }
    },
    "node_modules/peek-readable": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/peek-readable/-/peek-readable-7.0.0.tgz",
      "integrity": "sha512-nri2TO5JE3/mRryik9LlHFT53cgHfRK0Lt0BAZQXku/AW3E6XLt2GaY8siWi7dvW/m1z0ecn+J+bpDa9ZN3IsQ==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/Borewit"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.1.1.tgz",
      "integrity": "sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/postcss": {
      "version": "8.5.4",
      "resolved": "https://registry.npmjs.org/postcss/-/postcss-8.5.4.tgz",
      "integrity": "sha512-QSa9EBe+uwlGTFmHsPKokv3B/oEMQZxfqW0QqNCyhpa6mB1afzulwn8hihglqAb2pOw+BJgNlmXQ8la2VeHB7w==",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/prisma": {
      "version": "6.9.0",
      "resolved": "https://registry.npmjs.org/prisma/-/prisma-6.9.0.tgz",
      "integrity": "sha512-resJAwMyZREC/I40LF6FZ6rZTnlrlrYrb63oW37Gq+U+9xHwbyMSPJjKtM7VZf3gTO86t/Oyz+YeSXr3CmAY1Q==",
      "devOptional": true,
      "hasInstallScript": true,
      "license": "Apache-2.0",
      "dependencies": {
        "@prisma/config": "6.9.0",
        "@prisma/engines": "6.9.0"
      },
      "bin": {
        "prisma": "build/index.js"
      },
      "engines": {
        "node": ">=18.18"
      },
      "peerDependencies": {
        "typescript": ">=5.1.0"
      },
      "peerDependenciesMeta": {
        "typescript": {
          "optional": true
        }
      }
    },
    "node_modules/process-nextick-args": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/process-nextick-args/-/process-nextick-args-2.0.1.tgz",
      "integrity": "sha512-3ouUOpQhtgrbOa17J7+uxOTpITYWaGP7/AhoR3+A+/1e9skrzelGi/dXzEYyvbxubEF6Wn2ypscTKiKJFFn1ag==",
      "license": "MIT"
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "license": "MIT",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/pstree.remy": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/pstree.remy/-/pstree.remy-1.1.8.tgz",
      "integrity": "sha512-77DZwxQmxKnu3aR542U+X8FypNzbfJ+C5XQDk3uWjWxn6151aIMGthWYRXTqT1E5oJvg+ljaa2OJi+VfvCOQ8w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/q": {
      "version": "1.5.1",
      "resolved": "https://registry.npmjs.org/q/-/q-1.5.1.tgz",
      "integrity": "sha512-kV/CThkXo6xyFEZUugw/+pIOywXcDbFYgSct5cT3gqlbkBE1SJdwy6UQoZvodiWF/ckQLZyDE/Bu1M6gVu5lVw==",
      "license": "MIT",
      "engines": {
        "node": ">=0.6.0",
        "teleport": ">=0.2.0"
      }
    },
    "node_modules/qs": {
      "version": "6.13.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.13.0.tgz",
      "integrity": "sha512-+38qI9SOr8tfZ4QmJNplMUxqjbe7LKvvZgWdExBOmd+egZTtjLB67Gu0HRX3u/XOq7UU2Nx6nsjvS16Z9uwfpg==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.0.6"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "2.5.2",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.5.2.tgz",
      "integrity": "sha512-8zGqypfENjCIqGhgXToC8aB2r7YrBX+AQAfIPs/Mlk+BtPTztOvTS01NRW/3Eh60J+a48lt8qsCzirQ6loCVfA==",
      "license": "MIT",
      "dependencies": {
        "bytes": "3.1.2",
        "http-errors": "2.0.0",
        "iconv-lite": "0.4.24",
        "unpipe": "1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/readable-stream": {
      "version": "2.3.8",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-2.3.8.tgz",
      "integrity": "sha512-8p0AUk4XODgIewSi0l8Epjs+EVnWiK7NoDIEGU0HhE7+ZyY8D1IMY7odu5lRrFXGg71L15KG8QrPmum45RTtdA==",
      "license": "MIT",
      "dependencies": {
        "core-util-is": "~1.0.0",
        "inherits": "~2.0.3",
        "isarray": "~1.0.0",
        "process-nextick-args": "~2.0.0",
        "safe-buffer": "~5.1.1",
        "string_decoder": "~1.1.1",
        "util-deprecate": "~1.0.1"
      }
    },
    "node_modules/readable-stream/node_modules/safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
      "license": "MIT"
    },
    "node_modules/readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/reflect-metadata": {
      "version": "0.2.2",
      "resolved": "https://registry.npmjs.org/reflect-metadata/-/reflect-metadata-0.2.2.tgz",
      "integrity": "sha512-urBwgfrvVP/eAyXx4hluJivBKzuEbSQs9rKWCrCkbSxNv8mxPcUZKeuoF3Uy4mJl3Lwprp6yy5/39VWigZ4K6Q==",
      "license": "Apache-2.0"
    },
    "node_modules/resolve": {
      "version": "1.22.10",
      "resolved": "https://registry.npmjs.org/resolve/-/resolve-1.22.10.tgz",
      "integrity": "sha512-NPRy+/ncIMeDlTAsuqwKIiferiawhefFJtkNSW0qZJEqMEb+qBt/77B/jGeeek+F0uOeN05CDa6HXbbIgtVX4w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-core-module": "^2.16.0",
        "path-parse": "^1.0.7",
        "supports-preserve-symlinks-flag": "^1.0.0"
      },
      "bin": {
        "resolve": "bin/resolve"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/rimraf": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-2.7.1.tgz",
      "integrity": "sha512-uWjbaKIK3T1OSVptzX7Nl6PvQ3qAGtKEtVRjRuazjfL3Bx5eI409VZSqgND+4UNnmzLVdPj9FqFJNPqBZFve4w==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "glob": "^7.1.3"
      },
      "bin": {
        "rimraf": "bin.js"
      }
    },
    "node_modules/rimraf/node_modules/glob": {
      "version": "7.2.3",
      "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.3.tgz",
      "integrity": "sha512-nFR0zLpU2YCaRxwoCJvL6UvCH2JFyFVIvwTLsIf21AuHlMskA1hhTdk+LlYJtOlYt9v6dvszD2BGRqBL+iQK9Q==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "fs.realpath": "^1.0.0",
        "inflight": "^1.0.4",
        "inherits": "2",
        "minimatch": "^3.1.1",
        "once": "^1.3.0",
        "path-is-absolute": "^1.0.0"
      },
      "engines": {
        "node": "*"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/rollup": {
      "version": "4.41.1",
      "resolved": "https://registry.npmjs.org/rollup/-/rollup-4.41.1.tgz",
      "integrity": "sha512-cPmwD3FnFv8rKMBc1MxWCwVQFxwf1JEmSX3iQXrRVVG15zerAIXRjMFVWnd5Q5QvgKF7Aj+5ykXFhUl+QGnyOw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.7"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.41.1",
        "@rollup/rollup-android-arm64": "4.41.1",
        "@rollup/rollup-darwin-arm64": "4.41.1",
        "@rollup/rollup-darwin-x64": "4.41.1",
        "@rollup/rollup-freebsd-arm64": "4.41.1",
        "@rollup/rollup-freebsd-x64": "4.41.1",
        "@rollup/rollup-linux-arm-gnueabihf": "4.41.1",
        "@rollup/rollup-linux-arm-musleabihf": "4.41.1",
        "@rollup/rollup-linux-arm64-gnu": "4.41.1",
        "@rollup/rollup-linux-arm64-musl": "4.41.1",
        "@rollup/rollup-linux-loongarch64-gnu": "4.41.1",
        "@rollup/rollup-linux-powerpc64le-gnu": "4.41.1",
        "@rollup/rollup-linux-riscv64-gnu": "4.41.1",
        "@rollup/rollup-linux-riscv64-musl": "4.41.1",
        "@rollup/rollup-linux-s390x-gnu": "4.41.1",
        "@rollup/rollup-linux-x64-gnu": "4.41.1",
        "@rollup/rollup-linux-x64-musl": "4.41.1",
        "@rollup/rollup-win32-arm64-msvc": "4.41.1",
        "@rollup/rollup-win32-ia32-msvc": "4.41.1",
        "@rollup/rollup-win32-x64-msvc": "4.41.1",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/rxjs": {
      "version": "7.8.2",
      "resolved": "https://registry.npmjs.org/rxjs/-/rxjs-7.8.2.tgz",
      "integrity": "sha512-dhKf903U/PQZY6boNNtAGdWbG85WAbjT/1xYoZIC7FAY0yWapOBQVsVrDl58W86//e1VpMNBtRV4MaXfdMySFA==",
      "dependencies": {
        "tslib": "^2.1.0"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.2",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.2.tgz",
      "integrity": "sha512-RF0Fw+rO5AMf9MAyaRXI4AV0Ulj5lMHqVxxdSgiVbixSCXoEmmX/jk0CuJw4+3SqroYO9VoUh+HcuJivvtJemA==",
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/send": {
      "version": "0.19.0",
      "resolved": "https://registry.npmjs.org/send/-/send-0.19.0.tgz",
      "integrity": "sha512-dW41u5VfLXu8SJh5bwRmyYUbAoSB3c9uQh6L8h/KtsFREPWpbX1lrljJo186Jc4nmci/sGUZ9a0a0J2zgfq2hw==",
      "license": "MIT",
      "dependencies": {
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "encodeurl": "~1.0.2",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "fresh": "0.5.2",
        "http-errors": "2.0.0",
        "mime": "1.6.0",
        "ms": "2.1.3",
        "on-finished": "2.4.1",
        "range-parser": "~1.2.1",
        "statuses": "2.0.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/send/node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "license": "MIT",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/send/node_modules/debug/node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "license": "MIT"
    },
    "node_modules/send/node_modules/encodeurl": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
      "integrity": "sha512-TPJXq8JqFaVYm2CWmPvnP2Iyo4ZSM7/QKcSmuMLDObfpH5fi7RUGmd/rTDf+rut/saiDiQEeVTNgAmJEdAOx0w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/serve-static": {
      "version": "1.16.2",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.16.2.tgz",
      "integrity": "sha512-VqpjJZKadQB/PEbEwvFdO43Ax5dFBZ2UECszz8bQ7pi7wt//PWe1P6MN7eCnjsatYtBT6EuiClbjSWP2WrIoTw==",
      "license": "MIT",
      "dependencies": {
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "parseurl": "~1.3.3",
        "send": "0.19.0"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
      "license": "ISC"
    },
    "node_modules/shebang-command": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/shebang-command/-/shebang-command-2.0.0.tgz",
      "integrity": "sha512-kHxr2zZpYtdmrN1qDjrrX/Z1rR1kG8Dx+gkpK1G4eXmvXswmcE1hTWBWYUzlraYw1/yZp6YuDY77YtvbN0dmDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "shebang-regex": "^3.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/shebang-regex": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/shebang-regex/-/shebang-regex-3.0.0.tgz",
      "integrity": "sha512-7++dFhtcx3353uBaq8DDR4NuxBetBzC7ZQOhmTQInHEd6bSrXdiEyzCvG07Z44UYdLShWUyXt5M/yhz8ekcb1A==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/siginfo": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/siginfo/-/siginfo-2.0.0.tgz",
      "integrity": "sha512-ybx0WO1/8bSBLEWXZvEd7gMW3Sn3JFlW3TvX1nREbDLRNQNaeNN8WK0meBwPdAaOI7TtRRRJn/Es1zhrrCHu7g==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/signal-exit": {
      "version": "4.1.0",
      "resolved": "https://registry.npmjs.org/signal-exit/-/signal-exit-4.1.0.tgz",
      "integrity": "sha512-bzyZ1e88w9O1iNJbKnOlvYTrWPDl46O1bG0D3XInv+9tkPrxrN8jUUTiFlDkkmKWgn1M6CfIA13SuGqOa9Korw==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": ">=14"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/simple-update-notifier": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/simple-update-notifier/-/simple-update-notifier-2.0.0.tgz",
      "integrity": "sha512-a2B9Y0KlNXl9u/vsW6sTIu9vGEpfKu2wRV6l1H3XEas/0gUIzGzBoP/IouTcUQbm9JWZLH3COxyn03TYlFax6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "semver": "^7.5.3"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/source-map": {
      "version": "0.6.1",
      "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
      "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/source-map-js/-/source-map-js-1.2.1.tgz",
      "integrity": "sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/source-map-support": {
      "version": "0.5.21",
      "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.21.tgz",
      "integrity": "sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "buffer-from": "^1.0.0",
        "source-map": "^0.6.0"
      }
    },
    "node_modules/stackback": {
      "version": "0.0.2",
      "resolved": "https://registry.npmjs.org/stackback/-/stackback-0.0.2.tgz",
      "integrity": "sha512-1XMJE5fQo1jGH6Y/7ebnwPOBEkIEnT4QF32d5R1+VXdXveM0IBMJt8zfaxX1P3QhVwrYe+576+jkANtSS2mBbw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/statuses": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
      "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/std-env": {
      "version": "3.9.0",
      "resolved": "https://registry.npmjs.org/std-env/-/std-env-3.9.0.tgz",
      "integrity": "sha512-UGvjygr6F6tpH7o2qyqR6QYpwraIjKSdtzyBdyytFOHmPZY917kwdwLG0RbOjWOnKmnm3PeHjaoLLMie7kPLQw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/streamifier": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/streamifier/-/streamifier-0.1.1.tgz",
      "integrity": "sha512-zDgl+muIlWzXNsXeyUfOk9dChMjlpkq0DRsxujtYPgyJ676yQ8jEm6zzaaWHFDg5BNcLuif0eD2MTyJdZqXpdg==",
      "license": "MIT",
      "engines": {
        "node": ">=0.10"
      }
    },
    "node_modules/streamsearch": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/streamsearch/-/streamsearch-1.1.0.tgz",
      "integrity": "sha512-Mcc5wHehp9aXz1ax6bZUyY5afg9u2rv5cqQI3mRrYkGC8rW2hM02jWuwjtL++LS5qinSyhj2QfLyNsuc+VsExg==",
      "engines": {
        "node": ">=10.0.0"
      }
    },
    "node_modules/string_decoder": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.1.1.tgz",
      "integrity": "sha512-n/ShnvDi6FHbbVfviro+WojiFzv+s8MPMHBczVePfUpDJLwoLT0ht1l4YwBCbi8pJAveEEdnkHyPyTP/mzRfwg==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "~5.1.0"
      }
    },
    "node_modules/string_decoder/node_modules/safe-buffer": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
      "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
      "license": "MIT"
    },
    "node_modules/string-width": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-5.1.2.tgz",
      "integrity": "sha512-HnLOCR3vjcY8beoNLtcjZ5/nxn2afmME6lhrDrebokqMap+XbeW8n9TXpPDOqdGK5qcI3oT0GKTW6wC7EMiVqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "eastasianwidth": "^0.2.0",
        "emoji-regex": "^9.2.2",
        "strip-ansi": "^7.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/string-width-cjs": {
      "name": "string-width",
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/string-width/node_modules/ansi-regex": {
      "version": "6.1.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.1.0.tgz",
      "integrity": "sha512-7HSX4QQb4CspciLpVFwyRe79O3xsIZDDLER21kERQ71oaPodF8jL725AgJMFAYbooIqolJoRLuM81SpeUkpkvA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
      }
    },
    "node_modules/string-width/node_modules/emoji-regex": {
      "version": "9.2.2",
      "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-9.2.2.tgz",
      "integrity": "sha512-L18DaJsXSUk2+42pv8mLs5jJT2hqFkFE4j21wOmgbUqsZ2hL72NsUU785g9RXgo3s0ZNgVl42TiHp3ZtOv/Vyg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/string-width/node_modules/strip-ansi": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.0.tgz",
      "integrity": "sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^6.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
      }
    },
    "node_modules/strip-ansi": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-ansi-cjs": {
      "name": "strip-ansi",
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
      "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/strip-bom": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/strip-bom/-/strip-bom-3.0.0.tgz",
      "integrity": "sha512-vavAMRXOgBVNF6nyEEmL3DBK19iRpDcoIwW+swQ+CbGiu7lju6t+JklA1MHweoWtadgt4ISVUsXLyDq34ddcwA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/strip-json-comments": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-2.0.1.tgz",
      "integrity": "sha512-4gB8na07fecVVkOI6Rs4e7T6NOTki5EmL7TUduTs6bu3EdnSycntVJ4re8kgZA+wx9IueI2Y11bfbgwtzuE0KQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/strtok3": {
      "version": "10.2.2",
      "resolved": "https://registry.npmjs.org/strtok3/-/strtok3-10.2.2.tgz",
      "integrity": "sha512-Xt18+h4s7Z8xyZ0tmBoRmzxcop97R4BAh+dXouUDCYn+Em+1P3qpkUfI5ueWLT8ynC5hZ+q4iPEmGG1urvQGBg==",
      "license": "MIT",
      "dependencies": {
        "@tokenizer/token": "^0.3.0",
        "peek-readable": "^7.0.0"
      },
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/Borewit"
      }
    },
    "node_modules/superagent": {
      "version": "10.2.1",
      "resolved": "https://registry.npmjs.org/superagent/-/superagent-10.2.1.tgz",
      "integrity": "sha512-O+PCv11lgTNJUzy49teNAWLjBZfc+A1enOwTpLlH6/rsvKcTwcdTT8m9azGkVqM7HBl5jpyZ7KTPhHweokBcdg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "component-emitter": "^1.3.0",
        "cookiejar": "^2.1.4",
        "debug": "^4.3.4",
        "fast-safe-stringify": "^2.1.1",
        "form-data": "^4.0.0",
        "formidable": "^3.5.4",
        "methods": "^1.1.2",
        "mime": "2.6.0",
        "qs": "^6.11.0"
      },
      "engines": {
        "node": ">=14.18.0"
      }
    },
    "node_modules/superagent/node_modules/mime": {
      "version": "2.6.0",
      "resolved": "https://registry.npmjs.org/mime/-/mime-2.6.0.tgz",
      "integrity": "sha512-USPkMeET31rOMiarsBNIHZKLGgvKc/LrjofAnBlOttf5ajRvqiRA8QsenbcooctK6d6Ts6aqZXBA+XbkKthiQg==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "mime": "cli.js"
      },
      "engines": {
        "node": ">=4.0.0"
      }
    },
    "node_modules/superagent/node_modules/qs": {
      "version": "6.14.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.14.0.tgz",
      "integrity": "sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/supertest": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/supertest/-/supertest-7.1.1.tgz",
      "integrity": "sha512-aI59HBTlG9e2wTjxGJV+DygfNLgnWbGdZxiA/sgrnNNikIW8lbDvCtF6RnhZoJ82nU7qv7ZLjrvWqCEm52fAmw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "methods": "^1.1.2",
        "superagent": "^10.2.1"
      },
      "engines": {
        "node": ">=14.18.0"
      }
    },
    "node_modules/supports-color": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
      "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^3.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/supports-preserve-symlinks-flag": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/supports-preserve-symlinks-flag/-/supports-preserve-symlinks-flag-1.0.0.tgz",
      "integrity": "sha512-ot0WnXS9fgdkgIcePe6RHNk1WA8+muPa6cSjeR3V8K27q9BB1rTE3R1p7Hv0z1ZyAc8s6Vvv8DIyWf681MAt0w==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/swagger-jsdoc": {
      "version": "6.2.8",
      "resolved": "https://registry.npmjs.org/swagger-jsdoc/-/swagger-jsdoc-6.2.8.tgz",
      "integrity": "sha512-VPvil1+JRpmJ55CgAtn8DIcpBs0bL5L3q5bVQvF4tAW/k/9JYSj7dCpaYCAv5rufe0vcCbBRQXGvzpkWjvLklQ==",
      "license": "MIT",
      "dependencies": {
        "commander": "6.2.0",
        "doctrine": "3.0.0",
        "glob": "7.1.6",
        "lodash.mergewith": "^4.6.2",
        "swagger-parser": "^10.0.3",
        "yaml": "2.0.0-1"
      },
      "bin": {
        "swagger-jsdoc": "bin/swagger-jsdoc.js"
      },
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/swagger-parser": {
      "version": "10.0.3",
      "resolved": "https://registry.npmjs.org/swagger-parser/-/swagger-parser-10.0.3.tgz",
      "integrity": "sha512-nF7oMeL4KypldrQhac8RyHerJeGPD1p2xDh900GPvc+Nk7nWP6jX2FcC7WmkinMoAmoO774+AFXcWsW8gMWEIg==",
      "license": "MIT",
      "dependencies": {
        "@apidevtools/swagger-parser": "10.0.3"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/swagger-ui-dist": {
      "version": "5.24.0",
      "resolved": "https://registry.npmjs.org/swagger-ui-dist/-/swagger-ui-dist-5.24.0.tgz",
      "integrity": "sha512-okwN8vf14TOgBTUyGgCXEAoHnrwwp/042dC00B3kPu2OAe9zD75BtSbLlgAK1Y5e3csJhs+AdnIxJYZN9uvptg==",
      "license": "Apache-2.0",
      "dependencies": {
        "@scarf/scarf": "=1.4.0"
      }
    },
    "node_modules/swagger-ui-express": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/swagger-ui-express/-/swagger-ui-express-5.0.1.tgz",
      "integrity": "sha512-SrNU3RiBGTLLmFU8GIJdOdanJTl4TOmT27tt3bWWHppqYmAZ6IDuEuBvMU6nZq0zLEe6b/1rACXCgLZqO6ZfrA==",
      "license": "MIT",
      "dependencies": {
        "swagger-ui-dist": ">=5.0.0"
      },
      "engines": {
        "node": ">= v0.10.32"
      },
      "peerDependencies": {
        "express": ">=4.0.0 || >=5.0.0-beta"
      }
    },
    "node_modules/test-exclude": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/test-exclude/-/test-exclude-7.0.1.tgz",
      "integrity": "sha512-pFYqmTw68LXVjeWJMST4+borgQP2AyMNbg1BpZh9LbyhUeNkeaPF9gzfPGUAnSMV3qPYdWUwDIjjCLiSDOl7vg==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "@istanbuljs/schema": "^0.1.2",
        "glob": "^10.4.1",
        "minimatch": "^9.0.4"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/test-exclude/node_modules/brace-expansion": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-2.0.1.tgz",
      "integrity": "sha512-XnAIvQ8eM+kC6aULx6wuQiwVsnzsi9d3WxzV3FpWTGA19F621kwdbsAcFKXgKUHZWsy+mY6iL1sHTxWEFCytDA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0"
      }
    },
    "node_modules/test-exclude/node_modules/glob": {
      "version": "10.4.5",
      "resolved": "https://registry.npmjs.org/glob/-/glob-10.4.5.tgz",
      "integrity": "sha512-7Bv8RF0k6xjo7d4A/PxYLbUCfb6c+Vpd2/mB2yRDlew7Jb5hEXiCD9ibfO7wpk8i4sevK6DFny9h7EYbM3/sHg==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "foreground-child": "^3.1.0",
        "jackspeak": "^3.1.2",
        "minimatch": "^9.0.4",
        "minipass": "^7.1.2",
        "package-json-from-dist": "^1.0.0",
        "path-scurry": "^1.11.1"
      },
      "bin": {
        "glob": "dist/esm/bin.mjs"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/test-exclude/node_modules/minimatch": {
      "version": "9.0.5",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-9.0.5.tgz",
      "integrity": "sha512-G6T0ZX48xgozx7587koeX9Ys2NYy6Gmv//P89sEte9V9whIapMNF4idKxnW2QtCcLiTWlb/wfCabAtAFWhhBow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^2.0.1"
      },
      "engines": {
        "node": ">=16 || 14 >=14.17"
      },
      "funding": {
        "url": "https://github.com/sponsors/isaacs"
      }
    },
    "node_modules/tinybench": {
      "version": "2.9.0",
      "resolved": "https://registry.npmjs.org/tinybench/-/tinybench-2.9.0.tgz",
      "integrity": "sha512-0+DUvqWMValLmha6lr4kD8iAMK1HzV0/aKnCtWb9v9641TnP/MFb7Pc2bxoxQjTXAErryXVgUOfv2YqNllqGeg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tinyexec": {
      "version": "0.3.2",
      "resolved": "https://registry.npmjs.org/tinyexec/-/tinyexec-0.3.2.tgz",
      "integrity": "sha512-KQQR9yN7R5+OSwaK0XQoj22pwHoTlgYqmUscPYoknOoWCWfj/5/ABTMRi69FrKU5ffPVh5QcFikpWJI/P1ocHA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tinypool": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/tinypool/-/tinypool-1.1.0.tgz",
      "integrity": "sha512-7CotroY9a8DKsKprEy/a14aCCm8jYVmR7aFy4fpkZM8sdpNJbKkixuNjgM50yCmip2ezc8z4N7k3oe2+rfRJCQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      }
    },
    "node_modules/tinyrainbow": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/tinyrainbow/-/tinyrainbow-1.2.0.tgz",
      "integrity": "sha512-weEDEq7Z5eTHPDh4xjX789+fHfF+P8boiFB+0vbWzpbnbsEr/GRaohi/uMKxg8RZMXnl1ItAi/IUHWMsjDV7kQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/tinyspy": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/tinyspy/-/tinyspy-3.0.2.tgz",
      "integrity": "sha512-n1cw8k1k0x4pgA2+9XrOkFydTerNcJ1zWCO5Nn9scWHTD+5tp8dghT2x1uduQePZTZgd3Tupf+x9BxJjeJi77Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/token-types": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/token-types/-/token-types-6.0.0.tgz",
      "integrity": "sha512-lbDrTLVsHhOMljPscd0yitpozq7Ga2M5Cvez5AjGg8GASBjtt6iERCAJ93yommPmz62fb45oFIXHEZ3u9bfJEA==",
      "license": "MIT",
      "dependencies": {
        "@tokenizer/token": "^0.3.0",
        "ieee754": "^1.2.1"
      },
      "engines": {
        "node": ">=14.16"
      },
      "funding": {
        "type": "github",
        "url": "https://github.com/sponsors/Borewit"
      }
    },
    "node_modules/touch": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/touch/-/touch-3.1.1.tgz",
      "integrity": "sha512-r0eojU4bI8MnHr8c5bNo7lJDdI2qXlWWJk6a9EAFG7vbhTjElYhBVS3/miuE0uOuoLdb8Mc/rVfsmm6eo5o9GA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "nodetouch": "bin/nodetouch.js"
      }
    },
    "node_modules/tree-kill": {
      "version": "1.2.2",
      "resolved": "https://registry.npmjs.org/tree-kill/-/tree-kill-1.2.2.tgz",
      "integrity": "sha512-L0Orpi8qGpRG//Nd+H90vFB+3iHnue1zSSGmNOOCh1GLJ7rUKVwV2HvijphGQS2UmhUZewS9VgvxYIdgr+fG1A==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "tree-kill": "cli.js"
      }
    },
    "node_modules/ts-node": {
      "version": "10.9.2",
      "resolved": "https://registry.npmjs.org/ts-node/-/ts-node-10.9.2.tgz",
      "integrity": "sha512-f0FFpIdcHgn8zcPSbf1dRevwt047YMnaiJM3u2w2RewrB+fob/zePZcrOyQoLMMO7aBIddLcQIEK5dYjkLnGrQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@cspotcode/source-map-support": "^0.8.0",
        "@tsconfig/node10": "^1.0.7",
        "@tsconfig/node12": "^1.0.7",
        "@tsconfig/node14": "^1.0.0",
        "@tsconfig/node16": "^1.0.2",
        "acorn": "^8.4.1",
        "acorn-walk": "^8.1.1",
        "arg": "^4.1.0",
        "create-require": "^1.1.0",
        "diff": "^4.0.1",
        "make-error": "^1.1.1",
        "v8-compile-cache-lib": "^3.0.1",
        "yn": "3.1.1"
      },
      "bin": {
        "ts-node": "dist/bin.js",
        "ts-node-cwd": "dist/bin-cwd.js",
        "ts-node-esm": "dist/bin-esm.js",
        "ts-node-script": "dist/bin-script.js",
        "ts-node-transpile-only": "dist/bin-transpile.js",
        "ts-script": "dist/bin-script-deprecated.js"
      },
      "peerDependencies": {
        "@swc/core": ">=1.2.50",
        "@swc/wasm": ">=1.2.50",
        "@types/node": "*",
        "typescript": ">=2.7"
      },
      "peerDependenciesMeta": {
        "@swc/core": {
          "optional": true
        },
        "@swc/wasm": {
          "optional": true
        }
      }
    },
    "node_modules/ts-node-dev": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ts-node-dev/-/ts-node-dev-2.0.0.tgz",
      "integrity": "sha512-ywMrhCfH6M75yftYvrvNarLEY+SUXtUvU8/0Z6llrHQVBx12GiFk5sStF8UdfE/yfzk9IAq7O5EEbTQsxlBI8w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chokidar": "^3.5.1",
        "dynamic-dedupe": "^0.3.0",
        "minimist": "^1.2.6",
        "mkdirp": "^1.0.4",
        "resolve": "^1.0.0",
        "rimraf": "^2.6.1",
        "source-map-support": "^0.5.12",
        "tree-kill": "^1.2.2",
        "ts-node": "^10.4.0",
        "tsconfig": "^7.0.0"
      },
      "bin": {
        "ts-node-dev": "lib/bin.js",
        "tsnd": "lib/bin.js"
      },
      "engines": {
        "node": ">=0.8.0"
      },
      "peerDependencies": {
        "node-notifier": "*",
        "typescript": "*"
      },
      "peerDependenciesMeta": {
        "node-notifier": {
          "optional": true
        }
      }
    },
    "node_modules/ts-node-dev/node_modules/mkdirp": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-1.0.4.tgz",
      "integrity": "sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==",
      "dev": true,
      "license": "MIT",
      "bin": {
        "mkdirp": "bin/cmd.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/tsconfig": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/tsconfig/-/tsconfig-7.0.0.tgz",
      "integrity": "sha512-vZXmzPrL+EmC4T/4rVlT2jNVMWCi/O4DIiSj3UHg1OE5kCKbk4mfrXc6dZksLgRM/TZlKnousKH9bbTazUWRRw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/strip-bom": "^3.0.0",
        "@types/strip-json-comments": "0.0.30",
        "strip-bom": "^3.0.0",
        "strip-json-comments": "^2.0.0"
      }
    },
    "node_modules/tslib": {
      "version": "2.8.1",
      "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.8.1.tgz",
      "integrity": "sha512-oJFu94HQb+KVduSUQL7wnpmqnfmLsOA/nAh6b6EH0wCEoK0/mPeXU6c3wKDV83MkOuHPRHtSXKKU99IBazS/2w==",
      "license": "0BSD"
    },
    "node_modules/type-is": {
      "version": "1.6.18",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
      "license": "MIT",
      "dependencies": {
        "media-typer": "0.3.0",
        "mime-types": "~2.1.24"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/typedarray": {
      "version": "0.0.6",
      "resolved": "https://registry.npmjs.org/typedarray/-/typedarray-0.0.6.tgz",
      "integrity": "sha512-/aCDEGatGvZ2BIk+HmLf4ifCJFwvKFNb9/JeZPMulfgFracn9QFcAf5GO8B/mweUjSoblS5In0cWhqpfs/5PQA==",
      "license": "MIT"
    },
    "node_modules/typescript": {
      "version": "5.8.3",
      "resolved": "https://registry.npmjs.org/typescript/-/typescript-5.8.3.tgz",
      "integrity": "sha512-p1diW6TqL9L07nNxvRMM7hMMw4c5XOo/1ibL4aAIGmSAt9slTE1Xgw5KWuof2uTOvCg9BY7ZRi+GaF+7sfgPeQ==",
      "devOptional": true,
      "license": "Apache-2.0",
      "bin": {
        "tsc": "bin/tsc",
        "tsserver": "bin/tsserver"
      },
      "engines": {
        "node": ">=14.17"
      }
    },
    "node_modules/uid": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/uid/-/uid-2.0.2.tgz",
      "integrity": "sha512-u3xV3X7uzvi5b1MncmZo3i2Aw222Zk1keqLA1YkHldREkAhAqi65wuPfe7lHx8H/Wzy+8CE7S7uS3jekIM5s8g==",
      "license": "MIT",
      "dependencies": {
        "@lukeed/csprng": "^1.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/uint8array-extras": {
      "version": "1.4.0",
      "resolved": "https://registry.npmjs.org/uint8array-extras/-/uint8array-extras-1.4.0.tgz",
      "integrity": "sha512-ZPtzy0hu4cZjv3z5NW9gfKnNLjoz4y6uv4HlelAjDK7sY/xOkKZv9xK/WQpcsBB3jEybChz9DPC2U/+cusjJVQ==",
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/undefsafe": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/undefsafe/-/undefsafe-2.0.5.tgz",
      "integrity": "sha512-WxONCrssBM8TSPRqN5EmsjVrsv4A8X12J4ArBiiayv3DyyG3ZlIg6yysuuSYdZsVz3TKcTg2fd//Ujd4CHV1iA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/undici-types": {
      "version": "6.19.8",
      "resolved": "https://registry.npmjs.org/undici-types/-/undici-types-6.19.8.tgz",
      "integrity": "sha512-ve2KP6f/JnbPBFyobGHuerC9g1FYGn/F8n1LWTwNxCEzd6IfqTwUQcNXgEtmmQ6DlRrC1hrSrBnCZPokRrDHjw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "license": "MIT"
    },
    "node_modules/utils-merge": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
      "integrity": "sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/uuid": {
      "version": "10.0.0",
      "resolved": "https://registry.npmjs.org/uuid/-/uuid-10.0.0.tgz",
      "integrity": "sha512-8XkAphELsDnEGrDxUOHB3RGvXz6TeuYSGEZBOjtTtPm2lwhGBjLgOzLHB63IUWfBpNucQjND6d3AOudO+H3RWQ==",
      "funding": [
        "https://github.com/sponsors/broofa",
        "https://github.com/sponsors/ctavan"
      ],
      "license": "MIT",
      "bin": {
        "uuid": "dist/bin/uuid"
      }
    },
    "node_modules/v8-compile-cache-lib": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/v8-compile-cache-lib/-/v8-compile-cache-lib-3.0.1.tgz",
      "integrity": "sha512-wa7YjyUGfNZngI/vtK0UHAN+lgDCxBPCylVXGp0zu59Fz5aiGtNXaq3DhIov063MorB+VfufLh3JlF2KdTK3xg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/validator": {
      "version": "13.15.15",
      "resolved": "https://registry.npmjs.org/validator/-/validator-13.15.15.tgz",
      "integrity": "sha512-BgWVbCI72aIQy937xbawcs+hrVaN/CZ2UwutgaJ36hGqRrLNM+f5LUT/YPRbo8IV/ASeFzXszezV+y2+rq3l8A==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/vite": {
      "version": "5.4.19",
      "resolved": "https://registry.npmjs.org/vite/-/vite-5.4.19.tgz",
      "integrity": "sha512-qO3aKv3HoQC8QKiNSTuUM1l9o/XX3+c+VTgLHbJWHZGeTPVAg2XwazI9UWzoxjIJCGCV2zU60uqMzjeLZuULqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.21.3",
        "postcss": "^8.4.43",
        "rollup": "^4.20.0"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || >=20.0.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.4.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        }
      }
    },
    "node_modules/vite-node": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/vite-node/-/vite-node-2.1.9.tgz",
      "integrity": "sha512-AM9aQ/IPrW/6ENLQg3AGY4K1N2TGZdR5e4gu/MmmR2xR3Ll1+dib+nook92g4TV3PXVyeyxdWwtaCAiUL0hMxA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cac": "^6.7.14",
        "debug": "^4.3.7",
        "es-module-lexer": "^1.5.4",
        "pathe": "^1.1.2",
        "vite": "^5.0.0"
      },
      "bin": {
        "vite-node": "vite-node.mjs"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/vitest": {
      "version": "2.1.9",
      "resolved": "https://registry.npmjs.org/vitest/-/vitest-2.1.9.tgz",
      "integrity": "sha512-MSmPM9REYqDGBI8439mA4mWhV5sKmDlBKWIYbA3lRb2PTHACE0mgKwA8yQ2xq9vxDTuk4iPrECBAEW2aoFXY0Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/expect": "2.1.9",
        "@vitest/mocker": "2.1.9",
        "@vitest/pretty-format": "^2.1.9",
        "@vitest/runner": "2.1.9",
        "@vitest/snapshot": "2.1.9",
        "@vitest/spy": "2.1.9",
        "@vitest/utils": "2.1.9",
        "chai": "^5.1.2",
        "debug": "^4.3.7",
        "expect-type": "^1.1.0",
        "magic-string": "^0.30.12",
        "pathe": "^1.1.2",
        "std-env": "^3.8.0",
        "tinybench": "^2.9.0",
        "tinyexec": "^0.3.1",
        "tinypool": "^1.0.1",
        "tinyrainbow": "^1.2.0",
        "vite": "^5.0.0",
        "vite-node": "2.1.9",
        "why-is-node-running": "^2.3.0"
      },
      "bin": {
        "vitest": "vitest.mjs"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "@edge-runtime/vm": "*",
        "@types/node": "^18.0.0 || >=20.0.0",
        "@vitest/browser": "2.1.9",
        "@vitest/ui": "2.1.9",
        "happy-dom": "*",
        "jsdom": "*"
      },
      "peerDependenciesMeta": {
        "@edge-runtime/vm": {
          "optional": true
        },
        "@types/node": {
          "optional": true
        },
        "@vitest/browser": {
          "optional": true
        },
        "@vitest/ui": {
          "optional": true
        },
        "happy-dom": {
          "optional": true
        },
        "jsdom": {
          "optional": true
        }
      }
    },
    "node_modules/which": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
      "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "isexe": "^2.0.0"
      },
      "bin": {
        "node-which": "bin/node-which"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/why-is-node-running": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/why-is-node-running/-/why-is-node-running-2.3.0.tgz",
      "integrity": "sha512-hUrmaWBdVDcxvYqnyh09zunKzROWjbZTiNy8dBEjkS7ehEDQibXJ7XvlmtbwuTclUiIyN+CyXQD4Vmko8fNm8w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "siginfo": "^2.0.0",
        "stackback": "0.0.2"
      },
      "bin": {
        "why-is-node-running": "cli.js"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/wrap-ansi": {
      "version": "8.1.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-8.1.0.tgz",
      "integrity": "sha512-si7QWI6zUMq56bESFvagtmzMdGOtoxfR+Sez11Mobfc7tm+VkUckk9bW2UeffTGVUbOksxmSw0AA2gs8g71NCQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^6.1.0",
        "string-width": "^5.0.1",
        "strip-ansi": "^7.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrap-ansi-cjs": {
      "name": "wrap-ansi",
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
      "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-styles": "^4.0.0",
        "string-width": "^4.1.0",
        "strip-ansi": "^6.0.0"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
      }
    },
    "node_modules/wrap-ansi-cjs/node_modules/string-width": {
      "version": "4.2.3",
      "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
      "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "emoji-regex": "^8.0.0",
        "is-fullwidth-code-point": "^3.0.0",
        "strip-ansi": "^6.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/wrap-ansi/node_modules/ansi-regex": {
      "version": "6.1.0",
      "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-6.1.0.tgz",
      "integrity": "sha512-7HSX4QQb4CspciLpVFwyRe79O3xsIZDDLER21kERQ71oaPodF8jL725AgJMFAYbooIqolJoRLuM81SpeUkpkvA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-regex?sponsor=1"
      }
    },
    "node_modules/wrap-ansi/node_modules/ansi-styles": {
      "version": "6.2.1",
      "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-6.2.1.tgz",
      "integrity": "sha512-bN798gFfQX+viw3R7yrGWRqnrN2oRkEkUjjl4JNn4E8GxxbjtG3FbrEIIY3l8/hrwUwIeCZvi4QuOTP4MErVug==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/ansi-styles?sponsor=1"
      }
    },
    "node_modules/wrap-ansi/node_modules/strip-ansi": {
      "version": "7.1.0",
      "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-7.1.0.tgz",
      "integrity": "sha512-iq6eVVI64nQQTRYq2KtEg2d2uU7LElhTJwsH4YzIHZshxlgZms/wIc4VoDQTlG/IvVIrBKG06CrZnp0qv7hkcQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ansi-regex": "^6.0.1"
      },
      "engines": {
        "node": ">=12"
      },
      "funding": {
        "url": "https://github.com/chalk/strip-ansi?sponsor=1"
      }
    },
    "node_modules/wrappy": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
      "integrity": "sha512-l4Sp/DRseor9wL6EvV2+TuQn63dMkPjZ/sp9XkghTEbV9KlPS1xUsZ3u7/IQO4wxtcFB4bgpQPRcR3QCvezPcQ==",
      "license": "ISC"
    },
    "node_modules/xtend": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/xtend/-/xtend-4.0.2.tgz",
      "integrity": "sha512-LKYU1iAXJXUgAXn9URjiu+MWhyUXHsvfp7mcuYm9dSUKK0/CjtrUwFAxD82/mCWbtLsGjFIad0wIsod4zrTAEQ==",
      "license": "MIT",
      "engines": {
        "node": ">=0.4"
      }
    },
    "node_modules/yaml": {
      "version": "2.0.0-1",
      "resolved": "https://registry.npmjs.org/yaml/-/yaml-2.0.0-1.tgz",
      "integrity": "sha512-W7h5dEhywMKenDJh2iX/LABkbFnBxasD27oyXWDS/feDsxiw0dD5ncXdYXgkvAsXIY2MpW/ZKkr9IU30DBdMNQ==",
      "license": "ISC",
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/yn": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/yn/-/yn-3.1.1.tgz",
      "integrity": "sha512-Ux4ygGWsu2c7isFWe8Yu1YluJmqVhxqK2cLXNQA5AcC3QfbGNpM7fu0Y8b/z16pXLnFxZYvWhd3fhBY9DLmC6Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/z-schema": {
      "version": "5.0.6",
      "resolved": "https://registry.npmjs.org/z-schema/-/z-schema-5.0.6.tgz",
      "integrity": "sha512-+XR1GhnWklYdfr8YaZv/iu+vY+ux7V5DS5zH1DQf6bO5ufrt/5cgNhVO5qyhsjFXvsqQb/f08DWE9b6uPscyAg==",
      "license": "MIT",
      "dependencies": {
        "lodash.get": "^4.4.2",
        "lodash.isequal": "^4.5.0",
        "validator": "^13.7.0"
      },
      "bin": {
        "z-schema": "bin/z-schema"
      },
      "engines": {
        "node": ">=8.0.0"
      },
      "optionalDependencies": {
        "commander": "^10.0.0"
      }
    },
    "node_modules/z-schema/node_modules/commander": {
      "version": "10.0.1",
      "resolved": "https://registry.npmjs.org/commander/-/commander-10.0.1.tgz",
      "integrity": "sha512-y4Mg2tXshplEbSGzx7amzPwKKOCGuoSRP/CjEdwwk0FOGlUbq6lKuoyDZTNZkmxHdJtp54hdfY/JUrdL7Xfdug==",
      "license": "MIT",
      "optional": true,
      "engines": {
        "node": ">=14"
      }
    }
  }
}



// ====== [12] backend/package.json ======
{
  "name": "backend",
  "version": "1.15.0",
  "main": "dist/index.js",
  "license": "SEE LICENSE IN ../LICENSE.md",
  "scripts": {
    "build": "npx tsc",
    "start": "node dist/index.js",
    "dev:build": "npx tsc --watch",
    "dev:run": "npx nodemon dist/index.js",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "db:seed": "ts-node --compiler-options \"{\\\"module\\\":\\\"commonjs\\\"}\" prisma/seed.ts"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "dependencies": {
    "@nestjs/common": "^11.1.2",
    "@nestjs/core": "^11.1.2",
    "@prisma/client": "^6.6.0",
    "@types/multer": "^1.4.12",
    "@types/node-cron": "^3.0.11",
    "@types/streamifier": "^0.1.2",
    "bcryptjs": "^2.4.3",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.2",
    "cloudinary": "^2.6.0",
    "cors": "^2.8.5",
    "date-fns": "^3.6.0",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.2",
    "node-cron": "^3.0.3",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.2",
    "streamifier": "^0.1.1",
    "swagger-jsdoc": "^6.2.8",
    "swagger-ui-express": "^5.0.1",
    "uuid": "^10.0.0"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cors": "^2.8.17",
    "@types/date-fns": "^2.6.0",
    "@types/dotenv": "^8.2.0",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/node": "^20.14.10",
    "@types/supertest": "^6.0.2",
    "@types/swagger-jsdoc": "^6.0.4",
    "@types/swagger-ui-express": "^4.1.8",
    "@types/uuid": "^10.0.0",
    "@vitest/coverage-v8": "^2.0.4",
    "nodemon": "^3.1.4",
    "prisma": "^6.6.0",
    "supertest": "^7.0.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.5.3",
    "vitest": "^2.0.4"
  },
  "resolutions": {
    "@types/express": "^4.17.21",
    "@types/express-serve-static-core": "^4.17.42"
  }
}



// ====== [13] backend/prisma/seed.ts ======
// backend/prisma/seed.ts
// Versi√≥n: 20250617_ADD_RANDOM_SUFFIX
/// <reference types="node" />

import {
    PrismaClient, UserRole, DocumentType, TierCalculationBasis, TierDowngradePolicy,
    Prisma, QrCodeStatus, ActivityType, OrderStatus, OrderItemStatus, OrderType,
    TableStatus
} from '@prisma/client';
import bcrypt from 'bcryptjs';
import { v4 as uuidv4 } from 'uuid';
import { subDays, startOfDay, endOfDay, eachDayOfInterval, formatISO, subMinutes, addMinutes, subHours } from 'date-fns';

const prisma = new PrismaClient();

enum SeedModifierUiType {
    RADIO = 'RADIO',
    CHECKBOX = 'CHECKBOX',
}

async function hashPassword(password: string): Promise<string> {
  const salt = await bcrypt.genSalt(10);
  return bcrypt.hash(password, salt);
}

async function main() {
  console.log(`[SEED V8.2 - Add Subscription Data & Random Suffix] Start seeding.`);

  const randomSuffix = Math.floor(Math.random() * 10000);
  const createdCategories: Record<string, Prisma.MenuCategoryGetPayload<{}>> = {};
  const createdMenuItems: Record<string, Prisma.MenuItemGetPayload<{ include: { category: true } }>> = {};
  const createdTables: Record<string, Prisma.TableGetPayload<{}>> = {};
  const createdModOptionsPunto: Record<string, Prisma.ModifierOptionGetPayload<{}>> = {};
  const createdModOptionsExtras: Record<string, Prisma.ModifierOptionGetPayload<{}>> = {};
  let camareroDemoUser: Prisma.UserGetPayload<{ select: { id: true } }> | null = null;


  // --- Creaci√≥n de Business, Admin, Customers, Tiers, Rewards LCo, MenuCategories, MenuItems, Tables, Staff ---
  const demoBusinessName = 'Restaurante Demo LoyalPyME'; 
  const demoBusinessSlug = 'restaurante-demo-loyalpyme'; 
  
  const demoBusiness = await prisma.business.upsert({ 
    where: { slug: demoBusinessSlug }, 
    update: { 
      name: demoBusinessName, 
      pointsPerEuro: 1.0, 
      tierSystemEnabled: true, 
      tierCalculationBasis: TierCalculationBasis.SPEND, 
      tierCalculationPeriodMonths: 0, 
      tierDowngradePolicy: TierDowngradePolicy.PERIODIC_REVIEW, 
      inactivityPeriodMonths: 6, 
      isActive: true, 
      isLoyaltyCoreActive: true, 
      isCamareroActive: true, 
      logoUrl: 'https://res.cloudinary.com/dq8e13lmr/image/upload/v1710860730/loyalpyme/assets/default_business_logo_vzg0sa.png', 
      brandingColorPrimary: '#228BE6', 
      brandingColorSecondary: '#495057', 
      qrCodeExpirationMinutes: 30,
      monthlyPrice: 49.99,
      currency: "EUR"
    }, 
    create: { 
      id: uuidv4(), 
      name: demoBusinessName, 
      slug: demoBusinessSlug, 
      pointsPerEuro: 1.0, 
      tierSystemEnabled: true, 
      tierCalculationBasis: TierCalculationBasis.SPEND, 
      tierCalculationPeriodMonths: 0, 
      tierDowngradePolicy: TierDowngradePolicy.PERIODIC_REVIEW, 
      inactivityPeriodMonths: 6, 
      isActive: true, 
      isLoyaltyCoreActive: true, 
      isCamareroActive: true, 
      logoUrl: 'https://res.cloudinary.com/dq8e13lmr/image/upload/v1710860730/loyalpyme/assets/default_business_logo_vzg0sa.png', 
      brandingColorPrimary: '#228BE6', 
      brandingColorSecondary: '#495057', 
      qrCodeExpirationMinutes: 30,
      monthlyPrice: 49.99,
      currency: "EUR"
    }, 
  }); 
  console.log(`[SEED] Upserted Demo Business: ${demoBusiness.name} (ID: ${demoBusiness.id})`);
  
  const adminEmail = 'admin@demo.com'; const hashedAdminPassword = await hashPassword('password'); const demoAdminForGift = await prisma.user.upsert({ where: { email: adminEmail }, update: { password: hashedAdminPassword, name: 'Admin Demo', role: UserRole.BUSINESS_ADMIN, businessId: demoBusiness.id, isActive: true, }, create: { email: adminEmail, password: hashedAdminPassword, name: 'Admin Demo', phone: '+34000000001', documentId: '00000001A', documentType: DocumentType.DNI, role: UserRole.BUSINESS_ADMIN, businessId: demoBusiness.id, isActive: true, }, }); console.log(`[SEED] Upserted Demo Admin: ${adminEmail}`);
  const customer1Email = 'cliente@demo.com'; const hashedCustomer1Password = await hashPassword('password'); const demoCustomer1 = await prisma.user.upsert({ where: { email: customer1Email }, update: { password: hashedCustomer1Password, name: 'Cliente Demo 1', points: 150, totalSpend: 150.0, totalVisits: 3, lastActivityAt: new Date(), isActive: true, }, create: { email: customer1Email, password: hashedCustomer1Password, name: 'Cliente Demo 1', phone: '+34000000002', documentId: '00000002B', documentType: DocumentType.DNI, role: UserRole.CUSTOMER_FINAL, businessId: demoBusiness.id, points: 150, totalSpend: 150.0, totalVisits: 3, lastActivityAt: new Date(), isActive: true, }, }); console.log(`[SEED] Upserted Demo Customer 1: ${demoCustomer1.email}`);
  const customer2Email = 'cliente2@demo.com'; const customer3Email = 'cliente3.semana.pasada@demo.com'; const hashedCustomer2Password = await hashPassword('password'); await prisma.user.upsert({ where: { email: customer2Email }, update: { password: hashedCustomer2Password, name: 'Cliente Demo 2 Activo', isActive: true, }, create: { email: customer2Email, password: hashedCustomer2Password, name: 'Cliente Demo 2 Activo', phone: '+34000000003', documentId: '00000003C', documentType: DocumentType.DNI, role: UserRole.CUSTOMER_FINAL, businessId: demoBusiness.id, isActive: true, createdAt: subDays(new Date(), 3) }, }); console.log(`[SEED] Upserted Demo Customer 2: ${customer2Email}`); const hashedCustomer3Password = await hashPassword('password'); const demoCustomer3 = await prisma.user.upsert({ where: { email: customer3Email }, update: { password: hashedCustomer3Password, name: 'Cliente Semana Pasada', isActive: true, }, create: { email: customer3Email, password: hashedCustomer3Password, name: 'Cliente Semana Pasada', phone: '+34000000004', documentId: '00000004D', documentType: DocumentType.DNI, role: UserRole.CUSTOMER_FINAL, businessId: demoBusiness.id, isActive: true, createdAt: subDays(new Date(), 9) }, }); console.log(`[SEED] Upserted Demo Customer 3: ${demoCustomer3.email}`);
  const tiersDataSeed = [ { name: 'Bronce Demo', level: 1, minValue: 50, benefitsDescription: 'Peque√±os descuentos', description: 'Nivel inicial.' }, { name: 'Plata Demo', level: 2, minValue: 200, benefitsDescription: 'Descuentos y acceso', description: 'Nivel intermedio.' }, { name: 'Oro Demo', level: 3, minValue: 500, benefitsDescription: 'Grandes descuentos', description: 'Nivel superior.' }, ]; for (const tierData of tiersDataSeed) { await prisma.tier.upsert({ where: { businessId_level: { businessId: demoBusiness.id, level: tierData.level } }, update: { name: tierData.name, minValue: tierData.minValue, description: tierData.description, benefitsDescription: tierData.benefitsDescription, isActive: true }, create: { ...tierData, businessId: demoBusiness.id, isActive: true }, }); } console.log(`[SEED] Upserted Tiers for business ${demoBusiness.id}`);
  const rewardsLCoDataSeed = [ { name_es: 'Caf√© Gratis Demo LCo', name_en: 'Free Coffee Demo LCo', pointsCost: 50, imageUrl: 'https://source.unsplash.com/random/300x300/?coffee', description_es: 'Un delicioso caf√© por tus puntos.', description_en: 'A delicious coffee for your points.', isActive: true }, { name_es: 'Descuento 10% LCo', name_en: '10% Discount LCo', pointsCost: 100, isActive: true, description_es: 'Obt√©n un 10% de descuento en tu pr√≥xima compra.', description_en: 'Get a 10% discount on your next purchase.' }, ]; let cafeLCoRewardIdSeed: string | undefined; for (const rewardData of rewardsLCoDataSeed) { const existingReward = await prisma.reward.findFirst({ where: { businessId: demoBusiness.id, name_es: rewardData.name_es, } }); let r: Prisma.RewardGetPayload<{}>; if (existingReward) { r = await prisma.reward.update({ where: { id: existingReward.id }, data: { name_en: rewardData.name_en, pointsCost: rewardData.pointsCost, imageUrl: rewardData.imageUrl, isActive: rewardData.isActive !== undefined ? rewardData.isActive : true, description_es: rewardData.description_es, description_en: rewardData.description_en, }, }); } else { r = await prisma.reward.create({ data: { ...rewardData, businessId: demoBusiness.id, }, }); } if (rewardData.name_es?.includes('Caf√©')) cafeLCoRewardIdSeed = r.id; } console.log(`[SEED] Processed LCo Rewards for business ${demoBusiness.id}`);
  console.log(`[SEED] Creating Digital Menu for business ${demoBusiness.id}...`); const menuCategoriesDataSeed = [ { name_es: "Entrantes Demo", name_en: "Starters Demo", description_es: "Deliciosas opciones para comenzar", description_en: "Delicious options to start", imageUrl: "https://source.unsplash.com/random/400x400/?appetizer", position: 0, isActive: true }, { name_es: "Platos Principales Demo", name_en: "Main Courses Demo", description_es: "Nuestra selecci√≥n de platos fuertes", description_en: "Our selection of main dishes", imageUrl: "https://source.unsplash.com/random/400x400/?main,course", position: 1, isActive: true }, { name_es: "Postres Demo", name_en: "Desserts Demo", description_es: "Dulces tentaciones para finalizar", description_en: "Sweet temptations to finish", imageUrl: "https://source.unsplash.com/random/400x400/?dessert", position: 2, isActive: true }, { name_es: "Bebidas Demo", name_en: "Drinks Demo", description_es: "Refrescantes opciones para acompa√±ar", description_en: "Refreshing options to accompany", imageUrl: "https://source.unsplash.com/random/400x400/?drinks", position: 3, isActive: true }, ]; for (const catData of menuCategoriesDataSeed) { const category = await prisma.menuCategory.upsert({ where: { businessId_name_es: { businessId: demoBusiness.id, name_es: catData.name_es } }, update: { description_es:catData.description_es, description_en:catData.description_en, imageUrl:catData.imageUrl, position:catData.position, isActive: catData.isActive, name_en: catData.name_en }, create: { ...catData, businessId: demoBusiness.id } }); createdCategories[catData.name_es] = category; } console.log(`[SEED] Upserted Menu Categories: ${Object.values(createdCategories).map(c => c.name_es).join(', ')}`);
  const menuItemsDataSeed = [ { categoryName: "Entrantes Demo", name_es: "Croquetas Caseras Demo", name_en: "Homemade Croquettes Demo", price: new Prisma.Decimal(8.50), imageUrl: "https://source.unsplash.com/random/300x300/?croquettes", allergens: ["GLUTEN", "LACTOSE"], tags: ["POPULAR"], position: 0, isAvailable: true, kdsDestination: "COCINA", preparationTime: 10, description_es: "Croquetas cremosas de jam√≥n ib√©rico.", description_en:"Creamy Iberian ham croquettes." }, { categoryName: "Entrantes Demo", name_es: "Ensalada C√©sar Demo", name_en: "Caesar Salad Demo", description_es: "Pollo, lechuga, croutons, parmesano y nuestra salsa c√©sar especial.", description_en: "Chicken, lettuce, croutons, parmesan, and our special caesar dressing.", price: new Prisma.Decimal(10.00), imageUrl: "https://source.unsplash.com/random/300x300/?caesar,salad", allergens: ["GLUTEN", "LACTOSE", "FISH"], tags: [], position: 1, isAvailable: true, kdsDestination: "COCINA", preparationTime: 7 }, { categoryName: "Platos Principales Demo", idForModifiers: "itemHamburguesa", name_es: "Hamburguesa Gourmet Demo", name_en: "Gourmet Burger Demo", price: new Prisma.Decimal(12.75), imageUrl: "https://source.unsplash.com/random/300x300/?burger", description_es: "200g de ternera premium, queso cheddar, bacon crujiente, lechuga, tomate y salsa especial. Acompa√±ada de patatas fritas.", description_en: "200g premium beef, cheddar cheese, crispy bacon, lettuce, tomato, and special sauce. Served with french fries.", allergens: ["GLUTEN", "LACTOSE", "SESAME"], tags: ["HOUSE_SPECIAL"], position: 0, isAvailable: true, preparationTime: 15, calories: 850, sku: "BURG-GOURMET-001", kdsDestination: "COCINA" }, { categoryName: "Platos Principales Demo", name_es: "Salm√≥n a la Plancha Demo", name_en: "Grilled Salmon Demo", description_es: "Lomo de salm√≥n fresco a la plancha con guarnici√≥n de verduras de temporada.", description_en: "Grilled fresh salmon loin with a side of seasonal vegetables.", price: new Prisma.Decimal(15.00), imageUrl: "https://source.unsplash.com/random/300x300/?salmon,dish", allergens: ["FISH"], tags: [], position: 1, isAvailable: true, kdsDestination: "COCINA", preparationTime: 12 }, { categoryName: "Postres Demo", name_es: "Tarta de Queso Demo", name_en: "Cheesecake Demo", description_es: "Nuestra famosa tarta de queso casera con coulis de frutos rojos.", description_en: "Our famous homemade cheesecake with red berry coulis.", price: new Prisma.Decimal(6.00), imageUrl: "https://source.unsplash.com/random/300x300/?cheesecake", allergens: ["LACTOSE", "GLUTEN"], tags: ["POPULAR"], position: 0, isAvailable: true, kdsDestination: "COCINA", preparationTime: 5 }, { categoryName: "Bebidas Demo", name_es: "Refresco de Cola Demo", name_en: "Cola Drink Demo", description_es: "Lata de 33cl.", description_en: "33cl can.", price: new Prisma.Decimal(2.50), imageUrl: "https://source.unsplash.com/random/300x300/?soda,can", tags: [], position: 0, isAvailable: true, kdsDestination: "BARRA", preparationTime: 1 }, { categoryName: "Bebidas Demo", name_es: "Agua Mineral Demo", name_en: "Mineral Water Demo", description_es: "Botella de 50cl.", description_en: "50cl bottle.", price: new Prisma.Decimal(2.00), imageUrl: "https://source.unsplash.com/random/300x300/?water,bottle", tags: [], position: 1, isAvailable: true, kdsDestination: "BARRA", preparationTime: 1 }, ]; for (const itemData of menuItemsDataSeed) { const { categoryName, idForModifiers, ...dataWithoutCategoryName } = itemData; const category = createdCategories[categoryName]; if (!category) { console.warn(`[SEED] Category ${categoryName} not found for item ${dataWithoutCategoryName.name_es}. Skipping item.`); continue; } const menuItem = await prisma.menuItem.upsert({ where: { categoryId_name_es: { categoryId: category.id, name_es: dataWithoutCategoryName.name_es } }, update: { ...dataWithoutCategoryName, businessId: demoBusiness.id, categoryId: category.id }, create: { ...dataWithoutCategoryName, businessId: demoBusiness.id, categoryId: category.id }, include: { category: true } }); if (idForModifiers) createdMenuItems[idForModifiers] = menuItem; const key = dataWithoutCategoryName.name_es.replace(/\s+/g, ''); createdMenuItems[key] = menuItem; } console.log(`[SEED] Upserted Menu Items.`);
  console.log(`[SEED] Creating Tables for business ${demoBusiness.id}...`);
  const tablesDataSeed = [
    { identifier: "M1", zone: "Sal√≥n Interior", capacity: 4, isActive: true, status: TableStatus.AVAILABLE },
    { identifier: "M2", zone: "Sal√≥n Interior", capacity: 2, isActive: true, status: TableStatus.OCCUPIED },
    { identifier: "T1", zone: "Terraza", capacity: 4, isActive: true, status: TableStatus.PENDING_PAYMENT_TABLE },
    { identifier: "B1", zone: "Barra", capacity: 1, isActive: true, status: TableStatus.AVAILABLE },
  ];
  for (const tableData of tablesDataSeed) {
    const table = await prisma.table.upsert({
      where: { businessId_identifier: { businessId: demoBusiness.id, identifier: tableData.identifier } },
      update: { ...tableData, businessId: demoBusiness.id },
      create: { ...tableData, businessId: demoBusiness.id }
    });
    createdTables[tableData.identifier] = table;
  }
  console.log(`[SEED] Upserted Tables: ${Object.keys(createdTables).join(', ')} with their statuses.`);
  console.log(`[SEED] Creating Staff users and Pins for business ${demoBusiness.id}...`); const staffUsersDataSeed = [ { email: 'cocina@demo.com', name: 'Cocinero Demo', role: UserRole.KITCHEN_STAFF, pin: '1111', pinDescription: 'PIN Cocina' }, { email: 'barra@demo.com', name: 'Barman Demo', role: UserRole.BAR_STAFF, pin: '2222', pinDescription: 'PIN Barra' }, { email: 'camarero@demo.com', name: 'Camarero Demo', role: UserRole.WAITER, pin: '3333', pinDescription: 'PIN Camarero' }, ];
  for (const staffData of staffUsersDataSeed) {
    const user = await prisma.user.upsert({
        where: { email: staffData.email },
        update: { name: staffData.name, role: staffData.role, businessId: demoBusiness.id, isActive: true, password: await hashPassword('password123') },
        create: { email: staffData.email, password: await hashPassword('password123'), name: staffData.name, role: staffData.role, businessId: demoBusiness.id, isActive: true }
    });
    await prisma.staffPin.upsert({
        where: { userId: user.id },
        update: { pinHash: await hashPassword(staffData.pin), description: staffData.pinDescription, isActive: true, businessId: demoBusiness.id },
        create: { pinHash: await hashPassword(staffData.pin), description: staffData.pinDescription, isActive: true, userId: user.id, businessId: demoBusiness.id }
    });
    if (staffData.role === UserRole.WAITER && staffData.email === 'camarero@demo.com') {
        camareroDemoUser = { id: user.id };
    }
  }
  console.log(`[SEED] Upserted Staff users (Kitchen, Bar, Waiter) and their Pins.`);
  console.log(`[SEED] Creating Modifiers and sample Orders for KDS Demo...`); const itemHamburguesaRefSeedMod = createdMenuItems["itemHamburguesa"]; if (itemHamburguesaRefSeedMod) { const grupoPuntoCoccion = await prisma.modifierGroup.upsert({ where: { menuItemId_name_es: { menuItemId: itemHamburguesaRefSeedMod.id, name_es: "Punto de la Carne" } }, update: { uiType: SeedModifierUiType.RADIO, minSelections: 1, maxSelections: 1, position: 0, isRequired: true, name_en: "Meat Doneness", businessId: demoBusiness.id }, create: { menuItemId: itemHamburguesaRefSeedMod.id, businessId: demoBusiness.id, name_es: "Punto de la Carne", name_en: "Meat Doneness", uiType: SeedModifierUiType.RADIO, minSelections: 1, maxSelections: 1, position: 0, isRequired: true } }); const modifierOptionsPuntoData = [ { groupId: grupoPuntoCoccion.id, name_es: "Poco Hecha", name_en: "Rare", priceAdjustment: new Prisma.Decimal(0), position: 0, isDefault: false, isAvailable: true }, { groupId: grupoPuntoCoccion.id, name_es: "Al Punto", name_en: "Medium", priceAdjustment: new Prisma.Decimal(0), position: 1, isDefault: true, isAvailable: true }, { groupId: grupoPuntoCoccion.id, name_es: "Muy Hecha", name_en: "Well Done", priceAdjustment: new Prisma.Decimal(0), position: 2, isDefault: false, isAvailable: true }, ]; for (const modOptData of modifierOptionsPuntoData) { const opt = await prisma.modifierOption.upsert({ where: {groupId_name_es: {groupId: modOptData.groupId, name_es: modOptData.name_es}}, update: {...modOptData}, create: {...modOptData} }); createdModOptionsPunto[modOptData.name_es.replace(/\s+/g, '')] = opt; } console.log(`[SEED] Upserted ModifierGroup "${grupoPuntoCoccion.name_es}" for ${itemHamburguesaRefSeedMod.name_es}`); const grupoExtrasBurger = await prisma.modifierGroup.upsert({ where: { menuItemId_name_es: { menuItemId: itemHamburguesaRefSeedMod.id, name_es: "Extras Hamburguesa" } }, update: { uiType: SeedModifierUiType.CHECKBOX, minSelections: 0, maxSelections: 3, position: 1, isRequired: false, name_en: "Burger Extras", businessId: demoBusiness.id }, create: { menuItemId: itemHamburguesaRefSeedMod.id, businessId: demoBusiness.id, name_es: "Extras Hamburguesa", name_en: "Burger Extras", uiType: SeedModifierUiType.CHECKBOX, minSelections: 0, maxSelections: 3, position: 1, isRequired: false } }); const modifierOptionsExtrasData = [ { groupId: grupoExtrasBurger.id, name_es: "Queso Extra", name_en: "Extra Cheese", priceAdjustment: new Prisma.Decimal(1.00), position: 0, isAvailable: true }, { groupId: grupoExtrasBurger.id, name_es: "Bacon Extra", name_en: "Extra Bacon", priceAdjustment: new Prisma.Decimal(1.50), position: 1, isAvailable: true }, { groupId: grupoExtrasBurger.id, name_es: "Huevo Frito", name_en: "Fried Egg", priceAdjustment: new Prisma.Decimal(1.20), position: 2, isAvailable: true }, { groupId: grupoExtrasBurger.id, name_es: "Guacamole", name_en: "Guacamole", priceAdjustment: new Prisma.Decimal(2.00), position: 3, isAvailable: true }, ]; for (const modOptData of modifierOptionsExtrasData) { const opt = await prisma.modifierOption.upsert({ where: {groupId_name_es: {groupId: modOptData.groupId, name_es: modOptData.name_es}}, update: {...modOptData}, create: {...modOptData} }); createdModOptionsExtras[modOptData.name_es.replace(/\s+/g, '')] = opt; } console.log(`[SEED] Upserted ModifierGroup "${grupoExtrasBurger.name_es}" for ${itemHamburguesaRefSeedMod.name_es}`);
      const order1CreationTime = subMinutes(new Date(), 30);
      const order1Table = createdTables["M1"];
      if (!order1Table) { console.warn("[SEED] Table M1 not found for Order 1. Skipping Order 1."); }
      else {
        const order1ItemsToCreateAnidado: Prisma.OrderItemCreateWithoutOrderInput[] = [];
        let calculatedTotalAmountOrder1 = new Prisma.Decimal(0);
        const hamburguesaMenuItemSeed = itemHamburguesaRefSeedMod;
        const refrescoMenuItemSeed = createdMenuItems["RefrescodeColaDemo"];
        if (hamburguesaMenuItemSeed && createdModOptionsPunto["AlPunto"] && createdModOptionsExtras["BaconExtra"]) {
          let hamburguesaBasePrice = hamburguesaMenuItemSeed.price;
          let hamburguesaModifierPriceAdjustment = new Prisma.Decimal(0);
          hamburguesaModifierPriceAdjustment = hamburguesaModifierPriceAdjustment.add(createdModOptionsPunto["AlPunto"].priceAdjustment);
          hamburguesaModifierPriceAdjustment = hamburguesaModifierPriceAdjustment.add(createdModOptionsExtras["BaconExtra"].priceAdjustment);
          const hamburguesaPriceAtPurchase = hamburguesaBasePrice.add(hamburguesaModifierPriceAdjustment);
          const hamburguesaQuantity = 1;
          const hamburguesaTotalItemPrice = hamburguesaPriceAtPurchase.mul(hamburguesaQuantity);
          calculatedTotalAmountOrder1 = calculatedTotalAmountOrder1.add(hamburguesaTotalItemPrice);
          order1ItemsToCreateAnidado.push({
              menuItem: { connect: { id: hamburguesaMenuItemSeed.id } }, quantity: hamburguesaQuantity,
              priceAtPurchase: hamburguesaPriceAtPurchase, totalItemPrice: hamburguesaTotalItemPrice,
              itemNameSnapshot: hamburguesaMenuItemSeed.name_es, itemDescriptionSnapshot: hamburguesaMenuItemSeed.description_es,
              kdsDestination: hamburguesaMenuItemSeed.kdsDestination, notes: "Bien hecha.",
              selectedModifiers: { create: [
                  { modifierOption: { connect: { id: createdModOptionsPunto["AlPunto"].id } }, optionNameSnapshot: createdModOptionsPunto["AlPunto"].name_es, optionPriceAdjustmentSnapshot: createdModOptionsPunto["AlPunto"].priceAdjustment },
                  { modifierOption: { connect: { id: createdModOptionsExtras["BaconExtra"].id } }, optionNameSnapshot: createdModOptionsExtras["BaconExtra"].name_es, optionPriceAdjustmentSnapshot: createdModOptionsExtras["BaconExtra"].priceAdjustment },
              ]}
          });
        } else console.warn("[SEED] Could not prepare Hamburguesa for Order 1 due to missing item or modifier references.");
        if (refrescoMenuItemSeed) {
          const refrescoQuantity = 2;
          const refrescoPriceAtPurchase = refrescoMenuItemSeed.price;
          const refrescoTotalItemPrice = refrescoPriceAtPurchase.mul(refrescoQuantity);
          calculatedTotalAmountOrder1 = calculatedTotalAmountOrder1.add(refrescoTotalItemPrice);
          order1ItemsToCreateAnidado.push({
              menuItem: { connect: { id: refrescoMenuItemSeed.id } }, quantity: refrescoQuantity,
              priceAtPurchase: refrescoPriceAtPurchase, totalItemPrice: refrescoTotalItemPrice,
              itemNameSnapshot: refrescoMenuItemSeed.name_es, itemDescriptionSnapshot: refrescoMenuItemSeed.description_es,
              kdsDestination: refrescoMenuItemSeed.kdsDestination,
          });
        } else console.warn("[SEED] Could not prepare Refresco for Order 1 due to missing item reference.");
        if (order1ItemsToCreateAnidado.length > 0) {
          const order1DataForCreate: Prisma.OrderCreateInput = {
              business: { connect: { id: demoBusiness.id } },
              orderNumber: `DEMO-${formatISO(new Date(), { representation: 'date' })}-${randomSuffix}-001`,
              status: OrderStatus.RECEIVED,
              totalAmount: calculatedTotalAmountOrder1,
              finalAmount: calculatedTotalAmountOrder1,
              source: "CUSTOMER_APP_DEMO",
              table: { connect: { id: order1Table.id } },
              customerLCo: { connect: { id: demoCustomer1.id } },
              orderType: OrderType.DINE_IN,
              notes: "Sin pepinillos en la hamburguesa, por favor.",
              createdAt: order1CreationTime,
              isBillRequested: false,
              items: { create: order1ItemsToCreateAnidado }
          };
          const order1 = await prisma.order.create({ data: order1DataForCreate });
          console.log(`[SEED] Created Order ${order1.orderNumber} (Total: ${order1.totalAmount}).`);
        } else console.warn("[SEED] No items to create for Order 1. Skipping Order 1 creation.");
      }
    } else console.warn("[SEED] itemHamburguesaRefSeedMod not found. Skipping Order 1 and its modifier setup.");
    const order2CreationTime = subMinutes(new Date(), 5);
    const order2Table = createdTables["T1"];
    if (!order2Table) { console.warn("[SEED] Table T1 not found for Order 2. Skipping Order 2."); }
    else {
      const order2ItemsToCreateAnidado: Prisma.OrderItemCreateWithoutOrderInput[] = [];
      let calculatedTotalAmountOrder2 = new Prisma.Decimal(0);
      const ensaladaCesarMenuItemSeed = createdMenuItems["EnsaladaC√©sarDemo"];
      const aguaMineralMenuItemSeed = createdMenuItems["AguaMineralDemo"];
      if (ensaladaCesarMenuItemSeed) {
          const ensaladaQuantity = 2;
          const ensaladaPriceAtPurchase = ensaladaCesarMenuItemSeed.price;
          const ensaladaTotalItemPrice = ensaladaPriceAtPurchase.mul(ensaladaQuantity);
          calculatedTotalAmountOrder2 = calculatedTotalAmountOrder2.add(ensaladaTotalItemPrice);
          order2ItemsToCreateAnidado.push({ menuItem: { connect: { id: ensaladaCesarMenuItemSeed.id } }, quantity: ensaladaQuantity, priceAtPurchase: ensaladaPriceAtPurchase, totalItemPrice: ensaladaTotalItemPrice, itemNameSnapshot: ensaladaCesarMenuItemSeed.name_es, itemDescriptionSnapshot: ensaladaCesarMenuItemSeed.description_es, kdsDestination: ensaladaCesarMenuItemSeed.kdsDestination, status: OrderItemStatus.SERVED, servedAt: subMinutes(new Date(), 1) });
      } else console.warn("[SEED] EnsaladaC√©sarDemo not found for Order 2.");
      if (aguaMineralMenuItemSeed) {
          const aguaQuantity = 1;
          const aguaPriceAtPurchase = aguaMineralMenuItemSeed.price;
          const aguaTotalItemPrice = aguaPriceAtPurchase.mul(aguaQuantity);
          calculatedTotalAmountOrder2 = calculatedTotalAmountOrder2.add(aguaTotalItemPrice);
          order2ItemsToCreateAnidado.push({ menuItem: { connect: { id: aguaMineralMenuItemSeed.id } }, quantity: aguaQuantity, priceAtPurchase: aguaPriceAtPurchase, totalItemPrice: aguaTotalItemPrice, itemNameSnapshot: aguaMineralMenuItemSeed.name_es, itemDescriptionSnapshot: aguaMineralMenuItemSeed.description_es, kdsDestination: aguaMineralMenuItemSeed.kdsDestination, status: OrderItemStatus.SERVED, servedAt: subMinutes(new Date(), 1) });
      } else console.warn("[SEED] AguaMineralDemo not found for Order 2.");
      if (order2ItemsToCreateAnidado.length > 0) {
        const customerForOrder2 = await prisma.user.findUnique({ where: { email: customer2Email }, select: { id: true } });
        const order2DataForCreate: Prisma.OrderCreateInput = {
            business: { connect: { id: demoBusiness.id } },
            orderNumber: `DEMO-${formatISO(new Date(), { representation: 'date' })}-${randomSuffix}-002`,
            status: OrderStatus.PENDING_PAYMENT,
            isBillRequested: true,
            totalAmount: calculatedTotalAmountOrder2,
            finalAmount: calculatedTotalAmountOrder2,
            source: "CUSTOMER_APP_DEMO",
            table: { connect: { id: order2Table.id } },
            customerLCo: customerForOrder2 ? { connect: { id: customerForOrder2.id } } : { connect: { id: demoCustomer1.id } }, // Usar customer2 si existe
            orderType: OrderType.DINE_IN,
            createdAt: order2CreationTime,
            items: { create: order2ItemsToCreateAnidado }
        };
        const order2 = await prisma.order.create({ data: order2DataForCreate });
        console.log(`[SEED] Created Order ${order2.orderNumber} (Status: ${order2.status}, Total: ${order2.totalAmount}).`);
      } else console.warn(`[SEED] Could not create Order 2 due to no items being added.`);
    }
    if (camareroDemoUser) {
        const order3CreationTime = subHours(new Date(), 2);
        const order3Table = createdTables["M2"];
        if (!order3Table) { console.warn("[SEED] Table M2 not found for Order 3. Skipping Order 3."); }
        else {
            const order3ItemsToCreate: Prisma.OrderItemCreateWithoutOrderInput[] = [];
            let calculatedTotalAmountOrder3 = new Prisma.Decimal(0);
            const tartaQuesoItem = createdMenuItems["TartadeQuesoDemo"];
            if (tartaQuesoItem) {
                const itemPrice = tartaQuesoItem.price;
                const quantity = 1;
                const totalItemPrice = itemPrice.mul(quantity);
                calculatedTotalAmountOrder3 = calculatedTotalAmountOrder3.add(totalItemPrice);
                order3ItemsToCreate.push({
                    menuItem: { connect: { id: tartaQuesoItem.id } },
                    quantity: quantity,
                    priceAtPurchase: itemPrice,
                    totalItemPrice: totalItemPrice,
                    itemNameSnapshot: tartaQuesoItem.name_es,
                    status: OrderItemStatus.SERVED,
                    servedAt: addMinutes(order3CreationTime, 30),
                    servedBy: { connect: { id: camareroDemoUser.id } }
                });
            }
            if (order3ItemsToCreate.length > 0) {
                const order3Data: Prisma.OrderCreateInput = {
                    business: { connect: { id: demoBusiness.id } },
                    orderNumber: `DEMO-${formatISO(new Date(), { representation: 'date' })}-${randomSuffix}-003`,
                    status: OrderStatus.PAID,
                    isBillRequested: true,
                    paidAt: new Date(),
                    paidByUser: { connect: { id: camareroDemoUser.id } },
                    paymentMethodUsed: "EFECTIVO_DEMO",
                    totalAmount: calculatedTotalAmountOrder3,
                    finalAmount: calculatedTotalAmountOrder3,
                    source: "STAFF_MANUAL",
                    table: { connect: { id: order3Table.id } },
                    customerLCo: { connect: { id: demoCustomer1.id } },
                    orderType: OrderType.DINE_IN,
                    createdAt: order3CreationTime,
                    items: { create: order3ItemsToCreate }
                };
                const order3 = await prisma.order.create({ data: order3Data });
                console.log(`[SEED] Created Order ${order3.orderNumber} (Status: PAID, Total: ${order3.totalAmount}).`);
                await prisma.table.update({
                    where: { id: order3Table.id },
                    data: { status: TableStatus.AVAILABLE }
                });
                console.log(`[SEED] Table ${order3Table.identifier} status updated to AVAILABLE after Order 3 payment.`);
            } else {
                console.warn("[SEED] No items to create for Order 3. Skipping Order 3 creation.");
            }
        }
    } else {
        console.warn("[SEED] camareroDemoUser not found. Skipping Order 3 (PAID example).");
    }
    console.log(`[SEED] Generating historical data for LCo statistics...`); const now = new Date(); const startOfThisWeek = startOfDay(subDays(now, 6)); const daysThisWeek = eachDayOfInterval({ start: startOfThisWeek, end: now }); for (const day of daysThisWeek.slice(0, -1)) { if (Math.random() > 0.3) { const amount = Math.floor(Math.random() * 40) + 5; const pointsToEarn = Math.floor(amount * (demoBusiness.pointsPerEuro ?? 1)); const ticketNum = `TICKET-${formatISO(day, { representation: 'date' })}-${Math.floor(Math.random() * 1000)}`; const createdQr = await prisma.qrCode.create({ data: { token: uuidv4(), businessId: demoBusiness.id, amount, ticketNumber: ticketNum, expiresAt: addMinutes(day, demoBusiness.qrCodeExpirationMinutes), status: QrCodeStatus.COMPLETED, completedAt: day, userId: demoCustomer1.id, pointsEarned: pointsToEarn }}); await prisma.activityLog.create({ data: { userId: demoCustomer1.id, businessId: demoBusiness.id, type: ActivityType.POINTS_EARNED_QR, pointsChanged: pointsToEarn, description: `Ticket: ${ticketNum}`, createdAt: day, relatedQrId: createdQr.id }}); await prisma.user.update({ where: {id: demoCustomer1.id }, data: { points: {increment: pointsToEarn}, totalSpend: {increment: amount}, totalVisits: {increment: 1}, lastActivityAt: day }}); } }
    const startOfLastWeek = startOfDay(subDays(now, 13)); const endOfLastWeek = endOfDay(subDays(now, 7)); const daysLastWeek = eachDayOfInterval({ start: startOfLastWeek, end: endOfLastWeek }); for (const day of daysLastWeek) { if (Math.random() > 0.4) { const amount = Math.floor(Math.random() * 50) + 10; const pointsToEarn = Math.floor(amount * (demoBusiness.pointsPerEuro ?? 1)); const ticketNum = `TICKET-LW-${formatISO(day, { representation: 'date' })}-${Math.floor(Math.random() * 1000)}`; const createdQr = await prisma.qrCode.create({ data: { token: uuidv4(), businessId: demoBusiness.id, amount, ticketNumber: ticketNum, expiresAt: addMinutes(day, demoBusiness.qrCodeExpirationMinutes), status: QrCodeStatus.COMPLETED, completedAt: day, userId: demoCustomer3.id, pointsEarned: pointsToEarn }}); await prisma.activityLog.create({ data: { userId: demoCustomer3.id, businessId: demoBusiness.id, type: ActivityType.POINTS_EARNED_QR, pointsChanged: pointsToEarn, description: `Ticket: ${ticketNum}`, createdAt: day, relatedQrId: createdQr.id }}); await prisma.user.update({ where: {id: demoCustomer3.id }, data: { points: {increment: pointsToEarn}, totalSpend: {increment: amount}, totalVisits: {increment: 1}, lastActivityAt: day }}); }
    if (cafeLCoRewardIdSeed && demoAdminForGift && Math.random() > 0.85) { const userForReward = await prisma.user.findUnique({where: {id: demoCustomer1.id}, select: {points: true}}); const cafeRewardDetails = await prisma.reward.findUnique({where: {id: cafeLCoRewardIdSeed}, select: {pointsCost: true, name_es: true}}); if (userForReward && cafeRewardDetails && cafeRewardDetails.name_es && userForReward.points >= cafeRewardDetails.pointsCost) { const granted = await prisma.grantedReward.create({ data: { userId: demoCustomer1.id, rewardId: cafeLCoRewardIdSeed, businessId: demoBusiness.id, status: 'REDEEMED', assignedAt: day, redeemedAt: day, assignedById: demoAdminForGift.id }}); await prisma.activityLog.create({ data: { userId: demoCustomer1.id, businessId: demoBusiness.id, type: ActivityType.GIFT_REDEEMED, description: `Canje: ${cafeRewardDetails.name_es}`, createdAt: day, relatedGrantedRewardId: granted.id } }); await prisma.user.update({ where: {id: demoCustomer1.id}, data: { points: {decrement: cafeRewardDetails.pointsCost}}}); } } }
    console.log(`[SEED] Seeding finished.`);
}

main()
  .catch(async (e) => {
    console.error("[SEED] Error during seeding:", e);
    await prisma.$disconnect();
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


// ====== [14] backend/scripts/create-superadmin.ts ======
// backend/scripts/create-superadmin.ts
/// <reference types="node" />

import { PrismaClient, UserRole } from '@prisma/client';
import bcrypt from 'bcryptjs';
import dotenv from 'dotenv';

dotenv.config({ path: '../.env' });

const prisma = new PrismaClient();

async function hashPassword(password: string): Promise<string> {
  const salt = await bcrypt.genSalt(10);
  return bcrypt.hash(password, salt);
}

async function createOrUpdateSuperAdmin() { // Nombre de funci√≥n cambiado para reflejar la acci√≥n
  console.log('[SUPERADMIN_SCRIPT] Iniciando creaci√≥n/actualizaci√≥n de Super Admin...');

  const superAdminEmail = 'superadmin@loyalpyme.com';
  const superAdminPassword = 'superadminpassword'; // Aseg√∫rate de que esta es la contrase√±a que quieres usar
  const superAdminName = 'Super Admin';

  try {
    const existingSuperAdmin = await prisma.user.findUnique({
      where: { email: superAdminEmail },
    });

    const hashedPassword = await hashPassword(superAdminPassword); // Hasheamos la contrase√±a deseada

    if (existingSuperAdmin) {
      console.log(`[SUPERADMIN_SCRIPT] El Super Admin con email ${superAdminEmail} ya existe. Actualizando su contrase√±a y rol si es necesario...`);
      await prisma.user.update({
        where: { email: superAdminEmail },
        data: {
            password: hashedPassword,
            role: UserRole.SUPER_ADMIN, // Asegurar que el rol es SUPER_ADMIN
            isActive: true,             // Asegurar que est√° activo
            name: superAdminName        // Actualizar nombre por si acaso
            // No tocamos businessId, debe seguir siendo null
        },
      });
      console.log(`[SUPERADMIN_SCRIPT] Datos del Super Admin actualizados (contrase√±a, rol, estado activo, nombre).`);
    } else {
      // Si no existe, crearlo
      const newSuperAdmin = await prisma.user.create({
        data: {
          email: superAdminEmail,
          password: hashedPassword,
          name: superAdminName,
          role: UserRole.SUPER_ADMIN,
          isActive: true,
        },
      });
      console.log(`[SUPERADMIN_SCRIPT] Super Admin creado exitosamente:`);
      console.log(`  ID: ${newSuperAdmin.id}`);
      console.log(`  Email: ${newSuperAdmin.email}`);
    }
    console.log(`  IMPORTANTE: La contrase√±a para ${superAdminEmail} est√° establecida a '${superAdminPassword}'. ¬°Gu√°rdala de forma segura!`);

  } catch (error) {
    console.error('[SUPERADMIN_SCRIPT] Error creando/actualizando el Super Admin:', error);
  } finally {
    await prisma.$disconnect();
    console.log('[SUPERADMIN_SCRIPT] Prisma client desconectado.');
  }
}

createOrUpdateSuperAdmin();


// ====== [15] backend/scripts/hash-customer-password.ts ======
// File: backend/scripts/hash-customer-password.ts
// MODIFIED: To target admin user and set correct password for tests

import { PrismaClient } from '@prisma/client';
// Importamos la funcion hashPassword de nuestro servicio de autenticacion
import { hashPassword } from '../src/auth/auth.service';

// Asegurarse de que las variables de entorno, incluida DATABASE_URL, esten cargadas
import dotenv from 'dotenv';
dotenv.config({ path: '.env' }); // Carga desde backend/.env

const prisma = new PrismaClient();

async function main() {
  // --- CONFIGURACION (MODIFICADA) ---
  const userEmailToUpdate = 'admin@cafeelsol.com'; // <-- Email del admin para los tests
  const plainPasswordToHash = 'superpasswordseguro';   // <-- Contrase√±a que usan los tests
  // --- FIN CONFIGURACION ---

  // --- LOGICA DEL SCRIPT ---
  try {
    console.log(`[SCRIPT] Iniciando hash y actualizacion de contrase√±a para: ${userEmailToUpdate}`);

    // 1. Buscar el usuario por email
    const user = await prisma.user.findUnique({
        where: { email: userEmailToUpdate },
        select: { id: true, email: true, password: true } // Seleccionar campos para verificacion
    });

    if (!user) {
        console.error(`[SCRIPT] ERROR: Usuario no encontrado con el email: ${userEmailToUpdate}`);
        console.error(`[SCRIPT] Aseg√∫rate de haber registrado el negocio con este email primero.`);
        return; // Salir si el usuario no existe
    }

    console.log(`[SCRIPT] Usuario encontrado. ID: ${user.id}`);

    // 2. Hashear la contrase√±a plana
    console.log(`[SCRIPT] Hasheando la contrase√±a plana '${plainPasswordToHash}'...`);
    const hashedPassword = await hashPassword(plainPasswordToHash);
    console.log(`[SCRIPT] Contrase√±a hasheada (hash): ${hashedPassword.substring(0, 10)}...`);

    // 3. Actualizar el usuario en la base de datos con la contrase√±a hasheada
    console.log(`[SCRIPT] Actualizando usuario en la base de datos...`);
    const updatedUser = await prisma.user.update({
      where: { id: user.id }, // Actualizar por ID para mayor seguridad
      data: { password: hashedPassword },
      select: { id: true, email: true } // Seleccionar campos para confirmar actualizacion
    });
    console.log(`[SCRIPT] Usuario ${updatedUser.email} (${updatedUser.id}) actualizado exitosamente con contrase√±a hasheada.`);

  } catch (error: any) {
    console.error(`[SCRIPT] ERROR durante la ejecucion del script:`, error instanceof Error ? error.message : error);
  } finally {
    // Asegurar la desconexion de Prisma Client al finalizar el script
    await prisma.$disconnect();
    console.log('[SCRIPT] Prisma client desconectado.');
  }
}

// Ejecutar la funcion principal del script
main();


// ====== [16] backend/src/config/swagger.config.ts ======
// backend/src/config/swagger.config.ts (CORREGIDO v1.2.0)
import {
    Prisma,
    UserRole,
    TierCalculationBasis,
    TierDowngradePolicy,
    BenefitType,
    OrderItemStatus,
    OrderStatus,
    ActivityType,
    DocumentType
} from '@prisma/client';

const port = process.env.PORT || 3000;

export const swaggerOptions = {
  definition: {
    openapi: '3.0.0',
    info: {
      title: 'LoyalPyME API',
      version: '1.17.0',
      description: 'API REST para la plataforma de fidelizaci√≥n LoyalPyME. Permite gestionar clientes, puntos, niveles, recompensas, historial, subidas de archivos, autenticaci√≥n, funcionalidades de Super Administrador, administraci√≥n del M√≥dulo Camarero (gesti√≥n de carta, KDS, interfaz de camarero), y visualizaci√≥n de men√∫ p√∫blico y creaci√≥n de pedidos.',
      contact: { name: 'Olivier Hottelet', email: 'olivierhottelet1980@gmail.com' },
      license: { name: 'Software Propietario. Copyright (c) 2024-2025 Olivier Hottelet', url: 'LICENSE.MD' }
    },
    servers: [
        { url: `http://localhost:${port}/api`, description: 'Servidor de Desarrollo Local (API Protegida)', },
        { url: `http://localhost:${port}/public`, description: 'Servidor de Desarrollo Local (API P√∫blica)', },
    ],
    components: {
        securitySchemes: { bearerAuth: { type: 'http', scheme: 'bearer', bearerFormat: 'JWT', } },
        schemas: {
             ActivityLogItem: { type: 'object', properties: { id: { type: 'string', format: 'uuid', readOnly: true }, type: { type: 'string', enum: Object.values(ActivityType), readOnly: true }, pointsChanged: { type: 'integer', nullable: true, readOnly: true, description: 'Cambio en puntos (+/-), null si no aplica.' }, description: { type: 'string', nullable: true, readOnly: true, description: 'Descripci√≥n del evento.' }, createdAt: { type: 'string', format: 'date-time', readOnly: true, description: 'Fecha y hora del evento.' } } },
             PaginatedActivityResponse: { type: 'object', properties: { logs: { type: 'array', items: { '$ref': '#/components/schemas/ActivityLogItem' } }, totalPages: { type: 'integer', example: 5 }, currentPage: { type: 'integer', example: 1 }, totalItems: { type: 'integer', example: 73 } } },
             LoginCredentials: { type: 'object', required: ['email', 'password'], properties: { email: { type: 'string', format: 'email'}, password: { type: 'string', format: 'password'} }, example: { email: 'user@example.com', password: 'password123' } },
             RegisterUserDto: { type: 'object', required: ['email', 'password', 'phone', 'documentId', 'documentType', 'businessId', 'role'], properties: { email: { type: 'string', format: 'email'}, password: { type: 'string', format: 'password', minLength: 6 }, name: { type: 'string', nullable: true }, phone: { type: 'string', example: '+34612345678' }, documentId: { type: 'string'}, documentType: { type: 'string', enum: Object.values(DocumentType) }, businessId: { type: 'string', format: 'uuid'}, role: { type: 'string', enum: [UserRole.CUSTOMER_FINAL]} } },
             RegisterBusinessDto: { type: 'object', required: ['businessName', 'adminEmail', 'adminPassword'], properties: { businessName: { type: 'string', minLength: 2 }, adminEmail: { type: 'string', format: 'email'}, adminPassword: { type: 'string', format: 'password', minLength: 6 }, adminName: { type: 'string', nullable: true } } },
             ForgotPasswordDto: { type: 'object', required: ['email'], properties: { email: { type: 'string', format: 'email'} } },
             ResetPasswordDto: { type: 'object', required: ['password'], properties: { password: { type: 'string', format: 'password', minLength: 6 } } },
             UserResponse: { type: 'object', properties: { id: { type: 'string', format: 'uuid'}, email: { type: 'string', format: 'email'}, name: { type: 'string', nullable: true }, role: { type: 'string', enum: Object.values(UserRole) }, businessId: { type: 'string', format: 'uuid', nullable: true}, points: { type: 'integer'}, createdAt: { type: 'string', format: 'date-time'}, isActive: { type: 'boolean'}, isFavorite: { type: 'boolean', nullable: true }, currentTierId: { type: 'string', format: 'uuid', nullable: true }, tierAchievedAt: { type: 'string', format: 'date-time', nullable: true } } },
             LoginResponse: { type: 'object', properties: { token: { type: 'string'}, user: { '$ref': '#/components/schemas/UserResponse' } } },
             SuccessMessage: { type: 'object', properties: { message: { type: 'string'} }, example: { message: 'Operaci√≥n completada con √©xito.'} },
             ErrorResponse: { type: 'object', properties: { message: { type: 'string'}, error: { type: 'string', nullable: true } }, example: { message: 'Error de validaci√≥n.', error: 'El campo email es inv√°lido.'} },
             RewardBase: { type: 'object', properties: { id: { type: 'string', format: 'uuid', readOnly: true }, name_es: { type: 'string', nullable: true}, name_en: { type: 'string', nullable: true}, description_es: { type: 'string', nullable: true }, description_en: { type: 'string', nullable: true }, pointsCost: { type: 'integer', format: 'int32', minimum: 0 }, isActive: { type: 'boolean'}, businessId: { type: 'string', format: 'uuid', readOnly: true }, createdAt: { type: 'string', format: 'date-time', readOnly: true }, updatedAt: { type: 'string', format: 'date-time', readOnly: true }, imageUrl: { type: 'string', format: 'url', nullable: true } } },
             CreateRewardDto: { type: 'object', required: ['name_es', 'name_en', 'pointsCost'], properties: { name_es: { type: 'string', example: 'Caf√© Gratis' }, name_en: { type: 'string', example: 'Free Coffee' }, description_es: { type: 'string', nullable: true, example: 'Un caf√© espresso o americano.' }, description_en: { type: 'string', nullable: true, example: 'One espresso or americano coffee.' }, pointsCost: { type: 'integer', format: 'int32', minimum: 0, example: 100 }, imageUrl: { type: 'string', format: 'url', nullable: true } } },
             UpdateRewardDto: { type: 'object', properties: { name_es: { type: 'string'}, name_en: { type: 'string'}, description_es: { type: 'string', nullable: true }, description_en: { type: 'string', nullable: true }, pointsCost: { type: 'integer', format: 'int32', minimum: 0 }, isActive: { type: 'boolean'}, imageUrl: { type: 'string', format: 'url', nullable: true } } },
             RewardListResponse: { type: 'array', items: { '$ref': '#/components/schemas/RewardBase' } },
             DeletedRewardResponse: { type: 'object', properties: { message: { type: 'string'}, deletedReward: { '$ref': '#/components/schemas/RewardBase' } } },
             GenerateQrDto: { type: 'object', required: ['amount', 'ticketNumber'], properties: { amount: { type: 'number', format: 'float', minimum: 0.01 }, ticketNumber: { type: 'string'} } },
             QrDataResponse: { type: 'object', properties: { qrToken: { type: 'string', format: 'uuid'}, amount: { type: 'number', format: 'float'} } },
             ValidateQrDto: { type: 'object', required: ['qrToken'], properties: { qrToken: { type: 'string', format: 'uuid'} } },
             PointsEarnedResponse: { type: 'object', properties: { message: { type: 'string'}, pointsEarned: { type: 'integer'}, user: { '$ref': '#/components/schemas/UserResponse' } }, example: { message: '...', pointsEarned: 7, user: { } } },
             RedeemRewardResult: { type: 'object', properties: { message: { type: 'string'}, newPointsBalance: { type: 'integer'} }, example: { message: '...', newPointsBalance: 930 } },
             RewardInfoForGift: { type: 'object', properties: { id: { type: 'string', format: 'uuid', readOnly: true }, name_es: { type: 'string', nullable: true, readOnly: true }, name_en: { type: 'string', nullable: true, readOnly: true }, description_es: { type: 'string', nullable: true, readOnly: true }, description_en: { type: 'string', nullable: true, readOnly: true }, imageUrl: { type: 'string', format: 'url', nullable: true, readOnly: true } } },
             AssignerInfo: { type: 'object', properties: { name: { type: 'string', nullable: true, readOnly: true }, email: { type: 'string', format: 'email', readOnly: true } } },
             BusinessInfoForGift: { type: 'object', properties: { name: { type: 'string', readOnly: true } } },
             GrantedReward: { type: 'object', properties: { id: { type: 'string', format: 'uuid', readOnly: true }, status: { type: 'string', enum: ['PENDING', 'REDEEMED', 'EXPIRED'], readOnly: true }, assignedAt: { type: 'string', format: 'date-time', readOnly: true }, redeemedAt: { type: 'string', format: 'date-time', nullable: true, readOnly: true }, reward: { '$ref': '#/components/schemas/RewardInfoForGift' }, assignedBy: { '$ref': '#/components/schemas/AssignerInfo', nullable: true }, business: { '$ref': '#/components/schemas/BusinessInfoForGift', nullable: true } } },
             GrantedRewardListResponse: { type: 'array', items: { '$ref': '#/components/schemas/GrantedReward' } },
             RedeemedGiftResponse: { type: 'object', properties: { message: { type: 'string'}, grantedRewardId: { type: 'string', format: 'uuid'}, rewardId: { type: 'string', format: 'uuid'}, redeemedAt: { type: 'string', format: 'date-time'} } },
             TierBenefitBase: { type: 'object', properties: { id: { type: 'string', format: 'uuid', readOnly: true }, type: { type: 'string', enum: Object.values(BenefitType) }, value: { type: 'string'}, description: { type: 'string', nullable: true }, isActive: { type: 'boolean'} } },
             TierWithBenefits: { type: 'object', properties: { id: { type: 'string', format: 'uuid', readOnly: true }, name: { type: 'string'}, level: { type: 'integer'}, minValue: { type: 'number'}, description: { type: 'string', nullable: true }, benefitsDescription: { type: 'string', nullable: true }, isActive: { type: 'boolean'}, benefits: { type: 'array', items: { '$ref': '#/components/schemas/TierBenefitBase' } } } },
             TierListResponse: { type: 'array', items: { '$ref': '#/components/schemas/TierWithBenefits' } },
             TierConfigResponse: { type: 'object', properties: { tierSystemEnabled: { type: 'boolean' }, tierCalculationBasis: { type: 'string', enum: Object.values(TierCalculationBasis), nullable: true }, tierCalculationPeriodMonths: { type: 'integer', nullable: true, minimum: 0 }, tierDowngradePolicy: { type: 'string', enum: Object.values(TierDowngradePolicy) }, inactivityPeriodMonths: { type: 'integer', nullable: true, minimum: 1 } } },
             TierConfigUpdateDto: { type: 'object', properties: { tierSystemEnabled: { type: 'boolean'}, tierCalculationBasis: { type: 'string', enum: Object.values(TierCalculationBasis), nullable: true }, tierCalculationPeriodMonths: { type: 'integer', nullable: true, minimum: 0 }, tierDowngradePolicy: { type: 'string', enum: Object.values(TierDowngradePolicy) }, inactivityPeriodMonths: { type: 'integer', nullable: true, minimum: 1 } } },
             TierBase: { type: 'object', properties: { id: { type: 'string', format: 'uuid', readOnly: true }, name: { type: 'string'}, level: { type: 'integer', minimum: 0 }, minValue: { type: 'number', minimum: 0 }, description: { type: 'string', nullable: true }, benefitsDescription: { type: 'string', nullable: true }, isActive: { type: 'boolean'}, businessId: { type: 'string', format: 'uuid', readOnly: true }, createdAt: { type: 'string', format: 'date-time', readOnly: true }, updatedAt: { type: 'string', format: 'date-time', readOnly: true } } },
             CreateTierDto: { type: 'object', required: ['name', 'level', 'minValue'], properties: { name: { type: 'string'}, level: { type: 'integer', minimum: 0 }, minValue: { type: 'number', minimum: 0 }, description: { type: 'string', nullable: true }, benefitsDescription: { type: 'string', nullable: true }, isActive: { type: 'boolean', default: true } } },
             UpdateTierDto: { type: 'object', properties: { name: { type: 'string'}, level: { type: 'integer', minimum: 0 }, minValue: { type: 'number', minimum: 0 }, description: { type: 'string', nullable: true }, benefitsDescription: { type: 'string', nullable: true }, isActive: { type: 'boolean'} } },
             AdminTierListResponse: { type: 'array', items: { '$ref': '#/components/schemas/TierWithBenefits' } },
             DeletedTierResponse: { type: 'object', properties: { message: { type: 'string'}, deletedTier: { '$ref': '#/components/schemas/TierBase' } } },
             TierBenefitListResponse: { type: 'array', items: { '$ref': '#/components/schemas/TierBenefitBase' } },
             CreateTierBenefitDto: { type: 'object', required: ['type', 'value'], properties: { type: { type: 'string', enum: Object.values(BenefitType) }, value: { type: 'string'}, description: { type: 'string', nullable: true }, isActive: { type: 'boolean', default: true } } },
             UpdateTierBenefitDto: { type: 'object', properties: { type: { type: 'string', enum: Object.values(BenefitType) }, value: { type: 'string'}, description: { type: 'string', nullable: true }, isActive: { type: 'boolean'} } },
             DeletedTierBenefitResponse: { type: 'object', properties: { message: { type: 'string'}, deletedBenefit: { '$ref': '#/components/schemas/TierBenefitBase' } } },
             AdminStatsOverviewResponse: { type: 'object', properties: { totalActiveCustomers: { type: 'integer'}, newCustomersLast7Days: { type: 'integer'}, newCustomersPrevious7Days: { type: 'integer'}, pointsIssuedLast7Days: { type: 'integer'}, pointsIssuedPrevious7Days: { type: 'integer'}, rewardsRedeemedLast7Days: { type: 'integer'}, rewardsRedeemedPrevious7Days: { type: 'integer'} } },
             CustomerListItem: { type: 'object', properties: { id: { type: 'string', format: 'uuid' }, name: { type: 'string', nullable: true }, email: { type: 'string', format: 'email' }, points: { type: 'integer' }, createdAt: { type: 'string', format: 'date-time' }, isActive: { type: 'boolean' }, isFavorite: { type: 'boolean', nullable: true }, currentTier: { type: 'object', nullable: true, properties: { id: { type: 'string', format: 'uuid' }, name: { type: 'string' }, level: { type: 'integer' } } } } },
             AdminCustomerListResponse: { type: 'object', properties: { items: { type: 'array', items: { '$ref': '#/components/schemas/CustomerListItem' } }, totalPages: { type: 'integer' }, currentPage: { type: 'integer' }, totalItems: { type: 'integer' } } },
             CustomerDetailsResponse: { allOf: [ { '$ref': '#/components/schemas/UserResponse' }, { type: 'object', properties: { adminNotes: { type: 'string', nullable: true } } } ] },
             UpdateCustomerNotesDto: { type: 'object', properties: { notes: { type: 'string', nullable: true } } },
             AdjustPointsDto: { type: 'object', required: ['amount'], properties: { amount: { type: 'number', not: { const: 0 } }, reason: { type: 'string', nullable: true } } },
             ChangeCustomerTierDto: { type: 'object', properties: { tierId: { type: 'string', format: 'uuid', nullable: true } } },
             AssignRewardDto: { type: 'object', required: ['rewardId'], properties: { rewardId: { type: 'string', format: 'uuid' } } },
             CustomerActionResponse: { type: 'object', properties: { message: { type: 'string' }, customer: { type: 'object', properties: { id: { type: 'string', format: 'uuid' }, points: { type: 'integer' }, currentTierId: { type: 'string', format: 'uuid', nullable: true }, tierAchievedAt: { type: 'string', format: 'date-time', nullable: true }, isFavorite: { type: 'boolean' }, isActive: { type: 'boolean' } }, additionalProperties: false } } },
             GrantedRewardIdResponse: { type: 'object', properties: { message: { type: 'string' }, grantedRewardId: { type: 'string', format: 'uuid' } } },
             BulkCustomerIdListDto: { type: 'object', required: ['customerIds'], properties: { customerIds: { type: 'array', items: { type: 'string', format: 'uuid' }, minItems: 1 } } },
             BulkStatusUpdateDto: { type: 'object', required: ['customerIds', 'isActive'], properties: { customerIds: { type: 'array', items: { type: 'string', format: 'uuid' }, minItems: 1 }, isActive: { type: 'boolean'} } },
             BulkPointsAdjustDto: { type: 'object', required: ['customerIds', 'amount'], properties: { customerIds: { type: 'array', items: { type: 'string', format: 'uuid' }, minItems: 1 }, amount: { type: 'number', not: { const: 0 } }, reason: { type: 'string', nullable: true } } },
             BulkOperationResponse: { type: 'object', properties: { message: { type: 'string' }, count: { type: 'integer'} } },
             ImageUploadResponse: { type: 'object', properties: { url: { type: 'string', format: 'url', description: 'URL de la imagen subida a Cloudinary.' } } },
             // DTOs para Camarero Staff
             ReadyPickupItemDto: { 
                type: 'object',
                properties: {
                    orderItemId: { type: 'string', format: 'uuid', description: "ID del OrderItem" },
                    orderId: { type: 'string', format: 'uuid', description: "ID del Order al que pertenece" },
                    orderNumber: { type: 'string', description: "N√∫mero legible del Order" },
                    orderCreatedAt: { type: 'string', format: 'date-time', description: "Fecha de creaci√≥n del Order" },
                    tableIdentifier: { type: 'string', nullable: true, description: "Identificador de la mesa" },
                    itemNameSnapshot_es: { type: 'string', nullable: true, description: "Nombre del √≠tem en espa√±ol (snapshot)" },
                    itemNameSnapshot_en: { type: 'string', nullable: true, description: "Nombre del √≠tem en ingl√©s (snapshot)" },
                    quantity: { type: 'integer', description: "Cantidad del √≠tem" },
                    itemNotes: { type: 'string', nullable: true, description: "Notas espec√≠ficas del OrderItem" },
                    kdsDestination: { type: 'string', nullable: true, description: "Destino KDS (COCINA, BARRA)" },
                    selectedModifiers: {
                        type: 'array',
                        items: {
                            type: 'object',
                            properties: {
                                optionName_es: { type: 'string', nullable: true },
                                optionName_en: { type: 'string', nullable: true },
                            }
                        }
                    },
                    currentOrderItemStatus: { type: 'string', enum: Object.values(OrderItemStatus) }
                }
             },
             MarkOrderItemServedPayloadDto: { 
                type: 'object',
                required: ['newStatus'],
                properties: {
                    newStatus: { type: 'string', enum: [OrderItemStatus.SERVED], description: 'Debe ser "SERVED"' }
                }
             },
             OrderItemStatusUpdateResponseDto: { 
                type: 'object',
                properties: {
                    message: { type: 'string' },
                    orderItemId: { type: 'string', format: 'uuid' },
                    newStatus: { type: 'string', enum: Object.values(OrderItemStatus) },
                    orderStatus: { type: 'string', enum: Object.values(OrderStatus), nullable: true }
                }
             }
         }
    },
    security: [{ bearerAuth: [] }],
  },
  apis: [
    './src/shared/auth/*.ts',
    './src/modules/loyalpyme/admin/*.ts',
    './src/modules/loyalpyme/rewards/*.ts',
    './src/modules/loyalpyme/points/*.ts',
    './src/modules/loyalpyme/customer/*.ts',
    './src/modules/loyalpyme/tiers/*.ts',
    './src/modules/camarero/*.ts', // Se asume que los controladores est√°n aqu√≠
    './src/modules/camarero/public/*.ts',
    './src/modules/superadmin/*.ts',
    './src/shared/uploads/*.ts',
    './src/routes/*.ts'
  ],
};


// ====== [17] backend/src/index.ts ======
// backend/src/index.ts (CORREGIDO v1.8.1)
import express, { Express, Request, Response, NextFunction, RequestHandler } from 'express';
import dotenv from 'dotenv';
import 'reflect-metadata';
import cors from 'cors';
import { Prisma, PrismaClient } from '@prisma/client';
import cron from 'node-cron';
import swaggerJsdoc from 'swagger-jsdoc';
import swaggerUi from 'swagger-ui-express';

import { swaggerOptions } from './config/swagger.config';
import { apiRouter, publicRouter } from './routes';

// --- RUTA CORREGIDA ---
import { processTierUpdatesAndDowngrades } from './modules/loyalpyme/tiers/tier-logic.service';

dotenv.config();

const prisma = new PrismaClient();
const app: Express = express();
const port = process.env.PORT || 3000;

app.use(cors());
app.use(express.json());
app.use((req, res, next) => {
  if (process.env.NODE_ENV !== 'test' && !process.env.VITEST) {
      const method = req.method;
      const url = req.originalUrl;
      const ip = req.ip || req.connection.remoteAddress;
      const timestamp = new Date().toISOString();
      let bodyLog = '';
      if (req.body && Object.keys(req.body).length > 0 && !req.is('multipart/form-data')) {
         try { bodyLog = JSON.stringify(req.body); if (bodyLog.length > 500) bodyLog = bodyLog.substring(0, 497) + '...'; } catch { bodyLog = '[Unloggable Body]'; }
      }
      console.log(`[REQ LOG - ${timestamp}] ${method} ${url} - From: ${ip} ${bodyLog ? '- Body: '+bodyLog : ''}`);
  }
  next();
});

const swaggerSpec = swaggerJsdoc(swaggerOptions);
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec) as RequestHandler);

app.use('/api', apiRouter);
app.use('/public', publicRouter);

app.get('/', (req: Request, res: Response) => { res.send('Welcome to LoyalPyME API! Docs available at /api-docs'); });

app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
    console.error('[GLOBAL ERROR HANDLER]', err.stack);
    if (err instanceof Prisma.PrismaClientKnownRequestError) {
        if (err.code === 'P2002') { return res.status(409).json({ message: 'Conflicto de unicidad.', error: `Ya existe un registro con uno de los valores √∫nicos proporcionados. (${(err.meta?.target as string[])?.join(', ')})`, code: err.code }); }
        if (err.code === 'P2025') { return res.status(404).json({ message: 'Registro no encontrado.', error: (err.meta?.cause as string) || 'El registro necesario para la operaci√≥n no existe.', code: err.code });}
        return res.status(400).json({ message: 'Error de base de datos.', error: err.message, code: err.code });
    }
    if (err instanceof Prisma.PrismaClientValidationError) {
         return res.status(400).json({ message: 'Error de validaci√≥n de datos Prisma.', error: 'Los datos proporcionados no cumplen con el formato esperado por la base de datos.'});
    }
    const statusCode = (err as any).status || 500;
    const errorMessage = statusCode === 500 && process.env.NODE_ENV === 'production' ? 'Ocurri√≥ un error interno en el servidor.' : err.message || 'Error desconocido.';
    res.status(statusCode).json({ message: statusCode === 500 ? 'Error Interno del Servidor' : 'Error en la Petici√≥n', error: errorMessage });
});

if (process.env.NODE_ENV !== 'test' && !process.env.VITEST) {
    const cronSchedule = process.env.TIER_UPDATE_CRON_SCHEDULE || '0 3 * * *';
    console.log(`Scheduling Tier update/downgrade job with schedule: [${cronSchedule}]`);
    cron.schedule(cronSchedule, () => {
        const startTime = Date.now();
        console.log(`[CRON ${new Date().toISOString()}] Starting Tier update/downgrade job...`);
        processTierUpdatesAndDowngrades()
            .then(() => {
                 const duration = (Date.now() - startTime) / 1000;
                 console.log(`[CRON ${new Date().toISOString()}] Tier update/downgrade job finished successfully in ${duration.toFixed(2)}s.`);
            })
            // --- TIPO 'any' A√ëADIDO ---
            .catch((cronErr: any) => console.error(`[CRON ${new Date().toISOString()}] Tier update/downgrade job failed:`, cronErr));
    });
    console.log(`‚úÖ Tier update/downgrade job registered.`);
} else {
     console.log("‚ÑπÔ∏è Cron job scheduling skipped in test/Vitest environment.");
}

if (!process.env.VITEST) {
     app.listen(port, () => {
         console.log(`\nüöÄ [server]: Server is running at http://localhost:${port}`);
         console.log(`üìö [docs]: API Docs available at http://localhost:${port}/api-docs`);
     });
}

export default app;


// ====== [18] backend/src/modules/camarero/admin-menu-category.controller.ts ======
// backend/src/modules/camarero/admin-menu-category.controller.ts (CORREGIDO)
import { Request, Response, NextFunction } from 'express';
// --- RUTA CORREGIDA ---
import * as menuCategoryAdminService from './admin-menu-category.service';
// --- FIN RUTA CORREGIDA ---

// --- Handlers del Controlador (Sin cambios en la l√≥gica interna) ---
export const createMenuCategoryHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }

    const { name_es, name_en, description_es, description_en, imageUrl, position, isActive } = req.body;

    if (!name_es || typeof name_es !== 'string' || name_es.trim() === '') {
        return res.status(400).json({ message: "El campo 'name_es' (nombre en espa√±ol) es obligatorio." });
    }
    if (name_en !== undefined && name_en !== null && typeof name_en !== 'string') {
        return res.status(400).json({ message: "El campo 'name_en' debe ser un texto o nulo." });
    }
    if (position !== undefined && typeof position !== 'number') {
        return res.status(400).json({ message: "El campo 'position' debe ser un n√∫mero si se proporciona." });
    }
    if (isActive !== undefined && typeof isActive !== 'boolean') {
        return res.status(400).json({ message: "El campo 'isActive' debe ser un booleano si se proporciona." });
    }

    try {
        const categoryData: menuCategoryAdminService.CreateMenuCategoryData = {
            name_es: name_es.trim(),
            name_en: name_en?.trim() || null,
            description_es: description_es?.trim() || null,
            description_en: description_en?.trim() || null,
            imageUrl: imageUrl || null,
            position: typeof position === 'number' ? position : 0,
            isActive: typeof isActive === 'boolean' ? isActive : true,
        };
        const newCategory = await menuCategoryAdminService.createMenuCategory(businessId, categoryData);
        res.status(201).json(newCategory);
    } catch (error: any) {
        if (error.message && error.message.includes('Ya existe una categor√≠a con el nombre')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};

export const getMenuCategoriesHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }
    try {
        const categories = await menuCategoryAdminService.getMenuCategoriesByBusiness(businessId);
        res.status(200).json(categories);
    } catch (error) {
        next(error);
    }
};

export const getMenuCategoryByIdHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }
    try {
        const category = await menuCategoryAdminService.getMenuCategoryById(categoryId, businessId);
        if (!category) {
            return res.status(404).json({ message: "Categor√≠a de men√∫ no encontrada o no pertenece a este negocio." });
        }
        res.status(200).json(category);
    } catch (error) {
        next(error);
    }
};

export const updateMenuCategoryHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }

    const { name_es, name_en, description_es, description_en, imageUrl, position, isActive } = req.body;
    if (Object.keys(req.body).length === 0) {
        return res.status(400).json({ message: "Se requiere al menos un campo para actualizar." });
    }
    if (name_es !== undefined && (typeof name_es !== 'string' || name_es.trim() === '')) {
        return res.status(400).json({ message: "Si se proporciona 'name_es', no puede estar vac√≠o." });
    }
    if (name_en !== undefined && name_en !== null && typeof name_en !== 'string') {
        return res.status(400).json({ message: "Si se proporciona 'name_en', debe ser un texto o nulo." });
    }
    if (position !== undefined && typeof position !== 'number') {
        return res.status(400).json({ message: "Si se proporciona 'position', debe ser un n√∫mero." });
    }
    if (isActive !== undefined && typeof isActive !== 'boolean') {
        return res.status(400).json({ message: "Si se proporciona 'isActive', debe ser un booleano." });
    }
    
    try {
        const updateData: menuCategoryAdminService.UpdateMenuCategoryData = {};
        if (name_es !== undefined) updateData.name_es = name_es.trim();
        if (name_en !== undefined) updateData.name_en = name_en === null ? null : name_en?.trim() || null;
        if (description_es !== undefined) updateData.description_es = description_es === null ? null : description_es?.trim() || null;
        if (description_en !== undefined) updateData.description_en = description_en === null ? null : description_en?.trim() || null;
        if (imageUrl !== undefined) updateData.imageUrl = imageUrl === null ? null : imageUrl || null;
        if (position !== undefined) updateData.position = position;
        if (isActive !== undefined) updateData.isActive = isActive;

        const updatedCategory = await menuCategoryAdminService.updateMenuCategory(categoryId, businessId, updateData);
        res.status(200).json(updatedCategory);
    } catch (error: any) {
        if (error.message && error.message.includes('no encontrada')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('Error de unicidad')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};

export const deleteMenuCategoryHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;
    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    }
    try {
        const deletedCategory = await menuCategoryAdminService.deleteMenuCategory(categoryId, businessId);
        res.status(200).json({ message: "Categor√≠a de men√∫ eliminada con √©xito.", id: deletedCategory.id });
    } catch (error: any) {
         if (error.message && error.message.includes('no encontrada')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('contiene √≠tems que est√°n actualmente en uso')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};


// ====== [19] backend/src/modules/camarero/admin-menu-category.service.ts ======
// backend/src/camarero/admin-menu-category.service.ts
import { PrismaClient, MenuCategory, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

// Tipo para los datos de creaci√≥n (excluye businessId ya que se pasa como argumento)
export type CreateMenuCategoryData = Omit<Prisma.MenuCategoryCreateInput, 'business' | 'items'>;

// Tipo para los datos de actualizaci√≥n (parcial y excluye relaciones)
export type UpdateMenuCategoryData = Partial<Omit<Prisma.MenuCategoryUpdateInput, 'business' | 'items'>>;


/**
 * Crea una nueva categor√≠a de men√∫ para un negocio espec√≠fico.
 */
export const createMenuCategory = async (
    businessId: string,
    data: CreateMenuCategoryData
): Promise<MenuCategory> => {
    console.log(`[MC_SVC] Creating menu category for business ${businessId}:`, data.name_es);
    try {
        const newCategory = await prisma.menuCategory.create({
            data: {
                ...data,
                business: {
                    connect: { id: businessId }
                }
            }
        });
        return newCategory;
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            // P2002 es error de constraint √∫nico (ej: nombre de categor√≠a ya existe para ese negocio)
            console.warn(`[MC_SVC] Unique constraint violation for business ${businessId}, name: ${data.name_es}`, error.meta);
            throw new Error(`Ya existe una categor√≠a con el nombre '${data.name_es}' en este negocio.`);
        }
        console.error(`[MC_SVC] Error creating menu category for business ${businessId}:`, error);
        throw new Error("Error de base de datos al crear la categor√≠a de men√∫.");
    }
};

/**
 * Obtiene todas las categor√≠as de men√∫ para un negocio, ordenadas por posici√≥n.
 */
export const getMenuCategoriesByBusiness = async (businessId: string): Promise<MenuCategory[]> => {
    console.log(`[MC_SVC] Fetching menu categories for business ${businessId}`);
    try {
        return await prisma.menuCategory.findMany({
            where: { businessId },
            orderBy: { position: 'asc' },
            // Podr√≠amos incluir √≠tems si fuera necesario para alguna vista: include: { items: true }
        });
    } catch (error) {
        console.error(`[MC_SVC] Error fetching menu categories for business ${businessId}:`, error);
        throw new Error("Error al obtener las categor√≠as de men√∫.");
    }
};

/**
 * Obtiene una categor√≠a de men√∫ espec√≠fica por su ID, verificando que pertenezca al negocio.
 */
export const getMenuCategoryById = async (categoryId: string, businessId: string): Promise<MenuCategory | null> => {
    console.log(`[MC_SVC] Fetching menu category ${categoryId} for business ${businessId}`);
    try {
        return await prisma.menuCategory.findFirst({
            where: {
                id: categoryId,
                businessId: businessId
            },
            // include: { items: true } // Opcional: incluir √≠tems al obtener una categor√≠a espec√≠fica
        });
    } catch (error) {
        console.error(`[MC_SVC] Error fetching menu category ${categoryId}:`, error);
        throw new Error("Error al obtener la categor√≠a de men√∫ por ID.");
    }
};

/**
 * Actualiza una categor√≠a de men√∫ existente.
 */
export const updateMenuCategory = async (
    categoryId: string,
    businessId: string,
    data: UpdateMenuCategoryData
): Promise<MenuCategory> => {
    console.log(`[MC_SVC] Updating menu category ${categoryId} for business ${businessId}:`, data);
    try {
        // Verificar que la categor√≠a existe y pertenece al negocio antes de actualizar
        const existingCategory = await prisma.menuCategory.findFirst({
            where: { id: categoryId, businessId: businessId },
            select: { id: true } // Solo necesitamos saber si existe
        });
        if (!existingCategory) {
            throw new Error(`Categor√≠a de men√∫ con ID ${categoryId} no encontrada o no pertenece a este negocio.`);
        }

        return await prisma.menuCategory.update({
            where: { id: categoryId },
            data: data
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            console.warn(`[MC_SVC] Unique constraint violation on update for category ${categoryId}, business ${businessId}:`, error.meta);
            // El mensaje de error podr√≠a ser m√°s espec√≠fico si sabemos qu√© campo caus√≥ el P2002
            throw new Error(`Error de unicidad al actualizar la categor√≠a (ej: el nuevo nombre ya existe).`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            // Este error significa que el registro a actualizar (where: { id: categoryId }) no se encontr√≥.
            // Ya lo manejamos con la verificaci√≥n previa, pero es bueno tenerlo por si acaso.
            throw new Error(`Categor√≠a de men√∫ con ID ${categoryId} no encontrada al intentar actualizar.`);
        }
        if (error instanceof Error && error.message.startsWith('Categor√≠a de men√∫ con ID')) {
            throw error; // Relanzar el error espec√≠fico de "no encontrado"
        }
        console.error(`[MC_SVC] Error updating menu category ${categoryId}:`, error);
        throw new Error("Error de base de datos al actualizar la categor√≠a de men√∫.");
    }
};

/**
 * Elimina una categor√≠a de men√∫.
 * Prisma se encargar√° de eliminar los MenuItems asociados debido a `onDelete: Cascade`.
 */
export const deleteMenuCategory = async (categoryId: string, businessId: string): Promise<MenuCategory> => {
    console.log(`[MC_SVC] Deleting menu category ${categoryId} for business ${businessId}`);
    try {
        // Verificar que la categor√≠a existe y pertenece al negocio antes de eliminar
        const existingCategory = await prisma.menuCategory.findFirst({
            where: { id: categoryId, businessId: businessId },
            select: { id: true }
        });
        if (!existingCategory) {
            throw new Error(`Categor√≠a de men√∫ con ID ${categoryId} no encontrada o no pertenece a este negocio.`);
        }

        // Opcional: Verificar si la categor√≠a tiene √≠tems que a su vez est√°n en pedidos activos si onDelete:Restrict se usara
        // En nuestro caso, MenuCategory -> MenuItem tiene onDelete: Cascade, as√≠ que borrar la categor√≠a borrar√° sus √≠tems.
        // Y MenuItem -> OrderItem tiene onDelete: Restrict, lo que PREVENDR√çA borrar un MenuItem si est√° en un pedido.
        // Esto significa que si una categor√≠a tiene √≠tems que est√°n en pedidos, la eliminaci√≥n de la categor√≠a (que intenta borrar los √≠tems) fallar√°
        // debido a la restricci√≥n en MenuItem. Esto es probablemente el comportamiento deseado.

        return await prisma.menuCategory.delete({
            where: { id: categoryId }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Categor√≠a de men√∫ con ID ${categoryId} no encontrada al intentar eliminar.`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') {
            // Error de Foreign key constraint failed on the field: `MenuItem_categoryId_fkey (index)` (o similar)
            // Esto ocurrir√≠a si intentamos borrar una categor√≠a cuyos √≠tems est√°n en uso (ej: en OrderItem) y la relaci√≥n MenuItem->OrderItem es Restrict.
            console.warn(`[MC_SVC] Failed to delete category ${categoryId} due to foreign key constraint (likely items in use).`);
            throw new Error(`No se puede eliminar la categor√≠a porque contiene √≠tems que est√°n actualmente en uso (ej: en pedidos). Elimine o desvincule esos √≠tems primero.`);
        }
        if (error instanceof Error && error.message.startsWith('Categor√≠a de men√∫ con ID')) {
            throw error; // Relanzar el error espec√≠fico de "no encontrado"
        }
        console.error(`[MC_SVC] Error deleting menu category ${categoryId}:`, error);
        throw new Error("Error de base de datos al eliminar la categor√≠a de men√∫.");
    }
};


// ====== [20] backend/src/modules/camarero/admin-menu-item.controller.ts ======
// backend/src/camarero/admin-menu-item.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as menuItemAdminService from './admin-menu-item.service';
import { Prisma } from '@prisma/client'; // Para tipos de error

// --- Handlers del Controlador ---

// POST /api/camarero/admin/menu/categories/:categoryId/items
export const createMenuItemHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!categoryId) return res.status(400).json({ message: "Se requiere ID de la categor√≠a." });

    const {
        name_es, name_en, description_es, description_en, price, imageUrl,
        allergens, tags, isAvailable, position, preparationTime, calories, kdsDestination, sku
    } = req.body;

    // Validaci√≥n b√°sica (mejorar con Zod)
    if (!name_es || typeof name_es !== 'string' || name_es.trim() === '') {
        return res.status(400).json({ message: "El campo 'name_es' (nombre en espa√±ol) es obligatorio." });
    }
    if (price === undefined || typeof price !== 'number' || price < 0) {
        return res.status(400).json({ message: "El campo 'price' es obligatorio y debe ser un n√∫mero positivo." });
    }
    // Aqu√≠ podr√≠as a√±adir m√°s validaciones para los otros campos (tipos, formatos)

    try {
        const menuItemData: Omit<menuItemAdminService.CreateMenuItemData, 'businessId' | 'categoryId'> = {
            name_es: name_es.trim(),
            name_en: name_en?.trim() || null,
            description_es: description_es?.trim() || null,
            description_en: description_en?.trim() || null,
            price: new Prisma.Decimal(price), // Convertir a Decimal para Prisma
            imageUrl: imageUrl || null,
            allergens: Array.isArray(allergens) ? allergens.filter(a => typeof a === 'string') : [],
            tags: Array.isArray(tags) ? tags.filter(t => typeof t === 'string') : [],
            isAvailable: typeof isAvailable === 'boolean' ? isAvailable : true,
            position: typeof position === 'number' ? position : 0,
            preparationTime: typeof preparationTime === 'number' ? preparationTime : null,
            calories: typeof calories === 'number' ? calories : null,
            kdsDestination: kdsDestination || null,
            sku: sku?.trim() || null
        };
        const newItem = await menuItemAdminService.createMenuItem(businessId, categoryId, menuItemData);
        res.status(201).json(newItem);
    } catch (error: any) {
        if (error.message && (error.message.includes('Ya existe un √≠tem') || error.message.includes('Conflicto de unicidad'))) {
            return res.status(409).json({ message: error.message });
        }
        if (error.message && error.message.startsWith('Categor√≠a con ID')) { // Error del servicio si la categor√≠a no es v√°lida
            return res.status(400).json({ message: error.message });
        }
        next(error);
    }
};

// GET /api/camarero/admin/menu/categories/:categoryId/items
export const getMenuItemsByCategoryHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { categoryId } = req.params;
    const { isAvailable } = req.query; // Filtro opcional

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!categoryId) return res.status(400).json({ message: "Se requiere ID de la categor√≠a." });

    try {
        const filter: { isAvailable?: boolean } = {};
        if (isAvailable !== undefined) {
            filter.isAvailable = String(isAvailable).toLowerCase() === 'true';
        }
        const items = await menuItemAdminService.getMenuItemsByCategory(categoryId, businessId, filter);
        res.status(200).json(items);
    } catch (error: any) {
        if (error.message && error.message.startsWith('Categor√≠a con ID')) {
            return res.status(404).json({ message: error.message }); // Si la categor√≠a no existe
        }
        next(error);
    }
};

// GET /api/camarero/admin/menu/items/:itemId
export const getMenuItemByIdHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    try {
        const item = await menuItemAdminService.getMenuItemById(itemId, businessId);
        if (!item) {
            return res.status(404).json({ message: "√çtem de men√∫ no encontrado o no pertenece a este negocio." });
        }
        res.status(200).json(item);
    } catch (error) {
        next(error);
    }
};

// PUT o PATCH /api/camarero/admin/menu/items/:itemId
export const updateMenuItemHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    const updateDataFromRequest = req.body;
    if (Object.keys(updateDataFromRequest).length === 0) {
        return res.status(400).json({ message: "Se requiere al menos un campo para actualizar." });
    }

    try {
        // Construir el objeto de datos para el servicio, procesando cada campo
        const serviceUpdateData: menuItemAdminService.UpdateMenuItemData = {};

        // Campos string opcionales
        if (updateDataFromRequest.name_es !== undefined) serviceUpdateData.name_es = String(updateDataFromRequest.name_es).trim();
        if (updateDataFromRequest.name_en !== undefined) serviceUpdateData.name_en = updateDataFromRequest.name_en === null ? null : String(updateDataFromRequest.name_en).trim() || null;
        if (updateDataFromRequest.description_es !== undefined) serviceUpdateData.description_es = updateDataFromRequest.description_es === null ? null : String(updateDataFromRequest.description_es).trim() || null;
        if (updateDataFromRequest.description_en !== undefined) serviceUpdateData.description_en = updateDataFromRequest.description_en === null ? null : String(updateDataFromRequest.description_en).trim() || null;
        if (updateDataFromRequest.imageUrl !== undefined) serviceUpdateData.imageUrl = updateDataFromRequest.imageUrl === null ? null : String(updateDataFromRequest.imageUrl) || null;
        if (updateDataFromRequest.kdsDestination !== undefined) serviceUpdateData.kdsDestination = updateDataFromRequest.kdsDestination === null ? null : String(updateDataFromRequest.kdsDestination).trim() || null;
        if (updateDataFromRequest.sku !== undefined) serviceUpdateData.sku = updateDataFromRequest.sku === null ? null : String(updateDataFromRequest.sku).trim() || null;
        
        // Campos num√©ricos
        if (updateDataFromRequest.price !== undefined) {
            const priceNum = parseFloat(updateDataFromRequest.price);
            if (isNaN(priceNum) || priceNum < 0) return res.status(400).json({ message: "El precio debe ser un n√∫mero positivo." });
            serviceUpdateData.price = new Prisma.Decimal(priceNum);
        }
        if (updateDataFromRequest.position !== undefined) {
            const posNum = parseInt(updateDataFromRequest.position, 10);
            if (isNaN(posNum)) return res.status(400).json({ message: "La posici√≥n debe ser un n√∫mero." });
            serviceUpdateData.position = posNum;
        }
        if (updateDataFromRequest.preparationTime !== undefined) {
            serviceUpdateData.preparationTime = updateDataFromRequest.preparationTime === null ? null : parseInt(updateDataFromRequest.preparationTime, 10);
            if (serviceUpdateData.preparationTime !== null && isNaN(serviceUpdateData.preparationTime)) return res.status(400).json({ message: "El tiempo de preparaci√≥n debe ser un n√∫mero o nulo." });
        }
        if (updateDataFromRequest.calories !== undefined) {
            serviceUpdateData.calories = updateDataFromRequest.calories === null ? null : parseInt(updateDataFromRequest.calories, 10);
            if (serviceUpdateData.calories !== null && isNaN(serviceUpdateData.calories)) return res.status(400).json({ message: "Las calor√≠as deben ser un n√∫mero o nulo." });
        }

        // Campos booleanos
        if (updateDataFromRequest.isAvailable !== undefined) {
            if (typeof updateDataFromRequest.isAvailable !== 'boolean') return res.status(400).json({ message: "isAvailable debe ser booleano." });
            serviceUpdateData.isAvailable = updateDataFromRequest.isAvailable;
        }

        // Campos array
        if (updateDataFromRequest.allergens !== undefined) {
            if (!Array.isArray(updateDataFromRequest.allergens) || !updateDataFromRequest.allergens.every((s: any) => typeof s === 'string')) return res.status(400).json({ message: "Los al√©rgenos deben ser un array de strings." });
            serviceUpdateData.allergens = updateDataFromRequest.allergens;
        }
        if (updateDataFromRequest.tags !== undefined) {
            if (!Array.isArray(updateDataFromRequest.tags) || !updateDataFromRequest.tags.every((s: any) => typeof s === 'string')) return res.status(400).json({ message: "Las etiquetas deben ser un array de strings." });
            serviceUpdateData.tags = updateDataFromRequest.tags;
        }
        
        // Campo categoryId (para mover el √≠tem de categor√≠a)
        if (updateDataFromRequest.categoryId !== undefined) {
            if (typeof updateDataFromRequest.categoryId !== 'string' || updateDataFromRequest.categoryId.trim() === '') return res.status(400).json({ message: "categoryId debe ser un string v√°lido si se proporciona." });
            serviceUpdateData.categoryId = updateDataFromRequest.categoryId.trim();
        }

        if (Object.keys(serviceUpdateData).length === 0) {
            return res.status(400).json({ message: "No se proporcionaron datos v√°lidos para actualizar." });
        }

        const updatedItem = await menuItemAdminService.updateMenuItem(itemId, businessId, serviceUpdateData);
        res.status(200).json(updatedItem);
    } catch (error: any) {
        if (error.message && (error.message.includes('no encontrado') || error.message.includes('no pertenece'))) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && (error.message.includes('Ya existe un √≠tem') || error.message.includes('Conflicto de unicidad'))) {
            return res.status(409).json({ message: error.message });
        }
         if (error.message && error.message.startsWith('La nueva categor√≠a de destino')) {
            return res.status(400).json({ message: error.message });
        }
        next(error);
    }
};

// DELETE /api/camarero/admin/menu/items/:itemId
export const deleteMenuItemHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    try {
        const deletedItem = await menuItemAdminService.deleteMenuItem(itemId, businessId);
        res.status(200).json({ message: "√çtem de men√∫ eliminado con √©xito.", id: deletedItem.id });
    } catch (error: any) {
         if (error.message && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('est√° en uso')) { // Mensaje del servicio para P2003
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};


// ====== [21] backend/src/modules/camarero/admin-menu-item.service.ts ======
// backend/src/camarero/admin-menu-item.service.ts
import { PrismaClient, MenuItem, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

export type CreateMenuItemData = Omit<
    Prisma.MenuItemCreateInput,
    'business' | 'category' | 'modifierGroups' | 'orderItems'
> & { categoryId: string };

export type UpdateMenuItemData = Partial<
    Omit<Prisma.MenuItemUncheckedUpdateInput, 'id' | 'businessId' | 'createdAt' | 'updatedAt' | 'modifierGroups' | 'orderItems' | 'category'>
    // No necesitamos omitir 'businessId' si no lo vamos a permitir cambiar desde aqu√≠.
    // 'id', 'createdAt', 'updatedAt' son gestionados por Prisma o no deber√≠an ser actualizables.
    // 'category' como relaci√≥n se maneja a trav√©s de 'categoryId'.
    // 'modifierGroups' y 'orderItems' son relaciones que se gestionar√≠an por separado.
>;


export const createMenuItem = async (
    businessId: string,
    categoryId: string,
    data: Omit<CreateMenuItemData, 'businessId' | 'categoryId'>
): Promise<MenuItem> => {
    console.log(`[MI_SVC] Creating menu item for business ${businessId}, category ${categoryId}:`, data.name_es);
    try {
        const categoryExists = await prisma.menuCategory.findFirst({
            where: { id: categoryId, businessId: businessId },
            select: { id: true }
        });
        if (!categoryExists) {
            throw new Error(`Categor√≠a con ID ${categoryId} no encontrada o no pertenece al negocio ${businessId}.`);
        }

        const skuValue = data.sku // data.sku puede ser string | null | undefined
            ? (typeof data.sku === 'string' ? data.sku.trim() : data.sku) // si es string, trim√©alo
            : null; // si es undefined o null, queda como null

        const newItem = await prisma.menuItem.create({
            data: {
                ...data,
                sku: skuValue || null, // Asegurar que se env√≠e null si es cadena vac√≠a despu√©s del trim
                business: { connect: { id: businessId } },
                category: { connect: { id: categoryId } },
            }
        });
        return newItem;
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            console.warn(`[MI_SVC] Unique constraint violation for item:`, data.name_es, error.meta);
            const target = error.meta?.target as string[];
            if (target?.includes('name_es') && target?.includes('categoryId')) {
                 throw new Error(`Ya existe un √≠tem con el nombre '${data.name_es}' en esta categor√≠a.`);
            }
            if (target?.includes('sku') && target?.includes('businessId')) {
                 throw new Error(`Ya existe un √≠tem con el SKU '${data.sku || ''}' en este negocio.`);
            }
            throw new Error(`Conflicto de unicidad al crear el √≠tem de men√∫.`);
        }
        if (error instanceof Error && error.message.startsWith('Categor√≠a con ID')) {
            throw error;
        }
        console.error(`[MI_SVC] Error creating menu item for business ${businessId}:`, error);
        throw new Error("Error de base de datos al crear el √≠tem de men√∫.");
    }
};

export const getMenuItemsByCategory = async (
    categoryId: string,
    businessId: string,
    filter?: { isAvailable?: boolean }
): Promise<MenuItem[]> => {
    console.log(`[MI_SVC] Fetching menu items for category ${categoryId}, business ${businessId}, filter:`, filter);
    try {
        const categoryExists = await prisma.menuCategory.findFirst({
            where: { id: categoryId, businessId: businessId },
            select: { id: true }
        });
        if (!categoryExists) {
            throw new Error(`Categor√≠a con ID ${categoryId} no encontrada o no pertenece al negocio ${businessId}.`);
        }

        const whereClause: Prisma.MenuItemWhereInput = { categoryId };
        if (filter?.isAvailable !== undefined) {
            whereClause.isAvailable = filter.isAvailable;
        }

        return await prisma.menuItem.findMany({
            where: whereClause,
            orderBy: { position: 'asc' },
        });
    } catch (error) {
        if (error instanceof Error && error.message.startsWith('Categor√≠a con ID')) {
            throw error;
        }
        console.error(`[MI_SVC] Error fetching menu items for category ${categoryId}:`, error);
        throw new Error("Error al obtener los √≠tems de men√∫.");
    }
};

export const getMenuItemById = async (menuItemId: string, businessId: string): Promise<MenuItem | null> => {
    console.log(`[MI_SVC] Fetching menu item ${menuItemId} for business ${businessId}`);
    try {
        return await prisma.menuItem.findFirst({
            where: {
                id: menuItemId,
                businessId: businessId
            },
        });
    } catch (error) {
        console.error(`[MI_SVC] Error fetching menu item ${menuItemId}:`, error);
        throw new Error("Error al obtener el √≠tem de men√∫ por ID.");
    }
};

export const updateMenuItem = async (
    menuItemId: string,
    businessId: string,
    data: UpdateMenuItemData
): Promise<MenuItem> => {
    console.log(`[MI_SVC] Updating menu item ${menuItemId} for business ${businessId}:`, data);
    try {
        const existingItem = await prisma.menuItem.findFirst({
            where: { id: menuItemId, businessId: businessId },
            select: { id: true, categoryId: true }
        });
        if (!existingItem) {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado o no pertenece a este negocio.`);
        }

        // --- CORRECCI√ìN en la construcci√≥n de updatePayload ---
        // Clonamos 'data' para no modificar el objeto original y tiparlo correctamente
        const updatePayload: Prisma.MenuItemUpdateInput = { ...data } as Prisma.MenuItemUpdateInput;

        // Manejo espec√≠fico para SKU: si se proporciona, trimear si es string, o pasar null.
        // Si no se proporciona (undefined), no se incluye en updatePayload, por lo que no se actualiza.
        if (data.sku !== undefined) {
            if (typeof data.sku === 'string') {
                updatePayload.sku = data.sku.trim() || null; // Si despu√©s de trim es vac√≠o, se vuelve null
            } else { // data.sku es null
                updatePayload.sku = null;
            }
        }
        // --- FIN CORRECCI√ìN ---
        
        // Si se intenta cambiar categoryId
        if (data.categoryId && typeof data.categoryId === 'string' && data.categoryId !== existingItem.categoryId) {
            const newCategory = await prisma.menuCategory.findFirst({
                where: { id: data.categoryId, businessId: businessId },
                select: { id: true }
            });
            if (!newCategory) {
                throw new Error(`La nueva categor√≠a de destino (ID: ${data.categoryId}) no es v√°lida o no pertenece a este negocio.`);
            }
            // 'categoryId' se pasar√° directamente en updatePayload si est√° en 'data'
            // y el tipo UpdateMenuItemData lo permite (MenuItemUncheckedUpdateInput lo hace).
        }

        return await prisma.menuItem.update({
            where: { id: menuItemId },
            data: updatePayload, // Aqu√≠ updatePayload contiene los campos procesados
        });
    } catch (error) {
        // ... (manejo de errores sin cambios) ...
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            console.warn(`[MI_SVC] Unique constraint violation on update for item ${menuItemId}:`, error.meta);
            const target = error.meta?.target as string[];
            if (target?.includes('name_es') && target?.includes('categoryId')) {
                 throw new Error(`Ya existe un √≠tem con el nuevo nombre en la categor√≠a especificada.`);
            }
            if (target?.includes('sku') && target?.includes('businessId')) {
                 throw new Error(`Ya existe un √≠tem con el nuevo SKU en este negocio.`);
            }
            throw new Error(`Conflicto de unicidad al actualizar el √≠tem de men√∫.`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado al intentar actualizar.`);
        }
        if (error instanceof Error && (error.message.startsWith('√çtem de men√∫ con ID') || error.message.startsWith('La nueva categor√≠a'))) {
            throw error;
        }
        console.error(`[MI_SVC] Error updating menu item ${menuItemId}:`, error);
        throw new Error("Error de base de datos al actualizar el √≠tem de men√∫.");
    }
};

export const deleteMenuItem = async (menuItemId: string, businessId: string): Promise<MenuItem> => {
    console.log(`[MI_SVC] Deleting menu item ${menuItemId} for business ${businessId}`);
    try {
        const existingItem = await prisma.menuItem.findFirst({
            where: { id: menuItemId, businessId: businessId },
            select: { id: true }
        });
        if (!existingItem) {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado o no pertenece a este negocio.`);
        }

        return await prisma.menuItem.delete({
            where: { id: menuItemId }
        });
    } catch (error) {
        // ... (manejo de errores sin cambios) ...
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado al intentar eliminar.`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') {
             console.warn(`[MI_SVC] Failed to delete menu item ${menuItemId} due to foreign key constraint (P2003).`);
            throw new Error(`No se puede eliminar el √≠tem de men√∫ porque est√° en uso (ej: en pedidos existentes). Considere desactivarlo en su lugar.`);
        }
        if (error instanceof Error && error.message.startsWith('√çtem de men√∫ con ID')) {
            throw error;
        }
        console.error(`[MI_SVC] Error deleting menu item ${menuItemId}:`, error);
        throw new Error("Error de base de datos al eliminar el √≠tem de men√∫.");
    }
};


// ====== [22] backend/src/modules/camarero/admin-modifier.controller.ts ======
// backend/src/camarero/admin-modifier.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as modifierAdminService from './admin-modifier.service';
import { Prisma } from '@prisma/client'; // Para tipos de error

// === Handlers para ModifierGroup ===

// POST /api/camarero/admin/menu/items/:itemId/modifier-groups
export const createModifierGroupHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    const { name_es, name_en, uiType, minSelections, maxSelections, position, isRequired } = req.body;

    // Validaci√≥n b√°sica (mejorar con Zod)
    if (!name_es || typeof name_es !== 'string' || name_es.trim() === '') {
        return res.status(400).json({ message: "El campo 'name_es' (nombre en espa√±ol) es obligatorio para el grupo." });
    }
    // A√±adir m√°s validaciones para uiType, minSelections, maxSelections, etc.

    try {
        const groupData: Omit<modifierAdminService.CreateModifierGroupData, 'businessId' | 'menuItemId'> = {
            name_es: name_es.trim(),
            name_en: name_en?.trim() || null,
            uiType: uiType || "RADIO", // Valor por defecto si no se provee
            minSelections: typeof minSelections === 'number' ? minSelections : 0,
            maxSelections: typeof maxSelections === 'number' ? maxSelections : 1,
            position: typeof position === 'number' ? position : 0,
            isRequired: typeof isRequired === 'boolean' ? isRequired : false,
        };
        const newGroup = await modifierAdminService.createModifierGroup(businessId, itemId, groupData);
        res.status(201).json(newGroup);
    } catch (error: any) {
        if (error.message && (error.message.includes('Ya existe un grupo') || error.message.startsWith('√çtem de men√∫ con ID'))) {
            return res.status(error.message.startsWith('√çtem de men√∫ con ID') ? 404 : 409).json({ message: error.message });
        }
        next(error);
    }
};

// GET /api/camarero/admin/menu/items/:itemId/modifier-groups
export const getModifierGroupsByMenuItemHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { itemId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!itemId) return res.status(400).json({ message: "Se requiere ID del √≠tem de men√∫." });

    try {
        const groups = await modifierAdminService.getModifierGroupsByMenuItem(itemId, businessId);
        res.status(200).json(groups);
    } catch (error: any) {
        if (error.message && error.message.startsWith('√çtem de men√∫ con ID')) {
            return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

// PUT o PATCH /api/camarero/admin/modifier-groups/:modifierGroupId
export const updateModifierGroupHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { modifierGroupId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierGroupId) return res.status(400).json({ message: "Se requiere ID del grupo de modificadores." });

    const updateDataFromRequest = req.body;
    if (Object.keys(updateDataFromRequest).length === 0) {
        return res.status(400).json({ message: "Se requiere al menos un campo para actualizar." });
    }
    // Aqu√≠ ir√≠an validaciones m√°s detalladas para los campos de updateDataFromRequest

    try {
        // No es necesario construir el objeto 'serviceUpdateData' aqu√≠ si el tipo del servicio es suficientemente permisivo
        // y los nombres de campo coinciden. El servicio se encarga de la l√≥gica.
        const updatedGroup = await modifierAdminService.updateModifierGroup(modifierGroupId, businessId, updateDataFromRequest);
        res.status(200).json(updatedGroup);
    } catch (error: any) {
        if (error.message && error.message.startsWith('Grupo de modificadores con ID')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('Error de unicidad')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};

// DELETE /api/camarero/admin/modifier-groups/:modifierGroupId
export const deleteModifierGroupHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const { modifierGroupId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierGroupId) return res.status(400).json({ message: "Se requiere ID del grupo de modificadores." });

    try {
        const deletedGroup = await modifierAdminService.deleteModifierGroup(modifierGroupId, businessId);
        res.status(200).json({ message: "Grupo de modificadores eliminado con √©xito.", id: deletedGroup.id });
    } catch (error: any) {
        if (error.message && error.message.startsWith('Grupo de modificadores con ID')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('opciones est√° en uso')) { // Mensaje del servicio para P2003
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};


// === Handlers para ModifierOption ===

// POST /api/camarero/admin/modifier-groups/:modifierGroupId/options
export const createModifierOptionHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Para verificar pertenencia del grupo padre
    const { modifierGroupId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierGroupId) return res.status(400).json({ message: "Se requiere ID del grupo de modificadores." });

    const { name_es, name_en, priceAdjustment, position, isDefault, isAvailable } = req.body;

    if (!name_es || typeof name_es !== 'string' || name_es.trim() === '') {
        return res.status(400).json({ message: "El campo 'name_es' es obligatorio para la opci√≥n." });
    }
    // A√±adir m√°s validaciones (priceAdjustment debe ser n√∫mero, etc.)

    try {
        const optionData: Omit<modifierAdminService.CreateModifierOptionData, 'groupId'> = {
            name_es: name_es.trim(),
            name_en: name_en?.trim() || null,
            priceAdjustment: priceAdjustment === undefined ? 0 : new Prisma.Decimal(priceAdjustment),
            position: typeof position === 'number' ? position : 0,
            isDefault: typeof isDefault === 'boolean' ? isDefault : false,
            isAvailable: typeof isAvailable === 'boolean' ? isAvailable : true,
        };
        const newOption = await modifierAdminService.createModifierOption(modifierGroupId, businessId, optionData);
        res.status(201).json(newOption);
    } catch (error: any) {
        if (error.message && (error.message.includes('Ya existe una opci√≥n') || error.message.startsWith('Grupo de modificadores con ID'))) {
            return res.status(error.message.startsWith('Grupo de modificadores con ID') ? 404 : 409).json({ message: error.message });
        }
        next(error);
    }
};

// GET /api/camarero/admin/modifier-groups/:modifierGroupId/options
export const getModifierOptionsByGroupHandler = async (req: Request, res: Response, next: NextFunction) => {
    // businessId no es estrictamente necesario aqu√≠ si el servicio conf√≠a en que modifierGroupId es v√°lido
    // pero se podr√≠a a√±adir una capa extra de verificaci√≥n si se desea.
    const { modifierGroupId } = req.params;
    if (!modifierGroupId) return res.status(400).json({ message: "Se requiere ID del grupo de modificadores." });

    try {
        // El servicio getModifierOptionsByGroup podr√≠a necesitar businessId si queremos verificar que el grupo
        // realmente pertenece al negocio del admin autenticado, ANTES de buscar las opciones.
        // Por ahora, el servicio actual no lo requiere, pero es una consideraci√≥n de seguridad/l√≥gica.
        const options = await modifierAdminService.getModifierOptionsByGroup(modifierGroupId);
        res.status(200).json(options);
    } catch (error) {
        next(error);
    }
};

// PUT o PATCH /api/camarero/admin/modifier-options/:modifierOptionId
export const updateModifierOptionHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Para verificar pertenencia
    const { modifierOptionId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierOptionId) return res.status(400).json({ message: "Se requiere ID de la opci√≥n de modificador." });

    const updateDataFromRequest = req.body;
    if (Object.keys(updateDataFromRequest).length === 0) {
        return res.status(400).json({ message: "Se requiere al menos un campo para actualizar." });
    }
    // Aqu√≠ ir√≠an validaciones m√°s detalladas

    try {
        const serviceUpdateData: modifierAdminService.UpdateModifierOptionData = { ...updateDataFromRequest };
        if (updateDataFromRequest.priceAdjustment !== undefined) {
            serviceUpdateData.priceAdjustment = new Prisma.Decimal(updateDataFromRequest.priceAdjustment);
        }
        // ... procesar otros campos si necesitan conversi√≥n o validaci√≥n espec√≠fica ...

        const updatedOption = await modifierAdminService.updateModifierOption(modifierOptionId, businessId, serviceUpdateData);
        res.status(200).json(updatedOption);
    } catch (error: any) {
        if (error.message && error.message.startsWith('Opci√≥n de modificador con ID')) {
            return res.status(404).json({ message: error.message });
        }
        if (error.message && error.message.includes('Error de unicidad')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};

// DELETE /api/camarero/admin/modifier-options/:modifierOptionId
export const deleteModifierOptionHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Para verificar pertenencia
    const { modifierOptionId } = req.params;

    if (!businessId) return res.status(403).json({ message: "Identificador de negocio no encontrado." });
    if (!modifierOptionId) return res.status(400).json({ message: "Se requiere ID de la opci√≥n de modificador." });

    try {
        const deletedOption = await modifierAdminService.deleteModifierOption(modifierOptionId, businessId);
        res.status(200).json({ message: "Opci√≥n de modificador eliminada con √©xito.", id: deletedOption.id });
    } catch (error: any) {
        if (error.message && error.message.startsWith('Opci√≥n de modificador con ID')) {
            return res.status(404).json({ message: error.message });
        }
         if (error.message && error.message.includes('est√° en uso')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};


// ====== [23] backend/src/modules/camarero/admin-modifier.service.ts ======
// backend/src/camarero/admin-modifier.service.ts
import { PrismaClient, ModifierGroup, ModifierOption, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

// --- TIPOS PARA ModifierGroup ---
export type CreateModifierGroupData = Omit<Prisma.ModifierGroupCreateInput, 'menuItem' | 'business' | 'options'>;
export type UpdateModifierGroupData = Partial<Omit<Prisma.ModifierGroupUpdateInput, 'menuItem' | 'business' | 'options'>>;

// --- TIPOS PARA ModifierOption ---
export type CreateModifierOptionData = Omit<Prisma.ModifierOptionCreateInput, 'group' | 'orderItems'>;
export type UpdateModifierOptionData = Partial<Omit<Prisma.ModifierOptionUpdateInput, 'group' | 'orderItems'>>;

// === L√ìGICA PARA ModifierGroup ===

/**
 * Crea un nuevo grupo de modificadores para un √≠tem de men√∫ espec√≠fico.
 */
export const createModifierGroup = async (
    businessId: string,
    menuItemId: string,
    data: Omit<CreateModifierGroupData, 'businessId' | 'menuItemId'>
): Promise<ModifierGroup> => {
    console.log(`[MOD_SVC] Creating modifier group for menuItem ${menuItemId}, business ${businessId}:`, data.name_es);
    try {
        // Verificar que el MenuItem pertenece al businessId
        const menuItemExists = await prisma.menuItem.findFirst({
            where: { id: menuItemId, businessId: businessId },
            select: { id: true }
        });
        if (!menuItemExists) {
            throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado o no pertenece al negocio ${businessId}.`);
        }

        return await prisma.modifierGroup.create({
            data: {
                ...data,
                menuItem: { connect: { id: menuItemId } },
                business: { connect: { id: businessId } } // Conectar tambi√©n al negocio
            }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            throw new Error(`Ya existe un grupo de modificadores con el nombre '${data.name_es}' para este √≠tem de men√∫.`);
        }
        if (error instanceof Error && error.message.startsWith('√çtem de men√∫ con ID')) throw error;
        console.error(`[MOD_SVC] Error creating modifier group for menuItem ${menuItemId}:`, error);
        throw new Error("Error de base de datos al crear el grupo de modificadores.");
    }
};

/**
 * Obtiene todos los grupos de modificadores para un √≠tem de men√∫.
 */
export const getModifierGroupsByMenuItem = async (menuItemId: string, businessId: string): Promise<ModifierGroup[]> => {
    console.log(`[MOD_SVC] Fetching modifier groups for menuItem ${menuItemId}, business ${businessId}`);
    try {
        // Verificar que el MenuItem pertenece al businessId (opcional, pero buena pr√°ctica)
        const menuItemExists = await prisma.menuItem.count({ where: { id: menuItemId, businessId: businessId }});
        if (menuItemExists === 0) {
             throw new Error(`√çtem de men√∫ con ID ${menuItemId} no encontrado o no pertenece al negocio ${businessId}.`);
        }

        return await prisma.modifierGroup.findMany({
            where: { menuItemId: menuItemId },
            orderBy: { position: 'asc' },
            include: { options: { orderBy: { position: 'asc' } } } // Incluir opciones ordenadas
        });
    } catch (error) {
        if (error instanceof Error && error.message.startsWith('√çtem de men√∫ con ID')) throw error;
        console.error(`[MOD_SVC] Error fetching modifier groups for menuItem ${menuItemId}:`, error);
        throw new Error("Error al obtener los grupos de modificadores.");
    }
};

/**
 * Actualiza un grupo de modificadores existente.
 */
export const updateModifierGroup = async (
    modifierGroupId: string,
    businessId: string, // Para verificar pertenencia
    data: UpdateModifierGroupData
): Promise<ModifierGroup> => {
    console.log(`[MOD_SVC] Updating modifier group ${modifierGroupId} for business ${businessId}:`, data);
    try {
        const existingGroup = await prisma.modifierGroup.findFirst({
            where: { id: modifierGroupId, businessId: businessId }, // Asegurar que el grupo pertenece al negocio
            select: { id: true }
        });
        if (!existingGroup) {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado o no pertenece a este negocio.`);
        }
        return await prisma.modifierGroup.update({
            where: { id: modifierGroupId },
            data: data
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            throw new Error(`Error de unicidad al actualizar el grupo de modificadores (ej: el nuevo nombre ya existe para el √≠tem).`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado.`);
        }
        if (error instanceof Error && error.message.startsWith('Grupo de modificadores con ID')) throw error;
        console.error(`[MOD_SVC] Error updating modifier group ${modifierGroupId}:`, error);
        throw new Error("Error de base de datos al actualizar el grupo de modificadores.");
    }
};

/**
 * Elimina un grupo de modificadores (y sus opciones en cascada).
 */
export const deleteModifierGroup = async (modifierGroupId: string, businessId: string): Promise<ModifierGroup> => {
    console.log(`[MOD_SVC] Deleting modifier group ${modifierGroupId} for business ${businessId}`);
    try {
        const existingGroup = await prisma.modifierGroup.findFirst({
            where: { id: modifierGroupId, businessId: businessId },
            select: { id: true }
        });
        if (!existingGroup) {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado o no pertenece a este negocio.`);
        }
        // Prisma maneja el borrado en cascada de ModifierOption debido a la relaci√≥n
        return await prisma.modifierGroup.delete({
            where: { id: modifierGroupId }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado.`);
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') {
            throw new Error(`No se puede eliminar el grupo de modificadores porque una de sus opciones est√° en uso (ej: en pedidos).`);
        }
        if (error instanceof Error && error.message.startsWith('Grupo de modificadores con ID')) throw error;
        console.error(`[MOD_SVC] Error deleting modifier group ${modifierGroupId}:`, error);
        throw new Error("Error de base de datos al eliminar el grupo de modificadores.");
    }
};


// === L√ìGICA PARA ModifierOption ===

/**
 * Crea una nueva opci√≥n de modificador para un grupo espec√≠fico.
 */
export const createModifierOption = async (
    modifierGroupId: string,
    businessId: string, // Para verificar que el grupo padre pertenece al negocio
    data: Omit<CreateModifierOptionData, 'groupId'>
): Promise<ModifierOption> => {
    console.log(`[MOD_SVC] Creating modifier option for group ${modifierGroupId}, business ${businessId}:`, data.name_es);
    try {
        // Verificar que el ModifierGroup padre pertenece al businessId
        const groupExists = await prisma.modifierGroup.findFirst({
            where: { id: modifierGroupId, businessId: businessId },
            select: { id: true }
        });
        if (!groupExists) {
            throw new Error(`Grupo de modificadores con ID ${modifierGroupId} no encontrado o no pertenece al negocio ${businessId}.`);
        }

        return await prisma.modifierOption.create({
            data: {
                ...data,
                group: { connect: { id: modifierGroupId } }
            }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            throw new Error(`Ya existe una opci√≥n con el nombre '${data.name_es}' en este grupo de modificadores.`);
        }
        if (error instanceof Error && error.message.startsWith('Grupo de modificadores con ID')) throw error;
        console.error(`[MOD_SVC] Error creating modifier option for group ${modifierGroupId}:`, error);
        throw new Error("Error de base de datos al crear la opci√≥n de modificador.");
    }
};

/**
 * Obtiene todas las opciones para un grupo de modificadores espec√≠fico.
 * (La verificaci√≥n de pertenencia del grupo al negocio ya se har√≠a al obtener/validar el grupo)
 */
export const getModifierOptionsByGroup = async (modifierGroupId: string): Promise<ModifierOption[]> => {
    console.log(`[MOD_SVC] Fetching modifier options for group ${modifierGroupId}`);
    try {
        return await prisma.modifierOption.findMany({
            where: { groupId: modifierGroupId },
            orderBy: { position: 'asc' }
        });
    } catch (error) {
        console.error(`[MOD_SVC] Error fetching modifier options for group ${modifierGroupId}:`, error);
        throw new Error("Error al obtener las opciones de modificadores.");
    }
};

/**
 * Actualiza una opci√≥n de modificador existente.
 */
export const updateModifierOption = async (
    modifierOptionId: string,
    businessId: string, // Para verificar que la opci√≥n pertenece a un grupo de ese negocio
    data: UpdateModifierOptionData
): Promise<ModifierOption> => {
    console.log(`[MOD_SVC] Updating modifier option ${modifierOptionId} for business ${businessId}:`, data);
    try {
        // Verificar que la opci√≥n pertenece a un grupo del negocio
        const existingOption = await prisma.modifierOption.findFirst({
            where: {
                id: modifierOptionId,
                group: { businessId: businessId } // Verificar a trav√©s de la relaci√≥n con el grupo
            },
            select: { id: true }
        });
        if (!existingOption) {
            throw new Error(`Opci√≥n de modificador con ID ${modifierOptionId} no encontrada o no pertenece a este negocio.`);
        }

        return await prisma.modifierOption.update({
            where: { id: modifierOptionId },
            data: data
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            throw new Error(`Error de unicidad al actualizar la opci√≥n (ej: el nuevo nombre ya existe en el grupo).`);
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Opci√≥n de modificador con ID ${modifierOptionId} no encontrada.`);
        }
        if (error instanceof Error && error.message.startsWith('Opci√≥n de modificador con ID')) throw error;
        console.error(`[MOD_SVC] Error updating modifier option ${modifierOptionId}:`, error);
        throw new Error("Error de base de datos al actualizar la opci√≥n de modificador.");
    }
};

/**
 * Elimina una opci√≥n de modificador.
 */
export const deleteModifierOption = async (modifierOptionId: string, businessId: string): Promise<ModifierOption> => {
    console.log(`[MOD_SVC] Deleting modifier option ${modifierOptionId} for business ${businessId}`);
    try {
        const existingOption = await prisma.modifierOption.findFirst({
            where: {
                id: modifierOptionId,
                group: { businessId: businessId }
            },
            select: { id: true }
        });
        if (!existingOption) {
            throw new Error(`Opci√≥n de modificador con ID ${modifierOptionId} no encontrada o no pertenece a este negocio.`);
        }
        // Prisma maneja el borrado en cascada si esta opci√≥n estuviera en OrderItemModifierOption
        // debido a la relaci√≥n en ese modelo de uni√≥n.
        return await prisma.modifierOption.delete({
            where: { id: modifierOptionId }
        });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error(`Opci√≥n de modificador con ID ${modifierOptionId} no encontrada.`);
        }
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2003') {
            // Foreign key constraint failed on the field: `OrderItemModifierOption_modifierOptionId_fkey (index)`
            throw new Error(`No se puede eliminar la opci√≥n porque est√° en uso (ej: en pedidos existentes).`);
        }
        if (error instanceof Error && error.message.startsWith('Opci√≥n de modificador con ID')) throw error;
        console.error(`[MOD_SVC] Error deleting modifier option ${modifierOptionId}:`, error);
        throw new Error("Error de base de datos al eliminar la opci√≥n de modificador.");
    }
};


// ====== [24] backend/src/modules/camarero/camarero.dto.ts ======
// backend/src/camarero/camarero.dto.ts
// Version: 1.2.0 (Add WaiterOrderListItemDto)

import { OrderItemStatus, OrderStatus, OrderType } from '@prisma/client'; // A√±adido OrderType

/**
 * DTO para la informaci√≥n de un modificador seleccionado que se muestra al camarero
 * como parte de un √≠tem listo para recoger.
 */
export interface WaiterSelectedModifierDto {
  optionName_es: string | null;
  optionName_en: string | null;
}

/**
 * DTO para cada √≠tem de pedido que est√° listo para ser recogido y servido por el personal de camareros.
 * Esta es la estructura de datos que el endpoint GET /api/camarero/staff/ready-for-pickup devolver√°.
 */
export interface ReadyPickupItemDto {
  orderItemId: string;
  orderId: string;
  orderNumber: string;
  orderCreatedAt: Date;
  tableIdentifier: string | null;
  itemNameSnapshot_es: string | null;
  itemNameSnapshot_en: string | null;
  quantity: number;
  itemNotes: string | null;
  kdsDestination: string | null;
  selectedModifiers: WaiterSelectedModifierDto[];
  currentOrderItemStatus: OrderItemStatus;
}

/**
 * DTO para el payload del endpoint que permite al camarero marcar un OrderItem como SERVED.
 * Usado en: PATCH /api/camarero/staff/order-items/:orderItemId/status
 */
export interface MarkOrderItemServedPayloadDto {
  newStatus: typeof OrderItemStatus.SERVED;
}

/**
 * DTO para la respuesta est√°ndar al actualizar el estado de un OrderItem
 * desde la interfaz de camarero o KDS.
 */
export interface OrderItemStatusUpdateResponseDto {
  message: string;
  orderItemId: string;
  newStatus: OrderItemStatus;
  orderStatus?: OrderStatus;
}

/**
 * DTO para el payload del endpoint que permite al personal solicitar la cuenta.
 * Usado en: POST /api/camarero/staff/order/:orderId/request-bill
 */
export interface RequestBillPayloadDto {
  paymentPreference?: string;
}

/**
 * DTO para el payload del endpoint que permite al camarero marcar un pedido como PAGADO.
 * Usado en: POST /api/camarero/staff/order/:orderId/mark-as-paid
 */
export interface MarkOrderAsPaidPayloadDto {
  method?: string;
  notes?: string;
}

// ---- NUEVO DTO ----
/**
 * DTO para representar un √≠tem en la lista de pedidos para la interfaz del camarero.
 * Usado en: GET /api/camarero/staff/orders
 */
export interface WaiterOrderListItemDto {
  orderId: string;
  orderNumber: string;
  tableIdentifier: string | null;
  status: OrderStatus;
  finalAmount: number; // O string si prefieres manejarlo como string en el frontend inicialmente
  itemCount: number; // N√∫mero total de √≠tems (no cancelados) en el pedido
  customerName?: string | null; // Nombre del cliente LCo si est√° asociado
  createdAt: Date; // Fecha de creaci√≥n del pedido
  isBillRequested?: boolean; // Para saber si la cuenta ya fue solicitada
  orderType?: OrderType | null; // Tipo de pedido
}
// ---- FIN NUEVO DTO ----


// ====== [25] backend/src/modules/camarero/kds.controller.ts ======
// backend/src/camarero/kds.controller.ts
import { Request, Response, NextFunction } from 'express';
import { OrderItemStatus } from '@prisma/client'; // Para validar el enum
import * as kdsService from './kds.service';

/**
 * Handler para GET /api/camarero/kds/items
 * Obtiene los √≠tems de pedido para una destino KDS espec√≠fico.
 */
export const getItemsForKdsHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Asumimos que authenticateToken ya lo a√±adi√≥
    const { destination, status } = req.query;

    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado en la sesi√≥n del usuario." });
    }
    if (!destination || typeof destination !== 'string' || destination.trim() === '') {
        return res.status(400).json({ message: "El par√°metro 'destination' (destino KDS) es obligatorio." });
    }

    let statusFilter: OrderItemStatus[] | undefined = undefined;
    if (status) {
        if (typeof status === 'string') {
            const singleStatus = status.toUpperCase() as OrderItemStatus;
            if (Object.values(OrderItemStatus).includes(singleStatus)) {
                statusFilter = [singleStatus];
            } else {
                return res.status(400).json({ message: `Valor de 'status' inv√°lido: ${status}` });
            }
        } else if (Array.isArray(status)) {
            statusFilter = [];
            for (const s of status) {
                if (typeof s === 'string') {
                    const singleStatus = s.toUpperCase() as OrderItemStatus;
                     if (Object.values(OrderItemStatus).includes(singleStatus)) {
                        statusFilter.push(singleStatus);
                    } else {
                        return res.status(400).json({ message: `Valor de 'status' inv√°lido en el array: ${s}` });
                    }
                } else {
                     return res.status(400).json({ message: "Todos los valores de 'status' en el array deben ser strings." });
                }
            }
            if (statusFilter.length === 0) statusFilter = undefined; // Si el array queda vac√≠o, no filtrar
        } else {
            return res.status(400).json({ message: "El par√°metro 'status' debe ser un string o un array de strings." });
        }
    }
    
    console.log(`[KDS CTRL] Request for KDS items. Business: ${businessId}, Dest: ${destination}, Status: ${statusFilter?.join(',') || 'Default'}`);

    try {
        const items = await kdsService.getItemsForKds(businessId, destination.trim().toUpperCase(), statusFilter);
        res.status(200).json(items);
    } catch (error) {
        console.error(`[KDS CTRL] Error getting items for KDS (Dest: ${destination}):`, error);
        next(error); // Pasar al manejador de errores global
    }
};

/**
 * Handler para PATCH /api/camarero/kds/items/:orderItemId/status
 * Actualiza el estado de un OrderItem espec√≠fico.
 */
export const updateOrderItemStatusHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId; // Asumimos que authenticateToken ya lo a√±adi√≥
    const { orderItemId } = req.params;
    const { newStatus } = req.body; // Esperamos { "newStatus": "PREPARING" } por ejemplo

    if (!businessId) {
        return res.status(403).json({ message: "Identificador de negocio no encontrado en la sesi√≥n del usuario." });
    }
    if (!orderItemId) {
        return res.status(400).json({ message: "Falta el ID del √≠tem de pedido (orderItemId) en la URL." });
    }
    if (!newStatus || typeof newStatus !== 'string') {
        return res.status(400).json({ message: "Falta el campo 'newStatus' o no es un string en el cuerpo de la petici√≥n." });
    }

    const validatedNewStatus = newStatus.toUpperCase() as OrderItemStatus;
    if (!Object.values(OrderItemStatus).includes(validatedNewStatus)) {
        return res.status(400).json({ message: `El valor de 'newStatus' ('${newStatus}') no es un estado v√°lido.` });
    }
    
    console.log(`[KDS CTRL] Request to update OrderItem ${orderItemId} to status ${validatedNewStatus} for business ${businessId}`);

    try {
        const updatedItem = await kdsService.updateOrderItemStatus(orderItemId, validatedNewStatus, businessId);
        res.status(200).json(updatedItem);
    } catch (error: any) { // Especificar 'any' o un tipo m√°s espec√≠fico
        console.error(`[KDS CTRL] Error updating status for OrderItem ${orderItemId} to ${validatedNewStatus}:`, error);
        // El servicio ya puede lanzar errores con mensajes espec√≠ficos (ej: transici√≥n no permitida, √≠tem no encontrado)
        // Si el mensaje es espec√≠fico del servicio y queremos mostrarlo, lo pasamos tal cual.
        if (error.message) {
            // Podr√≠amos mapear ciertos mensajes de error a c√≥digos de estado HTTP espec√≠ficos
            if (error.message.includes('no encontrado')) {
                return res.status(404).json({ message: error.message });
            }
            if (error.message.includes('no permitida')) {
                return res.status(400).json({ message: error.message }); // Bad Request por l√≥gica de negocio
            }
        }
        next(error); // Pasar otros errores al manejador global
    }
};


// ====== [26] backend/src/modules/camarero/kds.service.ts ======
// backend/src/camarero/kds.service.ts
// Version: 1.1.1 (Corrected enums based on TS errors, refined Order.status logic - FULL FILE)

import { PrismaClient, Prisma, OrderItem, OrderItemStatus, OrderStatus } from '@prisma/client';

const prisma = new PrismaClient();

// Tipo para la informaci√≥n que necesita el KDS para cada OrderItem
export interface KdsOrderItemData {
    id: string; // OrderItem ID
    quantity: number;
    status: OrderItemStatus; // Usar√° los enums del cliente: PENDING_KDS, PREPARING, READY, etc.
    notes: string | null;
    kdsDestination: string | null;
    menuItemName_es: string | null;
    menuItemName_en: string | null;
    selectedModifiers: {
        optionName_es: string | null;
        optionName_en: string | null;
    }[];
    orderInfo: {
        id: string; // Order ID
        orderNumber: string;
        createdAt: Date;
        tableIdentifier: string | null;
    };
    preparationTime?: number | null;
    preparedAt?: Date | null;
    servedAt?: Date | null;
}


/**
 * Obtiene los √≠tems de pedido para una destino KDS espec√≠fico.
 * @param businessId - ID del negocio.
 * @param kdsDestination - El destino KDS (ej. "COCINA", "BARRA").
 * @param filterStatus - Array opcional de OrderItemStatus para filtrar.
 * @returns Array de KdsOrderItemData.
 */
export const getItemsForKds = async (
    businessId: string,
    kdsDestination: string,
    filterStatus?: OrderItemStatus[]
): Promise<KdsOrderItemData[]> => {
    console.log(`[KDS SVC] Fetching items for KDS. Business: ${businessId}, Destination: ${kdsDestination}, StatusFilter: ${filterStatus?.join(',')}`);

    // Usamos los estados de Prisma que el entorno espera: PENDING_KDS, PREPARING
    const statusFilterToUse = filterStatus && filterStatus.length > 0
        ? filterStatus
        : [OrderItemStatus.PENDING_KDS, OrderItemStatus.PREPARING];

    try {
        const orderItems = await prisma.orderItem.findMany({
            where: {
                order: {
                    businessId: businessId,
                    // Pedidos que est√°n listos para cocina/KDS: RECEIVED, IN_PROGRESS, PARTIALLY_READY, ALL_ITEMS_READY
                    // Excluimos PENDING_PAYMENT, PAID, COMPLETED, CANCELLED, PAYMENT_FAILED
                    status: {
                        in: [
                            OrderStatus.RECEIVED,
                            OrderStatus.IN_PROGRESS,
                            OrderStatus.PARTIALLY_READY,
                            OrderStatus.ALL_ITEMS_READY
                        ],
                    }
                },
                kdsDestination: kdsDestination,
                status: {
                    in: statusFilterToUse,
                },
            },
            include: {
                menuItem: {
                    select: {
                        name_es: true,
                        name_en: true,
                        preparationTime: true,
                    }
                },
                selectedModifiers: {
                    include: {
                        modifierOption: {
                            select: {
                                name_es: true,
                                name_en: true,
                            }
                        }
                    }
                },
                order: {
                    select: {
                        id: true,
                        orderNumber: true,
                        createdAt: true,
                        table: {
                            select: {
                                identifier: true,
                            }
                        }
                    }
                }
            },
            orderBy: {
                order: {
                    createdAt: 'asc',
                }
            }
        });

        const kdsItems: KdsOrderItemData[] = orderItems.map(item => ({
            id: item.id,
            quantity: item.quantity,
            status: item.status,
            notes: item.notes,
            kdsDestination: item.kdsDestination,
            menuItemName_es: item.menuItem?.name_es || item.itemNameSnapshot,
            menuItemName_en: item.menuItem?.name_en || null,
            selectedModifiers: item.selectedModifiers.map(sm => ({
                optionName_es: sm.modifierOption?.name_es || sm.optionNameSnapshot,
                optionName_en: sm.modifierOption?.name_en || null,
            })),
            orderInfo: {
                id: item.order.id,
                orderNumber: item.order.orderNumber,
                createdAt: item.order.createdAt,
                tableIdentifier: item.order.table?.identifier || null,
            },
            preparationTime: item.menuItem?.preparationTime,
            preparedAt: item.preparedAt,
            servedAt: item.servedAt,
        }));

        console.log(`[KDS SVC] Found ${kdsItems.length} items for KDS Destination '${kdsDestination}'.`);
        return kdsItems;

    } catch (error) {
        console.error(`[KDS SVC] Error fetching items for KDS (Destination: ${kdsDestination}):`, error);
        if (error instanceof Error) {
            throw new Error(`Error al obtener los √≠tems para el KDS: ${error.message}`);
        }
        throw new Error('Error al obtener los √≠tems para el KDS desde la base de datos.');
    }
};


/**
 * Actualiza el estado de un OrderItem espec√≠fico.
 * Tambi√©n maneja la l√≥gica para actualizar el estado del Order general.
 * @param orderItemId - ID del OrderItem a actualizar.
 * @param newOrderItemStatus - El nuevo OrderItemStatus (debe ser uno de los definidos en el Prisma del entorno).
 * @param businessId - ID del negocio (para verificaci√≥n de pertenencia).
 * @returns El OrderItem actualizado con sus relaciones (order, menuItem, selectedModifiers).
 */
export const updateOrderItemStatus = async (
    orderItemId: string,
    newOrderItemStatus: OrderItemStatus, // Usamos el enum del entorno
    businessId: string
): Promise<OrderItem> => {
    console.log(`[KDS SVC] Attempting to update OrderItem ${orderItemId} to ${newOrderItemStatus} for business ${businessId}`);

    // Transiciones permitidas usando los enums del entorno
    const allowedTransitions: Partial<Record<OrderItemStatus, OrderItemStatus[]>> = {
        [OrderItemStatus.PENDING_KDS]: [OrderItemStatus.PREPARING, OrderItemStatus.CANCELLED, OrderItemStatus.CANCELLATION_REQUESTED],
        [OrderItemStatus.PREPARING]:   [OrderItemStatus.READY, OrderItemStatus.PENDING_KDS, OrderItemStatus.CANCELLED, OrderItemStatus.CANCELLATION_REQUESTED],
        [OrderItemStatus.READY]:       [OrderItemStatus.SERVED, OrderItemStatus.PREPARING], // SERVED lo har√≠a un camarero, KDS lo pasa a READY, quiz√° puede volver a PREPARING
        [OrderItemStatus.CANCELLATION_REQUESTED]: [OrderItemStatus.CANCELLED, OrderItemStatus.PENDING_KDS, OrderItemStatus.PREPARING], // Si se rechaza la cancelaci√≥n
        // SERVED y CANCELLED son finales desde KDS
    };

    const finalUpdatedOrderItem = await prisma.$transaction(async (tx) => {
        let currentOrderItem = await tx.orderItem.findFirst({
            where: { id: orderItemId, order: { businessId: businessId } },
            include: { order: { select: { id: true, status: true } } }
        });

        if (!currentOrderItem) {
            throw new Error(`√çtem de pedido con ID ${orderItemId} no encontrado o no pertenece a este negocio.`);
        }
        if (!currentOrderItem.order?.id) {
             throw new Error(`Error interno: El √≠tem de pedido ${orderItemId} no est√° asociado a un pedido.`);
        }

        const currentOrderItemStatusValue = currentOrderItem.status;

        if (currentOrderItemStatusValue !== newOrderItemStatus) {
            if (allowedTransitions[currentOrderItemStatusValue] && !allowedTransitions[currentOrderItemStatusValue]?.includes(newOrderItemStatus)) {
                throw new Error(`Transici√≥n de estado no permitida para el √≠tem de '${currentOrderItemStatusValue}' a '${newOrderItemStatus}'.`);
            }

            const dataToUpdateForOrderItem: Prisma.OrderItemUpdateInput = { status: newOrderItemStatus };
            let newPreparedAtDate: Date | null = currentOrderItem.preparedAt;
            let newServedAtDate: Date | null = currentOrderItem.servedAt;

            if (newOrderItemStatus === OrderItemStatus.PREPARING && !currentOrderItem.preparedAt) {
                newPreparedAtDate = new Date();
                dataToUpdateForOrderItem.preparedAt = newPreparedAtDate;
            } else if (newOrderItemStatus === OrderItemStatus.READY && !currentOrderItem.preparedAt) {
                newPreparedAtDate = new Date();
                dataToUpdateForOrderItem.preparedAt = newPreparedAtDate;
            } else if (newOrderItemStatus === OrderItemStatus.SERVED && !currentOrderItem.servedAt) {
                newServedAtDate = new Date();
                dataToUpdateForOrderItem.servedAt = newServedAtDate;
                if (!currentOrderItem.preparedAt) { // Si se sirve directamente (ej. bebidas)
                    newPreparedAtDate = new Date();
                    dataToUpdateForOrderItem.preparedAt = newPreparedAtDate;
                }
            }

            await tx.orderItem.update({
                where: { id: orderItemId },
                data: dataToUpdateForOrderItem,
            });
            console.log(`[KDS SVC] OrderItem ${orderItemId} status updated to ${newOrderItemStatus} in DB.`);

            currentOrderItem.status = newOrderItemStatus;
            currentOrderItem.preparedAt = newPreparedAtDate;
            currentOrderItem.servedAt = newServedAtDate;

        } else {
            console.log(`[KDS SVC] OrderItem ${orderItemId} ya est√° en estado ${newOrderItemStatus}. No se requiere actualizaci√≥n de √≠tem.`);
        }

        // --- L√ìGICA DE ACTUALIZACI√ìN DEL ESTADO DEL PEDIDO (Order.status) CON ENUMS DEL ENTORNO ---
        const orderId = currentOrderItem.order.id;
        const currentOrderStatusInDb = currentOrderItem.order.status;

        const allItemsOfThisOrder = await tx.orderItem.findMany({
            where: { orderId: orderId },
            select: { status: true, id: true }
        });

        console.log(`[KDS SVC - OrderStatusLogic] For Order ${orderId} - Current Order Status in DB: ${currentOrderStatusInDb}`);
        console.log(`[KDS SVC - OrderStatusLogic] All items for order ${orderId} (after potential item update):`, allItemsOfThisOrder.map(i => ({id: i.id, status: i.status})));

        // Filtrar √≠tems que no est√°n CANCELLED. CANCELLATION_REQUESTED se trata como activo hasta que se confirma.
        const activeItems = allItemsOfThisOrder.filter(item =>
            item.status !== OrderItemStatus.CANCELLED
        );

        let determinedNewOrderStatus: OrderStatus = currentOrderStatusInDb;

        if (allItemsOfThisOrder.length === 0) {
            console.log(`[KDS SVC - OrderStatusLogic] No items found for order ${orderId}. Status remains ${determinedNewOrderStatus}`);
        } else if (activeItems.length === 0) {
            // Todos los √≠tems originales fueron CANCELLED
            determinedNewOrderStatus = OrderStatus.CANCELLED;
            console.log(`[KDS SVC - OrderStatusLogic] All items are CANCELLED. New OrderStatus -> ${determinedNewOrderStatus}`);
        } else {
            const allServed = activeItems.every(item => item.status === OrderItemStatus.SERVED);
            const allReadyOrServed = activeItems.every(item => item.status === OrderItemStatus.READY || item.status === OrderItemStatus.SERVED);
            const anyReady = activeItems.some(item => item.status === OrderItemStatus.READY);
            const anyPreparing = activeItems.some(item => item.status === OrderItemStatus.PREPARING);
            // const allPendingKds = activeItems.every(item => item.status === OrderItemStatus.PENDING_KDS);

            if (allServed) {
                // Si todos los √≠tems activos est√°n servidos, el pedido se considera completado.
                // La transici√≥n a PAID se manejar√≠a en otro flujo (POS o similar).
                determinedNewOrderStatus = OrderStatus.COMPLETED;
                console.log(`[KDS SVC - OrderStatusLogic] All active items SERVED. New OrderStatus -> ${determinedNewOrderStatus}`);
            } else if (allReadyOrServed) {
                // Si todos los √≠tems activos est√°n listos (READY) o ya servidos (pero no todos servidos)
                determinedNewOrderStatus = OrderStatus.ALL_ITEMS_READY;
                console.log(`[KDS SVC - OrderStatusLogic] All active items READY or SERVED. New OrderStatus -> ${determinedNewOrderStatus}`);
            } else if (anyReady) {
                // Si algunos √≠tems est√°n listos (READY), pero no todos (y no todos servidos)
                // Y el pedido estaba en progreso o reci√©n recibido.
                if (currentOrderStatusInDb === OrderStatus.IN_PROGRESS || currentOrderStatusInDb === OrderStatus.RECEIVED || currentOrderStatusInDb === OrderStatus.PARTIALLY_READY) {
                    determinedNewOrderStatus = OrderStatus.PARTIALLY_READY;
                    console.log(`[KDS SVC - OrderStatusLogic] Some items READY. Order status was ${currentOrderStatusInDb}. New OrderStatus -> ${determinedNewOrderStatus}`);
                } else {
                    console.log(`[KDS SVC - OrderStatusLogic] Some items READY, but current order status ${currentOrderStatusInDb} prevents auto-move to PARTIALLY_READY. Status remains ${determinedNewOrderStatus}`);
                }
            } else if (anyPreparing) {
                 // Si alg√∫n √≠tem se est√° preparando
                if (currentOrderStatusInDb === OrderStatus.RECEIVED || currentOrderStatusInDb === OrderStatus.IN_PROGRESS || currentOrderStatusInDb === OrderStatus.PARTIALLY_READY ) {
                    determinedNewOrderStatus = OrderStatus.IN_PROGRESS;
                    console.log(`[KDS SVC - OrderStatusLogic] Some items PREPARING. Order status was ${currentOrderStatusInDb}. New OrderStatus -> ${determinedNewOrderStatus}`);
                } else {
                    console.log(`[KDS SVC - OrderStatusLogic] Some items PREPARING, but current order status ${currentOrderStatusInDb} prevents auto-move to IN_PROGRESS. Status remains ${determinedNewOrderStatus}`);
                }
            }
            // No es necesario un 'else if (allPendingKds)' porque si el pedido est√° RECEIVED y todos los √≠tems est√°n PENDING_KDS, el estado no deber√≠a cambiar.
            // Si estaba IN_PROGRESS y todos vuelven a PENDING_KDS (raro), podr√≠a volver a RECEIVED o quedarse IN_PROGRESS seg√∫n la pol√≠tica.
            // Por ahora, si no se cumplen las condiciones anteriores, se mantiene el 'determinedNewOrderStatus'
            else {
                console.log(`[KDS SVC - OrderStatusLogic] No specific aggregate condition met for active items to change OrderStatus from ${currentOrderStatusInDb}.`);
                 // Si el estado actual es RECEIVED y hay alg√∫n item que no sea PENDING_KDS (ej. PREPARING, READY), deber√≠a pasar a IN_PROGRESS o PARTIALLY_READY
                if (currentOrderStatusInDb === OrderStatus.RECEIVED && activeItems.some(it => it.status !== OrderItemStatus.PENDING_KDS) ) {
                    if (activeItems.some(it => it.status === OrderItemStatus.READY)) {
                        determinedNewOrderStatus = OrderStatus.PARTIALLY_READY;
                         console.log(`[KDS SVC - OrderStatusLogic] Order was RECEIVED, now has READY items. New OrderStatus -> ${determinedNewOrderStatus}`);
                    } else if (activeItems.some(it => it.status === OrderItemStatus.PREPARING)) {
                        determinedNewOrderStatus = OrderStatus.IN_PROGRESS;
                        console.log(`[KDS SVC - OrderStatusLogic] Order was RECEIVED, now has PREPARING items. New OrderStatus -> ${determinedNewOrderStatus}`);
                    }
                }
            }
        }

        if (currentOrderStatusInDb !== determinedNewOrderStatus) {
            // Asegurar que el determinedNewOrderStatus es uno de los valores v√°lidos del enum OrderStatus
            if (Object.values(OrderStatus).includes(determinedNewOrderStatus)) {
                 await tx.order.update({
                    where: { id: orderId },
                    data: { status: determinedNewOrderStatus }
                });
                console.log(`[KDS SVC - DB UPDATE] Order ${orderId} status was ${currentOrderStatusInDb}, NOW UPDATED to ${determinedNewOrderStatus}.`);
            } else {
                 // Esto no deber√≠a ocurrir si la l√≥gica es correcta y solo asigna valores del enum
                 console.error(`[KDS SVC - INVALID STATUS] Attempted to set invalid OrderStatus '${determinedNewOrderStatus}'. Order status REMAINS ${currentOrderStatusInDb}.`);
            }
        } else {
            console.log(`[KDS SVC - NO DB UPDATE] Order ${orderId} status REMAINS ${currentOrderStatusInDb}. (Determined new status was also: ${determinedNewOrderStatus})`);
        }
        // --- FIN L√ìGICA DE ACTUALIZACI√ìN DEL ESTADO DEL PEDIDO ---

        const finalOrderItemResult = await tx.orderItem.findUniqueOrThrow({
            where: { id: orderItemId },
            include: {
                order: true,
                menuItem: true,
                selectedModifiers: { include: { modifierOption: true }}
            }
        });
        return finalOrderItemResult;
    });
    return finalUpdatedOrderItem;
};


// ====== [27] backend/src/modules/camarero/public/OrderValidationService.ts ======
// backend/src/public/order-item-processor.service.ts
import {
    PrismaClient,
    Prisma,
    MenuItem,
    ModifierGroup,
    OrderItemStatus, // Necesario para el estado inicial del OrderItem
} from '@prisma/client';
import {
    BadRequestException,
    InternalServerErrorException,
    Logger,
    NotFoundException,
} from '@nestjs/common';

// Tipos importados de los DTOs internos (o definidos aqu√≠ si es preferible)
interface SelectedModifierOptionInternalDto {
    modifierOptionId: string;
}

interface OrderItemInternalDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: SelectedModifierOptionInternalDto[] | null;
}

// Tipos para la estructura de datos que este servicio devolver√°
// Esto es lo que se necesita para crear un OrderItem en la BD
export interface ProcessedOrderItemData {
    menuItemId: string;
    quantity: number;
    priceAtPurchase: Prisma.Decimal;
    totalItemPrice: Prisma.Decimal;
    notes?: string | null;
    kdsDestination: string | null;
    itemNameSnapshot: string; // Asumiendo que el snapshot se toma aqu√≠
    itemDescriptionSnapshot: string | null; // Asumiendo que el snapshot se toma aqu√≠
    status: OrderItemStatus; // Estado inicial
    // Datos para crear los OrderItemModifierOption asociados
    modifierOptionsToCreate: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[];
}

// Tipos internos para el manejo de modificadores (similares a los que ten√≠as)
interface SelectedModifierOptionShape {
    id: string;
    name_es: string | null;
    priceAdjustment: Prisma.Decimal;
    isAvailable: boolean;
    groupId: string; // Clave para la l√≥gica de validaci√≥n de grupos
}

type ModifierGroupWithSelectedOptions = ModifierGroup & {
    options: SelectedModifierOptionShape[];
};

// Prisma.validator para obtener MenuItem con sus modificadores y opciones activas
const menuItemWithFullModifiersArgs = Prisma.validator<Prisma.MenuItemDefaultArgs>()({
    include: {
        modifierGroups: {
            orderBy: { position: 'asc' }, // Importante para la l√≥gica de validaci√≥n si el orden importa
            include: {
                options: {
                    where: { isAvailable: true }, // Solo opciones disponibles
                    orderBy: { position: 'asc' },
                    select: { // Seleccionar solo lo necesario
                        id: true,
                        name_es: true, // Para snapshots
                        // name_en: true, // Si tuvieras i18n para snapshots
                        priceAdjustment: true,
                        isAvailable: true, // Aunque ya filtramos, es bueno tenerlo
                        groupId: true,
                    },
                },
            },
        },
    },
});
type MenuItemWithFullModifiers = Prisma.MenuItemGetPayload<typeof menuItemWithFullModifiersArgs>;


export class OrderItemProcessorService {
    private readonly logger = new Logger(OrderItemProcessorService.name);

    /**
     * Procesa una lista de √≠tems de un DTO, valida su contenido (incluyendo modificadores)
     * y calcula los precios.
     *
     * @param tx - Cliente Prisma de la transacci√≥n actual.
     * @param businessId - ID del negocio al que deben pertenecer los √≠tems.
     * @param itemsDto - Array de √≠tems tal como vienen en el payload de la orden.
     * @returns Un array de ProcessedOrderItemData, listos para ser usados en la creaci√≥n de OrderItems.
     */
    async processOrderItems(
        tx: Prisma.TransactionClient,
        businessId: string,
        itemsDto: OrderItemInternalDto[]
    ): Promise<ProcessedOrderItemData[]> {
        this.logger.log(`[OrderItemProcessor] Processing ${itemsDto.length} items for business ${businessId}`);
        const processedItems: ProcessedOrderItemData[] = [];

        for (const itemDto of itemsDto) {
            const menuItem = await this.fetchAndValidateMenuItem(tx, itemDto.menuItemId, businessId);

            const {
                itemPriceWithModifiers,
                modifierOptionsToCreateForDb,
            } = this.processModifiersForItem(menuItem, itemDto.selectedModifierOptions || []);

            const priceAtPurchase = menuItem.price.add(itemPriceWithModifiers);
            const totalItemPrice = priceAtPurchase.mul(itemDto.quantity);

            processedItems.push({
                menuItemId: menuItem.id,
                quantity: itemDto.quantity,
                priceAtPurchase,
                totalItemPrice,
                notes: itemDto.notes,
                kdsDestination: menuItem.kdsDestination,
                itemNameSnapshot: menuItem.name_es || '√çtem sin nombre ES', // Tomar snapshot del nombre
                itemDescriptionSnapshot: menuItem.description_es, // Tomar snapshot de la descripci√≥n
                status: OrderItemStatus.PENDING_KDS, // Estado inicial por defecto
                modifierOptionsToCreate: modifierOptionsToCreateForDb,
            });
        }
        this.logger.log(`[OrderItemProcessor] Finished processing ${processedItems.length} items.`);
        return processedItems;
    }

    /**
     * Obtiene y valida un MenuItem.
     */
    private async fetchAndValidateMenuItem(
        tx: Prisma.TransactionClient,
        menuItemId: string,
        businessId: string
    ): Promise<MenuItemWithFullModifiers> {
        const menuItem = await tx.menuItem.findUnique({
            where: { id: menuItemId },
            ...menuItemWithFullModifiersArgs,
        });

        if (!menuItem) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItemId}' not found.`);
            throw new NotFoundException(`√çtem de men√∫ con ID '${menuItemId}' no encontrado.`);
        }
        if (menuItem.businessId !== businessId) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItemId}' does not belong to business '${businessId}'.`);
            throw new BadRequestException(`√çtem de men√∫ con ID '${menuItemId}' no pertenece a este negocio.`);
        }
        if (!menuItem.isAvailable) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItem.name_es}' is not available.`);
            throw new BadRequestException(`El √≠tem '${menuItem.name_es || menuItemId}' no est√° disponible actualmente.`);
        }
        return menuItem;
    }

    /**
     * Procesa los modificadores seleccionados para un √≠tem de men√∫,
     * calcula el ajuste total de precio y valida las selecciones.
     */
    private processModifiersForItem(
        menuItem: MenuItemWithFullModifiers,
        selectedOptionsDto: SelectedModifierOptionInternalDto[]
    ): {
        itemPriceWithModifiers: Prisma.Decimal; // Es el total de los priceAdjustments
        modifierOptionsToCreateForDb: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[];
    } {
        let totalModifierPriceAdjustment = new Prisma.Decimal(0);
        const modifierOptionsToCreateForDb: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[] = [];
        const typedModifierGroups = menuItem.modifierGroups as ModifierGroupWithSelectedOptions[];

        // Mapear las opciones seleccionadas por el cliente a sus datos completos de la BD
        // y agruparlas por su modifierGroupId para f√°cil validaci√≥n.
        const selectedOptionsDataByGroup: Record<string, SelectedModifierOptionShape[]> = {};

        for (const selectedOptDto of selectedOptionsDto) {
            let foundOption: SelectedModifierOptionShape | undefined;
            let foundInGroup: ModifierGroupWithSelectedOptions | undefined;

            for (const group of typedModifierGroups) {
                const option = group.options.find(opt => opt.id === selectedOptDto.modifierOptionId);
                if (option) {
                    foundOption = option;
                    foundInGroup = group;
                    break;
                }
            }

            if (!foundOption || !foundInGroup) {
                this.logger.warn(`[OrderItemProcessor] Invalid or unavailable modifierOptionId '${selectedOptDto.modifierOptionId}' for MenuItem '${menuItem.id}'.`);
                throw new BadRequestException(`Opci√≥n de modificador con ID '${selectedOptDto.modifierOptionId}' no es v√°lida o no est√° disponible para el √≠tem '${menuItem.name_es}'.`);
            }
            
            if (!foundOption.groupId) { // Esto no deber√≠a pasar si el schema es correcto
                 this.logger.error(`[OrderItemProcessor] Critical: ModifierOption '${foundOption.id}' has no groupId.`);
                 throw new InternalServerErrorException(`Error de configuraci√≥n: Opci√≥n de modificador '${foundOption.id}' no tiene grupo.`);
            }

            if (!selectedOptionsDataByGroup[foundOption.groupId]) {
                selectedOptionsDataByGroup[foundOption.groupId] = [];
            }
            selectedOptionsDataByGroup[foundOption.groupId].push(foundOption);

            totalModifierPriceAdjustment = totalModifierPriceAdjustment.add(foundOption.priceAdjustment);
            modifierOptionsToCreateForDb.push({
                modifierOptionId: foundOption.id,
                optionNameSnapshot: foundOption.name_es || 'Opci√≥n sin nombre ES', // Snapshot
                optionPriceAdjustmentSnapshot: foundOption.priceAdjustment,
            });
        }

        // Validar cada grupo de modificadores del MenuItem contra las selecciones hechas
        for (const group of typedModifierGroups) {
            const selectionsInThisGroup = selectedOptionsDataByGroup[group.id] || [];
            const selectedCount = selectionsInThisGroup.length;

            if (group.isRequired && selectedCount < group.minSelections) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for group '${group.name_es}': required min ${group.minSelections}, got ${selectedCount}.`);
                throw new BadRequestException(`Para el √≠tem '${menuItem.name_es}', el grupo de modificadores '${group.name_es}' requiere al menos ${group.minSelections} selecci√≥n(es).`);
            }
            if (selectedCount > group.maxSelections) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for group '${group.name_es}': allowed max ${group.maxSelections}, got ${selectedCount}.`);
                throw new BadRequestException(`Para el √≠tem '${menuItem.name_es}', el grupo de modificadores '${group.name_es}' permite como m√°ximo ${group.maxSelections} selecci√≥n(es).`);
            }
            // Adicionalmente, si es RADIO, solo debe haber una selecci√≥n
            if (group.uiType === 'RADIO' && selectedCount > 1) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for RADIO group '${group.name_es}': got ${selectedCount} selections.`);
                throw new BadRequestException(`El grupo de modificadores '${group.name_es}' (tipo RADIO) solo permite una selecci√≥n.`);
            }
        }

        return {
            itemPriceWithModifiers: totalModifierPriceAdjustment,
            modifierOptionsToCreateForDb,
        };
    }
}


// ====== [28] backend/src/modules/camarero/public/menu.controller.ts ======
// backend/src/public/menu.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as publicMenuService from './menu.service'; // Asumimos que el servicio se llamar√° menu.service.ts en la misma carpeta

export const getPublicDigitalMenuHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessSlug } = req.params;

    if (!businessSlug || typeof businessSlug !== 'string' || businessSlug.trim() === '') {
        return res.status(400).json({ message: 'Se requiere el slug del negocio en la URL.' });
    }

    console.log(`[PublicMenu CTRL] Requesting public menu for business slug: ${businessSlug}`);

    try {
        const menuData = await publicMenuService.getPublicDigitalMenuBySlug(businessSlug.trim());

        if (!menuData) {
            // El servicio devolver√° null si el negocio no existe o el m√≥dulo camarero no est√° activo
            return res.status(404).json({ message: 'Men√∫ no encontrado o no disponible para este negocio.' });
        }

        res.status(200).json(menuData);
    } catch (error) {
        // Loguear el error en el backend para diagn√≥stico
        console.error(`[PublicMenu CTRL] Error fetching public menu for slug ${businessSlug}:`, error);
        // Pasar el error al manejador de errores global de Express
        // El manejador global puede decidir enviar una respuesta 500 gen√©rica
        // o manejar errores espec√≠ficos si los lanzamos desde el servicio.
        next(error);
    }
};


// ====== [29] backend/src/modules/camarero/public/menu.service.ts ======
// backend/src/public/menu.service.ts
// Version: 1.0.0 (Initial functional version for public menu display)

import { PrismaClient, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

// Definici√≥n local de ModifierUiType (como en seed.ts y como se usa en tus otros servicios)
const ModifierUiTypeEnum = {
    RADIO: 'RADIO',
    CHECKBOX: 'CHECKBOX',
} as const;
type LocalModifierUiType = typeof ModifierUiTypeEnum[keyof typeof ModifierUiTypeEnum];


// --- Definici√≥n de Tipos de Salida ---
interface PublicMenuCategoryItemModifierOption {
    id: string;
    name_es: string | null;
    name_en: string | null;
    priceAdjustment: Prisma.Decimal;
    position: number;
    isDefault: boolean;
}

interface PublicMenuCategoryItemModifierGroup {
    id: string;
    name_es: string | null;
    name_en: string | null;
    uiType: LocalModifierUiType; // Usar el tipo LocalModifierUiType
    minSelections: number;
    maxSelections: number;
    isRequired: boolean;
    position: number;
    options: PublicMenuCategoryItemModifierOption[];
}

interface PublicMenuCategoryItem {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    price: Prisma.Decimal;
    imageUrl: string | null;
    allergens: string[];
    tags: string[];
    position: number;
    modifierGroups: PublicMenuCategoryItemModifierGroup[];
}

interface PublicMenuCategory {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    imageUrl: string | null;
    position: number;
    items: PublicMenuCategoryItem[];
}

interface PublicDigitalMenu {
    businessName: string;
    businessSlug: string;
    businessLogoUrl: string | null;
    categories: PublicMenuCategory[];
}
// --- Fin Definici√≥n de Tipos de Salida ---


export const getPublicDigitalMenuBySlug = async (businessSlug: string): Promise<PublicDigitalMenu | null> => {
    console.log(`[PublicMenu SVC] Fetching public digital menu for business slug: ${businessSlug}`);

    try {
        const businessWithMenu = await prisma.business.findUnique({
            where: { slug: businessSlug },
            select: {
                id: true,
                name: true,
                slug: true,
                logoUrl: true,
                isCamareroActive: true,
                isActive: true,
                menuCategories: {
                    where: { isActive: true },
                    orderBy: { position: 'asc' },
                    select: {
                        id: true,
                        name_es: true,
                        name_en: true,
                        description_es: true,
                        description_en: true,
                        imageUrl: true,
                        position: true,
                        items: {
                            where: {
                                // Asumiendo que MenuItem usa 'isAvailable' para la vista p√∫blica
                                // y 'isActive' para la habilitaci√≥n general del √≠tem.
                                // Si solo 'isAvailable' controla la vista p√∫blica, quitar 'isActive: true'.
                                // Si el schema de MenuItem NO tiene 'isActive', esta l√≠nea dar√° error.
                                // Basado en el √∫ltimo error, comentaremos 'isActive' para MenuItem.
                                // isActive: true, 
                                isAvailable: true
                            },
                            orderBy: { position: 'asc' },
                            select: {
                                id: true,
                                name_es: true,
                                name_en: true,
                                description_es: true,
                                description_en: true,
                                price: true,
                                imageUrl: true,
                                allergens: true,
                                tags: true,
                                position: true,
                                modifierGroups: {
                                    // Asumiendo que ModifierGroup usa 'isActive'
                                    // Si no tiene 'isActive' filtrable, esta l√≠nea debe comentarse o ajustarse.
                                    // Basado en el √∫ltimo error, comentaremos 'isActive' para ModifierGroup.
                                    // where: { isActive: true }, 
                                    orderBy: { position: 'asc' },
                                    select: {
                                        id: true,
                                        name_es: true,
                                        name_en: true,
                                        uiType: true,
                                        minSelections: true,
                                        maxSelections: true,
                                        isRequired: true,
                                        position: true,
                                        options: {
                                            where: { isAvailable: true }, // ModifierOption usa isAvailable
                                            orderBy: { position: 'asc' },
                                            select: {
                                                id: true,
                                                name_es: true,
                                                name_en: true,
                                                priceAdjustment: true,
                                                position: true,
                                                isDefault: true,
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        });

        if (!businessWithMenu) {
            console.log(`[PublicMenu SVC] Business not found for slug: ${businessSlug}`);
            return null;
        }

        if (!businessWithMenu.isActive) {
            console.log(`[PublicMenu SVC] Business ${businessSlug} (ID: ${businessWithMenu.id}) is not active. Menu not available.`);
            return null;
        }

        if (!businessWithMenu.isCamareroActive) {
            console.log(`[PublicMenu SVC] Camarero module is not active for business ${businessSlug} (ID: ${businessWithMenu.id}). Menu not available.`);
            return null;
        }
        
        type CategoryFromPrisma = typeof businessWithMenu.menuCategories[0];
        type ItemFromPrisma = CategoryFromPrisma['items'][0];
        type GroupFromPrisma = ItemFromPrisma['modifierGroups'][0];
        type OptionFromPrisma = GroupFromPrisma['options'][0];

        const mapCategory = (category: CategoryFromPrisma): PublicMenuCategory => ({
            id: category.id,
            name_es: category.name_es,
            name_en: category.name_en,
            description_es: category.description_es,
            description_en: category.description_en,
            imageUrl: category.imageUrl,
            position: category.position,
            items: category.items.map(mapItem),
        });

        const mapItem = (item: ItemFromPrisma): PublicMenuCategoryItem => ({
            id: item.id,
            name_es: item.name_es,
            name_en: item.name_en,
            description_es: item.description_es,
            description_en: item.description_en,
            price: item.price,
            imageUrl: item.imageUrl,
            allergens: item.allergens,
            tags: item.tags,
            position: item.position,
            modifierGroups: item.modifierGroups.map(mapGroup),
        });

        const mapGroup = (group: GroupFromPrisma): PublicMenuCategoryItemModifierGroup => ({
            id: group.id,
            name_es: group.name_es,
            name_en: group.name_en,
            uiType: group.uiType as LocalModifierUiType,
            minSelections: group.minSelections,
            maxSelections: group.maxSelections,
            isRequired: group.isRequired,
            position: group.position,
            options: group.options.map(mapOption),
        });

        const mapOption = (option: OptionFromPrisma): PublicMenuCategoryItemModifierOption => ({
            id: option.id,
            name_es: option.name_es,
            name_en: option.name_en,
            priceAdjustment: option.priceAdjustment,
            position: option.position,
            isDefault: option.isDefault,
        });

        const categoriesTyped: PublicMenuCategory[] = businessWithMenu.menuCategories.map(mapCategory);

        const menuToReturn: PublicDigitalMenu = {
            businessName: businessWithMenu.name,
            businessSlug: businessWithMenu.slug,
            businessLogoUrl: businessWithMenu.logoUrl,
            categories: categoriesTyped,
        };

        return menuToReturn;

    } catch (error) {
        console.error(`[PublicMenu SVC] Error fetching public menu for slug ${businessSlug}:`, error);
        throw new Error('Error al obtener los datos del men√∫ desde la base de datos.');
    }
};


// ====== [30] backend/src/modules/camarero/public/order-creation.service.ts ======
// backend/src/modules/camarero/public/order-creation.service.ts (CORREGIDO)
import {
    PrismaClient,
    Prisma,
    Order,
    OrderStatus,
    TableStatus,
} from '@prisma/client';
import {
    Injectable,
    Logger,
    NotFoundException,
    BadRequestException,
    InternalServerErrorException,
} from '@nestjs/common';

// Importar los servicios que vamos a usar
import { OrderItemProcessorService, ProcessedOrderItemData } from './order-item-processor.service';
// --- RUTA CORREGIDA ---
import { TableService } from '../../../shared/services/table.service';

// Tipos del payload que este servicio espera
export interface CreateOrderPayloadInternalDto {
    tableIdentifier?: string | null;
    customerId?: string | null;
    orderNotes?: string | null;
    items: OrderItemInternalDto[];
}

interface OrderItemInternalDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: { modifierOptionId: string }[] | null;
}

interface BusinessContextForOrder {
    id: string;
    isActive: boolean;
    isCamareroActive: boolean;
}

@Injectable()
export class OrderCreationService {
    private readonly logger = new Logger(OrderCreationService.name);
    private readonly orderItemProcessorService: OrderItemProcessorService;
    private readonly tableService: TableService;
    private prisma: PrismaClient;

    constructor() {
        this.prisma = new PrismaClient();
        this.orderItemProcessorService = new OrderItemProcessorService();
        this.tableService = new TableService();
        this.logger.log("OrderCreationService instantiated");
    }

    async createNewOrder(
        businessSlug: string,
        payload: CreateOrderPayloadInternalDto,
        requestingCustomerId?: string | null
    ): Promise<Order> {
        this.logger.log(`[OrderCreationService] Attempting to create new order for business slug '${businessSlug}'. Items: ${payload.items.length}`);

        const businessContext = await this.validateBusinessForOrdering(businessSlug);
        const businessId = businessContext.id;

        return this.prisma.$transaction(async (tx) => {
            this.logger.log(`[OrderCreationService TX] Transaction started for new order.`);

            const processedItems: ProcessedOrderItemData[] =
                await this.orderItemProcessorService.processOrderItems(
                    tx,
                    businessId,
                    payload.items
                );

            if (processedItems.length === 0 && payload.items.length > 0) {
                this.logger.warn(`[OrderCreationService TX] All items in payload were invalid. No items to create for order.`);
                throw new BadRequestException('Ninguno de los √≠tems proporcionados pudo ser procesado.');
            }
            if (processedItems.length === 0 && payload.items.length === 0) {
                 this.logger.warn(`[OrderCreationService TX] No items provided in the payload.`);
                 throw new BadRequestException('El pedido debe contener al menos un √≠tem.');
            }

            const totalAmount = processedItems.reduce(
                (sum, item) => sum.add(item.totalItemPrice),
                new Prisma.Decimal(0)
            );
            this.logger.log(`[OrderCreationService TX] Calculated totalAmount: ${totalAmount}`);

            const orderNumber = await this._generateOrderNumber(tx, businessId);
            this.logger.log(`[OrderCreationService TX] Generated orderNumber: ${orderNumber}`);

            const orderCreateData: Prisma.OrderCreateInput = {
                business: { connect: { id: businessId } },
                orderNumber: orderNumber,
                notes: payload.orderNotes,
                totalAmount: totalAmount,
                finalAmount: totalAmount,
                status: OrderStatus.RECEIVED,
                isBillRequested: false,
                source: payload.customerId || requestingCustomerId ? 'CUSTOMER_APP' : 'CUSTOMER_APP_ANONYMOUS',
                orderType: payload.tableIdentifier ? 'DINE_IN' : 'TAKE_AWAY',
                items: {
                    create: processedItems.map(pItem => ({
                        menuItemId: pItem.menuItemId,
                        quantity: pItem.quantity,
                        priceAtPurchase: pItem.priceAtPurchase,
                        totalItemPrice: pItem.totalItemPrice,
                        notes: pItem.notes,
                        kdsDestination: pItem.kdsDestination,
                        itemNameSnapshot: pItem.itemNameSnapshot,
                        itemDescriptionSnapshot: pItem.itemDescriptionSnapshot,
                        status: pItem.status,
                        ...(pItem.modifierOptionsToCreate.length > 0 && {
                            selectedModifiers: {
                                createMany: {
                                    data: pItem.modifierOptionsToCreate,
                                },
                            },
                        }),
                    })),
                },
            };

            if (payload.tableIdentifier) {
                const table = await this.tableService.findTableByIdentifier(
                    tx,
                    businessId,
                    payload.tableIdentifier
                );
                if (table) {
                    orderCreateData.table = { connect: { id: table.id } };
                    await this.tableService.updateTableStatus(tx, table.id, TableStatus.OCCUPIED);
                    this.logger.log(`[OrderCreationService TX] Table '${payload.tableIdentifier}' (ID: ${table.id}) connected and set to OCCUPIED.`);
                } else {
                    this.logger.warn(`[OrderCreationService TX] Table identifier '${payload.tableIdentifier}' provided but table not found for business '${businessId}'. Order will be created without table assignment.`);
                }
            }

            const finalCustomerId = payload.customerId || requestingCustomerId;
            if (finalCustomerId) {
                const customerExists = await tx.user.findFirst({ where: { id: finalCustomerId, businessId: businessId }});
                if(customerExists) {
                    orderCreateData.customerLCo = { connect: { id: finalCustomerId } };
                    this.logger.log(`[OrderCreationService TX] CustomerLCoId '${finalCustomerId}' connected to order.`);
                } else {
                    this.logger.warn(`[OrderCreationService TX] CustomerLCoId '${finalCustomerId}' provided but not found for business '${businessId}'. Order will be created without LCo customer.`);
                }
            }

            const newOrder = await tx.order.create({
                data: orderCreateData,
                include: { items: { include: { selectedModifiers: true } }, table: true },
            });

            this.logger.log(`[OrderCreationService TX] Order ${newOrder.id} (Number: ${newOrder.orderNumber}) created successfully with ${newOrder.items.length} item(s).`);
            return newOrder;
        });
    }

    private async validateBusinessForOrdering(businessSlug: string): Promise<BusinessContextForOrder> {
        const business = await this.prisma.business.findUnique({
            where: { slug: businessSlug },
            select: { id: true, isActive: true, isCamareroActive: true },
        });

        if (!business) {
            this.logger.warn(`[OrderCreationService] Business with slug '${businessSlug}' not found.`);
            throw new NotFoundException(`Negocio con slug '${businessSlug}' no encontrado.`);
        }
        if (!business.isActive) {
            this.logger.warn(`[OrderCreationService] Business '${businessSlug}' is not active.`);
            throw new BadRequestException(`El negocio '${businessSlug}' no est√° activo y no puede recibir pedidos.`);
        }
        if (!business.isCamareroActive) {
            this.logger.warn(`[OrderCreationService] Camarero module not active for business '${businessSlug}'.`);
            throw new BadRequestException(`El m√≥dulo de pedidos (Camarero) no est√° activo para el negocio '${businessSlug}'.`);
        }
        this.logger.log(`[OrderCreationService] Business '${businessSlug}' validated for ordering. ID: ${business.id}`);
        return business;
    }

    private async _generateOrderNumber(tx: Prisma.TransactionClient, businessId: string): Promise<string> {
        const orderCount = await tx.order.count({
            where: { businessId: businessId },
        });
        const datePrefix = new Date().toISOString().slice(0, 10).replace(/-/g, '');
        const newCount = orderCount + 1;
        return `P-${datePrefix}-${String(newCount).padStart(5, '0')}`;
    }
}


// ====== [31] backend/src/modules/camarero/public/order-item-processor.service.ts ======
// backend/src/public/order-item-processor.service.ts
import {
    PrismaClient, // Aunque no lo use directamente, es com√∫n para servicios Prisma
    Prisma,
    MenuItem,
    ModifierGroup,
    OrderItemStatus, // Necesario para el estado inicial del OrderItem
} from '@prisma/client';
import {
    BadRequestException,
    InternalServerErrorException,
    Logger,
    NotFoundException,
} from '@nestjs/common';

// Tipos importados o definidos (aseg√∫rate de que `SelectedModifierOptionInternalDto` est√© definido si no se importa)
// Si estos DTOs se definen en un archivo central (ej. order.types.ts), imp√≥rtalos desde all√≠.
// Por ahora, los definir√© aqu√≠ para que el archivo sea autocontenido.
interface SelectedModifierOptionInternalDto {
    modifierOptionId: string;
}

interface OrderItemInternalDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: SelectedModifierOptionInternalDto[] | null;
}

// Tipo de retorno de este servicio para cada √≠tem procesado
export interface ProcessedOrderItemData {
    menuItemId: string;
    quantity: number;
    priceAtPurchase: Prisma.Decimal; // Precio unitario del √≠tem con modificadores
    totalItemPrice: Prisma.Decimal;  // priceAtPurchase * quantity
    notes?: string | null;
    kdsDestination: string | null;
    itemNameSnapshot: string;
    itemDescriptionSnapshot: string | null;
    status: OrderItemStatus;
    // Datos para crear los OrderItemModifierOption asociados
    modifierOptionsToCreate: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[];
}

// Tipos internos para el manejo de modificadores, similares a los que ten√≠as
interface SelectedModifierOptionShape {
    id: string;
    name_es: string | null;
    // name_en: string | null; // Si necesitas i18n para snapshots de modificadores
    priceAdjustment: Prisma.Decimal;
    isAvailable: boolean;
    groupId: string;
}

// Tipo para ModifierGroup cuando se incluye sus opciones (con los campos seleccionados)
type ModifierGroupWithSelectedOptions = ModifierGroup & {
    options: SelectedModifierOptionShape[];
};

// Prisma.validator para obtener MenuItem con sus modificadores y opciones activas
// Esta definici√≥n es crucial y debe ser consistente con tu schema.prisma
const menuItemWithFullModifiersArgs = Prisma.validator<Prisma.MenuItemDefaultArgs>()({
    include: {
        modifierGroups: {
            orderBy: { position: 'asc' },
            include: {
                options: {
                    where: { isAvailable: true }, // Solo opciones disponibles
                    orderBy: { position: 'asc' },
                    select: {
                        id: true,
                        name_es: true, // Para snapshots
                        // name_en: true, // Descomentar si tienes name_en y lo usas para snapshots
                        priceAdjustment: true,
                        isAvailable: true, // Aunque ya filtramos, es bueno tenerlo para confirmaci√≥n
                        groupId: true, // Esencial para la l√≥gica de grupo
                    },
                },
            },
        },
    },
});
type MenuItemWithFullModifiers = Prisma.MenuItemGetPayload<typeof menuItemWithFullModifiersArgs>;

export class OrderItemProcessorService {
    private readonly logger = new Logger(OrderItemProcessorService.name);
    // Este servicio no necesita su propia instancia de Prisma si siempre se le pasa 'tx'.
    // constructor(private prisma: PrismaClient) {} // Si se inyectara

    /**
     * Procesa una lista de √≠tems de un DTO, valida su contenido (incluyendo modificadores)
     * y calcula los precios.
     *
     * @param tx - Cliente Prisma de la transacci√≥n actual.
     * @param businessId - ID del negocio al que deben pertenecer los √≠tems.
     * @param itemsDto - Array de √≠tems tal como vienen en el payload de la orden.
     * @returns Un array de ProcessedOrderItemData, listos para ser usados en la creaci√≥n de OrderItems.
     */
    async processOrderItems(
        tx: Prisma.TransactionClient, // Siempre operamos dentro de una transacci√≥n
        businessId: string,
        itemsDto: OrderItemInternalDto[]
    ): Promise<ProcessedOrderItemData[]> {
        this.logger.log(`[OrderItemProcessor] Processing ${itemsDto.length} items for business ${businessId}`);
        const processedItems: ProcessedOrderItemData[] = [];

        for (const itemDto of itemsDto) {
            const menuItem = await this.fetchAndValidateMenuItem(tx, itemDto.menuItemId, businessId);

            const {
                accumulatedModifierPrice, // Cambiado el nombre para mayor claridad
                modifierOptionsToCreateForDb,
            } = this.processAndValidateModifiersForItem(menuItem, itemDto.selectedModifierOptions || []);

            // El precio base del √≠tem ya lo tenemos en menuItem.price
            // priceAtPurchase = precio base del √≠tem + suma de ajustes de los modificadores
            const priceAtPurchase = new Prisma.Decimal(menuItem.price).add(accumulatedModifierPrice);
            const totalItemPrice = priceAtPurchase.mul(itemDto.quantity);

            processedItems.push({
                menuItemId: menuItem.id,
                quantity: itemDto.quantity,
                priceAtPurchase,
                totalItemPrice,
                notes: itemDto.notes,
                kdsDestination: menuItem.kdsDestination,
                itemNameSnapshot: menuItem.name_es || '√çtem (ES) no disponible', // Tomar snapshot
                itemDescriptionSnapshot: menuItem.description_es, // Tomar snapshot
                status: OrderItemStatus.PENDING_KDS, // Estado inicial por defecto
                modifierOptionsToCreate: modifierOptionsToCreateForDb,
            });
        }
        this.logger.log(`[OrderItemProcessor] Finished processing ${processedItems.length} items successfully.`);
        return processedItems;
    }

    /**
     * Obtiene y valida un MenuItem, asegurando que existe, pertenece al negocio y est√° disponible.
     * Incluye los grupos de modificadores y sus opciones disponibles.
     */
    private async fetchAndValidateMenuItem(
        tx: Prisma.TransactionClient,
        menuItemId: string,
        businessId: string
    ): Promise<MenuItemWithFullModifiers> {
        const menuItem = await tx.menuItem.findUnique({
            where: { id: menuItemId },
            ...menuItemWithFullModifiersArgs, // Usar el validador definido
        });

        if (!menuItem) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItemId}' not found.`);
            throw new NotFoundException(`√çtem de men√∫ con ID '${menuItemId}' no encontrado.`);
        }
        if (menuItem.businessId !== businessId) {
            this.logger.warn(`[OrderItemProcessor] MenuItem ID '${menuItemId}' (negocio: ${menuItem.businessId}) does not belong to specified business '${businessId}'.`);
            throw new BadRequestException(`√çtem de men√∫ con ID '${menuItem.name_es || menuItemId}' no pertenece a este negocio.`);
        }
        if (!menuItem.isAvailable) {
            this.logger.warn(`[OrderItemProcessor] MenuItem '${menuItem.name_es || menuItemId}' is not available.`);
            throw new BadRequestException(`El √≠tem '${menuItem.name_es || menuItemId}' no est√° disponible actualmente.`);
        }
        return menuItem;
    }

    /**
     * Procesa los modificadores seleccionados para un √≠tem de men√∫,
     * calcula el ajuste total de precio y valida las selecciones contra las reglas del grupo.
     *
     * @param menuItem - El MenuItem completo con sus grupos de modificadores y opciones cargadas.
     * @param selectedOptionsDto - Array de IDs de las ModifierOption seleccionadas por el cliente para este √≠tem.
     * @returns Objeto con el ajuste total de precio de los modificadores y los datos para crear OrderItemModifierOption.
     */
    private processAndValidateModifiersForItem(
        menuItem: MenuItemWithFullModifiers,
        selectedOptionsDto: SelectedModifierOptionInternalDto[]
    ): {
        accumulatedModifierPrice: Prisma.Decimal; // Suma de todos los priceAdjustments de las opciones v√°lidas
        modifierOptionsToCreateForDb: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[];
    } {
        let accumulatedModifierPrice = new Prisma.Decimal(0);
        const modifierOptionsToCreateForDb: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[] = [];

        // Casteo seguro, ya que menuItemWithFullModifiersArgs incluye esto
        const typedModifierGroups = menuItem.modifierGroups as ModifierGroupWithSelectedOptions[];

        // Un mapa para rastrear cu√°ntas opciones se seleccionaron por grupo
        const selectionsByGroupId: Record<string, SelectedModifierOptionShape[]> = {};

        // Primero, iterar sobre las opciones seleccionadas por el cliente para validarlas y calcular precios
        for (const selectedOptDto of selectedOptionsDto) {
            let foundOption: SelectedModifierOptionShape | undefined;
            let parentGroupForOption: ModifierGroupWithSelectedOptions | undefined;

            // Buscar la opci√≥n seleccionada dentro de todos los grupos del √≠tem
            for (const group of typedModifierGroups) {
                // option es de tipo SelectedModifierOptionShape (definido arriba)
                const option = group.options.find(opt => opt.id === selectedOptDto.modifierOptionId);
                if (option) {
                    foundOption = option;
                    parentGroupForOption = group;
                    break;
                }
            }

            if (!foundOption || !parentGroupForOption) {
                this.logger.warn(`[OrderItemProcessor] Invalid or unavailable modifierOptionId '${selectedOptDto.modifierOptionId}' for MenuItem '${menuItem.id}' ('${menuItem.name_es}'). Option not found in any group or group not found.`);
                throw new BadRequestException(`Opci√≥n de modificador con ID '${selectedOptDto.modifierOptionId}' no es v√°lida, no est√° disponible o no pertenece a ning√∫n grupo del √≠tem '${menuItem.name_es}'.`);
            }
            
            // Asegurarse de que la opci√≥n tiene un groupId (deber√≠a ser as√≠ por el schema y la consulta)
            if (!foundOption.groupId) {
                 this.logger.error(`[OrderItemProcessor] Critical: ModifierOption '${foundOption.id}' ('${foundOption.name_es}') has no groupId. This indicates a data integrity issue or an error in the Prisma query.`);
                 throw new InternalServerErrorException(`Error de configuraci√≥n: La opci√≥n de modificador '${foundOption.name_es}' no tiene un grupo asignado.`);
            }
            // Asegurarse de que el groupId de la opci√≥n coincide con el ID del grupo donde se encontr√≥
             if (foundOption.groupId !== parentGroupForOption.id) {
                this.logger.error(`[OrderItemProcessor] Critical: ModifierOption '${foundOption.id}' groupId '${foundOption.groupId}' does not match parent group ID '${parentGroupForOption.id}'.`);
                throw new InternalServerErrorException(`Error de configuraci√≥n: Inconsistencia en la asignaci√≥n de grupo para la opci√≥n '${foundOption.name_es}'.`);
            }


            // Registrar la selecci√≥n para el grupo padre
            if (!selectionsByGroupId[parentGroupForOption.id]) {
                selectionsByGroupId[parentGroupForOption.id] = [];
            }
            selectionsByGroupId[parentGroupForOption.id].push(foundOption);

            // Acumular ajuste de precio
            accumulatedModifierPrice = accumulatedModifierPrice.add(foundOption.priceAdjustment);

            // Preparar datos para la tabla de uni√≥n OrderItemModifierOption
            modifierOptionsToCreateForDb.push({
                modifierOptionId: foundOption.id,
                optionNameSnapshot: foundOption.name_es || 'Opci√≥n sin nombre ES', // Tomar snapshot
                optionPriceAdjustmentSnapshot: foundOption.priceAdjustment,
            });
        }

        // Segundo, validar las reglas de cada grupo del MenuItem
        for (const group of typedModifierGroups) {
            const selectedOptionsInThisGroup = selectionsByGroupId[group.id] || [];
            const countInThisGroup = selectedOptionsInThisGroup.length;

            this.logger.debug(`[OrderItemProcessor] Validating Group ID: ${group.id} ('${group.name_es}'). Required: ${group.isRequired}, Min: ${group.minSelections}, Max: ${group.maxSelections}, UI: ${group.uiType}. Selected count: ${countInThisGroup}`);

            if (group.isRequired && countInThisGroup < group.minSelections) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for group '${group.name_es}': required min ${group.minSelections}, got ${countInThisGroup}.`);
                throw new BadRequestException(`Para el √≠tem '${menuItem.name_es}', el grupo de opciones '${group.name_es}' requiere al menos ${group.minSelections} selecci√≥n(es). Se recibieron ${countInThisGroup}.`);
            }

            if (countInThisGroup > group.maxSelections) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for group '${group.name_es}': allowed max ${group.maxSelections}, got ${countInThisGroup}.`);
                throw new BadRequestException(`Para el √≠tem '${menuItem.name_es}', el grupo de opciones '${group.name_es}' permite como m√°ximo ${group.maxSelections} selecci√≥n(es). Se recibieron ${countInThisGroup}.`);
            }

            // Si es tipo RADIO, y se seleccion√≥ m√°s de uno (aunque el frontend deber√≠a prevenirlo, es una guarda)
            if (group.uiType === 'RADIO' && countInThisGroup > 1) {
                this.logger.warn(`[OrderItemProcessor] Validation fail for RADIO group '${group.name_es}': got ${countInThisGroup} selections, expected 0 or 1.`);
                throw new BadRequestException(`El grupo de opciones '${group.name_es}' (tipo RADIO) solo permite una selecci√≥n como m√°ximo.`);
            }
        }

        this.logger.log(`[OrderItemProcessor] Modifier processing for item '${menuItem.name_es}' complete. Accumulated adjustment: ${accumulatedModifierPrice}. Options to create: ${modifierOptionsToCreateForDb.length}`);
        return {
            accumulatedModifierPrice,
            modifierOptionsToCreateForDb,
        };
    }
}


// ====== [32] backend/src/modules/camarero/public/order-modification.service.ts ======
// backend/src/public/order-modification.service.ts
import {
    PrismaClient,
    Prisma,
    Order,
    OrderStatus,
    OrderItemStatus,
} from '@prisma/client';
import {
    Injectable,
    Logger,
    NotFoundException,
    BadRequestException,
    InternalServerErrorException,
} from '@nestjs/common';

import { OrderItemProcessorService, ProcessedOrderItemData } from './order-item-processor.service';

// Importar tipos desde el archivo centralizado
import {
    FrontendAddItemsToOrderDto,
    FrontendAddItemsOrderItemDto, // Este tipo ahora deber√≠a tener 'notes' y 'selectedModifierOptions'
    OrderItemInternalDto,         // Tipo que espera OrderItemProcessorService
    SelectedModifierOptionInternalDto // Tipo que espera OrderItemProcessorService
} from './order.types';

interface BusinessContextForOrder {
    id: string;
    isActive: boolean;
    isCamareroActive: boolean;
}

@Injectable()
export class OrderModificationService {
    private readonly logger = new Logger(OrderModificationService.name);
    private readonly orderItemProcessorService: OrderItemProcessorService;
    private prisma: PrismaClient;

    constructor() {
        this.prisma = new PrismaClient();
        this.orderItemProcessorService = new OrderItemProcessorService();
        this.logger.log("OrderModificationService instantiated");
    }

    async addItemsToExistingOrder(
        orderId: string,
        addItemsDto: FrontendAddItemsToOrderDto, // DTO del frontend
        businessSlug: string,
        _requestingCustomerId?: string | null
    ): Promise<Order> {
        this.logger.log(`[OrderModificationService] Attempting to add ${addItemsDto.items.length} items to order '${orderId}' for business slug '${businessSlug}'.`);

        const businessContext = await this._validateBusinessForOrdering(businessSlug);
        const businessId = businessContext.id;

        return this.prisma.$transaction(async (tx) => {
            this.logger.log(`[OrderModificationService TX] Transaction started for adding items to order '${orderId}'.`);

            const order = await tx.order.findUnique({
                where: { id: orderId },
                select: { id: true, status: true, businessId: true, totalAmount: true, finalAmount: true, notes: true, isBillRequested: true }
            });

            if (!order) {
                this.logger.warn(`[OrderModificationService TX] Order with ID '${orderId}' not found.`);
                throw new NotFoundException(`Pedido con ID '${orderId}' no encontrado.`);
            }
            if (order.businessId !== businessId) {
                this.logger.warn(`[OrderModificationService TX] Order '${orderId}' (business: ${order.businessId}) does not belong to specified business '${businessId}'.`);
                throw new BadRequestException(`El pedido no pertenece al negocio especificado.`);
            }

            const validStatusToAddItems: OrderStatus[] = [
                OrderStatus.RECEIVED, OrderStatus.IN_PROGRESS,
                OrderStatus.PARTIALLY_READY, OrderStatus.ALL_ITEMS_READY,
                OrderStatus.COMPLETED, OrderStatus.PENDING_PAYMENT,
            ];
            if (!validStatusToAddItems.includes(order.status)) {
                this.logger.warn(`[OrderModificationService TX] Cannot add items to order '${orderId}' in status '${order.status}'.`);
                throw new BadRequestException(`No se pueden a√±adir √≠tems a un pedido en estado '${order.status}'.`);
            }

            // --- CORRECCI√ìN EN EL MAPEO Y TIPADO ---
            // Mapear FrontendAddItemsOrderItemDto a OrderItemInternalDto
            const itemsToProcessDto: OrderItemInternalDto[] = addItemsDto.items.map((item: FrontendAddItemsOrderItemDto) => ({
                menuItemId: item.menuItemId,
                quantity: item.quantity,
                notes: item.notes, // 'notes' ahora existe en FrontendAddItemsOrderItemDto
                selectedModifierOptions: item.selectedModifierOptions?.map(
                    (sm: { modifierOptionId: string }) => ({ // Tipo expl√≠cito para 'sm'
                        modifierOptionId: sm.modifierOptionId
                    })
                ) || [], // Asegurar que sea un array vac√≠o si es undefined
            }));
            // --- FIN CORRECCI√ìN ---

            const processedNewItems: ProcessedOrderItemData[] =
                await this.orderItemProcessorService.processOrderItems(
                    tx,
                    businessId,
                    itemsToProcessDto
                );

            // ... (resto de la l√≥gica de la funci√≥n sin cambios)...
            if (processedNewItems.length === 0 && addItemsDto.items.length > 0) {
                this.logger.warn(`[OrderModificationService TX] All new items in payload were invalid. No items to add to order '${orderId}'.`);
                throw new BadRequestException('Ninguno de los nuevos √≠tems proporcionados pudo ser procesado.');
            }
             if (processedNewItems.length === 0 && addItemsDto.items.length === 0) {
                this.logger.warn(`[OrderModificationService TX] No new items provided in the payload to add to order '${orderId}'.`);
                throw new BadRequestException('No se proporcionaron √≠tems para a√±adir al pedido.');
            }

            const additionalAmount = processedNewItems.reduce(
                (sum, item) => sum.add(item.totalItemPrice),
                new Prisma.Decimal(0)
            );
            const newTotalAmount = new Prisma.Decimal(order.totalAmount).add(additionalAmount);
            const newFinalAmount = new Prisma.Decimal(order.finalAmount || order.totalAmount).add(additionalAmount);
            this.logger.log(`[OrderModificationService TX] Additional amount for order '${orderId}': ${additionalAmount}. New total: ${newTotalAmount}`);

            let updatedOrderNotes = order.notes;
            if (addItemsDto.customerNotes && addItemsDto.customerNotes.trim() !== '') {
                const additionNotePrefix = "Adici√≥n de √≠tems:";
                updatedOrderNotes = order.notes
                    ? `${order.notes}\n---\n${additionNotePrefix} ${addItemsDto.customerNotes.trim()}`
                    : `${additionNotePrefix} ${addItemsDto.customerNotes.trim()}`;
            }

            let newOrderStatus = order.status;
            let resetBillRequested = false;
            if (
                (order.status === OrderStatus.COMPLETED ||
                 order.status === OrderStatus.ALL_ITEMS_READY ||
                 order.status === OrderStatus.PENDING_PAYMENT) &&
                processedNewItems.length > 0
            ) {
                newOrderStatus = OrderStatus.IN_PROGRESS;
                this.logger.log(`[OrderModificationService TX] Order '${orderId}' was '${order.status}', new items added. Changing status to '${newOrderStatus}'.`);
                if (order.status === OrderStatus.PENDING_PAYMENT && order.isBillRequested) {
                    resetBillRequested = true;
                    this.logger.log(`[OrderModificationService TX] Bill was requested for order '${orderId}', resetting flag.`);
                }
            }

            const orderUpdateData: Prisma.OrderUpdateInput = {
                items: {
                    create: processedNewItems.map(pItem => ({
                        menuItemId: pItem.menuItemId,
                        quantity: pItem.quantity,
                        priceAtPurchase: pItem.priceAtPurchase,
                        totalItemPrice: pItem.totalItemPrice,
                        notes: pItem.notes,
                        kdsDestination: pItem.kdsDestination,
                        itemNameSnapshot: pItem.itemNameSnapshot,
                        itemDescriptionSnapshot: pItem.itemDescriptionSnapshot,
                        status: pItem.status,
                        ...(pItem.modifierOptionsToCreate.length > 0 && {
                            selectedModifiers: {
                                createMany: { data: pItem.modifierOptionsToCreate },
                            },
                        }),
                    })),
                },
                totalAmount: newTotalAmount,
                finalAmount: newFinalAmount,
                notes: updatedOrderNotes,
                status: newOrderStatus,
            };

            if (resetBillRequested) {
                orderUpdateData.isBillRequested = false;
            }

            const updatedOrder = await tx.order.update({
                where: { id: orderId },
                data: orderUpdateData,
                include: { items: { include: { selectedModifiers: true } }, table: true },
            });

            this.logger.log(`[OrderModificationService TX] Items successfully added to order '${orderId}'. New total: ${updatedOrder.totalAmount}. New status: ${updatedOrder.status}`);
            return updatedOrder;
        });
    }

    private async _validateBusinessForOrdering(businessSlug: string): Promise<BusinessContextForOrder> {
        // ... (sin cambios)
        const business = await this.prisma.business.findUnique({
            where: { slug: businessSlug },
            select: { id: true, isActive: true, isCamareroActive: true },
        });

        if (!business) {
            this.logger.warn(`[OrderModificationService] Business with slug '${businessSlug}' not found.`);
            throw new NotFoundException(`Negocio con slug '${businessSlug}' no encontrado.`);
        }
        if (!business.isActive) {
            this.logger.warn(`[OrderModificationService] Business '${businessSlug}' is not active.`);
            throw new BadRequestException(`El negocio '${businessSlug}' no est√° activo y no puede procesar pedidos.`);
        }
        if (!business.isCamareroActive) {
            this.logger.warn(`[OrderModificationService] Camarero module not active for business '${businessSlug}'.`);
            throw new BadRequestException(`El m√≥dulo de pedidos (Camarero) no est√° activo para el negocio '${businessSlug}'.`);
        }
        this.logger.log(`[OrderModificationService] Business '${businessSlug}' validated for ordering. ID: ${business.id}`);
        return business;
    }
}


// ====== [33] backend/src/modules/camarero/public/order-payment.service.ts ======
// backend/src/modules/camarero/public/order-payment.service.ts (CORREGIDO)
import {
    PrismaClient,
    Prisma,
    Order,
    OrderStatus,
    TableStatus,
    User,
    Business,
    ActivityType,
    TierBenefit,
} from '@prisma/client';
import {
    Injectable,
    Logger,
    NotFoundException,
    BadRequestException,
    ForbiddenException,
    InternalServerErrorException,
} from '@nestjs/common';

// --- RUTAS CORREGIDAS ---
import { TableService } from '../../../shared/services/table.service';
import { LoyaltyPointsService } from '../../../shared/services/loyalty-points.service';
import { updateUserTier } from '../../../modules/loyalpyme/tiers/tier-logic.service';
// --- FIN RUTAS CORREGIDAS ---

// Tipos para los datos que necesita LoyaltyPointsService
type OrderForLoyalty = Pick<Order, 'id' | 'orderNumber' | 'finalAmount' | 'totalAmount' | 'customerLCoId' | 'businessId'>;
type CustomerForLoyalty = User & {
    currentTier?: ({ benefits: Pick<TierBenefit, 'type' | 'value' | 'isActive'>[] } & { id: string; name: string }) | null;
};
type BusinessForLoyalty = Pick<Business, 'id' | 'pointsPerEuro' | 'isLoyaltyCoreActive'>;

@Injectable()
export class OrderPaymentService {
    private readonly logger = new Logger(OrderPaymentService.name);
    private readonly tableService: TableService;
    private readonly loyaltyPointsService: LoyaltyPointsService;
    private prisma: PrismaClient;

    constructor() {
        this.prisma = new PrismaClient();
        this.tableService = new TableService();
        this.loyaltyPointsService = new LoyaltyPointsService();
        this.logger.log("OrderPaymentService instantiated");
    }

    async requestBillForClient(
        orderId: string,
        paymentPreference?: string | null
    ): Promise<Order> {
        this.logger.log(`[OrderPaymentService] Client requesting bill for order '${orderId}'. Preference: ${paymentPreference || 'N/A'}`);

        return this.prisma.$transaction(async (tx) => {
            const order = await tx.order.findUnique({
                where: { id: orderId },
                select: { id: true, status: true, businessId: true, tableId: true, orderNumber: true },
            });

            if (!order) {
                this.logger.warn(`[OrderPaymentService TX] Order '${orderId}' not found for client bill request.`);
                throw new NotFoundException(`Pedido con ID '${orderId}' no encontrado.`);
            }

            const allowedStates: OrderStatus[] = [
                OrderStatus.RECEIVED, OrderStatus.IN_PROGRESS,
                OrderStatus.PARTIALLY_READY, OrderStatus.ALL_ITEMS_READY,
                OrderStatus.COMPLETED,
            ];
            if (!allowedStates.includes(order.status)) {
                this.logger.warn(`[OrderPaymentService TX] Cannot request bill for order '${orderId}' in status '${order.status}'.`);
                throw new BadRequestException(`No se puede solicitar la cuenta para un pedido en estado '${order.status}'.`);
            }

            const updateData: Prisma.OrderUpdateInput = {
                status: OrderStatus.PENDING_PAYMENT,
                isBillRequested: true,
            };
            if (paymentPreference !== undefined) {
                updateData.paymentMethodPreference = paymentPreference;
            }

            const updatedOrder = await tx.order.update({
                where: { id: orderId },
                data: updateData,
            });
            this.logger.log(`[OrderPaymentService TX] Order '${orderId}' status set to PENDING_PAYMENT by client request.`);

            if (order.tableId && order.businessId) {
                try {
                    await this.tableService.updateTableStatus(tx, order.tableId, TableStatus.PENDING_PAYMENT_TABLE);
                    this.logger.log(`[OrderPaymentService TX] Table ID '${order.tableId}' status updated to PENDING_PAYMENT_TABLE.`);
                } catch (tableError) {
                    this.logger.error(`[OrderPaymentService TX] Failed to update table status for table '${order.tableId}' during client bill request. Continuing. Error:`, tableError);
                }
            }
            return updatedOrder;
        });
    }

    async markOrderAsPaid(
        orderId: string,
        paidByStaffId: string,
        businessId: string,
        paymentDetails?: { method?: string; notes?: string }
    ): Promise<Order> {
        this.logger.log(`[OrderPaymentService] Staff '${paidByStaffId}' attempting to mark order '${orderId}' as PAID for business '${businessId}'. Payment method: ${paymentDetails?.method || 'N/A'}`);

        return this.prisma.$transaction(async (tx) => {
            const order = await tx.order.findUnique({
                where: { id: orderId },
                include: {
                    business: { select: { id: true, isLoyaltyCoreActive: true, pointsPerEuro: true } },
                    table: { select: { id: true, status: true } },
                    customerLCo: {
                        include: {
                            currentTier: {
                                include: {
                                    benefits: { where: { isActive: true, type: 'POINTS_MULTIPLIER' } }
                                }
                            }
                        }
                    }
                }
            });

            if (!order) {
                this.logger.warn(`[OrderPaymentService TX] Order '${orderId}' not found.`);
                throw new NotFoundException(`Pedido con ID '${orderId}' no encontrado.`);
            }
            if (order.businessId !== businessId) {
                this.logger.warn(`[OrderPaymentService TX] Order '${orderId}' (business: ${order.businessId}) does not belong to staff's business '${businessId}'.`);
                throw new ForbiddenException("El pedido no pertenece al negocio del personal.");
            }

            if (order.status !== OrderStatus.PENDING_PAYMENT && order.status !== OrderStatus.COMPLETED) {
                this.logger.warn(`[OrderPaymentService TX] Cannot mark order '${orderId}' as PAID. Current status: '${order.status}'.`);
                throw new BadRequestException(`Solo se pueden marcar como pagados pedidos en estado 'PENDING_PAYMENT' o 'COMPLETED'. Estado actual: ${order.status}`);
            }

            const updatedOrder = await tx.order.update({
                where: { id: orderId },
                data: {
                    status: OrderStatus.PAID,
                    paidAt: new Date(),
                    paidByUserId: paidByStaffId,
                    paymentMethodUsed: paymentDetails?.method,
                },
            });
            this.logger.log(`[OrderPaymentService TX] Order '${orderId}' status updated to PAID.`);

            if (order.tableId && order.table && order.table.status !== TableStatus.AVAILABLE) {
                await this.tableService.updateTableStatus(tx, order.tableId, TableStatus.AVAILABLE);
                this.logger.log(`[OrderPaymentService TX] Table ID '${order.tableId}' status updated to AVAILABLE.`);
            }

            if (order.customerLCoId && order.business?.isLoyaltyCoreActive && order.customerLCo) {
                const loyaltyResult = await this.loyaltyPointsService.awardPointsForLcOrder(
                    tx,
                    order as OrderForLoyalty,
                    order.customerLCo as CustomerForLoyalty,
                    order.business as BusinessForLoyalty
                );
                if (loyaltyResult) {
                    this.logger.log(`[OrderPaymentService TX] Loyalty points awarded: ${loyaltyResult.pointsAwarded} for order '${orderId}'.`);
                } else {
                    this.logger.warn(`[OrderPaymentService TX] Loyalty points awarding process for order '${orderId}' returned null (possibly skipped or failed internally).`);
                }
            } else {
                if (order.customerLCoId) {
                    this.logger.log(`[OrderPaymentService TX] LCo module not active for business '${order.businessId}' or customer data missing. Skipping LCo points for order '${order.id}'.`);
                }
            }
            return updatedOrder;
        });
    }
}


// ====== [34] backend/src/modules/camarero/public/order.controller.ts ======
// backend/src/public/order.controller.ts
// Version 1.2.1 (Fix private logger access in NestJS controller part)
import { Controller, Post, Body, Param, Get, Req, BadRequestException, NotFoundException } from '@nestjs/common';
import { Request as ExpressRequest, Response as ExpressResponse, NextFunction } from 'express';
import { Order } from '@prisma/client';
import { plainToInstance } from 'class-transformer';
import { validate } from 'class-validator';

import { CreateOrderDto, AddItemsToOrderDto, RequestBillClientPayloadDto } from './order.dto';
import { CreateOrderPayloadInternalDto, PublicOrderStatusInfo } from './order.types';

import { OrderService } from './order.service';
import { OrderCreationService } from './order-creation.service';
import { OrderModificationService } from './order-modification.service';
import { OrderPaymentService } from './order-payment.service';

const orderServiceInstance = new OrderService();
const orderCreationServiceInstance = new OrderCreationService();
const orderModificationServiceInstance = new OrderModificationService();
const orderPaymentServiceInstance = new OrderPaymentService();

// --- Handlers Express (sin cambios respecto a la versi√≥n anterior que te pas√©) ---

export const createPublicOrderHandler = async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
    try {
        const businessSlug = req.params.businessSlug;
        const createOrderDto = plainToInstance(CreateOrderDto, req.body as Record<string, any>);
        const validationErrors = await validate(createOrderDto, { whitelist: true, forbidNonWhitelisted: true });

        if (validationErrors.length > 0) {
            console.error('[OrderCtrl createPublic] DTO validation errors:', JSON.stringify(validationErrors, null, 2));
            const formattedErrors = validationErrors.map(err => ({ property: err.property, constraints: err.constraints }));
            return res.status(400).json({ message: 'Error de validaci√≥n en los datos del pedido.', errors: formattedErrors });
        }

        if (!businessSlug) {
            return res.status(400).json({ message: 'Business slug es requerido en la ruta.' });
        }

        const servicePayload: CreateOrderPayloadInternalDto = {
            tableIdentifier: createOrderDto.tableIdentifier,
            orderNotes: createOrderDto.customerNotes,
            customerId: createOrderDto.customerId,
            items: createOrderDto.items.map(item => ({
                menuItemId: item.menuItemId,
                quantity: item.quantity,
                notes: item.notes,
                selectedModifierOptions: item.selectedModifierOptions?.map(mod => ({ modifierOptionId: mod.modifierOptionId })) || [],
            })),
        };

        const newOrder: Order = await orderCreationServiceInstance.createNewOrder(
            businessSlug,
            servicePayload,
            createOrderDto.customerId
        );
        res.status(201).json(newOrder);
    } catch (error) {
        next(error);
    }
};

export const addItemsToExistingOrderHandler = async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
    try {
        const orderId = req.params.orderId;
        const addItemsToOrderDto = plainToInstance(AddItemsToOrderDto, req.body as Record<string, any>);
        const validationErrors = await validate(addItemsToOrderDto, { whitelist: true, forbidNonWhitelisted: true });

        if (validationErrors.length > 0) {
            console.error('[OrderCtrl addItems] DTO validation errors:', JSON.stringify(validationErrors, null, 2));
            const formattedErrors = validationErrors.map(err => ({ property: err.property, constraints: err.constraints }));
            return res.status(400).json({ message: 'Error de validaci√≥n al a√±adir √≠tems.', errors: formattedErrors });
        }

        const businessSlugFromHeader = req.headers['x-loyalpyme-business-slug'] as string;

        if (!orderId) return res.status(400).json({ message: 'Order ID es requerido.' });
        if (!businessSlugFromHeader) return res.status(400).json({ message: 'Contexto de Business Slug (x-loyalpyme-business-slug header) es requerido.' });

        const updatedOrder: Order = await orderModificationServiceInstance.addItemsToExistingOrder(
            orderId,
            addItemsToOrderDto,
            businessSlugFromHeader,
        );
        res.status(200).json(updatedOrder);
    } catch (error) {
        next(error);
    }
};

export const getPublicOrderStatusHandler = async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
    try {
        const orderId = req.params.orderId;
        if (!orderId) {
            return res.status(400).json({ message: 'Order ID es requerido.' });
        }
        const statusInfo: PublicOrderStatusInfo | null = await orderServiceInstance.getOrderStatus(orderId);
        if (!statusInfo) {
            return res.status(404).json({ message: `Pedido con ID ${orderId} no encontrado.` });
        }
        res.status(200).json(statusInfo);
    } catch (error) {
        next(error);
    }
};

export const requestBillByClientHandler = async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {
    const { orderId } = req.params;
    const requestBillDto = plainToInstance(RequestBillClientPayloadDto, (req.body || {}) as Record<string, any>);
    const validationErrors = await validate(requestBillDto);

    if (validationErrors.length > 0) {
        const formattedErrors = validationErrors.map(err => ({ property: err.property, constraints: err.constraints }));
        return res.status(400).json({ message: 'Datos inv√°lidos para solicitar la cuenta.', errors: formattedErrors });
    }

    if (!orderId) {
        return res.status(400).json({ message: "Falta el ID del pedido (orderId) en la URL." });
    }

    console.log(`[OrderCtrl requestBillClient] Client requesting bill for order ${orderId}. Preference: ${requestBillDto.paymentPreference || 'N/A'}`);

    try {
        const updatedOrder: Order = await orderPaymentServiceInstance.requestBillForClient(
            orderId,
            requestBillDto.paymentPreference
        );

        res.status(200).json({
            message: `Cuenta solicitada para el pedido #${updatedOrder.orderNumber}. Estado: ${updatedOrder.status}.`,
            order: {
                id: updatedOrder.id,
                orderNumber: updatedOrder.orderNumber,
                status: updatedOrder.status,
                isBillRequested: updatedOrder.isBillRequested,
            }
        });
    } catch (error) {
        next(error);
    }
};

// --- Clase de Controlador NestJS (DEPRECADA o para futura migraci√≥n completa a NestJS) ---
@Controller('public/orders_nest')
export class OrderController {
  constructor(
    private readonly creationService: OrderCreationService,
    private readonly modificationService: OrderModificationService,
    private readonly paymentService: OrderPaymentService,
    private readonly statusService: OrderService
  ) {}

  @Post(':businessSlug')
  async createOrderNest(
    @Param('businessSlug') businessSlug: string,
    @Body() createOrderDto: CreateOrderDto,
    @Req() req: any,
  ) {
    const user = req.user;
    const servicePayload: CreateOrderPayloadInternalDto = {
      tableIdentifier: createOrderDto.tableIdentifier,
      orderNotes: createOrderDto.customerNotes,
      customerId: createOrderDto.customerId || user?.id,
      items: createOrderDto.items.map((item) => ({
        menuItemId: item.menuItemId,
        quantity: item.quantity,
        notes: item.notes,
        selectedModifierOptions: item.selectedModifierOptions?.map(mod => ({
            modifierOptionId: mod.modifierOptionId
        })) || []
      })),
    };
    return this.creationService.createNewOrder(
        businessSlug,
        servicePayload,
        createOrderDto.customerId || user?.id
    );
  }

  @Get(':orderId/status')
  async getOrderStatusNest(@Param('orderId') orderId: string) {
    const statusInfo = await this.statusService.getOrderStatus(orderId);
    if (!statusInfo) {
        throw new NotFoundException(`Pedido con ID ${orderId} no encontrado.`);
    }
    return statusInfo;
  }

  @Post(':orderId/items')
  async addItemsToExistingOrderNest(
    @Param('orderId') orderId: string,
    @Body() addItemsToOrderDto: AddItemsToOrderDto,
    @Req() req: any,
  ) {
    const businessSlugFromHeader = req.headers['x-loyalpyme-business-slug'] as string;
    const user = req.user;
    if (!businessSlugFromHeader) {
      throw new BadRequestException('Contexto de Business Slug (x-loyalpyme-business-slug header) es requerido.');
    }
    return this.modificationService.addItemsToExistingOrder(
      orderId,
      addItemsToOrderDto,
      businessSlugFromHeader,
      user?.id,
    );
  }

  @Post(':orderId/request-bill')
  async requestBillByClientNest(
      @Param('orderId') orderId: string,
      @Body() requestBillDto: RequestBillClientPayloadDto
  ) {
      if (!orderId) {
          throw new BadRequestException("Falta el ID del pedido (orderId) en la URL.");
      }
      // --- CORRECCI√ìN: Quitar el log que accede a logger privado ---
      // this.paymentService.logger.log(`[NestCtrl requestBillClient] Client requesting bill for order ${orderId}. Preference: ${requestBillDto.paymentPreference || 'N/A'}`);
      // El OrderPaymentService ya loguea esto internamente.
      // --- FIN CORRECCI√ìN ---
      const updatedOrder = await this.paymentService.requestBillForClient(
          orderId,
          requestBillDto.paymentPreference
      );
      return {
          message: `Cuenta solicitada para el pedido #${updatedOrder.orderNumber}. Estado: ${updatedOrder.status}.`,
          order: {
              id: updatedOrder.id,
              orderNumber: updatedOrder.orderNumber,
              status: updatedOrder.status,
              isBillRequested: updatedOrder.isBillRequested,
          }
      };
  }
}


// ====== [35] backend/src/modules/camarero/public/order.dto.ts ======
// backend/src/public/order.dto.ts
// Versi√≥n 1.7.1 (Add IsArray() to selectedModifierOptions and make optional)

import { Type } from 'class-transformer';
import {
  IsArray,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
  IsUUID,
  Min,
  ValidateNested,
} from 'class-validator';

// DTO para cada opci√≥n de modificador seleccionada DENTRO de un √≠tem de pedido
export class SelectedOrderModifierOptionDto {
  @IsString()
  @IsNotEmpty({ message: 'modifierOptionId no puede estar vac√≠o.'})
  modifierOptionId!: string;
}

// DTO para cada √≠tem de pedido en la creaci√≥n
export class CreateOrderItemDto {
  @IsUUID()
  @IsNotEmpty({ message: 'El ID del art√≠culo del men√∫ no puede estar vac√≠o al crear.' })
  menuItemId!: string;

  @IsNumber({}, { message: 'La cantidad debe ser un n√∫mero al crear.' })
  @Min(1, { message: 'La cantidad debe ser como m√≠nimo 1 al crear.' })
  quantity!: number;

  @IsOptional()
  @IsString()
  notes?: string;

  // --- CORRECCI√ìN AQU√ç ---
  @IsOptional() // El array completo es opcional
  @IsArray({ message: 'Los modificadores seleccionados deben ser un array.' }) // Asegurarse de que, si viene, sea un array
  @ValidateNested({ each: true })
  @Type(() => SelectedOrderModifierOptionDto)
  selectedModifierOptions?: SelectedOrderModifierOptionDto[];
  // --- FIN CORRECCI√ìN ---
}

// DTO principal para crear un pedido
export class CreateOrderDto {
  @IsOptional()
  @IsString()
  businessId?: string;

  @IsString({ message: 'El identificador de mesa debe ser texto.' })
  @IsOptional()
  tableIdentifier?: string;

  @IsArray({ message: 'Los √≠tems deben ser un array al crear.' })
  @ValidateNested({ each: true, message: 'Cada √≠tem debe ser v√°lido al crear.' })
  @Type(() => CreateOrderItemDto)
  items!: CreateOrderItemDto[];

  @IsString({ message: 'Las notas del cliente deben ser texto.' })
  @IsOptional()
  customerNotes?: string;

  @IsUUID()
  @IsOptional()
  customerId?: string;
}

// --- DTOs para A√ëADIR √≠tems a un pedido existente (tambi√©n corregido) ---

export class AddItemsOrderItemDto {
    @IsUUID()
    @IsNotEmpty({ message: 'El ID del art√≠culo del men√∫ no puede estar vac√≠o.' })
    menuItemId!: string;

    @IsNumber({}, { message: 'La cantidad debe ser un n√∫mero.' })
    @Min(1, { message: 'La cantidad debe ser como m√≠nimo 1.' })
    quantity!: number;

    @IsOptional()
    @IsString()
    notes?: string;
    
    // --- CORRECCI√ìN AQU√ç ---
    @IsOptional()
    @IsArray({ message: 'Los modificadores seleccionados deben ser un array.' })
    @ValidateNested({ each: true })
    @Type(() => SelectedOrderModifierOptionDto)
    selectedModifierOptions?: SelectedOrderModifierOptionDto[];
    // --- FIN CORRECCI√ìN ---
}

export class AddItemsToOrderDto {
    @IsArray({ message: 'Los √≠tems deben ser un array.' })
    @ValidateNested({ each: true, message: 'Cada √≠tem debe ser v√°lido.' })
    @Type(() => AddItemsOrderItemDto)
    items!: AddItemsOrderItemDto[];

    @IsString({ message: 'Las notas del cliente deben ser texto.' })
    @IsOptional()
    customerNotes?: string;
}

// DTO para solicitar la cuenta (sin cambios)
export class RequestBillClientPayloadDto {
  @IsOptional()
  @IsString({ message: 'La preferencia de pago debe ser texto.' })
  paymentPreference?: string;
}


// ====== [36] backend/src/modules/camarero/public/order.service.ts ======
// backend/src/public/order.service.ts
// Versi√≥n 2.1.0 (Refactored to use dedicated sub-services for creation, modification, and payment logic)
import {
    Injectable,
    Logger,
    // Las excepciones espec√≠ficas ya no se lanzan desde aqu√≠, sino desde los sub-servicios.
} from '@nestjs/common';
import {
    PrismaClient,
    Order,
    // Ya no se necesitan la mayor√≠a de los otros tipos de Prisma aqu√≠
} from '@prisma/client';

// Importar los nuevos servicios que har√°n el trabajo pesado
import { OrderCreationService } from './order-creation.service';
import { OrderModificationService } from './order-modification.service';
import { OrderPaymentService } from './order-payment.service';

// Importar los tipos necesarios desde el archivo centralizado
import {
    CreateOrderPayloadInternalDto,
    PublicOrderStatusInfo,
    PublicOrderItemStatusInfo,
    FrontendAddItemsToOrderDto,
} from './order.types'; // Asumiendo que se llama order.types.ts

@Injectable()
export class OrderService {
    private readonly logger = new Logger(OrderService.name);

    // Instanciar los nuevos servicios. En un entorno NestJS completo, se inyectar√≠an.
    private readonly orderCreationService: OrderCreationService;
    private readonly orderModificationService: OrderModificationService;
    private readonly orderPaymentService: OrderPaymentService;
    private readonly prisma: PrismaClient; // Necesario solo para getOrderStatus si se queda aqu√≠

    constructor() {
        this.orderCreationService = new OrderCreationService();
        this.orderModificationService = new OrderModificationService();
        this.orderPaymentService = new OrderPaymentService();
        this.prisma = new PrismaClient();
        this.logger.log("OrderService (Public Orchestrator) instantiated");
    }

    /**
     * Orquesta la creaci√≥n de un nuevo pedido delegando al OrderCreationService.
     */
    async createOrder(
        businessSlug: string,
        payload: CreateOrderPayloadInternalDto,
        requestingCustomerId?: string | null
    ): Promise<Order> {
        this.logger.log(`[OrderService -> Create] Orchestrating new order for business slug '${businessSlug}'.`);
        // La l√≥gica compleja ahora vive en OrderCreationService
        return this.orderCreationService.createNewOrder(businessSlug, payload, requestingCustomerId);
    }

    /**
     * Orquesta la adici√≥n de √≠tems a un pedido existente delegando al OrderModificationService.
     */
    async addItemsToOrder(
        orderId: string,
        addItemsDto: FrontendAddItemsToOrderDto,
        businessSlug: string,
        requestingCustomerId?: string | null,
    ): Promise<Order> {
        this.logger.log(`[OrderService -> AddItems] Orchestrating add items to order '${orderId}' for business slug '${businessSlug}'.`);
        // La l√≥gica compleja ahora vive en OrderModificationService
        return this.orderModificationService.addItemsToExistingOrder(
            orderId,
            addItemsDto,
            businessSlug,
            requestingCustomerId
        );
    }

    /**
     * Orquesta la solicitud de cuenta por parte de un cliente delegando al OrderPaymentService.
     */
    async requestBillForClient(
        orderId: string,
        paymentPreference?: string | null
    ): Promise<Order> {
        this.logger.log(`[OrderService -> RequestBillClient] Orchestrating client bill request for order '${orderId}'.`);
        // La l√≥gica compleja ahora vive en OrderPaymentService
        return this.orderPaymentService.requestBillForClient(orderId, paymentPreference);
    }

    /**
     * Orquesta el marcado de un pedido como pagado delegando al OrderPaymentService.
     * Este m√©todo ser√≠a llamado t√≠picamente desde un servicio de staff (como WaiterService), no directamente desde un controlador p√∫blico.
     */
    async markOrderAsPaid(
        orderId: string,
        paidByStaffId: string,
        businessId: string,
        paymentDetails?: { method?: string; notes?: string }
    ): Promise<Order> {
        this.logger.log(`[OrderService -> MarkPaid] Orchestrating mark order '${orderId}' as PAID by staff '${paidByStaffId}'.`);
        // La l√≥gica compleja ahora vive en OrderPaymentService
        return this.orderPaymentService.markOrderAsPaid(orderId, paidByStaffId, businessId, paymentDetails);
    }

    /**
     * Obtiene la informaci√≥n p√∫blica del estado de un pedido.
     * Esta funci√≥n es principalmente de lectura y puede permanecer aqu√≠.
     */
    async getOrderStatus(orderId: string): Promise<PublicOrderStatusInfo | null> {
        this.logger.log(`[OrderService -> GetStatus] Fetching public status for order '${orderId}'.`);
        try {
            const order = await this.prisma.order.findUnique({
                where: { id: orderId },
                select: {
                    id: true, orderNumber: true, status: true, notes: true, createdAt: true,
                    isBillRequested: true,
                    table: { select: { identifier: true } },
                    items: {
                        select: { id: true, itemNameSnapshot: true, itemDescriptionSnapshot: true, quantity: true, status: true },
                        orderBy: { createdAt: 'asc' }
                    }
                }
            });

            if (!order) {
                this.logger.warn(`[OrderService getOrderStatus] Pedido con ID ${orderId} no encontrado.`);
                return null;
            }

            const itemsInfo: PublicOrderItemStatusInfo[] = order.items.map(item => ({
                id: item.id,
                menuItemName_es: item.itemNameSnapshot,
                menuItemName_en: null, // Si tuvieras itemNameSnapshot_en, lo usar√≠as aqu√≠
                quantity: item.quantity,
                status: item.status,
            }));

            const orderStatusInfo: PublicOrderStatusInfo = {
                orderId: order.id,
                orderNumber: order.orderNumber,
                orderStatus: order.status,
                items: itemsInfo,
                tableIdentifier: order.table?.identifier || null,
                orderNotes: order.notes,
                createdAt: order.createdAt,
                isBillRequested: order.isBillRequested,
            };

            this.logger.log(`[OrderService -> GetStatus] Status for order '${orderId}': ${orderStatusInfo.orderStatus}`);
            return orderStatusInfo;
        } catch (error) {
            this.logger.error(`[OrderService -> GetStatus] Error fetching status for order '${orderId}':`, error);
            // Relanzar para que el controlador lo maneje
            throw error;
        }
    }
}


// ====== [37] backend/src/modules/camarero/public/order.types.ts ======
// backend/src/public/order.types.ts
import { OrderStatus, OrderItemStatus, Prisma } from '@prisma/client';

// --- DTOs y Tipos para la L√≥gica Interna de los Servicios de Pedidos ---

/**
 * Representa una opci√≥n de modificador seleccionada, usado internamente por los servicios
 * al procesar los payloads de entrada.
 */
export interface SelectedModifierOptionInternalDto {
    modifierOptionId: string;
}

/**
 * Representa un √≠tem de pedido en su forma interna, tal como lo esperan los servicios
 * de procesamiento y creaci√≥n antes de la validaci√≥n completa y el c√°lculo de precios.
 */
export interface OrderItemInternalDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: SelectedModifierOptionInternalDto[] | null; // Array de IDs de opciones
}

/**
 * Payload interno que usan OrderCreationService y OrderModificationService,
 * derivado de lo que env√≠an los DTOs del frontend/controlador.
 */
export interface CreateOrderPayloadInternalDto {
    tableIdentifier?: string | null;
    customerId?: string | null; // Cliente LCo
    orderNotes?: string | null; // Notas generales del pedido
    items: OrderItemInternalDto[];
}

/**
 * Estructura de datos que devuelve OrderItemProcessorService para cada √≠tem procesado.
 * Contiene toda la informaci√≥n validada y calculada lista para la creaci√≥n en BD.
 */
export interface ProcessedOrderItemData {
    menuItemId: string;
    quantity: number;
    priceAtPurchase: Prisma.Decimal; // Precio unitario del √≠tem CON modificadores
    totalItemPrice: Prisma.Decimal;  // priceAtPurchase * quantity
    notes?: string | null;           // Notas espec√≠ficas del √≠tem
    kdsDestination: string | null;
    itemNameSnapshot: string;         // Snapshot del nombre del √≠tem (ej. en ES)
    itemDescriptionSnapshot: string | null; // Snapshot de la descripci√≥n (ej. en ES)
    status: OrderItemStatus;         // Estado inicial (ej. PENDING_KDS)
    // Datos para crear los OrderItemModifierOption asociados
    modifierOptionsToCreate: Prisma.OrderItemModifierOptionCreateManyOrderItemInput[];
}


// --- Estructuras para la Respuesta P√∫blica del Estado del Pedido ---

/**
 * Informaci√≥n de un √≠tem de pedido para la vista p√∫blica de estado.
 */
export interface PublicOrderItemStatusInfo {
    id: string;                     // ID del OrderItem
    menuItemName_es: string | null; // Snapshot del nombre en espa√±ol
    menuItemName_en: string | null; // Snapshot del nombre en ingl√©s (o el idioma secundario)
    quantity: number;
    status: OrderItemStatus;
}

/**
 * Informaci√≥n completa del estado de un pedido para la vista p√∫blica.
 */
export interface PublicOrderStatusInfo {
    orderId: string;
    orderNumber: string;
    orderStatus: OrderStatus;
    items: PublicOrderItemStatusInfo[];
    tableIdentifier?: string | null;
    orderNotes?: string | null;
    createdAt: Date;
    isBillRequested?: boolean; // Indica si el cliente/personal ya solicit√≥ la cuenta
    // Podr√≠as a√±adir m√°s campos si el cliente los necesita en esta vista,
    // como finalAmount, paymentMethodPreference, etc.
    // finalAmount?: Prisma.Decimal;
}


// --- DTOs que representan los payloads esperados desde el Frontend/Controlador ---
// Estos son los que se validar√≠an con class-validator en el controlador (order.dto.ts).
// Los replicamos aqu√≠ (o los importar√≠amos desde order.dto.ts) para claridad en los servicios.

/**
 * DTO para una opci√≥n de modificador seleccionada dentro de un √≠tem, tal como viene del frontend.
 */
export interface FrontendSelectedOrderModifierOptionDto {
    modifierOptionId: string;
}

/**
 * DTO para un √≠tem de pedido individual al crear un nuevo pedido, tal como viene del frontend.
 */
export interface FrontendCreateOrderItemDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: FrontendSelectedOrderModifierOptionDto[] | null;
}

/**
 * DTO principal para crear un nuevo pedido, tal como viene del frontend.
 */
export interface FrontendCreateOrderDto {
    tableIdentifier?: string | null;
    customerNotes?: string | null; // Notas generales del pedido
    customerId?: string | null;    // ID del cliente LCo (opcional)
    items: FrontendCreateOrderItemDto[];
    // businessId o businessSlug no vienen en el body para la creaci√≥n p√∫blica, van en la URL del endpoint.
}

/**
 * DTO para un √≠tem individual al a√±adir √≠tems a un pedido existente, tal como viene del frontend.
 */
export interface FrontendAddItemsOrderItemDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;                                       // Notas espec√≠ficas para este √≠tem
    selectedModifierOptions?: Array<{ modifierOptionId: string }>; // Consistente con CreateOrderItemDto
}

/**
 * DTO principal para a√±adir √≠tems a un pedido existente, tal como viene del frontend.
 */
export interface FrontendAddItemsToOrderDto {
    items: FrontendAddItemsOrderItemDto[];
    customerNotes?: string; // Notas generales para ESTA ADICI√ìN de √≠tems (podr√≠an concatenarse a las existentes)
}

/**
 * DTO para el payload opcional que el cliente puede enviar al solicitar la cuenta.
 */
export interface FrontendRequestBillClientPayloadDto {
  paymentPreference?: string | null; // Ej: "EFECTIVO", "TARJETA"
}

/**
 * DTO para el payload que el personal puede enviar al solicitar la cuenta (desde WaiterController).
 */
export interface FrontendRequestBillStaffPayloadDto {
  paymentPreference?: string | null;
  // Podr√≠a incluir m√°s campos si es necesario, como payAmountInput del Development Plan
}

/**
 * DTO para el payload que el personal env√≠a al marcar un pedido como pagado (desde WaiterController).
 */
export interface FrontendMarkOrderAsPaidPayloadDto {
  method?: string; // Ej: "EFECTIVO_CAJA", "TARJETA_VISA_XXXX"
  notes?: string | null; // Notas adicionales sobre el pago
  // Podr√≠a incluir amountPaid si se maneja cambio, etc.
}


// ====== [38] backend/src/modules/camarero/waiter.controller.ts ======
// backend/src/camarero/waiter.controller.ts
// Version 1.3.1 (Adjusted for waiter.service v1.3.0 and simplified markAsPaid response)

import { Request, Response, NextFunction } from 'express';
import { OrderItemStatus, Order, OrderStatus, Prisma, OrderItem } from '@prisma/client';

// Importar el servicio de camarero existente
import * as waiterService from './waiter.service'; // Asume que waiter.service.ts est√° en la misma carpeta
// Importar el OrderPaymentService para marcar como pagado
import { OrderPaymentService } from './public/order-payment.service';

// DTOs y tipos
import {
    MarkOrderItemServedPayloadDto,
    OrderItemStatusUpdateResponseDto,
} from './camarero.dto';
import { FrontendMarkOrderAsPaidPayloadDto, FrontendRequestBillStaffPayloadDto } from './public/order.types';

// Instanciar OrderPaymentService
const orderPaymentServiceInstance = new OrderPaymentService();

/**
 * Handler para GET /api/camarero/staff/ready-for-pickup
 */
export const getReadyForPickupItemsHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    if (!businessId) {
        console.error("[WaiterCtrl] Critical: businessId missing from req.user in getReadyForPickupItemsHandler.");
        return res.status(403).json({ message: "Identificador de negocio no encontrado en la sesi√≥n del usuario." });
    }
    console.log(`[WaiterCtrl] Request for ready-for-pickup items for business: ${businessId}`);
    try {
        const items = await waiterService.getReadyForPickupItems(businessId);
        res.status(200).json(items);
    } catch (error) {
        console.error(`[WaiterCtrl] Error getting ready-for-pickup items for business ${businessId}:`, error);
        next(error);
    }
};

/**
 * Handler para PATCH /api/camarero/staff/order-items/:orderItemId/status
 * Marca un OrderItem como SERVED.
 */
export const markOrderItemServedHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const waiterUserId = req.user?.id;
    const { orderItemId } = req.params;
    const payload: MarkOrderItemServedPayloadDto = req.body;

    if (!businessId || !waiterUserId) {
        console.error("[WaiterCtrl] Critical: businessId or waiterUserId missing for markOrderItemServedHandler.");
        return res.status(403).json({ message: "Informaci√≥n de autenticaci√≥n de personal incompleta." });
    }
    if (!orderItemId) {
        return res.status(400).json({ message: "Falta el ID del √≠tem de pedido (orderItemId) en la URL." });
    }
    if (!payload || payload.newStatus !== OrderItemStatus.SERVED) {
        return res.status(400).json({ message: "Payload inv√°lido. Se esperaba que 'newStatus' sea 'SERVED'." });
    }

    console.log(`[WaiterCtrl] Request to mark OrderItem ${orderItemId} as SERVED by waiter ${waiterUserId} for business ${businessId}.`);

    try {
        // Asumimos que waiterService.markOrderItemAsServed ahora devuelve { updatedOrderItem, finalOrderStatus }
        const result = await waiterService.markOrderItemAsServed(
            orderItemId,
            businessId,
            waiterUserId
        );

        const responseDto: OrderItemStatusUpdateResponseDto = {
            message: `√çtem '${result.updatedOrderItem.itemNameSnapshot || orderItemId}' marcado como ${OrderItemStatus.SERVED}.`,
            orderItemId: result.updatedOrderItem.id,
            newStatus: result.updatedOrderItem.status,
            orderStatus: result.finalOrderStatus, // Usar el estado del pedido devuelto por el servicio
        };
        res.status(200).json(responseDto);

    } catch (error: any) {
        console.error(`[WaiterCtrl] Error marking OrderItem ${orderItemId} as SERVED:`, error);
        if (error.message) {
            if (error.message.includes('no encontrado') || (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025')) {
                return res.status(404).json({ message: error.message });
            }
            if (error.message.includes('no est√° en estado \'READY\'') || error.message.includes('Transici√≥n de estado no permitida')) {
                return res.status(409).json({ message: `Conflicto de estado: ${error.message}` });
            }
        }
        next(error);
    }
};

/**
 * Handler para POST /api/camarero/staff/order/:orderId/request-bill
 */
export const requestBillByStaffHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const staffUserId = req.user?.id;
    const { orderId } = req.params;
    const payload: FrontendRequestBillStaffPayloadDto = req.body;

    if (!businessId || !staffUserId) {
        console.error("[WaiterCtrl] Critical: businessId or staffUserId missing for requestBillByStaffHandler.");
        return res.status(403).json({ message: "Informaci√≥n de autenticaci√≥n de personal incompleta." });
    }
    if (!orderId) {
        return res.status(400).json({ message: "Falta el ID del pedido (orderId) en la URL." });
    }

    console.log(`[WaiterCtrl] Staff ${staffUserId} requesting bill for order ${orderId}. Preference: ${payload.paymentPreference || 'N/A'}`);
    try {
        const paymentPreferenceForService = payload.paymentPreference ?? undefined;

        // Podr√≠amos decidir que waiterService.requestBillByStaff llame internamente a OrderPaymentService
        // o hacer la llamada a OrderPaymentService aqu√≠ directamente.
        // Por consistencia con markOrderAsPaid, si el servicio de pago centraliza, lo llamar√≠amos aqu√≠.
        // Por ahora, seguimos con la estructura donde WaiterService lo maneja.
        const updatedOrder: Order = await waiterService.requestBillByStaff(
            orderId,
            staffUserId,
            businessId,
            paymentPreferenceForService
        );
        res.status(200).json({
            message: `Cuenta solicitada para el pedido #${updatedOrder.orderNumber}. Estado: ${updatedOrder.status}.`,
            order: {
                id: updatedOrder.id,
                orderNumber: updatedOrder.orderNumber,
                status: updatedOrder.status,
                isBillRequested: updatedOrder.isBillRequested,
                paymentMethodPreference: updatedOrder.paymentMethodPreference,
            }
        });
    } catch (error: any) {
        console.error(`[WaiterCtrl] Error requesting bill for order ${orderId} by staff ${staffUserId}:`, error);
        if (error.message) {
            if (error.message.includes('no encontrado') || (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025')) {
                return res.status(404).json({ message: error.message });
            }
            if (error.message.includes('No se puede solicitar la cuenta') || error.message.includes('estado inv√°lido')) {
                return res.status(400).json({ message: error.message });
            }
            if (error.message.includes('no pertenece al negocio')) {
                return res.status(403).json({ message: error.message });
            }
        }
        next(error);
    }
};

/**
 * Handler para POST /api/camarero/staff/order/:orderId/mark-as-paid
 */
export const markOrderAsPaidHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    const staffUserId = req.user?.id;
    const { orderId } = req.params;
    const payloadFromFrontend: FrontendMarkOrderAsPaidPayloadDto = req.body;

    if (!businessId || !staffUserId) {
        console.error("[WaiterCtrl] Critical: businessId or staffUserId missing for markOrderAsPaidHandler.");
        return res.status(403).json({ message: "Informaci√≥n de autenticaci√≥n de personal incompleta." });
    }
    if (!orderId) {
        return res.status(400).json({ message: "Falta el ID del pedido (orderId) en la URL." });
    }

    const paymentDetailsForService: { method?: string; notes?: string } = {
        method: payloadFromFrontend.method,
        notes: payloadFromFrontend.notes ?? undefined,
    };

    console.log(`[WaiterCtrl] Staff ${staffUserId} marking order ${orderId} as PAID. Payment Details: ${JSON.stringify(paymentDetailsForService)}`);

    try {
        const updatedOrder: Order = await orderPaymentServiceInstance.markOrderAsPaid(
            orderId,
            staffUserId,
            businessId,
            paymentDetailsForService
        );

        // Respuesta simplificada. El frontend puede hacer un refetch de la lista de pedidos
        // o del estado de la mesa si necesita la info actualizada inmediatamente.
        res.status(200).json({
            message: `Pedido #${updatedOrder.orderNumber || orderId} marcado como PAGADO.`,
            order: { // Devolver la informaci√≥n esencial del pedido actualizado
                id: updatedOrder.id,
                orderNumber: updatedOrder.orderNumber,
                status: updatedOrder.status,
                paidAt: updatedOrder.paidAt,
                paymentMethodUsed: updatedOrder.paymentMethodUsed,
                tableId: updatedOrder.tableId, // Enviar tableId para que el frontend sepa si debe refetchear mesas
            }
        });

    } catch (error: any) {
        console.error(`[WaiterCtrl] Error marking order ${orderId} as PAID by staff ${staffUserId}:`, error);
        // El tipo de error de NestJS (error.name) podr√≠a no estar disponible si no se est√° ejecutando en un contexto NestJS puro
        // Usaremos instanceof para los errores de Prisma y mensajes para el resto
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             return res.status(404).json({ message: 'Pedido no encontrado.' });
        }
        if (error.message?.includes('no encontrado')) {
             return res.status(404).json({ message: error.message });
        }
        if (error.message?.includes('Solo se pueden marcar como pagados') || error.message?.includes('estado inv√°lido')) {
            return res.status(400).json({ message: error.message });
        }
        if (error.message?.includes('no pertenece al negocio')) {
            return res.status(403).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para GET /api/camarero/staff/orders
 */
export const getStaffOrdersHandler = async (req: Request, res: Response, next: NextFunction) => {
    const businessId = req.user?.businessId;
    if (!businessId) {
        console.error("[WaiterCtrl] Critical: businessId missing from req.user in getStaffOrdersHandler.");
        return res.status(403).json({ message: "Identificador de negocio no encontrado en la sesi√≥n del usuario." });
    }
    const statusQuery = req.query.status as string | string[] | undefined;
    let statusFilter: OrderStatus[] | undefined = undefined;
    if (statusQuery) {
        const statuses = Array.isArray(statusQuery) ? statusQuery : (typeof statusQuery === 'string' ? statusQuery.split(',') : []);
        statusFilter = statuses
            .map(s => s.trim().toUpperCase() as OrderStatus)
            .filter(s => Object.values(OrderStatus).includes(s));
        if (statusFilter.length === 0) {
            statusFilter = undefined;
        }
    }
    console.log(`[WaiterCtrl] Request for staff orders for business: ${businessId}. Filters: ${JSON.stringify({ status: statusFilter })}`);
    try {
        const orders = await waiterService.getOrdersForStaff(businessId, { status: statusFilter });
        res.status(200).json(orders);
    } catch (error: any) {
        console.error(`[WaiterCtrl] Error fetching staff orders for business ${businessId}:`, error);
        next(error);
    }
};


// ====== [39] backend/src/modules/camarero/waiter.service.ts ======
// backend/src/camarero/waiter.service.ts
// Version 1.3.1 (Corrected orderBy clause in getOrdersForStaff)

import {
    PrismaClient,
    OrderItem,
    OrderItemStatus,
    OrderStatus,
    Prisma,
    TableStatus,
    Order,
    OrderType,
    User, // Asegurarse de importar User si se usa en tipos
} from '@prisma/client';
import {
    ReadyPickupItemDto,
    WaiterSelectedModifierDto,
    WaiterOrderListItemDto
} from './camarero.dto';
import {
    NotFoundException,
    BadRequestException,
    ForbiddenException,
    Logger,
    InternalServerErrorException,
} from '@nestjs/common';

const prisma = new PrismaClient(); // Instancia de Prisma para este servicio
const logger = new Logger('WaiterService'); // Logger para este servicio

/**
 * Obtiene la lista de √≠tems de pedido que est√°n listos para ser recogidos por el personal de sala.
 * @param businessId - ID del negocio.
 * @returns Un array de ReadyPickupItemDto.
 */
export const getReadyForPickupItems = async (businessId: string): Promise<ReadyPickupItemDto[]> => {
    logger.log(`[WaiterService] Fetching items ready for pickup for business: ${businessId}`);
    try {
        const orderItemsFromDb = await prisma.orderItem.findMany({
            where: {
                status: OrderItemStatus.READY,
                order: {
                    businessId: businessId,
                    status: {
                        in: [
                            OrderStatus.IN_PROGRESS,
                            OrderStatus.PARTIALLY_READY,
                            OrderStatus.ALL_ITEMS_READY,
                        ],
                    },
                },
            },
            include: {
                order: {
                    include: {
                        table: { select: { identifier: true } },
                    },
                },
                selectedModifiers: {
                    select: {
                        optionNameSnapshot: true,
                        modifierOption: {
                            select: { name_en: true, name_es: true }
                        }
                    },
                },
            },
            orderBy: [
                { order: { createdAt: 'asc' } },
                { createdAt: 'asc' }
            ]
        });

        const readyItemsDto: ReadyPickupItemDto[] = orderItemsFromDb.map(item => {
            const selectedModifiersDto: WaiterSelectedModifierDto[] = item.selectedModifiers.map(sm => {
                return {
                    optionName_es: sm.optionNameSnapshot || sm.modifierOption?.name_es || null,
                    optionName_en: sm.modifierOption?.name_en || null,
                };
            });

            return {
                orderItemId: item.id,
                orderId: item.orderId,
                orderNumber: item.order.orderNumber,
                orderCreatedAt: item.order.createdAt,
                tableIdentifier: item.order.table?.identifier || null,
                itemNameSnapshot_es: item.itemNameSnapshot,
                itemNameSnapshot_en: null, // Ajustar si tienes snapshot_en
                quantity: item.quantity,
                itemNotes: item.notes,
                kdsDestination: item.kdsDestination,
                selectedModifiers: selectedModifiersDto,
                currentOrderItemStatus: item.status,
            };
        });

        logger.log(`[WaiterService] Found ${readyItemsDto.length} items ready for pickup for business ${businessId}.`);
        return readyItemsDto;

    } catch (error) {
        logger.error(`[WaiterService] Error fetching 'ready for pickup' items for business ${businessId}:`, error);
        throw new InternalServerErrorException('Error al obtener los √≠tems listos para servir desde la base de datos.');
    }
};

export interface MarkServedResult {
    updatedOrderItem: OrderItem;
    finalOrderStatus: OrderStatus;
}

export const markOrderItemAsServed = async (
    orderItemId: string,
    businessId: string,
    waiterUserId?: string
): Promise<MarkServedResult> => {
    logger.log(`[WaiterService] Attempting to mark OrderItem ${orderItemId} as SERVED by waiter ${waiterUserId || 'unknown'} for business ${businessId}.`);

    return prisma.$transaction(async (tx) => {
        const orderItem = await tx.orderItem.findFirst({
            where: {
                id: orderItemId,
                order: { businessId: businessId }
            },
            include: {
                order: {
                    select: { id: true, status: true }
                }
            }
        });

        if (!orderItem) {
            logger.warn(`[WaiterService TX] OrderItem '${orderItemId}' not found or not in business '${businessId}'.`);
            throw new NotFoundException(`√çtem de pedido con ID ${orderItemId} no encontrado o no pertenece a este negocio.`);
        }
        if (!orderItem.order) {
            logger.error(`[WaiterService TX] Critical: OrderItem '${orderItemId}' has no associated order.`);
            throw new InternalServerErrorException(`Error interno: El √≠tem de pedido ${orderItemId} no est√° asociado a ning√∫n pedido.`);
        }

        if (orderItem.status !== OrderItemStatus.READY) {
            logger.warn(`[WaiterService TX] OrderItem '${orderItemId}' is in status '${orderItem.status}', not 'READY'. Cannot mark as served.`);
            throw new BadRequestException(`El √≠tem de pedido '${orderItem.itemNameSnapshot || orderItemId}' no est√° en estado 'READY'. Estado actual: ${orderItem.status}. No se puede marcar como servido.`);
        }

        const dataToUpdateOrderItem: Prisma.OrderItemUpdateArgs['data'] = {
            status: OrderItemStatus.SERVED,
            servedAt: new Date(),
        };
        if (waiterUserId) {
            dataToUpdateOrderItem.servedById = waiterUserId;
        }

        const updatedOrderItem = await tx.orderItem.update({
            where: { id: orderItemId },
            data: dataToUpdateOrderItem,
        });
        logger.log(`[WaiterService TX] OrderItem ${orderItemId} marked as SERVED in DB.`);

        const orderId = orderItem.order.id;
        const allItemsInThisOrder = await tx.orderItem.findMany({
            where: { orderId: orderId },
            select: { status: true }
        });

        const activeItems = allItemsInThisOrder.filter(item => item.status !== OrderItemStatus.CANCELLED);
        let newOrderStatusForParent: OrderStatus = orderItem.order.status;

        if (activeItems.length > 0 && activeItems.every(item => item.status === OrderItemStatus.SERVED)) {
            if (
                orderItem.order.status !== OrderStatus.PAID &&
                orderItem.order.status !== OrderStatus.CANCELLED &&
                orderItem.order.status !== OrderStatus.COMPLETED
            ) {
                newOrderStatusForParent = OrderStatus.COMPLETED;
                await tx.order.update({
                    where: { id: orderId },
                    data: { status: newOrderStatusForParent }
                });
                logger.log(`[WaiterService TX] Order ${orderId} status updated to COMPLETED as all active items are SERVED.`);
            } else {
                 logger.log(`[WaiterService TX] Order ${orderId} already in final/completed state (${orderItem.order.status}). Not changing to COMPLETED.`);
            }
        } else if (activeItems.length === 0 && allItemsInThisOrder.length > 0) {
             if (orderItem.order.status !== OrderStatus.CANCELLED && orderItem.order.status !== OrderStatus.PAID) {
                newOrderStatusForParent = OrderStatus.CANCELLED;
                await tx.order.update({
                    where: { id: orderId },
                    data: { status: newOrderStatusForParent }
                });
                logger.log(`[WaiterService TX] Order ${orderId} status updated to CANCELLED as all items were cancelled.`);
            }
        } else {
            logger.log(`[WaiterService TX] Order ${orderId} still has items not SERVED or no active items. Order status remains ${newOrderStatusForParent}.`);
        }
        return { updatedOrderItem, finalOrderStatus: newOrderStatusForParent };
    });
};

export const requestBillByStaff = async (
    orderId: string,
    staffUserId: string,
    businessId: string,
    paymentPreference?: string | undefined
): Promise<Order> => {
    logger.log(`[WaiterService] Staff ${staffUserId} requesting bill for order ${orderId} in business ${businessId}. Preference: ${paymentPreference || 'N/A'}`);

    return prisma.$transaction(async (tx) => {
        const order = await tx.order.findUnique({
            where: { id: orderId },
            select: { id: true, status: true, businessId: true, tableId: true, orderNumber: true }
        });

        if (!order) {
            throw new NotFoundException(`Pedido con ID ${orderId} no encontrado.`);
        }
        if (order.businessId !== businessId) {
            throw new ForbiddenException("El pedido no pertenece al negocio del personal.");
        }

        const allowedStates: OrderStatus[] = [
            OrderStatus.RECEIVED, OrderStatus.IN_PROGRESS, OrderStatus.PARTIALLY_READY,
            OrderStatus.ALL_ITEMS_READY, OrderStatus.COMPLETED,
        ];
        if (!allowedStates.includes(order.status)) {
            throw new BadRequestException(`No se puede solicitar la cuenta para un pedido en estado '${order.status}'.`);
        }

        const updateData: Prisma.OrderUpdateInput = {
            status: OrderStatus.PENDING_PAYMENT,
            isBillRequested: true,
            ...(paymentPreference !== undefined && { paymentMethodPreference: paymentPreference }),
        };

        const updatedOrder = await tx.order.update({ where: { id: orderId }, data: updateData });
        logger.log(`[WaiterService TX] Bill requested by staff ${staffUserId} for order ${orderId}. Status set to PENDING_PAYMENT.`);

        if (order.tableId) {
            try {
                await tx.table.update({
                    where: { id: order.tableId },
                    data: { status: TableStatus.PENDING_PAYMENT_TABLE }
                });
                logger.log(`[WaiterService TX] Table ID '${order.tableId}' status updated to PENDING_PAYMENT_TABLE.`);
            } catch (tableError) {
                logger.error(`[WaiterService TX] Failed to update table status for table '${order.tableId}' on staff bill request. Continuing. Error:`, tableError);
            }
        }
        return updatedOrder;
    });
};

export const getOrdersForStaff = async (
    businessId: string,
    filters?: { status?: OrderStatus[] }
): Promise<WaiterOrderListItemDto[]> => {
    logger.log(`[WaiterService] Fetching orders for staff UI. Business: ${businessId}, Filters: ${JSON.stringify(filters)}`);

    const whereClause: Prisma.OrderWhereInput = {
        businessId: businessId,
    };

    if (filters?.status && filters.status.length > 0) {
        whereClause.status = { in: filters.status };
    } else {
        whereClause.status = {
            in: [
                OrderStatus.PENDING_PAYMENT, OrderStatus.COMPLETED,
                OrderStatus.ALL_ITEMS_READY, OrderStatus.PARTIALLY_READY,
                OrderStatus.IN_PROGRESS, OrderStatus.RECEIVED
            ]
        };
    }

    try {
        const ordersFromDb = await prisma.order.findMany({
            where: whereClause,
            select: {
                id: true,
                orderNumber: true,
                table: { select: { identifier: true } },
                status: true,
                finalAmount: true,
                totalAmount: true,
                items: {
                    where: { status: { not: OrderItemStatus.CANCELLED } },
                    select: { quantity: true }
                },
                customerLCo: { select: { name: true, email: true } },
                createdAt: true,
                isBillRequested: true,
                orderType: true,
            },
            // --- CORRECCI√ìN APLICADA ---
            orderBy: [
                { status: 'asc' },    // Primer criterio de ordenaci√≥n
                { createdAt: 'asc' }  // Segundo criterio de ordenaci√≥n
            ]
            // --- FIN CORRECCI√ìN ---
        });

        const orderListItems: WaiterOrderListItemDto[] = ordersFromDb.map(order => {
            const itemCount = order.items.reduce((sum, item) => sum + item.quantity, 0);
            let customerDisplayName: string | null = null;
            if (order.customerLCo) {
                customerDisplayName = order.customerLCo.name || order.customerLCo.email;
            }

            return {
                orderId: order.id,
                orderNumber: order.orderNumber,
                tableIdentifier: order.table?.identifier || null,
                status: order.status,
                finalAmount: (order.finalAmount ?? order.totalAmount).toNumber(),
                itemCount: itemCount,
                customerName: customerDisplayName,
                createdAt: order.createdAt,
                isBillRequested: order.isBillRequested,
                orderType: order.orderType as OrderType | null, // Casteo al enum local si es necesario
            };
        });

        logger.log(`[WaiterService] Found ${orderListItems.length} orders for staff UI for business ${businessId}.`);
        return orderListItems;

    } catch (error) {
        logger.error(`[WaiterService] Error fetching orders for staff UI (Business: ${businessId}):`, error);
        if (error instanceof Prisma.PrismaClientValidationError) {
            logger.error("[WaiterService] Prisma Client Validation Error details:", error.message);
            throw new InternalServerErrorException(`Error de validaci√≥n de Prisma al obtener pedidos: ${error.message}`);
        }
        throw new InternalServerErrorException('Error al obtener la lista de pedidos para el personal.');
    }
};

// (No se necesita exportar `prisma` si el controlador no lo usa directamente)


// ====== [40] backend/src/modules/loyalpyme/activity/activity.controller.ts ======
// filename: backend/src/activity/activity.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as activityService from './activity.service'; // Importar el servicio

/**
 * Handler para obtener el historial de actividad paginado del cliente autenticado.
 * GET / (montado bajo /api/customer/activity)
 */
export const getCustomerActivityHandler = async (req: Request, res: Response, next: NextFunction) => {
    // El userId viene de req.user a√±adido por authenticateToken
    const userId = req.user?.id;

    if (!userId) {
        // Esto no deber√≠a ocurrir si el middleware funciona, pero es una guarda
        return res.status(401).json({ message: 'Usuario no autenticado.' });
    }

    // Obtener par√°metros de paginaci√≥n de la query string, con valores por defecto
    const pageQuery = req.query.page as string | undefined;
    const limitQuery = req.query.limit as string | undefined;

    const page = parseInt(pageQuery || '1', 10);
    const limit = parseInt(limitQuery || '15', 10); // Default 15 items por p√°gina

    // Validar que sean n√∫meros v√°lidos
    if (isNaN(page) || page < 1) {
        return res.status(400).json({ message: 'Par√°metro "page" inv√°lido. Debe ser un n√∫mero mayor o igual a 1.' });
    }
    if (isNaN(limit) || limit < 1 || limit > 100) { // Limitar el m√°ximo por petici√≥n
        return res.status(400).json({ message: 'Par√°metro "limit" inv√°lido. Debe ser un n√∫mero entre 1 y 100.' });
    }

    console.log(`[Activity CTRL] Request received for user ${userId} activity. Page: ${page}, Limit: ${limit}`);

    try {
        const paginatedResult = await activityService.getCustomerActivityLog(userId, page, limit);
        res.status(200).json(paginatedResult);
    } catch (error) {
        // Pasar el error al manejador global de errores
        next(error);
    }
};


// ====== [41] backend/src/modules/loyalpyme/activity/activity.service.ts ======
// filename: backend/src/activity/activity.service.ts
import { PrismaClient, ActivityLog, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

// Tipo para la respuesta paginada
export interface PaginatedActivityLog {
    logs: Pick<ActivityLog, 'id' | 'type' | 'pointsChanged' | 'description' | 'createdAt'>[]; // Devolvemos solo campos necesarios
    totalPages: number;
    currentPage: number;
    totalItems: number;
}

/**
 * Obtiene el historial de actividad paginado para un usuario espec√≠fico.
 * @param userId ID del usuario.
 * @param page N√∫mero de p√°gina solicitada.
 * @param limit N√∫mero de items por p√°gina.
 * @returns Objeto con los logs paginados y metadatos de paginaci√≥n.
 */
export const getCustomerActivityLog = async (
    userId: string,
    page: number,
    limit: number
): Promise<PaginatedActivityLog> => {
    console.log(`[Activity SVC] Fetching activity log for user ${userId}, Page: ${page}, Limit: ${limit}`);

    const skip = (page - 1) * limit;

    try {
        // Usar transacci√≥n para obtener count y logs en una sola llamada a DB
        const [totalItems, logs] = await prisma.$transaction([
            prisma.activityLog.count({
                where: { userId: userId },
            }),
            prisma.activityLog.findMany({
                where: { userId: userId },
                select: { // Seleccionar solo los campos que necesita el frontend
                    id: true,
                    type: true,
                    pointsChanged: true,
                    description: true,
                    createdAt: true,
                },
                orderBy: {
                    createdAt: 'desc', // M√°s recientes primero
                },
                skip: skip,
                take: limit,
            }),
        ]);

        const totalPages = Math.ceil(totalItems / limit);
        console.log(`[Activity SVC] Found ${logs.length} logs on page ${page}. Total items: ${totalItems}, Total pages: ${totalPages}`);

        return {
            logs,
            totalPages,
            currentPage: page,
            totalItems,
        };

    } catch (error) {
        console.error(`[Activity SVC] Error fetching activity log for user ${userId}:`, error);
        // Podr√≠amos relanzar un error m√°s espec√≠fico si quisi√©ramos
        throw new Error('Error al obtener el historial de actividad desde la base de datos.');
    }
};


// ====== [42] backend/src/modules/loyalpyme/admin/admin-customer-bulk.controller.ts ======
// filename: backend/src/admin/admin-customer-bulk.controller.ts
// Version: 1.0.0 (Handlers extracted from admin-customer.controller, @ts-ignore removed, cleaned)

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client'; // Para tipos de error

// Importar solo los servicios necesarios para acciones masivas
import {
    bulkUpdateStatusForCustomers,
    bulkDeleteCustomers,
    bulkAdjustPointsForCustomers
} from './admin-customer-bulk.service'; // Ajustado a la nueva ubicaci√≥n del servicio

/**
 * Handler para actualizar estado activo/inactivo masivo.
 * PATCH /api/admin/customers/bulk-status
 */
export const bulkUpdateCustomerStatusHandler = async (req: Request, res: Response, next: NextFunction) => {
    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_BULK_CTRL] Critical: User or businessId missing in bulkUpdateCustomerStatusHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    const { customerIds, isActive } = req.body;
    console.log(`[ADM_CUST_BULK_CTRL] Request for bulk status update to ${isActive} for customers [${customerIds?.join(', ')}] by admin from business ${adminBusinessId}`);

    // Validaciones
    if (!adminBusinessId) { return res.status(403).json({ message: "Informaci√≥n de administrador no disponible." }); } // Doble check por si acaso
    if (!Array.isArray(customerIds) || customerIds.length === 0) { return res.status(400).json({ message: "Se requiere un array 'customerIds' con al menos un ID de cliente." }); }
    if (typeof isActive !== 'boolean') { return res.status(400).json({ message: "Se requiere el campo 'isActive' (true o false) para indicar el estado deseado." }); }
    if (!customerIds.every(id => typeof id === 'string')) { return res.status(400).json({ message: "Todos los elementos en 'customerIds' deben ser strings." }); }

    try {
        const result = await bulkUpdateStatusForCustomers(customerIds, adminBusinessId, isActive);
        res.status(200).json({ message: `Estado actualizado a ${isActive ? 'Activo' : 'Inactivo'} para ${result.count} cliente(s).`, count: result.count }); // Corregido: cliente(s)
    } catch (error) {
        console.error(`[ADM_CUST_BULK_CTRL] Failed bulk status update for customers [${customerIds.join(', ')}]:`, error);
        next(error);
    }
};

/**
 * Handler para eliminar m√∫ltiples clientes.
 * DELETE /api/admin/customers/bulk-delete
 */
export const bulkDeleteCustomersHandler = async (req: Request, res: Response, next: NextFunction) => {
     // --- FIX: Comprobaci√≥n expl√≠cita ---
     if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_BULK_CTRL] Critical: User or businessId missing in bulkDeleteCustomersHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    const { customerIds } = req.body; // Los IDs vienen en el body para DELETE masivo
    console.log(`[ADM_CUST_BULK_CTRL] Request for bulk delete for customers [${customerIds?.join(', ')}] by admin from business ${adminBusinessId}`);

    // Validaciones
    if (!adminBusinessId) { return res.status(403).json({ message: "Informaci√≥n de administrador no disponible." }); }
    if (!Array.isArray(customerIds) || customerIds.length === 0) { return res.status(400).json({ message: "Se requiere un array 'customerIds' con al menos un ID de cliente." }); }
    if (!customerIds.every(id => typeof id === 'string')) { return res.status(400).json({ message: "Todos los elementos en 'customerIds' deben ser strings." }); }

    try {
        const result = await bulkDeleteCustomers(customerIds, adminBusinessId);
        res.status(200).json({ message: `${result.count} cliente(s) eliminados correctamente.`, count: result.count }); // Corregido: cliente(s), correctamente
    } catch (error) {
        console.error(`[ADM_CUST_BULK_CTRL] Failed bulk delete for customers [${customerIds.join(', ')}]:`, error);
        // Si el servicio lanza un error espec√≠fico por FK, el manejador global lo capturar√°
        // pero podr√≠amos querer manejarlo aqu√≠ si el frontend necesita un c√≥digo de estado espec√≠fico (ej: 409 Conflict)
        if (error instanceof Error && error.message.includes('datos asociados')) {
             return res.status(409).json({ message: error.message }); // 409 Conflict
        }
        next(error);
    }
};

/**
 * Handler para ajustar los puntos de m√∫ltiples clientes.
 * POST /api/admin/customers/bulk-adjust-points
 */
export const bulkAdjustPointsHandler = async (req: Request, res: Response, next: NextFunction) => {
    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId) { // No necesitamos user.id aqu√≠ en el controller
        console.error("[ADM_CUST_BULK_CTRL] Critical: User or businessId missing in bulkAdjustPointsHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // const adminUserId = req.user.id; // Lo obtenemos pero no lo usamos activamente aqu√≠
    // --- FIN FIX ---

    const { customerIds, amount, reason } = req.body;
    // Log con menos info sensible
    console.log(`[ADM_CUST_BULK_CTRL] Request for bulk points adjustment by ${amount} for ${customerIds?.length} customers from business ${adminBusinessId}. Reason: ${reason || 'N/A'}`);

    // Validaciones
    if (!adminBusinessId) { return res.status(403).json({ message: "Informaci√≥n de administrador no disponible." }); }
    if (!Array.isArray(customerIds) || customerIds.length === 0) { return res.status(400).json({ message: "Se requiere un array 'customerIds' con al menos un ID de cliente." }); }
    if (typeof amount !== 'number' || amount === 0) { return res.status(400).json({ message: "La cantidad ('amount') debe ser un n√∫mero distinto de cero." }); }
    if (reason !== undefined && reason !== null && typeof reason !== 'string') { return res.status(400).json({ message: "La raz√≥n ('reason') debe ser un texto o nula/omitida." }); } // Corregido: raz√≥n
    if (!customerIds.every(id => typeof id === 'string')) { return res.status(400).json({ message: "Todos los elementos en 'customerIds' deben ser strings." }); }

    try {
        const result = await bulkAdjustPointsForCustomers( customerIds, adminBusinessId, amount, reason || null );
        const actionText = amount > 0 ? 'a√±adidos' : 'restados'; // Corregido: √±
        res.status(200).json({
            message: `${Math.abs(amount)} puntos ${actionText} correctamente para ${result.count} cliente(s).`, // Corregido: √±, cliente(s)
            count: result.count
        });
    } catch (error) {
        console.error(`[ADM_CUST_BULK_CTRL] Failed bulk points adjustment for customers [${customerIds?.join(', ')}]:`, error);
        next(error);
    }
};

// End of File: backend/src/admin/admin-customer-bulk.controller.ts


// ====== [43] backend/src/modules/loyalpyme/admin/admin-customer-bulk.service.ts ======
// filename: backend/src/admin/admin-customer-bulk.service.ts
// Version: 1.1.1 (Store reason or null in ActivityLog description for bulk adjustments)

import {
    PrismaClient, Prisma, UserRole,
    ActivityType // Aseg√∫rate que est√© importado
} from '@prisma/client';

const prisma = new PrismaClient();

// Tipos (sin cambios)
interface BatchPayload { count: number; }

// bulkUpdateStatusForCustomers (sin cambios)
export const bulkUpdateStatusForCustomers = async ( customerIds: string[], adminBusinessId: string, isActive: boolean ): Promise<BatchPayload> => {
    const action = isActive ? 'Activating' : 'Deactivating'; console.log(`[ADM_CUST_BULK_SVC] ${action} ${customerIds.length} customers for business ${adminBusinessId}`); try { const result = await prisma.user.updateMany({ where: { id: { in: customerIds, }, businessId: adminBusinessId, role: UserRole.CUSTOMER_FINAL }, data: { isActive: isActive }, }); console.log(`[ADM_CUST_BULK_SVC] Bulk status update successful. ${result.count} customers updated to isActive=${isActive}.`); return result; } catch (error) { console.error(`[ADM_CUST_BULK_SVC] Error during bulk status update for customers [${customerIds.join(', ')}] of business ${adminBusinessId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { throw new Error(`Error de base de datos durante la actualizaci√≥n masiva: ${error.message}`); } throw new Error('Error inesperado durante la actualizaci√≥n masiva de estado.'); }
};

// bulkDeleteCustomers (sin cambios)
export const bulkDeleteCustomers = async ( customerIds: string[], adminBusinessId: string ): Promise<BatchPayload> => {
    console.log(`[ADM_CUST_BULK_SVC] Deleting ${customerIds.length} customers for business ${adminBusinessId}`); try { const result = await prisma.user.deleteMany({ where: { id: { in: customerIds, }, businessId: adminBusinessId, role: UserRole.CUSTOMER_FINAL }, }); console.log(`[ADM_CUST_BULK_SVC] Bulk delete successful. ${result.count} customers deleted.`); return result; } catch (error) { console.error(`[ADM_CUST_BULK_SVC] Error during bulk delete for customers [${customerIds.join(', ')}] of business ${adminBusinessId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2003') { throw new Error(`No se pudieron eliminar todos los clientes porque tienen datos asociados (registros de puntos, regalos, etc.). C√≥digo: ${error.code}`); } throw new Error(`Error de base de datos durante el borrado masivo: ${error.message} (C√≥digo: ${error.code})`); } throw new Error('Error inesperado durante el borrado masivo de clientes.'); }
};


// --- bulkAdjustPointsForCustomers MODIFICADO ---
/**
 * Ajusta puntos masivamente y crea logs individuales guardando la raz√≥n (o null).
 */
export const bulkAdjustPointsForCustomers = async (
    customerIds: string[],
    adminBusinessId: string,
    amount: number,
    reason: string | null // La raz√≥n viene como argumento
): Promise<BatchPayload> => {
    const action = amount > 0 ? 'Adding' : 'Subtracting';
    console.log(`[ADM_CUST_BULK_SVC] ${action} ${Math.abs(amount)} points for ${customerIds.length} customers. Business: ${adminBusinessId}. Reason: ${reason || 'N/A'}`);

    if (amount === 0) { console.warn(`[ADM_CUST_BULK_SVC] Attempted bulk adjust points with amount 0. No action taken.`); return { count: 0 }; }

    const whereClause: Prisma.UserWhereInput = { id: { in: customerIds }, businessId: adminBusinessId, role: UserRole.CUSTOMER_FINAL };
    let updateResult: BatchPayload;

    try {
        // 1. Ejecutar la actualizaci√≥n masiva
        updateResult = await prisma.user.updateMany({ where: whereClause, data: { points: { increment: amount } }, });
        console.log(`[ADM_CUST_BULK_SVC] Bulk points update successful. ${updateResult.count} customers updated.`);
    } catch (error) {
        console.error(`[ADM_CUST_BULK_SVC] Error during bulk points update for customers [${customerIds.join(', ')}] of business ${adminBusinessId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { throw new Error(`Error de base de datos durante el ajuste masivo de puntos: ${error.message}`); } throw new Error('Error inesperado durante el ajuste masivo de puntos.');
    }

    // 2. Si se actualiz√≥ algo, intentar crear logs
    if (updateResult.count > 0) {
        try {
            // 2.1 Obtener IDs afectados
            const affectedUsers = await prisma.user.findMany({ where: whereClause, select: { id: true } });
            console.log(`[ADM_CUST_BULK_SVC] Found ${affectedUsers.length} affected user IDs to log.`);

            // 2.2 Crear datos para los logs (MODIFICACI√ìN en description)
            const logsToCreate: Prisma.ActivityLogCreateManyInput[] = affectedUsers.map(user => ({
                userId: user.id,
                businessId: adminBusinessId,
                type: ActivityType.POINTS_ADJUSTED_ADMIN,
                pointsChanged: amount,
                description: reason || null, // <-- GUARDA LA RAZ√ìN O NULL
                // No hay IDs relacionados
            }));

            // 2.3 Crear los logs
            if (logsToCreate.length > 0) {
                const logResult = await prisma.activityLog.createMany({ data: logsToCreate, skipDuplicates: true, });
                console.log(`[ADM_CUST_BULK_SVC] Successfully created ${logResult.count} activity logs for bulk adjustment.`);
            }
        } catch (logError) {
            console.error(`[ADM_CUST_BULK_SVC] WARNING: Failed to create some or all activity logs for bulk adjustment for business ${adminBusinessId}. Error:`, logError);
        }
    }

    // 3. Devolver resultado del updateMany
    return updateResult;
};
// --- FIN bulkAdjustPointsForCustomers ---

// End of File: backend/src/admin/admin-customer-bulk.service.ts


// ====== [44] backend/src/modules/loyalpyme/admin/admin-customer-individual.controller.ts ======
// filename: backend/src/admin/admin-customer-individual.controller.ts
// Version: 1.0.0 (Handlers extracted from admin-customer.controller, @ts-ignore removed, cleaned)

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client'; // Para tipos de error

// Importar solo los servicios necesarios para acciones individuales
import {
    getCustomerDetailsById,
    updateAdminNotesForCustomer,
    adjustPointsForCustomer,
    changeCustomerTier,
    assignRewardToCustomer,
    toggleFavoriteStatus,
    toggleActiveStatusForCustomer
} from './admin-customer-individual.service'; // Ajustado a la nueva ubicaci√≥n del servicio

/**
 * Handler para obtener los detalles completos de un cliente espec√≠fico.
 */
export const getCustomerDetailsHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;

    // --- FIX: Comprobaci√≥n expl√≠cita de req.user y req.user.businessId ---
    if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in getCustomerDetailsHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    console.log(`[ADM_CUST_IND_CTRL] Request to get details for customer ${customerId} by admin from business ${adminBusinessId}`);
    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }

    try {
        const customerDetails = await getCustomerDetailsById(customerId, adminBusinessId);
        if (!customerDetails) { return res.status(404).json({ message: "Cliente no encontrado o no pertenece a este negocio." }); }
        res.status(200).json(customerDetails);
    } catch (error) {
        console.error(`[ADM_CUST_IND_CTRL] Failed to get details for customer ${customerId}:`, error);
        // Pasar error al manejador global, excepto 404
        if (error instanceof Error && (error.message.includes('no encontrado') || error.message.includes('no pertenece'))) {
            return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para actualizar las notas de administrador de un cliente.
 */
export const updateCustomerNotesHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;
    const { notes } = req.body;

    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in updateCustomerNotesHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    console.log(`[ADM_CUST_IND_CTRL] Request to update notes for customer ${customerId} by admin from business ${adminBusinessId}`);
    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }
    // Permitir enviar 'notes' como null expl√≠citamente
    if (notes === undefined) { return res.status(400).json({ message: "Falta el campo 'notes' en el cuerpo de la petici√≥n (puede ser null)." }); }
    if (notes !== null && typeof notes !== 'string') { return res.status(400).json({ message: "El campo 'notes' debe ser un texto o nulo." }); }

    try {
        const updatedCustomer = await updateAdminNotesForCustomer(customerId, adminBusinessId, notes);
        res.status(200).json({ message: `Notas actualizadas correctamente para ${updatedCustomer.email}.` }); // Corregido: correctamente
    } catch (error) {
        console.error(`[ADM_CUST_IND_CTRL] Failed to update notes for customer ${customerId}:`, error);
         if (error instanceof Error && (error.message.includes('no encontrado') || error.message.includes('no pertenece'))) {
             return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para ajustar puntos.
 */
export const adjustCustomerPoints = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;
    const { amount, reason } = req.body;

    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId || !req.user.id) { // Necesitamos id y businessId
        console.error("[ADM_CUST_IND_CTRL] Critical: User, businessId or userId missing in adjustCustomerPoints.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminUserId = req.user.id; // Se usaba impl√≠citamente antes, ahora expl√≠cito
    const adminBusinessId = req.user.businessId;
     // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }
    if (typeof amount !== 'number' || amount === 0) { return res.status(400).json({ message: "La cantidad ('amount') debe ser un n√∫mero distinto de cero." }); }

    try {
        const updatedCustomer = await adjustPointsForCustomer( customerId, adminBusinessId, amount, reason );
        res.status(200).json({ message: `Puntos ajustados correctamente para ${updatedCustomer.email}.`, customer: { id: updatedCustomer.id, points: updatedCustomer.points } }); // Corregido: correctamente
    }
    catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to adjust points for customer ${customerId}:`, error); next(error); }
};

/**
 * Handler para cambiar tier.
 */
export const changeCustomerTierHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;
    const { tierId } = req.body;

     // --- FIX: Comprobaci√≥n expl√≠cita ---
     if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in changeCustomerTierHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }
    if (tierId === undefined) { return res.status(400).json({ message: "Falta el ID del nivel ('tierId') en el cuerpo de la petici√≥n (puede ser nulo)." }); }
    if (tierId !== null && typeof tierId !== 'string') { return res.status(400).json({ message: "El ID del nivel ('tierId') debe ser un texto o nulo." }); }

    try {
        const updatedCustomer = await changeCustomerTier( customerId, adminBusinessId, tierId );
        res.status(200).json({ message: `Nivel cambiado correctamente para ${updatedCustomer.email}.`, customer: { id: updatedCustomer.id, currentTierId: updatedCustomer.currentTierId, tierAchievedAt: updatedCustomer.tierAchievedAt } }); // Corregido: correctamente
    }
    catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to change tier for customer ${customerId} to ${tierId}:`, error); next(error); }
};

/**
 * Handler para asignar recompensa.
 */
export const assignRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;
    const { rewardId } = req.body;

    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId || !req.user.id) { // Necesitamos id y businessId
        console.error("[ADM_CUST_IND_CTRL] Critical: User, businessId or userId missing in assignRewardHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminUserId = req.user.id;
    const adminBusinessId = req.user.businessId;
     // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }
    if (!rewardId || typeof rewardId !== 'string') { return res.status(400).json({ message: "Falta el ID de la recompensa ('rewardId') o no es v√°lido." }); // Corregido: v√°lido
    }

    try {
        const grantedReward = await assignRewardToCustomer( customerId, adminBusinessId, rewardId, adminUserId );
        res.status(201).json({ message: `Recompensa asignada correctamente al cliente.`, grantedRewardId: grantedReward.id }); // Corregido: correctamente
    }
    catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to assign reward ${rewardId} to customer ${customerId}:`, error); next(error); }
};

/**
 * Handler para toggle favorito.
 */
export const toggleFavoriteHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;

    // --- FIX: Comprobaci√≥n expl√≠cita ---
    if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in toggleFavoriteHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }

    try {
        const updatedCustomer = await toggleFavoriteStatus( customerId, adminBusinessId );
        res.status(200).json({ message: `Estado de favorito cambiado para ${updatedCustomer.email}. Nuevo estado: ${updatedCustomer.isFavorite}`, customer: { id: updatedCustomer.id, isFavorite: updatedCustomer.isFavorite } });
    }
    catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to toggle favorite status for customer ${customerId}:`, error); next(error); }
};

/**
 * Handler para toggle activo.
 */
export const toggleActiveStatusHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { customerId } = req.params;

     // --- FIX: Comprobaci√≥n expl√≠cita ---
     if (!req.user || !req.user.businessId) {
        console.error("[ADM_CUST_IND_CTRL] Critical: User or businessId missing in toggleActiveStatusHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId;
    // --- FIN FIX ---

    if (!customerId) { return res.status(400).json({ message: "Falta el ID del cliente." }); }

    try {
        const updatedCustomer = await toggleActiveStatusForCustomer(customerId, adminBusinessId);
        res.status(200).json({ message: `Estado cambiado para ${updatedCustomer.email}. Nuevo estado: ${updatedCustomer.isActive ? 'Activo' : 'Inactivo'}`, customer: { id: updatedCustomer.id, isActive: updatedCustomer.isActive } });
    } catch (error) { console.error(`[ADM_CUST_IND_CTRL] Failed to toggle active status for customer ${customerId}:`, error); next(error); }
};


// End of File: backend/src/admin/admin-customer-individual.controller.ts


// ====== [45] backend/src/modules/loyalpyme/admin/admin-customer-individual.service.ts ======
// filename: backend/src/admin/admin-customer-individual.service.ts
// Version: 1.2.0 (Use i18n reward fields name_es/name_en)

import {
    PrismaClient, Prisma, UserRole, User, GrantedReward,
    ActivityType, Reward // <-- Reward debe estar aqu√≠ aunque usemos Pick
} from '@prisma/client';
const prisma = new PrismaClient();

// Tipos y Selectores (sin cambios)
const customerDetailsSelector = Prisma.validator<Prisma.UserSelect>()({ id: true, email: true, name: true, points: true, createdAt: true, isActive: true, isFavorite: true, tierAchievedAt: true, adminNotes: true, businessId: true, role: true, currentTier: { select: { id: true, name: true, level: true, description: true } } });
export type CustomerDetails = Prisma.UserGetPayload<{ select: typeof customerDetailsSelector }>;
type FavoriteStatusUpdate = Pick<User, 'id' | 'email' | 'isFavorite'>;
type ActiveStatusUpdate = Pick<User, 'id' | 'email' | 'isActive'>;
type NotesUpdate = Pick<User, 'id' | 'email' | 'adminNotes'>;

// getCustomerDetailsById (sin cambios)
export const getCustomerDetailsById = async (customerId: string, adminBusinessId: string): Promise<CustomerDetails | null> => {
     console.log(`[ADM_CUST_IND_SVC] Getting details for customer ${customerId} by admin from business ${adminBusinessId}`); try { const customerDetails = await prisma.user.findUnique({ where: { id: customerId, businessId: adminBusinessId, role: UserRole.CUSTOMER_FINAL }, select: customerDetailsSelector }); if (!customerDetails) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } console.log(`[ADM_CUST_IND_SVC] Details found for customer ${customerId}`); return customerDetails; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error getting details for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { throw new Error(`Error de base de datos al obtener detalles del cliente: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al obtener los detalles del cliente.'); }
};

// updateAdminNotesForCustomer (sin cambios)
export const updateAdminNotesForCustomer = async ( customerId: string, adminBusinessId: string, notes: string | null ): Promise<NotesUpdate> => {
     console.log(`[ADM_CUST_IND_SVC] Updating admin notes for customer ${customerId} by admin from business ${adminBusinessId}`); try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { adminNotes: notes }, select: { id: true, email: true, adminNotes: true } }); console.log(`[ADM_CUST_IND_SVC] Admin notes updated successfully for customer ${customer.email} (${customerId})`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error updating admin notes for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error(`No se encontr√≥ el cliente especificado al intentar actualizar las notas.`); } throw new Error(`Error de base de datos al actualizar las notas: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al actualizar las notas del administrador.'); }
};

// adjustPointsForCustomer (sin cambios respecto a versi√≥n anterior)
export const adjustPointsForCustomer = async ( customerId: string, adminBusinessId: string, amount: number, reason?: string | null ): Promise<User> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to adjust points for customer ${customerId} by ${amount}. Reason: ${reason || 'N/A'}. Admin Business: ${adminBusinessId}`); if (amount === 0) { throw new Error("La cantidad de puntos a ajustar no puede ser cero."); } try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId }, select: { businessId: true, id: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado.`); } if (customer.businessId !== adminBusinessId) { throw new Error("No tienes permiso para modificar este cliente."); } const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { points: { increment: amount } } }); console.log(`[ADM_CUST_IND_SVC - TX] Points adjusted successfully for customer ${userAfterUpdate.email} (${customerId}). New balance potentially: ${userAfterUpdate.points}`); await tx.activityLog.create({ data: { userId: customerId, businessId: adminBusinessId, type: ActivityType.POINTS_ADJUSTED_ADMIN, pointsChanged: amount, description: reason || null } }); console.log(`[ADM_CUST_IND_SVC - TX] ActivityLog created for admin points adjustment for user ${customerId}.`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error adjusting points for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error(`No se encontr√≥ el cliente especificado para actualizar.`); } throw new Error(`Error de base de datos al ajustar puntos: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al ajustar los puntos.'); }
};

// changeCustomerTier (sin cambios)
export const changeCustomerTier = async ( customerId: string, adminBusinessId: string, tierId: string | null ): Promise<User> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to change tier for customer ${customerId} to tier ${tierId ?? 'NULL'}. Admin Business: ${adminBusinessId}`); try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } if (tierId !== null) { const tierExists = await tx.tier.findUnique({ where: { id: tierId, businessId: adminBusinessId }, select: { id: true } }); if (!tierExists) { throw new Error(`El nivel seleccionado (ID: ${tierId}) no es v√°lido o no pertenece a tu negocio.`); } } const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { currentTierId: tierId, tierAchievedAt: tierId ? new Date() : null } }); console.log(`[ADM_CUST_IND_SVC] Tier changed successfully for customer ${userAfterUpdate.email} (${customerId}) to ${tierId ?? 'NULL'}`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error changing tier for customer ${customerId} to ${tierId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { throw new Error(`Error de base de datos al cambiar nivel: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al cambiar el nivel del cliente.'); }
};

// --- assignRewardToCustomer MODIFICADO ---
/**
 * Asigna una recompensa como "regalo" a un cliente.
 */
export const assignRewardToCustomer = async (
    customerId: string,
    adminBusinessId: string,
    rewardId: string,
    adminUserId: string
): Promise<GrantedReward> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to assign reward ${rewardId} to customer ${customerId} by admin ${adminUserId} from business ${adminBusinessId}`);
     try {
        const grantedReward = await prisma.$transaction(async (tx) => {
            const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, email: true } });
            if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); }

            // --- MODIFICADO: Seleccionar name_es y name_en en lugar de name ---
            const reward = await tx.reward.findUnique({
                where: { id: rewardId, businessId: adminBusinessId },
                select: {
                    id: true,
                    isActive: true,
                    name_es: true, // Seleccionar nombre ES
                    name_en: true  // Seleccionar nombre EN
                }
            });
            // --- FIN MODIFICADO ---

            if (!reward) { throw new Error(`Recompensa con ID ${rewardId} no encontrada o no pertenece a tu negocio.`); }
            if (!reward.isActive) {
                // --- MODIFICADO: Usar name_es o name_en en el mensaje de error ---
                const rewardDisplayName = reward.name_es || reward.name_en || `ID ${rewardId}`;
                throw new Error(`La recompensa "${rewardDisplayName}" no est√° activa y no puede ser asignada.`);
                 // --- FIN MODIFICADO ---
            }

            const newGrantedReward = await tx.grantedReward.create({
                data: { userId: customerId, rewardId: rewardId, businessId: adminBusinessId, assignedById: adminUserId, status: 'PENDING', }
            });

            // --- MODIFICADO: Usar name_es o name_en en el log ---
            const rewardLogName = reward.name_es || reward.name_en || `ID ${rewardId}`;
            console.log(`[ADM_CUST_IND_SVC - TX] Reward ${rewardLogName} (${rewardId}) assigned successfully to customer ${customer.email} (${customerId}). GrantedReward ID: ${newGrantedReward.id}`);
            // --- FIN MODIFICADO ---

            return newGrantedReward;
        });
        return grantedReward;
    } catch (error) {
        console.error(`[ADM_CUST_IND_SVC] Error assigning reward ${rewardId} to customer ${customerId}:`, error);
        // --- MODIFICADO: Usar Prisma.PrismaClientKnownRequestError para chequear error ---
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            // No necesitamos chequear P2002 aqu√≠ espec√≠ficamente, un error gen√©rico est√° bien
            throw new Error(`Error de base de datos al asignar recompensa: ${error.message}`);
        }
        // --- FIN MODIFICADO ---
        if (error instanceof Error) { throw error; }
        throw new Error('Error inesperado al asignar la recompensa.');
    }
};
// --- FIN assignRewardToCustomer ---

// toggleFavoriteStatus (sin cambios)
export const toggleFavoriteStatus = async ( customerId: string, adminBusinessId: string ): Promise<FavoriteStatusUpdate> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to toggle favorite status for customer ${customerId} by admin from business ${adminBusinessId}`); try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, isFavorite: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } const newFavoriteStatus = !customer.isFavorite; const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { isFavorite: newFavoriteStatus }, select: { id: true, email: true, isFavorite: true } }); console.log(`[ADM_CUST_IND_SVC] Favorite status for customer ${customer.email} (${customerId}) toggled to ${newFavoriteStatus}`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error toggling favorite status for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error(`No se encontr√≥ el cliente especificado al intentar actualizar.`); } throw new Error(`Error de base de datos al cambiar estado de favorito: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al cambiar el estado de favorito.'); }
};

// toggleActiveStatusForCustomer (sin cambios)
export const toggleActiveStatusForCustomer = async ( customerId: string, adminBusinessId: string ): Promise<ActiveStatusUpdate> => {
     console.log(`[ADM_CUST_IND_SVC] Attempting to toggle active status for customer ${customerId} by admin from business ${adminBusinessId}`); try { const updatedUser = await prisma.$transaction(async (tx) => { const customer = await tx.user.findUnique({ where: { id: customerId, businessId: adminBusinessId }, select: { id: true, isActive: true, email: true } }); if (!customer) { throw new Error(`Cliente con ID ${customerId} no encontrado o no pertenece a tu negocio.`); } const newActiveStatus = !customer.isActive; const userAfterUpdate = await tx.user.update({ where: { id: customerId }, data: { isActive: newActiveStatus }, select: { id: true, email: true, isActive: true } }); console.log(`[ADM_CUST_IND_SVC] Active status for customer ${customer.email} (${customerId}) toggled to ${newActiveStatus}`); return userAfterUpdate; }); return updatedUser; } catch (error) { console.error(`[ADM_CUST_IND_SVC] Error toggling active status for customer ${customerId}:`, error); if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error(`No se encontr√≥ el cliente especificado al intentar actualizar.`); } throw new Error(`Error de base de datos al cambiar estado activo: ${error.message}`); } if (error instanceof Error) { throw error; } throw new Error('Error inesperado al cambiar el estado activo del cliente.'); }
};

// End of File: backend/src/admin/admin-customer-individual.service.ts


// ====== [46] backend/src/modules/loyalpyme/admin/admin-customer-list.controller.ts ======
// filename: backend/src/admin/admin-customer-list.controller.ts
// Version: 1.0.0 (Handler extracted from admin-customer.controller, @ts-ignore removed)

import { Request, Response, NextFunction } from 'express';

// Importar s√≥lo el servicio necesario
import { getCustomersForBusiness } from './admin-customer-list.service'; // Ajustado a la nueva ubicaci√≥n del servicio

// Tipos locales para este controlador (podr√≠an moverse a un DTO o types si se complejizan)
type SortDirection = 'asc' | 'desc';
interface ControllerGetCustomersOptions {
    page?: number;
    limit?: number;
    sortBy?: string;
    sortDir?: SortDirection;
    filters?: {
        search?: string;
        isFavorite?: boolean;
        isActive?: boolean;
        tierId?: string;
    }
}

/**
 * Handler para que el Admin obtenga la lista PAGINADA, FILTRADA y ORDENADA de clientes.
 * GET /api/admin/customers
 */
export const getAdminCustomers = async (req: Request, res: Response, next: NextFunction) => {
    console.log('[ADM_CUST_LIST_CTRL] Entering getAdminCustomers handler...');

    // --- FIX: Comprobaci√≥n expl√≠cita de req.user y req.user.businessId ---
    if (!req.user || !req.user.businessId) {
        // Este error no deber√≠a ocurrir si authenticateToken funciona, pero es una guarda segura.
        console.error("[ADM_CUST_LIST_CTRL] Critical: User or businessId missing after authenticateToken.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const adminBusinessId = req.user.businessId; // Ahora podemos acceder de forma segura
    console.log(`[ADM_CUST_LIST_CTRL] Admin businessId: ${adminBusinessId}`);
    // --- FIN FIX ---

    // Leer par√°metros de query (sin cambios)
    const page = parseInt(req.query.page as string || '1', 10);
    const limit = parseInt(req.query.limit as string || '10', 10);
    const sortBy = req.query.sortBy as string || 'createdAt';
    const sortDirInput = req.query.sortDir as string;
    const sortDir: SortDirection = sortDirInput === 'asc' ? 'asc' : 'desc';
    const search = req.query.search as string | undefined;
    const isActiveParam = req.query.isActive as string | undefined;
    const isFavoriteParam = req.query.isFavorite as string | undefined;
    const tierIdParam = req.query.tierId as string | undefined;

    // Construir objeto de filtros (sin cambios)
    const filters: ControllerGetCustomersOptions['filters'] = {};
    if (search?.trim()) filters.search = search.trim();
    if (isActiveParam !== undefined) filters.isActive = isActiveParam === 'true';
    if (isFavoriteParam !== undefined) filters.isFavorite = isFavoriteParam === 'true';
    if (tierIdParam?.trim()) filters.tierId = tierIdParam.trim();

    // Construir objeto de opciones (sin cambios)
    const options: ControllerGetCustomersOptions = {
        page: isNaN(page) || page < 1 ? 1 : page,
        limit: isNaN(limit) || limit < 1 ? 10 : limit,
        sortBy: sortBy,
        sortDir: sortDir,
        filters: filters
    };

    console.log(`[ADM_CUST_LIST_CTRL] Parsed options being sent to service:`, options);

    try {
        // Llamar al servicio (sin cambios)
        const result = await getCustomersForBusiness(adminBusinessId, options);
        console.log(`[ADM_CUST_LIST_CTRL] Service call returned. Result has ${result?.items?.length ?? 'N/A'} items. Total items: ${result?.totalItems ?? 'N/A'}`);
        res.status(200).json(result);
    } catch (error) {
        console.error("[ADM_CUST_LIST_CTRL] *** ERROR caught in getAdminCustomers handler:", error);
        next(error); // Pasar al manejador de errores global
    }
};

// End of File: backend/src/admin/admin-customer-list.controller.ts


// ====== [47] backend/src/modules/loyalpyme/admin/admin-customer-list.service.ts ======
// filename: backend/src/admin/admin-customer-list.service.ts
// Version: 1.0.0 (Extracted from admin-customer.service.ts and cleaned)

import { PrismaClient, Prisma, UserRole } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos y Selectores (Copiados del original, necesarios para esta funci√≥n) ---
interface GetCustomersOptions {
    page?: number;
    limit?: number;
    sortBy?: string;
    sortDir?: 'asc' | 'desc';
    filters?: {
        search?: string;
        isFavorite?: boolean;
        isActive?: boolean;
        tierId?: string;
    }
}

const customerListItemSelector = Prisma.validator<Prisma.UserSelect>()({
    id: true, name: true, email: true, points: true, createdAt: true, isActive: true, isFavorite: true,
    currentTier: { select: { name: true, id: true, level: true } }
});
type CustomerListItem = Prisma.UserGetPayload<{ select: typeof customerListItemSelector }>;
// --- Fin Tipos y Selectores ---


/**
 * Obtiene una lista paginada, filtrada y ordenada de clientes para un negocio espec√≠fico.
 */
export const getCustomersForBusiness = async (
    businessId: string,
    options: GetCustomersOptions = {}
): Promise<{ items: CustomerListItem[], totalPages: number, currentPage: number, totalItems: number }> => {
    const { page = 1, limit = 10, sortBy = 'createdAt', sortDir = 'desc', filters = {} } = options;
    // Log inicial con todos los par√°metros (√∫til para debug)
    console.log(`[ADM_CUST_LIST_SVC] getCustomersForBusiness - Fetching: businessId=${businessId}, Page=${page}, Limit=${limit}, SortBy=${sortBy}, SortDir=${sortDir}, Filters=`, filters);
    const allowedSortByFields = ['name', 'email', 'points', 'createdAt', 'isActive', 'isFavorite', 'currentTier.level'];
    const safeSortBy = allowedSortByFields.includes(sortBy) ? sortBy : 'createdAt';
    const safeSortDir = sortDir === 'asc' ? 'asc' : 'desc';
    const skip = (page - 1) * limit;

    try {
        // Construcci√≥n de whereClause con todos los filtros
        const whereClause: Prisma.UserWhereInput = {
            businessId: businessId,
            role: UserRole.CUSTOMER_FINAL
        };

        // Filtro de B√∫squeda (Name/Email)
        if (filters.search && filters.search.trim() !== '') {
            const searchTerm = filters.search.trim();
            whereClause.OR = [
                { name: { contains: searchTerm, mode: 'insensitive' } },
                { email: { contains: searchTerm, mode: 'insensitive' } }
            ];
        }

        // Filtro Favorito (isFavorite)
        if (filters.isFavorite !== undefined) {
            whereClause.isFavorite = filters.isFavorite;
        }

        // Filtro Estado (isActive)
        if (filters.isActive !== undefined) {
            whereClause.isActive = filters.isActive;
        }

        // Filtro Nivel (tierId)
        if (filters.tierId && filters.tierId.trim() !== '') {
             if (filters.tierId === 'NONE') { // Manejar expl√≠citamente "Sin Nivel"
                whereClause.currentTierId = null;
             } else {
                whereClause.currentTierId = filters.tierId;
             }
        }

        // Ordenaci√≥n (OrderBy)
        let orderByClause: Prisma.UserOrderByWithRelationInput | Prisma.UserOrderByWithRelationInput[];
        if (safeSortBy === 'currentTier.level') {
            orderByClause = { currentTier: { level: safeSortDir } };
        } else {
            orderByClause = { [safeSortBy]: safeSortDir };
        }

        const selectClause = customerListItemSelector;
        // Log de cl√°usulas finales (√∫til para debug)
        console.log('[ADM_CUST_LIST_SVC] getCustomersForBusiness - Final Clauses:', { where: whereClause, orderBy: orderByClause });

        // Ejecutar Consultas (COUNT y FINDMANY) en transacci√≥n
        const [totalItems, customers] = await prisma.$transaction([
            prisma.user.count({ where: whereClause }),
            prisma.user.findMany({
                where: whereClause,
                select: selectClause,
                orderBy: orderByClause,
                skip: skip,
                take: limit,
            })
        ]);

        console.log(`[ADM_CUST_LIST_SVC] getCustomersForBusiness - Found ${customers.length} customers on page ${page}. Total items matching filters: ${totalItems}`);
        const totalPages = Math.ceil(totalItems / limit);
        console.log(`[ADM_CUST_LIST_SVC] getCustomersForBusiness - Calculation done. Total pages: ${totalPages}`);

        return { items: customers, totalPages: totalPages, currentPage: page, totalItems: totalItems };

    } catch (error) {
        console.error(`[ADM_CUST_LIST_SVC] *** ERROR in getCustomersForBusiness for business ${businessId}:`, error);
        console.error(`[ADM_CUST_LIST_SVC] Options causing error:`, options);
        throw new Error('Error al obtener la lista de clientes desde la base de datos.');
    }
};

// End of File: backend/src/admin/admin-customer-list.service.ts


// ====== [48] backend/src/modules/loyalpyme/admin/admin-stats.controller.ts ======
// filename: backend/src/admin/admin-stats.controller.ts
// Version: 1.0.0

import { Request, Response, NextFunction } from 'express';
// Importamos la funci√≥n del servicio que acabamos de crear
import { getOverviewStats, AdminOverviewStatsData } from './admin-stats.service';

/**
 * Handler para obtener las estad√≠sticas del overview para el dashboard del admin.
 * GET /api/admin/stats/overview
 */
export const handleGetOverviewStats = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  // El middleware 'authenticateToken' ya deber√≠a haber a√±adido req.user
  // El middleware 'checkRole' ya deber√≠a haber verificado que es BUSINESS_ADMIN
  const businessId = req.user?.businessId;

  console.log(`[AdminStatsController] Solicitud de overview stats para businessId: ${businessId}`);

  // Comprobaci√≥n de seguridad adicional (aunque el middleware deber√≠a cubrirlo)
  if (!businessId) {
    console.warn('[AdminStatsController] No se encontr√≥ businessId en req.user. Acceso denegado.');
    // Usamos 403 Forbidden ya que el rol es correcto pero falta asociaci√≥n clave
    res.status(403).json({ message: 'El usuario administrador no est√° asociado a ning√∫n negocio.' });
    return; 
  }

  try {
    // Llamamos a la funci√≥n del servicio para obtener los datos
    const stats: AdminOverviewStatsData = await getOverviewStats(businessId);

    // Enviamos la respuesta exitosa con los datos
    res.status(200).json(stats);
    console.log(`[AdminStatsController] Stats enviadas correctamente para businessId: ${businessId}`);

  } catch (error) {
    // Si el servicio lanza un error, lo pasamos al manejador de errores global
    console.error(`[AdminStatsController] Error al obtener stats para business ${businessId}:`, error);
    next(error); // Pasamos el error al siguiente middleware (manejador de errores global)
  }
};

// Podr√≠an a√±adirse aqu√≠ m√°s handlers para otras estad√≠sticas si fueran necesarias.

// End of file: backend/src/admin/admin-stats.controller.ts


// ====== [49] backend/src/modules/loyalpyme/admin/admin-stats.service.ts ======
// filename: backend/src/admin/admin-stats.service.ts
// Version: 1.2.1 (Count points-based redemptions from ActivityLog)

import { PrismaClient, UserRole, QrCodeStatus, Prisma, ActivityType } from '@prisma/client';
import { startOfDay, endOfDay, subDays } from 'date-fns';

const prisma = new PrismaClient();

export interface AdminOverviewStatsData {
    totalActiveCustomers: number;
    newCustomersLast7Days: number;
    newCustomersPrevious7Days: number;
    pointsIssuedLast7Days: number;
    pointsIssuedPrevious7Days: number;
    rewardsRedeemedLast7Days: number;
    rewardsRedeemedPrevious7Days: number;
}

// Helper Functions (sin cambios respecto a tu versi√≥n anterior que funcionaba parcialmente)
async function _getTotalActiveCustomers(businessId: string): Promise<number> {
    return prisma.user.count({
        where: { businessId, isActive: true, role: UserRole.CUSTOMER_FINAL }
    });
}

async function _getNewCustomersCount(businessId: string, startDate: Date, endDate: Date): Promise<number> {
    return prisma.user.count({
        where: { businessId, role: UserRole.CUSTOMER_FINAL, createdAt: { gte: startDate, lte: endDate } }
    });
}

async function _getPointsIssuedSum(businessId: string, startDate: Date, endDate: Date): Promise<number> {
    const result = await prisma.qrCode.aggregate({
        _sum: { pointsEarned: true },
        where: { businessId, status: QrCodeStatus.COMPLETED, completedAt: { gte: startDate, lte: endDate } }
    });
    return result._sum.pointsEarned ?? 0;
}

// --- FUNCI√ìN MODIFICADA PARA CONTAR TODOS LOS CANJES ---
async function _getRewardsRedeemedCount(businessId: string, startDate: Date, endDate: Date): Promise<number> {
    let giftedRedeemedCount = 0;
    let pointsRedeemedCount = 0;

    try {
        // Contar regalos canjeados (como estaba antes)
        giftedRedeemedCount = await prisma.grantedReward.count({
            where: { businessId, status: 'REDEEMED', redeemedAt: { gte: startDate, lte: endDate } }
        });
    } catch (error) {
        console.error(`[AdminStatsService] Error counting gifted redeemed rewards:`, error);
        // Continuar para intentar contar los otros canjes, pero loguear el error
    }

    try {
        // Contar recompensas canjeadas por puntos (usando ActivityLog)
        pointsRedeemedCount = await prisma.activityLog.count({
            where: {
                businessId,
                type: ActivityType.POINTS_REDEEMED_REWARD, // Usar el tipo de actividad correcto
                createdAt: { gte: startDate, lte: endDate } // Usar createdAt del log
            }
        });
    } catch (error) {
        console.error(`[AdminStatsService] Error counting points redeemed rewards:`, error);
        // Continuar, pero loguear el error
    }
    
    // Log m√°s seguro para depuraci√≥n
    const startDateStr = startDate ? startDate.toISOString() : 'N/A';
    const endDateStr = endDate ? endDate.toISOString() : 'N/A';
    console.log(`[AdminStatsService DEBUG] Period: ${startDateStr} to ${endDateStr}. Gifted redeemed: ${giftedRedeemedCount}, Points redeemed: ${pointsRedeemedCount}`);
    
    return giftedRedeemedCount + pointsRedeemedCount;
}
// --- FIN FUNCI√ìN MODIFICADA ---


export const getOverviewStats = async (businessId: string): Promise<AdminOverviewStatsData> => {
    console.log(`[AdminStatsService] Calculating overview stats for businessId: ${businessId}`);

    try {
        const now = new Date();
        // Definici√≥n precisa de los rangos de fechas
        const startOfLast7Days = startOfDay(subDays(now, 6)); // Incluye hoy y los 6 d√≠as anteriores
        const endOfLast7Days = endOfDay(now);                 // Hasta el final del d√≠a de hoy

        const startOfPrevious7Days = startOfDay(subDays(now, 13)); // Empieza hace 13 d√≠as
        const endOfPrevious7Days = endOfDay(subDays(now, 7));   // Termina al final del d√≠a hace 7 d√≠as

        console.log(`[AdminStatsService DEBUG] Date Ranges - Last 7: ${startOfLast7Days.toISOString()} - ${endOfLast7Days.toISOString()}`);
        console.log(`[AdminStatsService DEBUG] Date Ranges - Prev 7: ${startOfPrevious7Days.toISOString()} - ${endOfPrevious7Days.toISOString()}`);

        const [
            totalActiveCustomers,
            newCustomersLast7Days,
            pointsIssuedLast7Days,
            rewardsRedeemedLast7Days, // Usar√° la funci√≥n modificada
            newCustomersPrevious7Days,
            pointsIssuedPrevious7Days,
            rewardsRedeemedPrevious7Days, // Usar√° la funci√≥n modificada
        ] = await Promise.all([
            _getTotalActiveCustomers(businessId),
            _getNewCustomersCount(businessId, startOfLast7Days, endOfLast7Days),
            _getPointsIssuedSum(businessId, startOfLast7Days, endOfLast7Days),
            _getRewardsRedeemedCount(businessId, startOfLast7Days, endOfLast7Days),
            _getNewCustomersCount(businessId, startOfPrevious7Days, endOfPrevious7Days),
            _getPointsIssuedSum(businessId, startOfPrevious7Days, endOfPrevious7Days),
            _getRewardsRedeemedCount(businessId, startOfPrevious7Days, endOfPrevious7Days),
        ]);

        const result = {
            totalActiveCustomers,
            newCustomersLast7Days,
            newCustomersPrevious7Days,
            pointsIssuedLast7Days,
            pointsIssuedPrevious7Days,
            rewardsRedeemedLast7Days,
            rewardsRedeemedPrevious7Days,
        };

        console.log(`[AdminStatsService] Stats calculated successfully for ${businessId}:`, result);
        return result;

    } catch (error) {
        console.error(`[AdminStatsService] CRITICAL Error calculating overview stats for business ${businessId}:`, error);
        // Es importante que el error se propague para que el controlador lo maneje
        throw new Error('Error cr√≠tico al obtener las estad√≠sticas del dashboard.');
    }
};


// ====== [50] backend/src/modules/loyalpyme/customer/customer.controller.ts ======
// filename: backend/src/customer/customer.controller.ts
// Version: 2.2.0 (Add handler for customer to get business config)

import { Request, Response, NextFunction } from 'express';

// Importar funciones desde el servicio de cliente
import {
    findActiveRewardsForCustomer,
    getPendingGrantedRewards,
    redeemGrantedReward,
    // --- NUEVO: Importar futura funci√≥n de servicio ---
    getCustomerFacingBusinessConfig // A√∫n no existe, se crear√° en customer.service
    // --- FIN NUEVO ---
} from './customer.service';

// Importar TierService para el handler de tiers del cliente
import * as TierService from '../tiers/tiers.service';


/**
 * Handler para que el cliente obtenga las recompensas activas de su negocio.
 * GET /api/customer/rewards
 */
export const getCustomerRewardsHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId || !req.user.id) {
        console.error('[CUST_CTRL] Error: User context (id or businessId) missing from request.');
        return res.status(401).json({ message: 'Informaci√≥n de usuario o negocio no encontrada en la sesi√≥n.' });
    }
    const businessId = req.user.businessId;
    const userId = req.user.id;
    console.log(`[CUST_CTRL] User ${userId} requesting rewards for business ${businessId}`);
    try {
        const rewards = await findActiveRewardsForCustomer(businessId);
        res.status(200).json(rewards);
    } catch (error) {
        console.error(`[CUST_CTRL] Error fetching rewards for business ${businessId}:`, error);
        next(error);
    }
};

/**
 * Handler para que el cliente obtenga sus regalos pendientes.
 * GET /api/customer/granted-rewards
 */
export const getPendingGrantedRewardsHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.id) {
        console.error('[CUST_CTRL] Error: userId missing from req.user for granted rewards request.');
        return res.status(401).json({ message: 'Informaci√≥n de usuario no encontrada en la sesi√≥n.' });
    }
    const userId = req.user.id;
    const userEmail = req.user.email;
    console.log(`[CUST_CTRL] User ${userId} (${userEmail || 'N/A'}) requesting pending granted rewards.`);
    try {
        const grantedRewards = await getPendingGrantedRewards(userId);
        res.status(200).json(grantedRewards);
    }
    catch (error) {
        console.error(`[CUST_CTRL] Failed to fetch pending granted rewards for user ${userId}:`, error);
        next(error);
    }
};

/**
 * Handler para que el cliente canjee un regalo espec√≠fico.
 * POST /api/customer/granted-rewards/:grantedRewardId/redeem
 */
export const redeemGrantedRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.id) {
        console.error('[CUST_CTRL] Error: userId missing from req.user for redeem request.');
        return res.status(401).json({ message: 'Informaci√≥n de usuario no encontrada en la sesi√≥n.' });
    }
    const userId = req.user.id;
    const { grantedRewardId } = req.params;
    console.log(`[CUST_CTRL] User ${userId} attempting to redeem granted reward ID: ${grantedRewardId}`);
    if (!grantedRewardId) { return res.status(400).json({ message: 'Falta el ID del regalo otorgado en la URL.' }); }
    try {
        const redeemedGrant = await redeemGrantedReward(userId, grantedRewardId);
        res.status(200).json({ message: 'Regalo canjeado con √©xito.', grantedRewardId: redeemedGrant.id, rewardId: redeemedGrant.rewardId, redeemedAt: redeemedGrant.redeemedAt });
    }
    catch (error) {
        console.error(`[CUST_CTRL] Failed to redeem granted reward ${grantedRewardId} for user ${userId}:`, error);
        if (error instanceof Error && (error.message.includes('no te pertenece') || error.message.includes('no encontrado'))) {
            return res.status(403).json({ message: error.message });
        }
        if (error instanceof Error && error.message.includes('ya fue canjeado')) {
            return res.status(409).json({ message: error.message });
        }
        next(error);
    }
};


/**
 * Handler para que el cliente obtenga los Tiers disponibles en su programa.
 * GET /api/customer/tiers
 */
export const getCustomerTiersHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId || !req.user.id) {
        console.error('[CUST_CTRL] Error: User context (id or businessId) missing in getCustomerTiersHandler.');
        return res.status(401).json({ message: 'Informaci√≥n de usuario o negocio no encontrada en la sesi√≥n.' });
    }
    const businessId = req.user.businessId;
    const userId = req.user.id;
    console.log(`[CUST_CTRL] User ${userId} requesting available tiers for business ${businessId}.`);
    try {
        const tiers = await TierService.findTiersByBusiness(businessId, true);
        res.status(200).json(tiers);
    } catch (error: any) {
        console.error(`[CUST_CTRL] Error getting tiers for customer of business ${businessId}:`, error);
        next(error);
    }
};

// --- NUEVO HANDLER ---
/**
 * Handler para que el cliente obtenga la configuraci√≥n relevante de su negocio.
 * GET /api/customer/business-config
 */
export const getCustomerBusinessConfigHandler = async (req: Request, res: Response, next: NextFunction) => {
    // El middleware authenticateToken ya verific√≥ el token y a√±adi√≥ req.user
    // El middleware checkRole ya verific√≥ que es CUSTOMER_FINAL
    if (!req.user || !req.user.businessId) {
        // Doble check por si acaso o si la info no se carg√≥ bien
        console.error('[CUST_CTRL] Error: businessId missing from req.user for business-config request.');
        return res.status(401).json({ message: 'Informaci√≥n de negocio no encontrada en la sesi√≥n.' });
    }
    const businessId = req.user.businessId;
    const userId = req.user.id; // √ötil para logs

    console.log(`[CUST_CTRL] User ${userId} requesting business config for business ${businessId}.`);

    try {
        // Llamar a la nueva funci√≥n del servicio (que crearemos a continuaci√≥n)
        const config = await getCustomerFacingBusinessConfig(businessId);

        if (!config) {
            // Esto podr√≠a pasar si el negocio asociado al usuario ya no existe, por ejemplo
            console.warn(`[CUST_CTRL] Business config not found for businessId: ${businessId}`);
            return res.status(404).json({ message: 'No se encontr√≥ la configuraci√≥n para el negocio asociado.' });
        }

        // Devolver solo la configuraci√≥n relevante para el cliente
        res.status(200).json(config);

    } catch (error) {
        console.error(`[CUST_CTRL] Error getting business config for user ${userId}, business ${businessId}:`, error);
        next(error); // Pasar al manejador de errores global
    }
};
// --- FIN NUEVO HANDLER ---


// End of File: backend/src/customer/customer.controller.ts


// ====== [51] backend/src/modules/loyalpyme/customer/customer.service.ts ======
// filename: backend/src/customer/customer.service.ts
// Version: 2.3.2 (Use i18n reward fields name_es/name_en)

import {
    PrismaClient,
    Reward,
    Prisma,
    User,
    GrantedReward,
    Business,
    TierCalculationBasis,
    ActivityType
} from '@prisma/client';

const prisma = new PrismaClient();

// Tipo CustomerBusinessConfig (sin cambios)
export type CustomerBusinessConfig = Pick<Business, 'tierCalculationBasis'> | null;

// --- findActiveRewardsForCustomer ACTUALIZADO ---
/**
 * Encuentra recompensas activas para el cliente, seleccionando campos i18n.
 */
export const findActiveRewardsForCustomer = async ( businessId: string ): Promise<Reward[]> => { // Devuelve Reward completo
  console.log( `[CUST_SVC] Finding active rewards for customer view for business: ${businessId}` );
  try {
    // Aunque antes no usaba select, lo a√±adimos para ser expl√≠citos
    // y asegurar que obtenemos los campos necesarios, incluidos los nuevos
    const rewards = await prisma.reward.findMany({
        where: { businessId: businessId, isActive: true, },
        select: {
            id: true,
            name_es: true, // Seleccionar campos nuevos
            name_en: true, // Seleccionar campos nuevos
            description_es: true,
            description_en: true,
            pointsCost: true,
            isActive: true,
            imageUrl: true,
            businessId: true, // Incluir si es necesario para alg√∫n tipo
            createdAt: true,
            updatedAt: true
        },
        orderBy: { pointsCost: 'asc', },
    });
    console.log( `[CUST_SVC] Found ${rewards.length} active rewards for business ${businessId}` );
    console.log('[DEBUG findActiveRewardsForCustomer] Rewards found:', rewards);
    // El tipo de retorno sigue siendo Reward[] porque select * devuelve el tipo Reward
    // Si quisi√©ramos un tipo m√°s espec√≠fico, lo ajustar√≠amos aqu√≠
    return rewards;
  } catch (error) {
    console.error( `[CUST_SVC] Error fetching active rewards for business ${businessId}:`, error );
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        throw new Error(`Error de base de datos al buscar recompensas: ${error.message}`);
    }
    throw new Error('Error inesperado al buscar recompensas activas.');
  }
};
// --- FIN findActiveRewardsForCustomer ---


// getPendingGrantedRewards (MODIFICADO para seleccionar name_es/en)
export const getPendingGrantedRewards = async (userId: string): Promise<GrantedReward[]> => {
    console.log(`[CUST_SVC] Fetching pending granted rewards for user ${userId}`);
    try {
        const grantedRewards = await prisma.grantedReward.findMany({
            where: { userId: userId, status: 'PENDING' },
            include: {
                reward: {
                    select: { // Seleccionar campos i18n
                        id: true,
                        name_es: true, // <-- Seleccionar nuevo campo
                        name_en: true, // <-- Seleccionar nuevo campo
                        description_es: true, // <-- Opcional: seleccionar si se necesita
                        description_en: true, // <-- Opcional: seleccionar si se necesita
                        imageUrl: true
                    }
                },
                assignedBy: { select: { name: true, email: true } },
                business: { select: { name: true } } // No necesitamos ID aqu√≠
            },
            orderBy: { assignedAt: 'desc' }
        });
        console.log(`[CUST_SVC] Found ${grantedRewards.length} pending granted rewards for user ${userId}`);
        console.log('[DEBUG getPendingGrantedRewards] Granted rewards found:', JSON.stringify(grantedRewards, null, 2));
        // El tipo GrantedReward[] devuelto ahora tendr√° la estructura interna de reward actualizada
        return grantedRewards;
    } catch (error) {
        console.error(`[CUST_SVC] Error fetching pending granted rewards for user ${userId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
             throw new Error(`Error de base de datos al buscar recompensas otorgadas: ${error.message}`);
        }
        throw new Error('Error inesperado al buscar recompensas otorgadas.');
    }
};


// --- redeemGrantedReward MODIFICADO ---
export const redeemGrantedReward = async ( userId: string, grantedRewardId: string ): Promise<GrantedReward> => {
    console.log(`[CUST_SVC] User ${userId} attempting to redeem granted reward ${grantedRewardId}`);
    try {
        const updatedGrantedReward = await prisma.$transaction(async (tx) => {
            // 1. Encontrar el GrantedReward y verificar estado y pertenencia
            //    Incluimos reward con sus nuevos campos de nombre y el businessId
            const grantedReward = await tx.grantedReward.findUnique({
                where: { id: grantedRewardId },
                include: {
                    // Incluimos la relaci√≥n reward completa para acceder a sus campos
                    reward: {
                        select: { // Seleccionar expl√≠citamente lo necesario
                            id: true,
                            name_es: true,
                            name_en: true
                        }
                    },
                    business: { select: { id: true } } // Necesario para el businessId del log
                }
            });

            if (!grantedReward) { throw new Error(`Regalo con ID ${grantedRewardId} no encontrado.`); }
            // Verificar que las relaciones necesarias existen
            if (!grantedReward.business?.id) { console.error(`[CUST_SVC] Critical: GrantedReward ${grantedRewardId} missing business relation!`); throw new Error(`Error interno: El regalo no est√° asociado a un negocio.`); }
            if (!grantedReward.reward?.id) { console.error(`[CUST_SVC] Critical: GrantedReward ${grantedRewardId} missing reward relation!`); throw new Error(`Error interno: El regalo no est√° asociado a una recompensa.`); }


            if (grantedReward.userId !== userId) { console.warn(`[CUST_SVC] Unauthorized attempt by user ${userId} to redeem granted reward ${grantedRewardId} belonging to user ${grantedReward.userId}`); throw new Error("Este regalo no te pertenece."); }
            if (grantedReward.status !== 'PENDING') {
                 // Usar los nuevos campos de nombre para el mensaje de error
                 const rewardDisplayName = grantedReward.reward.name_es || grantedReward.reward.name_en || `ID ${grantedReward.rewardId}`;
                throw new Error(`Este regalo (${rewardDisplayName}) ya fue canjeado o no es v√°lido (Estado: ${grantedReward.status}).`);
            }

            // 2. Actualizar el estado del GrantedReward
            const redeemed = await tx.grantedReward.update({
                where: { id: grantedRewardId, userId: userId, status: 'PENDING' },
                data: { status: 'REDEEMED', redeemedAt: new Date() }
            });

            // 3. Crear Entrada en ActivityLog
            // Usar los nuevos campos de nombre para la descripci√≥n
            const logDescription = grantedReward.reward.name_es || grantedReward.reward.name_en || null;
            await tx.activityLog.create({
                data: {
                    userId: userId,
                    businessId: grantedReward.business.id, // Usar el ID del negocio incluido
                    type: ActivityType.GIFT_REDEEMED,
                    pointsChanged: null,
                    description: logDescription, // Guardar nombre ES o EN o null
                    relatedGrantedRewardId: grantedRewardId
                }
            });

            console.log(`[CUST_SVC] Granted reward ${grantedRewardId} (${redeemed.rewardId}) successfully redeemed by user ${userId}. Activity logged.`);
            return redeemed;
        });
        return updatedGrantedReward;
    } catch (error) {
        console.error(`[CUST_SVC] Error redeeming granted reward ${grantedRewardId} for user ${userId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError) { if (error.code === 'P2025') { throw new Error("El regalo no se encontr√≥ o ya no estaba pendiente al intentar canjearlo."); } throw new Error(`Error de base de datos al canjear el regalo: ${error.message}`); }
        if (error instanceof Error) { throw error; }
        throw new Error('Error inesperado al canjear el regalo.');
    }
};
// --- FIN redeemGrantedReward ---

// getCustomerFacingBusinessConfig (sin cambios)
export const getCustomerFacingBusinessConfig = async (businessId: string): Promise<CustomerBusinessConfig> => { /* ... (sin cambios) ... */ console.log(`[CUST_SVC] Fetching customer-facing config for business: ${businessId}`); try { const config = await prisma.business.findUnique({ where: { id: businessId }, select: { tierCalculationBasis: true } }); if (!config) { console.warn(`[CUST_SVC] Business not found when fetching config: ${businessId}`); return null; } return { tierCalculationBasis: config.tierCalculationBasis ?? null }; } catch (error) { console.error(`[CUST_SVC] Error fetching customer-facing config for business ${businessId}:`, error); throw new Error('Error al obtener la configuraci√≥n del negocio.'); } };

// End of File: backend/src/customer/customer.service.ts


// ====== [52] backend/src/modules/loyalpyme/points/points.controller.ts ======
// filename: backend/src/points/points.controller.ts
// Version: 1.3.0 (Handle updated return value from validateQrCode service)

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client';
// --- MODIFICACI√ìN: Importar tambi√©n ValidateQrResult ---
import { generateQrCodeData, validateQrCode, redeemReward, ValidateQrResult } from './points.service';
// --- FIN MODIFICACI√ìN ---

// DTOs (sin cambios)
export interface GenerateQrDto {
    amount: number;
    ticketNumber: string;
}
export interface ValidateQrDto {
    qrToken: string;
}

/**
 * Handles the request to generate QR code data for a points transaction.
 * POST /api/points/generate-qr
 */
export const generateQrHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId || !req.user.role) {
        console.error("[POINTS CTRL] Critical: User context missing in generateQrHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const businessId = req.user.businessId;
    const role = req.user.role;

    if (role !== 'BUSINESS_ADMIN') {
        return res.status(403).json({ message: 'Acceso denegado. Solo administradores pueden generar c√≥digos QR.' });
    }

    const { amount, ticketNumber }: GenerateQrDto = req.body;
    if (amount === undefined || typeof amount !== 'number' || amount <= 0) {
         return res.status(400).json({ message: 'Transaction amount must be a positive number.' });
    }
    if (!ticketNumber || typeof ticketNumber !== 'string' || ticketNumber.trim() === '') {
         return res.status(400).json({ message: 'Ticket number is required.' });
    }

    try {
        const qrData = await generateQrCodeData(businessId, amount, ticketNumber.trim());
        res.status(201).json(qrData);
    } catch (error: unknown) {
        if (error instanceof Error) {
             return res.status(400).json({ message: error.message });
        }
        console.error('Server error in generateQrHandler (unexpected):', error);
        next(new Error('Error del servidor al generar c√≥digo QR.'));
    }
};


/**
 * Handles the request to validate a QR token and assign points to the customer.
 * POST /api/points/validate-qr
 */
export const validateQrHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.id || !req.user.role) {
        console.error("[POINTS CTRL] Critical: User context missing in validateQrHandler.");
        return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
    }
    const customerUserId = req.user.id;
    const role = req.user.role;

    if (role !== 'CUSTOMER_FINAL') {
         console.warn(`User ${customerUserId} with role ${role} attempted to validate QR.`);
         return res.status(403).json({ message: 'Acceso denegado. Solo cuentas de cliente pueden validar c√≥digos QR.' });
    }

    const { qrToken }: ValidateQrDto = req.body;
    if (!qrToken) {
         return res.status(400).json({ message: 'Se requiere el token QR.' });
    }

    try {
        // --- MODIFICACI√ìN: Capturar el objeto ValidateQrResult completo ---
        const result: ValidateQrResult = await validateQrCode(qrToken, customerUserId);
        // --- FIN MODIFICACI√ìN ---

        // --- MODIFICACI√ìN: Devolver el objeto updatedUser en la respuesta ---
        res.status(200).json({
            message: 'C√≥digo QR validado con √©xito. Puntos asignados.',
            pointsEarned: result.pointsEarned,
            user: result.updatedUser // Devolver los datos actualizados del usuario
        });
        // --- FIN MODIFICACI√ìN ---

    } catch (error: unknown) {
         if (error instanceof Error) {
             console.error('Error in validateQrHandler (service error):', error.message);
             return res.status(400).json({ message: error.message });
         }
         console.error('Server error in validateQrHandler (unexpected):', error);
         next(new Error('Ocurri√≥ un error interno durante la validaci√≥n del QR.'));
    }
};


/**
 * Handles the request to redeem a specific reward using customer points.
 * POST /api/points/redeem-reward/:rewardId
 */
export const redeemRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.id || !req.user.role) {
       console.error("[POINTS CTRL] Critical: User context missing in redeemRewardHandler.");
       return res.status(401).json({ message: "Informaci√≥n de autenticaci√≥n no encontrada." });
   }
   const userId = req.user.id;
   const role = req.user.role;
    const rewardId = req.params.rewardId;

    console.log(`[REDEEM CTRL] Handling request for user ${userId}, reward ${rewardId}`);

    if (role !== 'CUSTOMER_FINAL') {
        console.warn(`[REDEEM CTRL] Access denied for user ${userId || 'unknown'} with role ${role}.`);
        return res.status(403).json({ message: 'Acceso denegado. Solo cuentas de cliente autenticadas pueden canjear recompensas.' });
    }
    if (!rewardId) {
        console.error('[REDEEM CTRL] Reward ID missing from request parameters.');
        return res.status(400).json({ message: 'Se requiere el ID de la recompensa.' });
    }

    try {
        console.log(`[REDEEM CTRL] Calling redeemReward service for user ${userId} and reward ${rewardId}...`);
        const result = await redeemReward(userId, rewardId);
        console.log(`[REDEEM CTRL] Service call successful for user ${userId}, reward ${rewardId}.`);
        res.status(200).json(result);
    } catch (error: unknown) {
        console.error(`[REDEEM CTRL - ERROR] Error redeeming reward for user ${userId}, reward ${rewardId}:`, error);
        if (error instanceof Error) {
            return res.status(400).json({ message: error.message });
        }
        next(new Error('Error interno del servidor durante el canje de recompensa.'));
    }
};

// End of File: backend/src/points/points.controller.ts


// ====== [53] backend/src/modules/loyalpyme/points/points.service.ts ======
// backend/src/points/points.service.ts
import {
    PrismaClient,
    User,
    Reward,
    QrCode,
    Business, // Aseg√∫rate que Business est√° importado si lo usas directamente en tipos
    QrCodeStatus,
    UserRole,
    Prisma,
    TierBenefit,
    TierCalculationBasis,
    // Tier, // Tier no se usa directamente en este archivo
    // TierDowngradePolicy, // No se usa directamente
    ActivityType
} from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';
import { addMinutes, isAfter } from 'date-fns';
import { updateUserTier } from '../tiers/tier-logic.service';

const prisma = new PrismaClient();
const QR_EXPIRATION_MINUTES = 30; // O lee de config si es din√°mico por negocio

// Tipos y Interfaces
interface RedeemResult {
    message: string;
    newPointsBalance: number;
}

// Tipo para el resultado de QR validado, incluyendo datos del usuario actualizados
export interface ValidateQrResult {
    pointsEarned: number;
    updatedUser: { // Estructura devuelta al frontend
        id: string;
        points: number;
        totalSpend: number; // Asegurar que este campo se actualiza y devuelve
        totalVisits: number; // Asegurar que este campo se actualiza y devuelve
        currentTierId: string | null;
        currentTierName: string | null; // Nombre del tier
    };
}


// Tipos internos para helpers
type ValidQrCode = QrCode & {
    business: Pick<Business, 'id' | 'pointsPerEuro' | 'tierSystemEnabled' | 'tierCalculationBasis'>; // Ajustado
    ticketNumber: string; // Asegurar que no sea null
};

type ValidCustomer = User & {
    currentTier: ({ benefits: TierBenefit[] } & { id: string; name: string }) | null;
    businessId: string; // <--- Aseguramos que aqu√≠ businessId NO es null
};


// ==============================================
// HELPER FUNCTIONS for validateQrCode (Internal)
// ==============================================

const _findAndValidateQrCodeRecord = async (qrToken: string, now: Date): Promise<ValidQrCode> => {
    const qrCode = await prisma.qrCode.findUnique({
        where: { token: qrToken },
        include: {
            business: { // Seleccionar solo lo necesario de business
                select: { id: true, pointsPerEuro: true, tierSystemEnabled: true, tierCalculationBasis: true }
            }
        }
    });

    if (!qrCode) { throw new Error('C√≥digo QR inv√°lido.'); }
    if (qrCode.status !== QrCodeStatus.PENDING) {
        if (qrCode.status === QrCodeStatus.COMPLETED) throw new Error('El c√≥digo QR ya ha sido utilizado.');
        if (qrCode.status === QrCodeStatus.EXPIRED) throw new Error('El c√≥digo QR ha expirado.');
        throw new Error('El c√≥digo QR no est√° disponible para canjear.');
    }
    if (isAfter(now, qrCode.expiresAt)) {
        try {
            await prisma.qrCode.update({ where: { id: qrCode.id }, data: { status: QrCodeStatus.EXPIRED } });
            console.log(`[Points SVC Helper] QR code ${qrToken} marked as EXPIRED.`);
        } catch (updateError) {
            console.error(`[Points SVC Helper] Failed to update QR status to EXPIRED for token ${qrToken}:`, updateError);
        }
        throw new Error('El c√≥digo QR ha expirado.');
    }
    if (!qrCode.business) {
        console.error(`[Points SVC Helper] QR code ${qrCode.id} has no associated business!`);
        throw new Error('Error interno: El QR no est√° asociado a un negocio.');
    }
    if (qrCode.ticketNumber === null) { // Aunque el schema lo hace no-nulo, una verificaci√≥n extra no da√±a
        console.error(`[Points SVC Helper] QR code ${qrCode.id} has null ticketNumber!`);
        throw new Error('Error interno: Falta n√∫mero de ticket en QR.');
    }
    return qrCode as ValidQrCode; // Casteo seguro despu√©s de las validaciones
};

const _findAndValidateCustomerForQr = async (userId: string, qrCodeBusinessId: string): Promise<ValidCustomer> => {
    const customer = await prisma.user.findUnique({
        where: { id: userId },
        include: { currentTier: { include: { benefits: { where: { isActive: true } } } } }
    });

    if (!customer || customer.role !== UserRole.CUSTOMER_FINAL) {
        throw new Error('Solo las cuentas de cliente pueden canjear c√≥digos QR.');
    }
    if (!customer.businessId) { // <--- A√ëADIDA ESTA VALIDACI√ìN
        console.error(`[Points SVC Helper] Customer ${userId} has no businessId! This should not happen for CUSTOMER_FINAL.`);
        throw new Error('Error interno: El cliente no est√° asociado a ning√∫n negocio.');
    }
    if (customer.businessId !== qrCodeBusinessId) {
        throw new Error('El c√≥digo QR no es v√°lido para el negocio de este cliente.');
    }
    return customer as ValidCustomer; // Casteo seguro
};

const _calculatePointsEarned = (qrAmount: number, businessConfig: ValidQrCode['business'], customer: ValidCustomer): number => {
    let effectivePoints = qrAmount * (businessConfig.pointsPerEuro ?? 1); // Usar 1 si pointsPerEuro es null/undefined
    const multiplierBenefit = customer.currentTier?.benefits.find(b => b.type === 'POINTS_MULTIPLIER');
    if (multiplierBenefit) {
        const multiplier = parseFloat(multiplierBenefit.value);
        if (!isNaN(multiplier) && multiplier > 0) {
            effectivePoints *= multiplier;
            console.log(`[Points SVC Helper] Applied tier multiplier ${multiplier} for user ${customer.id}`);
        } else {
            console.warn(`[Points SVC Helper] Invalid multiplier value '${multiplierBenefit.value}' for tier ${customer.currentTier?.id}`);
        }
    }
    const calculatedPoints = Math.floor(effectivePoints);
    return calculatedPoints < 0 ? 0 : calculatedPoints; // Asegurar que no sean negativos
};

const _performQrValidationTransaction = async (
    tx: Prisma.TransactionClient,
    qrCode: ValidQrCode,
    customerId: string, // Este es el ID del usuario que valid√≥
    customerBusinessId: string, // <--- A√ëADIDO: El businessId del cliente que valid√≥
    pointsEarned: number,
    now: Date
): Promise<void> => {
    await tx.user.update({
        where: { id: customerId },
        data: {
            points: { increment: pointsEarned },
            lastActivityAt: now,
            totalVisits: { increment: 1 },
            totalSpend: { increment: qrCode.amount },
        },
    });
    await tx.qrCode.update({
        where: { id: qrCode.id },
        data: {
            status: QrCodeStatus.COMPLETED,
            completedAt: now,
            userId: customerId,
            pointsEarned: pointsEarned
        },
    });

    // --- CORRECCI√ìN EN ActivityLog ---
    await tx.activityLog.create({
        data: {
            userId: customerId,
            // businessId de la actividad debe ser el del negocio del cliente,
            // que ya validamos que es el mismo que el del QR.
            businessId: customerBusinessId, // <--- USAR EL businessId DEL CLIENTE
            type: ActivityType.POINTS_EARNED_QR,
            pointsChanged: pointsEarned,
            description: qrCode.ticketNumber, // ticketNumber ahora es string
            relatedQrId: qrCode.id,
        }
    });
    // --- FIN CORRECCI√ìN ---
    console.log(`[Points SVC Helper TX] User, QR, and ActivityLog updated for QR ${qrCode.id}`);
};


// ==================================
// Funciones de Servicio Exportadas
// ==================================

export const generateQrCodeData = async (businessId: string, amount: number, ticketNumber: string): Promise<{ qrToken: string; amount: number }> => {
    if (amount <= 0 || typeof amount !== 'number') {
        throw new Error('El importe de la transacci√≥n debe ser un n√∫mero positivo.');
    }
    const token = uuidv4();
    const expiresAt = addMinutes(new Date(), QR_EXPIRATION_MINUTES); // Considerar usar qrCodeExpirationMinutes del Business
    try {
        const qrCode = await prisma.qrCode.create({
            data: { token, businessId, amount, ticketNumber, expiresAt, status: QrCodeStatus.PENDING },
            select: { token: true, amount: true }
        });
        console.log(`[Points SVC] QR Code generated for business ${businessId} with token ${token} for amount ${amount}, ticket: ${ticketNumber}.`);
        return { qrToken: qrCode.token, amount: qrCode.amount };
    } catch (error: unknown) {
        console.error('[Points SVC] Error generating QR code data:', error);
        throw new Error('No se pudieron generar los datos del c√≥digo QR.');
    }
};


export const validateQrCode = async (qrToken: string, customerUserId: string): Promise<ValidateQrResult> => {
    const now = new Date();
    console.log(`[Points SVC] Validating QR token starting with ${qrToken.substring(0, 5)}... for user ${customerUserId}`);
    try {
        const qrCode = await _findAndValidateQrCodeRecord(qrToken, now);
        const customer = await _findAndValidateCustomerForQr(customerUserId, qrCode.businessId); // customer.businessId aqu√≠ NO es null
        const calculatedPointsEarned = _calculatePointsEarned(qrCode.amount, qrCode.business, customer);

        await prisma.$transaction(async (tx) => {
            // Pasamos customer.businessId (que sabemos que no es null)
            await _performQrValidationTransaction(
                tx,
                qrCode,
                customerUserId,
                customer.businessId, // <--- PASAR EL businessId del cliente
                calculatedPointsEarned,
                now
            );
        });
        console.log(`[Points SVC] Transaction successful for QR ${qrCode.id} and user ${customerUserId}.`);

        // L√≥gica de actualizaci√≥n de Tier (sin cambios)
        if (qrCode.business.tierSystemEnabled) {
            console.log(`[Points SVC] Triggering tier update for user ${customerUserId} (async)`);
            updateUserTier(customerUserId).catch(err => {
                console.error(`[Points SVC] Background tier update failed for user ${customerUserId}:`, err);
            });
        }

        // Esperar un poco para que la actualizaci√≥n de tier se refleje si es s√≠ncrona (no es el caso ideal)
        // O mejor, el updateUserTier deber√≠a devolver el usuario actualizado o refetchear aqu√≠.
        // Por ahora, un peque√±o delay puede ayudar en algunos casos de prueba, pero no es robusto.
        // await new Promise(resolve => setTimeout(resolve, 150)); // Considerar quitar esto

        const updatedUserData = await prisma.user.findUniqueOrThrow({
            where: { id: customerUserId },
            select: {
                id: true,
                points: true,
                totalSpend: true,
                totalVisits: true,
                currentTierId: true,
                currentTier: { select: { name: true } }
            }
        });
        console.log(`[Points SVC] Fetched latest user data post-validation for ${customerUserId}: TierId=${updatedUserData.currentTierId}`);

        return {
            pointsEarned: calculatedPointsEarned,
            updatedUser: {
                id: updatedUserData.id,
                points: updatedUserData.points,
                totalSpend: updatedUserData.totalSpend ?? 0,
                totalVisits: updatedUserData.totalVisits ?? 0,
                currentTierId: updatedUserData.currentTierId,
                currentTierName: updatedUserData.currentTier?.name ?? null
            }
        };
    } catch (error: unknown) {
        // ... (manejo de errores sin cambios) ...
        if (error instanceof Error && (
            error.message.startsWith('C√≥digo QR inv√°lido') ||
            error.message.includes('ya ha sido utilizado') ||
            error.message.includes('ha expirado') ||
            error.message.includes('no est√° disponible para canjear') ||
            error.message.includes('Solo las cuentas de cliente') ||
            error.message.includes('no es v√°lido para el negocio')
        )) {
            console.warn(`[Points SVC] Validation failed for token ${qrToken}: ${error.message}`);
            throw error; // Relanzar el error espec√≠fico para el controlador
        }
        console.error(`[Points SVC] Unexpected error validating token ${qrToken}:`, error);
        throw new Error('Ocurri√≥ un error interno del servidor durante la validaci√≥n del QR.');
    }
};


export const redeemReward = async (customerUserId: string, rewardId: string): Promise<RedeemResult> => {
    console.log(`[Points SVC] Redeeming standard reward ${rewardId} for user ${customerUserId}`);
    try {
        const user = await prisma.user.findUniqueOrThrow({
            where: { id: customerUserId },
            select: { id: true, points: true, businessId: true, role: true }
        });

        if (!user.businessId) { // <--- CHEQUEO IMPORTANTE
            console.error(`[Points SVC] Customer ${customerUserId} attempting to redeem reward but has no businessId.`);
            throw new Error("El usuario cliente no est√° asociado a ning√∫n negocio.");
        }

        const reward = await prisma.reward.findUniqueOrThrow({
            where: { id: rewardId },
            select: {
                id: true, name_es: true, name_en: true,
                pointsCost: true, isActive: true, businessId: true
            }
        });

        if (user.role !== UserRole.CUSTOMER_FINAL) { throw new Error('Rol de usuario inv√°lido para canjear recompensas.'); }
        if (user.businessId !== reward.businessId) { throw new Error('La recompensa no pertenece al negocio del cliente.'); }
        if (!reward.isActive) { throw new Error('Esta recompensa est√° actualmente inactiva.'); }

        const rewardDisplayName = reward.name_es || reward.name_en || `ID ${rewardId}`;
        if (user.points < reward.pointsCost) {
            throw new Error(`Puntos insuficientes para canjear "${rewardDisplayName}". Necesarios: ${reward.pointsCost}, Disponibles: ${user.points}`);
        }

        const updatedUser = await prisma.$transaction(async (tx) => {
            const resultUser = await tx.user.update({
                where: { id: customerUserId },
                data: { points: { decrement: reward.pointsCost } },
                select: { id: true, points: true }
            });

            // --- CORRECCI√ìN EN ActivityLog ---
            await tx.activityLog.create({
                data: {
                    userId: customerUserId,
                    businessId: user.businessId!, // Usamos '!' porque ya validamos que no es null
                    type: ActivityType.POINTS_REDEEMED_REWARD,
                    pointsChanged: -reward.pointsCost,
                    description: reward.name_es || reward.name_en,
                    relatedRewardId: rewardId
                }
            });
            // --- FIN CORRECCI√ìN ---

            console.log(`[Points SVC - TX SUCCESS] User ${resultUser.id} redeemed reward '${rewardDisplayName}' (${reward.id}) for ${reward.pointsCost} points. Activity logged. New balance: ${resultUser.points}.`);
            return resultUser;
        });

        return {
            message: `¬°Recompensa '${rewardDisplayName}' canjeada con √©xito!`,
            newPointsBalance: updatedUser.points
        };
    } catch (error: unknown) {
        // ... (manejo de errores sin cambios) ...
        console.error(`[Points SVC - ERROR] Failed to redeem reward for user ${customerUserId}, reward ${rewardId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            throw new Error('No se encontr√≥ el usuario o la recompensa especificada.');
        }
        if (error instanceof Error) { throw error; } // Relanzar errores espec√≠ficos ya lanzados
        throw new Error('Ocurri√≥ un error inesperado durante el canje de la recompensa.');
    }
};


// ====== [54] backend/src/modules/loyalpyme/rewards/rewards.controller.ts ======
// filename: backend/src/rewards/rewards.controller.ts
// Version: 1.3.0 (Adapt controller to use i18n reward fields)

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client';
import {
    createReward,
    findRewardsByBusiness,
    findRewardById,
    updateReward,
    deleteReward,
    // Importar los tipos de datos necesarios del servicio si se definieron all√≠
    // o definirlos aqu√≠/en un DTO
} from './rewards.service';

// --- DTOs ACTUALIZADOS ---
// DTO para la creaci√≥n (ahora espera campos i18n)
export interface CreateRewardDto {
    name_es: string; // Obligatorio
    name_en: string; // Obligatorio
    description_es?: string | null;
    description_en?: string | null;
    pointsCost: number; // Obligatorio
    imageUrl?: string | null;
}

// DTO para la actualizaci√≥n (campos opcionales)
export interface UpdateRewardDto {
    name_es?: string;
    name_en?: string;
    description_es?: string | null;
    description_en?: string | null;
    pointsCost?: number;
    isActive?: boolean;
    imageUrl?: string | null;
}
// --- FIN DTOs ACTUALIZADOS ---


/**
 * Handles creation of a new reward.
 * POST /api/rewards
 */
export const createRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) {
        return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." });
    }
    const businessId = req.user.businessId;

    // --- CORRECCI√ìN: Destructurar y validar campos i18n ---
    const {
        name_es, name_en, description_es, description_en, pointsCost, imageUrl
    }: CreateRewardDto = req.body;

    // Validaci√≥n b√°sica (mejorar con Zod si se desea)
    if (!name_es || typeof name_es !== 'string' || name_es.trim() === '') {
        return res.status(400).json({ message: 'Se requiere el nombre en espa√±ol (name_es).' });
    }
     if (!name_en || typeof name_en !== 'string' || name_en.trim() === '') {
        return res.status(400).json({ message: 'Se requiere el nombre en ingl√©s (name_en).' });
    }
    if (pointsCost === undefined || typeof pointsCost !== 'number' || pointsCost < 0) {
        return res.status(400).json({ message: 'Se requiere un coste en puntos v√°lido (pointsCost).' });
    }
    // --- FIN CORRECCI√ìN ---

    try {
        // --- CORRECCI√ìN: Pasar campos i18n al servicio ---
        const newReward = await createReward({
            name_es: name_es.trim(), // <-- Pasar name_es
            name_en: name_en.trim(), // <-- Pasar name_en
            description_es: description_es?.trim() || null, // <-- Pasar description_es
            description_en: description_en?.trim() || null, // <-- Pasar description_en
            pointsCost, // Ya validado como n√∫mero
            businessId,
            imageUrl // Puede ser null o undefined
        });
        // --- FIN CORRECCI√ìN ---
        res.status(201).json(newReward); // Devuelve el objeto Reward completo (con todos los campos)
    } catch (error) {
        console.error('[REWARDS CTRL] Error creating reward:', error);
        if (error instanceof Prisma.PrismaClientKnownRequestError || error instanceof Error) {
            // Devolver 409 si es error de unicidad del servicio
            if (error.message.includes('unicidad') || error.message.includes('ya existen')) {
                 return res.status(409).json({ message: error.message });
            }
            // Para otros errores Prisma o gen√©ricos, intentar devolver el mensaje
             return res.status(500).json({ message: error.message || 'Error de base de datos al crear la recompensa.' });
        }
        next(new Error('Error del servidor al crear la recompensa.'));
    }
};

/**
 * Handles fetching all rewards for the authenticated business.
 * GET /api/rewards
 */
export const getRewardsHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.businessId) { return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." }); }
    const businessId = req.user.businessId;
    try {
        // El servicio ya devuelve los campos correctos (name_es, name_en, etc.)
        const rewards = await findRewardsByBusiness(businessId);
        res.status(200).json(rewards); // rewards es ahora RewardListItem[]
    } catch (error) {
        console.error('[REWARDS CTRL] Error fetching rewards:', error);
        next(new Error('Error del servidor al obtener recompensas.'));
    }
};

/**
 * Handles fetching a single reward by ID.
 * GET /api/rewards/:id
 */
export const getRewardByIdHandler = async (req: Request, res: Response, next: NextFunction) => {
   if (!req.user || !req.user.businessId) { return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." }); }
    const businessId = req.user.businessId;
    const rewardId = req.params.id;
    if (!rewardId) { return res.status(400).json({ message: 'Se requiere el ID de la recompensa en la URL.' }); }
    try {
        // El servicio devuelve el objeto Reward completo (con name_es, etc.)
        const reward = await findRewardById(rewardId, businessId);
        if (!reward) { return res.status(404).json({ message: 'Recompensa no encontrada o no pertenece a tu negocio.' }); }
        res.status(200).json(reward);
    } catch (error) {
        console.error('[REWARDS CTRL] Error fetching reward by ID:', error);
        next(new Error('Error del servidor al obtener la recompensa por ID.'));
    }
};

/**
 * Handles updating an existing reward (handles PUT and PATCH).
 * PUT/PATCH /api/rewards/:id
 */
export const updateRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.businessId) { return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." }); }
    const businessId = req.user.businessId;
    const rewardId = req.params.id;
    // --- CORRECCI√ìN: Usar DTO actualizado y limpiar datos ---
    const updateInput: UpdateRewardDto = req.body;
    const updateData: UpdateRewardDto = {}; // Objeto limpio para pasar al servicio

    if (!rewardId) { return res.status(400).json({ message: 'Se requiere el ID de la recompensa en la URL.' }); }
    if (Object.keys(updateInput).length === 0) { return res.status(400).json({ message: 'Se requieren datos de actualizaci√≥n en el cuerpo de la petici√≥n.' }); }

    // Copiar y limpiar solo los campos v√°lidos y definidos
    if (updateInput.name_es !== undefined) updateData.name_es = updateInput.name_es.trim();
    if (updateInput.name_en !== undefined) updateData.name_en = updateInput.name_en.trim();
    if (updateInput.description_es !== undefined) updateData.description_es = updateInput.description_es?.trim() || null;
    if (updateInput.description_en !== undefined) updateData.description_en = updateInput.description_en?.trim() || null;
    if (updateInput.pointsCost !== undefined) {
         if (typeof updateInput.pointsCost !== 'number' || updateInput.pointsCost < 0) { return res.status(400).json({ message: 'Si se actualiza, pointsCost debe ser un n√∫mero >= 0.' }); }
         updateData.pointsCost = updateInput.pointsCost;
    }
    if (updateInput.isActive !== undefined) {
        if (typeof updateInput.isActive !== 'boolean') { return res.status(400).json({ message: 'El campo isActive debe ser un valor booleano (true o false).' }); }
        updateData.isActive = updateInput.isActive;
    }
    // Permitir enviar null para quitar la imagen
     if (updateInput.imageUrl !== undefined) {
         updateData.imageUrl = updateInput.imageUrl;
     }

     // Verificar si hay algo que actualizar despu√©s de limpiar
     if (Object.keys(updateData).length === 0) {
        return res.status(400).json({ message: 'No se proporcionaron datos v√°lidos para actualizar.' });
     }
    // --- FIN CORRECCI√ìN ---

    try {
        // Pasar los datos limpios y correctos al servicio
        const updatedReward = await updateReward(rewardId, businessId, updateData);
        res.status(200).json(updatedReward); // Devuelve el objeto completo actualizado
    } catch (error) {
         console.error('[REWARDS CTRL] Error updating reward:', error);
         if (error instanceof Error && error.message.includes('no encontrada o no pertenece')) { return res.status(404).json({ message: error.message }); }
         if (error instanceof Prisma.PrismaClientKnownRequestError || error instanceof Error) {
            // Devolver 409 si es error de unicidad del servicio
            if (error.message.includes('unicidad') || error.message.includes('ya existen')) {
                 return res.status(409).json({ message: error.message });
            }
            return res.status(500).json({ message: error.message || 'Error de base de datos al actualizar recompensa.' });
         }
         next(new Error('Error del servidor al actualizar la recompensa.'));
    }
};

/**
 * Handles deletion of an existing reward. DELETE /api/rewards/:id
 */
export const deleteRewardHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) { return res.status(401).json({ message: "Usuario no autenticado o negocio no asociado." }); }
    const businessId = req.user.businessId;
    const rewardId = req.params.id;
    if (!rewardId) { return res.status(400).json({ message: 'Se requiere el ID de la recompensa en la URL.' }); }
    try {
        // deleteReward ahora devuelve el objeto Reward completo (con name_es/en)
        const deletedReward = await deleteReward(rewardId, businessId);
        // Devolvemos el objeto borrado completo
        res.status(200).json({ message: 'Recompensa eliminada con √©xito.', deletedReward });
    } catch (error) {
        console.error('[REWARDS CTRL] Error deleting reward:', error);
        if (error instanceof Error && error.message.includes('no encontrada o no pertenece')) { return res.status(404).json({ message: error.message }); }
        // El servicio ya lanza error espec√≠fico si est√° en uso
        if (error instanceof Error && error.message.includes('siendo utilizada')) { return res.status(409).json({ message: error.message }); }
        // Otros errores
        if (error instanceof Prisma.PrismaClientKnownRequestError || error instanceof Error) { return res.status(500).json({ message: error.message || 'Error de base de datos al eliminar recompensa.' }); }
        next(new Error('Error del servidor al eliminar la recompensa.'));
    }
};

// End of File: backend/src/rewards/rewards.controller.ts


// ====== [55] backend/src/modules/loyalpyme/rewards/rewards.service.ts ======
// filename: backend/src/rewards/rewards.service.ts
// Version: 1.2.1 (Use generated i18n Reward types correctly)

import { PrismaClient, Reward, Prisma, GrantedReward } from '@prisma/client';

const prisma = new PrismaClient();

// Interfaz CreateRewardData (Usa los campos correctos del schema)
interface CreateRewardData {
    name_es: string;
    name_en: string;
    description_es?: string | null;
    description_en?: string | null;
    pointsCost: number;
    businessId: string;
    imageUrl?: string | null;
}

/**
 * Creates a new reward for a specific business with i18n fields.
 */
export const createReward = async (rewardData: CreateRewardData): Promise<Reward> => {
    console.log(`[Rewards SVC] Creating reward for business ${rewardData.businessId}: ${rewardData.name_es} / ${rewardData.name_en}`);
    console.log('[DEBUG createReward] Saving data:', { ...rewardData });
    try {
        // Prisma create ya espera los campos correctos (name_es, etc.)
        // seg√∫n el cliente generado despu√©s de la migraci√≥n
        const newReward = await prisma.reward.create({
            data: {
                name_es: rewardData.name_es,
                name_en: rewardData.name_en,
                description_es: rewardData.description_es,
                description_en: rewardData.description_en,
                pointsCost: rewardData.pointsCost,
                businessId: rewardData.businessId,
                imageUrl: rewardData.imageUrl,
            },
        });
        console.log('[DEBUG createReward] Reward created:', newReward);
        return newReward;
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            console.error(`[Rewards SVC] Prisma error creating reward: ${error.code}`, error);
             if (error.code === 'P2002') {
                const target = (error.meta?.target as string[]) || [];
                // Usamos name_es en el mensaje como ejemplo
                if (target.includes('name_es')) { throw new Error(`Ya existe una recompensa con el nombre (ES) "${rewardData.name_es}" para este negocio.`); }
                if (target.includes('name_en')) { throw new Error(`Ya existe una recompensa con el nombre (EN) "${rewardData.name_en}" para este negocio.`); }
                 throw new Error(`Conflicto de unicidad al crear la recompensa (nombre ES o EN ya existen).`);
             }
        } else { console.error(`[Rewards SVC] Unexpected error creating reward:`, error); }
        throw new Error('Error al crear la recompensa.');
    }
};

// --- Tipo RewardListItem ACTUALIZADO ---
// Ahora usa los campos correctos que seleccionaremos
type RewardListItem = Pick<
    Reward,
    'id' | 'name_es' | 'name_en' | 'pointsCost' | 'description_es' | 'description_en' | 'isActive' | 'imageUrl'
>;

/**
 * Finds all rewards for a specific business, selecting i18n fields.
 */
export const findRewardsByBusiness = async (businessId: string): Promise<RewardListItem[]> => {
    console.log(`[Rewards SVC] Finding ALL rewards (with i18n fields) for business ${businessId}`);
    // Select ya est√° actualizado para seleccionar los campos correctos
    const selectFields = {
        id: true,
        name_es: true,
        name_en: true,
        pointsCost: true,
        description_es: true,
        description_en: true,
        isActive: true,
        imageUrl: true
    };
    console.log('[DEBUG findRewardsByBusiness] Using select:', selectFields);
    try {
        const rewardsFound = await prisma.reward.findMany({
            where: { businessId: businessId, },
            select: selectFields,
            // Usar name_es para ordenar (o name_en si se prefiere)
            orderBy: [ { pointsCost: 'asc' }, { name_es: 'asc' } ]
        });
        console.log('[DEBUG findRewardsByBusiness] Rewards found:', rewardsFound);
        // El tipo de retorno ahora coincide con RewardListItem actualizado
        return rewardsFound;
    } catch (error) {
        console.error(`[Rewards SVC] Error finding rewards for business ${businessId}:`, error);
        throw new Error('Error al buscar las recompensas.');
    }
};


/**
 * Finds a single reward by its ID, ensuring it belongs to a specific business.
 * (Returns full object including i18n fields)
 */
export const findRewardById = async (id: string, businessId: string): Promise<Reward | null> => {
     console.log(`[Rewards SVC] Finding reward by ID ${id} for business ${businessId}`);
     try {
         // findFirst devuelve el tipo Reward completo (que ahora tiene name_es, etc.)
         const reward = await prisma.reward.findFirst({ where: { id: id, businessId: businessId } });
         return reward;
     } catch (error) {
         console.error(`[Rewards SVC] Error finding reward by ID ${id}:`, error);
         throw new Error('Error al buscar la recompensa por ID.');
     }
};

// --- Tipo UpdateRewardData ACTUALIZADO ---
// Ahora Partial<Pick<...>> usa los campos correctos
type UpdateRewardData = Partial<Pick<
    Reward,
    'name_es' | 'name_en' | 'description_es' | 'description_en' | 'pointsCost' | 'isActive' | 'imageUrl'
>>;

/**
 * Updates an existing reward with i18n fields, ensuring it belongs to a specific business.
 */
export const updateReward = async (
    id: string,
    businessId: string,
    updateData: UpdateRewardData // Usa el tipo actualizado
): Promise<Reward> => {
    console.log(`[Rewards SVC] Updating reward ID ${id} for business ${businessId}`);
    const existingReward = await findRewardById(id, businessId);
    if (!existingReward) { throw new Error(`Recompensa con ID ${id} no encontrada o no pertenece al negocio ${businessId}.`); }

    console.log('[DEBUG updateReward] Updating with data:', { ...updateData });
    try {
        // updateData ya debe contener los nombres de campo correctos (name_es, etc.)
        const updatedReward = await prisma.reward.update({
            where: { id: id },
            data: updateData,
        });
        console.log('[DEBUG updateReward] Reward updated:', updatedReward);
        return updatedReward;
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            console.error(`[Rewards SVC] Prisma error updating reward ${id}: ${error.code}`, error);
            // Comprobar unicidad en ambos nombres si se est√°n actualizando
             if (error.code === 'P2002') {
                const target = (error.meta?.target as string[]) || [];
                 if (target.includes('name_es') && updateData.name_es) { // Comprobar si se intent√≥ actualizar name_es
                     throw new Error(`Ya existe otra recompensa con el nombre (ES) "${updateData.name_es}" para este negocio.`);
                 }
                  if (target.includes('name_en') && updateData.name_en) { // Comprobar si se intent√≥ actualizar name_en
                     throw new Error(`Ya existe otra recompensa con el nombre (EN) "${updateData.name_en}" para este negocio.`);
                  }
                 throw new Error(`Conflicto de unicidad al actualizar la recompensa (nombre ES o EN ya existen).`);
             }
            throw new Error(`Error de base de datos al actualizar recompensa: ${error.message}`);
        }
        console.error(`[Rewards SVC] Unexpected error updating reward ${id}:`, error);
        throw new Error('Error inesperado al actualizar la recompensa.');
    }
};

/**
 * Deletes an existing reward, ensuring it belongs to a specific business.
 */
export const deleteReward = async (id: string, businessId: string): Promise<Reward> => {
    console.log(`[Rewards SVC] Deleting reward ID ${id} for business ${businessId}`);
    const existingReward = await findRewardById(id, businessId); // Ahora existingReward tiene name_es, name_en
    if (!existingReward) { throw new Error(`Recompensa con ID ${id} no encontrada o no pertenece al negocio ${businessId}.`); }

    const relatedGrantsCount = await prisma.grantedReward.count({ where: { rewardId: id } });
    if (relatedGrantsCount > 0) {
        // Usar name_es o name_en (o ID) en el mensaje de error
        const displayName = existingReward.name_es || existingReward.name_en || `ID ${id}`;
        throw new Error(`No se puede eliminar la recompensa "${displayName}" porque est√° siendo utilizada (ej: ha sido asignada como regalo ${relatedGrantsCount} veces).`);
    }
    try {
        // delete no necesita cambios, usa el where { id }
        return await prisma.reward.delete({ where: { id: id } });
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
            console.error(`[Rewards SVC] Prisma error deleting reward ${id}: ${error.code}`, error);
            throw new Error(`Error de base de datos al eliminar recompensa: ${error.message}`);
        }
        console.error(`[Rewards SVC] Unexpected error deleting reward ${id}:`, error);
        throw new Error('Error inesperado al eliminar la recompensa.');
    }
};

// End of File: backend/src/rewards/rewards.service.ts


// ====== [56] backend/src/modules/loyalpyme/tiers/__tests__/tier-logic.helpers.test.ts ======
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { determineTargetTier, calculateUserMetric } from '../tier-logic.helpers';
import { PrismaClient, TierCalculationBasis, QrCodeStatus } from '@prisma/client';

// Mock simple
const prismaMock = {
  qrCode: {
    aggregate: vi.fn(),
    count: vi.fn(),
  },
};


type ActiveTierInfo = {
  id: string;
  name: string;
  level: number;
  minValue: number;
};

describe('Tier Logic Helpers', () => {

  describe('determineTargetTier', () => {
    // ... (tests sin cambios) ...
    const mockActiveTiers: ActiveTierInfo[] = [
        { id: 'tier-oro', name: 'Oro', level: 3, minValue: 1000 },
        { id: 'tier-plata', name: 'Plata', level: 2, minValue: 500 },
        { id: 'tier-bronce', name: 'Bronce', level: 1, minValue: 100 },
      ];
      it('should return null if metric value is below the lowest tier threshold', () => {
        const metricValue = 50;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBeNull();
      });
      it('should return the lowest tier ID if metric value matches its threshold', () => {
        const metricValue = 100;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBe('tier-bronce');
      });
      it('should return the correct tier ID if metric value is between thresholds', () => {
        const metricValue = 650;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBe('tier-plata');
      });
      it('should return the highest tier ID if metric value meets its threshold', () => {
        const metricValue = 1000;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBe('tier-oro');
      });
      it('should return the highest tier ID if metric value exceeds the highest threshold', () => {
        const metricValue = 5000;
        const targetTierId = determineTargetTier(metricValue, mockActiveTiers);
        expect(targetTierId).toBe('tier-oro');
      });
      it('should return null if the list of active tiers is empty', () => {
        const metricValue = 500;
        const emptyTiers: ActiveTierInfo[] = [];
        const targetTierId = determineTargetTier(metricValue, emptyTiers);
        expect(targetTierId).toBeNull();
      });
       it('should handle tiers with minValue 0 correctly', () => {
         const tiersWithZero: ActiveTierInfo[] = [
           { id: 'tier-plata', name: 'Plata', level: 1, minValue: 100 },
           { id: 'tier-basico', name: 'Basico', level: 0, minValue: 0 },
         ];
         const metricValue = 50;
         const targetTierId = determineTargetTier(metricValue, tiersWithZero);
         expect(targetTierId).toBe('tier-basico');
       });
       it('should return the base tier ID if metric value is 0 and a tier starts at 0', () => {
         const tiersWithZero: ActiveTierInfo[] = [
             { id: 'tier-plata', name: 'Plata', level: 1, minValue: 100 },
             { id: 'tier-basico', name: 'Basico', level: 0, minValue: 0 },
           ];
         const metricValue = 0;
         const targetTierId = determineTargetTier(metricValue, tiersWithZero);
         expect(targetTierId).toBe('tier-basico');
       });
  });

  describe('calculateUserMetric', () => {
    const userId = 'test-user-id';
    const testStartDate = new Date('2024-01-01T00:00:00.000Z');

    beforeEach(() => {
      vi.resetAllMocks();
    });

    it('should calculate metric based on SPEND correctly', async () => {
      prismaMock.qrCode.aggregate.mockResolvedValue({ _sum: { amount: 150.75, pointsEarned: null } });
      // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
      // @ts-expect-error: prismaMock is intentionally simplified for this test
      const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.SPEND, undefined);
      // --- FIN CAMBIO ---
      expect(prismaMock.qrCode.aggregate).toHaveBeenCalledWith(expect.objectContaining({
        _sum: { amount: true },
        where: { userId: userId, status: QrCodeStatus.COMPLETED }
      }));
      expect(metric).toBe(150.75);
    });

    it('should calculate metric based on VISITS correctly', async () => {
      prismaMock.qrCode.count.mockResolvedValue(12);
       // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
       // @ts-expect-error: prismaMock is intentionally simplified for this test
      const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.VISITS, undefined);
       // --- FIN CAMBIO ---
      expect(prismaMock.qrCode.count).toHaveBeenCalledWith(expect.objectContaining({
        where: { userId: userId, status: QrCodeStatus.COMPLETED }
      }));
      expect(metric).toBe(12);
    });

    it('should calculate metric based on POINTS_EARNED correctly', async () => {
      prismaMock.qrCode.aggregate.mockResolvedValue({ _sum: { amount: null, pointsEarned: 5430 } });
       // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
       // @ts-expect-error: prismaMock is intentionally simplified for this test
      const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.POINTS_EARNED, undefined);
       // --- FIN CAMBIO ---
      expect(prismaMock.qrCode.aggregate).toHaveBeenCalledWith(expect.objectContaining({
        _sum: { pointsEarned: true },
        where: { userId: userId, status: QrCodeStatus.COMPLETED }
      }));
      expect(metric).toBe(5430);
    });

    it('should calculate metric based on SPEND with a start date', async () => {
      prismaMock.qrCode.aggregate.mockResolvedValue({ _sum: { amount: 99.50, pointsEarned: null } });
       // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
       // @ts-expect-error: prismaMock is intentionally simplified for this test
      const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.SPEND, testStartDate);
       // --- FIN CAMBIO ---
      expect(prismaMock.qrCode.aggregate).toHaveBeenCalledWith(expect.objectContaining({
        _sum: { amount: true },
        where: { userId: userId, status: QrCodeStatus.COMPLETED, completedAt: { gte: testStartDate } }
      }));
      expect(metric).toBe(99.50);
    });

     it('should return 0 if aggregation sum is null', async () => {
       prismaMock.qrCode.aggregate.mockResolvedValue({ _sum: { amount: null, pointsEarned: null } });
        // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
        // @ts-expect-error: prismaMock is intentionally simplified for this test
       const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.SPEND, undefined);
       // --- FIN CAMBIO ---
       expect(prismaMock.qrCode.aggregate).toHaveBeenCalled();
       expect(metric).toBe(0);
     });

     it('should return 0 if count is 0', async () => {
        prismaMock.qrCode.count.mockResolvedValue(0);
         // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
         // @ts-expect-error: prismaMock is intentionally simplified for this test
        const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.VISITS, undefined);
         // --- FIN CAMBIO ---
        expect(prismaMock.qrCode.count).toHaveBeenCalled();
        expect(metric).toBe(0);
      });

     it('should handle Prisma errors gracefully and return 0', async () => {
        prismaMock.qrCode.aggregate.mockRejectedValue(new Error("Database connection failed"));
         // --- CAMBIO: A√±adir directiva para ignorar error de tipo ---
         // @ts-expect-error: prismaMock is intentionally simplified for this test
        const metric = await calculateUserMetric(prismaMock, userId, TierCalculationBasis.SPEND, undefined);
         // --- FIN CAMBIO ---
        expect(prismaMock.qrCode.aggregate).toHaveBeenCalled();
        expect(metric).toBe(0);
      });
  });
});

// End of File: backend/src/tiers/__tests__/tier-logic.helpers.test.ts


// ====== [57] backend/src/modules/loyalpyme/tiers/tier-benefit.controller.ts ======
// filename: backend/src/tiers/tier-benefit.controller.ts
// Version: 1.0.1 (Fix encoding, remove @ts-ignore)

import { Request, Response, NextFunction } from 'express'; // Add NextFunction
import { Prisma } from '@prisma/client';
import * as TierBenefitService from './tier-benefit.service';
import * as TierService from './tiers.service';

// --- Handlers para CRUD de TierBenefits (Admin) ---

/**
 * Handler para crear un nuevo beneficio para un Tier espec√≠fico.
 * POST /api/tiers/tiers/:tierId/benefits
 */
export const createTierBenefitHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    // --- FIX: Check req.user ---
    if (!req.user || !req.user.businessId) {
        console.error("[TIER_BENEFIT_CTRL] Critical: User context missing in createTierBenefitHandler.");
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    // --- FIN FIX ---

    const { tierId } = req.params;
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier en la URL.' });

    const benefitData = req.body;
    console.log(`[TIER_BENEFIT_CTRL] Creating benefit for tier ${tierId}`);

     // Validaci√≥n b√°sica (mejorar con DTOs/Zod)
     if (!benefitData.type || !benefitData.value) {
         return res.status(400).json({ message: 'Tipo y valor son requeridos para el beneficio.' });
     }
     // TODO: Validaci√≥n m√°s profunda de 'type' y 'value' seg√∫n el tipo

    try {
        // Verificar que el Tier pertenece al negocio antes de crear el beneficio
        // Esta verificaci√≥n podr√≠a hacerse tambi√©n en el servicio, pero hacerla aqu√≠ es una capa extra.
        const tier = await TierService.findTierById(tierId, businessId);
        if (!tier) {
             return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }

        // Crear el beneficio asociado a ese tierId usando el servicio de beneficios
        const { type, value, description, isActive } = benefitData;
        const newBenefit = await TierBenefitService.createTierBenefit(tierId, { type, value, description, isActive });
        console.log(`[TIER_BENEFIT_CTRL] Benefit created successfully: ${newBenefit.id}`);
        res.status(201).json(newBenefit);
    } catch (error: any) {
         console.error(`[TIER_BENEFIT_CTRL] Error creating benefit for tier ${tierId}:`, error);
         // Manejar error P2025 del servicio si el tierId no existe al hacer connect (ya cubierto por el check previo)
        // Devolver 500 para errores inesperados
        next(new Error('Error interno al crear el beneficio.')); // Pasar a manejador global
    }
};

/**
 * Handler para obtener todos los beneficios de un Tier espec√≠fico.
 * GET /api/tiers/tiers/:tierId/benefits
 */
export const getTierBenefitsHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    // --- FIX: Check req.user ---
     if (!req.user || !req.user.businessId) {
        console.error("[TIER_BENEFIT_CTRL] Critical: User context missing in getTierBenefitsHandler.");
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    // --- FIN FIX ---

    const { tierId } = req.params;
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
     console.log(`[TIER_BENEFIT_CTRL] Getting benefits for tier ${tierId}`);

    try {
        // Opcional: Verificar que el Tier pertenece al negocio (buena pr√°ctica)
        const tier = await TierService.findTierById(tierId, businessId);
        if (!tier) {
             return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }

        // Obtener los beneficios usando el servicio de beneficios
        const benefits = await TierBenefitService.findBenefitsByTier(tierId);
        res.status(200).json(benefits);
    } catch (error: any) {
        console.error(`[TIER_BENEFIT_CTRL] Error getting benefits for tier ${tierId}:`, error);
        next(new Error('Error interno al obtener los beneficios.')); // Pasar a manejador global
    }
};

/**
 * Handler para actualizar un beneficio de Tier existente.
 * PUT /api/tiers/benefits/:benefitId
 */
export const updateTierBenefitHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    const { benefitId } = req.params;
     if (!benefitId) return res.status(400).json({ message: 'Se requiere ID del Beneficio.' });

    const updateData = req.body;
     console.log(`[TIER_BENEFIT_CTRL] Updating benefit ${benefitId}`);
    // Validaci√≥n b√°sica
    if (Object.keys(updateData).length === 0) { return res.status(400).json({ message: 'Se requieren datos para actualizar.' }); }
    // TODO: Validar updateData con DTO/Zod si es necesario

    // Opcional: Verificar que el beneficio pertenece a un tier del negocio logueado (m√°s complejo, podr√≠a hacerse en el servicio)
    // const businessId = req.user?.businessId; // Necesitar√≠a check de req.user
    // const canAccess = await checkBenefitBelongsToBusiness(benefitId, businessId); // Funci√≥n hipot√©tica
    // if (!canAccess) return res.status(403).json({ message: 'Acceso denegado a este beneficio.' });

    try {
        const updatedBenefit = await TierBenefitService.updateTierBenefit(benefitId, updateData);
         console.log(`[TIER_BENEFIT_CTRL] Benefit ${benefitId} updated successfully.`);
        res.status(200).json(updatedBenefit);
    } catch (error: any) {
        console.error(`[TIER_BENEFIT_CTRL] Error updating benefit ${benefitId}:`, error);
        if (error instanceof Error && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message }); // Espec√≠fico 404
        }
        next(new Error('Error interno al actualizar el beneficio.')); // Pasar a manejador global
    }
};

/**
 * Handler para eliminar un beneficio de Tier existente.
 * DELETE /api/tiers/benefits/:benefitId
 */
export const deleteTierBenefitHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    const { benefitId } = req.params;
    if (!benefitId) return res.status(400).json({ message: 'Se requiere ID del Beneficio.' });
     console.log(`[TIER_BENEFIT_CTRL] Deleting benefit ${benefitId}`);

    // Opcional: Verificar pertenencia al negocio logueado antes de borrar (requiere check de req.user)
    try {
        const deletedBenefit = await TierBenefitService.deleteTierBenefit(benefitId);
         console.log(`[TIER_BENEFIT_CTRL] Benefit ${benefitId} deleted successfully.`);
        res.status(200).json({ message: 'Beneficio eliminado correctamente.', deletedBenefit }); // o res.sendStatus(204) // Corregido: correctamente
    } catch (error: any) {
        console.error(`[TIER_BENEFIT_CTRL] Error deleting benefit ${benefitId}:`, error);
        if (error instanceof Error && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message }); // Espec√≠fico 404
        }
        next(new Error('Error interno al eliminar el beneficio.')); // Pasar a manejador global
    }
};

// End of File: backend/src/tiers/tier-benefit.controller.ts


// ====== [58] backend/src/modules/loyalpyme/tiers/tier-benefit.service.ts ======
// filename: backend/src/tiers/tier-benefit.service.ts
// Version: 1.0.1 (Fix character encoding)

import { PrismaClient, TierBenefit, Prisma } from '@prisma/client';
// Importar el enum BenefitType si se necesita para validaciones o l√≥gica futura
import { BenefitType } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Crea un nuevo beneficio y lo asocia a un Tier existente.
 * @param tierId - ID del Tier al que pertenece el beneficio.
 * @param benefitData - Datos del nuevo beneficio (type, value, etc.).
 * @returns El TierBenefit creado.
 */
export const createTierBenefit = async (
    tierId: string,
    benefitData: Omit<Prisma.TierBenefitCreateInput, 'tier'>
): Promise<TierBenefit> => {
    console.log(`[TierBenefit SVC] Creating benefit for tier ${tierId}:`, benefitData);
    // Se podr√≠a a√±adir verificaci√≥n de que el tierId pertenece al businessId correcto si fuera necesario
    try {
        const newBenefit = await prisma.tierBenefit.create({
            data: {
                ...benefitData,
                tier: { // Conectar al Tier padre
                    connect: { id: tierId }
                }
            }
        });
        console.log(`[TierBenefit SVC] Benefit created successfully with ID: ${newBenefit.id}`);
        return newBenefit;
    } catch (error) {
        console.error(`[TierBenefit SVC] Error creating benefit for tier ${tierId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             // Este error ocurre si el tierId no existe al intentar conectar
             throw new Error(`No se encontr√≥ el Nivel (Tier) con ID ${tierId} para asociar el beneficio.`); // Corregido: encontr√≥
         }
        throw new Error('Error al crear el beneficio del nivel.');
    }
};

/**
 * Encuentra todos los beneficios asociados a un Tier espec√≠fico.
 * @param tierId - ID del Tier.
 * @returns Lista de TierBenefits.
 */
export const findBenefitsByTier = async (tierId: string): Promise<TierBenefit[]> => {
    console.log(`[TierBenefit SVC] Finding benefits for tier: ${tierId}`);
    try {
        const benefits = await prisma.tierBenefit.findMany({
            where: { tierId: tierId },
             orderBy: { createdAt: 'asc' } // Opcional: ordenar
        });
        return benefits;
    } catch (error) {
        console.error(`[TierBenefit SVC] Error finding benefits for tier ${tierId}:`, error);
        throw new Error('Error al buscar los beneficios del nivel.');
    }
};

/**
 * Actualiza un beneficio de Tier existente.
 * @param benefitId - ID del beneficio a actualizar.
 * @param updateData - Datos a actualizar.
 * @returns El TierBenefit actualizado.
 * @throws Error si el beneficio no se encuentra.
 */
export const updateTierBenefit = async (
    benefitId: string,
    updateData: Partial<Omit<Prisma.TierBenefitUpdateInput, 'tier'>>
): Promise<TierBenefit> => {
    console.log(`[TierBenefit SVC] Updating benefit ID: ${benefitId}`, updateData);
    try {
        // Usamos update directamente, Prisma lanzar√° P2025 si no lo encuentra
        const updatedBenefit = await prisma.tierBenefit.update({
            where: { id: benefitId },
            data: updateData,
        });
        console.log(`[TierBenefit SVC] Benefit ${benefitId} updated successfully.`);
        return updatedBenefit;
    } catch (error) {
        console.error(`[TierBenefit SVC] Error updating benefit ${benefitId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             throw new Error(`Beneficio con ID ${benefitId} no encontrado.`); // Corregido: encontr√≥
         }
        throw new Error('Error al actualizar el beneficio del nivel.');
    }
};

/**
 * Elimina un beneficio de Tier existente.
 * @param benefitId - ID del beneficio a eliminar.
 * @returns El TierBenefit eliminado.
 * @throws Error si el beneficio no se encuentra.
 */
export const deleteTierBenefit = async (benefitId: string): Promise<TierBenefit> => {
    console.log(`[TierBenefit SVC] Deleting benefit ID: ${benefitId}`);
    try {
         // Usamos delete directamente
        const deletedBenefit = await prisma.tierBenefit.delete({
            where: { id: benefitId },
        });
        console.log(`[TierBenefit SVC] Benefit ${benefitId} deleted successfully.`);
        return deletedBenefit;
    } catch (error) {
         console.error(`[TierBenefit SVC] Error deleting benefit ${benefitId}:`, error);
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             throw new Error(`Beneficio con ID ${benefitId} no encontrado.`); // Corregido: encontr√≥
         }
         throw new Error('Error al eliminar el beneficio del nivel.');
       }
};

// End of File: backend/src/tiers/tier-benefit.service.ts


// ====== [59] backend/src/modules/loyalpyme/tiers/tier-config.controller.ts ======
// filename: backend/src/tiers/tier-config.controller.ts
// Version: 1.0.1 (Fix encoding, remove @ts-ignore)

import { Request, Response, NextFunction } from 'express'; // Add NextFunction
import * as TierConfigService from './tier-config.service';

// --- Handlers para Configuraci√≥n de Tiers del Negocio (Admin) ---

/**
 * Handler para obtener la configuraci√≥n de Tiers del negocio.
 * GET /api/tiers/config
 */
export const getBusinessTierConfigHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    // --- FIX: Check req.user ---
    if (!req.user || !req.user.businessId) {
        console.error("[TIER_CONF_CTRL] Critical: User context missing in getBusinessTierConfigHandler.");
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    // --- FIN FIX ---

    console.log(`[TIER_CONF_CTRL] Getting tier config for business ${businessId}`);
    try {
        const config = await TierConfigService.getBusinessTierConfig(businessId);
        if (!config) {
            // Si el servicio devuelve null (negocio no encontrado, aunque no deber√≠a pasar si el token es v√°lido)
            return res.status(404).json({ message: 'Configuraci√≥n de Tiers no encontrada para este negocio.' }); // Corregido: Configuraci√≥n
        }
        res.status(200).json(config);
    } catch (error: any) {
        console.error(`[TIER_CONF_CTRL] Error getting tier config for business ${businessId}:`, error);
        // Pasar al manejador global
        next(new Error('Error interno al obtener la configuraci√≥n de Tiers.')); // Corregido: configuraci√≥n
    }
};

/**
 * Handler para actualizar la configuraci√≥n de Tiers del negocio.
 * PUT /api/tiers/config
 */
export const updateBusinessTierConfigHandler = async (req: Request, res: Response, next: NextFunction) => { // Add next
    // --- FIX: Check req.user ---
     if (!req.user || !req.user.businessId) {
        console.error("[TIER_CONF_CTRL] Critical: User context missing in updateBusinessTierConfigHandler.");
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    // --- FIN FIX ---

    const configData = req.body; // Datos a actualizar
    console.log(`[TIER_CONF_CTRL] Updating tier config for business ${businessId}:`, configData);

    // TODO: Validaci√≥n m√°s robusta con DTOs/Zod aqu√≠ si es necesario.
    // Validaciones b√°sicas como ejemplo:
    if (configData.tierSystemEnabled !== undefined && typeof configData.tierSystemEnabled !== 'boolean') {
        return res.status(400).json({ message: 'tierSystemEnabled debe ser booleano.' });
    }
    // A√±adir m√°s validaciones si se requiere...

    try {
        const updatedBusiness = await TierConfigService.updateBusinessTierConfig(businessId, configData);
        // El servicio devuelve Business, lo devolvemos entero.
        console.log(`[TIER_CONF_CTRL] Tier config updated successfully for business ${businessId}`);
        res.status(200).json(updatedBusiness);
    } catch (error: any) {
        console.error(`[TIER_CONF_CTRL] Error updating tier config for business ${businessId}:`, error);
         // Manejar error de 'Negocio no encontrado' del servicio
        if (error instanceof Error && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        // Pasar otros errores al manejador global
        next(new Error('Error interno al actualizar la configuraci√≥n de Tiers.')); // Corregido: configuraci√≥n
    }
};

// End of File: backend/src/tiers/tier-config.controller.ts


// ====== [60] backend/src/modules/loyalpyme/tiers/tier-config.service.ts ======
// filename: backend/src/tiers/tier-config.service.ts
// Version: 1.0.1 (Fix character encoding)

import { PrismaClient, Business, Prisma } from '@prisma/client';
// Importar los Enums relevantes si se usan en los tipos de datos
import { TierCalculationBasis, TierDowngradePolicy } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Obtiene la configuraci√≥n del sistema de Tiers para un negocio espec√≠fico.
 * @param businessId - ID del negocio.
 * @returns Un objeto con la configuraci√≥n de Tiers o null si el negocio no se encuentra.
 */
export const getBusinessTierConfig = async (businessId: string): Promise<Pick<Business, 'tierSystemEnabled' | 'tierCalculationBasis' | 'tierCalculationPeriodMonths' | 'tierDowngradePolicy' | 'inactivityPeriodMonths'> | null> => {
    console.log(`[TierConfig SVC] Getting tier config for business: ${businessId}`);
    try {
        const business = await prisma.business.findUnique({
            where: { id: businessId },
            // Seleccionar solo los campos de configuraci√≥n de Tiers
            select: {
                tierSystemEnabled: true,
                tierCalculationBasis: true,
                tierCalculationPeriodMonths: true,
                tierDowngradePolicy: true,
                inactivityPeriodMonths: true,
            }
        });
        // findUnique devuelve null si no lo encuentra, lo cual es correcto aqu√≠.
        return business;
    } catch (error) {
        console.error(`[TierConfig SVC] Error fetching tier config for business ${businessId}:`, error);
        // Lanzamos un error gen√©rico para que lo maneje el controlador
        throw new Error('Error al obtener la configuraci√≥n de tiers del negocio.'); // Corregido: configuraci√≥n, gen√©rico
    }
};

/**
 * Actualiza la configuraci√≥n del sistema de Tiers para un negocio.
 * @param businessId - ID del negocio.
 * @param configData - Datos de configuraci√≥n a actualizar.
 * @returns El objeto Business completo actualizado (o solo los campos de config si se prefiere).
 */
export const updateBusinessTierConfig = async (
    businessId: string,
    // Tipado para aceptar un subconjunto de los campos de configuraci√≥n
    configData: Partial<Pick<Business, 'tierSystemEnabled' | 'tierCalculationBasis' | 'tierCalculationPeriodMonths' | 'tierDowngradePolicy' | 'inactivityPeriodMonths'>>
): Promise<Business> => { // Devuelve Business completo por defecto
    console.log(`[TierConfig SVC] Updating tier config for business: ${businessId}`, configData);
    try {
        // Usamos update, que arrojar√° error si businessId no existe // Corregido: arrojar√°
        const updatedBusiness = await prisma.business.update({
            where: { id: businessId },
            data: configData, // Prisma solo actualiza los campos presentes en configData
        });
        console.log(`[TierConfig SVC] Tier config updated successfully for business ${businessId}.`);
        return updatedBusiness;
    } catch (error) {
        console.error(`[TierConfig SVC] Error updating tier config for business ${businessId}:`, error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
            // Error espec√≠fico si el businessId no existe
             throw new Error(`Negocio con ID ${businessId} no encontrado.`); // Corregido: espec√≠fico
         }
        // Otros posibles errores (ej: tipo de dato incorrecto para enums si no se valida antes)
        throw new Error('Error al actualizar la configuraci√≥n de tiers del negocio.'); // Corregido: configuraci√≥n
    }
};

// End of File: backend/src/tiers/tier-config.service.ts


// ====== [61] backend/src/modules/loyalpyme/tiers/tier-crud.controller.ts ======
// filename: backend/src/tiers/tier-crud.controller.ts
// Version: 1.1.1 (Fix validation checks and P2002->409 mapping)

import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client';
import * as TierService from './tiers.service';

// --- Handlers para CRUD de Tiers (Admin) ---

export const createTierHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) {
        return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    }
    const businessId = req.user.businessId;
    const tierData = req.body;
    console.log(`[TIER_CRUD_CTRL] Attempting to create tier for business ${businessId}`);

    // --- VALIDACI√ìN REFORZADA ---
    if (!tierData.name || typeof tierData.name !== 'string' || tierData.name.trim() === '') {
        return res.status(400).json({ message: 'El campo "name" es obligatorio y debe ser un texto.' });
    }
    // Comprobar que level sea n√∫mero, entero y >= 0 EXPL√çCITAMENTE
    if (tierData.level === undefined || typeof tierData.level !== 'number' || !Number.isInteger(tierData.level) || tierData.level < 0) {
         return res.status(400).json({ message: 'El campo "level" es obligatorio y debe ser un n√∫mero entero igual o mayor que 0.' });
     }
     // Comprobar que minValue sea n√∫mero y >= 0 EXPL√çCITAMENTE
    if (tierData.minValue === undefined || typeof tierData.minValue !== 'number' || tierData.minValue < 0) {
        return res.status(400).json({ message: 'El campo "minValue" es obligatorio y debe ser un n√∫mero igual o mayor que 0.' });
    }
     if (tierData.isActive !== undefined && typeof tierData.isActive !== 'boolean') {
        return res.status(400).json({ message: 'El campo "isActive" debe ser un valor booleano (true/false) si se proporciona.' });
    }
    // --- FIN VALIDACI√ìN ---

    try {
        const { name, level, minValue, description, benefitsDescription, isActive } = tierData;
        const newTier = await TierService.createTier(businessId, {
            name: name.trim(), level, minValue,
            description: description?.trim() || null,
            benefitsDescription: benefitsDescription?.trim() || null,
            isActive
        });
        console.log(`[TIER_CRUD_CTRL] Tier created successfully: ${newTier.id}`);
        res.status(201).json(newTier);
    } catch (error: any) {
        console.error(`[TIER_CRUD_CTRL] Error creating tier for business ${businessId}:`, error);
        // --- CAPTURA ESPEC√çFICA PARA 409 ---
        // El servicio lanza un Error con un mensaje espec√≠fico para P2002
        if (error instanceof Error && (error.message.includes('Ya existe un Tier con el nivel') || error.message.includes('Ya existe un Tier con el nombre'))) {
             return res.status(409).json({ message: error.message }); // Devolver 409
        }
        // --- FIN CAPTURA 409 ---
        next(error); // Otros errores a 500
    }
};

// getBusinessTiersHandler (sin cambios)
export const getBusinessTiersHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) { return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' }); }
    const businessId = req.user.businessId;
    const includeBenefits = req.query.includeBenefits === 'true';
    try {
        const tiers = await TierService.findTiersByBusiness(businessId, includeBenefits);
        res.status(200).json(tiers);
    } catch (error: any) { next(error); }
};

// getTierByIdHandler (sin cambios)
export const getTierByIdHandler = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !req.user.businessId) { return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' }); }
    const businessId = req.user.businessId;
    const { tierId } = req.params;
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
    const includeBenefits = req.query.includeBenefits === 'true';
    try {
        const tier = await TierService.findTierById(tierId, businessId, includeBenefits);
        if (!tier) { return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' }); }
        res.status(200).json(tier);
    } catch (error: any) { next(error); }
};

// updateTierHandler (con validaci√≥n a√±adida)
export const updateTierHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.businessId) { return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' }); }
     const businessId = req.user.businessId;
     const { tierId } = req.params;
     if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
     const updateData = req.body;

     // --- VALIDACI√ìN ---
     if (Object.keys(updateData).length === 0) { return res.status(400).json({ message: 'Se requieren datos para actualizar.' }); }
     if (updateData.name !== undefined && (typeof updateData.name !== 'string' || updateData.name.trim() === '')) { return res.status(400).json({ message: 'Si se proporciona "name", no puede estar vac√≠o.' }); }
     if (updateData.level !== undefined && (typeof updateData.level !== 'number' || !Number.isInteger(updateData.level) || updateData.level < 0)) { return res.status(400).json({ message: 'Si se proporciona "level", debe ser un n√∫mero entero igual o mayor que 0.' }); }
     if (updateData.minValue !== undefined && (typeof updateData.minValue !== 'number' || updateData.minValue < 0)) { return res.status(400).json({ message: 'Si se proporciona "minValue", debe ser un n√∫mero igual o mayor que 0.' }); }
     if (updateData.isActive !== undefined && typeof updateData.isActive !== 'boolean') { return res.status(400).json({ message: 'Si se proporciona "isActive", debe ser un valor booleano.' }); }
     // --- FIN VALIDACI√ìN ---

     try {
         const cleanUpdateData: Prisma.TierUpdateInput = {}; // Usar tipo Prisma aqu√≠
         if (updateData.name !== undefined) cleanUpdateData.name = updateData.name.trim();
         if (updateData.level !== undefined) cleanUpdateData.level = updateData.level;
         if (updateData.minValue !== undefined) cleanUpdateData.minValue = updateData.minValue;
         if (updateData.description !== undefined) cleanUpdateData.description = updateData.description?.trim() || null;
         if (updateData.benefitsDescription !== undefined) cleanUpdateData.benefitsDescription = updateData.benefitsDescription?.trim() || null;
         if (updateData.isActive !== undefined) cleanUpdateData.isActive = updateData.isActive;

         const updatedTier = await TierService.updateTier(tierId, businessId, cleanUpdateData);
         console.log(`[TIER_CRUD_CTRL] Tier ${tierId} updated successfully.`);
         res.status(200).json(updatedTier);
     } catch (error: any) {
         console.error(`[TIER_CRUD_CTRL] Error updating tier ${tierId} for business ${businessId}:`, error);
         // --- CAPTURA ESPEC√çFICA 404 y 409 ---
         if (error instanceof Error && error.message.includes('no encontrado')) { return res.status(404).json({ message: error.message }); }
         if (error instanceof Error && (error.message.includes('Ya existe un Tier con el nivel') || error.message.includes('Ya existe un Tier con el nombre'))) { return res.status(409).json({ message: error.message }); }
         // --- FIN CAPTURA ---
         next(error);
     }
};

// deleteTierHandler (con manejo de 409 a√±adido)
export const deleteTierHandler = async (req: Request, res: Response, next: NextFunction) => {
     if (!req.user || !req.user.businessId) { return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' }); }
     const businessId = req.user.businessId;
     const { tierId } = req.params;
     if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
     console.log(`[TIER_CRUD_CTRL] Deleting tier ${tierId} for business ${businessId}`);
     try {
         const deletedTier = await TierService.deleteTier(tierId, businessId);
         console.log(`[TIER_CRUD_CTRL] Tier ${tierId} deleted successfully.`);
         res.status(200).json({ message: 'Tier eliminado correctamente.', deletedTier });
     } catch (error: any) {
         console.error(`[TIER_CRUD_CTRL] Error deleting tier ${tierId} for business ${businessId}:`, error);
         // --- CAPTURA ESPEC√çFICA 404 y 409 ---
         if (error instanceof Error && error.message.includes('no encontrado')) { return res.status(404).json({ message: error.message }); }
         if (error instanceof Error && error.message.includes('usuarios asignados')) { return res.status(409).json({ message: error.message }); }
         // --- FIN CAPTURA ---
         next(error);
     }
};

// End of File: backend/src/tiers/tier-crud.controller.ts


// ====== [62] backend/src/modules/loyalpyme/tiers/tier-logic.helpers.ts ======
// filename: backend/src/tiers/tier-logic.helpers.ts
// Version: 1.3.2 (Add null check for calculationBasis in calculateTierForReview)

import { PrismaClient, User, Prisma, QrCodeStatus, Tier, TierCalculationBasis, TierDowngradePolicy } from '@prisma/client';
import { subMonths, isBefore } from 'date-fns';

type ActiveTierInfo = Pick<Tier, 'id' | 'name' | 'level' | 'minValue'>;

export async function calculateUserMetric(
    prismaClient: Pick<PrismaClient, 'qrCode'>,
    userId: string,
    basis: TierCalculationBasis, // Sigue siendo no nulo aqu√≠
    startDate: Date | undefined
): Promise<number> {
    console.log(`[TierLogic Helper DI] Calculating metric for user ${userId}. Basis=${basis}, StartDate=${startDate?.toISOString() ?? 'Lifetime'}`);
    const whereBase: Prisma.QrCodeWhereInput = { userId: userId, status: QrCodeStatus.COMPLETED, };
    if (startDate) {
        whereBase.completedAt = { gte: startDate };
    }
    let userMetricValue = 0;
    try {
        switch (basis) {
            case TierCalculationBasis.SPEND:
                const spendResult = await prismaClient.qrCode.aggregate({ _sum: { amount: true }, where: whereBase, });
                userMetricValue = spendResult._sum.amount ?? 0;
                break;
            case TierCalculationBasis.VISITS:
                const visitCount = await prismaClient.qrCode.count({ where: whereBase, });
                userMetricValue = visitCount;
                break;
            case TierCalculationBasis.POINTS_EARNED:
                const pointsResult = await prismaClient.qrCode.aggregate({ _sum: { pointsEarned: true }, where: whereBase, });
                userMetricValue = pointsResult._sum.pointsEarned ?? 0;
                break;
        }
    } catch (error) {
        console.error(`[TierLogic Helper DI] Error calculating metric ${basis} for user ${userId}:`, error);
        userMetricValue = 0;
    }
    console.log(`[TierLogic Helper DI] User ${userId} - Metric Result (${basis}) = ${userMetricValue}`);
    return userMetricValue;
}

export function determineTargetTier(metricValue: number, activeTiers: ActiveTierInfo[]): string | null {
    // (Sin cambios)
    let targetTierId: string | null = null;
    for (const tier of activeTiers) {
        if (metricValue >= tier.minValue) {
            targetTierId = tier.id;
            break;
        }
    }
    return targetTierId;
}

export async function calculateTierForReview(
    prismaClient: PrismaClient,
    userId: string
): Promise<{ userId: string, currentTierId: string | null, targetTierId: string | null } | null> {
    console.log(`[Tier JOB Helper DI] Calculating target tier for user ${userId}`);
    try {
        const user = await prismaClient.user.findUnique({
             where: { id: userId },
             include: { /* ... include business ... */
                business: {
                    select: {
                        id: true, tierSystemEnabled: true, tierCalculationBasis: true,
                        tierCalculationPeriodMonths: true,
                        tiers: { where: { isActive: true }, orderBy: { level: 'desc' }, select: { id: true, name: true, level: true, minValue: true } }
                    }
                },
             }
        });

         if (!user || !user.business) { return null; }

        // --- NUEVO: Comprobaci√≥n de null ---
        if (!user.business.tierSystemEnabled || !user.business.tierCalculationBasis || !user.business.tiers || user.business.tiers.length === 0) {
            console.log(`[Tier JOB Helper DI] Skipping review calc for user ${userId} due to missing config or no active tiers.`);
            return null;
        }
        // --- FIN NUEVO ---


        const config = user.business;
        const activeTiers: ActiveTierInfo[] = config.tiers;
        const calculationBasis = config.tierCalculationBasis; // Sabemos que no es null aqu√≠
        const periodMonths = config.tierCalculationPeriodMonths;
        const now = new Date();
        let startDate: Date | undefined = (periodMonths && periodMonths > 0) ? subMonths(now, periodMonths) : undefined;

        // --- CAMBIO: A√±adir '!' para asegurar a TS que calculationBasis no es null ---
        const userMetricValue = await calculateUserMetric(prismaClient, userId, calculationBasis!, startDate);
        // --- FIN CAMBIO ---
        const targetTierId = determineTargetTier(userMetricValue, activeTiers);

        return { userId: user.id, currentTierId: user.currentTierId, targetTierId: targetTierId };
    } catch (error) {
        console.error(`[Tier JOB Helper DI] Error calculating tier for review for user ${userId}:`, error);
        return null;
    }
}

export async function handleInactivityCheckUser(
    prismaClient: PrismaClient,
    user: Pick<User, 'id' | 'lastActivityAt' | 'currentTierId'>,
    inactivityPeriodMonths: number,
    now: Date
): Promise<boolean> {
    // (Sin cambios)
     if (user.currentTierId === null) { return false; }
    if (!user.lastActivityAt) { console.log(`[Tier JOB Helper DI] User ${user.id} has no lastActivityAt date.`); return false; }
    const inactivityLimitDate = subMonths(now, inactivityPeriodMonths);
    if (isBefore(user.lastActivityAt, inactivityLimitDate)) {
        console.log(`[Tier JOB Helper DI] Downgrading user ${user.id} due to inactivity.`);
        try {
            await prismaClient.user.update({ where: { id: user.id }, data: { currentTierId: null, tierAchievedAt: null } });
            return true;
        } catch (error) {
            console.error(`[Tier JOB Helper DI] Failed to downgrade user ${user.id} due to inactivity:`, error);
            return false;
        }
    }
    return false;
}

// End of File: backend/src/tiers/tier-logic.helpers.ts


// ====== [63] backend/src/modules/loyalpyme/tiers/tier-logic.service.ts ======
// filename: backend/src/tiers/tier-logic.service.ts
// Version: 2.2.1 (Pass prisma instance to helpers)

import { PrismaClient, User, Prisma, Tier, TierCalculationBasis, TierDowngradePolicy } from '@prisma/client';
import { subMonths } from 'date-fns';
import {
    calculateUserMetric,
    determineTargetTier,
    calculateTierForReview,
    handleInactivityCheckUser
} from './tier-logic.helpers';

// Instancia de Prisma para este servicio
const prisma = new PrismaClient();

type ActiveTierInfo = Pick<Tier, 'id' | 'name' | 'level' | 'minValue'>;


/**
 * Calcula y actualiza el Tier de un usuario basado en la configuraci√≥n del negocio.
 */
export const updateUserTier = async (userId: string): Promise<void> => {
    console.log(`[TierLogic SVC] Checking/Updating tier for user: ${userId}`);
    try {
        const user = await prisma.user.findUniqueOrThrow({
             where: { id: userId },
             include: {
                 business: {
                     select: {
                         id: true, tierSystemEnabled: true, tierCalculationBasis: true,
                         tierCalculationPeriodMonths: true,
                         tiers: { where: { isActive: true }, orderBy: { level: 'desc' }, select: { id: true, name: true, level: true, minValue: true } }
                     }
                 },
             }
        });
        if (!user.business || !user.business.tierSystemEnabled || !user.business.tierCalculationBasis || !user.business.tiers || user.business.tiers.length === 0) {
            console.log(`[TierLogic SVC] Skipping tier update for user ${userId} due to missing config or disabled system.`);
            return;
        }

        const config = user.business;
        const activeTiers: ActiveTierInfo[] = config.tiers;
        const calculationBasis = config.tierCalculationBasis; // Sabemos que no es null
        const periodMonths = config.tierCalculationPeriodMonths;
        const now = new Date();
        let startDate: Date | undefined = (periodMonths && periodMonths > 0) ? subMonths(now, periodMonths) : undefined;

        // --- CORRECCI√ìN: Pasar 'prisma' a calculateUserMetric ---
        const userMetricValue = await calculateUserMetric(prisma, userId, calculationBasis!, startDate);
        // --- FIN CORRECCI√ìN ---
        const targetTierId = determineTargetTier(userMetricValue, activeTiers);

        if (user.currentTierId !== targetTierId) {
            console.log(`[TierLogic SVC] Updating user ${userId} tier from ${user.currentTierId || 'None'} to ${targetTierId || 'None'}`);
            await prisma.user.update({
                where: { id: userId },
                data: {
                    currentTierId: targetTierId,
                    tierAchievedAt: targetTierId ? now : null,
                 },
            });
        } else {
            console.log(`[TierLogic SVC] User ${userId} remains in tier ${user.currentTierId || 'None'}. No update needed.`);
        }
    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
             console.error(`[TierLogic SVC] User ${userId} not found during tier update check.`);
         } else {
             console.error(`[TierLogic SVC] Error updating tier for user ${userId}:`, error);
         }
    }
};

/**
 * Procesa las actualizaciones y posibles descensos de nivel para todos los usuarios aplicables.
 */
export const processTierUpdatesAndDowngrades = async (): Promise<void> => {
    const jobStartTime = new Date();
    console.log(`[Tier JOB ${jobStartTime.toISOString()}] Starting scheduled tier update/downgrade process...`);
    let businessesProcessed = 0;
    let usersProcessed = 0;
    let usersDowngradedInactivity = 0;
    let usersCheckedPeriodic = 0;
    let usersUpdatedPeriodic = 0;

    try {
        const businessesToProcess = await prisma.business.findMany({
            where: {
                tierSystemEnabled: true,
                 tierDowngradePolicy: { not: TierDowngradePolicy.NEVER }
            },
            select: { id: true, tierDowngradePolicy: true, tierCalculationPeriodMonths: true, inactivityPeriodMonths: true }
        });
        if (businessesToProcess.length === 0) {
            console.log(`[Tier JOB ${jobStartTime.toISOString()}] No businesses with active downgrade policies. Finishing.`);
            return;
        }
        console.log(`[Tier JOB ${jobStartTime.toISOString()}] Found ${businessesToProcess.length} businesses to process.`);
        businessesProcessed = businessesToProcess.length;
        const now = new Date();

        for (const business of businessesToProcess) {
            console.log(`[Tier JOB] Processing business ${business.id} with policy ${business.tierDowngradePolicy}`);
            const users = await prisma.user.findMany({
                where: { businessId: business.id, isActive: true, role: 'CUSTOMER_FINAL' },
                select: { id: true, lastActivityAt: true, currentTierId: true }
            });
            if (users.length === 0) {
                console.log(`[Tier JOB] No active customer users for business ${business.id}. Skipping.`);
                continue;
            }

            for (const user of users) {
                usersProcessed++;
                try {
                    if (business.tierDowngradePolicy === TierDowngradePolicy.PERIODIC_REVIEW) {
                        usersCheckedPeriodic++;
                        // --- CORRECCI√ìN: Pasar 'prisma' a calculateTierForReview ---
                        const reviewResult = await calculateTierForReview(prisma, user.id);
                        // --- FIN CORRECCI√ìN ---
                        if (reviewResult && reviewResult.currentTierId !== reviewResult.targetTierId) {
                            console.log(`[Tier JOB] Updating user ${user.id} tier from ${reviewResult.currentTierId || 'None'} to ${reviewResult.targetTierId || 'None'} based on periodic review.`);
                            await prisma.user.update({
                                where: { id: user.id },
                                data: {
                                     currentTierId: reviewResult.targetTierId,
                                     tierAchievedAt: reviewResult.targetTierId ? now : null
                                }
                            });
                            usersUpdatedPeriodic++;
                        } else if (reviewResult) {
                            // console.log(`[Tier JOB] User ${user.id} tier remains unchanged after periodic review.`);
                        }
                    } else if (business.tierDowngradePolicy === TierDowngradePolicy.AFTER_INACTIVITY && business.inactivityPeriodMonths) {
                        // --- CORRECCI√ìN: Pasar 'prisma' a handleInactivityCheckUser ---
                        const downgraded = await handleInactivityCheckUser(prisma, user, business.inactivityPeriodMonths, now);
                        // --- FIN CORRECCI√ìN ---
                        if (downgraded) usersDowngradedInactivity++;
                    }
                } catch (userProcessingError) {
                    console.error(`[Tier JOB] Unexpected error processing user ${user.id} for business ${business.id}:`, userProcessingError);
                }
            } // Fin loop usuarios
        } // Fin loop negocios
    } catch (error) {
        console.error(`[Tier JOB ${jobStartTime.toISOString()}] Critical error during scheduled processing:`, error);
    } finally {
        const jobEndTime = new Date();
        const duration = (jobEndTime.getTime() - jobStartTime.getTime()) / 1000;
        console.log(`[Tier JOB ${jobStartTime.toISOString()}] Finished processing. Duration: ${duration}s. Businesses: ${businessesProcessed}, Total Users Processed: ${usersProcessed}, Users Checked (Periodic): ${usersCheckedPeriodic}, Updated (Periodic): ${usersUpdatedPeriodic}, Downgraded (Inactivity): ${usersDowngradedInactivity}.`);
    }
};

// End of File: backend/src/tiers/tier-logic.service.ts


// ====== [64] backend/src/modules/loyalpyme/tiers/tiers.controller.ts ======
// File: backend/src/tiers/tiers.controller.ts
// Version: 1.0.0 (Initial controller structure with handlers)

import { Request, Response } from 'express';
import { Prisma } from '@prisma/client'; // Para tipos de error y DTOs

// Importar funciones de los diferentes servicios de Tiers
import * as TierConfigService from './tier-config.service';
import * as TierService from './tiers.service';
import * as TierBenefitService from './tier-benefit.service';
// Todav√≠a no importamos nada de tier-logic.service, ya que updateUserTier se llama internamente o por jobs

// --- Handlers para Configuraci√≥n de Tiers del Negocio (Admin) ---

export const getBusinessTierConfigHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId; // Asumimos que authenticateToken y checkRole(ADMIN) ya pasaron
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });

    try {
        const config = await TierConfigService.getBusinessTierConfig(businessId);
        if (!config) {
            // No es necesariamente un error, podr√≠a ser que el negocio no existe (aunque el token s√≠)
            // O simplemente devolvemos un objeto por defecto si queremos que siempre exista config?
            // Por ahora, devolvemos 404 si no hay negocio o config impl√≠citamente.
             return res.status(404).json({ message: 'Configuraci√≥n de Tiers no encontrada para este negocio.' });
        }
        res.status(200).json(config);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error getting tier config for business ${businessId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener la configuraci√≥n de Tiers.' });
    }
};

export const updateBusinessTierConfigHandler = async (req: Request, res: Response) => {
     const businessId = req.user?.businessId;
     if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });

     // TODO: Validar req.body con un DTO (ej: usando class-validator si se a√±ade)
     const configData = req.body; // Asumimos que el body contiene los campos a actualizar

     // Validaci√≥n b√°sica (mejorar con DTOs)
     if (typeof configData.tierSystemEnabled !== 'boolean' && configData.tierSystemEnabled !== undefined) {
         return res.status(400).json({ message: 'tierSystemEnabled debe ser booleano.' });
     }
     // A√±adir m√°s validaciones para enums, periodos, etc.

     try {
         const updatedBusiness = await TierConfigService.updateBusinessTierConfig(businessId, configData);
         // Devolvemos solo la parte de config actualizada para consistencia con GET? O todo el Business?
         // Devolvemos todo por ahora.
         res.status(200).json(updatedBusiness);
     } catch (error: any) {
         console.error(`[Tiers CTRL] Error updating tier config for business ${businessId}:`, error);
         res.status(500).json({ message: error.message || 'Error interno al actualizar la configuraci√≥n de Tiers.' });
     }
};


// --- Handlers para CRUD de Tiers (Admin) ---

export const createTierHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });

    // TODO: Validar req.body con DTO
    const tierData = req.body;

    // Validaci√≥n b√°sica (mejorar con DTOs)
     if (!tierData.name || typeof tierData.level !== 'number' || typeof tierData.minValue !== 'number') {
         return res.status(400).json({ message: 'Nombre, nivel y valor m√≠nimo son requeridos para el Tier.' });
     }

    try {
        // Pasamos solo los datos relevantes al servicio, excluyendo relaciones/ids
        const { name, level, minValue, description, benefitsDescription, isActive } = tierData;
        const newTier = await TierService.createTier(businessId, { name, level, minValue, description, benefitsDescription, isActive });
        res.status(201).json(newTier);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error creating tier for business ${businessId}:`, error);
        // Devolver 409 si es error de unicidad
        if (error.message.includes('unicidad')) {
            return res.status(409).json({ message: error.message });
        }
        res.status(500).json({ message: error.message || 'Error interno al crear el Tier.' });
    }
};

export const getBusinessTiersHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    const includeBenefits = req.query.includeBenefits === 'true'; // Opci√≥n para incluir beneficios

    try {
        const tiers = await TierService.findTiersByBusiness(businessId, includeBenefits);
        res.status(200).json(tiers);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error getting tiers for business ${businessId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener los Tiers.' });
    }
};

export const getTierByIdHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    const { tierId } = req.params;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });
    const includeBenefits = req.query.includeBenefits === 'true';

    try {
        const tier = await TierService.findTierById(tierId, businessId, includeBenefits);
        if (!tier) {
            return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }
        res.status(200).json(tier);
    } catch (error: any) {
         console.error(`[Tiers CTRL] Error getting tier ${tierId} for business ${businessId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener el Tier.' });
    }
};

export const updateTierHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    const { tierId } = req.params;
     if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
     if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });

     // TODO: Validar req.body con DTO
     const updateData = req.body;
      // Validaci√≥n b√°sica
      if (Object.keys(updateData).length === 0) {
         return res.status(400).json({ message: 'Se requieren datos para actualizar.' });
      }

     try {
         const updatedTier = await TierService.updateTier(tierId, businessId, updateData);
         res.status(200).json(updatedTier);
     } catch (error: any) {
         console.error(`[Tiers CTRL] Error updating tier ${tierId} for business ${businessId}:`, error);
         if (error.message.includes('no encontrado')) {
             return res.status(404).json({ message: error.message });
         }
         if (error.message.includes('unicidad')) {
             return res.status(409).json({ message: error.message });
         }
         res.status(500).json({ message: error.message || 'Error interno al actualizar el Tier.' });
     }
};

export const deleteTierHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId;
    const { tierId } = req.params;
     if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
     if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });

     try {
         const deletedTier = await TierService.deleteTier(tierId, businessId);
         res.status(200).json({ message: 'Tier eliminado correctamente.', deletedTier }); // o res.sendStatus(204)
     } catch (error: any) {
         console.error(`[Tiers CTRL] Error deleting tier ${tierId} for business ${businessId}:`, error);
         if (error.message.includes('no encontrado') || error.message.includes('usuarios asignados')) {
             // 404 si no existe, 409 (Conflicto) si tiene usuarios
             const statusCode = error.message.includes('usuarios asignados') ? 409 : 404;
             return res.status(statusCode).json({ message: error.message });
         }
         res.status(500).json({ message: error.message || 'Error interno al eliminar el Tier.' });
     }
};

// --- Handlers para CRUD de TierBenefits (Admin) ---

export const createTierBenefitHandler = async (req: Request, res: Response) => {
    // Necesitamos el ID del Tier al que a√±adir el beneficio (vendr√° en la URL)
    const businessId = req.user?.businessId; // Para verificar pertenencia del Tier
    const { tierId } = req.params;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier en la URL.' });

    // TODO: Validar req.body con DTO
    const benefitData = req.body;
     // Validaci√≥n b√°sica
     if (!benefitData.type || !benefitData.value) {
         return res.status(400).json({ message: 'Tipo y valor son requeridos para el beneficio.' });
     }
     // A√±adir validaci√≥n de enum BenefitType

    try {
        // Verificar que el Tier pertenece al negocio antes de crear el beneficio
        const tier = await TierService.findTierById(tierId, businessId);
        if (!tier) {
             return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }
        // Crear el beneficio asociado a ese tierId
        const { type, value, description, isActive } = benefitData;
        const newBenefit = await TierBenefitService.createTierBenefit(tierId, { type, value, description, isActive });
        res.status(201).json(newBenefit);
    } catch (error: any) {
         console.error(`[Tiers CTRL] Error creating benefit for tier ${tierId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al crear el beneficio.' });
    }
};

export const getTierBenefitsHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId; // Para verificar pertenencia del Tier
    const { tierId } = req.params;
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token.' });
    if (!tierId) return res.status(400).json({ message: 'Se requiere ID del Tier.' });

    try {
        // Opcional: Verificar que el Tier pertenece al negocio
        const tier = await TierService.findTierById(tierId, businessId);
        if (!tier) {
             return res.status(404).json({ message: 'Tier no encontrado o no pertenece a este negocio.' });
        }
        // Obtener los beneficios
        const benefits = await TierBenefitService.findBenefitsByTier(tierId);
        res.status(200).json(benefits);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error getting benefits for tier ${tierId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener los beneficios.' });
    }
};

export const updateTierBenefitHandler = async (req: Request, res: Response) => {
    const { benefitId } = req.params; // Solo necesitamos el ID del beneficio
     if (!benefitId) return res.status(400).json({ message: 'Se requiere ID del Beneficio.' });
    // TODO: Validar req.body con DTO
    const updateData = req.body;
    if (Object.keys(updateData).length === 0) { return res.status(400).json({ message: 'Se requieren datos para actualizar.' }); }

    // Opcional: Verificar que el beneficio pertenece a un tier del negocio logueado (m√°s complejo)
    // const businessId = req.user?.businessId;
    // const benefit = await prisma.tierBenefit.findUnique({ where: {id: benefitId}, include: { tier: { select: { businessId: true }}}})
    // if (!benefit || benefit.tier.businessId !== businessId) return res.status(404)...

    try {
        const updatedBenefit = await TierBenefitService.updateTierBenefit(benefitId, updateData);
        res.status(200).json(updatedBenefit);
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error updating benefit ${benefitId}:`, error);
        if (error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        res.status(500).json({ message: error.message || 'Error interno al actualizar el beneficio.' });
    }
};

export const deleteTierBenefitHandler = async (req: Request, res: Response) => {
    const { benefitId } = req.params;
    if (!benefitId) return res.status(400).json({ message: 'Se requiere ID del Beneficio.' });

    // Opcional: Verificar pertenencia al negocio logueado
    try {
        const deletedBenefit = await TierBenefitService.deleteTierBenefit(benefitId);
        res.status(200).json({ message: 'Beneficio eliminado correctamente.', deletedBenefit }); // o res.sendStatus(204)
    } catch (error: any) {
        console.error(`[Tiers CTRL] Error deleting benefit ${benefitId}:`, error);
        if (error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        res.status(500).json({ message: error.message || 'Error interno al eliminar el beneficio.' });
    }
};


// --- Handlers para Clientes ---

export const getCustomerTiersHandler = async (req: Request, res: Response) => {
    const businessId = req.user?.businessId; // Cliente final autenticado
    if (!businessId) return res.status(401).json({ message: 'ID de negocio no encontrado en el token del cliente.' });

    try {
         // Reutilizamos la funci√≥n del servicio de Tiers para obtenerlos
         // Podr√≠amos querer incluir beneficios aqu√≠ tambi√©n para mostrarlos al cliente
        const tiers = await TierService.findTiersByBusiness(businessId, true); // includeBenefits = true
        res.status(200).json(tiers);
    } catch (error: any) {
         console.error(`[Tiers CTRL] Error getting tiers for customer of business ${businessId}:`, error);
        res.status(500).json({ message: error.message || 'Error interno al obtener los niveles del programa.' });
    }
};


// End of File: backend/src/tiers/tiers.controller.ts


// ====== [65] backend/src/modules/loyalpyme/tiers/tiers.service.ts ======
// filename: backend/src/tiers/tiers.service.ts
// Version: 1.0.1 (Add debug log)

import { PrismaClient, Tier, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Crea un nuevo Tier para un negocio.
 * @param businessId - ID del negocio.
 * @param tierData - Datos del nuevo Tier.
 * @returns El Tier creado.
 */
export const createTier = async (
    businessId: string,
    tierData: Omit<Prisma.TierCreateInput, 'business' | 'users' | 'benefits'>
): Promise<Tier> => {
    console.log(`[Tier SVC] Creating tier for business ${businessId}:`, tierData);
    try {
        const newTier = await prisma.tier.create({
             data: {
                 ...tierData,
                 business: {
                     connect: { id: businessId }
                 }
             },
        });
        console.log(`[Tier SVC] Tier created successfully with ID: ${newTier.id}`);
        return newTier;
     } catch (error) {
         console.error(`[Tier SVC] Error creating tier for business ${businessId}:`, error);
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             const target = error.meta?.target as string[];
             if (target?.includes('level')) {
                 throw new Error(`Ya existe un Tier con el nivel '${tierData.level}' para este negocio.`);
             } else if (target?.includes('name')) {
                 throw new Error(`Ya existe un Tier con el nombre '${tierData.name}' para este negocio.`);
             }
             throw new Error('Conflicto de unicidad al crear el Tier (nivel o nombre ya existen).');
         }
         throw new Error('Error al crear el nivel de fidelizaci√≥n.');
     }
};

/**
 * Encuentra todos los Tiers de un negocio espec√≠fico, opcionalmente incluyendo sus beneficios.
 * @param businessId ID del negocio.
 * @param includeBenefits Si es true, incluye los beneficios asociados.
 * @returns Lista de Tiers.
 */
export const findTiersByBusiness = async (businessId: string, includeBenefits: boolean = false): Promise<Tier[]> => {
    console.log(`[Tier SVC] Finding tiers for business: ${businessId}, includeBenefits: ${includeBenefits}`);
    try {
        const tiers = await prisma.tier.findMany({
            where: { businessId: businessId },
            orderBy: { level: 'asc' },
            include: {
                benefits: includeBenefits,
            }
        });
        // --- NUEVO LOG ---
        console.log(`[Tier SVC] Prisma findMany finished. Found ${tiers.length} tiers.`);
        // ---------------
        return tiers;
    } catch (error) {
        // --- NUEVO LOG ---
        console.error(`[Tier SVC] *** ERROR within findTiersByBusiness try/catch for business ${businessId}:`, error);
        // ---------------
         console.error(`[Tier SVC] Error finding tiers for business ${businessId}:`, error); // Mantener log original tambi√©n
         throw new Error('Error al buscar los niveles de fidelizaci√≥n.');
    }
};

/**
 * Encuentra un Tier espec√≠fico por su ID, asegurando que pertenece al negocio dado.
 * @param tierId ID del Tier.
 * @param businessId ID del negocio propietario.
 * @param includeBenefits Si es true, incluye los beneficios asociados.
 * @returns El Tier encontrado o null.
 */
export const findTierById = async (tierId: string, businessId: string, includeBenefits: boolean = false): Promise<Tier | null> => {
     console.log(`[Tier SVC] Finding tier by ID: ${tierId} for business: ${businessId}, includeBenefits: ${includeBenefits}`);
     try {
         const tier = await prisma.tier.findFirst({
             where: {
                 id: tierId,
                 businessId: businessId
             },
             include: {
                 benefits: includeBenefits,
             }
         });
         return tier;
     } catch (error) {
         console.error(`[Tier SVC] Error finding tier ${tierId}:`, error);
         throw new Error('Error al buscar el nivel de fidelizaci√≥n por ID.');
     }
};

/**
 * Actualiza un Tier existente.
 * @param tierId ID del Tier a actualizar.
 * @param businessId ID del negocio propietario (para verificaci√≥n).
 * @param updateData Datos a actualizar.
 * @returns El Tier actualizado.
 * @throws Error si el Tier no se encuentra o no pertenece al negocio.
 */
export const updateTier = async (
    tierId: string,
    businessId: string,
    updateData: Partial<Omit<Prisma.TierUpdateInput, 'business' | 'users' | 'benefits'>>
): Promise<Tier> => {
    console.log(`[Tier SVC] Updating tier ID: ${tierId} for business: ${businessId}`, updateData);
    try {
        const existingTier = await prisma.tier.findFirst({
            where: { id: tierId, businessId: businessId },
            select: { id: true }
        });
        if (!existingTier) {
            throw new Error(`Nivel (Tier) con ID ${tierId} no encontrado o no pertenece a este negocio.`);
        }
        const updatedTier = await prisma.tier.update({
            where: { id: tierId },
            data: updateData,
        });
        console.log(`[Tier SVC] Tier ${tierId} updated successfully.`);
        return updatedTier;
    } catch (error) {
        console.error(`[Tier SVC] Error updating tier ${tierId}:`, error);
         if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             throw new Error('Conflicto de unicidad al actualizar el Tier (nivel o nombre ya existen).');
         }
        if (error instanceof Error && error.message.startsWith('Nivel (Tier) con ID')) {
             throw error;
         }
        throw new Error('Error al actualizar el nivel de fidelizaci√≥n.');
    }
};

/**
 * Elimina un Tier existente.
 * @param tierId ID del Tier a eliminar.
 * @param businessId ID del negocio propietario (para verificaci√≥n).
 * @returns El Tier eliminado.
 * @throws Error si el Tier no se encuentra o no pertenece al negocio, o si tiene usuarios asignados.
 */
export const deleteTier = async (tierId: string, businessId: string): Promise<Tier> => {
    console.log(`[Tier SVC] Deleting tier ID: ${tierId} for business: ${businessId}`);
    try {
        const existingTier = await prisma.tier.findFirst({
            where: { id: tierId, businessId: businessId },
             select: { id: true, _count: { select: { users: true } } }
        });
        if (!existingTier) {
            throw new Error(`Nivel (Tier) con ID ${tierId} no encontrado o no pertenece a este negocio.`);
        }
        if (existingTier._count.users > 0) {
             console.warn(`[Tiers SVC] Attempted to delete tier ${tierId} which has ${existingTier._count.users} users assigned.`);
             throw new Error(`No se puede eliminar el Nivel ${tierId} porque tiene usuarios asignados. Reas√≠gnelos primero.`);
         }
        const deletedTier = await prisma.tier.delete({
            where: { id: tierId },
        });
        console.log(`[Tier SVC] Tier ${tierId} deleted successfully.`);
        return deletedTier;
     } catch (error) {
         console.error(`[Tier SVC] Error deleting tier ${tierId}:`, error);
        if (error instanceof Error && (error.message.startsWith('Nivel (Tier) con ID') || error.message.includes('usuarios asignados'))) {
             throw error;
         }
        throw new Error('Error al eliminar el nivel de fidelizaci√≥n.');
     }
};

// End of File: backend/src/tiers/tiers.service.ts


// ====== [66] backend/src/modules/superadmin/superadmin.controller.ts ======
// backend/src/superadmin/superadmin.controller.ts
import { Request, Response, NextFunction } from 'express';
import * as superAdminService from './superadmin.service';

/**
 * Handler para obtener la lista de todos los negocios con su estado de suscripci√≥n.
 */
export const getAllBusinessesHandler = async (req: Request, res: Response, next: NextFunction) => {
    try {
        const businesses = await superAdminService.getAllBusinesses();
        res.status(200).json(businesses);
    } catch (error) {
        console.error("[SA_CTRL] Error in getAllBusinessesHandler:", error);
        next(error);
    }
};

/**
 * Handler para cambiar el estado general (activo/inactivo) de un negocio.
 */
export const toggleBusinessStatusHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessId } = req.params;
    const { isActive } = req.body;
    const adminId = req.user?.id;

    if (typeof isActive !== 'boolean') {
        return res.status(400).json({ message: 'El campo "isActive" es requerido y debe ser un booleano.' });
    }
    if (!adminId) {
        return res.status(403).json({ message: 'No se pudo identificar al administrador.' });
    }

    try {
        const updatedBusiness = await superAdminService.toggleBusinessStatus(businessId, isActive, adminId);
        res.status(200).json(updatedBusiness);
    } catch (error: any) {
        console.error(`[SA_CTRL] Error in toggleBusinessStatusHandler for business ${businessId}:`, error);
        if (error.message && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para activar/desactivar el m√≥dulo LoyaltyCore para un negocio.
 */
export const toggleLoyaltyCoreModuleHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessId } = req.params;
    const { isActive } = req.body;
    const adminId = req.user?.id;

    if (typeof isActive !== 'boolean') {
        return res.status(400).json({ message: 'El campo "isActive" es requerido y debe ser un booleano para el m√≥dulo.' });
    }
    if (!adminId) {
        return res.status(403).json({ message: 'No se pudo identificar al administrador.' });
    }

    try {
        const updatedBusiness = await superAdminService.toggleModule(businessId, 'isLoyaltyCoreActive', isActive, adminId);
        res.status(200).json(updatedBusiness);
    } catch (error: any) {
        console.error(`[SA_CTRL] Error in toggleLoyaltyCoreModuleHandler for business ${businessId}:`, error);
        if (error.message && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para activar/desactivar el m√≥dulo Camarero para un negocio.
 */
export const toggleCamareroModuleHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessId } = req.params;
    const { isActive } = req.body;
    const adminId = req.user?.id;

    if (typeof isActive !== 'boolean') {
        return res.status(400).json({ message: 'El campo "isActive" es requerido y debe ser un booleano para el m√≥dulo.' });
    }
    if (!adminId) {
        return res.status(403).json({ message: 'No se pudo identificar al administrador.' });
    }

    try {
        const updatedBusiness = await superAdminService.toggleModule(businessId, 'isCamareroActive', isActive, adminId);
        res.status(200).json(updatedBusiness);
    } catch (error: any) {
        console.error(`[SA_CTRL] Error in toggleCamareroModuleHandler for business ${businessId}:`, error);
        if (error.message && error.message.includes('no encontrado')) {
            return res.status(404).json({ message: error.message });
        }
        next(error);
    }
};

/**
 * Handler para actualizar el precio de la suscripci√≥n de un negocio.
 */
export const setSubscriptionPriceHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessId } = req.params;
    const { price, currency } = req.body;
    const adminId = req.user?.id;

    if (typeof price !== 'number' || price < 0) {
        return res.status(400).json({ message: 'El campo "price" es requerido y debe ser un n√∫mero no negativo.' });
    }
    if (!currency || typeof currency !== 'string' || currency.length !== 3) {
        return res.status(400).json({ message: 'El campo "currency" es requerido y debe ser un c√≥digo de 3 letras.' });
    }
    if (!adminId) {
        return res.status(403).json({ message: 'No se pudo identificar al administrador.' });
    }

    try {
        const updatedBusiness = await superAdminService.setBusinessSubscriptionPrice(businessId, price, currency, adminId);
        res.status(200).json(updatedBusiness);
    } catch (error) {
        next(error);
    }
};

/**
 * Handler para registrar un pago manual.
 */
export const recordPaymentHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessId } = req.params;
    const paymentData = req.body;
    const adminId = req.user?.id;

    if (!adminId) return res.status(403).json({ message: 'No se pudo identificar al administrador.' });
    if (!paymentData || typeof paymentData.amountPaid !== 'number' || typeof paymentData.month !== 'number' || typeof paymentData.year !== 'number') {
        return res.status(400).json({ message: "Los campos 'amountPaid', 'month' y 'year' son requeridos y deben ser n√∫meros." });
    }

    try {
        const newPayment = await superAdminService.recordManualPayment(businessId, adminId, paymentData);
        res.status(201).json(newPayment);
    } catch (error) {
        next(error);
    }
};

/**
 * Handler para obtener el historial de pagos de un negocio.
 */
export const getPaymentHistoryHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessId } = req.params;
    try {
        const payments = await superAdminService.getBusinessPaymentHistory(businessId);
        res.status(200).json(payments);
    } catch (error) {
        next(error);
    }
};

// --- NUEVO HANDLER A√ëADIDO ---
/**
 * Handler para obtener los periodos de pago pendientes de un negocio.
 */
export const getPendingPeriodsHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { businessId } = req.params;
    try {
        const pendingPeriods = await superAdminService.getPendingPaymentPeriods(businessId);
        res.status(200).json(pendingPeriods);
    } catch (error) {
        next(error);
    }
};

/**
 * Handler para suplantar la identidad de un BUSINESS_ADMIN.
 */
export const impersonationHandler = async (req: Request, res: Response, next: NextFunction) => {
    const { userId: targetUserId } = req.params;
    const adminId = req.user?.id;

    if (!adminId) return res.status(403).json({ message: 'No se pudo identificar al administrador.' });
    if (!targetUserId) return res.status(400).json({ message: "Se requiere el ID del usuario a suplantar." });

    try {
        const token = await superAdminService.getImpersonationToken(targetUserId, adminId);
        res.status(200).json({ token });
    } catch (error) {
        next(error);
    }
};


// ====== [67] backend/src/modules/superadmin/superadmin.service.ts ======
// backend/src/superadmin/superadmin.service.ts
import { PrismaClient, Business, Prisma, SuperAdminActionType, BusinessPayment, UserRole } from '@prisma/client';
import { differenceInCalendarMonths, getMonth, getYear, format } from 'date-fns';
import { es } from 'date-fns/locale';
import jwt from 'jsonwebtoken';

const prisma = new PrismaClient();
const JWT_SECRET = process.env.JWT_SECRET as string;

// --- TIPOS ---

export type SuperAdminBusinessListItem = Pick<
    Business,
    'id' | 'name' | 'slug' | 'isActive' | 'isLoyaltyCoreActive' | 'isCamareroActive' | 'createdAt' | 'monthlyPrice' | 'currency'
> & {
    paymentStatus: 'PAID' | 'PENDING' | 'OVERDUE' | 'NOT_CONFIGURED';
    lastPayment?: { month: number, year: number };
    pendingMonths: number;
};

type ModuleFieldInBusiness = 'isLoyaltyCoreActive' | 'isCamareroActive';


// --- SERVICIOS PRINCIPALES ---

/**
 * Obtiene todos los negocios y calcula su estado de suscripci√≥n.
 */
export const getAllBusinesses = async (): Promise<SuperAdminBusinessListItem[]> => {
    console.log("[SuperAdminService] Fetching all businesses for Super Admin panel...");
    try {
        const businesses = await prisma.business.findMany({
            orderBy: { name: 'asc' },
            include: {
                payments: {
                    orderBy: [{ year: 'desc' }, { month: 'desc' }],
                }
            }
        });

        const now = new Date();
        return businesses.map(business => {
            const lastPaymentRecord = business.payments[0];
            const lastPayment = lastPaymentRecord ? { month: lastPaymentRecord.month, year: lastPaymentRecord.year } : null;
            
            const monthsSinceCreation = differenceInCalendarMonths(now, business.createdAt);
            const paidMonthsCount = business.payments.length;
            const pendingMonths = Math.max(0, monthsSinceCreation - paidMonthsCount);
            
            let paymentStatus: 'PAID' | 'PENDING' | 'OVERDUE' | 'NOT_CONFIGURED' = 'PAID';

            if (!business.monthlyPrice || business.monthlyPrice.toNumber() === 0) {
                paymentStatus = 'NOT_CONFIGURED';
            } else if (pendingMonths > 1) {
                paymentStatus = 'OVERDUE';
            } else if (pendingMonths === 1) {
                paymentStatus = 'PENDING';
            }

            return {
                id: business.id,
                name: business.name,
                slug: business.slug,
                isActive: business.isActive,
                isLoyaltyCoreActive: business.isLoyaltyCoreActive,
                isCamareroActive: business.isCamareroActive,
                createdAt: business.createdAt,
                monthlyPrice: business.monthlyPrice,
                currency: business.currency,
                paymentStatus: paymentStatus,
                lastPayment: lastPayment || undefined,
                pendingMonths: pendingMonths,
            };
        });

    } catch (error) {
        console.error("[SuperAdminService] Error fetching all businesses:", error);
        throw new Error("Error al obtener la lista de negocios desde la base de datos.");
    }
};

/**
 * Cambia el estado 'isActive' general de un negocio y crea un log de auditor√≠a.
 */
export const toggleBusinessStatus = async (businessId: string, isActive: boolean, adminId: string): Promise<Business> => {
    console.log(`[SuperAdminService] Toggling general isActive status for business ${businessId} to ${isActive} by admin ${adminId}`);
    try {
        const business = await prisma.business.findUnique({ where: { id: businessId } });
        if (!business) {
            throw new Error(`Negocio con ID ${businessId} no encontrado.`);
        }
        
        const updatedBusiness = await prisma.business.update({
            where: { id: businessId },
            data: { isActive },
        });

        await createAuditLog({
            adminUserId: adminId,
            actionType: SuperAdminActionType.BUSINESS_STATUS_TOGGLED,
            targetBusinessId: businessId,
            details: { oldValue: business.isActive, newValue: isActive }
        });

        return updatedBusiness;
    } catch (error) {
        handleServiceError(error, `Error toggling status for business ${businessId}`);
        throw error;
    }
};

/**
 * Cambia el estado de un m√≥dulo espec√≠fico y crea un log de auditor√≠a.
 */
export const toggleModule = async (
    businessId: string,
    moduleField: ModuleFieldInBusiness,
    isActiveModule: boolean,
    adminId: string
): Promise<Business> => {
    console.log(`[SuperAdminService] Toggling module '${moduleField}' for business ${businessId} to ${isActiveModule} by admin ${adminId}`);
    try {
        const business = await prisma.business.findUnique({ where: { id: businessId } });
        if (!business) {
            throw new Error(`Negocio con ID ${businessId} no encontrado.`);
        }

        const dataToUpdate: Prisma.BusinessUpdateInput = { [moduleField]: isActiveModule };
        const updatedBusiness = await prisma.business.update({
            where: { id: businessId },
            data: dataToUpdate,
        });

        await createAuditLog({
            adminUserId: adminId,
            actionType: moduleField === 'isLoyaltyCoreActive' ? SuperAdminActionType.MODULE_LOYALTY_TOGGLED : SuperAdminActionType.MODULE_CAMARERO_TOGGLED,
            targetBusinessId: businessId,
            details: { oldValue: business[moduleField], newValue: isActiveModule, module: moduleField }
        });

        return updatedBusiness;
    } catch (error) {
        handleServiceError(error, `Error toggling module ${moduleField} for business ${businessId}`);
        throw error;
    }
};

/**
 * Establece o actualiza el precio de la suscripci√≥n mensual para un negocio.
 */
export const setBusinessSubscriptionPrice = async (businessId: string, price: number, currency: string, adminId: string): Promise<Business> => {
  console.log(`[SuperAdminService] Setting subscription price for business ${businessId} to ${price} ${currency} by admin ${adminId}`);
  try {
    const business = await prisma.business.findUnique({ where: { id: businessId } });
    if (!business) throw new Error(`Negocio con ID ${businessId} no encontrado.`);

    const updatedBusiness = await prisma.business.update({
      where: { id: businessId },
      data: { monthlyPrice: price, currency: currency },
    });

    await createAuditLog({
        adminUserId: adminId,
        actionType: SuperAdminActionType.SUBSCRIPTION_PRICE_UPDATED,
        targetBusinessId: businessId,
        details: { 
            oldPrice: business.monthlyPrice?.toNumber() ?? null,
            newPrice: price, 
            currency: currency 
        }
    });

    return updatedBusiness;
  } catch (error) {
    handleServiceError(error, `Error setting price for business ${businessId}`);
    throw error;
  }
};

/**
 * Registra un nuevo pago manual para un negocio.
 */
export const recordManualPayment = async (businessId: string, adminId: string, paymentData: { amountPaid: number; month: number; year: number; notes?: string; paymentMethod?: string }): Promise<BusinessPayment> => {
    console.log(`[SuperAdminService] Recording manual payment for business ${businessId} by admin ${adminId}`, paymentData);
    try {
        const business = await prisma.business.findUnique({ where: { id: businessId }, select: { id: true }});
        if (!business) throw new Error(`Negocio con ID ${businessId} no encontrado para registrar pago.`);

        const newPayment = await prisma.businessPayment.create({
            data: {
                businessId: businessId,
                recordedByAdminId: adminId,
                amountPaid: paymentData.amountPaid,
                month: paymentData.month,
                year: paymentData.year,
                notes: paymentData.notes,
                paymentMethod: paymentData.paymentMethod
            }
        });

        await createAuditLog({
            adminUserId: adminId,
            actionType: SuperAdminActionType.MANUAL_PAYMENT_RECORDED,
            targetBusinessId: businessId,
            details: { 
                paymentId: newPayment.id, 
                amount: newPayment.amountPaid.toNumber(),
                period: `${paymentData.month}/${paymentData.year}` 
            }
        });

        return newPayment;
    } catch (error) {
        handleServiceError(error, `Error recording payment for business ${businessId}`);
        throw error;
    }
};

/**
 * Obtiene el historial de pagos de un negocio.
 */
export const getBusinessPaymentHistory = async (businessId: string): Promise<BusinessPayment[]> => {
    console.log(`[SuperAdminService] Fetching payment history for business ${businessId}`);
    try {
        return await prisma.businessPayment.findMany({
            where: { businessId: businessId },
            orderBy: [{ year: 'desc' }, { month: 'desc' }],
        });
    } catch (error) {
        handleServiceError(error, `Error fetching payment history for business ${businessId}`);
        throw error;
    }
};

/**
 * Calcula y devuelve los periodos (mes/a√±o) pendientes de pago para un negocio.
 */
export const getPendingPaymentPeriods = async (businessId: string): Promise<{ year: number; month: number; label: string; }[]> => {
    console.log(`[SuperAdminService] Calculating pending payment periods for business ${businessId}`);
    try {
        const business = await prisma.business.findUnique({
            where: { id: businessId },
            select: { createdAt: true, payments: true }
        });
        if (!business) {
            throw new Error(`Negocio con ID ${businessId} no encontrado.`);
        }

        const paidPeriods = new Set(business.payments.map(p => `${p.year}-${p.month}`));
        const pendingPeriods: { year: number; month: number; label: string; }[] = [];
        
        let currentDate = business.createdAt;
        const now = new Date();

        while (currentDate <= now) {
            const year = getYear(currentDate);
            const month = getMonth(currentDate) + 1; // getMonth es 0-indexado
            const periodKey = `${year}-${month}`;

            if (!paidPeriods.has(periodKey)) {
                pendingPeriods.push({
                    year: year,
                    month: month,
                    label: format(currentDate, 'MMMM yyyy', { locale: es }) // Formato "junio 2025"
                });
            }
            
            // Avanzar al siguiente mes
            currentDate = new Date(year, month, 1); // El mes ya est√° 1-indexado, as√≠ que `month` es el siguiente mes
        }

        return pendingPeriods;
    } catch (error) {
        handleServiceError(error, `Error calculating pending periods for business ${businessId}`);
        throw error;
    }
};


/**
 * Genera un token de suplantaci√≥n para un BUSINESS_ADMIN.
 */
export const getImpersonationToken = async (targetUserId: string, adminId: string): Promise<string> => {
    console.log(`[SuperAdminService] Admin ${adminId} requesting impersonation token for user ${targetUserId}`);
    try {
        const targetUser = await prisma.user.findUnique({ where: { id: targetUserId }});

        if (!targetUser || targetUser.role !== UserRole.BUSINESS_ADMIN) {
            throw new Error('El usuario a suplantar no existe o no es un administrador de negocio.');
        }

        const payload = {
            userId: targetUser.id,
            role: targetUser.role,
            businessId: targetUser.businessId,
            impersonated_by: adminId 
        };
        const token = jwt.sign(payload, JWT_SECRET, { expiresIn: '1h' }); 

        await createAuditLog({
            adminUserId: adminId,
            actionType: SuperAdminActionType.IMPERSONATION_STARTED,
            targetBusinessId: targetUser.businessId,
            details: { targetUserId: targetUser.id, targetUserEmail: targetUser.email }
        });

        return token;
    } catch (error) {
        handleServiceError(error, `Error generating impersonation token for user ${targetUserId}`);
        throw error;
    }
};


// --- FUNCIONES HELPERS ---

/**
 * Helper para crear una entrada en el log de auditor√≠a del Super Admin.
 */
async function createAuditLog(data: {
    adminUserId: string;
    actionType: SuperAdminActionType;
    targetBusinessId?: string | null;
    details?: Prisma.JsonValue;
}) {
    try {
        const createData: Prisma.SuperAdminActivityLogCreateInput = {
            actionType: data.actionType,
            details: data.details || Prisma.JsonNull,
            adminUser: {
                connect: { id: data.adminUserId }
            }
        };

        if (data.targetBusinessId) {
            createData.targetBusiness = {
                connect: { id: data.targetBusinessId }
            };
        }

        await prisma.superAdminActivityLog.create({ data: createData });

    } catch (auditError) {
        console.error(`[SuperAdminService] CRITICAL: FAILED TO CREATE AUDIT LOG!`, auditError, `Original Action Data:`, data);
    }
}

/**
 * Helper para manejar y loguear errores de Prisma de forma consistente.
 */
function handleServiceError(error: unknown, contextMessage: string) {
    console.error(`[SuperAdminService] ${contextMessage}:`, error);
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2025') {
            throw new Error(`El registro solicitado no fue encontrado.`);
        }
        if (error.code === 'P2002') {
            throw new Error(`Error de unicidad: Ya existe un registro con estos datos (${(error.meta?.target as string[])?.join(', ')}).`);
        }
    }
}


// ====== [68] backend/src/routes/activity.routes.ts ======
// backend/src/routes/activity.routes.ts (CORREGIDO)
import { Router } from 'express';
// --- RUTA CORREGIDA ---
import { getCustomerActivityHandler } from '../modules/loyalpyme/activity/activity.controller';
// --- FIN RUTA CORREGIDA ---

const activityRouter = Router();

// GET / - Obtiene el historial paginado del cliente
activityRouter.get('/', getCustomerActivityHandler);

export default activityRouter;


// ====== [69] backend/src/routes/admin.routes.ts ======
// backend/src/routes/admin.routes.ts (CORREGIDO)

import { Router } from 'express';
// UserRole no es necesario aqu√≠ si checkRole no se usa directamente
// import { UserRole } from '@prisma/client';

// --- RUTAS DE MIDDLEWARE CORREGIDAS ---
import { checkRole } from '../shared/middleware/role.middleware';
import upload from '../shared/middleware/multer.config';

// --- RUTAS DE CONTROLADORES CORREGIDAS ---
import { getAdminCustomers } from '../modules/loyalpyme/admin/admin-customer-list.controller';
import {
    getCustomerDetailsHandler,
    updateCustomerNotesHandler,
    adjustCustomerPoints,
    changeCustomerTierHandler,
    assignRewardHandler,
    toggleFavoriteHandler,
    toggleActiveStatusHandler
} from '../modules/loyalpyme/admin/admin-customer-individual.controller';
import {
    bulkUpdateCustomerStatusHandler,
    bulkDeleteCustomersHandler,
    bulkAdjustPointsHandler
} from '../modules/loyalpyme/admin/admin-customer-bulk.controller';
import { handleGetOverviewStats } from '../modules/loyalpyme/admin/admin-stats.controller';
import { handleImageUpload } from '../shared/uploads/uploads.controller';


const router = Router();

// NOTA: El middleware checkRole([UserRole.BUSINESS_ADMIN]) se aplica en /src/routes/index.ts
// antes de montar este router, por lo que no es necesario volver a aplicarlo aqu√≠.

// Ruta para Estad√≠sticas
router.get('/stats/overview', handleGetOverviewStats);

// --- Rutas espec√≠ficas de Admin relacionadas con Clientes (sin cambios en la l√≥gica) ---
router.get('/customers', getAdminCustomers);
router.get('/customers/:customerId/details', getCustomerDetailsHandler);
router.patch('/customers/:customerId/notes', updateCustomerNotesHandler);
router.post('/customers/:customerId/adjust-points', adjustCustomerPoints);
router.put('/customers/:customerId/tier', changeCustomerTierHandler);
router.post('/customers/:customerId/assign-reward', assignRewardHandler);
router.patch('/customers/:customerId/toggle-favorite', toggleFavoriteHandler);
router.patch('/customers/:customerId/toggle-active', toggleActiveStatusHandler);
router.patch('/customers/bulk-status', bulkUpdateCustomerStatusHandler);
router.delete('/customers/bulk-delete', bulkDeleteCustomersHandler);
router.post('/customers/bulk-adjust-points', bulkAdjustPointsHandler);

// Ruta para subida de imagen de recompensa
router.post(
    '/upload/reward-image',
    upload.single('imageFile'),
    handleImageUpload
);

export default router;


// ====== [70] backend/src/routes/auth.routes.ts ======
// backend/src/routes/auth.routes.ts (CORREGIDO)

import { Router } from 'express';

// --- RUTAS CORREGIDAS ---
import { login } from '../shared/auth/auth.controller';
import { register, registerBusinessHandler } from '../shared/auth/registration.controller';
import { forgotPasswordHandler, resetPasswordHandler } from '../shared/auth/password-reset.controller';
// --- FIN RUTAS CORREGIDAS ---

const router = Router();

// --- Rutas de autenticaci√≥n (sin cambios en la l√≥gica) ---
router.post('/register', register);
router.post('/register-business', registerBusinessHandler);
router.post('/login', login);
router.post('/forgot-password', forgotPasswordHandler);
router.post('/reset-password/:token', resetPasswordHandler);

export default router;


// ====== [71] backend/src/routes/businesses.routes.ts ======
// backend/src/routes/businesses.routes.ts (CORREGIDO)

import { Router } from 'express';
// --- RUTA CORREGIDA ---
import { handleGetPublicBusinesses } from '../shared/businesses/businesses.controller';
// --- FIN RUTA CORREGIDA ---

const businessRouter = Router();

businessRouter.get(
    '/public-list',
    handleGetPublicBusinesses
);

export default businessRouter;


// ====== [72] backend/src/routes/camarero-admin.routes.ts ======
// backend/src/routes/camarero-admin.routes.ts (CORREGIDO)
import { Router } from 'express';
// --- RUTAS CORREGIDAS ---
import { authenticateToken } from '../shared/middleware/auth.middleware';
import { checkRole } from '../shared/middleware/role.middleware';
import { UserRole } from '@prisma/client';
import { checkModuleActive } from '../shared/middleware/module.middleware';

// Controladores (ahora desde la ubicaci√≥n modular correcta)
import {
    createMenuCategoryHandler,
    getMenuCategoriesHandler,
    getMenuCategoryByIdHandler,
    updateMenuCategoryHandler,
    deleteMenuCategoryHandler
} from '../modules/camarero/admin-menu-category.controller';

import {
    createMenuItemHandler,
    getMenuItemsByCategoryHandler,
    getMenuItemByIdHandler,
    updateMenuItemHandler,
    deleteMenuItemHandler
} from '../modules/camarero/admin-menu-item.controller';

import {
    createModifierGroupHandler,
    getModifierGroupsByMenuItemHandler,
    updateModifierGroupHandler,
    deleteModifierGroupHandler,
    createModifierOptionHandler,
    getModifierOptionsByGroupHandler,
    updateModifierOptionHandler,
    deleteModifierOptionHandler
} from '../modules/camarero/admin-modifier.controller';
// --- FIN RUTAS CORREGIDAS ---

const camareroAdminRouter = Router();

// Middlewares aplicados a TODAS las rutas definidas en este router:
camareroAdminRouter.use(authenticateToken);
camareroAdminRouter.use(checkRole([UserRole.BUSINESS_ADMIN]));
camareroAdminRouter.use(checkModuleActive('CAMARERO'));

// --- RUTAS PARA GESTI√ìN DE CATEGOR√çAS DEL MEN√ö ---
const categoriesBase = '/menu/categories';
camareroAdminRouter.post(categoriesBase, createMenuCategoryHandler);
camareroAdminRouter.get(categoriesBase, getMenuCategoriesHandler);
camareroAdminRouter.get(`${categoriesBase}/:categoryId`, getMenuCategoryByIdHandler);
camareroAdminRouter.put(`${categoriesBase}/:categoryId`, updateMenuCategoryHandler);
camareroAdminRouter.patch(`${categoriesBase}/:categoryId`, updateMenuCategoryHandler);
camareroAdminRouter.delete(`${categoriesBase}/:categoryId`, deleteMenuCategoryHandler);

// --- RUTAS PARA GESTI√ìN DE √çTEMS DEL MEN√ö ---
const itemsBaseRelative = '/items'; // Relativo a la categor√≠a
const itemsBaseAbsolute = '/menu/items'; // Para acceder a un √≠tem directamente por su ID

camareroAdminRouter.post(`${categoriesBase}/:categoryId${itemsBaseRelative}`, createMenuItemHandler);
camareroAdminRouter.get(`${categoriesBase}/:categoryId${itemsBaseRelative}`, getMenuItemsByCategoryHandler);
camareroAdminRouter.get(`${itemsBaseAbsolute}/:itemId`, getMenuItemByIdHandler);
camareroAdminRouter.put(`${itemsBaseAbsolute}/:itemId`, updateMenuItemHandler);
camareroAdminRouter.patch(`${itemsBaseAbsolute}/:itemId`, updateMenuItemHandler);
camareroAdminRouter.delete(`${itemsBaseAbsolute}/:itemId`, deleteMenuItemHandler);

// --- NUEVAS RUTAS PARA GESTI√ìN DE MODIFICADORES ---
const modifierGroupsBaseRelative = '/modifier-groups'; // Relativo al √≠tem de men√∫
const modifierGroupsBaseAbsolute = '/modifier-groups'; // Para acceder a un grupo directamente
const modifierOptionsBaseRelative = '/options'; // Relativo al grupo de modificadores
const modifierOptionsBaseAbsolute = '/modifier-options'; // Para acceder a una opci√≥n directamente

// ModifierGroups (anidados bajo un MenuItem)
camareroAdminRouter.post(`${itemsBaseAbsolute}/:itemId${modifierGroupsBaseRelative}`, createModifierGroupHandler);
camareroAdminRouter.get(`${itemsBaseAbsolute}/:itemId${modifierGroupsBaseRelative}`, getModifierGroupsByMenuItemHandler);

// ModifierGroups (acceso directo por ID del grupo)
camareroAdminRouter.put(`${modifierGroupsBaseAbsolute}/:modifierGroupId`, updateModifierGroupHandler);
camareroAdminRouter.patch(`${modifierGroupsBaseAbsolute}/:modifierGroupId`, updateModifierGroupHandler);
camareroAdminRouter.delete(`${modifierGroupsBaseAbsolute}/:modifierGroupId`, deleteModifierGroupHandler);

// ModifierOptions (anidados bajo un ModifierGroup)
camareroAdminRouter.post(`${modifierGroupsBaseAbsolute}/:modifierGroupId${modifierOptionsBaseRelative}`, createModifierOptionHandler);
camareroAdminRouter.get(`${modifierGroupsBaseAbsolute}/:modifierGroupId${modifierOptionsBaseRelative}`, getModifierOptionsByGroupHandler);

// ModifierOptions (acceso directo por ID de la opci√≥n)
camareroAdminRouter.put(`${modifierOptionsBaseAbsolute}/:modifierOptionId`, updateModifierOptionHandler);
camareroAdminRouter.patch(`${modifierOptionsBaseAbsolute}/:modifierOptionId`, updateModifierOptionHandler);
camareroAdminRouter.delete(`${modifierOptionsBaseAbsolute}/:modifierOptionId`, deleteModifierOptionHandler);


// Placeholder para la ra√≠z de /api/camarero/admin
camareroAdminRouter.get('/', (req, res) => {
    res.json({ message: `[CAMARERO ADMIN] Panel de administraci√≥n del m√≥dulo Camarero para businessId: ${req.user?.businessId}` });
});

export default camareroAdminRouter;


// ====== [73] backend/src/routes/camarero-kds.routes.ts ======
// backend/src/routes/camarero-kds.routes.ts (CORREGIDO)
import { Router } from 'express';
// --- RUTAS CORREGIDAS ---
import { authenticateToken } from '../shared/middleware/auth.middleware';
import { checkRole } from '../shared/middleware/role.middleware';
import { checkModuleActive } from '../shared/middleware/module.middleware';
import { UserRole } from '@prisma/client';

import {
    getItemsForKdsHandler,
    updateOrderItemStatusHandler
} from '../modules/camarero/kds.controller';
// --- FIN RUTAS CORREGIDAS ---


const camareroKdsRouter = Router();

// Middlewares
camareroKdsRouter.use(authenticateToken);
camareroKdsRouter.use(checkModuleActive('CAMARERO'));
camareroKdsRouter.use(checkRole([
    UserRole.KITCHEN_STAFF,
    UserRole.BAR_STAFF,
    UserRole.BUSINESS_ADMIN
]));

// Rutas KDS
camareroKdsRouter.get('/items', getItemsForKdsHandler);
camareroKdsRouter.patch('/items/:orderItemId/status', updateOrderItemStatusHandler);

// Placeholder
camareroKdsRouter.get('/', (req, res) => {
    res.json({
        message: `[KDS API] Endpoints KDS para el negocio: ${req.user?.businessId}. Roles del usuario: ${req.user?.role}`
    });
});

export default camareroKdsRouter;


// ====== [74] backend/src/routes/customer.routes.ts ======
// backend/src/routes/customer.routes.ts (CORREGIDO)
import { Router } from 'express';
import { UserRole } from '@prisma/client';

// --- RUTAS CORREGIDAS ---
import { checkRole } from '../shared/middleware/role.middleware';

import {
    getCustomerRewardsHandler,
    getPendingGrantedRewardsHandler,
    redeemGrantedRewardHandler,
    getCustomerTiersHandler,
    getCustomerBusinessConfigHandler
} from '../modules/loyalpyme/customer/customer.controller';

// La ruta a activity.routes.ts ya es correcta porque ambos est√°n en /src/routes
import activityRouter from './activity.routes';
// --- FIN RUTAS CORREGIDAS ---


const router = Router();

// --- Rutas espec√≠ficas para Clientes (sin cambios en la l√≥gica) ---
router.get(
    '/rewards',
    checkRole([UserRole.CUSTOMER_FINAL]),
    getCustomerRewardsHandler
);

router.get(
    '/granted-rewards',
    checkRole([UserRole.CUSTOMER_FINAL]),
    getPendingGrantedRewardsHandler
);

router.post(
    '/granted-rewards/:grantedRewardId/redeem',
    checkRole([UserRole.CUSTOMER_FINAL]),
    redeemGrantedRewardHandler
);

router.get(
    '/tiers',
    checkRole([UserRole.CUSTOMER_FINAL]),
    getCustomerTiersHandler
);

router.get(
    '/business-config',
    checkRole([UserRole.CUSTOMER_FINAL]),
    getCustomerBusinessConfigHandler
);

router.use('/activity', checkRole([UserRole.CUSTOMER_FINAL]), activityRouter);


export default router;


// ====== [75] backend/src/routes/index.ts ======
// backend/src/routes/index.ts (CORREGIDO)
import { Router } from 'express';
import { UserRole } from '@prisma/client';

// --- RUTAS CORREGIDAS ---
import { authenticateToken } from '../shared/middleware/auth.middleware';
import { checkRole } from '../shared/middleware/role.middleware';
// --- FIN RUTAS CORREGIDAS ---


// Routers (las rutas relativas aqu√≠ son correctas, no necesitan cambio)
import authRouter from './auth.routes';
import protectedRouter from './protected.routes';
import rewardsRouter from './rewards.routes';
import pointsRouter from './points.routes';
import customerRouter from './customer.routes';
import tierRouter from './tiers.routes';
import adminRouter from './admin.routes';
import uploadsRouter from './uploads.routes';
import superAdminRouter from './superadmin.routes';
import camareroAdminRouter from './camarero-admin.routes';
import camareroKdsRouter from './camarero-kds.routes';
import waiterRouter from './waiter.routes';
import businessRouter from './businesses.routes';
import publicMenuRouter from './public-menu.routes';
import publicOrderRouter from './public-order.routes';

// Router para las rutas /api
const apiRouter = Router();

// Rutas con su propia l√≥gica de autenticaci√≥n o semi-p√∫blicas
apiRouter.use('/auth', authRouter);
apiRouter.use('/superadmin', superAdminRouter);

// Rutas de Camarero
apiRouter.use('/camarero/admin', camareroAdminRouter);
apiRouter.use('/camarero/kds', camareroKdsRouter);
apiRouter.use('/camarero/staff', waiterRouter);

// Aplicar autenticaci√≥n general
apiRouter.use(authenticateToken);

// Rutas protegidas
apiRouter.use('/profile', protectedRouter);
apiRouter.use('/rewards', checkRole([UserRole.BUSINESS_ADMIN]), rewardsRouter);
apiRouter.use('/points', pointsRouter);
apiRouter.use('/customer', checkRole([UserRole.CUSTOMER_FINAL]), customerRouter);
apiRouter.use('/tiers', checkRole([UserRole.BUSINESS_ADMIN]), tierRouter);
apiRouter.use('/admin', checkRole([UserRole.BUSINESS_ADMIN]), adminRouter);
apiRouter.use('/uploads', checkRole([UserRole.BUSINESS_ADMIN, UserRole.SUPER_ADMIN]), uploadsRouter);

// Router para las rutas /public
const publicRouterApi = Router(); // Renombrado para evitar conflicto de nombres
publicRouterApi.use('/businesses', businessRouter);
publicRouterApi.use('/menu', publicMenuRouter);
publicRouterApi.use('/order', publicOrderRouter);

export { apiRouter, publicRouterApi as publicRouter };


// ====== [76] backend/src/routes/points.routes.ts ======
// backend/src/routes/points.routes.ts (CORREGIDO)
import { Router } from 'express';
import { UserRole } from '@prisma/client';
// --- RUTAS CORREGIDAS ---
import { checkRole } from '../shared/middleware/role.middleware';
import { generateQrHandler, validateQrHandler, redeemRewardHandler } from '../modules/loyalpyme/points/points.controller';
// --- FIN RUTAS CORREGIDAS ---

const router = Router();

// Rutas para la gesti√≥n de puntos y QR con Roles
router.post('/generate-qr', checkRole([UserRole.BUSINESS_ADMIN]), generateQrHandler);
router.post('/validate-qr', checkRole([UserRole.CUSTOMER_FINAL]), validateQrHandler);
router.post('/redeem-reward/:rewardId', checkRole([UserRole.CUSTOMER_FINAL]), redeemRewardHandler);

export default router;


// ====== [77] backend/src/routes/protected.routes.ts ======
// backend/src/routes/protected.routes.ts
import { Router, Request, Response } from 'express';

const router = Router();

// El middleware authenticateToken ya se aplica ANTES de que se llegue a este handler
// cuando se monta el router en index.ts con app.use('/api/profile', authenticateToken, protectedRouter);

router.get('/', (req: Request, res: Response) => {
  // --- A√ëADIR LOG AQU√ç ---
  console.log('[PROTECTED ROUTE /api/profile DEBUG] req.user object before sending response:', JSON.stringify(req.user, null, 2));
  // --- FIN LOG ---

  if (!req.user) {
    console.error("[PROTECTED ROUTE /api/profile DEBUG] Error: req.user is missing in /api/profile route handler!");
    return res.status(401).json({ message: 'Authentication failed. User data not available.' });
  }
  res.json(req.user); // Esto es lo que recibe el frontend
});

export default router;


// ====== [78] backend/src/routes/public-menu.routes.ts ======
// backend/src/routes/public-menu.routes.ts (CORREGIDO)
import { Router } from 'express';
// --- RUTA CORREGIDA ---
import { getPublicDigitalMenuHandler } from '../modules/camarero/public/menu.controller';
// --- FIN RUTA CORREGIDA ---

const publicMenuRouter = Router();

publicMenuRouter.get(
    '/business/:businessSlug',
    getPublicDigitalMenuHandler
);

export default publicMenuRouter;


// ====== [79] backend/src/routes/public-order.routes.ts ======
// backend/src/routes/public-order.routes.ts (CORREGIDO)
import { Router } from 'express';
// --- RUTA CORREGIDA ---
import {
    createPublicOrderHandler,
    getPublicOrderStatusHandler,
    addItemsToExistingOrderHandler,
    requestBillByClientHandler
} from '../modules/camarero/public/order.controller';
// --- FIN RUTA CORREGIDA ---

const publicOrderRouter = Router();

// Ruta para crear un pedido
publicOrderRouter.post(
    '/:businessSlug',
    createPublicOrderHandler
);

// Ruta para obtener el estado del pedido
publicOrderRouter.get(
    '/:orderId/status',
    getPublicOrderStatusHandler
);

// Ruta para a√±adir √≠tems a un pedido existente
publicOrderRouter.post(
    '/:orderId/items',
    addItemsToExistingOrderHandler
);

// Ruta para que el cliente solicite la cuenta
publicOrderRouter.post(
    '/:orderId/request-bill',
    requestBillByClientHandler
);

export default publicOrderRouter;


// ====== [80] backend/src/routes/rewards.routes.ts ======
// backend/src/routes/rewards.routes.ts (CORREGIDO)
import { Router } from 'express';
import { UserRole } from '@prisma/client';
// --- RUTAS CORREGIDAS ---
import { checkRole } from '../shared/middleware/role.middleware';
import { checkModuleActive } from '../shared/middleware/module.middleware';
import {
    createRewardHandler,
    getRewardsHandler,
    getRewardByIdHandler,
    updateRewardHandler,
    deleteRewardHandler,
} from '../modules/loyalpyme/rewards/rewards.controller';
// --- FIN RUTAS CORREGIDAS ---


const router = Router();

const loyaltyCoreRequired = checkModuleActive('LOYALTY_CORE');

// NOTA: El middleware checkRole([UserRole.BUSINESS_ADMIN]) ya se aplica en src/routes/index.ts
// antes de montar este router, por lo que t√©cnicamente podr√≠a eliminarse de aqu√≠ para evitar redundancia.
// Lo mantenemos por ahora por si decides cambiar la l√≥gica de montaje.

router.post('/', checkRole([UserRole.BUSINESS_ADMIN]), loyaltyCoreRequired, createRewardHandler);
router.get('/', checkRole([UserRole.BUSINESS_ADMIN]), loyaltyCoreRequired, getRewardsHandler);
router.get('/:id', checkRole([UserRole.BUSINESS_ADMIN]), loyaltyCoreRequired, getRewardByIdHandler);
router.put('/:id', checkRole([UserRole.BUSINESS_ADMIN]), loyaltyCoreRequired, updateRewardHandler);
router.patch('/:id', checkRole([UserRole.BUSINESS_ADMIN]), loyaltyCoreRequired, updateRewardHandler);
router.delete('/:id', checkRole([UserRole.BUSINESS_ADMIN]), loyaltyCoreRequired, deleteRewardHandler);

export default router;


// ====== [81] backend/src/routes/superadmin.routes.ts ======
// backend/src/routes/superadmin.routes.ts (CORREGIDO)
import { Router } from 'express';
import { UserRole } from '@prisma/client';
// --- RUTAS CORREGIDAS ---
import { authenticateToken } from '../shared/middleware/auth.middleware';
import { checkRole } from '../shared/middleware/role.middleware';
import {
    getAllBusinessesHandler,
    toggleBusinessStatusHandler,
    toggleLoyaltyCoreModuleHandler,
    toggleCamareroModuleHandler,
    setSubscriptionPriceHandler,
    recordPaymentHandler,
    getPaymentHistoryHandler,
    impersonationHandler,
    getPendingPeriodsHandler
} from '../modules/superadmin/superadmin.controller';
// --- FIN RUTAS CORREGIDAS ---


const router = Router();

// Middleware para todas las rutas de superadmin
router.use(authenticateToken);
router.use(checkRole([UserRole.SUPER_ADMIN]));

// Rutas de Superadmin (sin cambios en la l√≥gica)
router.get('/businesses', getAllBusinessesHandler);
router.patch('/businesses/:businessId/status', toggleBusinessStatusHandler);
router.patch('/businesses/:businessId/module-loyaltycore', toggleLoyaltyCoreModuleHandler);
router.patch('/businesses/:businessId/module-camarero', toggleCamareroModuleHandler);
router.put('/businesses/:businessId/subscription', setSubscriptionPriceHandler);
router.post('/businesses/:businessId/payments', recordPaymentHandler);
router.get('/businesses/:businessId/payments', getPaymentHistoryHandler);
router.get('/businesses/:businessId/pending-payments', getPendingPeriodsHandler);
router.post('/impersonate/:userId', impersonationHandler);

export default router;


// ====== [82] backend/src/routes/tiers.routes.ts ======
// backend/src/routes/tiers.routes.ts (CORREGIDO)
import { Router } from 'express';
import { UserRole } from '@prisma/client';
// --- RUTAS CORREGIDAS ---
import { checkRole } from '../shared/middleware/role.middleware';
import { checkModuleActive } from '../shared/middleware/module.middleware';
import { getBusinessTierConfigHandler, updateBusinessTierConfigHandler } from '../modules/loyalpyme/tiers/tier-config.controller';
import { createTierHandler, getBusinessTiersHandler, getTierByIdHandler, updateTierHandler, deleteTierHandler } from '../modules/loyalpyme/tiers/tier-crud.controller';
import { createTierBenefitHandler, getTierBenefitsHandler, updateTierBenefitHandler, deleteTierBenefitHandler } from '../modules/loyalpyme/tiers/tier-benefit.controller';
// --- FIN RUTAS CORREGIDAS ---

const tierRouter = Router();
const adminOnly = checkRole([UserRole.BUSINESS_ADMIN]);
const loyaltyCoreRequired = checkModuleActive('LOYALTY_CORE');

// Rutas de Configuraci√≥n
tierRouter.get('/config', adminOnly, loyaltyCoreRequired, getBusinessTierConfigHandler);
tierRouter.put('/config', adminOnly, loyaltyCoreRequired, updateBusinessTierConfigHandler);

// Rutas para Tiers CRUD
tierRouter.post('/tiers', adminOnly, loyaltyCoreRequired, createTierHandler);
tierRouter.get('/', adminOnly, loyaltyCoreRequired, getBusinessTiersHandler);
tierRouter.get('/tiers/:tierId', adminOnly, loyaltyCoreRequired, getTierByIdHandler);
tierRouter.put('/tiers/:tierId', adminOnly, loyaltyCoreRequired, updateTierHandler);
tierRouter.patch('/tiers/:tierId', adminOnly, loyaltyCoreRequired, updateTierHandler);
tierRouter.delete('/tiers/:tierId', adminOnly, loyaltyCoreRequired, deleteTierHandler);

// Rutas para Beneficios
tierRouter.post('/tiers/:tierId/benefits', adminOnly, loyaltyCoreRequired, createTierBenefitHandler);
tierRouter.get('/tiers/:tierId/benefits', adminOnly, loyaltyCoreRequired, getTierBenefitsHandler);
tierRouter.put('/benefits/:benefitId', adminOnly, loyaltyCoreRequired, updateTierBenefitHandler);
tierRouter.delete('/benefits/:benefitId', adminOnly, loyaltyCoreRequired, deleteTierBenefitHandler);

export default tierRouter;


// ====== [83] backend/src/routes/uploads.routes.ts ======
// backend/src/routes/uploads.routes.ts (CORREGIDO)
import { Router } from 'express';
// --- RUTAS CORREGIDAS ---
import { handleImageUpload } from '../shared/uploads/uploads.controller';
import uploadImageMemory from '../shared/middleware/multer.config';
// --- FIN RUTAS CORREGIDAS ---

const uploadsRouter = Router();

// Ruta para subir im√°genes
uploadsRouter.post(
    '/image',
    uploadImageMemory.single('image'),
    handleImageUpload
);

export default uploadsRouter;


// ====== [84] backend/src/routes/waiter.routes.ts ======
// backend/src/routes/waiter.routes.ts (CORREGIDO)
import { Router } from 'express';
import { UserRole } from '@prisma/client';
// --- RUTAS CORREGIDAS ---
import { authenticateToken } from '../shared/middleware/auth.middleware';
import { checkRole } from '../shared/middleware/role.middleware';
import { checkModuleActive } from '../shared/middleware/module.middleware';

import {
    getReadyForPickupItemsHandler,
    markOrderItemServedHandler,
    requestBillByStaffHandler,
    markOrderAsPaidHandler,
    getStaffOrdersHandler
} from '../modules/camarero/waiter.controller';
// --- FIN RUTAS CORREGIDAS ---

const waiterRouter = Router();

// Middlewares
waiterRouter.use(authenticateToken);
waiterRouter.use(checkModuleActive('CAMARERO'));
waiterRouter.use(checkRole([UserRole.WAITER, UserRole.BUSINESS_ADMIN]));

// Rutas (sin cambios en la l√≥gica)
waiterRouter.get('/ready-for-pickup', getReadyForPickupItemsHandler);
waiterRouter.patch('/order-items/:orderItemId/status', markOrderItemServedHandler);
waiterRouter.post('/order/:orderId/request-bill', requestBillByStaffHandler);
waiterRouter.post('/order/:orderId/mark-as-paid', markOrderAsPaidHandler);
waiterRouter.get('/orders', getStaffOrdersHandler);

export default waiterRouter;


// ====== [85] backend/src/shared/auth/__tests__/auth.service.test.ts ======
import { describe, it, expect } from 'vitest';
import { hashPassword, comparePassword } from '../auth.service'; // Ajusta ruta si auth.service no est√° en el nivel superior

describe('Auth Service Helpers', () => {
  it('should hash a password correctly', async () => {
    const plainPassword = 'password123';
    const hashedPassword = await hashPassword(plainPassword);

    expect(hashedPassword).toBeTypeOf('string');
    expect(hashedPassword).not.toBe(plainPassword);
    expect(hashedPassword.length).toBeGreaterThan(50);
  });

  it('should compare a correct password successfully', async () => {
    const plainPassword = 'password123';
    const hashedPassword = await hashPassword(plainPassword);
    const isMatch = await comparePassword(plainPassword, hashedPassword);

    expect(isMatch).toBe(true);
  });

  it('should fail comparing an incorrect password', async () => {
    const plainPassword = 'password123';
    const wrongPassword = 'password456';
    const hashedPassword = await hashPassword(plainPassword);
    const isMatch = await comparePassword(wrongPassword, hashedPassword);

    expect(isMatch).toBe(false);
  });
});


// ====== [86] backend/src/shared/auth/auth.controller.ts ======
// filename: backend/src/auth/auth.controller.ts
// Version: 2.1.0 (Refactored: Only contains login handler, cleaned)

import { Request, Response } from 'express';
import { User } from '@prisma/client'; // Needed for type casting if generateToken expects User

// Importar solo utilidades necesarias para login desde auth.service
import { comparePassword, generateToken, findUserByEmail } from './auth.service';

/**
 * Handles user login. POST /api/auth/login
 */
export const login = async (req: Request, res: Response) => {
    const { email, password } = req.body;
    // console.log(`[AUTH CTRL] Attempting login for email: ${email}`); // Log reducido

    if (!email || !password) {
        // console.log('[AUTH CTRL] Login failed: Email or password missing.'); // Log reducido
        return res.status(400).json({ message: 'Se requieren email y contrase√±a.' }); // Corregido: contrase√±a
    }

    try {
        // console.log(`[AUTH CTRL] Finding user by email: ${email}`); // Log reducido
        const user = await findUserByEmail(email);
        if (!user || !user.isActive) {
            // console.log(`[AUTH CTRL] User not found or inactive for email: ${email}. Sending 401.`); // Log reducido
            // Devolvemos 401 Unauthorized para ambos casos (no encontrado o inactivo) por seguridad
            return res.status(401).json({ message: 'Credenciales inv√°lidas o usuario inactivo.' }); // Corregido: inv√°lidas
        }

        // console.log(`[AUTH CTRL] User found: ${user.id}. Comparing password...`); // Log reducido
        const passwordMatch = await comparePassword(password, user.password);
        if (!passwordMatch) {
            // console.log(`[AUTH CTRL] Password mismatch for user ${user.id}. Sending 401.`); // Log reducido
            return res.status(401).json({ message: 'Credenciales inv√°lidas.' }); // Corregido: inv√°lidas
        }

        // console.log(`[AUTH CTRL] Password matches for user ${user.id}. Generating token...`); // Log reducido
        const token = generateToken(user); // generateToken necesita id, role, businessId

        // Excluimos campos sensibles de la respuesta. Ahora quitamos las variables no usadas directamente.
        const {
            password: _password, // Renombrar para evitar conflicto y marcar como no usado
            documentId: _documentId,
            resetPasswordToken: _resetPasswordToken,
            resetPasswordExpires: _resetPasswordExpires,
            ...userWithoutSensitiveData // El resto de campos del usuario
        } = user;

        console.log(`[AUTH CTRL] Login successful for user ${user.id}. Sending 200.`);
        res.status(200).json({ user: userWithoutSensitiveData, token });

    } catch (error) {
        console.error('[AUTH CTRL] Error during login:', error); // Mantener log de error
        res.status(500).json({ message: 'Error del servidor durante el inicio de sesi√≥n.' }); // Corregido: sesi√≥n
    }
};

// Las funciones register, registerBusinessHandler, forgotPasswordHandler, resetPasswordHandler han sido movidas.

// End of File: backend/src/auth/auth.controller.ts


// ====== [87] backend/src/shared/auth/auth.dto.ts ======
// filename: backend/src/auth/auth.dto.ts
// --- INICIO DEL C√ìDIGO COMPLETO ---
// File: backend/src/auth/auth.dto.ts
// Version: 1.2.0 (Add RegisterBusinessDto)

import { UserRole, DocumentType } from '@prisma/client';

// DTO para Registro de Cliente (existente)
export interface RegisterUserDto {
  email: string;
  password: string;
  name?: string;
  phone: string; // Tel√©fono del cliente
  documentId: string; // Documento del cliente
  documentType: DocumentType; // Tipo doc cliente
  businessId: string; // ID del negocio al que se une
  role: UserRole; // Debe ser CUSTOMER_FINAL
}

// DTO para solicitar reseteo (existente)
export interface ForgotPasswordDto {
    email: string;
}

// DTO para realizar el reseteo (existente)
export interface ResetPasswordDto {
    password: string; // La nueva contrase√±a
    // El token vendr√° por la URL (req.params)
}

// --- NUEVO: DTO para registrar un Negocio y su Admin ---
export interface RegisterBusinessDto {
    businessName: string;   // Nombre del nuevo negocio
    adminEmail: string;     // Email para el usuario administrador inicial
    adminPassword: string;  // Contrase√±a para ese administrador
    adminName?: string;      // Nombre opcional para el administrador
    // No necesitamos m√°s datos por ahora para el MVP (slug se generar√°, etc.)
    // No pasamos role porque siempre ser√° BUSINESS_ADMIN
    // No pasamos businessId porque se va a crear uno nuevo
}
// --- FIN NUEVO ---


// End of File: backend/src/auth/auth.dto.ts
// --- FIN DEL C√ìDIGO COMPLETO ---


// ====== [88] backend/src/shared/auth/auth.service.ts ======
// filename: backend/src/auth/auth.service.ts
// Version: 2.1.0 (Add conditional logging for test environment)

import { PrismaClient, User } from '@prisma/client';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';

const prisma = new PrismaClient();
const JWT_SECRET = process.env.JWT_SECRET as string;

// Validaci√≥n de JWT_SECRET
if (!JWT_SECRET) {
    console.error('FATAL ERROR: JWT_SECRET is not defined in auth.service.');
    // process.exit(1); // Considerar salir
}

// --- Funciones de Utilidad B√°sicas ---

/**
 * Hashea una contrase√±a usando bcrypt.
 */
export const hashPassword = async (password: string): Promise<string> => {
    const salt = await bcrypt.genSalt(10);
    return bcrypt.hash(password, salt);
};

/**
 * Compara una contrase√±a en texto plano con una hasheada.
 */
export const comparePassword = async (plainPassword: string, hashedPassword: string): Promise<boolean> => {
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - comparePassword] Comparing provided password with hash ${hashedPassword ? hashedPassword.substring(0,10) : 'N/A'}...`);
    }
    // --- FIN LOG DE DEBUG ---
    const isMatch = await bcrypt.compare(plainPassword, hashedPassword);
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - comparePassword] Result: ${isMatch}`);
    }
    // --- FIN LOG DE DEBUG ---
    return isMatch;
};

/**
 * Genera un token JWT para un usuario.
 */
export const generateToken = (user: Pick<User, 'id' | 'role' | 'businessId'>): string => {
    const payload = {
        userId: user.id,
        role: user.role,
        businessId: user.businessId
    };
    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: '7d' }); // 7 d√≠as de expiraci√≥n
    return token;
};

/**
 * Encuentra un usuario por su direcci√≥n de email.
 */
export const findUserByEmail = async (email: string): Promise<User | null> => {
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - findUserByEmail] Searching for email: ${email}`);
    }
    // --- FIN LOG DE DEBUG ---
    const user = await prisma.user.findUnique({ where: { email } });
    // --- LOG DE DEBUG (Solo en Test) ---
    if (process.env.VITEST === 'true') {
        console.log(`[DEBUG TEST - findUserByEmail] User found: ${user ? `{ id: ${user.id}, email: ${user.email}, isActive: ${user.isActive} }` : 'null'}`);
    }
    // --- FIN LOG DE DEBUG ---
    return user;
};

// --- Funciones movidas a otros servicios ---
// createUser -> registration.service.ts
// handleForgotPassword, handleResetPassword -> password-reset.service.ts
// createBusinessAndAdmin, generateSlug -> registration.service.ts

// End of File: backend/src/auth/auth.service.ts


// ====== [89] backend/src/shared/auth/password-reset.controller.ts ======
// filename: backend/src/auth/password-reset.controller.ts
// Version: 1.0.3 (Remove Swagger annotations)

import { Request, Response } from 'express';
// DTOs necesarios para reseteo
import { ForgotPasswordDto, ResetPasswordDto } from './auth.dto';

// Servicios necesarios
import { hashPassword } from './auth.service';
import { handleForgotPassword, handleResetPassword } from './password-reset.service';

// SIN ANOTACI√ìN @openapi
export const forgotPasswordHandler = async (req: Request, res: Response) => {
    const { email }: ForgotPasswordDto = req.body;

    if (!email) {
        return res.status(400).json({ message: 'Se requiere el email.' });
    }
    try {
        await handleForgotPassword(email);
        res.status(200).json({ message: 'Si existe una cuenta con ese email, se ha enviado un enlace para restablecer la contrase√±a.' });
    } catch (error: any) {
        console.error('[PWD_RESET CTRL] Error in forgotPasswordHandler:', error.message);
        res.status(200).json({ message: 'Si existe una cuenta con ese email, se ha enviado un enlace para restablecer la contrase√±a.' });
    }
};

// SIN ANOTACI√ìN @openapi
export const resetPasswordHandler = async (req: Request, res: Response) => {
    const { token } = req.params;
    const { password: newPassword }: ResetPasswordDto = req.body;

    if (!token) {
        return res.status(400).json({ message: 'Falta el token de reseteo.' });
    }
    if (!newPassword) {
        return res.status(400).json({ message: 'Se requiere la nueva contrase√±a.' });
    }
    if (newPassword.length < 6) {
        return res.status(400).json({ message: 'La nueva contrase√±a debe tener al menos 6 caracteres.' });
    }

    try {
        const hashedNewPassword = await hashPassword(newPassword);
        await handleResetPassword(token, hashedNewPassword);

        res.status(200).json({ message: 'Contrase√±a restablecida con √©xito.' });
    } catch (error: any) {
        console.error(`[PWD_RESET CTRL] Error in resetPasswordHandler for token ${token ? token.substring(0,5)+'...' : 'undefined'}:`, error.message);
        res.status(400).json({ message: error.message || 'No se pudo restablecer la contrase√±a.' });
    }
};

// End of File: backend/src/auth/password-reset.controller.ts


// ====== [90] backend/src/shared/auth/password-reset.service.ts ======
// filename: backend/src/auth/password-reset.service.ts
// Version: 1.0.1 (Fix encoding, remove insecure log, cleanup comments)

import { PrismaClient, User } from '@prisma/client';
// bcrypt ya no se usa directamente aqu√≠ si usamos comparePassword desde auth.service
import crypto from 'crypto';

// Importar utilidades necesarias desde el servicio principal de auth
// ASUNCI√ìN: Estas funciones permanecer√°n o ser√°n exportadas desde auth.service.ts
import { hashPassword, comparePassword, findUserByEmail } from './auth.service';

const prisma = new PrismaClient();

// Constante de expiraci√≥n (espec√≠fica de este flujo)
const RESET_TOKEN_EXPIRATION_MS = 60 * 60 * 1000; // 1 hour

// --- Funciones para Reseteo de Contrase√±a ---

export const handleForgotPassword = async (email: string): Promise<void> => {
    console.log(`[PWD_RESET SVC] Handling forgot password for: ${email}`);
    const user = await findUserByEmail(email); // Usa la utilidad importada
    if (!user) {
        console.log(`[PWD_RESET SVC] User not found for forgot password: ${email}. Responding generically.`);
        return; // Salir silenciosamente
    }

    const resetToken = crypto.randomBytes(32).toString('hex');
    // console.log(`[PWD_RESET SVC] Generated PLAIN reset token for ${email}: ${resetToken}`); // <-- LOG INSEGURO ELIMINADO
    const hashedResetToken = await hashPassword(resetToken);
    const expires = new Date(Date.now() + RESET_TOKEN_EXPIRATION_MS);

    try {
        await prisma.user.update({
            where: { email: email },
            data: {
                resetPasswordToken: hashedResetToken,
                resetPasswordExpires: expires,
            },
        });
        console.log(`[PWD_RESET SVC] Hashed reset token stored successfully for user ${user.id}`);
        // Aqu√≠ ir√≠a la l√≥gica real de env√≠o de email con el 'resetToken' (el original, NO el hasheado)
        // Ejemplo: await sendPasswordResetEmail(user.email, resetToken);
        // Por ahora, el token plano solo se logueaba (y ya hemos quitado eso)
    } catch (error) {
        console.error(`[PWD_RESET SVC] Failed to store reset token for user ${user.id}:`, error);
        // Considerar si relanzar o manejar el error de forma diferente
    }
};

export const handleResetPassword = async (token: string, hashedNewPassword: string): Promise<void> => {
    console.log(`[PWD_RESET SVC] Handling reset password with token starting: ${token.substring(0, 5)}...`);

    const potentialUsers = await prisma.user.findMany({
        where: {
            resetPasswordToken: { not: null },
            resetPasswordExpires: { gt: new Date() } // Buscar solo tokens no expirados
        }
    });

    if (!potentialUsers || potentialUsers.length === 0) {
        console.log('[PWD_RESET SVC] No users found with potentially valid (non-null, non-expired) reset tokens.');
        throw new Error('Token inv√°lido o expirado.'); // Error gen√©rico
    }
    console.log(`[PWD_RESET SVC] Found ${potentialUsers.length} users with active tokens. Verifying provided token...`);

    // Comparar token plano proporcionado con los hashes guardados
    let userToUpdate: User | null = null;
    for (const user of potentialUsers) {
        if (user.resetPasswordToken) {
            const isTokenMatch = await comparePassword(token, user.resetPasswordToken);
            if (isTokenMatch) {
                console.log(`[PWD_RESET SVC] Token match found for user ID: ${user.id}`);
                userToUpdate = user;
                break; // Encontramos el usuario, salimos del bucle
            }
        }
    }

    if (!userToUpdate) {
        // Si recorrimos todos los usuarios con token activo y ninguno coincidi√≥
        console.log(`[PWD_RESET SVC] No user matched the provided token among active ones.`);
        throw new Error('Token inv√°lido o expirado.'); // Mismo error gen√©rico
    }

    // Actualizar contrase√±a y limpiar campos de reseteo
    try {
        await prisma.user.update({
            where: { id: userToUpdate.id },
            data: {
                password: hashedNewPassword,
                resetPasswordToken: null, // Limpiar token
                resetPasswordExpires: null, // Limpiar expiraci√≥n
            },
        });
        console.log(`[PWD_RESET SVC] Password reset successful for user ${userToUpdate.id}`);
    } catch (error) {
        console.error(`[PWD_RESET SVC] Failed to update password for user ${userToUpdate.id}:`, error);
        throw new Error('Error al actualizar la contrase√±a.'); // Error m√°s espec√≠fico para el frontend
    }
};

// End of File: backend/src/auth/password-reset.service.ts


// ====== [91] backend/src/shared/auth/registration.controller.ts ======
// filename: backend/src/auth/registration.controller.ts
// Version: 1.0.2 (Remove Swagger annotations)

import { Request, Response } from 'express';
import { Prisma, DocumentType, User } from '@prisma/client';

// DTOs necesarios para registro
import { RegisterUserDto, RegisterBusinessDto } from './auth.dto';
// Utils de Validaci√≥n
import { isValidDni, isValidNie, isValidPhoneNumber } from '../utils/validation';

// Servicios necesarios
import { findUserByEmail, generateToken } from './auth.service';
import { createUser, createBusinessAndAdmin } from './registration.service';

// SIN ANOTACI√ìN @openapi
export const register = async (req: Request, res: Response) => {
    const { email, password, name, phone, documentId, documentType, businessId, role }: RegisterUserDto = req.body;

    if (!email || !password || !phone || !documentId || !documentType || !businessId || !role || role !== 'CUSTOMER_FINAL') {
        return res.status(400).json({ message: 'Faltan campos obligatorios o rol inv√°lido para registro de cliente.' });
    }

    try {
        const existingUser = await findUserByEmail(email);
        if (existingUser) {
            return res.status(409).json({ message: 'El email ya est√° registrado.' });
        }

        if (!isValidPhoneNumber(phone)) {
             return res.status(400).json({ message: 'Formato de tel√©fono inv√°lido.' });
        }
        let isDocumentValid = false;
        const upperDocumentId = documentId.toUpperCase();
        switch (documentType) {
            case DocumentType.DNI: isDocumentValid = isValidDni(upperDocumentId); break;
            case DocumentType.NIE: isDocumentValid = isValidNie(upperDocumentId); break;
            case DocumentType.PASSPORT: isDocumentValid = upperDocumentId.trim().length > 3; break;
            case DocumentType.OTHER: isDocumentValid = upperDocumentId.trim().length > 0; break;
            default: return res.status(400).json({ message: 'Tipo de documento inv√°lido.' });
        }
        if (!isDocumentValid) { return res.status(400).json({ message: `Formato de ${documentType} inv√°lido.` }); }

        const userDataForService: RegisterUserDto = {
             email, password, name, phone,
             documentId: upperDocumentId, // Enviar normalizado
             documentType, businessId, role
        };
        const newUser = await createUser(userDataForService);

        const {
            password: _password,
            documentId: _documentId,
            resetPasswordToken: _resetToken,
            resetPasswordExpires: _resetExpires,
            ...userWithoutSensitiveData
        } = newUser;
        console.log(`[REG CTRL] Customer registration successful for user ${newUser.id}. Sending 201.`);
        res.status(201).json({ user: userWithoutSensitiveData });
    } catch (error) {
        if (error instanceof Error && (error.message.includes('tel√©fono') || error.message.includes('documento') || error.message.includes('Business with ID') || error.message.includes('ya est√° registrado'))) {
             return res.status(409).json({ message: error.message });
        }
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            const target = (error.meta?.target as string[])?.join(', ');
            console.error(`[REG CTRL] Registration failed: Unique constraint DB error on ${target}.`);
            return res.status(409).json({ message: `Error de unicidad en ${target}` });
        }
        console.error('[REG CTRL] Error during customer registration:', error);
        res.status(500).json({ message: 'Error del servidor durante el registro.' });
    }
};


// SIN ANOTACI√ìN @openapi
export const registerBusinessHandler = async (req: Request, res: Response) => {
    const { businessName, adminEmail, adminPassword, adminName }: RegisterBusinessDto = req.body;
    console.log(`[REG CTRL] Attempting business registration for: ${businessName} / ${adminEmail}`);

    if (!businessName || !adminEmail || !adminPassword) {
        return res.status(400).json({ message: 'Nombre del negocio, email del administrador y contrase√±a son requeridos.' });
    }
    if (businessName.trim().length < 2) {
        return res.status(400).json({ message: 'El nombre del negocio debe tener al menos 2 caracteres.' });
    }
    if (adminPassword.length < 6) {
        return res.status(400).json({ message: 'La contrase√±a debe tener al menos 6 caracteres.' });
    }

    try {
        const newAdminUser = await createBusinessAndAdmin({
            businessName: businessName.trim(),
            adminEmail,
            adminPassword,
            adminName: adminName?.trim()
        });
        const token = generateToken(newAdminUser as User);

        console.log(`[REG CTRL] Business registration successful for ${newAdminUser.email}. Sending 201.`);
        res.status(201).json({
            user: newAdminUser,
            token: token
        });
    } catch (error: any) {
        console.error('[REG CTRL] Error during business registration:', error);
        if (error instanceof Error) {
             if (error.message.includes('El email proporcionado ya est√° registrado') ||
                 error.message.includes('Ya existe un negocio con un nombre similar')) {
                 return res.status(409).json({ message: error.message });
             }
              if (error.message.includes('nombre del negocio') || error.message.includes('Error de base de datos')) {
                   return res.status(400).json({ message: error.message });
              }
        }
        res.status(500).json({ message: error.message || 'Error del servidor durante el registro del negocio.' });
    }
};

// End of File: backend/src/auth/registration.controller.ts


// ====== [92] backend/src/shared/auth/registration.service.ts ======
// backend/src/shared/auth/registration.service.ts (CORREGIDO)
import { PrismaClient, User, UserRole, DocumentType, Prisma, Business } from '@prisma/client';
import { RegisterUserDto, RegisterBusinessDto } from './auth.dto';
import { hashPassword, findUserByEmail } from './auth.service';

// --- RUTA CORREGIDA ---
import { updateUserTier } from '../../modules/loyalpyme/tiers/tier-logic.service';
// --- FIN RUTA CORREGIDA ---

const prisma = new PrismaClient();

export const createUser = async (userData: RegisterUserDto): Promise<User> => {
    console.log(`[REG SVC] Creating CUSTOMER user: ${userData.email}`);
    const businessExists = await prisma.business.findUnique({ where: { id: userData.businessId } });
    if (!businessExists) {
        throw new Error(`Business with ID ${userData.businessId} not found.`);
    }
    if (userData.phone) {
        const existingPhone = await prisma.user.findUnique({ where: { phone: userData.phone }, select: { id: true } });
        if (existingPhone) throw new Error('El tel√©fono ya est√° registrado.');
    } else {
        throw new Error('El tel√©fono es un campo obligatorio para clientes.');
    }
    if (userData.documentId) {
        const existingDocument = await prisma.user.findUnique({ where: { documentId: userData.documentId }, select: { id: true } });
        if (existingDocument) throw new Error('El documento de identidad ya est√° registrado.');
    } else {
        throw new Error('El documento de identidad es un campo obligatorio para clientes.');
    }
    console.log(`[REG SVC] Uniqueness checks passed for ${userData.email}. Hashing password...`);

    const hashedPassword = await hashPassword(userData.password);
    let newUser: User | null = null;

    try {
        newUser = await prisma.user.create({
            data: {
                email: userData.email,
                password: hashedPassword,
                name: userData.name,
                phone: userData.phone,
                documentId: userData.documentId,
                documentType: userData.documentType,
                role: UserRole.CUSTOMER_FINAL,
                business: {
                    connect: { id: userData.businessId }
                }
            },
        });
        console.log(`[REG SVC] Customer user created successfully with ID: ${newUser.id}`);

        try {
             console.log(`[REG SVC] Attempting initial tier assignment for new user: ${newUser.id}`);
             await updateUserTier(newUser.id);
             console.log(`[REG SVC] Initial tier assignment process completed for user: ${newUser.id}`);
        } catch (tierError: any) {
            console.error(`[REG SVC] WARNING: Failed to assign initial tier for user ${newUser.id}. Tier can be updated later. Error:`, tierError);
        }

        return newUser;

    } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
            const target = (error.meta?.target as string[])?.join(', ');
            console.error(`[REG SVC] Customer creation failed: Unique constraint DB error on ${target}.`);
            if (target?.includes('email')) throw new Error('El email ya est√° registrado.');
            if (target?.includes('phone')) throw new Error('El tel√©fono ya est√° registrado.');
            if (target?.includes('documentId')) throw new Error('El documento de identidad ya est√° registrado.');
            throw new Error(`Conflicto de unicidad en ${target}.`);
        }
        console.error(`[REG SVC] Unexpected error creating customer ${userData.email}:`, error);
        throw new Error('Error inesperado al crear el usuario cliente.');
    }
};

const generateSlug = (name: string): string => {
    return name
        .toLowerCase()
        .trim()
        .replace(/[^\w\s-]/g, '')
        .replace(/[\s_-]+/g, '-')
        .replace(/^-+|-+$/g, '');
};

export const createBusinessAndAdmin = async (
    data: RegisterBusinessDto
): Promise<Omit<User, 'password'>> => {
    console.log('[REG SVC] Attempting to create business and admin:', data.businessName, data.adminEmail);

    const existingUser = await findUserByEmail(data.adminEmail);
    if (existingUser) {
        console.warn(`[REG SVC] Admin email ${data.adminEmail} already exists.`);
        throw new Error('El email proporcionado ya est√° registrado.');
    }

    const slug = generateSlug(data.businessName);
    if (!slug) {
        console.error(`[REG SVC] Could not generate slug from business name: ${data.businessName}`);
        throw new Error('El nombre del negocio proporcionado no es v√°lido para generar un identificador.');
    }
    const existingBusiness = await prisma.business.findUnique({
        where: { slug: slug },
        select: { id: true }
    });
    if (existingBusiness) {
        console.warn(`[REG SVC] Business slug ${slug} already exists.`);
        throw new Error(`Ya existe un negocio con un nombre similar ('${slug}'). Por favor, elige otro nombre.`);
    }

    const hashedPassword = await hashPassword(data.adminPassword);

    try {
        console.log(`[REG SVC] Starting transaction to create business '${data.businessName}' (slug: ${slug}) and admin '${data.adminEmail}'`);
        const newUser = await prisma.$transaction(async (tx) => {
            const newBusiness = await tx.business.create({
                data: {
                    name: data.businessName,
                    slug: slug,
                },
                select: { id: true }
            });
            console.log(`[REG SVC - TX] Business created with ID: ${newBusiness.id}`);

            const adminUser = await tx.user.create({
                data: {
                    email: data.adminEmail,
                    password: hashedPassword,
                    name: data.adminName,
                    role: UserRole.BUSINESS_ADMIN,
                    businessId: newBusiness.id,
                }
            });
            console.log(`[REG SVC - TX] Admin user created with ID: ${adminUser.id} for business ${newBusiness.id}`);
            return adminUser;
        });

        const { password, ...userWithoutPassword } = newUser;
        console.log(`[REG SVC] Business and admin creation successful for ${data.adminEmail}.`);
        return userWithoutPassword;

    } catch (error) {
        console.error('[REG SVC] Error during business/admin creation transaction:', error);
        if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2002') {
             const target = (error.meta?.target as string[])?.join(', ');
             console.error(`[REG SVC] Unique constraint failed on: ${target}`);
             throw new Error(`Error de base de datos: Conflicto de unicidad en ${target}.`);
        }
        throw new Error('No se pudo completar el registro del negocio. Error interno del servidor.');
    }
};


// ====== [93] backend/src/shared/businesses/businesses.controller.ts ======
// filename: backend/src/businesses/businesses.controller.ts
// Version: 1.0.0

import { Request, Response, NextFunction } from 'express';
// Importamos la funci√≥n del servicio que acabamos de crear
import { findPublicBusinesses, PublicBusinessInfo } from './businesses.service'; // Usamos ruta relativa './'

/**
 * Handler para obtener la lista p√∫blica de negocios (ID y Nombre).
 * GET /api/businesses/public-list (o la ruta que definamos)
 * No requiere autenticaci√≥n.
 */
export const handleGetPublicBusinesses = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
  console.log('[BusinessController] Solicitud de lista p√∫blica de negocios...');

  try {
    // Llamamos a la funci√≥n del servicio para obtener los datos
    const businesses: PublicBusinessInfo[] = await findPublicBusinesses();

    // Enviamos la respuesta exitosa con la lista de negocios
    res.status(200).json(businesses);
    console.log('[BusinessController] Lista p√∫blica de negocios enviada.');

  } catch (error) {
    // Si el servicio lanza un error, lo pasamos al manejador de errores global
    console.error('[BusinessController] Error al obtener lista p√∫blica de negocios:', error);
    next(error);
  }
};

// Aqu√≠ podr√≠an ir otros handlers del controlador relacionados con Business en el futuro
// (ej: getBusinessDetails, updateBusinessSettings - que s√≠ requerir√≠an autenticaci√≥n/rol)

// End of file: backend/src/businesses/businesses.controller.ts


// ====== [94] backend/src/shared/businesses/businesses.service.ts ======
// filename: backend/src/businesses/businesses.service.ts
// Version: 1.0.2 (Remove obsolete comments)

import { PrismaClient, Prisma } from '@prisma/client';

const prisma = new PrismaClient();

/**
 * Define la estructura de datos devuelta para la lista p√∫blica de negocios.
 */
export interface PublicBusinessInfo {
  id: string;
  name: string;
}

/**
 * Busca y devuelve una lista de negocios (solo ID y Nombre) para mostrar p√∫blicamente.
 * Por ahora, devuelve todos los negocios ordenados por nombre.
 * En el futuro, se podr√≠a filtrar por negocios activos o verificados si fuera necesario.
 *
 * @returns Una promesa que resuelve con un array de objetos PublicBusinessInfo.
 * @throws Error si ocurre un problema al consultar la base de datos.
 */
export const findPublicBusinesses = async (): Promise<PublicBusinessInfo[]> => {
  console.log('[BusinessService] Buscando lista p√∫blica de negocios...');
  try {
    const businesses = await prisma.business.findMany({
      select: {
        id: true,
        name: true,
      },
      orderBy: {
        name: 'asc',
      },
    });
    console.log(`[BusinessService] Encontrados ${businesses.length} negocios.`);
    return businesses;
  } catch (error) {
    console.error('[BusinessService] Error al buscar negocios p√∫blicos:', error);
    throw new Error('No se pudo obtener la lista de negocios.');
  }
};

// End of file: backend/src/businesses/businesses.service.ts


// ====== [95] backend/src/shared/middleware/auth.middleware.ts ======
// backend/src/middleware/auth.middleware.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { PrismaClient, UserRole, Prisma, User } from '@prisma/client'; // User ya estaba importado

const prisma = new PrismaClient();
const JWT_SECRET = process.env.JWT_SECRET as string;

if (!JWT_SECRET) {
    console.error('FATAL ERROR: JWT_SECRET is not defined in auth.middleware.');
    // Considerar process.exit(1) en un escenario real si esto es cr√≠tico
}

// Definici√≥n de req.user (Aseg√∫rate de que este tipo global ya incluya los nuevos campos o aj√∫stalo)
// Esta declaraci√≥n ya estaba en tu archivo original, la adaptamos.
declare global {
    namespace Express {
        interface Request {
            user?: {
                id: string;
                email: string;
                role: UserRole;
                businessId: string | null;
                isActive: boolean;
                name?: string | null;
                points?: number;
                totalSpend?: number;
                totalVisits?: number;
                currentTier?: { id: string; name: string; benefits: any[]; } | null; // 'any[]' para benefits es gen√©rico, considera tiparlo mejor si es posible
                
                // Flags del negocio
                businessIsActive?: boolean;
                isLoyaltyCoreActive?: boolean;
                isCamareroActive?: boolean;

                // --- NUEVOS CAMPOS PARA EL NEGOCIO ---
                businessName?: string | null;
                businessSlug?: string | null;
                businessLogoUrl?: string | null;
                // --- FIN NUEVOS CAMPOS ---
            };
        }
    }
}

export const authenticateToken = async (req: Request, res: Response, next: NextFunction) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (token == null) {
        console.log('[AUTH MIDDLEWARE] No token provided. Sending 401.');
        return res.sendStatus(401);
    }

    jwt.verify(token, JWT_SECRET, async (err: any, payload: any) => {
        if (err || !payload || !payload.userId || !payload.role) {
            console.error('[AUTH MIDDLEWARE] JWT verification failed or invalid payload:', { err, payload_userId: payload?.userId, payload_role: payload?.role });
            return res.sendStatus(403); // Token inv√°lido o corrupto
        }
        // console.log('[AUTH MIDDLEWARE DEBUG] JWT Payload OK:', payload);

        try {
            // Define el tipo de selecci√≥n para Prisma, incluyendo campos del negocio
            const userProfileSelect: Prisma.UserSelect = {
                id: true,
                email: true,
                role: true,
                businessId: true, // Necesario para la l√≥gica de negocio y para obtener los detalles del negocio
                isActive: true,
                name: true,
            };

            // Si el usuario tiene un businessId (es decir, no es SUPER_ADMIN que no tiene businessId directo)
            if (payload.businessId) {
                // console.log('[AUTH MIDDLEWARE DEBUG] Payload has businessId, selecting business data...');
                userProfileSelect.business = { // Seleccionar la relaci√≥n 'business'
                    select: {
                        isActive: true,
                        isLoyaltyCoreActive: true,
                        isCamareroActive: true,
                        name: true,         // <--- A√ëADIDO
                        slug: true,         // <--- A√ëADIDO
                        logoUrl: true,      // <--- A√ëADIDO (Opcional, pero √∫til para el header)
                    }
                };
            }

            // Si el rol es CUSTOMER_FINAL y tiene businessId (para asegurar que no se intente para SUPER_ADMIN)
            if (payload.role === UserRole.CUSTOMER_FINAL && payload.businessId) {
                // console.log('[AUTH MIDDLEWARE DEBUG] Role is CUSTOMER_FINAL, selecting LCo specific fields...');
                userProfileSelect.points = true;
                userProfileSelect.totalSpend = true;
                userProfileSelect.totalVisits = true;
                userProfileSelect.currentTier = {
                    select: {
                        id: true,
                        name: true,
                        benefits: { // Considerar si realmente se necesitan todos los beneficios aqu√≠
                            where: { isActive: true },
                            select: { id: true, type: true, value: true, description: true }
                        }
                    }
                };
            } else if (payload.role !== UserRole.SUPER_ADMIN && !payload.businessId) {
                 // Esto es un caso an√≥malo: un rol que no es SUPER_ADMIN deber√≠a tener un businessId.
                 console.error(`[AUTH MIDDLEWARE] User role ${payload.role} requires a businessId, but none found for user ${payload.userId}. Denying access.`);
                 return res.sendStatus(403); // Prohibido
            }
            // console.log('[AUTH MIDDLEWARE DEBUG] Prisma User Select Query:', JSON.stringify(userProfileSelect, null, 2));

            const userFromDb = await prisma.user.findUnique({
                where: { id: payload.userId },
                select: userProfileSelect
            });
            // console.log('[AUTH MIDDLEWARE DEBUG] User fetched from DB:', JSON.stringify(userFromDb, null, 2));

            if (!userFromDb || !userFromDb.isActive) {
                console.log(`[AUTH MIDDLEWARE] User ${payload.userId} not found or not active in DB. Sending 403.`);
                return res.sendStatus(403); // Usuario no encontrado o inactivo
            }

            // Extraer datos del negocio si existen en el usuario cargado
            // @ts-ignore Prisma genera el tipo `business` en `userFromDb` si se incluy√≥ en el select
            const businessDataFromDb = userFromDb.business;
            // console.log('[AUTH MIDDLEWARE DEBUG] Business data from DB relation:', JSON.stringify(businessDataFromDb, null, 2));


            // Si el usuario no es SUPER_ADMIN y su negocio asociado NO est√° activo, denegar acceso
            if (userFromDb.role !== UserRole.SUPER_ADMIN && businessDataFromDb && !businessDataFromDb.isActive) {
                console.log(`[AUTH MIDDLEWARE] Business ${userFromDb.businessId} for user ${userFromDb.id} is not active. Denying access.`);
                return res.sendStatus(403); // Negocio inactivo
            }
            
            // Construir el objeto req.user
            const reqUserObject: Express.Request['user'] = {
                id: userFromDb.id,
                email: userFromDb.email,
                role: userFromDb.role,
                businessId: userFromDb.businessId,
                isActive: userFromDb.isActive,
                name: userFromDb.name,
            };

            // A√±adir campos espec√≠ficos de LCo si es CUSTOMER_FINAL
            if (userFromDb.role === UserRole.CUSTOMER_FINAL) {
                // @ts-ignore
                reqUserObject.points = userFromDb.points;
                // @ts-ignore
                reqUserObject.totalSpend = userFromDb.totalSpend;
                // @ts-ignore
                reqUserObject.totalVisits = userFromDb.totalVisits;
                // @ts-ignore
                reqUserObject.currentTier = userFromDb.currentTier ?? null;
            }

            // A√±adir flags y detalles del negocio si existen
            if (businessDataFromDb) {
                reqUserObject.businessIsActive = businessDataFromDb.isActive;
                reqUserObject.isLoyaltyCoreActive = businessDataFromDb.isLoyaltyCoreActive;
                reqUserObject.isCamareroActive = businessDataFromDb.isCamareroActive;
                reqUserObject.businessName = businessDataFromDb.name;           // <--- A√ëADIDO
                reqUserObject.businessSlug = businessDataFromDb.slug;           // <--- A√ëADIDO
                reqUserObject.businessLogoUrl = businessDataFromDb.logoUrl;     // <--- A√ëADIDO
            } else if (userFromDb.role !== UserRole.SUPER_ADMIN && payload.businessId) {
                // Caso borde: El token ten√≠a businessId, pero no se pudo cargar la info del negocio.
                // Esto podr√≠a indicar un problema de datos (ej. negocio borrado pero usuario a√∫n lo referencia).
                // Por seguridad, podr√≠amos denegar o loguear y continuar con flags undefined/null.
                console.warn(`[AUTH MIDDLEWARE] Business data for businessId ${payload.businessId} was expected but not found for user ${userFromDb.id}. Module flags and business details will be undefined.`);
            }
            
            req.user = reqUserObject; // Asignar el objeto construido a req.user
            
            // console.log('[AUTH MIDDLEWARE DEBUG] Final req.user object being set:', JSON.stringify(req.user, null, 2));
            console.log(`[AUTH MIDDLEWARE] User ${req.user.id} (Role: ${req.user.role}, BizId: ${req.user.businessId || 'N/A'}, BizSlug: ${req.user.businessSlug || 'N/A'}) authenticated.`);

            next();
        } catch (dbError) {
            console.error('[AUTH MIDDLEWARE] Database error during user/business fetch:', dbError);
            delete req.user; // Limpiar req.user en caso de error
            res.status(500).json({ message: 'Server error during authentication process.' });
        }
    });
};


// ====== [96] backend/src/shared/middleware/module.middleware.ts ======
// backend/src/middleware/module.middleware.ts
import { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

// Definimos los c√≥digos de m√≥dulo que usaremos.
// Podr√≠as expandir esto o usar un Enum de Prisma si los m√≥dulos se vuelven m√°s complejos.
export type ModuleCode = 'LOYALTY_CORE' | 'CAMARERO';

/**
 * Middleware factory para verificar si un m√≥dulo espec√≠fico est√° activo para el negocio
 * del usuario autenticado.
 *
 * @param moduleCode El c√≥digo del m√≥dulo a verificar.
 * @returns Una funci√≥n middleware de Express.
 */
export const checkModuleActive = (moduleCode: ModuleCode) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    // Asumimos que authenticateToken ya se ejecut√≥ y req.user y req.user.businessId existen.
    // El rol ya deber√≠a haber sido verificado por checkRole si es necesario para la ruta.
    if (!req.user || !req.user.businessId) {
      console.warn('[ModuleMiddleware] User or businessId missing from request. Is authenticateToken running first?');
      return res.status(403).json({ message: 'Acceso denegado. No se pudo identificar el negocio para la verificaci√≥n del m√≥dulo.' });
    }

    const businessId = req.user.businessId;

    try {
      const business = await prisma.business.findUnique({
        where: { id: businessId },
        select: {
          isLoyaltyCoreActive: true,
          isCamareroActive: true,
          // Podr√≠amos seleccionar tambi√©n business.isActive aqu√≠ si quisi√©ramos
          // que un m√≥dulo no funcione si el negocio entero est√° inactivo,
          // pero eso se puede manejar en checkRole o un middleware de estado de negocio.
        }
      });

      if (!business) {
        // Esto ser√≠a raro si el token es v√°lido y tiene un businessId.
        console.warn(`[ModuleMiddleware] Business with ID ${businessId} not found during module check.`);
        return res.status(404).json({ message: 'Negocio asociado no encontrado.' });
      }

      let moduleIsCurrentlyActive = false;
      if (moduleCode === 'LOYALTY_CORE') {
        moduleIsCurrentlyActive = business.isLoyaltyCoreActive;
      } else if (moduleCode === 'CAMARERO') {
        moduleIsCurrentlyActive = business.isCamareroActive;
      } else {
        // C√≥digo de m√≥dulo desconocido, por seguridad denegar.
        console.error(`[ModuleMiddleware] Unknown moduleCode specified: ${moduleCode}`);
        return res.status(500).json({ message: 'Error interno: C√≥digo de m√≥dulo no reconocido.' });
      }

      if (moduleIsCurrentlyActive) {
        next(); // El m√≥dulo est√° activo, continuar.
      } else {
        console.log(`[ModuleMiddleware] Access denied. Module '${moduleCode}' is not active for business ${businessId}.`);
        return res.status(403).json({ message: `Acceso denegado. El m√≥dulo ${moduleCode} no est√° activo para este negocio.` });
      }
    } catch (error) {
      console.error(`[ModuleMiddleware] Error checking module '${moduleCode}' for business ${businessId}:`, error);
      return res.status(500).json({ message: 'Error interno al verificar el estado del m√≥dulo.' });
    }
  };
};


// ====== [97] backend/src/shared/middleware/multer.config.ts ======
// filename: backend/src/middleware/multer.config.ts
// Version: 1.0.0 (Initial Multer configuration for image uploads)

import multer, { FileFilterCallback } from 'multer';
import { Request } from 'express';

// Tipos de archivo permitidos (MIME types)
const ALLOWED_MIMETYPES = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
// L√≠mite de tama√±o (ej. 5MB)
const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5 MB in bytes

// Configuraci√≥n de almacenamiento en memoria
const storage = multer.memoryStorage();

// Funci√≥n de filtro de archivos
const fileFilter = (
    req: Request,
    file: Express.Multer.File,
    cb: FileFilterCallback
) => {
    console.log(`[Multer Filter] Checking file: ${file.originalname}, MIME type: ${file.mimetype}`);
    if (ALLOWED_MIMETYPES.includes(file.mimetype)) {
        // Aceptar el archivo
        console.log(`[Multer Filter] File type ${file.mimetype} accepted.`);
        cb(null, true);
    } else {
        // Rechazar el archivo
        console.warn(`[Multer Filter] File type ${file.mimetype} rejected.`);
        // Pasamos un error para que pueda ser manejado por el controlador/manejador de errores
        cb(new Error('Tipo de archivo no permitido. Solo se aceptan im√°genes (jpeg, png, webp, gif).'));
        // Alternativa: cb(null, false); // Simplemente rechaza sin error expl√≠cito
    }
};

// Crear la instancia de Multer configurada
const upload = multer({
    storage: storage,
    fileFilter: fileFilter,
    limits: {
        fileSize: MAX_FILE_SIZE, // L√≠mite de 5MB
    },
});

// Exportar la instancia configurada (espec√≠ficamente para manejar un solo archivo llamado 'image')
// Usaremos upload.single('imageField') en la ruta. El nombre 'imageField' debe coincidir
// con el nombre del campo que env√≠a el frontend en el FormData.
// Exportamos la instancia base para usarla en la ruta.
export default upload;

// End of File: backend/src/middleware/multer.config.ts


// ====== [98] backend/src/shared/middleware/role.middleware.ts ======
// filename: backend/src/middleware/role.middleware.ts
// Version: 1.0.1 (Remove verbose log and inline comments)

import { Request, Response, NextFunction } from 'express';
import { UserRole } from '@prisma/client';

/**
 * Middleware factory para verificar si el rol del usuario autenticado
 * est√° incluido en la lista de roles permitidos.
 *
 * @param allowedRoles Un array de UserRole permitidos para la ruta.
 * @returns Una funci√≥n middleware de Express.
 */
export const checkRole = (allowedRoles: UserRole[]) => {
    return (req: Request, res: Response, next: NextFunction) => {
        // Verifica que authenticateToken haya adjuntado un usuario con rol
        if (!req.user || !req.user.role) {
            console.warn('[Role Middleware] User or user role not found on request. Is authenticateToken running first?');
            return res.status(403).json({ message: 'Acceso denegado: Autenticaci√≥n requerida o rol no disponible.' });
        }

        const userRole = req.user.role;
        // console.log(`[Role Middleware] Checking role: User has '${userRole}', Allowed: [${allowedRoles.join(', ')}] for route ${req.originalUrl}`); // Log eliminado por verbosidad

        // Comprueba si el rol est√° permitido
        if (allowedRoles.includes(userRole)) {
            next(); // Rol permitido, continuar
        } else {
            // Rol no permitido
            console.warn(`[Role Middleware] Access Forbidden for role '${userRole}' on route ${req.originalUrl}. Allowed: [${allowedRoles.join(', ')}]`);
            res.status(403).json({ message: 'Acceso denegado: Permisos insuficientes.' });
        }
    };
};

// End of File: backend/src/middleware/role.middleware.ts


// ====== [99] backend/src/shared/services/loyalty-points.service.ts ======
// backend/src/shared/services/loyalty-points.service.ts (CORREGIDO)
import {
    PrismaClient,
    Prisma,
    Order,
    User,
    Business,
    ActivityType,
    TierBenefit,
} from '@prisma/client';
import { Logger, InternalServerErrorException } from '@nestjs/common';
// --- RUTA CORREGIDA ---
import { updateUserTier } from '../../modules/loyalpyme/tiers/tier-logic.service';
// --- FIN RUTA CORREGIDA ---

type OrderForLoyalty = Pick<Order, 'id' | 'orderNumber' | 'finalAmount' | 'totalAmount' | 'customerLCoId' | 'businessId'>;
type CustomerForLoyalty = User & {
    currentTier?: ({ benefits: Pick<TierBenefit, 'type' | 'value' | 'isActive'>[] } & { id: string; name: string }) | null;
};
type BusinessForLoyalty = Pick<Business, 'id' | 'pointsPerEuro' | 'isLoyaltyCoreActive'>;


export class LoyaltyPointsService {
    private readonly logger = new Logger(LoyaltyPointsService.name);

    async awardPointsForLcOrder(
        tx: Prisma.TransactionClient,
        order: OrderForLoyalty,
        customer: CustomerForLoyalty,
        business: BusinessForLoyalty
    ): Promise<{ pointsAwarded: number } | null> {
        if (!order.customerLCoId) {
            this.logger.warn(`[LoyaltyPointsService] Order ${order.id} has no customerLCoId. No points to award.`);
            return null;
        }
        if (!business.isLoyaltyCoreActive) {
            this.logger.log(`[LoyaltyPointsService] LoyaltyCore module is not active for business ${business.id}. Skipping points for order ${order.id}.`);
            return null;
        }
        if (customer.id !== order.customerLCoId) {
             this.logger.error(`[LoyaltyPointsService] Mismatch: Order customerLCoId ${order.customerLCoId} vs provided customer ID ${customer.id}. Aborting points.`);
             throw new InternalServerErrorException("Discrepancia en IDs de cliente al otorgar puntos.");
        }

        this.logger.log(`[LoyaltyPointsService TX] Processing LCo points for customer ${customer.id} (Order: ${order.id}, Business: ${business.id})`);

        const orderAmountForPoints = order.finalAmount ?? order.totalAmount;
        let pointsToEarnDecimal = new Prisma.Decimal(orderAmountForPoints).mul(business.pointsPerEuro ?? 1);

        const multiplierBenefit = customer.currentTier?.benefits.find(
            b => b.type === 'POINTS_MULTIPLIER' && b.isActive
        );

        if (multiplierBenefit?.value) {
            const multiplier = parseFloat(multiplierBenefit.value);
            if (!isNaN(multiplier) && multiplier > 0) {
                pointsToEarnDecimal = pointsToEarnDecimal.mul(multiplier);
                this.logger.log(`[LoyaltyPointsService TX] Applied tier '${customer.currentTier?.name}' multiplier ${multiplier} for LCo points.`);
            } else {
                this.logger.warn(`[LoyaltyPointsService TX] Invalid LCo tier multiplier value '${multiplierBenefit.value}' for user ${customer.id} on tier '${customer.currentTier?.name}'.`);
            }
        }

        const finalPointsToAward = Math.floor(pointsToEarnDecimal.toNumber());

        if (finalPointsToAward <= 0) {
            this.logger.log(`[LoyaltyPointsService TX] No LCo points to award (calculated ${finalPointsToAward}) for customer ${customer.id} on order ${order.id}.`);
            return { pointsAwarded: 0 };
        }

        try {
            await tx.user.update({
                where: { id: customer.id },
                data: {
                    points: { increment: finalPointsToAward },
                    totalSpend: { increment: orderAmountForPoints.toNumber() },
                    totalVisits: { increment: 1 },
                    lastActivityAt: new Date(),
                },
            });
            this.logger.log(`[LoyaltyPointsService TX] Customer ${customer.id} updated: +${finalPointsToAward} points, +${orderAmountForPoints} spend, +1 visit.`);

            await tx.activityLog.create({
                data: {
                    userId: customer.id,
                    businessId: business.id,
                    type: ActivityType.POINTS_EARNED_ORDER_LC,
                    pointsChanged: finalPointsToAward,
                    description: `Puntos por pedido LC #${order.orderNumber}`,
                    relatedOrderId: order.id,
                },
            });
            this.logger.log(`[LoyaltyPointsService TX] ActivityLog created for order ${order.id}, user ${customer.id}.`);

            updateUserTier(customer.id).catch((tierError: any) => {
                this.logger.error(`[LoyaltyPointsService] Background tier update failed for customer ${customer.id} after LC order points:`, tierError);
            });
            this.logger.log(`[LoyaltyPointsService] Tier update process initiated for customer ${customer.id}.`);

            return { pointsAwarded: finalPointsToAward };

        } catch (error) {
            this.logger.error(`[LoyaltyPointsService TX] Error during points awarding transaction for order ${order.id}, customer ${customer.id}:`, error);
            return null;
        }
    }
}


// ====== [100] backend/src/shared/services/table.service.ts ======
// backend/src/services/table.service.ts (o backend/src/camarero/table.service.ts si prefieres)
import {
    PrismaClient,
    Prisma,
    Table,
    TableStatus,
} from '@prisma/client';
import {
    Logger,
    NotFoundException,
    InternalServerErrorException,
} from '@nestjs/common';

export class TableService {
    private readonly logger = new Logger(TableService.name);

    /**
     * Encuentra una mesa por su identificador y el ID del negocio.
     *
     * @param tx - Cliente Prisma de la transacci√≥n actual.
     * @param businessId - ID del negocio.
     * @param tableIdentifier - Identificador de la mesa (ej. "M1", "T2").
     * @returns El objeto Table si se encuentra, o null si no.
     */
    async findTableByIdentifier(
        tx: Prisma.TransactionClient,
        businessId: string,
        tableIdentifier: string
    ): Promise<Table | null> {
        this.logger.log(`[TableService] Finding table with identifier '${tableIdentifier}' for business '${businessId}'.`);
        try {
            const table = await tx.table.findUnique({
                where: {
                    businessId_identifier: {
                        businessId: businessId,
                        identifier: tableIdentifier,
                    },
                },
            });
            if (table) {
                this.logger.log(`[TableService] Table '${tableIdentifier}' found with ID '${table.id}'.`);
            } else {
                this.logger.warn(`[TableService] Table '${tableIdentifier}' not found for business '${businessId}'.`);
            }
            return table;
        } catch (error) {
            this.logger.error(`[TableService] Error finding table '${tableIdentifier}':`, error);
            throw new InternalServerErrorException('Error al buscar la mesa en la base de datos.');
        }
    }

    /**
     * Actualiza el estado de una mesa espec√≠fica.
     *
     * @param tx - Cliente Prisma de la transacci√≥n actual.
     * @param tableId - ID de la mesa a actualizar.
     * @param newStatus - El nuevo TableStatus para la mesa.
     * @returns El objeto Table actualizado.
     * @throws NotFoundException si la mesa no existe.
     */
    async updateTableStatus(
        tx: Prisma.TransactionClient,
        tableId: string,
        newStatus: TableStatus
    ): Promise<Table> {
        this.logger.log(`[TableService] Updating status of table '${tableId}' to '${newStatus}'.`);
        try {
            // Primero, verificar si la mesa existe para dar un error m√°s claro si no.
            // Esto podr√≠a ser redundante si la operaci√≥n que llama ya verific√≥, pero es una salvaguarda.
            const existingTable = await tx.table.findUnique({ where: { id: tableId }, select: { id: true } });
            if (!existingTable) {
                this.logger.warn(`[TableService] Table with ID '${tableId}' not found for status update.`);
                throw new NotFoundException(`Mesa con ID '${tableId}' no encontrada.`);
            }

            const updatedTable = await tx.table.update({
                where: { id: tableId },
                data: { status: newStatus },
            });
            this.logger.log(`[TableService] Table '${tableId}' status successfully updated to '${newStatus}'.`);
            return updatedTable;
        } catch (error) {
            if (error instanceof NotFoundException) throw error; // Relanzar si es nuestro error espec√≠fico
            
            this.logger.error(`[TableService] Error updating status for table '${tableId}':`, error);
            if (error instanceof Prisma.PrismaClientKnownRequestError && error.code === 'P2025') {
                // P2025 = "An operation failed because it depends on one or more records that were required but not found."
                // (Registro para actualizar no encontrado)
                throw new NotFoundException(`Mesa con ID '${tableId}' no encontrada al intentar actualizar estado.`);
            }
            throw new InternalServerErrorException('Error al actualizar el estado de la mesa.');
        }
    }

    // --- Podr√≠as a√±adir m√°s m√©todos aqu√≠ si son necesarios, como: ---
    // async getTableById(tx: Prisma.TransactionClient, tableId: string): Promise<Table | null> { ... }
    // async createTable(tx: Prisma.TransactionClient, businessId: string, data: Prisma.TableCreateWithoutBusinessInput): Promise<Table> { ... }
    // etc.
}


// ====== [101] backend/src/shared/uploads/uploads.controller.ts ======
// filename: backend/src/uploads/uploads.controller.ts
// Version: 1.0.1 (Correct service import path)

import { Request, Response, NextFunction } from 'express';
// --- MODIFICADO: Importar desde 'uploads.service' (plural) ---
import { uploadImageToCloudinary } from './uploads.service';
// --- FIN MODIFICADO ---

/**
 * Maneja la subida de una imagen (generalmente para recompensas).
 * Espera que el middleware Multer (upload.single('image')) se haya ejecutado antes.
 */
export const handleImageUpload = async (req: Request, res: Response, next: NextFunction) => {
    console.log('[Upload CTRL] Received image upload request.');

    // Multer a√±ade 'file' a la request
    if (!req.file) {
        console.error('[Upload CTRL] No file found in req.file. Check field name in client and Multer config.');
        // El campo en Multer y en RewardForm debe ser 'image' seg√∫n c√≥digo anterior
        return res.status(400).json({ message: 'No se recibi√≥ ning√∫n archivo de imagen o el campo no es "image".' });
    }

    if (!req.file.buffer) {
        console.error('[Upload CTRL] File buffer is missing.');
        return res.status(500).json({ message: 'Error interno al procesar el archivo.' });
    }

    // Carpeta en Cloudinary
    const folderName = `loyalpyme/rewards_${process.env.NODE_ENV || 'development'}`;

    try {
        console.log(`[Upload CTRL] Uploading file ${req.file.originalname} (${(req.file.size / 1024).toFixed(1)} KB) to Cloudinary folder '${folderName}'...`);
        const imageUrl = await uploadImageToCloudinary(req.file.buffer, folderName);

        console.log(`[Upload CTRL] Image uploaded successfully. URL: ${imageUrl}`);
        // Devolver la URL (ajustado a como lo espera el form v2.1.0)
        res.status(200).json({
            // message: 'Imagen subida correctamente.', // El form no espera message
            url: imageUrl // El form espera 'url'
        });

    } catch (error) {
        console.error('[Upload CTRL] Error during image upload process:', error);
        next(error); // Pasar al manejador global
    }
};

// End of File: backend/src/uploads/uploads.controller.ts


// ====== [102] backend/src/shared/uploads/uploads.service.ts ======
// filename: backend/src/uploads/upload.service.ts
// Version: 1.0.0 (CORRECTED - Standard Cloudinary upload service with folder)

import cloudinary from '../utils/cloudinary.config'; // Importa config est√°ndar (lee .env)
import streamifier from 'streamifier';
import { UploadApiResponse, UploadApiErrorResponse } from 'cloudinary';

// --- ASEG√öRATE DE QUE LA FIRMA DE LA FUNCI√ìN EST√â AS√ç ---
export const uploadImageToCloudinary = (
    fileBuffer: Buffer,      // <-- Par√°metro para el buffer
    folderName: string       // <-- Par√°metro para la carpeta
): Promise<string> => {
// --- FIN FIRMA ---

    return new Promise((resolve, reject) => {
        // Usamos folderName en el log
        console.log(`[Upload SVC] Attempting to upload image buffer to Cloudinary folder: ${folderName}`);

        const uploadStream = cloudinary.uploader.upload_stream(
            {
                folder: folderName, // <-- Usamos el par√°metro folderName
                resource_type: 'image',
            },
            (error: UploadApiErrorResponse | undefined, result: UploadApiResponse | undefined) => {
                if (error) {
                    console.error('[Upload SVC] Cloudinary upload failed:', error);
                    // Usar un mensaje gen√©rico o el espec√≠fico de Cloudinary
                    reject(new Error(`Error al subir imagen a Cloudinary: ${error.message}`));
                } else if (result) {
                    console.log(`[Upload SVC] Cloudinary upload successful! Secure URL: ${result.secure_url}`);
                    resolve(result.secure_url); // Devuelve la URL segura
                } else {
                    // Caso improbable
                    console.error('[Upload SVC] Cloudinary upload stream finished without error or result.');
                    reject(new Error('La subida a Cloudinary finaliz√≥ sin resultado ni error.'));
                }
            }
        );
        // Usamos fileBuffer para crear el stream de lectura
        streamifier.createReadStream(fileBuffer).pipe(uploadStream);
    });
}; // <-- Aseg√∫rate que la llave de cierre de la funci√≥n est√°

// End of File: backend/src/uploads/upload.service.ts


// ====== [103] backend/src/shared/utils/cloudinary.config.ts ======
// filename: backend/src/utils/cloudinary.config.ts
// Version: 1.0.0 (Standard - Using process.env)
import { v2 as cloudinary } from 'cloudinary';
import dotenv from 'dotenv';
dotenv.config();
const cloudName = process.env.CLOUDINARY_CLOUD_NAME;
const apiKey = process.env.CLOUDINARY_API_KEY;
const apiSecret = process.env.CLOUDINARY_API_SECRET;
if (!cloudName || !apiKey || !apiSecret) {
  console.error("ERROR: Cloudinary environment variables are missing!"); // ... resto del mensaje de error ...
} else {
   console.log("[Cloudinary Config] Credentials found from .env, configuring Cloudinary SDK...");
   cloudinary.config({ cloud_name: cloudName, api_key: apiKey, api_secret: apiSecret, secure: true });
   console.log("[Cloudinary Config] Cloudinary SDK configured successfully from .env.");
}
export default cloudinary;


// ====== [104] backend/src/shared/utils/validation.ts ======
// filename: backend/src/utils/validation.ts
// Version: 1.0.1 (Fix character encoding)

// Contiene funciones de utilidad para validaciones comunes

/**
 * Valida si un string tiene formato de DNI espa√±ol v√°lido.
 * @param dni - El string a validar.
 * @returns true si es v√°lido, false en caso contrario.
 */
export function isValidDni(dni: string): boolean {
    if (!/^\d{8}[A-Z]$/i.test(dni)) {
        return false;
    }
    const numero = parseInt(dni.substring(0, 8), 10);
    const letra = dni.substring(8, 9).toUpperCase();
    const letrasControl = "TRWAGMYFPDXBNJZSQVHLCKE";
    const letraCalculada = letrasControl.charAt(numero % 23);
    return letra === letraCalculada;
}

/**
 * Valida si un string tiene formato de NIE espa√±ol v√°lido.
 * @param nie - El string a validar.
 * @returns true si es v√°lido, false en caso contrario.
 */
export function isValidNie(nie: string): boolean {
    if (!/^[XYZ]\d{7}[A-Z]$/i.test(nie)) {
        return false;
    }
    let numeroStr = nie.substring(1, 8);
    const letraInicial = nie.substring(0, 1).toUpperCase();
    // Reemplazar letra inicial por su equivalente num√©rico para el c√°lculo
    if (letraInicial === 'Y') numeroStr = '1' + numeroStr;
    if (letraInicial === 'Z') numeroStr = '2' + numeroStr;
    // Si es X, se trata como 0, lo cual ya est√° impl√≠cito al no a√±adir prefijo

    const numero = parseInt(numeroStr, 10);
    const letra = nie.substring(8, 9).toUpperCase();
    const letrasControl = "TRWAGMYFPDXBNJZSQVHLCKE";
    const letraCalculada = letrasControl.charAt(numero % 23);
    return letra === letraCalculada;
}

/**
 * Valida si un string tiene formato de n√∫mero de tel√©fono internacional b√°sico.
 * @param phone - El string a validar.
 * @returns true si es v√°lido, false en caso contrario.
 */
export function isValidPhoneNumber(phone: string): boolean {
    // Regex simple: empieza con +, seguido de 9 a 15 d√≠gitos.
    const phoneRegex = /^\+[0-9]{9,15}$/;
    return phoneRegex.test(phone);
}

// Aqu√≠ podr√≠an a√±adirse m√°s funciones de validaci√≥n comunes en el futuro

// End of File: backend/src/utils/validation.ts


// ====== [105] backend/test-server.js ======
// File: backend/test-server.js
// Servidor Express m√≠nimo para pruebas - Puerto 3001

const express = require('express');
const app = express();
const port = 3001; // <-- CAMBIADO A 3001

app.get('/', (req, res) => {
  res.send(`¬°Servidor de prueba m√≠nimo funcionando en puerto ${port}!`);
});

app.listen(port, () => {
  console.log(`Servidor de PRUEBA escuchando en http://localhost:${port}`); // Mensaje actualizado
  console.log('Este proceso DEBER√çA quedarse corriendo. Presiona Ctrl+C para salir.');
});

process.on('exit', (code) => {
  console.log(`[TEST SERVER ${port}] Proceso saliendo con c√≥digo: ${code}`);
});
process.on('beforeExit', (code) => {
    console.log(`[TEST SERVER ${port}] Evento 'beforeExit' detectado con c√≥digo: ${code}`);
});


// ====== [106] backend/tests/integration/auth.test.ts ======
import { describe, it, expect } from 'vitest';
import request from 'supertest';
import app from '../../src/index';

describe('Auth API Integration Tests', () => {

  it('POST /api/auth/login - should login successfully with valid credentials', async () => {
    const credentials = {
      email: 'admin@cafeelsol.com', // Mantenemos este email, corr√≠gelo si es otro
      password: 'superpasswordseguro', // <-- CONTRASE√ëA ACTUALIZADA
    };

    const response = await request(app)
      .post('/api/auth/login')
      .send(credentials)
      .expect('Content-Type', /json/)
      .expect(200);

    expect(response.body).toBeTypeOf('object');
    expect(response.body).toHaveProperty('token');
    expect(response.body).toHaveProperty('user');
    expect(response.body.user).toBeTypeOf('object');
    expect(response.body.user.email).toBe(credentials.email);
    expect(response.body.user).not.toHaveProperty('password');
    expect(response.body.user.role).toBe('BUSINESS_ADMIN');
  });

  it('POST /api/auth/login - should fail with incorrect password', async () => {
    const credentials = {
      email: 'admin@cafeelsol.com', // Usa el email correcto aqu√≠ tambi√©n
      password: 'password123',     // Una contrase√±a incorrecta diferente a la buena
    };
    const response = await request(app)
      .post('/api/auth/login')
      .send(credentials)
      .expect('Content-Type', /json/)
      .expect(401);
    expect(response.body.message).toContain('inv√°lidas');
  });

   it('POST /api/auth/login - should fail with non-existent user', async () => {
    const credentials = {
      email: `no-existe-${Date.now()}@example.com`,
      password: 'somepassword',
    };
    const response = await request(app)
      .post('/api/auth/login')
      .send(credentials)
      .expect('Content-Type', /json/)
      .expect(401);
    expect(response.body.message).toContain('inv√°lidas');
  });

   it('POST /api/auth/login - should fail if email or password is missing', async () => {
     await request(app)
      .post('/api/auth/login')
      .send({ password: 'superpasswordseguro' }) // Contrase√±a correcta pero sin email
      .expect('Content-Type', /json/)
      .expect(400);

     await request(app)
      .post('/api/auth/login')
      .send({ email: 'admin@cafeelsol.com' }) // Email correcto pero sin contrase√±a
      .expect('Content-Type', /json/)
      .expect(400);
   });

});


// ====== [107] backend/tests/integration/points.test.ts ======
import { describe, it, expect, beforeAll, afterAll, vi } from 'vitest';
import request from 'supertest';
import app from '../../src/index';
import { UserRole, DocumentType } from '@prisma/client';

// Helper DNI (sin cambios)
function generateValidDni(): string {
    const num = Math.floor(Math.random() * 100000000);
    const numStr = num.toString().padStart(8, '0');
    const letters = "TRWAGMYFPDXBNJZSQVHLCKE";
    const letter = letters.charAt(parseInt(numStr, 10) % 23);
    return `${numStr}${letter}`;
}


describe('Points API Integration Tests (/api/points)', () => {

    // Variables para guardar estado entre tests
    let customerToken: string | null = null;
    let adminToken: string | null = null;
    let customerUserId: string | null = null; // <-- GUARDAMOS ID DEL CLIENTE CREADO
    let businessId: string | null = null;
    let generatedQrToken: string | null = null; // <-- Guardamos token QR
    const testCustomerEmail = `test-customer-${Date.now()}@test.loyal`;
    const testCustomerPassword = 'password123';
    const testCustomerDni = generateValidDni();

    beforeAll(async () => {
        console.log("Starting beforeAll setup for points tests...");
        // Login Admin
        try { /* ... (c√≥digo login admin sin cambios) ... */
            const adminLoginRes = await request(app).post('/api/auth/login').send({ email: 'admin@cafeelsol.com', password: 'superpasswordseguro' });
            if (adminLoginRes.status === 200 && adminLoginRes.body.token) {
                adminToken = adminLoginRes.body.token;
                businessId = adminLoginRes.body.user?.businessId;
                console.log("Admin logged in, businessId:", businessId);
            } else { throw new Error("Admin login failed in test setup"); }
        } catch (error) { console.error("CRITICAL: Error during admin login setup:", error); throw error; }

        // Crear y Loguear Cliente de Prueba
        if (businessId) { /* ... (c√≥digo crear/loguear cliente sin cambios) ... */
            try {
                console.log(`Attempting to register test customer: ${testCustomerEmail} with DNI: ${testCustomerDni}`);
                const registerRes = await request(app).post('/api/auth/register').send({ email: testCustomerEmail, password: testCustomerPassword, name: 'Test Customer', phone: `+${Date.now()}`.substring(0, 13), documentType: DocumentType.DNI, documentId: testCustomerDni, businessId: businessId, role: UserRole.CUSTOMER_FINAL });
                if (registerRes.status !== 201) { console.warn("Failed to register test customer", registerRes.status, registerRes.body.message); }
                else { console.log("Test customer registered:", testCustomerEmail); }

                console.log(`Attempting to login test customer: ${testCustomerEmail}`);
                const customerLoginRes = await request(app).post('/api/auth/login').send({ email: testCustomerEmail, password: testCustomerPassword });
                if (customerLoginRes.status === 200 && customerLoginRes.body.token) {
                    customerToken = customerLoginRes.body.token;
                    customerUserId = customerLoginRes.body.user?.id; // <-- Guardar ID del cliente
                    console.log("Test customer logged in, userId:", customerUserId);
                } else { console.error("Failed to login test customer", customerLoginRes.status, customerLoginRes.body.message); }
            } catch (error) { console.error("Error during customer setup:", error); }
        } else { console.error("Cannot setup customer - businessId not obtained."); }

        // Generar QR
        if (adminToken) { /* ... (c√≥digo generar QR sin cambios) ... */
             try {
                 const qrGenRes = await request(app).post('/api/points/generate-qr').set('Authorization', `Bearer ${adminToken}`).send({ amount: 10, ticketNumber: `TEST-${Date.now()}`});
                 if (qrGenRes.status === 201 && qrGenRes.body.qrToken) {
                    generatedQrToken = qrGenRes.body.qrToken;
                    console.log(`Generated QR Token for tests: ${generatedQrToken}`);
                 } else { console.warn("Failed to generate QR token for tests", qrGenRes.status, qrGenRes.body.message); }
             } catch(error) { console.error("Error generating QR during setup:", error); }
        } else { console.warn("Skipping QR generation, adminToken not available."); }
        console.log("Finished beforeAll setup.");
    }, 30000);

    // --- NUEVO: afterAll para limpiar cliente ---
    afterAll(async () => {
        console.log("Running afterAll cleanup for points tests...");
        // Intentar borrar el cliente creado si tenemos su ID y el token de admin
        if (customerUserId && adminToken) {
            console.log(`Attempting to delete test customer ${customerUserId}...`);
            try {
                // Usamos el endpoint de borrado masivo pas√°ndole un solo ID
                // OJO: Aseg√∫rate de que el endpoint DELETE /api/admin/customers/bulk-delete exista y funcione
                // Alternativamente, si tienes un DELETE /api/admin/customers/:id, √∫salo.
                // Si no hay endpoint de borrado, necesitar√≠amos usar Prisma Client directamente aqu√≠.
                // Asumiendo que bulk-delete funciona con un array de 1:
                await request(app)
                    .delete('/api/admin/customers/bulk-delete')
                    .set('Authorization', `Bearer ${adminToken}`)
                    .send({ customerIds: [customerUserId] }) // Enviar ID en el body
                    .timeout(5000); // Timeout por si acaso
                console.log(`Test customer ${customerUserId} deleted successfully.`);
            } catch (error: any) {
                console.warn(`Warning: Could not delete test customer ${customerUserId} during cleanup. Status: ${error?.status || 'unknown'}`);
            }
        } else {
            console.log("Cleanup skipped: No customerUserId or adminToken available.");
        }
        // NOTA: La limpieza del QR code es m√°s compleja porque no guardamos su ID
        // y no suele haber un endpoint para borrar QR por token. Se podr√≠a hacer
        // buscando en la BD por el ticketNumber 'TEST-*' y borrando directamente
        // con Prisma Client si fuera necesario, pero por ahora lo omitimos.
    });
    // --- FIN afterAll ---


    // --- Tests (Sin cambios, solo quitamos vi.skip) ---
    it('should fail validation if no token is provided in body', async () => {
        if (!customerToken) return; // Sigue saltando si el setup fall√≥
        await request(app).post('/api/points/validate-qr').set('Authorization', `Bearer ${customerToken}`).send({}).expect(400);
    });

    it('should fail validation with an invalid QR token format', async () => {
         if (!customerToken) return;
         const res = await request(app).post('/api/points/validate-qr').set('Authorization', `Bearer ${customerToken}`).send({ qrToken: 'invalid-token-format' }).expect(400);
         expect(res.body.message).toContain('inv√°lido');
    });

    it('should successfully validate a valid, pending QR token', async () => {
        if (!customerToken || !generatedQrToken) return;
        const response = await request(app).post('/api/points/validate-qr').set('Authorization', `Bearer ${customerToken}`).send({ qrToken: generatedQrToken }).expect(200);
        expect(response.body).toHaveProperty('pointsEarned');
        expect(response.body.pointsEarned).toBeGreaterThanOrEqual(0);
    });

    it('should fail validation if QR token is already used', async () => {
        if (!customerToken || !generatedQrToken) return;
        // Asumimos que el test anterior ya lo us√≥ (o lo usamos aqu√≠ por si acaso)
        try { await request(app).post('/api/points/validate-qr').set('Authorization', `Bearer ${customerToken}`).send({ qrToken: generatedQrToken }); } catch (e) {/* Ignorar error de la primera llamada */}
        // Segundo intento
        const response = await request(app).post('/api/points/validate-qr').set('Authorization', `Bearer ${customerToken}`).send({ qrToken: generatedQrToken }).expect(400);
        expect(response.body.message).toContain('utilizado');
    });

    it('should fail validation if user is not a customer', async () => {
         if (!adminToken || !generatedQrToken) return;
         await request(app).post('/api/points/validate-qr').set('Authorization', `Bearer ${adminToken}`).send({ qrToken: generatedQrToken }).expect(403);
    });

});


// ====== [108] backend/tests/integration/rewards.test.ts ======
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import app from '../../src/index';
import { Reward } from '@prisma/client';

describe('Rewards API Integration Tests (/api/rewards)', () => {

    let adminToken: string | null = null;
    let mainTestRewardId: string | null = null; // Reward creada en el test POST y usada en GET/PUT/PATCH
    let rewardToDeleteId: string | null = null; // Reward creada espec√≠ficamente para el test DELETE

    beforeAll(async () => {
        console.log("Starting beforeAll setup for rewards tests...");
        try {
            const adminLoginRes = await request(app)
                .post('/api/auth/login')
                .send({ email: 'admin@cafeelsol.com', password: 'superpasswordseguro' });
            if (adminLoginRes.status === 200 && adminLoginRes.body.token) {
                adminToken = adminLoginRes.body.token;
                console.log("Admin logged in successfully for rewards tests.");
            } else {
                throw new Error("Admin login failed in rewards test setup");
            }
        } catch (error) {
            console.error("CRITICAL: Error during admin login setup for rewards:", error);
            throw error;
        }
        console.log("Finished beforeAll setup for rewards tests.");
    }, 20000);

    afterAll(async () => {
        // Limpiar la recompensa principal si se cre√≥
        if (mainTestRewardId && adminToken) {
            console.log(`Running afterAll cleanup: deleting main reward ${mainTestRewardId}...`);
            try {
                await request(app).delete(`/api/rewards/${mainTestRewardId}`).set('Authorization', `Bearer ${adminToken}`);
                console.log(`Main reward ${mainTestRewardId} deleted successfully.`);
            } catch (error) {
                console.warn(`Warning during afterAll cleanup, could not delete main reward ${mainTestRewardId}:`, error);
            }
        }
        // Limpiar la recompensa del test DELETE si por alguna raz√≥n no se borr√≥ en su test
        if (rewardToDeleteId && adminToken) {
             console.log(`Running afterAll cleanup: attempting to delete leftover DELETE test reward ${rewardToDeleteId}...`);
             try {
                await request(app).delete(`/api/rewards/${rewardToDeleteId}`).set('Authorization', `Bearer ${adminToken}`);
                console.log(`DELETE test reward ${rewardToDeleteId} deleted successfully.`);
             } catch (error) {
                // Silenciar error aqu√≠, es solo una limpieza extra
             }
        }
    });


    // --- Tests POST ---
    it('POST /api/rewards - should fail to create reward without auth token', async () => {
        await request(app).post('/api/rewards').send({ name: 'Fail No Auth', pointsCost: 10 }).expect(401);
    });
    it('POST /api/rewards - should fail to create reward with missing name', async () => {
        if (!adminToken) throw new Error("Admin token not available");
        await request(app).post('/api/rewards').set('Authorization', `Bearer ${adminToken}`).send({ pointsCost: 50 }).expect(400);
    });
     it('POST /api/rewards - should fail to create reward with invalid pointsCost', async () => {
        if (!adminToken) throw new Error("Admin token not available");
        await request(app).post('/api/rewards').set('Authorization', `Bearer ${adminToken}`).send({ name: 'Fail Points', pointsCost: -10 }).expect(400);
    });
    it('POST /api/rewards - should create a new reward successfully', async () => {
        if (!adminToken) throw new Error("Admin token not available");
        const rewardData = { name: `Test ${Date.now()}`, description: 'Desc', pointsCost: 150 };
        const response = await request(app).post('/api/rewards').set('Authorization', `Bearer ${adminToken}`).send(rewardData).expect(201);
        expect(response.body.id).toBeTypeOf('string');
        expect(response.body.name).toBe(rewardData.name);
        expect(response.body.isActive).toBe(true);
        mainTestRewardId = response.body.id; // Guardar ID para otros tests
    });

    // --- Tests GET ---
    it('GET /api/rewards - should retrieve a list of rewards', async () => {
         if (!adminToken) throw new Error("Admin token not available");
         const response = await request(app).get('/api/rewards').set('Authorization', `Bearer ${adminToken}`).expect(200);
         expect(Array.isArray(response.body)).toBe(true);
         if (mainTestRewardId) { // Verificar que la creada existe
             expect(response.body.some((r: Reward) => r.id === mainTestRewardId)).toBe(true);
         }
    });
     it('GET /api/rewards - should fail to get rewards without auth token', async () => {
        await request(app).get('/api/rewards').expect(401);
    });
    it('GET /api/rewards/:id - should retrieve a specific reward', async () => {
        if (!adminToken || !mainTestRewardId) throw new Error("Prerequisites not met");
        const response = await request(app).get(`/api/rewards/${mainTestRewardId}`).set('Authorization', `Bearer ${adminToken}`).expect(200);
        expect(response.body.id).toBe(mainTestRewardId);
    });
   it('GET /api/rewards/:id - should return 404 for non-existent reward', async () => {
       if (!adminToken) throw new Error("Admin token not available");
       const nonExistentId = '00000000-0000-0000-0000-000000000000';
       await request(app).get(`/api/rewards/${nonExistentId}`).set('Authorization', `Bearer ${adminToken}`).expect(404);
   });

   // --- Tests PUT/PATCH ---
    it('PUT /api/rewards/:id - should update a reward completely', async () => {
       if (!adminToken || !mainTestRewardId) throw new Error("Prerequisites not met");
       const updateData = { name: `Updated ${Date.now()}`, description: 'Upd Desc', pointsCost: 250, isActive: false };
       const response = await request(app).put(`/api/rewards/${mainTestRewardId}`).set('Authorization', `Bearer ${adminToken}`).send(updateData).expect(200);
       expect(response.body.name).toBe(updateData.name);
       expect(response.body.pointsCost).toBe(updateData.pointsCost);
       expect(response.body.isActive).toBe(updateData.isActive);
    });
    it('PATCH /api/rewards/:id - should partially update a reward (toggle isActive)', async () => {
       if (!adminToken || !mainTestRewardId) throw new Error("Prerequisites not met");
       const currentState = await request(app).get(`/api/rewards/${mainTestRewardId}`).set('Authorization', `Bearer ${adminToken}`);
       const currentIsActive = currentState.body.isActive;
       const response = await request(app).patch(`/api/rewards/${mainTestRewardId}`).set('Authorization', `Bearer ${adminToken}`).send({ isActive: !currentIsActive }).expect(200);
       expect(response.body.isActive).toBe(!currentIsActive);
    });

    // --- Tests DELETE ---
    it('DELETE /api/rewards/:id - should delete a reward', async () => {
        if (!adminToken) throw new Error("Admin token not available");
        // 1. Crear una recompensa espec√≠ficamente para este test
        const rewardName = `To Delete ${Date.now()}`;
        const createRes = await request(app).post('/api/rewards').set('Authorization', `Bearer ${adminToken}`).send({ name: rewardName, pointsCost: 10 }).expect(201);
        rewardToDeleteId = createRes.body.id; // Guardar ID para posible limpieza en afterAll si falla
        expect(rewardToDeleteId).toBeTypeOf('string');

        // 2. Borrarla
        await request(app)
            .delete(`/api/rewards/${rewardToDeleteId}`)
            .set('Authorization', `Bearer ${adminToken}`)
            .expect(200); // O 204 si no devuelve cuerpo

        // 3. Verificar que ya no existe (GET debe dar 404)
        await request(app)
            .get(`/api/rewards/${rewardToDeleteId}`)
            .set('Authorization', `Bearer ${adminToken}`)
            .expect(404);

        rewardToDeleteId = null; // Indicar que se borr√≥ con √©xito
    });

     it('DELETE /api/rewards/:id - should return 404 if reward to delete not found', async () => {
         if (!adminToken) throw new Error("Admin token not available");
         const nonExistentId = '00000000-0000-0000-0000-000000000000';
         await request(app)
             .delete(`/api/rewards/${nonExistentId}`)
             .set('Authorization', `Bearer ${adminToken}`)
             .expect('Content-Type', /json/) // El servicio devuelve JSON para 404
             .expect(404);
     });

    // Test 409 (conflicto) sigue pendiente de setup m√°s complejo
    /*
     it('DELETE /api/rewards/:id - should return 409 if reward is in use', async () => { ... });
    */

});


// ====== [109] backend/tests/integration/tiers.test.ts ======
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import app from '../../src/index';
import { Tier } from '@prisma/client';

describe('Tiers API Integration Tests (/api/tiers)', () => {

    let adminToken: string | null = null;
    // --- CAMBIO: Usar array para TODOS los IDs creados ---
    const createdTierIds: string[] = [];
    // --- FIN CAMBIO ---
    let initialTierData: Partial<Tier> = {}; // Para comparar despu√©s de actualizar


    // Setup (sin cambios)
    beforeAll(async () => {
        console.log("Starting beforeAll setup for tiers tests...");
        try {
            const adminLoginRes = await request(app)
                .post('/api/auth/login')
                .send({ email: 'admin@cafeelsol.com', password: 'superpasswordseguro' });
            if (adminLoginRes.status === 200 && adminLoginRes.body.token) {
                adminToken = adminLoginRes.body.token;
                console.log("Admin logged in successfully for tiers tests.");
            } else {
                throw new Error("Admin login failed in tiers test setup");
            }
        } catch (error) {
            console.error("CRITICAL: Error during admin login setup for tiers:", error);
            throw error;
        }
        console.log("Finished beforeAll setup for tiers tests.");
    }, 20000);

    // --- CAMBIO: Limpieza afterAll mejorada ---
    afterAll(async () => {
        if (adminToken && createdTierIds.length > 0) {
             console.log(`Running afterAll cleanup: deleting ${createdTierIds.length} created tiers...`);
             // Borrar en orden inverso por si acaso
             for (let i = createdTierIds.length - 1; i >= 0; i--) {
                 const tierId = createdTierIds[i];
                 try {
                     // Usamos un try/catch individual para que un fallo no detenga la limpieza de otros
                     await request(app)
                         .delete(`/api/tiers/tiers/${tierId}`)
                         .set('Authorization', `Bearer ${adminToken}`)
                         .timeout(2000); // Timeout corto para cleanup
                     console.log(`Tier ${tierId} deleted during cleanup.`);
                 } catch (error: any) {
                     // Solo logueamos si falla, no detenemos
                     console.warn(`Warning during afterAll cleanup, could not delete tier ${tierId}: Status ${error?.status || 'unknown'}`);
                 }
             }
             createdTierIds.length = 0; // Vaciar array para futuras ejecuciones si el test runner reutiliza contexto
        } else {
            console.log("afterAll cleanup: No tiers to delete or no admin token.");
        }
    });
    // --- FIN CAMBIO ---


    // --- Tests POST (Modificado para a√±adir ID al array) ---
    it('POST /api/tiers/tiers - should fail to create tier without auth token', async () => { /* sin cambios */
        await request(app).post('/api/tiers/tiers').send({ name: 'Fail No Auth', level: 1, minValue: 100 }).expect(401);
    });
    it('POST /api/tiers/tiers - should fail to create tier with missing name', async () => { /* sin cambios */
        if (!adminToken) throw new Error("Admin token not available");
        await request(app).post('/api/tiers/tiers').set('Authorization', `Bearer ${adminToken}`).send({ level: 1, minValue: 100 }).expect(400);
    });
     it('POST /api/tiers/tiers - should fail to create tier with invalid level (negative)', async () => { /* sin cambios */
        if (!adminToken) throw new Error("Admin token not available");
        await request(app).post('/api/tiers/tiers').set('Authorization', `Bearer ${adminToken}`).send({ name: 'Fail Level', level: -1, minValue: 100 }).expect(400);
    });
     it('POST /api/tiers/tiers - should fail to create tier with invalid minValue (negative)', async () => { /* sin cambios */
        if (!adminToken) throw new Error("Admin token not available");
        await request(app).post('/api/tiers/tiers').set('Authorization', `Bearer ${adminToken}`).send({ name: 'Fail MinValue', level: 1, minValue: -100 }).expect(400);
    });
    it('POST /api/tiers/tiers - should create a new tier successfully', async () => { /* MODIFICADO */
        if (!adminToken) throw new Error("Admin token not available");
        const uniqueLevel = Math.floor(Date.now() / 1000);
        initialTierData = { name: `Test Tier ${uniqueLevel}`, level: uniqueLevel, minValue: uniqueLevel * 100, description: 'Tier for testing', isActive: true };
        const response = await request(app).post('/api/tiers/tiers').set('Authorization', `Bearer ${adminToken}`).send(initialTierData).expect(201);
        expect(response.body.id).toBeTypeOf('string');
        expect(response.body.name).toBe(initialTierData.name);
        expect(response.body.isActive).toBe(initialTierData.isActive);
        // --- CAMBIO: A√±adir ID al array para limpieza ---
        createdTierIds.push(response.body.id);
        // --- FIN CAMBIO ---
    });
     it('POST /api/tiers/tiers - should fail to create tier with duplicate level', async () => { /* sin cambios */
        if (!adminToken || createdTierIds.length === 0) throw new Error("Prerequisites not met - need created tier");
         const getRes = await request(app).get(`/api/tiers/tiers/${createdTierIds[0]}`).set('Authorization', `Bearer ${adminToken}`);
         const levelToDuplicate = getRes.body.level;
        await request(app).post('/api/tiers/tiers').set('Authorization', `Bearer ${adminToken}`).send({ name: 'Duplicate Level Tier', level: levelToDuplicate, minValue: 50 }).expect(409);
    });

    // --- Tests GET (Sin cambios) ---
    it('GET /api/tiers - should retrieve a list of tiers', async () => { /* sin cambios */
         if (!adminToken) throw new Error("Admin token not available");
         const response = await request(app).get('/api/tiers').set('Authorization', `Bearer ${adminToken}`).expect(200);
         expect(Array.isArray(response.body)).toBe(true);
         if (createdTierIds.length > 0) { expect(response.body.some((t: Tier) => t.id === createdTierIds[0])).toBe(true); }
    });
    it('GET /api/tiers/tiers/:tierId - should retrieve a specific tier', async () => { /* sin cambios */
        if (!adminToken || createdTierIds.length === 0) throw new Error("Prerequisites not met");
        const tierIdToGet = createdTierIds[0];
        const response = await request(app).get(`/api/tiers/tiers/${tierIdToGet}`).set('Authorization', `Bearer ${adminToken}`).expect(200);
        expect(response.body.id).toBe(tierIdToGet);
        expect(response.body.name).toBe(initialTierData.name);
    });
     it('GET /api/tiers/tiers/:tierId - should return 404 for non-existent tier', async () => { /* sin cambios */
        if (!adminToken) throw new Error("Admin token not available");
        const nonExistentId = '00000000-0000-0000-0000-000000000000';
        await request(app).get(`/api/tiers/tiers/${nonExistentId}`).set('Authorization', `Bearer ${adminToken}`).expect(404);
    });

   // --- Tests PUT/PATCH (Sin cambios) ---
    it('PUT /api/tiers/tiers/:tierId - should update a tier completely', async () => { /* sin cambios */
       if (!adminToken || createdTierIds.length === 0) throw new Error("Prerequisites not met");
       const tierIdToUpdate = createdTierIds[0];
       const updateData = { name: `Updated Tier ${Date.now()}`, level: initialTierData.level! + 1, minValue: initialTierData.minValue! + 50, description: 'Updated', isActive: false };
       const response = await request(app).put(`/api/tiers/tiers/${tierIdToUpdate}`).set('Authorization', `Bearer ${adminToken}`).send(updateData).expect(200);
       expect(response.body.name).toBe(updateData.name);
       expect(response.body.isActive).toBe(updateData.isActive);
       initialTierData = response.body;
    });
    it('PATCH /api/tiers/tiers/:tierId - should partially update a tier (toggle isActive)', async () => { /* sin cambios */
       if (!adminToken || createdTierIds.length === 0) throw new Error("Prerequisites not met");
       const tierIdToPatch = createdTierIds[0];
       const currentIsActive = initialTierData.isActive;
       const patchData = { isActive: !currentIsActive };
       const response = await request(app).patch(`/api/tiers/tiers/${tierIdToPatch}`).set('Authorization', `Bearer ${adminToken}`).send(patchData).expect(200);
       expect(response.body.isActive).toBe(patchData.isActive);
       expect(response.body.name).toBe(initialTierData.name);
    });

    // --- Tests DELETE (Modificado para a√±adir ID al array) ---
    it('DELETE /api/tiers/tiers/:tierId - should delete a tier', async () => { /* MODIFICADO */
        if (!adminToken) throw new Error("Admin token not available");
         const uniqueLevel = Math.floor(Date.now() / 1000) + 2000;
         const tierData = { name: `To Delete ${uniqueLevel}`, level: uniqueLevel, minValue: 1 };
         const createRes = await request(app).post('/api/tiers/tiers').set('Authorization', `Bearer ${adminToken}`).send(tierData).expect(201);
         const idToDelete = createRes.body.id;
         // --- CAMBIO: A√±adir ID temporal al array ---
         createdTierIds.push(idToDelete); // Lo a√±adimos para que afterAll lo limpie si algo falla
         // --- FIN CAMBIO ---
         expect(idToDelete).toBeTypeOf('string');

        await request(app).delete(`/api/tiers/tiers/${idToDelete}`).set('Authorization', `Bearer ${adminToken}`).expect(200);
        await request(app).get(`/api/tiers/tiers/${idToDelete}`).set('Authorization', `Bearer ${adminToken}`).expect(404);

         // Si llegamos aqu√≠, el borrado tuvo √©xito, podemos quitarlo del array para que afterAll no lo intente de nuevo (opcional)
         const indexToRemove = createdTierIds.indexOf(idToDelete);
         if (indexToRemove > -1) {
             createdTierIds.splice(indexToRemove, 1);
         }
    });
     it('DELETE /api/tiers/tiers/:tierId - should return 404 if tier to delete not found', async () => { /* sin cambios */
         if (!adminToken) throw new Error("Admin token not available");
         const nonExistentId = '00000000-0000-0000-0000-000000000000';
         await request(app).delete(`/api/tiers/tiers/${nonExistentId}`).set('Authorization', `Bearer ${adminToken}`).expect(404);
     });

});


// ====== [110] backend/tsconfig.json ======
{
  "compilerOptions": {
    "target": "es2022",
    "module": "commonjs",
    "rootDir": "./src",
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "experimentalDecorators": true, // <--- A√ëADIDO
    "emitDecoratorMetadata": true   // <--- A√ëADIDO
  },
  "include": [
    "src/**/*.ts"
  ]
}


// ====== [111] backend/vitest.config.ts ======
// backend/vitest.config.ts (Opcional por ahora)
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true, // Para no tener que importar describe, it, expect, etc.
    environment: 'node', // Entorno de Node.js
    // setupFiles: ['./tests/setup.ts'], // Archivo opcional para configuraci√≥n global
    coverage: {
      provider: 'v8', // o 'istanbul'
      reporter: ['text', 'json', 'html'],
    },
  },
});


// ====== [112] frontend/eslint.config.js ======
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)



// ====== [113] frontend/index.html ======
<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LoyalPyME</title>

    <style>
      body {
        margin: 0; /* Asegura que no haya m√°rgenes por defecto */
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; /* Fuente simple de sistema */
      }
      #initial-loader {
        position: fixed; /* Posici√≥n fija para cubrir todo */
        inset: 0; /* Equivalente a top: 0; right: 0; bottom: 0; left: 0; */
        background-color: #f8f9fa; /* Un fondo claro simple (ajusta si prefieres oscuro) */
        display: flex;
        flex-direction: column; /* Apila texto y spinner */
        align-items: center;
        justify-content: center;
        z-index: 9999; /* Asegura que est√© por encima de todo */
        color: #495057;
        transition: opacity 0.5s ease-out; /* Transici√≥n suave al ocultar */
      }
      #initial-loader .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        width: 36px;
        height: 36px;
        border-radius: 50%;
        border-left-color: #09f; /* Color del spinner (puedes usar tu azul Mantine) */
        margin-top: 20px;
        animation: spin 1s ease infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      /* Estilo opcional para ocultar cuando se a√±ade la clase 'hidden' */
       #initial-loader.hidden {
          opacity: 0;
          pointer-events: none; /* No interferir con clics */
       }
    </style>
    </head>
  <body>
    <div id="initial-loader">
      <p>Cargando LoyalPyME...</p>
      <div class="spinner"></div>
    </div>
    <div id="root"></div>

    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


// ====== [114] frontend/package.json ======
{
  "name": "frontend",
  "private": true,
  "version": "0.1.0",
  "type": "module",
  "license": "SEE LICENSE IN ../LICENSE.md",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest run --coverage"
  },
  "dependencies": {
    "@mantine/core": "^7.17.4",
    "@mantine/form": "^7.17.4",
    "@mantine/hooks": "^7.17.4",
    "@mantine/modals": "^7.17.5",
    "@mantine/notifications": "^7.17.4",
    "@tabler/icons-react": "^3.31.0",
    "axios": "^1.8.4",
    "html5-qrcode": "^2.3.8",
    "i18next": "^23.13.2",
    "i18next-browser-languagedetector": "^8.0.1",
    "i18next-http-backend": "^2.5.2",
    "qrcode.react": "^4.2.0",
    "react": "^19.0.0",
    "react-country-flag": "^3.1.0",
    "react-dom": "^19.0.0",
    "react-i18next": "^15.0.1",
    "react-image-crop": "^11.0.10",
    "react-router-dom": "^6.26.1",
    "zod": "^3.24.3"
  },
  "devDependencies": {
    "@eslint/js": "^9.22.0",
    "@testing-library/dom": "^10.4.0",
    "@testing-library/jest-dom": "^6.7.1",
    "@testing-library/react": "^16.0.0",
    "@testing-library/user-event": "^14.5.2",
    "@types/qrcode.react": "^1.0.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.22.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^16.0.0",
    "jsdom": "^24.1.1",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.26.1",
    "vite": "^5.4.0",
    "vite-plugin-mkcert": "^1.17.8",
    "vitest": "^2.0.4"
  }
}


// ====== [115] frontend/public/locales/en/translation.json ======
{
  "common": {
    "loading": "Loading...",
    "save": "Save",
    "cancel": "Cancel",
    "delete": "Delete",
    "edit": "Edit",
    "add": "Add",
    "confirm": "Confirm",
    "close": "Close",
    "error": "Error",
    "success": "Success",
    "requiredField": "This field is required.",
    "back": "Back",
    "actions": "Actions",
    "status": "Status",
    "active": "Active",
    "inactive": "Inactive",
    "name": "Name",
    "description": "Description",
    "points": "Points",
    "level": "Level",
    "email": "Email",
    "registered": "Registered",
    "yes": "Yes",
    "no": "No",
    "searchPlaceholder": "Search...",
    "noResults": "No results found.",
    "selectPlaceholder": "Select one",
    "optional": "Optional",
    "confirmAction": "Confirm Action",
    "noItems": "No items defined yet.",
    "errorLoadingData": "Error loading data",
    "info": "Information",
    "errorUnknown": "Unknown error",
    "invalidDate": "Invalid date",
    "upcomingFeatureTitle": "Coming Soon",
    "deleting": "Deleting...",
    "customer": "Customer",
    "selected": "selected",
    "errorImageTooSmall": "The image is too small. It must be at least {{minSize}}x{{minSize}} pixels.",
    "errorMustBePositiveOrZero": "Must be a number equal to or greater than 0.",
    "nameNotAvailable": "(No name)",
    "saveChanges": "Save Changes",
    "camera": "Camera",
    "item": "Item"
  },
  "validation": {
    "cannotBeZero": "The amount cannot be zero.",
    "benefitTypeRequired": "Select a valid benefit type.",
    "nameRequired": "Name is required.",
    "levelMin0": "Level must be 0 or greater.",
    "minValueMin0": "Minimum value must be 0 or greater.",
    "mustBePositive": "Must be > 0",
    "invalidUrl": "Invalid image URL."
  },
  "loginPage": {
    "title": "Login",
    "subtitle": "Don't have an account?",
    "registerLink": "Register here",
    "forgotPasswordLink": "Forgot your password?",
    "emailLabel": "Email",
    "emailPlaceholder": "you@email.com",
    "passwordLabel": "Password",
    "passwordPlaceholder": "Your password",
    "loginButton": "Login",
    "errorCredentials": "Invalid credentials.",
    "errorServer": "Server error during login.",
    "errorUnknown": "An unexpected error occurred.",
    "accessMenuDirectlyTitle": "Know the business identifier?",
    "businessSlugPlaceholder": "Business identifier (slug)",
    "goToMenuButton": "View Menu"
  },
  "registerPage": {
    "welcomeTitle": "Welcome to LoyalPyME!",
    "title": "Create Your Customer Account",
    "subtitle": "Already have an account?",
    "loginLink": "Login",
    "emailLabel": "Email",
    "passwordLabel": "Password",
    "confirmPasswordLabel": "Confirm Password",
    "nameLabel": "Name (Optional)",
    "phoneLabel": "Phone (international format)",
    "docTypeLabel": "Document Type",
    "docIdLabel": "Document Number",
    "businessLabel": "Business to Join",
    "registerButton": "Register",
    "errorLoadingBusinesses": "Could not load the list of businesses.",
    "errorPasswordsDontMatch": "Passwords do not match.",
    "errorRegistration": "Error during registration.",
    "emailPlaceholder": "you@email.com",
    "passwordPlaceholder": "Create a password",
    "confirmPasswordPlaceholder": "Repeat password",
    "namePlaceholder": "Your full name",
    "phonePlaceholder": "+1555...",
    "docTypePlaceholder": "Select one",
    "docIdPlaceholder": "ID, Passport...",
    "businessSelectLoading": "Loading businesses...",
    "businessSelectPlaceholder": "Select a business",
    "businessSelectNotFound": "No businesses available",
    "businessSelectError": "Error loading",
    "errorInvalidEmail": "Invalid email format.",
    "errorPasswordLength": "Password must be at least 6 characters long.",
    "errorConfirmPassword": "Confirm the password.",
    "errorPhoneFormat": "Invalid format (e.g., +1555...).",
    "errorDocType": "Select a document type.",
    "errorDNIFormat": "Invalid ID format (e.g., 8 numbers and 1 letter for DNI).",
    "errorNIEFormat": "Invalid NIE format (e.g., letter, 7 numbers, letter).",
    "errorBusinessRequired": "You must select a business.",
    "successMessage": "Your account has been created. You will be redirected to the login page."
  },
  "forgotPasswordPage": {
    "title": "Reset Password",
    "subtitle": "Remember your password?",
    "loginLink": "Back to Login",
    "instructions": "Enter your email address and we will send you (or show in the backend console) a link to reset your password.",
    "emailLabel": "Registered Email",
    "emailPlaceholder": "you@email.com",
    "buttonText": "Request Reset",
    "successTitle": "Request Sent",
    "successMessage": "If an account with that email exists, you will receive (or see in console) a link to reset your password. The link will expire in 1 hour.",
    "errorTitle": "Error",
    "errorMissingEmail": "Please enter your email address.",
    "errorGenericTitle": "Request Processed",
    "errorGenericMessage": "If an account with that email exists, you will receive (or see in console) a link to reset your password."
  },
  "resetPasswordPage": {
    "title": "Set New Password",
    "subtitle": "Enter your new password below.",
    "passwordLabel": "New Password",
    "passwordPlaceholder": "Enter your new password",
    "confirmPasswordLabel": "Confirm New Password",
    "confirmPasswordPlaceholder": "Repeat the new password",
    "buttonText": "Save New Password",
    "loginLink": "Back to Login",
    "successTitle": "Password Changed!",
    "successMessage": "Your password has been successfully reset. You will be redirected to Login.",
    "errorTitle": "Error Resetting",
    "errorMissingToken": "Reset token is missing. Please use the link sent to your email.",
    "errorPasswordsRequired": "Please enter and confirm the new password.",
    "errorPasswordsDontMatch": "Passwords do not match.",
    "errorPasswordLength": "The new password must be at least 6 characters long.",
    "errorInvalidToken": "Error resetting password. The token might be invalid or expired."
  },
  "registerBusinessPage": {
    "title": "Register New Business",
    "subtitle": "Create the account for your business and the main administrator.",
    "businessNameLabel": "Business Name",
    "businessNamePlaceholder": "My Awesome Cafe",
    "adminNameLabel": "Your Name (Admin)",
    "adminNamePlaceholder": "John Doe",
    "adminEmailLabel": "Your Email (Admin)",
    "adminEmailPlaceholder": "john.doe@mycafe.com",
    "adminPasswordLabel": "Password (Admin)",
    "adminPasswordPlaceholder": "Your password",
    "confirmPasswordLabel": "Confirm Password",
    "confirmPasswordPlaceholder": "Repeat your password",
    "registerButton": "Register Business",
    "loginLink": "Login",
    "loginLinkSubtitle": "Already have an account?",
    "successTitle": "Registration Successful!",
    "successMessage": "The business '{{businessName}}' and administrator {{adminEmail}} have been created successfully.",
    "errorTitle": "Registration Error",
    "errorRegistration": "Could not complete registration. Please try again.",
    "errorBusinessNameLength": "Business name must be at least 2 characters long",
    "errorAdminEmailInvalid": "Invalid email",
    "errorAdminPasswordLength": "Password must be at least 6 characters long",
    "errorConfirmPasswordLength": "Password confirmation must be at least 6 characters long",
    "errorPasswordsDontMatch": "Passwords do not match"
  },
  "header": {
    "greeting": "Hello, {{name}}!",
    "logoutButton": "Logout",
    "languageLabel": "Language",
    "toggleNavigation": "Toggle navigation"
  },
  "customerDashboard": {
    "title": "Customer Dashboard",
    "points": "Points",
    "currentTier": "Current Tier:",
    "baseTier": "Basic",
    "validateQrSectionTitle": "Validate QR Code",
    "qrInputLabel": "Enter ticket/QR code",
    "qrInputPlaceholder": "Paste the code here...",
    "validateButton": "Validate Code",
    "scanButton": "Scan QR",
    "scanModalTitle": "Scan QR Code",
    "scanInstructions": "Point the camera at the QR code",
    "scanCancelButton": "Cancel Scan",
    "scanButtonDisabledTooltip": "Scan QR only available on mobile",
    "rewardsSectionTitle": "Rewards and Gifts",
    "noRewardsAvailable": "No rewards or gifts available at this time.",
    "redeemGiftButton": "Redeem Gift",
    "redeemRewardButton": "Redeem Reward",
    "insufficientPoints": "Insufficient points",
    "giftFree": "Free",
    "giftAssignedBy": "Gifted by {{assigner}} on {{date}}",
    "giftInfo": "Info",
    "errorLoadingProfile": "Error loading your profile: {{error}}",
    "errorLoadingRewards": "Could not load rewards or gifts. {{error}}",
    "errorScanningQr": "Scanner Error",
    "errorScanningQrDefault": "Could not start the camera: {{error}}",
    "validating": "Validating...",
    "errorValidatingQr": "Validation Error",
    "errorValidatingQrMessage": "Unknown error validating QR.",
    "successQrValidation": "QR code validated successfully. You've earned {{points}} points.",
    "errorRedeemTitle": "Error Redeeming",
    "errorRedeemMessage": "Unknown error while redeeming.",
    "successRedeemRewardTitle": "Reward Redeemed!",
    "successRedeemRewardMessage": "You have redeemed your reward.",
    "successRedeemGiftTitle": "Gift Redeemed!",
    "successRedeemGiftMessage": "You have redeemed \"{{rewardName}}\".",
    "errorLoadingProfileTitle": "Profile Error",
    "errorLoadingProfileDefault": "Could not load user data.",
    "noUserDataError": "Could not load user data.",
    "tierBenefitsTitle": "Benefits for Tier: {{tierName}}",
    "progressUnitVisits": "visits",
    "progressLabel": "{{currentValue}} / {{targetValue}} {{unit}} to reach {{nextTierName}}",
    "maxLevelReached": "Congratulations! You have reached the maximum level ({currentTierName}).",
    "maxLevelReachedShort": "Max Level!",
    "nextTierBenefitsTitle": "Upon reaching {{tierName}} you will have:",
    "errorLoadingProgress": "Could not load tier data to show progress.",
    "tabSummary": "Summary",
    "tabRewards": "Rewards",
    "tabActivity": "My Activity",
    "tabOffers": "Offers & News",
    "tabProfile": "My Profile",
    "summary": {
      "pendingGifts_one": "You have {{count}} pending gift:",
      "pendingGifts_other": "You have {{count}} pending gifts:",
      "pendingGiftsDesc": "You have gifts waiting to be redeemed.",
      "nextReward": "Next reward: {{name}} for {{points}} points.",
      "viewAllButton": "View All Rewards and Gifts",
      "noRewardsInfo": "Collect more points to get rewards.",
      "giftsAndRewardsTitle": "Available Gifts and Rewards:",
      "rewardsTitle": "Available Rewards:",
      "unknownAssigner": "Unknown",
      "redeemButton": "Redeem",
      "viewAllButtonShort": "View All",
      "viewMenuFor": "View Menu for {{businessName}}",
      "viewMenuDefaultTitle": "View Menu and Order",
      "viewMenuSubtitle": "Access the digital menu and place your order.",
      "viewMenuButton": "Go to Menu"
    },
    "activityTab": {
      "noActivity": "You have no registered activity yet.",
      "type_POINTS_EARNED_QR": "Points Earned (QR)",
      "type_POINTS_REDEEMED_REWARD": "Reward Redeemed",
      "type_GIFT_REDEEMED": "Gift Redeemed",
      "type_POINTS_ADJUSTED_ADMIN": "Manual Points Adjustment",
      "totalItems": "{{count}} record(s) in total",
      "desc_EARNED": "Points for ticket #{{ticketNumber}}",
      "desc_REDEEMED": "Redemption: {{rewardName}}",
      "desc_GIFT": "Gift redeemed: {{rewardName}}",
      "desc_ADJUSTED": "Manual points adjustment",
      "desc_ADJUSTED_REASON": "Manual adjustment: {{reason}}"
    },
    "rewards": {
      "affordable": "Affordable"
    }
  },
  "adminCommon": {
    "dashboard": "Dashboard",
    "rewards": "Rewards",
    "generateQr": "Generate QR",
    "customers": "Customers",
    "manageTiers": "Manage Tiers",
    "tierSettings": "Tier Settings",
    "saveSuccess": "Saved successfully",
    "updateSuccess": "Updated successfully",
    "createSuccess": "Created successfully",
    "deleteSuccess": "Deleted successfully",
    "saveError": "Error saving",
    "updateError": "Error updating",
    "createError": "Error creating",
    "deleteError": "Error deleting",
    "confirmDeleteTitle": "Confirm Deletion",
    "confirmDeleteMessage": "Are you sure? This action cannot be undone.",
    "adminTitle": "LoyalPyME Admin"
  },
  "adminOverview": {
    "welcome": "Welcome, {{name}}!",
    "panelIntro": "You are in the administration panel for",
    "panelDescription": "From here you can manage your loyalty program: configure tiers, rewards, customers, and generate QR codes.",
    "quickSummaryTitle": "Quick Summary",
    "statActiveCustomers": "CUSTOMERS",
    "statNewCustomers": "NEW (7D)",
    "statPointsIssued": "POINTS (7D)",
    "statRedemptions": "REDEMPTIONS (7D)",
    "quickAccessTitle": "Quick Access",
    "cardRewardsTitle": "Rewards",
    "cardRewardsDesc": "Create and manage the rewards your customers can redeem.",
    "cardRewardsButton": "Manage Rewards",
    "cardTiersTitle": "Loyalty Tiers",
    "cardTiersDesc": "Define the different levels and benefits for your customers.",
    "cardTiersButton": "Manage Tiers",
    "cardTierSettingsTitle": "Tier Configuration",
    "cardTierSettingsDesc": "Adjust the logic of how customers move up or down tiers.",
    "cardTierSettingsButton": "Adjust Configuration",
    "cardQrTitle": "Generate Points QR",
    "cardQrDesc": "Create unique QR codes for your customers to earn points.",
    "cardQrButton": "Generate QR Code",
    "cardCustomersTitle": "Customers",
    "cardCustomersDesc": "View and manage the list of your registered customers.",
    "cardCustomersButton": "Manage Customers",
    "errorLoadingStats": "Could not load statistics.",
    "noStatsAvailable": "No statistical data available.",
    "defaultBusinessName": "your Business",
    "noModulesActivePrompt": "No modules are active for this business. Activate them from the Super Admin panel."
  },
  "adminRewardsPage": {
    "title": "Reward Management",
    "addButton": "Add Reward",
    "cancelAddButton": "Cancel Add",
    "tableHeaderName": "Name",
    "tableHeaderCost": "Cost",
    "tableHeaderStatus": "Status",
    "tableHeaderActions": "Actions",
    "tooltipEdit": "Edit Reward",
    "tooltipDeactivate": "Deactivate",
    "tooltipActivate": "Activate",
    "tooltipDelete": "Delete Reward",
    "noRewardsYet": "You haven't created any rewards yet.",
    "addFormTitle": "Add New Reward",
    "editFormTitle": "Edit Reward",
    "confirmDeleteMessage": "Are you sure you want to delete the reward \"{{name}}\"? This action cannot be undone.",
    "deleteSuccessMessage": "The reward \"{{name}}\" has been deleted.",
    "deleteErrorNotFound": "Reward \"{{name}}\" not found (perhaps it was already deleted).",
    "deleteErrorInUse": "\"{{name}}\" cannot be deleted because it is in use.",
    "toggleStatusSuccess": "The reward has been {{status}} successfully.",
    "toggleStatusError": "Error {{status}} the reward: {{error}}",
    "statusActivated": "activated",
    "statusDeactivated": "deactivated",
    "updateSuccessMessage": "Reward \"{{name}}\" updated.",
    "createSuccessMessage": "Reward \"{{name}}\" created."
  },
  "component": {
    "rewardForm": {
      "nameLabel": "Reward Name:",
      "namePlaceholder": "E.g.: Free Coffee",
      "descriptionLabel": "Description (Optional):",
      "descriptionPlaceholder": "E.g.: One espresso or americano coffee",
      "pointsCostLabel": "Cost in Points:",
      "pointsCostPlaceholder": "E.g.: 100",
      "errorNameRequired": "Reward name cannot be empty.",
      "errorPointsCostInvalid": "Cost in points must be a number equal to or greater than zero.",
      "nameEsLabel": "Name (ES)",
      "nameEsPlaceholder": "E.g.: Caf√© Gratis",
      "nameEnLabel": "Name (EN)",
      "nameEnPlaceholder": "E.g.: Free Coffee",
      "descriptionEsLabel": "Description (ES, Optional)",
      "descriptionEsPlaceholder": "E.g.: Un caf√© espresso o americano",
      "descriptionEnLabel": "Description (EN, Optional)",
      "descriptionEnPlaceholder": "E.g.: One espresso or americano coffee",
      "imageLabel": "Image",
      "removeImageButton": "Remove Image",
      "selectImageButton": "Select Image",
      "cropInstructions": "Crop the image",
      "confirmCropButton": "Confirm Crop and Upload",
      "errorInvalidDataTitle": "Invalid Data",
      "errorInvalidDataMsg": "Please fill in the names in both languages and a valid point cost (0 or greater).",
      "errorNameEsRequired": "Name in Spanish is required.",
      "errorNameEnRequired": "Name in English is required.",
      "errorImageTooSmall": "The image is too small. It must be at least {{minSize}}x{{minSize}} pixels.",
      "errorInvalidCrop": "Invalid crop selection or image. Ensure the crop has a size.",
      "errorCreatingCroppedFile": "Could not create the cropped image file.",
      "imageUploadSuccess": "Image cropped and uploaded successfully.",
      "errorApiNoUrl": "The API did not return a valid image URL.",
      "errorUploadingWithDetail": "Error uploading: {{error}}",
      "imageUploadError": "Could not upload the image: {{error}}",
      "errorMissingIdForUpdate": "Reward ID is missing for update.",
      "rewardFallbackName": "Reward",
      "altImagePreview": "Preview of {{name}}",
      "altCropImage": "Image to crop"
    },
    "generateQr": {
      "amountLabel": "Sale Amount (‚Ç¨):",
      "amountPlaceholder": "E.g.: 15.50",
      "ticketLabel": "Ticket Number:",
      "ticketPlaceholder": "E.g.: T-12345",
      "buttonText": "Generate QR Data",
      "errorAmountPositive": "The amount must be a positive number.",
      "errorTicketRequired": "Ticket number is required.",
      "successMessage": "QR Generated for {{amount}} ‚Ç¨!",
      "successInstructions": "Ask the customer to scan this code to get their points.",
      "tokenRef": "Token (ref.):",
      "errorGeneric": "Error generating QR: {{error}}",
      "initialPrompt": "Enter amount and ticket number to generate QR data."
    },
    "tierForm": {
      "nameLabel": "Tier Name",
      "namePlaceholder": "E.g.: Gold",
      "levelLabel": "Level (Order)",
      "levelPlaceholder": "E.g.: 3",
      "levelDescription": "Number for ordering tiers (0 or greater).",
      "minValueLabel": "Minimum Value to Reach",
      "minValuePlaceholder": "E.g.: 1500",
      "minValueDescription": "Spend (‚Ç¨), Visits or Points required (depending on business config).",
      "descriptionLabel": "Description (Optional)",
      "descriptionPlaceholder": "Brief description of the tier",
      "benefitsDescriptionLabel": "Benefits Summary (Optional)",
      "benefitsDescriptionPlaceholder": "Summary text of main benefits for the customer",
      "activeLabel": "Active Tier",
      "activeDescription": "If inactive, customers cannot reach it or see its benefits."
    },
    "tierBenefitsModal": {
      "modalTitle": "Manage Benefits - Tier: {{name}}",
      "addSectionTitle": "Add New Benefit",
      "listSectionTitle": "Current Benefits",
      "errorLoading": "Error loading benefits.",
      "noBenefits": "This tier has no defined benefits.",
      "addBenefitButton": "Add Benefit",
      "closeButton": "Close",
      "tableHeaderType": "Type",
      "tableHeaderValue": "Value",
      "tableHeaderDescription": "Description",
      "tableHeaderStatus": "Status",
      "tableHeaderActions": "Actions",
      "tooltipEditBenefit": "Edit Benefit",
      "tooltipDeleteBenefit": "Delete Benefit",
      "addSuccessTitle": "Benefit Added",
      "addSuccessMessage": "The new benefit has been added successfully.",
      "addErrorTitle": "Error Adding",
      "addErrorMessage": "Could not add the benefit.",
      "deleteUpcoming": "Benefit deletion not yet implemented.",
      "editUpcoming": "Benefit editing not yet implemented."
    },
    "addTierBenefitForm": {
      "typeLabel": "Benefit Type",
      "typePlaceholder": "Select a type",
      "valueLabel": "Value",
      "valuePlaceholder": "E.g.: 1.5, reward_id, 'X Discount'",
      "valueDescription": "Value associated with the type (number, ID, text)",
      "descriptionLabel": "Description (Optional)",
      "descriptionPlaceholder": "Additional details of the benefit",
      "activeLabel": "Active Benefit",
      "benefitType_POINTS_MULTIPLIER": "Points Multiplier",
      "benefitType_EXCLUSIVE_REWARD_ACCESS": "Exclusive Reward Access",
      "benefitType_CUSTOM_BENEFIT": "Custom Benefit",
      "errorValueRequired": "Value is required"
    }
  },
  "adminTiersManagePage": {
    "title": "Manage Tiers",
    "addButton": "Create New Tier",
    "tableHeaderLevel": "Level (Order)",
    "tableHeaderName": "Name",
    "tableHeaderThreshold": "Minimum Threshold",
    "tableHeaderBenefits": "Benefits",
    "tableHeaderStatus": "Status",
    "tableHeaderActions": "Actions",
    "tooltipManageBenefits": "Manage Benefits",
    "tooltipEditTier": "Edit Tier",
    "tooltipDeleteTier": "Delete Tier",
    "noTiersDefined": "No tiers defined yet.",
    "benefitsSummaryNone": "None",
    "benefitsSummaryNoneActive": "None active",
    "benefitsSummaryActive_one": "{{count}} active benefit",
    "benefitsSummaryActive_other": "{{count}} active benefits",
    "createModalTitle": "Create New Tier",
    "editModalTitle": "Edit Tier: {{name}}",
    "deleteModalTitle": "Confirm Deletion",
    "deleteModalMessage": "Are you sure you want to delete the tier \"{{name}}\"? This action cannot be undone.",
    "deleteModalConfirm": "Delete Tier",
    "createSuccessTitle": "Tier Created",
    "createSuccessMessage": "Tier \"{{name}}\" has been created successfully.",
    "createErrorTitle": "Error Creating",
    "createErrorMessage": "Could not create the tier.",
    "updateSuccessTitle": "Tier Updated",
    "updateSuccessMessage": "Tier \"{{name}}\" has been updated successfully.",
    "updateErrorTitle": "Error Updating",
    "updateErrorMessage": "Could not update the tier.",
    "deleteLoadingMessage": "Attempting to delete tier \"{{name}}\"",
    "deleteSuccessTitle": "Deleted!",
    "deleteSuccessMessage": "Tier \"{{name}}\" has been deleted successfully.",
    "deleteErrorTitle": "Error Deleting",
    "deleteErrorMessage": "Error deleting the tier.",
    "deleteErrorNotFound": "Selected tier for editing not found.",
    "deleteErrorInUse": "Cannot delete Tier {{id}} because it has assigned users. Reassign them first."
  },
  "adminTiersSettingsPage": {
    "title": "Tier System Configuration",
    "description": "Define here how your tier system works globally. Changes will apply to all customers.",
    "enableSystemLabel": "Enable Tier System",
    "enableSystemDescription": "Activates or deactivates tier calculation and its benefits.",
    "basisLabel": "Basis for Calculating Tier",
    "basisPlaceholder": "Select how tier is achieved",
    "basisPlaceholderDisabled": "N/A (System Disabled)",
    "basisDescription": "Main metric used to determine tier (Spend, Visits, or Historical Points).",
    "basisOption_SPEND": "Accumulated Spend (‚Ç¨)",
    "basisOption_VISITS": "Number of Visits",
    "basisOption_POINTS_EARNED": "Historical Points Earned",
    "periodLabel": "Calculation Period (Months)",
    "periodPlaceholder": "E.g.: 12",
    "periodPlaceholderNA": "N/A",
    "periodDescription": "Months back to calculate metric (0/empty = lifetime).",
    "downgradePolicyLabel": "Tier Downgrade Policy",
    "downgradePolicyPlaceholder": "Select how tiers are lowered",
    "downgradePolicyDescription": "Rule for tier downgrade (Never, Periodic Review, or After Inactivity).",
    "downgradePolicyOption_NEVER": "Never Downgrade",
    "downgradePolicyOption_PERIODIC_REVIEW": "Periodic Review",
    "downgradePolicyOption_AFTER_INACTIVITY": "After Inactivity",
    "inactivityLabel": "Months of Inactivity for Downgrade",
    "inactivityPlaceholder": "E.g.: 6",
    "inactivityDescription": "Months without activity to downgrade tier.",
    "editButton": "Edit Configuration",
    "saveButton": "Save Changes",
    "cancelButton": "Cancel",
    "errorLoading": "Error loading Tier configuration.",
    "errorSaving": "Error saving configuration.",
    "successSaving": "Settings have been saved successfully."
  },
  "adminCustomersPage": {
    "title": "Customer Management",
    "filterLabel": "Filters:",
    "searchPlaceholder": "Search by name or email...",
    "statusFilterPlaceholder": "Status",
    "statusFilterAll": "All Statuses",
    "statusFilterActive": "Active",
    "statusFilterInactive": "Inactive",
    "favoriteFilterLabel": "Favorites Only",
    "tierFilterPlaceholder": "Tier",
    "tierFilterAll": "All Tiers",
    "tierFilterNone": "No Tier (Basic)",
    "tierFilterError": "Error loading",
    "selectedCount_one": "{{count}} customer selected",
    "selectedCount_other": "{{count}} customers selected",
    "bulkDeleteButton": "Delete",
    "bulkActivateButton": "Activate",
    "bulkDeactivateButton": "Deactivate",
    "bulkPointsButton": "Points",
    "resultsCount_one": "{{count}} customer found",
    "resultsCount_other": "{{count}} customers found",
    "resultsCountFiltered": " with current criteria",
    "noResults": "No customers found.",
    "noResultsFiltered": "No customers found with current criteria.",
    "tableHeaderFavorite": "Fav.",
    "tableHeaderName": "Name",
    "tableHeaderEmail": "Email",
    "tableHeaderPoints": "Points",
    "tableHeaderTier": "Tier",
    "tableHeaderRegistered": "Registered",
    "tableHeaderStatus": "Status",
    "tableHeaderActions": "Actions",
    "tooltipViewDetails": "View Details",
    "tooltipAdjustPoints": "Adjust Points",
    "tooltipChangeTier": "Change Tier",
    "tooltipAssignReward": "Assign Reward",
    "tooltipDeactivateCustomer": "Deactivate Customer",
    "tooltipActivateCustomer": "Activate Customer",
    "tooltipFavorite": "Mark as Favorite",
    "tooltipUnfavorite": "Remove from Favorites",
    "checkboxAriaLabel": "Select row {{id}}",
    "checkboxSelectAllAriaLabel": "Select all visible rows",
    "adjustPointsModalTitle": "Adjust Points for {{name}}",
    "adjustPointsCurrent": "Current points: {{points}}",
    "adjustPointsAmountLabel": "Amount to Add/Subtract",
    "adjustPointsAmountPlaceholder": "E.g.: 50 (add) or -20 (subtract)",
    "adjustPointsReasonLabel": "Reason (Optional)",
    "adjustPointsReasonPlaceholder": "E.g.: Manual correction, Special bonus",
    "adjustPointsButton": "Adjust Points",
    "adjustPointsSuccess": "Points adjusted successfully for {{name}}.",
    "adjustPointsError": "Could not adjust points: {{error}}",
    "changeTierModalTitle": "Manually Change Tier for {{name}}",
    "changeTierCurrent": "Current tier: {{tierName}}",
    "changeTierSelectLabel": "Select New Tier",
    "changeTierSelectPlaceholder": "Choose a tier from the list",
    "changeTierOptionNone": "Remove Tier (Basic)",
    "changeTierOptionLevel": "Level {{level}}",
    "changeTierNotFound": "No tiers available or not found.",
    "changeTierButton": "Change Tier",
    "changeTierNoChange": "The selected tier is the same as the current one.",
    "changeTierNoChangeTitle": "No Changes",
    "changeTierSuccess": "Tier changed successfully for {{name}}.",
    "changeTierError": "Could not change tier: {{error}}",
    "changeTierErrorLoadingTiers": "Could not load tiers: {{error}}",
    "changeTierLoadingErrorTitle": "Error Loading Tiers",
    "assignRewardModalTitle": "Assign Reward as Gift to {{name}}",
    "assignRewardSelectLabel": "Select a Reward",
    "assignRewardSelectPlaceholder": "Choose a reward from the list",
    "assignRewardOptionPoints": "{{points}} pts",
    "assignRewardNotFound": "No rewards available or not found.",
    "assignRewardButton": "Assign Reward",
    "assignRewardSuccess": "Reward assigned successfully to {{name}}.",
    "assignRewardError": "Could not assign reward: {{error}}",
    "assignRewardErrorLoading": "Could not load rewards: {{error}}",
    "assignRewardLoadingErrorTitle": "Error Loading Rewards",
    "customerDetailsModalTitle": "Details for {{name}}",
    "customerDetailsLoadingError": "Error Loading Details",
    "customerDetailsPoints": "Current Points:",
    "customerDetailsTier": "Current Tier:",
    "customerDetailsTierDate": "Tier Achieved:",
    "customerDetailsStatus": "Status:",
    "customerDetailsFavorite": "Favorite:",
    "customerDetailsRegisteredDate": "Registration Date:",
    "customerDetailsAdminNotesLabel": "Admin Notes",
    "customerDetailsAdminNotesPlaceholder": "Add internal notes about this customer...",
    "customerDetailsSaveNotesButton": "Save Notes",
    "customerDetailsNoDetails": "No details found for this customer.",
    "customerDetailsNotesSaved": "Admin notes saved successfully.",
    "customerDetailsNotesError": "Could not save notes: {{error}}",
    "noCustomerSelected": "No customer selected.",
    "bulkActionNoneSelected": "No customers selected.",
    "bulkConfirmToggleActiveTitle": "Confirm Bulk Activation/Deactivation",
    "bulkConfirmToggleActiveMessage": "Are you sure you want to {{action}} {{count}} selected customer(s)?",
    "bulkConfirmToggleActivate": "activate",
    "bulkConfirmToggleDeactivate": "deactivate",
    "bulkConfirmDeleteTitle": "Confirm Bulk Deletion",
    "bulkConfirmDeleteMessage": "Are you sure you want to permanently delete {{count}} selected customer(s)? This action cannot be undone.",
    "bulkConfirmDeleteButton": "Delete Customers",
    "bulkActionStatusSuccess": "{{count}} customer(s) {{status}} successfully.",
    "bulkActionStatusActivated": "activated",
    "bulkActionStatusDeactivated": "deactivated",
    "bulkActionStatusError": "Could not {{action}} customers: {{error}}",
    "bulkActionDeleteSuccess": "{{count}} customer(s) deleted successfully.",
    "bulkActionDeleteError": "Could not delete customers: {{error}}",
    "bulkAdjustPointsModalTitle": "Adjust Points for {{count}} Selected Customer(s)",
    "bulkAdjustPointsAmountLabel": "Amount to Add/Subtract",
    "bulkAdjustPointsAmountPlaceholder": "E.g.: 50 (add) or -20 (subtract)",
    "bulkAdjustPointsReasonLabel": "Reason (Optional)",
    "bulkAdjustPointsReasonPlaceholder": "E.g.: Bulk bonus, General correction",
    "bulkAdjustPointsButton": "Adjust Points in Bulk",
    "bulkAdjustPointsSuccess": "{{points}} points {{action}} to {{count}} customer(s) successfully.",
    "bulkAdjustPointsAdded": "added",
    "bulkAdjustPointsSubtracted": "subtracted",
    "bulkAdjustPointsError": "Could not adjust points: {{error}}",
    "bulkAdjustPointsErrorNoneSelected": "Unexpected error: No customers selected."
  },
  "benefits": {
    "pointsMultiplier": "x{{value}} Points Multiplier",
    "exclusiveRewardAccess": "Exclusive Reward: {{value}}",
    "customBenefit": "{{value}}"
  },
  "superAdminPage": {
    "title": "Super Admin Panel",
    "searchPlaceholder": "Search businesses by name or slug...",
    "tableHeaderBusiness": "Business",
    "tableHeaderStatus": "General Status",
    "tableHeaderLoyalty": "Loyalty",
    "tableHeaderCamarero": "Waiter",
    "tableHeaderRegistered": "Registered",
    "noBusinesses": "No businesses registered.",
    "tooltipActivateBusiness": "Activate business",
    "tooltipDeactivateBusiness": "Deactivate business",
    "moduleLoyaltyCoreTooltip": "Activate/Deactivate Loyalty Module (LoyalPyME Core)",
    "moduleCamareroTooltip": "Activate/Deactivate Waiter Module",
    "statusChangeSuccess": "Business '{{businessName}}' status changed to {{status}}.",
    "statusChangeError": "Error changing business status.",
    "moduleChangeSuccess": "Module '{{moduleName}}' {{status}} for business '{{businessName}}'.",
    "moduleChangeError": "Error changing module '{{moduleName}}' status.",
    "moduleLoyaltyCore": "LoyalPyME Core",
    "moduleCamarero": "LoyalPyME Waiter",
    "businessFallbackName": "the business"
  },
  "adminCamarero": {
    "manageMenu": "Manage Menu",
    "manageTables": "Manage Tables",
    "cardMenuTitle": "Digital Menu",
    "cardMenuDesc": "Create and edit your menu's products, categories, and modifiers.",
    "cardMenuButton": "Manage Menu",
    "manageMenu.title": "Digital Menu Management",
    "manageMenu.categoriesSectionTitle": "Menu Categories",
    "manageMenu.categoryManagerPlaceholder": "Category Manager will go here...",
    "manageMenu.itemsSectionTitle": "Menu Items",
    "manageMenu.itemManagerPlaceholder": "Item Manager (by category) will go here...",
    "manageMenu.editCategoryTitle": "Edit Category",
    "manageMenu.addCategoryTitle": "Add New Category",
    "manageMenu.categoryNameEsPlaceholder": "E.g.: Starters, Desserts...",
    "manageMenu.categoryNameEnPlaceholder": "E.g.: Starters, Desserts...",
    "manageMenu.categoryDescEsPlaceholder": "Description in Spanish (optional)",
    "manageMenu.categoryDescEnPlaceholder": "Description in English (optional)",
    "manageMenu.categoryImagePreviewAlt": "Category image preview",
    "manageMenu.uploadImageButton": "Upload selected image",
    "manageMenu.categoryPositionLabel": "Position (Order)",
    "manageMenu.categoryPositionPlaceholder": "E.g.: 1, 2, 3...",
    "manageMenu.categoryPositionDesc": "Number for ordering (0 or greater). Lower appears first.",
    "manageMenu.categoryActiveLabel": "Active Category",
    "manageMenu.categoryActiveDesc": "If inactive, it will not be shown to customers.",
    "manageMenu.categoryCreateSuccess": "Category '{{name}}' created successfully.",
    "manageMenu.categoryUpdateSuccess": "Category '{{name}}' updated successfully.",
    "manageMenu.categoryDeleteSuccess": "Category deleted successfully.",
    "manageMenu.pendingImageUpload": "Please upload the selected image or remove it before saving.",
    "manageMenu.category": "Category",
    "manageMenu.item": "Item",
    "manageMenu.itemLabel": "Item",
    "manageMenu.editItemTitle": "Edit Item",
    "manageMenu.addItemTitle": "Add New Item",
    "manageMenu.itemNameEsPlaceholder": "E.g.: Classic Burger",
    "manageMenu.itemNameEnPlaceholder": "E.g.: Classic Burger",
    "manageMenu.itemDescEsPlaceholder": "Detailed description in Spanish...",
    "manageMenu.itemDescEnPlaceholder": "Detailed description in English...",
    "manageMenu.itemPrice": "Price",
    "manageMenu.itemAllergens": "Allergens",
    "manageMenu.itemAllergensPlaceholder": "Select or type allergens",
    "manageMenu.itemTags": "Tags",
    "manageMenu.itemTagsPlaceholder": "Select or type tags",
    "manageMenu.itemPosition": "Position",
    "manageMenu.itemPrepTime": "Prep Time (min)",
    "manageMenu.itemCalories": "Calories (kcal)",
    "manageMenu.itemSku": "SKU / Ref.",
    "manageMenu.itemKds": "KDS Destination",
    "manageMenu.itemKdsPlaceholder": "E.g.: Kitchen, Bar",
    "manageMenu.itemKdsDesc": "For kitchen/bar display systems (optional)",
    "manageMenu.itemIsAvailable": "Item Available",
    "manageMenu.itemIsAvailableDesc": "If unavailable, it will not be shown to customers.",
    "manageMenu.modifierGroupsTitle": "Modifier Groups",
    "manageMenu.manageGroupsButton": "Manage Groups",
    "manageMenu.modifierGroupsDescription": "Define option groups to customize this item (e.g.: Size, Extras, Sauces).",
    "manageMenu.itemCreateSuccess": "Item '{{name}}' created successfully.",
    "manageMenu.itemUpdateSuccess": "Item '{{name}}' updated successfully.",
    "manageMenu.itemDeleteSuccess": "Item deleted successfully.",
    "manageMenu.itemFallbackName": "Item",
    "manageMenu.itemNew": "New Item",
    "manageMenu.noItemsInCategory": "No items in this category yet.",
    "manageMenu.itemImageLabel": "Item Image",
    "manageMenu.itemAvailability": "Availability",
    "manageMenu.itemAvailable": "Available",
    "manageMenu.itemNotAvailable": "Not Available",
    "manageMenu.markAvailable": "Mark Available",
    "manageMenu.markNotAvailable": "Mark Not Available",
    "manageMenu.manageModifiersTooltip": "Manage Modifiers",
    "manageMenu.viewItemsTooltip": "View/Manage Items in this Category",
    "manageMenu.previewButton": "Preview Public Menu",
    "manageMenu.previewErrorNoSlug": "Could not get business identifier for preview.",
    "manageMenu.previewDisabledTooltip": "Business identifier unavailable for preview.",
    "manageMenu.toCategories": "to Categories",
    "manageMenu.modifierGroupCreateSuccess": "Group '{{name}}' created successfully.",
    "manageMenu.modifierGroupUpdateSuccess": "Group '{{name}}' updated successfully.",
    "manageMenu.modifierGroupDeleteSuccess": "Modifier group deleted successfully.",
    "menuCategoryForm": {
      "errorInvalidCropOrImage": "Invalid crop or image.",
      "errorUploadingWithDetail": "Error uploading: {{error}}",
      "altPreview": "Category preview",
      "altCropImage": "Image to crop",
      "imageUploadSuccess": "Category image uploaded successfully.",
      "errorCreatingCroppedFile": "Could not create cropped category image file.",
      "errorApiNoUrl": "API did not return a valid URL for the category image.",
      "imageUploadError": "Could not upload category image: {{error}}"
    },
    "menuItemForm": {
      "errorInvalidCropOrImage": "Invalid crop or image.",
      "errorCreatingCroppedFile": "Could not create cropped item image file.",
      "imageUploadSuccess": "Item image uploaded successfully.",
      "errorApiNoUrl": "API did not return a valid URL for the item image.",
      "errorUploadingWithDetail": "Error uploading item image: {{error}}",
      "imageUploadError": "Could not upload item image: {{error}}",
      "altPreview": "Item preview",
      "altCropImage": "Item image to crop"
    },
    "menuItem": {
      "allergen.GLUTEN": "Gluten",
      "allergen.LACTOSE": "Lactose",
      "allergen.NUTS": "Nuts",
      "allergen.SOY": "Soy",
      "allergen.FISH": "Fish",
      "allergen.CRUSTACEANS": "Crustaceans",
      "allergen.CELERY": "Celery",
      "allergen.MUSTARD": "Mustard",
      "allergen.SESAME": "Sesame",
      "allergen.SULPHITES": "Sulphites",
      "allergen.LUPIN": "Lupin",
      "allergen.MOLLUSCS": "Molluscs",
      "tag.VEGAN": "Vegan",
      "tag.VEGETARIAN": "Vegetarian",
      "tag.SPICY": "Spicy",
      "tag.NEW": "New",
      "tag.POPULAR": "Popular",
      "tag.HOUSE_SPECIAL": "House Special"
    },
    "modifierGroupsModal": {
      "title": "Manage Modifier Groups for: \"{{itemName}}\"",
      "existingGroupsTitle": "Existing Groups",
      "createNewGroupButton": "Create New Group",
      "noGroupsForItem": "No modifier groups for this item.",
      "tableHeaderName": "Name",
      "tableHeaderUiType": "UI Type",
      "tableHeaderSelections": "Selections (Min-Max)",
      "tableHeaderRequired": "Required",
      "tableHeaderPosition": "Position",
      "tooltipManageOptions": "Manage Options",
      "tooltipEditGroup": "Edit Group",
      "tooltipDeleteGroup": "Delete Group",
      "formEditTitle": "Editing Group: {{groupName}}",
      "formCreateTitle": "Create New Modifier Group",
      "formCreateButton": "Create Group",
      "closeButton": "Close Group Management"
    },
    "modifierGroupForm": {
      "nameEsLabel": "Name (ES)",
      "nameEnLabel": "Name (EN)",
      "uiTypeLabel": "User Interface (UI) Type",
      "uiType.RADIO": "Single Option (Radio)",
      "uiType.CHECKBOX": "Multiple Options (Checkbox)",
      "minSelectionsLabel": "Minimum Selections",
      "maxSelectionsLabel": "Maximum Selections",
      "positionLabel": "Position (Order)",
      "isRequiredLabel": "Is Required",
      "validation": {
        "nameEsRequired": "Name in Spanish is required.",
        "uiTypeInvalid": "Select a valid UI type.",
        "minSelectionsInvalid": "Minimum selections must be 0 or more.",
        "maxSelectionsInvalid": "Maximum selections must be 1 or more.",
        "minMaxMismatch": "Minimum selections cannot be greater than maximum."
      }
    },
    "modifierOptionsModal": {
      "title": "Options for Group: \"{{groupName}}\"",
      "existingOptionsTitle": "Existing Options",
      "createNewOptionButton": "Create New Option",
      "noOptionsForGroup": "No options for this group.",
      "tableHeaderName": "Name",
      "tableHeaderPriceAdjustment": "Price Adjustment",
      "tableHeaderPosition": "Position",
      "tableHeaderDefault": "Default",
      "tableHeaderAvailable": "Available",
      "formEditTitle": "Editing Option: {{optionName}}",
      "formCreateTitle": "Create New Modifier Option",
      "formCreateButton": "Create Option",
      "closeButton": "Close Option Management"
    },
    "modifierOptionForm": {
      "nameEsLabel": "Name (ES)",
      "nameEnLabel": "Name (EN)",
      "priceAdjustmentLabel": "Price Adjustment (‚Ç¨)",
      "priceAdjustmentDescription": "Positive to increase, negative to decrease, 0 for no change.",
      "positionLabel": "Position (Order)",
      "isDefaultLabel": "Selected by Default",
      "isAvailableLabel": "Option Available",
      "validation": {
        "nameEsRequired": "Name in Spanish is required."
      }
    },
    "modifierOption": {
      "statusAvailable": "Available",
      "statusNotAvailable": "Not Avail.",
      "tooltipEditOption": "Edit Option",
      "tooltipMarkAvailable": "Mark Available",
      "tooltipMarkNotAvailable": "Mark Not Available",
      "tooltipDeleteOption": "Delete Option"
    },
    "modifierGroupHook": {
      "errorNoMenuItemForGroup": "Error: Cannot add a group without an associated menu item.",
      "fallbackGroupName": "Group",
      "createSuccess": "Group '{{name}}' created successfully.",
      "updateSuccess": "Group '{{name}}' updated successfully.",
      "deleteSuccess": "Modifier group deleted successfully."
    },
    "modifierOptionHook": {
      "errorLoadingOptions": "Error loading modifier options.",
      "errorNoGroupForOption": "Cannot add an option without an associated modifier group.",
      "createSuccess": "Option \"{{optionName}}\" created successfully.",
      "fallbackOptionName": "Option",
      "errorCreatingOption": "Error creating option.",
      "updateSuccess": "Option \"{{optionName}}\" updated successfully.",
      "errorUpdatingOption": "Error updating option.",
      "deleteSuccess": "Modifier option deleted successfully.",
      "errorDeletingOption": "Error deleting option."
    },
    "menuItemHook": {
      "errorNoCategoryForItem": "Cannot add an item without a selected category."
    }
  },
  "publicMenu": {
    "unnamedItem": "Unnamed Item",
    "unnamedCategory": "Unnamed Category",
    "noCategories": "No menu categories available.",
    "noItemsInCategory": "No items in this category.",
    "menuNotAvailable": "Menu not available or not found.",
    "customizeButton": "Customize",
    "optionsTitle": "Customize your choice:",
    "itemNotesLabel": "Notes for this item (optional)",
    "itemNotesPlaceholder": "E.g.: No onion, extra spicy...",
    "quantity": "Quantity",
    "confirmAndAddToCart": "Confirm and Add to Cart",
    "customizeAndAdd": "Customize and Add",
    "addToCart": "Add to Cart",
    "itemAddedTitle": "Added!",
    "itemAddedMessage": "{{itemName}} (x{{quantity}}) added to cart.",
    "invalidSelectionTitle": "Invalid Selection",
    "invalidSelectionMsg": "Please complete all required modifier options.",
    "modifier.chooseOneRequired": "Choose 1 (required)",
    "modifier.chooseMinUpToMax_required": "Choose from {{min}} to {{max}} (required)",
    "modifier.chooseUpToMaxOptional": "Choose up to {{max}} (optional)",
    "modifier.chooseOneOptional": "Choose 1 (optional)",
    "modifier.chooseOptional": "Optional",
    "modifier.chooseAtLeastOneUpToMax_required": "Choose at least 1 up to {{max}} (required)",
    "cart": {
      "title": "Your Order",
      "total": "Total",
      "empty": "Your order cart is empty.",
      "itemNotesLabel": "Notes:",
      "removeItem": "Remove item",
      "orderNotesLabel": "Notes for the Order (Optional)",
      "orderNotesPlaceholder": "E.g.: General allergies, delivery preference...",
      "totalOrder": "Order Total:",
      "continueShopping": "Continue Shopping",
      "submitOrder": "Submit Order",
      "viewOrderItems_one": "View your order ({{count}} item)",
      "viewOrderItems_other": "View your order ({{count}} items)",
      "decreaseQuantity": "Decrease quantity of {{itemName}}",
      "itemQuantity": "Quantity for {{itemName}}",
      "increaseQuantity": "Increase quantity of {{itemName}}",
      "removeItemFromOrder": "Remove {{itemName}} from order",
      "errorTitle": "Order Error",
      "errorEmpty": "Your cart is empty. Add some items before submitting.",
      "orderSuccessTitle": "Order Submitted!",
      "orderSuccessMsg": "Your order #{{orderNumber}} has been received and is being prepared.",
      "orderErrorTitle": "Error Submitting",
      "orderErrorMsg": "Could not submit your order. Please try again or contact staff.",
      "clearCartButton": "Clear Cart",
      "clearedTitle": "Cart Cleared",
      "clearedMsg": "All items have been removed from your order.",
      "titleAddToOrder": "Add to Order #{{orderNumber}}",
      "submitAddToOrder": "Add to Order",
      "emptyAddToOrder": "Select items to add to your order.",
      "totalAddItems": "Total to Add:",
      "addItemsToOrderButton": "Add {{count}} items to Order #{{orderNumber}}",
      "itemsAddedSuccessTitle": "Items Added",
      "itemsAddedSuccessMsg": "Items added to order #{{orderNumber}}.",
      "addItemsErrorTitle": "Error Adding Items"
    },
    "unnamedModifier": "Unnamed Modifier",
    "activeOrder": {
      "addingToOrderTitle": "Adding to Order #{{orderNumber}}",
      "addingToOrderMsg": "New items will be added to your ongoing order.",
      "viewStatusButton": "View Order Status",
      "cannotAddTitle": "Cannot add items to Order #{{orderNumber}}",
      "cannotAddMsg": "The order no longer accepts new items. Please start a new order.",
      "startNewButton": "Start New Order",
      "startNewButtonAlt": "Create New Order"
    }
  },
  "error": {
    "missingBusinessSlug": "Error: Business slug not provided.",
    "noMenuDataReceived": "No menu data received."
  },
  "orderStatusPage": {
    "title": "Your Order Status",
    "error": {
      "missingOrderId": "Order ID not specified.",
      "noData": "No order status data received.",
      "notFound": "Order not found or unavailable.",
      "updateFailed": "Could not update status: {{message}}"
    },
    "generalStatus": "General Status:",
    "table": "Table:",
    "placedAt": "Placed at:",
    "itemsTitle": "Order Items",
    "quantity": "Quantity:",
    "orderNotesLabel": "General Order Notes",
    "refreshButton": "Refresh Status",
    "backToMenuButton": "Back to Menu",
    "addMoreItemsButton": "Add More Items",
    "requestBillButton": "Request Bill",
    "billRequestedSuccess": "Bill requested. A waiter will be with you shortly.",
    "errorRequestingBill": "Error requesting bill: {{message}}",
    "paidSuccessMessage": "Order Paid! Thank you for your visit.",
    "itemStatus": {
      "pending_kds": "Received in kitchen",
      "preparing": "Preparing",
      "ready": "Ready to serve",
      "served": "Served",
      "cancelled": "Cancelled",
      "cancellation_requested": "Cancellation Requested"
    },
    "orderStatus": {
      "received": "Received",
      "in_progress": "In Progress",
      "partially_ready": "Partially Ready",
      "all_items_ready": "All Items Ready",
      "completed": "Completed",
      "pending_payment": "Pending Payment",
      "paid": "Paid",
      "cancelled": "Cancelled",
      "payment_failed": "Payment Failed"
    },
    "kdsPage": {
      "title": "Kitchen Display System (KDS)",
      "destination": {
        "kitchen": "KITCHEN",
        "bar": "BAR"
      },
      "unknownItem": "Unknown Item",
      "noItems": "No pending items for this destination.",
      "quantity": "Quantity",
      "notes": "Notes",
      "noTable": "No Table",
      "createdAt": "KDS Received",
      "modifiers": "Modifiers:",
      "statusUpdateSuccessTitle": "Status Updated",
      "statusUpdateSuccessMsg": "Item \"{{itemName}}\" updated to {{status}}.",
      "statusUpdateErrorMsg": "Error updating item status.",
      "updateInProgressTitle": "Update in Progress",
      "updateInProgressMsg": "Wait for the current action to finish before starting another.",
      "refreshManual": "Refresh Manually",
      "action": {
        "startPreparing": "Start Preparing",
        "markReady": "Mark as Ready",
        "cancelItem": "Cancel Item"
      }
    }
  },
  "waiterInterface": {
    "pickupPageTitle": "Orders Ready for Pickup and Serving",
    "noItemsReady": "No items ready for pickup at this time.",
    "orderNumber": "Order",
    "pickupFrom": "Pick up from",
    "markAsServedButton": "Mark as Served",
    "actionInProgress": "Please wait for the current action to complete.",
    "itemMarkedServedSuccess": "Item '{{itemName}}' marked as served.",
    "errorMarkingServed": "Error marking item as served.",
    "navLinkPickup": "Pickup Orders"
  },
  "waiterOrderManagement": {
    "title": "Floor Order Management",
    "filterStatusLabel": "Filter by Status:",
    "statusOptionAll": "All Orders",
    "statusOptionPendingPayment": "Pending Payment",
    "statusOptionCompleted": "Completed (Not Paid)",
    "statusOptionPaid": "Paid",
    "noOrdersFound": "No orders found with the current filters.",
    "tableHeaderOrderNum": "Order #",
    "tableHeaderTable": "Table",
    "tableHeaderTotal": "Total",
    "tableHeaderStatus": "Status",
    "tableHeaderActions": "Actions",
    "buttonMarkAsPaid": "Mark As Paid",
    "buttonRequestBill": "Request Bill",
    "confirmMarkAsPaidTitle": "Confirm Payment",
    "confirmMarkAsPaidMessage": "Do you confirm that order #{{orderNumber}} has been paid?",
    "markAsPaidSuccess": "Order #{{orderNumber}} marked as paid.",
    "markAsPaidError": "Error marking order #{{orderNumber}} as paid: {{error}}",
    "paymentDetailsModalTitle": "Record Payment Details for Order #{{orderNumber}}",
    "paymentMethodLabel": "Payment Method",
    "paymentMethodPlaceholder": "E.g.: Cash, Visa Card",
    "paymentNotesLabel": "Payment Notes (Optional)",
    "paymentNotesPlaceholder": "Additional details...",
    "confirmPaymentButton": "Confirm Payment",
    "navLinkTitle": "Manage Orders"
  }
}


// ====== [116] frontend/public/locales/es/translation.json ======
{
  "common": {
    "loading": "Cargando...",
    "save": "Guardar",
    "cancel": "Cancelar",
    "delete": "Eliminar",
    "edit": "Editar",
    "add": "A√±adir",
    "confirm": "Confirmar",
    "close": "Cerrar",
    "error": "Error",
    "success": "√âxito",
    "requiredField": "Este campo es obligatorio.",
    "back": "Volver",
    "actions": "Acciones",
    "status": "Estado",
    "active": "Activo",
    "inactive": "Inactivo",
    "name": "Nombre",
    "description": "Descripci√≥n",
    "points": "Puntos",
    "level": "Nivel",
    "email": "Email",
    "registered": "Registrado",
    "yes": "S√≠",
    "no": "No",
    "searchPlaceholder": "Buscar...",
    "noResults": "No se encontraron resultados.",
    "selectPlaceholder": "Selecciona uno",
    "optional": "Opcional",
    "confirmAction": "Confirmar Acci√≥n",
    "noItems": "No hay elementos definidos todav√≠a.",
    "errorLoadingData": "Error al cargar datos",
    "info": "Informaci√≥n",
    "errorUnknown": "Error desconocido",
    "invalidDate": "Fecha inv√°lida",
    "upcomingFeatureTitle": "Pr√≥ximamente",
    "deleting": "Eliminando...",
    "customer": "Cliente",
    "selected": "seleccionado",
    "errorImageTooSmall": "La imagen es demasiado peque√±a. Debe ser al menos {{minSize}}x{{minSize}} p√≠xeles.",
    "errorMustBePositiveOrZero": "Debe ser un n√∫mero igual o mayor que 0.",
    "nameNotAvailable": "(Sin nombre)",
    "saveChanges": "Guardar Cambios",
    "camera": "C√°mara",
    "item": "√çtem"
  },
  "validation": {
    "cannotBeZero": "La cantidad no puede ser cero.",
    "benefitTypeRequired": "Selecciona un tipo de beneficio v√°lido.",
    "nameRequired": "El nombre es obligatorio.",
    "levelMin0": "El nivel debe ser 0 o mayor.",
    "minValueMin0": "El valor m√≠nimo debe ser 0 o mayor.",
    "mustBePositive": "Debe ser > 0",
    "invalidUrl": "URL de imagen no v√°lida."
  },
  "loginPage": {
    "title": "Iniciar Sesi√≥n",
    "subtitle": "¬øNo tienes cuenta?",
    "registerLink": "Reg√≠strate aqu√≠",
    "forgotPasswordLink": "¬øHas olvidado tu contrase√±a?",
    "emailLabel": "Email",
    "emailPlaceholder": "tu@email.com",
    "passwordLabel": "Contrase√±a",
    "passwordPlaceholder": "Tu contrase√±a",
    "loginButton": "Iniciar Sesi√≥n",
    "errorCredentials": "Credenciales inv√°lidas.",
    "errorServer": "Error del servidor durante el inicio de sesi√≥n.",
    "errorUnknown": "Ocurri√≥ un error inesperado.",
    "accessMenuDirectlyTitle": "¬øConoces el identificador del negocio?",
    "businessSlugPlaceholder": "Identificador del negocio (slug)",
    "goToMenuButton": "Ver Men√∫"
  },
  "registerPage": {
    "welcomeTitle": "¬°Bienvenido a LoyalPyME!",
    "title": "Crea tu Cuenta de Cliente",
    "subtitle": "¬øYa tienes cuenta?",
    "loginLink": "Inicia sesi√≥n",
    "emailLabel": "Email",
    "passwordLabel": "Contrase√±a",
    "confirmPasswordLabel": "Confirmar Contrase√±a",
    "nameLabel": "Nombre (Opcional)",
    "phoneLabel": "Tel√©fono (formato internacional)",
    "docTypeLabel": "Tipo de Documento",
    "docIdLabel": "N√∫mero de Documento",
    "businessLabel": "Negocio al que Unirse",
    "registerButton": "Registrarse",
    "errorLoadingBusinesses": "No se pudo cargar la lista de negocios.",
    "errorPasswordsDontMatch": "Las contrase√±as no coinciden.",
    "errorRegistration": "Error durante el registro.",
    "emailPlaceholder": "tu@email.com",
    "passwordPlaceholder": "Crea una contrase√±a",
    "confirmPasswordPlaceholder": "Repite la contrase√±a",
    "namePlaceholder": "Tu nombre y apellidos",
    "phonePlaceholder": "+346...",
    "docTypePlaceholder": "Selecciona uno",
    "docIdPlaceholder": "DNI, NIE, Pasaporte...",
    "businessSelectLoading": "Cargando negocios...",
    "businessSelectPlaceholder": "Selecciona un negocio",
    "businessSelectNotFound": "No hay negocios disponibles",
    "businessSelectError": "Error al cargar",
    "errorInvalidEmail": "Formato de email inv√°lido.",
    "errorPasswordLength": "La contrase√±a debe tener al menos 6 caracteres.",
    "errorConfirmPassword": "Confirma la contrase√±a.",
    "errorPhoneFormat": "Formato inv√°lido (ej: +346...).",
    "errorDocType": "Selecciona un tipo de documento.",
    "errorDNIFormat": "Formato DNI inv√°lido (8 n√∫meros y 1 letra).",
    "errorNIEFormat": "Formato NIE inv√°lido (letra, 7 n√∫meros, letra).",
    "errorBusinessRequired": "Debes seleccionar un negocio.",
    "successMessage": "Tu cuenta ha sido creada. Ser√°s redirigido a la p√°gina de inicio de sesi√≥n."
  },
  "forgotPasswordPage": {
    "title": "Restablecer Contrase√±a",
    "subtitle": "¬øRecuerdas tu contrase√±a?",
    "loginLink": "Volver a Inicio de Sesi√≥n",
    "instructions": "Introduce tu direcci√≥n de email y te enviaremos (o mostraremos en la consola del backend) un enlace para restablecer tu contrase√±a.",
    "emailLabel": "Email Registrado",
    "emailPlaceholder": "tu@email.com",
    "buttonText": "Solicitar Reseteo",
    "successTitle": "Solicitud Enviada",
    "successMessage": "Si existe una cuenta con ese email, recibir√°s (o ver√°s en consola) un enlace para restablecer la contrase√±a. El enlace expirar√° en 1 hora.",
    "errorTitle": "Error",
    "errorMissingEmail": "Por favor, introduce tu direcci√≥n de email.",
    "errorGenericTitle": "Solicitud Procesada",
    "errorGenericMessage": "Si existe una cuenta con ese email, recibir√°s (o ver√°s en consola) un enlace para restablecer la contrase√±a."
  },
  "resetPasswordPage": {
    "title": "Establecer Nueva Contrase√±a",
    "subtitle": "Introduce tu nueva contrase√±a a continuaci√≥n.",
    "passwordLabel": "Nueva Contrase√±a",
    "passwordPlaceholder": "Introduce tu nueva contrase√±a",
    "confirmPasswordLabel": "Confirmar Nueva Contrase√±a",
    "confirmPasswordPlaceholder": "Repite la nueva contrase√±a",
    "buttonText": "Guardar Nueva Contrase√±a",
    "loginLink": "Volver a Inicio de Sesi√≥n",
    "successTitle": "¬°Contrase√±a Cambiada!",
    "successMessage": "Tu contrase√±a ha sido restablecida con √©xito. Ser√°s redirigido a Inicio de Sesi√≥n.",
    "errorTitle": "Error al Restablecer",
    "errorMissingToken": "Falta el token de reseteo. Por favor, usa el enlace enviado a tu email.",
    "errorPasswordsRequired": "Por favor, introduce y confirma la nueva contrase√±a.",
    "errorPasswordsDontMatch": "Las contrase√±as no coinciden.",
    "errorPasswordLength": "La nueva contrase√±a debe tener al menos 6 caracteres.",
    "errorInvalidToken": "Error al restablecer la contrase√±a. El token podr√≠a ser inv√°lido o haber expirado."
  },
  "registerBusinessPage": {
    "title": "Registrar Nuevo Negocio",
    "subtitle": "Crea la cuenta para tu negocio y el administrador principal.",
    "businessNameLabel": "Nombre del Negocio",
    "businessNamePlaceholder": "Mi Cafeter√≠a Estupenda",
    "adminNameLabel": "Tu Nombre (Admin)",
    "adminNamePlaceholder": "Juan P√©rez",
    "adminEmailLabel": "Tu Email (Admin)",
    "adminEmailPlaceholder": "juan.perez@micafeteria.com",
    "adminPasswordLabel": "Contrase√±a (Admin)",
    "adminPasswordPlaceholder": "Tu contrase√±a",
    "confirmPasswordLabel": "Confirmar Contrase√±a",
    "confirmPasswordPlaceholder": "Repite tu contrase√±a",
    "registerButton": "Registrar Negocio",
    "loginLink": "Iniciar sesi√≥n",
    "loginLinkSubtitle": "¬øYa tienes una cuenta?",
    "successTitle": "¬°Registro Exitoso!",
    "successMessage": "El negocio '{{businessName}}' y el administrador {{adminEmail}} se han creado correctamente.",
    "errorTitle": "Error en el Registro",
    "errorRegistration": "No se pudo completar el registro. Int√©ntalo de nuevo.",
    "errorBusinessNameLength": "El nombre del negocio debe tener al menos 2 caracteres",
    "errorAdminEmailInvalid": "Email inv√°lido",
    "errorAdminPasswordLength": "La contrase√±a debe tener al menos 6 caracteres",
    "errorConfirmPasswordLength": "La confirmaci√≥n de contrase√±a debe tener al menos 6 caracteres",
    "errorPasswordsDontMatch": "Las contrase√±as no coinciden"
  },
  "header": {
    "greeting": "Hola, {{name}}!",
    "logoutButton": "Cerrar Sesi√≥n",
    "languageLabel": "Idioma",
    "toggleNavigation": "Alternar navegaci√≥n"
  },
  "customerDashboard": {
    "title": "Panel de Cliente",
    "points": "Puntos",
    "currentTier": "Nivel Actual:",
    "baseTier": "B√°sico",
    "validateQrSectionTitle": "Validar C√≥digo QR",
    "qrInputLabel": "Introduce el c√≥digo del ticket/QR",
    "qrInputPlaceholder": "Pega el c√≥digo aqu√≠...",
    "validateButton": "Validar C√≥digo",
    "scanButton": "Escanear QR",
    "scanModalTitle": "Escanear C√≥digo QR",
    "scanInstructions": "Apunta la c√°mara al c√≥digo QR",
    "scanCancelButton": "Cancelar Escaneo",
    "scanButtonDisabledTooltip": "Escanear QR solo disponible en m√≥vil",
    "rewardsSectionTitle": "Recompensas y Regalos",
    "noRewardsAvailable": "No hay recompensas ni regalos disponibles en este momento.",
    "redeemGiftButton": "Canjear Regalo",
    "redeemRewardButton": "Canjear Recompensa",
    "insufficientPoints": "Puntos insuficientes",
    "giftFree": "Gratis",
    "giftAssignedBy": "Regalado por {{assigner}} el {{date}}",
    "giftInfo": "Info",
    "errorLoadingProfile": "Error al cargar tu perfil: {{error}}",
    "errorLoadingRewards": "No se pudieron cargar las recompensas o regalos. {{error}}",
    "errorScanningQr": "Error de Esc√°ner",
    "errorScanningQrDefault": "No se pudo iniciar la c√°mara: {{error}}",
    "validating": "Validando...",
    "errorValidatingQr": "Error de Validaci√≥n",
    "errorValidatingQrMessage": "Error desconocido al validar QR.",
    "successQrValidation": "C√≥digo QR validado con √©xito. Has ganado {{points}} puntos.",
    "errorRedeemTitle": "Error al Canjear",
    "errorRedeemMessage": "Error desconocido al canjear.",
    "successRedeemRewardTitle": "¬°Recompensa Canjeada!",
    "successRedeemRewardMessage": "Has canjeado tu recompensa.",
    "successRedeemGiftTitle": "¬°Regalo Canjeado!",
    "successRedeemGiftMessage": "Has canjeado \"{{rewardName}}\".",
    "errorLoadingProfileTitle": "Error de Perfil",
    "errorLoadingProfileDefault": "No se pudieron cargar los datos del usuario.",
    "noUserDataError": "No se pudieron cargar los datos del usuario.",
    "tierBenefitsTitle": "Beneficios del Nivel: {{tierName}}",
    "progressUnitVisits": "visitas",
    "progressLabel": "{{currentValue}} / {{targetValue}} {{unit}} para alcanzar {{nextTierName}}",
    "maxLevelReached": "¬°Felicidades! Has alcanzado el nivel m√°ximo ({currentTierName}).",
    "maxLevelReachedShort": "¬°Nivel M√°ximo!",
    "nextTierBenefitsTitle": "Al alcanzar {{tierName}} tendr√°s:",
    "errorLoadingProgress": "No se pudieron cargar los datos de niveles para mostrar el progreso.",
    "tabSummary": "Resumen",
    "tabRewards": "Recompensas",
    "tabActivity": "Mi Actividad",
    "tabOffers": "Ofertas y Noticias",
    "tabProfile": "Mi Perfil",
    "summary": {
      "pendingGifts_one": "Tienes {{count}} regalo pendiente:",
      "pendingGifts_other": "Tienes {{count}} regalos pendientes:",
      "pendingGiftsDesc": "Tienes regalos esperando ser canjeados.",
      "nextReward": "Pr√≥xima recompensa: {{name}} por {{points}} puntos.",
      "viewAllButton": "Ver Todas las Recompensas y Regalos",
      "noRewardsInfo": "Acumula m√°s puntos para conseguir recompensas.",
      "giftsAndRewardsTitle": "Regalos y Recompensas Disponibles:",
      "rewardsTitle": "Recompensas Disponibles:",
      "unknownAssigner": "Desconocido",
      "redeemButton": "Canjear",
      "viewAllButtonShort": "Ver Todo",
      "viewMenuFor": "Ver Men√∫ de {{businessName}}",
      "viewMenuDefaultTitle": "Ver la Carta y Pedir",
      "viewMenuSubtitle": "Accede al men√∫ digital y haz tu pedido.",
      "viewMenuButton": "Ir a la Carta"
    },
    "activityTab": {
      "noActivity": "A√∫n no tienes actividad registrada.",
      "type_POINTS_EARNED_QR": "Puntos Ganados (QR)",
      "type_POINTS_REDEEMED_REWARD": "Recompensa Canjeada",
      "type_GIFT_REDEEMED": "Regalo Canjeado",
      "type_POINTS_ADJUSTED_ADMIN": "Ajuste Manual de Puntos",
      "totalItems": "{{count}} registro(s) en total",
      "desc_EARNED": "Puntos por ticket #{{ticketNumber}}",
      "desc_REDEEMED": "Canje: {{rewardName}}",
      "desc_GIFT": "Regalo canjeado: {{rewardName}}",
      "desc_ADJUSTED": "Ajuste manual de puntos",
      "desc_ADJUSTED_REASON": "Ajuste manual: {{reason}}"
    },
    "rewards": {
      "affordable": "Asequible"
    }
  },
  "adminCommon": {
    "dashboard": "Dashboard",
    "rewards": "Recompensas",
    "generateQr": "Generar QR",
    "customers": "Clientes",
    "manageTiers": "Gestionar Niveles",
    "tierSettings": "Config. Niveles",
    "saveSuccess": "Guardado con √©xito",
    "updateSuccess": "Actualizado con √©xito",
    "createSuccess": "Creado con √©xito",
    "deleteSuccess": "Eliminado con √©xito",
    "saveError": "Error al guardar",
    "updateError": "Error al actualizar",
    "createError": "Error al crear",
    "deleteError": "Error al eliminar",
    "confirmDeleteTitle": "Confirmar Eliminaci√≥n",
    "confirmDeleteMessage": "¬øEst√°s seguro? Esta acci√≥n no se puede deshacer.",
    "adminTitle": "LoyalPyME Admin"
  },
  "adminOverview": {
    "welcome": "¬°Bienvenido, {{name}}!",
    "panelIntro": "Est√°s en el panel de administraci√≥n de",
    "panelDescription": "Desde aqu√≠ podr√°s gestionar tu programa de fidelizaci√≥n: configura niveles, recompensas, clientes y genera c√≥digos QR.",
    "quickSummaryTitle": "Resumen R√°pido",
    "statActiveCustomers": "CLIENTES",
    "statNewCustomers": "NUEVOS (7D)",
    "statPointsIssued": "PUNTOS (7D)",
    "statRedemptions": "CANJES (7D)",
    "quickAccessTitle": "Accesos R√°pidos",
    "cardRewardsTitle": "Recompensas",
    "cardRewardsDesc": "Crea y administra las recompensas que tus clientes pueden canjear.",
    "cardRewardsButton": "Gestionar Recompensas",
    "cardTiersTitle": "Niveles Fidelizaci√≥n",
    "cardTiersDesc": "Define los diferentes niveles y beneficios para tus clientes.",
    "cardTiersButton": "Gestionar Niveles",
    "cardTierSettingsTitle": "Configuraci√≥n Niveles",
    "cardTierSettingsDesc": "Ajusta la l√≥gica de c√≥mo los clientes suben o bajan de nivel.",
    "cardTierSettingsButton": "Ajustar Configuraci√≥n",
    "cardQrTitle": "Generar QR Puntos",
    "cardQrDesc": "Crea c√≥digos QR √∫nicos para que tus clientes sumen puntos.",
    "cardQrButton": "Generar C√≥digo QR",
    "cardCustomersTitle": "Clientes",
    "cardCustomersDesc": "Consulta y gestiona la lista de tus clientes registrados.",
    "cardCustomersButton": "Gestionar Clientes",
    "errorLoadingStats": "No se pudieron cargar las estad√≠sticas.",
    "noStatsAvailable": "No hay datos estad√≠sticos disponibles.",
    "defaultBusinessName": "tu Negocio",
    "noModulesActivePrompt": "No hay m√≥dulos activos para este negocio. Act√≠valos desde el panel de Super Administrador."
  },
  "adminRewardsPage": {
    "title": "Gesti√≥n de Recompensas",
    "addButton": "A√±adir Recompensa",
    "cancelAddButton": "Cancelar A√±adir",
    "tableHeaderName": "Nombre",
    "tableHeaderCost": "Coste",
    "tableHeaderStatus": "Estado",
    "tableHeaderActions": "Acciones",
    "tooltipEdit": "Editar Recompensa",
    "tooltipDeactivate": "Desactivar",
    "tooltipActivate": "Activar",
    "tooltipDelete": "Eliminar Recompensa",
    "noRewardsYet": "A√∫n no has creado ninguna recompensa.",
    "addFormTitle": "A√±adir Nueva Recompensa",
    "editFormTitle": "Editar Recompensa",
    "confirmDeleteMessage": "¬øEst√°s seguro de que quieres eliminar la recompensa \"{{name}}\"? Esta acci√≥n no se puede deshacer.",
    "deleteSuccessMessage": "La recompensa \"{{name}}\" ha sido eliminada.",
    "deleteErrorNotFound": "No se encontr√≥ la recompensa \"{{name}}\" (quiz√°s ya fue eliminada).",
    "deleteErrorInUse": "No se puede eliminar \"{{name}}\" porque est√° en uso.",
    "toggleStatusSuccess": "La recompensa se ha {{status}} correctamente.",
    "toggleStatusError": "Error al {{status}} la recompensa: {{error}}",
    "statusActivated": "activada",
    "statusDeactivated": "desactivada",
    "updateSuccessMessage": "Recompensa \"{{name}}\" actualizada.",
    "createSuccessMessage": "Recompensa \"{{name}}\" creada."
  },
  "component": {
    "rewardForm": {
      "nameLabel": "Nombre de la Recompensa:",
      "namePlaceholder": "Ej: Caf√© Gratis",
      "descriptionLabel": "Descripci√≥n (Opcional):",
      "descriptionPlaceholder": "Ej: Un caf√© espresso o americano",
      "pointsCostLabel": "Coste en Puntos:",
      "pointsCostPlaceholder": "Ej: 100",
      "errorNameRequired": "El nombre de la recompensa no puede estar vac√≠o.",
      "errorPointsCostInvalid": "El coste en puntos debe ser un n√∫mero igual o mayor que cero.",
      "nameEsLabel": "Nombre (ES)",
      "nameEsPlaceholder": "Ej: Caf√© Gratis",
      "nameEnLabel": "Nombre (EN)",
      "nameEnPlaceholder": "E.g.: Free Coffee",
      "descriptionEsLabel": "Descripci√≥n (ES, Opcional)",
      "descriptionEsPlaceholder": "Ej: Un caf√© espresso o americano",
      "descriptionEnLabel": "Descripci√≥n (EN, Opcional)",
      "descriptionEnPlaceholder": "E.g.: One espresso or americano coffee",
      "imageLabel": "Imagen",
      "removeImageButton": "Quitar Imagen",
      "selectImageButton": "Seleccionar Imagen",
      "cropInstructions": "Recorta la imagen",
      "confirmCropButton": "Confirmar Recorte y Subir",
      "errorInvalidDataTitle": "Datos Inv√°lidos",
      "errorInvalidDataMsg": "Por favor, rellena los nombres en ambos idiomas y un coste en puntos v√°lido (0 o mayor).",
      "errorNameEsRequired": "El nombre en espa√±ol es obligatorio.",
      "errorNameEnRequired": "El nombre en ingl√©s es obligatorio.",
      "errorImageTooSmall": "La imagen es demasiado peque√±a. Debe ser al menos {{minSize}}x{{minSize}} p√≠xeles.",
      "errorInvalidCrop": "Selecci√≥n de recorte o imagen no v√°lida. Aseg√∫rate de que el recorte tiene un tama√±o.",
      "errorCreatingCroppedFile": "No se pudo crear el archivo de imagen recortada.",
      "imageUploadSuccess": "Imagen recortada y subida correctamente.",
      "errorApiNoUrl": "La API no devolvi√≥ una URL de imagen v√°lida.",
      "errorUploadingWithDetail": "Error al subir: {{error}}",
      "imageUploadError": "No se pudo subir la imagen: {{error}}",
      "errorMissingIdForUpdate": "Falta el ID de la recompensa para actualizar.",
      "rewardFallbackName": "Recompensa",
      "altImagePreview": "Vista previa de {{name}}",
      "altCropImage": "Imagen para recortar"
    },
    "generateQr": {
      "amountLabel": "Importe de la Venta (‚Ç¨):",
      "amountPlaceholder": "Ej: 15.50",
      "ticketLabel": "N√∫mero de Ticket:",
      "ticketPlaceholder": "Ej: T-12345",
      "buttonText": "Generar Datos QR",
      "errorAmountPositive": "El importe debe ser un n√∫mero positivo.",
      "errorTicketRequired": "El n√∫mero de ticket es obligatorio.",
      "successMessage": "¬°QR Generado para {{amount}} ‚Ç¨!",
      "successInstructions": "P√≠dele al cliente que escanee este c√≥digo para obtener sus puntos.",
      "tokenRef": "Token (ref.):",
      "errorGeneric": "Error al generar QR: {{error}}",
      "initialPrompt": "Introduce importe y n√∫mero de ticket para generar los datos del QR."
    },
    "tierForm": {
      "nameLabel": "Nombre del Nivel",
      "namePlaceholder": "Ej: Oro",
      "levelLabel": "Nivel (Orden)",
      "levelPlaceholder": "Ej: 3",
      "levelDescription": "N√∫mero para ordenar los niveles (0 o mayor).",
      "minValueLabel": "Valor M√≠nimo para Alcanzar",
      "minValuePlaceholder": "Ej: 1500",
      "minValueDescription": "Gasto (‚Ç¨), Visitas o Puntos necesarios (seg√∫n config. negocio).",
      "descriptionLabel": "Descripci√≥n (Opcional)",
      "descriptionPlaceholder": "Breve descripci√≥n del nivel",
      "benefitsDescriptionLabel": "Resumen Beneficios (Opcional)",
      "benefitsDescriptionPlaceholder": "Texto resumen de los beneficios principales para el cliente",
      "activeLabel": "Nivel Activo",
      "activeDescription": "Si est√° inactivo, los clientes no podr√°n alcanzarlo ni ver sus beneficios."
    },
    "tierBenefitsModal": {
      "modalTitle": "Gestionar Beneficios - Nivel: {{name}}",
      "addSectionTitle": "A√±adir Nuevo Beneficio",
      "listSectionTitle": "Beneficios Actuales",
      "errorLoading": "Error al cargar los beneficios.",
      "noBenefits": "Este nivel no tiene beneficios definidos.",
      "addBenefitButton": "A√±adir Beneficio",
      "closeButton": "Cerrar",
      "tableHeaderType": "Tipo",
      "tableHeaderValue": "Valor",
      "tableHeaderDescription": "Descripci√≥n",
      "tableHeaderStatus": "Estado",
      "tableHeaderActions": "Acciones",
      "tooltipEditBenefit": "Editar Beneficio",
      "tooltipDeleteBenefit": "Eliminar Beneficio",
      "addSuccessTitle": "Beneficio A√±adido",
      "addSuccessMessage": "El nuevo beneficio se ha a√±adido correctamente.",
      "addErrorTitle": "Error al A√±adir",
      "addErrorMessage": "No se pudo a√±adir el beneficio.",
      "deleteUpcoming": "Eliminaci√≥n de beneficios a√∫n no implementada.",
      "editUpcoming": "Edici√≥n de beneficios a√∫n no implementada."
    },
    "addTierBenefitForm": {
      "typeLabel": "Tipo de Beneficio",
      "typePlaceholder": "Selecciona un tipo",
      "valueLabel": "Valor",
      "valuePlaceholder": "Ej: 1.5, reward_id, 'Descuento X'",
      "valueDescription": "Valor asociado al tipo (n√∫mero, ID, texto)",
      "descriptionLabel": "Descripci√≥n (Opcional)",
      "descriptionPlaceholder": "Detalles adicionales del beneficio",
      "activeLabel": "Beneficio Activo",
      "benefitType_POINTS_MULTIPLIER": "Multiplicador de Puntos",
      "benefitType_EXCLUSIVE_REWARD_ACCESS": "Acceso a Recompensa Exclusiva",
      "benefitType_CUSTOM_BENEFIT": "Beneficio Personalizado",
      "errorValueRequired": "El valor es obligatorio"
    }
  },
  "adminTiersManagePage": {
    "title": "Gestionar Niveles (Tiers)",
    "addButton": "Crear Nuevo Nivel",
    "tableHeaderLevel": "Nivel (Orden)",
    "tableHeaderName": "Nombre",
    "tableHeaderThreshold": "Umbral M√≠nimo",
    "tableHeaderBenefits": "Beneficios",
    "tableHeaderStatus": "Estado",
    "tableHeaderActions": "Acciones",
    "tooltipManageBenefits": "Gestionar Beneficios",
    "tooltipEditTier": "Editar Nivel",
    "tooltipDeleteTier": "Eliminar Nivel",
    "noTiersDefined": "No hay niveles definidos todav√≠a.",
    "benefitsSummaryNone": "Ninguno",
    "benefitsSummaryNoneActive": "Ninguno activo",
    "benefitsSummaryActive_one": "{{count}} beneficio activo",
    "benefitsSummaryActive_other": "{{count}} beneficios activos",
    "createModalTitle": "Crear Nuevo Nivel",
    "editModalTitle": "Editar Nivel: {{name}}",
    "deleteModalTitle": "Confirmar Eliminaci√≥n",
    "deleteModalMessage": "¬øEst√°s seguro de que quieres eliminar el nivel \"{{name}}\"? Esta acci√≥n no se puede deshacer.",
    "deleteModalConfirm": "Eliminar Nivel",
    "createSuccessTitle": "Nivel Creado",
    "createSuccessMessage": "El nivel \"{{name}}\" se ha creado correctamente.",
    "createErrorTitle": "Error al Crear",
    "createErrorMessage": "No se pudo crear el nivel.",
    "updateSuccessTitle": "Nivel Actualizado",
    "updateSuccessMessage": "El nivel \"{{name}}\" se ha actualizado correctamente.",
    "updateErrorTitle": "Error al Actualizar",
    "updateErrorMessage": "No se pudo actualizar el nivel.",
    "deleteLoadingMessage": "Intentando eliminar el nivel \"{{name}}\"",
    "deleteSuccessTitle": "¬°Eliminado!",
    "deleteSuccessMessage": "El nivel \"{{name}}\" se ha eliminado correctamente.",
    "deleteErrorTitle": "Error al Eliminar",
    "deleteErrorMessage": "Error al eliminar el nivel.",
    "deleteErrorNotFound": "No se encontr√≥ el nivel seleccionado para editar.",
    "deleteErrorInUse": "No se puede eliminar el Nivel {{id}} porque tiene usuarios asignados. Reas√≠gnelos primero."
  },
  "adminTiersSettingsPage": {
    "title": "Configuraci√≥n del Sistema de Niveles (Tiers)",
    "description": "Define aqu√≠ c√≥mo funciona globalmente tu sistema de niveles. Los cambios se aplicar√°n a todos los clientes.",
    "enableSystemLabel": "Habilitar Sistema de Tiers",
    "enableSystemDescription": "Activa o desactiva el c√°lculo de niveles y sus beneficios.",
    "basisLabel": "Base para Calcular el Nivel",
    "basisPlaceholder": "Selecciona c√≥mo se alcanza el nivel",
    "basisPlaceholderDisabled": "N/A (Sistema Deshabilitado)",
    "basisDescription": "M√©trica principal usada para determinar el nivel (Gasto, Visitas o Puntos Hist√≥ricos).",
    "basisOption_SPEND": "Gasto Acumulado (‚Ç¨)",
    "basisOption_VISITS": "N√∫mero de Visitas",
    "basisOption_POINTS_EARNED": "Puntos Hist√≥ricos Ganados",
    "periodLabel": "Periodo de C√°lculo (Meses)",
    "periodPlaceholder": "Ej: 12",
    "periodPlaceholderNA": "N/A",
    "periodDescription": "Meses hacia atr√°s para calcular m√©trica (0/vac√≠o = de por vida).",
    "downgradePolicyLabel": "Pol√≠tica de Descenso de Nivel",
    "downgradePolicyPlaceholder": "Selecciona c√≥mo se bajan niveles",
    "downgradePolicyDescription": "Regla para bajar de nivel (Nunca, Revisi√≥n Peri√≥dica o Inactividad).",
    "downgradePolicyOption_NEVER": "Nunca Bajar",
    "downgradePolicyOption_PERIODIC_REVIEW": "Revisi√≥n Peri√≥dica",
    "downgradePolicyOption_AFTER_INACTIVITY": "Tras Inactividad",
    "inactivityLabel": "Meses de Inactividad para Descenso",
    "inactivityPlaceholder": "Ej: 6",
    "inactivityDescription": "Meses sin actividad para bajar de nivel.",
    "editButton": "Editar Configuraci√≥n",
    "saveButton": "Guardar Cambios",
    "cancelButton": "Cancelar",
    "errorLoading": "Error al cargar la configuraci√≥n de Tiers.",
    "errorSaving": "Error al guardar la configuraci√≥n.",
    "successSaving": "Los ajustes se han guardado correctamente."
  },
  "adminCustomersPage": {
    "title": "Gesti√≥n de Clientes",
    "filterLabel": "Filtros:",
    "searchPlaceholder": "Buscar por nombre o email...",
    "statusFilterPlaceholder": "Estado",
    "statusFilterAll": "Todos los Estados",
    "statusFilterActive": "Activo",
    "statusFilterInactive": "Inactivo",
    "favoriteFilterLabel": "Solo Favoritos",
    "tierFilterPlaceholder": "Nivel",
    "tierFilterAll": "Todos los Niveles",
    "tierFilterNone": "Sin Nivel (B√°sico)",
    "tierFilterError": "Error al cargar",
    "selectedCount_one": "{{count}} cliente seleccionado",
    "selectedCount_other": "{{count}} clientes seleccionados",
    "bulkDeleteButton": "Eliminar",
    "bulkActivateButton": "Activar",
    "bulkDeactivateButton": "Desactivar",
    "bulkPointsButton": "Puntos",
    "resultsCount_one": "{{count}} cliente encontrado",
    "resultsCount_other": "{{count}} clientes encontrados",
    "resultsCountFiltered": " con los criterios actuales",
    "noResults": "No se encontraron clientes.",
    "noResultsFiltered": "No se encontraron clientes con los criterios actuales.",
    "tableHeaderFavorite": "Fav.",
    "tableHeaderName": "Nombre",
    "tableHeaderEmail": "Email",
    "tableHeaderPoints": "Puntos",
    "tableHeaderTier": "Nivel",
    "tableHeaderRegistered": "Registrado",
    "tableHeaderStatus": "Estado",
    "tableHeaderActions": "Acciones",
    "tooltipViewDetails": "Ver Detalles",
    "tooltipAdjustPoints": "Ajustar Puntos",
    "tooltipChangeTier": "Cambiar Nivel",
    "tooltipAssignReward": "Asignar Recompensa",
    "tooltipDeactivateCustomer": "Desactivar Cliente",
    "tooltipActivateCustomer": "Activar Cliente",
    "tooltipFavorite": "Marcar como Favorito",
    "tooltipUnfavorite": "Quitar de Favoritos",
    "checkboxAriaLabel": "Seleccionar fila {{id}}",
    "checkboxSelectAllAriaLabel": "Seleccionar todas las filas visibles",
    "adjustPointsModalTitle": "Ajustar Puntos para {{name}}",
    "adjustPointsCurrent": "Puntos actuales: {{points}}",
    "adjustPointsAmountLabel": "Cantidad a A√±adir/Restar",
    "adjustPointsAmountPlaceholder": "Ej: 50 (a√±adir) o -20 (restar)",
    "adjustPointsReasonLabel": "Raz√≥n (Opcional)",
    "adjustPointsReasonPlaceholder": "Ej: Correcci√≥n manual, Bonificaci√≥n especial",
    "adjustPointsButton": "Ajustar Puntos",
    "adjustPointsSuccess": "Puntos ajustados correctamente para {{name}}.",
    "adjustPointsError": "No se pudo ajustar los puntos: {{error}}",
    "changeTierModalTitle": "Cambiar Nivel Manualmente para {{name}}",
    "changeTierCurrent": "Nivel actual: {{tierName}}",
    "changeTierSelectLabel": "Selecciona el Nuevo Nivel",
    "changeTierSelectPlaceholder": "Elige un nivel de la lista",
    "changeTierOptionNone": "Quitar Nivel (B√°sico)",
    "changeTierOptionLevel": "Nivel {{level}}",
    "changeTierNotFound": "No hay niveles disponibles o no se encontraron.",
    "changeTierButton": "Cambiar Nivel",
    "changeTierNoChange": "El nivel seleccionado es el mismo que el actual.",
    "changeTierNoChangeTitle": "Sin Cambios",
    "changeTierSuccess": "Nivel cambiado correctamente para {{name}}.",
    "changeTierError": "No se pudo cambiar el nivel: {{error}}",
    "changeTierErrorLoadingTiers": "No se pudieron cargar los niveles: {{error}}",
    "changeTierLoadingErrorTitle": "Error Cargando Niveles",
    "assignRewardModalTitle": "Asignar Recompensa como Regalo a {{name}}",
    "assignRewardSelectLabel": "Selecciona una Recompensa",
    "assignRewardSelectPlaceholder": "Elige una recompensa de la lista",
    "assignRewardOptionPoints": "{{points}} pts",
    "assignRewardNotFound": "No hay recompensas disponibles o no se encontraron.",
    "assignRewardButton": "Asignar Recompensa",
    "assignRewardSuccess": "Recompensa asignada correctamente a {{name}}.",
    "assignRewardError": "No se pudo asignar la recompensa: {{error}}",
    "assignRewardErrorLoading": "No se pudieron cargar las recompensas: {{error}}",
    "assignRewardLoadingErrorTitle": "Error Cargando Recompensas",
    "customerDetailsModalTitle": "Detalles de {{name}}",
    "customerDetailsLoadingError": "Error al Cargar Detalles",
    "customerDetailsPoints": "Puntos Actuales:",
    "customerDetailsTier": "Nivel Actual:",
    "customerDetailsTierDate": "Nivel Conseguido:",
    "customerDetailsStatus": "Estado:",
    "customerDetailsFavorite": "Favorito:",
    "customerDetailsRegisteredDate": "Fecha Registro:",
    "customerDetailsAdminNotesLabel": "Notas del Administrador",
    "customerDetailsAdminNotesPlaceholder": "A√±adir notas internas sobre este cliente...",
    "customerDetailsSaveNotesButton": "Guardar Notas",
    "customerDetailsNoDetails": "No se encontraron detalles para este cliente.",
    "customerDetailsNotesSaved": "Las notas del administrador se han guardado correctamente.",
    "customerDetailsNotesError": "No se pudieron guardar las notas: {{error}}",
    "noCustomerSelected": "No se ha seleccionado ning√∫n cliente.",
    "bulkActionNoneSelected": "No hay clientes seleccionados.",
    "bulkConfirmToggleActiveTitle": "Confirmar Activaci√≥n/Desactivaci√≥n Masiva",
    "bulkConfirmToggleActiveMessage": "¬øEst√°s seguro de que quieres {{action}} a {{count}} cliente(s) seleccionado(s)?",
    "bulkConfirmToggleActivate": "activar",
    "bulkConfirmToggleDeactivate": "desactivar",
    "bulkConfirmDeleteTitle": "Confirmar Eliminaci√≥n Masiva",
    "bulkConfirmDeleteMessage": "¬øEst√°s seguro de que quieres eliminar permanentemente a {{count}} cliente(s) seleccionado(s)? Esta acci√≥n no se puede deshacer.",
    "bulkConfirmDeleteButton": "Eliminar Clientes",
    "bulkActionStatusSuccess": "{{count}} cliente(s) {{status}} correctamente.",
    "bulkActionStatusActivated": "activados",
    "bulkActionStatusDeactivated": "desactivados",
    "bulkActionStatusError": "No se pudo {{action}} a los clientes: {{error}}",
    "bulkActionDeleteSuccess": "{{count}} cliente(s) eliminados correctamente.",
    "bulkActionDeleteError": "No se pudo eliminar a los clientes: {{error}}",
    "bulkAdjustPointsModalTitle": "Ajustar Puntos para {{count}} Cliente(s) Seleccionado(s)",
    "bulkAdjustPointsAmountLabel": "Cantidad a A√±adir/Restar",
    "bulkAdjustPointsAmountPlaceholder": "Ej: 50 (a√±adir) o -20 (restar)",
    "bulkAdjustPointsReasonLabel": "Raz√≥n (Opcional)",
    "bulkAdjustPointsReasonPlaceholder": "Ej: Bonificaci√≥n masiva, Correcci√≥n general",
    "bulkAdjustPointsButton": "Ajustar Puntos Masivamente",
    "bulkAdjustPointsSuccess": "{{points}} puntos {{action}} a {{count}} cliente(s) correctamente.",
    "bulkAdjustPointsAdded": "a√±adidos",
    "bulkAdjustPointsSubtracted": "restados",
    "bulkAdjustPointsError": "No se pudo ajustar los puntos: {{error}}",
    "bulkAdjustPointsErrorNoneSelected": "Error inesperado: No hay clientes seleccionados."
  },
  "benefits": {
    "pointsMultiplier": "Multiplicador x{{value}} Puntos",
    "exclusiveRewardAccess": "Recompensa Exclusiva: {{value}}",
    "customBenefit": "{{value}}"
  },
  "superAdminPage": {
    "title": "Panel de Super Administrador",
    "searchPlaceholder": "Buscar negocios por nombre o slug...",
    "tableHeaderBusiness": "Negocio",
    "tableHeaderStatus": "Estado General",
    "tableHeaderLoyalty": "Fidelizaci√≥n",
    "tableHeaderCamarero": "Camarero",
    "tableHeaderRegistered": "Registrado",
    "noBusinesses": "No hay negocios registrados.",
    "tooltipActivateBusiness": "Activar negocio",
    "tooltipDeactivateBusiness": "Desactivar negocio",
    "moduleLoyaltyCoreTooltip": "Activar/Desactivar M√≥dulo Fidelizaci√≥n (LoyalPyME Core)",
    "moduleCamareroTooltip": "Activar/Desactivar M√≥dulo Camarero",
    "statusChangeSuccess": "Estado del negocio '{{businessName}}' cambiado a {{status}}.",
    "statusChangeError": "Error al cambiar el estado del negocio.",
    "moduleChangeSuccess": "M√≥dulo '{{moduleName}}' {{status}} para el negocio '{{businessName}}'.",
    "moduleChangeError": "Error al cambiar el estado del m√≥dulo '{{moduleName}}'.",
    "moduleLoyaltyCore": "LoyalPyME Core",
    "moduleCamarero": "LoyalPyME Camarero",
    "businessFallbackName": "el negocio"
  },
  "adminCamarero": {
    "manageMenu": "Gestionar Carta",
    "manageTables": "Gestionar Mesas",
    "cardMenuTitle": "Carta Digital",
    "cardMenuDesc": "Crea y edita los productos, categor√≠as y modificadores de tu men√∫.",
    "cardMenuButton": "Gestionar Carta",
    "manageMenu.title": "Gesti√≥n de Carta Digital",
    "manageMenu.categoriesSectionTitle": "Categor√≠as del Men√∫",
    "manageMenu.categoryManagerPlaceholder": "Gestor de Categor√≠as ir√° aqu√≠...",
    "manageMenu.itemsSectionTitle": "√çtems del Men√∫",
    "manageMenu.itemManagerPlaceholder": "Gestor de √çtems (por categor√≠a) ir√° aqu√≠...",
    "manageMenu.editCategoryTitle": "Editar Categor√≠a",
    "manageMenu.addCategoryTitle": "A√±adir Nueva Categor√≠a",
    "manageMenu.categoryNameEsPlaceholder": "Ej: Entrantes, Postres...",
    "manageMenu.categoryNameEnPlaceholder": "Ej: Starters, Desserts...",
    "manageMenu.categoryDescEsPlaceholder": "Descripci√≥n en espa√±ol (opcional)",
    "manageMenu.categoryDescEnPlaceholder": "Descripci√≥n en ingl√©s (opcional)",
    "manageMenu.categoryImagePreviewAlt": "Vista previa de la imagen de categor√≠a",
    "manageMenu.uploadImageButton": "Subir imagen seleccionada",
    "manageMenu.categoryPositionLabel": "Posici√≥n (Orden)",
    "manageMenu.categoryPositionPlaceholder": "Ej: 1, 2, 3...",
    "manageMenu.categoryPositionDesc": "N√∫mero para ordenar (0 o mayor). Menor aparece primero.",
    "manageMenu.categoryActiveLabel": "Categor√≠a Activa",
    "manageMenu.categoryActiveDesc": "Si est√° inactiva, no se mostrar√° a los clientes.",
    "manageMenu.categoryCreateSuccess": "Categor√≠a '{{name}}' creada con √©xito.",
    "manageMenu.categoryUpdateSuccess": "Categor√≠a '{{name}}' actualizada con √©xito.",
    "manageMenu.categoryDeleteSuccess": "Categor√≠a eliminada con √©xito.",
    "manageMenu.pendingImageUpload": "Por favor, sube la imagen seleccionada o elim√≠nala antes de guardar.",
    "manageMenu.category": "Categor√≠a",
    "manageMenu.item": "√çtem",
    "manageMenu.itemLabel": "√çtem",
    "manageMenu.editItemTitle": "Editar √çtem",
    "manageMenu.addItemTitle": "A√±adir Nuevo √çtem",
    "manageMenu.itemNameEsPlaceholder": "Ej: Hamburguesa Cl√°sica",
    "manageMenu.itemNameEnPlaceholder": "Ej: Classic Burger",
    "manageMenu.itemDescEsPlaceholder": "Descripci√≥n detallada en espa√±ol...",
    "manageMenu.itemDescEnPlaceholder": "Descripci√≥n detallada en ingl√©s...",
    "manageMenu.itemPrice": "Precio",
    "manageMenu.itemAllergens": "Al√©rgenos",
    "manageMenu.itemAllergensPlaceholder": "Selecciona o escribe al√©rgenos",
    "manageMenu.itemTags": "Etiquetas",
    "manageMenu.itemTagsPlaceholder": "Selecciona o escribe etiquetas",
    "manageMenu.itemPosition": "Posici√≥n",
    "manageMenu.itemPrepTime": "Tiempo Prep. (min)",
    "manageMenu.itemCalories": "Calor√≠as (kcal)",
    "manageMenu.itemSku": "SKU / Ref.",
    "manageMenu.itemKds": "Destino KDS",
    "manageMenu.itemKdsPlaceholder": "Ej: Cocina, Barra",
    "manageMenu.itemKdsDesc": "Para sistemas de pantalla en cocina/barra (opcional)",
    "manageMenu.itemIsAvailable": "√çtem Disponible",
    "manageMenu.itemIsAvailableDesc": "Si no est√° disponible, no se mostrar√° a los clientes.",
    "manageMenu.modifierGroupsTitle": "Grupos de Modificadores",
    "manageMenu.manageGroupsButton": "Gestionar Grupos",
    "manageMenu.modifierGroupsDescription": "Define grupos de opciones para personalizar este √≠tem (ej: Tama√±o, Extras, Salsas).",
    "manageMenu.itemCreateSuccess": "√çtem '{{name}}' creado con √©xito.",
    "manageMenu.itemUpdateSuccess": "√çtem '{{name}}' actualizado con √©xito.",
    "manageMenu.itemDeleteSuccess": "√çtem eliminado con √©xito.",
    "manageMenu.itemFallbackName": "√çtem",
    "manageMenu.itemNew": "Nuevo √çtem",
    "manageMenu.noItemsInCategory": "No hay √≠tems en esta categor√≠a todav√≠a.",
    "manageMenu.itemImageLabel": "Imagen del √çtem",
    "manageMenu.itemAvailability": "Disponibilidad",
    "manageMenu.itemAvailable": "Disponible",
    "manageMenu.itemNotAvailable": "No Disponible",
    "manageMenu.markAvailable": "Marcar Disponible",
    "manageMenu.markNotAvailable": "Marcar No Disponible",
    "manageMenu.manageModifiersTooltip": "Gestionar Modificadores",
    "manageMenu.viewItemsTooltip": "Ver/Gestionar √çtems de esta Categor√≠a",
    "manageMenu.previewButton": "Previsualizar Carta P√∫blica",
    "manageMenu.previewErrorNoSlug": "No se pudo obtener el identificador del negocio para la previsualizaci√≥n.",
    "manageMenu.previewDisabledTooltip": "Identificador de negocio no disponible para previsualizar.",
    "manageMenu.toCategories": "a Categor√≠as",
    "manageMenu.modifierGroupCreateSuccess": "Grupo '{{name}}' creado con √©xito.",
    "manageMenu.modifierGroupUpdateSuccess": "Grupo '{{name}}' actualizado con √©xito.",
    "manageMenu.modifierGroupDeleteSuccess": "Grupo de modificadores eliminado con √©xito.",
    "menuCategoryForm": {
      "errorInvalidCropOrImage": "Recorte o imagen no v√°lida.",
      "errorUploadingWithDetail": "Error al subir: {{error}}",
      "altPreview": "Vista previa de la categor√≠a",
      "altCropImage": "Imagen para recortar",
      "imageUploadSuccess": "Imagen de categor√≠a subida correctamente.",
      "errorCreatingCroppedFile": "No se pudo crear el archivo de imagen de categor√≠a recortada.",
      "errorApiNoUrl": "La API no devolvi√≥ una URL v√°lida para la imagen de categor√≠a.",
      "imageUploadError": "No se pudo subir la imagen de categor√≠a: {{error}}"
    },
    "menuItemForm": {
      "errorInvalidCropOrImage": "Recorte o imagen no v√°lida.",
      "errorCreatingCroppedFile": "No se pudo crear el archivo de imagen de √≠tem recortada.",
      "imageUploadSuccess": "Imagen de √≠tem subida correctamente.",
      "errorApiNoUrl": "La API no devolvi√≥ una URL v√°lida para la imagen de √≠tem.",
      "errorUploadingWithDetail": "Error al subir imagen de √≠tem: {{error}}",
      "imageUploadError": "No se pudo subir la imagen de √≠tem: {{error}}",
      "altPreview": "Vista previa del √≠tem",
      "altCropImage": "Imagen del √≠tem para recortar"
    },
    "menuItem": {
      "allergen.GLUTEN": "Gluten",
      "allergen.LACTOSE": "Lactosa",
      "allergen.NUTS": "Frutos Secos",
      "allergen.SOY": "Soja",
      "allergen.FISH": "Pescado",
      "allergen.CRUSTACEANS": "Crust√°ceos",
      "allergen.CELERY": "Apio",
      "allergen.MUSTARD": "Mostaza",
      "allergen.SESAME": "S√©samo",
      "allergen.SULPHITES": "Sulfitos",
      "allergen.LUPIN": "Altramuces",
      "allergen.MOLLUSCS": "Moluscos",
      "tag.VEGAN": "Vegano",
      "tag.VEGETARIAN": "Vegetariano",
      "tag.SPICY": "Picante",
      "tag.NEW": "Nuevo",
      "tag.POPULAR": "Popular",
      "tag.HOUSE_SPECIAL": "Especialidad de la Casa"
    },
    "modifierGroupsModal": {
      "title": "Gestionar Grupos de Modificadores para: \"{{itemName}}\"",
      "existingGroupsTitle": "Grupos Existentes",
      "createNewGroupButton": "Crear Nuevo Grupo",
      "noGroupsForItem": "No hay grupos de modificadores para este √≠tem.",
      "tableHeaderName": "Nombre",
      "tableHeaderUiType": "Tipo UI",
      "tableHeaderSelections": "Selecciones (Min-Max)",
      "tableHeaderRequired": "Requerido",
      "tableHeaderPosition": "Posici√≥n",
      "tooltipManageOptions": "Gestionar Opciones",
      "tooltipEditGroup": "Editar Grupo",
      "tooltipDeleteGroup": "Eliminar Grupo",
      "formEditTitle": "Editando Grupo: {{groupName}}",
      "formCreateTitle": "Crear Nuevo Grupo de Modificadores",
      "formCreateButton": "Crear Grupo",
      "closeButton": "Cerrar Gesti√≥n de Grupos"
    },
    "modifierGroupForm": {
      "nameEsLabel": "Nombre (ES)",
      "nameEnLabel": "Nombre (EN)",
      "uiTypeLabel": "Tipo de Interfaz de Usuario (UI)",
      "uiType.RADIO": "Opci√≥n √önica (Radio)",
      "uiType.CHECKBOX": "M√∫ltiples Opciones (Checkbox)",
      "minSelectionsLabel": "M√≠nimo Selecciones",
      "maxSelectionsLabel": "M√°ximo Selecciones",
      "positionLabel": "Posici√≥n (Orden)",
      "isRequiredLabel": "Es Requerido",
      "validation": {
        "nameEsRequired": "El nombre en espa√±ol es obligatorio.",
        "uiTypeInvalid": "Selecciona un tipo de UI v√°lido.",
        "minSelectionsInvalid": "M√≠nimo de selecciones debe ser 0 o m√°s.",
        "maxSelectionsInvalid": "M√°ximo de selecciones debe ser 1 o m√°s.",
        "minMaxMismatch": "El m√≠nimo de selecciones no puede ser mayor que el m√°ximo."
      }
    },
    "modifierOptionsModal": {
      "title": "Opciones para Grupo: \"{{groupName}}\"",
      "existingOptionsTitle": "Opciones Existentes",
      "createNewOptionButton": "Crear Nueva Opci√≥n",
      "noOptionsForGroup": "No hay opciones para este grupo.",
      "tableHeaderName": "Nombre",
      "tableHeaderPriceAdjustment": "Ajuste Precio",
      "tableHeaderPosition": "Posici√≥n",
      "tableHeaderDefault": "Por Defecto",
      "tableHeaderAvailable": "Disponible",
      "formEditTitle": "Editando Opci√≥n: {{optionName}}",
      "formCreateTitle": "Crear Nueva Opci√≥n de Modificador",
      "formCreateButton": "Crear Opci√≥n",
      "closeButton": "Cerrar Gesti√≥n de Opciones"
    },
    "modifierOptionForm": {
      "nameEsLabel": "Nombre (ES)",
      "nameEnLabel": "Nombre (EN)",
      "priceAdjustmentLabel": "Ajuste de Precio (‚Ç¨)",
      "priceAdjustmentDescription": "Positivo para aumentar, negativo para disminuir, 0 sin cambio.",
      "positionLabel": "Posici√≥n (Orden)",
      "isDefaultLabel": "Seleccionada por Defecto",
      "isAvailableLabel": "Opci√≥n Disponible",
      "validation": {
        "nameEsRequired": "El nombre en espa√±ol es obligatorio."
      }
    },
    "modifierOption": {
      "statusAvailable": "Disponible",
      "statusNotAvailable": "No Disp.",
      "tooltipEditOption": "Editar Opci√≥n",
      "tooltipMarkAvailable": "Marcar Disponible",
      "tooltipMarkNotAvailable": "Marcar No Disponible",
      "tooltipDeleteOption": "Eliminar Opci√≥n"
    },
    "modifierGroupHook": {
      "errorNoMenuItemForGroup": "Error: No se puede a√±adir un grupo sin un √≠tem de men√∫ asociado.",
      "fallbackGroupName": "Grupo",
      "createSuccess": "Grupo '{{name}}' creado con √©xito.",
      "updateSuccess": "Grupo '{{name}}' actualizado con √©xito.",
      "deleteSuccess": "Grupo de modificadores eliminado con √©xito."
    },
    "modifierOptionHook": {
      "errorLoadingOptions": "Error cargando opciones de modificador.",
      "errorNoGroupForOption": "No se puede a√±adir una opci√≥n sin un grupo de modificadores asociado.",
      "createSuccess": "Opci√≥n \"{{optionName}}\" creada correctamente.",
      "fallbackOptionName": "Opci√≥n",
      "errorCreatingOption": "Error al crear la opci√≥n.",
      "updateSuccess": "Opci√≥n \"{{optionName}}\" actualizada correctamente.",
      "errorUpdatingOption": "Error al actualizar la opci√≥n.",
      "deleteSuccess": "Opci√≥n de modificador eliminada correctamente.",
      "errorDeletingOption": "Error al eliminar la opci√≥n."
    },
    "menuItemHook": {
      "errorNoCategoryForItem": "No se puede a√±adir un √≠tem sin una categor√≠a seleccionada."
    }
  },
  "publicMenu": {
    "unnamedItem": "√çtem sin nombre",
    "unnamedCategory": "Categor√≠a sin nombre",
    "noCategories": "No hay categor√≠as de men√∫ disponibles.",
    "noItemsInCategory": "No hay √≠tems en esta categor√≠a.",
    "menuNotAvailable": "Men√∫ no disponible o no encontrado.",
    "customizeButton": "Personalizar",
    "optionsTitle": "Personaliza tu elecci√≥n:",
    "itemNotesLabel": "Notas para este √≠tem (opcional)",
    "itemNotesPlaceholder": "Ej: Sin cebolla, extra picante...",
    "quantity": "Cantidad",
    "confirmAndAddToCart": "Confirmar y A√±adir",
    "customizeAndAdd": "Personalizar y A√±adir",
    "addToCart": "A√±adir al Carrito",
    "itemAddedTitle": "¬°A√±adido!",
    "itemAddedMessage": "{{itemName}} (x{{quantity}}) a√±adido al carrito.",
    "invalidSelectionTitle": "Selecci√≥n Inv√°lida",
    "invalidSelectionMsg": "Por favor, completa todas las opciones obligatorias de los modificadores.",
    "modifier.chooseOneRequired": "Elige 1 (obligatorio)",
    "modifier.chooseMinUpToMax_required": "Elige de {{min}} a {{max}} (obligatorio)",
    "modifier.chooseUpToMaxOptional": "Elige hasta {{max}} (opcional)",
    "modifier.chooseOneOptional": "Elige 1 (opcional)",
    "modifier.chooseOptional": "Opcional",
    "modifier.chooseAtLeastOneUpToMax_required": "Elige al menos 1 hasta {{max}} (obligatorio)",
    "cart": {
      "title": "Tu Pedido",
      "total": "Total",
      "empty": "Tu carrito de pedido est√° vac√≠o.",
      "itemNotesLabel": "Notas:",
      "removeItem": "Eliminar √≠tem",
      "orderNotesLabel": "Notas para el Pedido (Opcional)",
      "orderNotesPlaceholder": "Ej: Alergias generales, preferencia de entrega...",
      "totalOrder": "Total del Pedido:",
      "continueShopping": "Seguir Pidiendo",
      "submitOrder": "Enviar Pedido",
      "viewOrderItems_one": "Ver tu pedido ({{count}} √≠tem)",
      "viewOrderItems_other": "Ver tu pedido ({{count}} √≠tems)",
      "decreaseQuantity": "Disminuir cantidad de {{itemName}}",
      "itemQuantity": "Cantidad para {{itemName}}",
      "increaseQuantity": "Aumentar cantidad de {{itemName}}",
      "removeItemFromOrder": "Eliminar {{itemName}} del pedido",
      "errorTitle": "Error en Pedido",
      "errorEmpty": "Tu carrito est√° vac√≠o. A√±ade algunos √≠tems antes de enviar.",
      "orderSuccessTitle": "¬°Pedido Enviado!",
      "orderSuccessMsg": "Tu pedido #{{orderNumber}} ha sido recibido y se est√° preparando.",
      "orderErrorTitle": "Error al Enviar",
      "orderErrorMsg": "No se pudo enviar tu pedido. Por favor, int√©ntalo de nuevo o contacta con el personal.",
      "clearCartButton": "Vaciar Carrito",
      "clearedTitle": "Carrito Vac√≠o",
      "clearedMsg": "Se han eliminado todos los √≠tems de tu pedido.",
      "titleAddToOrder": "A√±adir a Pedido #{{orderNumber}}",
      "submitAddToOrder": "A√±adir al Pedido",
      "emptyAddToOrder": "Selecciona √≠tems para a√±adir a tu pedido.",
      "totalAddItems": "Total a A√±adir:",
      "addItemsToOrderButton": "A√±adir {{count}} √≠tems al Pedido #{{orderNumber}}",
      "itemsAddedSuccessTitle": "√çtems A√±adidos",
      "itemsAddedSuccessMsg": "√çtems a√±adidos al pedido #{{orderNumber}}.",
      "addItemsErrorTitle": "Error al A√±adir √çtems"
    },
    "unnamedModifier": "Modificador sin nombre",
    "activeOrder": {
      "addingToOrderTitle": "A√±adiendo al Pedido #{{orderNumber}}",
      "addingToOrderMsg": "Los nuevos √≠tems se a√±adir√°n a tu pedido en curso.",
      "viewStatusButton": "Ver Estado del Pedido",
      "cannotAddTitle": "No se pueden a√±adir √≠tems al Pedido #{{orderNumber}}",
      "cannotAddMsg": "El pedido ya no acepta nuevos √≠tems. Comienza un nuevo pedido.",
      "startNewButton": "Empezar Nuevo Pedido",
      "startNewButtonAlt": "Crear Pedido Nuevo"
    }
  },
  "error": {
    "missingBusinessSlug": "Error: Slug del negocio no proporcionado.",
    "noMenuDataReceived": "No se recibieron datos del men√∫."
  },
  "orderStatusPage": {
    "title": "Estado de tu Pedido",
    "error": {
      "missingOrderId": "No se especific√≥ un ID de pedido.",
      "noData": "No se recibieron datos del estado del pedido.",
      "notFound": "Pedido no encontrado o no disponible.",
      "updateFailed": "No se pudo actualizar el estado: {{message}}"
    },
    "generalStatus": "Estado General:",
    "table": "Mesa:",
    "placedAt": "Realizado el:",
    "itemsTitle": "√çtems del Pedido",
    "quantity": "Cantidad:",
    "orderNotesLabel": "Notas Generales del Pedido",
    "refreshButton": "Actualizar Estado",
    "backToMenuButton": "Volver al Men√∫",
    "addMoreItemsButton": "A√±adir m√°s √≠tems",
    "requestBillButton": "Pedir la Cuenta",
    "billRequestedSuccess": "Cuenta solicitada. Un camarero se acercar√° pronto.",
    "errorRequestingBill": "Error al solicitar la cuenta: {{message}}",
    "paidSuccessMessage": "¬°Pedido Pagado! Gracias por tu visita.",
    "itemStatus": {
      "pending_kds": "Recibido en cocina",
      "preparing": "En preparaci√≥n",
      "ready": "Listo para servir",
      "served": "Entregado",
      "cancelled": "Cancelado",
      "cancellation_requested": "Cancelaci√≥n Solicitada"
    },
    "orderStatus": {
      "received": "Recibido",
      "in_progress": "En Progreso",
      "partially_ready": "Parcialmente Listo",
      "all_items_ready": "Todos los √çtems Listos",
      "completed": "Completado",
      "pending_payment": "Pendiente de Pago",
      "paid": "Pagado",
      "cancelled": "Cancelado",
      "payment_failed": "Pago Fallido"
    },
    "kdsPage": {
      "title": "Pantalla de Cocina (KDS)",
      "destination": {
        "kitchen": "COCINA",
        "bar": "BARRA"
      },
      "unknownItem": "√çtem Desconocido",
      "noItems": "No hay √≠tems pendientes para este destino.",
      "quantity": "Cantidad",
      "notes": "Notas",
      "noTable": "Sin Mesa",
      "createdAt": "Recibido KDS",
      "modifiers": "Modificadores:",
      "statusUpdateSuccessTitle": "Estado Actualizado",
      "statusUpdateSuccessMsg": "El √≠tem \"{{itemName}}\" se actualiz√≥ a {{status}}.",
      "statusUpdateErrorMsg": "Error al actualizar estado del √≠tem.",
      "updateInProgressTitle": "Actualizaci√≥n en Progreso",
      "updateInProgressMsg": "Espera a que finalice la acci√≥n actual antes de iniciar otra.",
      "refreshManual": "Refrescar Manualmente",
      "action": {
        "startPreparing": "Empezar Preparaci√≥n",
        "markReady": "Marcar como Listo",
        "cancelItem": "Cancelar √çtem"
      }
    }
  },
  "waiterInterface": {
    "pickupPageTitle": "Pedidos Listos para Recoger y Servir",
    "noItemsReady": "No hay √≠tems listos para recoger en este momento.",
    "orderNumber": "Pedido",
    "pickupFrom": "Recoger de",
    "markAsServedButton": "Marcar como Servido",
    "actionInProgress": "Por favor, espera a que la acci√≥n actual termine.",
    "itemMarkedServedSuccess": "√çtem '{{itemName}}' marcado como servido.",
    "errorMarkingServed": "Error al marcar el √≠tem como servido.",
    "navLinkPickup": "Recoger Pedidos"
  },
  "waiterOrderManagement": {
    "title": "Gesti√≥n de Pedidos de Sala",
    "filterStatusLabel": "Filtrar por Estado:",
    "statusOptionAll": "Todos los Pedidos",
    "statusOptionPendingPayment": "Pendientes de Pago",
    "statusOptionCompleted": "Completados (No Pagados)",
    "statusOptionPaid": "Pagados",
    "noOrdersFound": "No se encontraron pedidos con los filtros actuales.",
    "tableHeaderOrderNum": "N¬∫ Pedido",
    "tableHeaderTable": "Mesa",
    "tableHeaderTotal": "Total",
    "tableHeaderStatus": "Estado",
    "tableHeaderActions": "Acciones",
    "buttonMarkAsPaid": "Marcar Como Pagado",
    "buttonRequestBill": "Solicitar Cuenta",
    "confirmMarkAsPaidTitle": "Confirmar Pago",
    "confirmMarkAsPaidMessage": "¬øConfirmas que el pedido #{{orderNumber}} ha sido pagado?",
    "markAsPaidSuccess": "Pedido #{{orderNumber}} marcado como pagado.",
    "markAsPaidError": "Error al marcar el pedido #{{orderNumber}} como pagado: {{error}}",
    "paymentDetailsModalTitle": "Registrar Detalles del Pago para Pedido #{{orderNumber}}",
    "paymentMethodLabel": "M√©todo de Pago",
    "paymentMethodPlaceholder": "Ej: Efectivo, Tarjeta Visa",
    "paymentNotesLabel": "Notas del Pago (Opcional)",
    "paymentNotesPlaceholder": "Detalles adicionales...",
    "confirmPaymentButton": "Confirmar Pago",
    "navLinkTitle": "Gestionar Pedidos"
  }
}


// ====== [117] frontend/src/App.tsx ======
// filename: frontend/src/App.tsx
// Version: 1.0.2 (Clean comments, fix encoding)

import AppRoutes from './routes/index'; // Importa el componente que define las rutas

// Opcional: Importar estilos globales si se usan activamente
// import './index.css';

function App() {
  // Renderiza el componente AppRoutes que maneja las p√°ginas seg√∫n la URL
  return (
    <div className="App"> {/* Clase global opcional */}
      <AppRoutes />
    </div>
  );
}

export default App;

// End of File: frontend/src/App.tsx


// ====== [118] frontend/src/i18n.ts ======
// filename: frontend/src/i18n.ts
// Version: 1.4.1 (Enable debug mode)

import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import HttpApi from 'i18next-http-backend';
import LanguageDetector from 'i18next-browser-languagedetector';

i18n
  .use(HttpApi)
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    supportedLngs: ['es', 'en'],
    fallbackLng: 'es',
    defaultNS: 'translation',
    backend: {
      loadPath: '/locales/{{lng}}/{{ns}}.json',
    },
    detection: {
      order: ['localStorage', 'navigator'],
      caches: ['localStorage'],
      lookupLocalStorage: 'i18nextLng',
    },
    // --- A√ëADIR ESTA L√çNEA ---
    debug: true, // Muestra logs detallados de i18next en la consola
    // --- FIN A√ëADIR ---
    interpolation: {
      escapeValue: false,
    },
    react: {
      useSuspense: true,
    }
  });

export default i18n;

// End of File: frontend/src/i18n.ts


// ====== [119] frontend/src/index.css ======
/* File: frontend/src/index.css */
/* Version: 1.0.6 (Simplify font-family variable) */

:root {
  /* --- CAMBIO: Simplificar fuente --- */
  --font-family-sans: sans-serif;
  /* --- FIN CAMBIO --- */
  --font-family-mono: Consolas, 'Courier New', monospace;

  /* Paleta Modo Claro (Predeterminado) */
  --color-text: #213547;
  --color-background: #ffffff;
  --color-primary: #646cff;
  --color-primary-light: #747bff;
  --color-secondary: #f9f9f9; /* Un gris muy claro */
  --color-border: #e0e0e0;
  --color-error: #d32f2f;
  --color-success: #388e3c;

  /* Paleta Modo Oscuro */
  --color-text-dark: rgba(255, 255, 255, 0.87);
  --color-background-dark: #242424;
  --color-primary-dark: #747bff;
  --color-primary-light-dark: #535bf2;
  --color-secondary-dark: #1a1a1a;
  --color-border-dark: #444;
  --color-error-dark: #ef5350;
  --color-success-dark: #66bb6a;

  line-height: 1.6;
  font-weight: 400;
  color-scheme: light dark;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

@media (prefers-color-scheme: dark) {
  :root {
    /* Aplicar variables modo oscuro */
     --color-text: var(--color-text-dark);
     --color-background: var(--color-background-dark);
     --color-primary: var(--color-primary-dark);
     --color-primary-light: var(--color-primary-light-dark);
     --color-secondary: var(--color-secondary-dark);
     --color-border: var(--color-border-dark);
     --color-error: var(--color-error-dark);
     --color-success: var(--color-success-dark);
  }
}

*, *::before, *::after {
  box-sizing: border-box;
}

html, body {
  /* Aplicar fuente base y colores */
  font-family: var(--font-family-sans); /* Ahora usar√° 'sans-serif' */
  color: var(--color-text);
  background-color: var(--color-background);
}


body {
  margin: 0;
  min-height: 100vh;
}

/* Estilos base para elementos comunes */
h1, h2, h3, h4 {
  margin-top: 0;
  font-weight: 700;
  font-family: inherit; /* Forzar herencia de fuente */
}
h1 {
  font-size: 2.5em;
  line-height: 1.1;
  margin-bottom: 1rem;
}
h2 {
  font-size: 1.8em;
  line-height: 1.2;
  margin-bottom: 0.75rem;
  border-bottom: 1px solid var(--color-border);
  padding-bottom: 0.25em;
}
a {
  font-weight: 500;
  color: var(--color-primary);
  text-decoration: inherit;
  transition: color 0.2s ease;
}
a:hover {
  color: var(--color-primary-light);
}
button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: var(--color-secondary);
  color: var(--color-text);
  cursor: pointer;
  transition: border-color 0.25s, background-color 0.2s ease;
}
button:hover {
  border-color: var(--color-primary);
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
  outline-color: var(--color-primary-light);
}
button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
input[type="text"],
input[type="email"],
input[type="password"],
input[type="number"],
textarea {
    display: block;
    width: 100%;
    padding: 0.6em 0.8em;
    font-size: 1em;
    font-family: inherit;
    line-height: 1.5;
    border: 1px solid var(--color-border);
    border-radius: 6px;
    background-color: var(--color-background);
    color: var(--color-text);
    margin-bottom: 0.75rem;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
input:focus,
textarea:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 2px var(--color-primary-light);
}
label {
    display: block;
    margin-bottom: 0.25rem;
    font-weight: 500;
}
.text-error {
  color: var(--color-error);
  font-size: 0.9em;
}
.text-success {
  color: var(--color-success);
  font-size: 0.9em;
}

/* End of File: frontend/src/index.css */


// ====== [120] frontend/src/main.tsx ======
// filename: frontend/src/main.tsx
// Version: 1.4.0 (Import i18n config and add Suspense)

import React from 'react'; // Necesario para Suspense
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

// Mantine Imports
import '@mantine/core/styles.css';
import { MantineProvider, Loader, Center } from '@mantine/core'; // A√±adido Loader y Center para fallback
import { Notifications } from '@mantine/notifications';
import '@mantine/notifications/styles.css';
import { ModalsProvider } from '@mantine/modals';
import { theme } from './theme';

// React Router
import { BrowserRouter } from 'react-router-dom';

// --- NUEVO: Importar la configuraci√≥n de i18next ---
// Simplemente importarlo aqu√≠ ejecuta el c√≥digo de inicializaci√≥n
import './i18n';
// --- FIN NUEVO ---

// Renderizar la aplicaci√≥n React
ReactDOM.createRoot(document.getElementById('root')!).render(
  // MantineProvider y BrowserRouter envuelven todo
  <MantineProvider theme={theme}>
    <BrowserRouter>
      {/* --- NUEVO: Envolver App con Suspense --- */}
      {/* Muestra un loader mientras i18next carga las traducciones iniciales */}
      <React.Suspense fallback={
          <Center style={{ height: '100vh' }}> {/* Centrar el loader */}
            <Loader color="blue" />
          </Center>
        }>
        <ModalsProvider>
          <Notifications position="top-right" zIndex={1000} />
          <App /> {/* App ahora est√° dentro de Suspense */}
        </ModalsProvider>
      </React.Suspense>
      {/* --- FIN NUEVO --- */}
    </BrowserRouter>
  </MantineProvider>
);

// Ocultar/Eliminar el loader inicial HTML (sin cambios)
const loaderElement = document.getElementById('initial-loader');
if (loaderElement) {
     loaderElement.remove();
     console.log("Initial loader removed.");
 }

// End of file: frontend/src/main.tsx


// ====== [121] frontend/src/modules/camarero/components/admin/menu/MenuCategoryFormModal.tsx ======
// frontend/src/components/admin/camarero/menu/MenuCategoryFormModal.tsx
// Version 2.0.1 (Corrected aspect ratio to 1:1 and minDimension to 150px)

import React, { useEffect } from 'react';
import {
    Modal, TextInput, Textarea, NumberInput, Switch, Button, Group, Stack, Text
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next';
import { IconDeviceFloppy } from '@tabler/icons-react';
import { MenuCategoryData, MenuCategoryFormData } from '../../../types/menu.types';

// Importar el componente reutilizable
import ImageUploadCropper from '../../../../../shared/components/utils/ImageUploadCropper';

const createCategoryFormSchema = (t: Function) => z.object({
  name_es: z.string().min(1, { message: t('common.requiredField') }),
  name_en: z.string().nullable().optional(),
  description_es: z.string().nullable().optional(),
  description_en: z.string().nullable().optional(),
  imageUrl: z.string().url({ message: t('validation.invalidUrl') }).nullable().optional(),
  position: z.number().min(0, { message: t('validation.minValueMin0') }),
  isActive: z.boolean(),
});

type CategoryFormValues = z.infer<ReturnType<typeof createCategoryFormSchema>>;

interface MenuCategoryFormModalProps {
    opened: boolean;
    onClose: () => void;
    onSubmit: (values: MenuCategoryFormData) => Promise<void>;
    initialData?: MenuCategoryData | null;
    isSubmitting: boolean;
}

const MenuCategoryFormModal: React.FC<MenuCategoryFormModalProps> = ({
    opened,
    onClose,
    onSubmit,
    initialData,
    isSubmitting,
}) => {
    const { t } = useTranslation();
    
    const form = useForm<CategoryFormValues>({
        initialValues: {
            name_es: '', name_en: null, description_es: null, description_en: null,
            imageUrl: null, position: 0, isActive: true,
        },
        validate: zodResolver(createCategoryFormSchema(t)),
    });

    useEffect(() => {
        if (opened) {
            if (initialData) {
                form.setValues({
                    name_es: initialData.name_es, name_en: initialData.name_en || null,
                    description_es: initialData.description_es || null, description_en: initialData.description_en || null,
                    imageUrl: initialData.imageUrl || null, position: initialData.position, isActive: initialData.isActive,
                });
            } else {
                form.reset();
            }
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, initialData]);


    const handleSubmitForm = async (values: CategoryFormValues) => {
        const submitData: MenuCategoryFormData = {
            name_es: values.name_es, name_en: values.name_en?.trim() || null,
            description_es: values.description_es?.trim() || null, description_en: values.description_en?.trim() || null,
            imageUrl: values.imageUrl || null, position: values.position, isActive: values.isActive,
        };
        await onSubmit(submitData);
    };

    const handleModalClose = () => { if (!isSubmitting) onClose(); }

    return (
        <Modal
            opened={opened} onClose={handleModalClose}
            title={initialData ? t('adminCamarero.manageMenu.editCategoryTitle') : t('adminCamarero.manageMenu.addCategoryTitle')}
            centered size="lg" overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
            trapFocus closeOnClickOutside={!isSubmitting} closeOnEscape={!isSubmitting}
        >
            <form onSubmit={form.onSubmit(handleSubmitForm)}>
                <Stack gap="md">
                    <TextInput label={t('component.rewardForm.nameEsLabel')} placeholder={t('adminCamarero.manageMenu.categoryNameEsPlaceholder')} required disabled={isSubmitting} {...form.getInputProps('name_es')} />
                    <TextInput label={t('component.rewardForm.nameEnLabel')} placeholder={t('adminCamarero.manageMenu.categoryNameEnPlaceholder')} disabled={isSubmitting} {...form.getInputProps('name_en')} />
                    <Textarea label={t('component.rewardForm.descriptionEsLabel')} placeholder={t('adminCamarero.manageMenu.categoryDescEsPlaceholder')} rows={2} disabled={isSubmitting} {...form.getInputProps('description_es')} />
                    <Textarea label={t('component.rewardForm.descriptionEnLabel')} placeholder={t('adminCamarero.manageMenu.categoryDescEnPlaceholder')} rows={2} disabled={isSubmitting} {...form.getInputProps('description_en')} />
                    
                    <ImageUploadCropper
                        aspectRatio={1} // <-- CORRECCI√ìN AQU√ç: Cambiado de 16/9 a 1
                        minDimension={150} // <-- CORRECCI√ìN AQU√ç: Cambiado de 300 a 150
                        initialImageUrl={form.values.imageUrl || null}
                        onUploadSuccess={(url) => form.setFieldValue('imageUrl', url)}
                        onUploadError={(errorMsg) => form.setFieldError('imageUrl', errorMsg)}
                        onClearImage={() => form.setFieldValue('imageUrl', null)}
                        folderName="loyalpyme/categories"
                        disabled={isSubmitting}
                        imagePreviewAltText={t('adminCamarero.menuCategoryForm.altPreview')}
                    />
                     {form.errors.imageUrl && (
                        <Text c="red" size="xs" mt={-10}>{form.errors.imageUrl}</Text>
                    )}

                    <NumberInput label={t('adminCamarero.manageMenu.categoryPositionLabel')} placeholder={t('adminCamarero.manageMenu.categoryPositionPlaceholder')} description={t('adminCamarero.manageMenu.categoryPositionDesc')} required min={0} step={1} allowDecimal={false} disabled={isSubmitting} {...form.getInputProps('position')} />
                    <Switch label={t('adminCamarero.manageMenu.categoryActiveLabel')} description={t('adminCamarero.manageMenu.categoryActiveDesc')} mt="sm" disabled={isSubmitting} {...form.getInputProps('isActive', { type: 'checkbox' })} />

                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={handleModalClose} disabled={isSubmitting}>
                            {t('common.cancel')}
                        </Button>
                        <Button type="submit" loading={isSubmitting} disabled={isSubmitting} leftSection={<IconDeviceFloppy size={18} />} >
                            {initialData ? t('common.save') : t('common.add')}
                        </Button>
                    </Group>
                </Stack>
            </form>
        </Modal>
    );
};

export default MenuCategoryFormModal;


// ====== [122] frontend/src/modules/camarero/components/admin/menu/MenuCategoryManager.tsx ======
// frontend/src/components/admin/camarero/menu/MenuCategoryManager.tsx
import React, { useState } from 'react';
import {
    Button,
    Text, 
    Stack,
    Group,
    Loader,
    Alert,
    Table,
    ActionIcon,
    Badge,
    Image as MantineImage,
    AspectRatio,
    Center,
    Tooltip,
    Box // <--- A√ëADIDO Box
} from '@mantine/core';
import { IconPlus, IconAlertCircle, IconPencil, IconTrash, IconPhoto, IconPlayerPlay, IconPlayerStop, IconListDetails } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useModals } from '@mantine/modals';

import { useAdminMenuCategories } from '../../../hooks/useAdminMenuCategories';
import { MenuCategoryData, MenuCategoryFormData } from '../../../types/menu.types';
import MenuCategoryFormModal from './MenuCategoryFormModal';

interface MenuCategoryManagerProps {
    onSelectCategoryForItems: (category: MenuCategoryData) => void;
}

const MenuCategoryManager: React.FC<MenuCategoryManagerProps> = ({ onSelectCategoryForItems }) => {
    const { t, i18n } = useTranslation();
    const modals = useModals();
    const currentLanguage = i18n.language;

    const {
        categories,
        loading: loadingCategories,
        error: errorCategories,
        addCategory,
        updateCategory,
        deleteCategory,
    } = useAdminMenuCategories();

    const [modalOpened, setModalOpened] = useState(false);
    const [editingCategory, setEditingCategory] = useState<MenuCategoryData | null>(null);
    const [isSubmittingForm, setIsSubmittingForm] = useState(false);
    const [isUpdatingStatusId, setIsUpdatingStatusId] = useState<string | null>(null);
    const [isDeletingId, setIsDeletingId] = useState<string | null>(null);

    // console.log("[MenuCategoryManager - V2 con Prop] Renderizando. Categor√≠as:", categories.length, "Loading:", loadingCategories);

    const handleOpenAddModal = () => { setEditingCategory(null); setModalOpened(true); };
    const handleOpenEditModal = (category: MenuCategoryData) => { setEditingCategory(category); setModalOpened(true); };
    const handleCloseModal = () => { setModalOpened(false); setEditingCategory(null); };

    const handleSubmitCategoryForm = async (formData: MenuCategoryFormData) => {
        setIsSubmittingForm(true);
        let success = false;
        if (editingCategory) {
            const result = await updateCategory(editingCategory.id, formData);
            if (result) success = true;
        } else {
            const result = await addCategory(formData);
            if (result) success = true;
        }
        if (success) { handleCloseModal(); }
        setIsSubmittingForm(false);
    };

    const handleDeleteCategoryClick = (category: MenuCategoryData) => {
        const categoryName = (currentLanguage === 'es' ? category.name_es : category.name_en) || category.name_es || `ID ${category.id}`;
        modals.openConfirmModal({
            title: t('adminCommon.confirmDeleteTitle'), centered: true,
            children: ( <Text size="sm"> {t('adminCommon.confirmDeleteMessage')}{' '} {t('adminCamarero.manageMenu.category')}: <strong>"{categoryName}"</strong>? </Text> ),
            labels: { confirm: t('common.delete'), cancel: t('common.cancel') }, confirmProps: { color: 'red' },
            onConfirm: async () => { setIsDeletingId(category.id); await deleteCategory(category.id); setIsDeletingId(null); },
        });
    };

    const handleToggleCategoryActive = async (category: MenuCategoryData) => {
        setIsUpdatingStatusId(category.id);
        const newStatus = !category.isActive;
        try { await updateCategory(category.id, { isActive: newStatus }); }
        catch (error) { console.error(`Error toggling status for category ${category.id}:`, error); }
        finally { setIsUpdatingStatusId(null); }
    };

    const rows = categories.map((category) => {
        const displayName = (currentLanguage === 'es' ? category.name_es : category.name_en) || category.name_es || 'N/A';
        const isLoadingThisRowStatus = isUpdatingStatusId === category.id;
        const isLoadingThisRowDelete = isDeletingId === category.id;
        const disableActions = isSubmittingForm || !!isDeletingId || !!isUpdatingStatusId;

        return (
            <Table.Tr key={category.id}>
                <Table.Td>
                    <AspectRatio ratio={16 / 9} w={60}>
                        {category.imageUrl ? ( <MantineImage src={category.imageUrl} alt={displayName} radius="xs" fit="contain" /> )
                         : ( <Center bg="gray.1" h="100%" style={{ borderRadius: 'var(--mantine-radius-xs)' }}> <IconPhoto size={24} color="var(--mantine-color-gray-5)" /> </Center> )}
                    </AspectRatio>
                </Table.Td>
                <Table.Td>
                    <Text fw={500}>{displayName}</Text>
                    {displayName !== category.name_es && category.name_es && <Text size="xs" c="dimmed">ES: {category.name_es}</Text>}
                    {displayName !== category.name_en && category.name_en && <Text size="xs" c="dimmed">EN: {category.name_en}</Text>}
                </Table.Td>
                <Table.Td>{category.position}</Table.Td>
                <Table.Td> <Badge color={category.isActive ? 'green' : 'gray'} variant="light"> {category.isActive ? t('common.active') : t('common.inactive')} </Badge> </Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        {/* Clave de traducci√≥n: "adminCamarero.manageMenu.viewItemsTooltip": "Ver/Gestionar √çtems de esta Categor√≠a" */}
                        <Tooltip label={t('adminCamarero.manageMenu.viewItemsTooltip')} withArrow position="top">
                            <Box> {/* <--- Envolver ActionIcon en Box */}
                                <ActionIcon variant="subtle" color="cyan" onClick={() => onSelectCategoryForItems(category)} disabled={disableActions || isLoadingThisRowStatus || isLoadingThisRowDelete} >
                                    <IconListDetails size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                        
                        <Tooltip label={t('common.edit')} withArrow position="top">
                            <Box> {/* <--- Envolver ActionIcon en Box */}
                                <ActionIcon variant="subtle" color="blue" onClick={() => handleOpenEditModal(category)} disabled={disableActions || isLoadingThisRowStatus || isLoadingThisRowDelete} >
                                    <IconPencil size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>

                        <Tooltip label={category.isActive ? t('adminRewardsPage.tooltipDeactivate') : t('adminRewardsPage.tooltipActivate')} withArrow position="top" >
                            <Box> {/* <--- Envolver ActionIcon en Box */}
                                <ActionIcon variant="subtle" color={category.isActive ? 'orange' : 'teal'} onClick={() => handleToggleCategoryActive(category)} loading={isLoadingThisRowStatus} disabled={disableActions || isLoadingThisRowDelete || (isUpdatingStatusId !== null && isUpdatingStatusId !== category.id)} >
                                    {category.isActive ? <IconPlayerStop size={16} /> : <IconPlayerPlay size={16} />}
                                </ActionIcon>
                            </Box>
                        </Tooltip>

                        <Tooltip label={t('common.delete')} withArrow position="top">
                            <Box> {/* <--- Envolver ActionIcon en Box */}
                                <ActionIcon variant="subtle" color="red" onClick={() => handleDeleteCategoryClick(category)} loading={isLoadingThisRowDelete} disabled={disableActions || isLoadingThisRowStatus || (isDeletingId !== null && isDeletingId !== category.id)} >
                                    <IconTrash size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    return (
        <Stack gap="md">
            <Group justify="space-between">
                {/* Clave de traducci√≥n: "adminCamarero.manageMenu.category": "Categor√≠a" */}
                <Button leftSection={<IconPlus size={16} />} onClick={handleOpenAddModal} disabled={loadingCategories || isSubmittingForm || !!isDeletingId || !!isUpdatingStatusId} >
                    {t('common.add')} {t('adminCamarero.manageMenu.category')}
                </Button>
            </Group>
            {loadingCategories && <Group justify="center" mt="xl"><Loader /></Group>}
            {errorCategories && !loadingCategories && ( <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{errorCategories}</Alert> )}
            {!loadingCategories && !errorCategories && categories.length === 0 && ( <Text c="dimmed" ta="center" mt="md">{t('common.noItems')}</Text> )}
            {!loadingCategories && !errorCategories && categories.length > 0 && (
                <Table.ScrollContainer minWidth={600}>
                    <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                        <Table.Thead>
                            <Table.Tr>
                                <Table.Th style={{width: '80px'}}>{t('component.rewardForm.imageLabel')}</Table.Th>
                                <Table.Th>{t('common.name')}</Table.Th>
                                <Table.Th>{t('adminCamarero.manageMenu.categoryPositionLabel')}</Table.Th>
                                <Table.Th>{t('common.status')}</Table.Th>
                                <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                            </Table.Tr>
                        </Table.Thead>
                        <Table.Tbody>{rows}</Table.Tbody>
                    </Table>
                </Table.ScrollContainer>
            )}
            <MenuCategoryFormModal opened={modalOpened} onClose={handleCloseModal} onSubmit={handleSubmitCategoryForm} initialData={editingCategory} isSubmitting={isSubmittingForm} />
        </Stack>
    );
};

export default MenuCategoryManager;


// ====== [123] frontend/src/modules/camarero/components/admin/menu/MenuItemFormModal.tsx ======
// frontend/src/components/admin/camarero/menu/MenuItemFormModal.tsx
// Version 2.0.0 (Refactored to use ImageUploadCropper component)

import React, { useEffect } from 'react';
import {
    Modal, TextInput, Textarea, NumberInput, Switch, Button, Group, Stack, MultiSelect, 
    NativeScrollArea, Title, useMantineTheme, Box, Text as MantineText
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next';
import {
    IconDeviceFloppy, IconCurrencyEuro, IconSettings
} from '@tabler/icons-react';
import { useDisclosure } from '@mantine/hooks';
import { MenuItemData, MenuItemFormData } from '../../../types/menu.types';

// Importar el componente reutilizable
import ImageUploadCropper from '../../../../../shared/components/utils/ImageUploadCropper';
import ModifierGroupsManagementModal from './ModifierGroupsManagementModal';

// El schema de Zod no cambia
const createItemFormSchema = (t: Function) => z.object({
    name_es: z.string().min(1, { message: t('common.requiredField') }),
    name_en: z.string().nullable().optional(),
    description_es: z.string().nullable().optional(),
    description_en: z.string().nullable().optional(),
    price: z.number().min(0, { message: t('validation.minValueMin0') }),
    imageUrl: z.string().url({ message: t('validation.invalidUrl') }).nullable().optional(),
    allergens: z.array(z.string()).optional(),
    tags: z.array(z.string()).optional(),
    isAvailable: z.boolean(),
    position: z.number().min(0, { message: t('validation.minValueMin0') }),
    preparationTime: z.number().min(0, { message: t('common.errorMustBePositiveOrZero') }).nullable().optional(),
    calories: z.number().min(0, { message: t('common.errorMustBePositiveOrZero') }).nullable().optional(),
    kdsDestination: z.string().nullable().optional(),
    sku: z.string().nullable().optional(),
});

type ItemFormValues = z.infer<ReturnType<typeof createItemFormSchema>>;

interface MenuItemFormModalProps {
    opened: boolean;
    onClose: () => void;
    onSubmit: (values: MenuItemFormData) => Promise<void>;
    initialData?: MenuItemData | null;
    isSubmitting: boolean;
    categoryId: string;
}

const MenuItemFormModal: React.FC<MenuItemFormModalProps> = ({
    opened,
    onClose,
    onSubmit,
    initialData,
    isSubmitting,
}) => {
    const { t } = useTranslation();
    const theme = useMantineTheme();
    
    const form = useForm<ItemFormValues>({
        initialValues: {
            name_es: '', name_en: null, description_es: null, description_en: null,
            price: 0, imageUrl: null, allergens: [], tags: [],
            isAvailable: true, position: 0, preparationTime: null, calories: null,
            kdsDestination: null, sku: null,
        },
        validate: zodResolver(createItemFormSchema(t)),
    });

    const [groupsModalOpened, { open: openGroupsModal, close: closeGroupsModal }] = useDisclosure(false);

    useEffect(() => {
        if (opened) {
            if (initialData) {
                form.setValues({
                    name_es: initialData.name_es, name_en: initialData.name_en || null,
                    description_es: initialData.description_es || null, description_en: initialData.description_en || null,
                    price: initialData.price, imageUrl: initialData.imageUrl || null,
                    allergens: initialData.allergens || [], tags: initialData.tags || [],
                    isAvailable: initialData.isAvailable, position: initialData.position,
                    preparationTime: initialData.preparationTime || null, calories: initialData.calories || null,
                    kdsDestination: initialData.kdsDestination || null, sku: initialData.sku || null,
                });
            } else {
                form.reset();
            }
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, initialData]);

    const handleSubmitForm = async (values: ItemFormValues) => {
        const submitData: MenuItemFormData = {
            ...values,
            name_en: values.name_en?.trim() || null,
            description_es: values.description_es?.trim() || null,
            description_en: values.description_en?.trim() || null,
            imageUrl: values.imageUrl || null,
            allergens: values.allergens || [],
            tags: values.tags || [],
            preparationTime: values.preparationTime ?? null,
            calories: values.calories ?? null,
            kdsDestination: values.kdsDestination?.trim() || null,
            sku: values.sku?.trim() || null,
        };
        await onSubmit(submitData);
    };

    const handleModalClose = () => { if (!isSubmitting) onClose(); }
    
    const allergenOptions = ['GLUTEN', 'LACTOSE', 'NUTS', 'SOY', 'FISH', 'CRUSTACEANS', 'CELERY', 'MUSTARD', 'SESAME', 'SULPHITES', 'LUPIN', 'MOLLUSCS'].map(val => ({value: val, label: t(`adminCamarero.menuItem.allergen.${val}`, val)}));
    const tagOptions = ['VEGAN', 'VEGETARIAN', 'SPICY', 'NEW', 'POPULAR', 'HOUSE_SPECIAL'].map(val => ({value: val, label: t(`adminCamarero.menuItem.tag.${val}`, val)}));

    const allergenInputProps = form.getInputProps('allergens');
    const tagInputProps = form.getInputProps('tags');

    const menuItemIdForGroupsModal = initialData ? initialData.id : null;
    const menuItemDisplayNameForModal = initialData ? (initialData.name_es || initialData.name_en || t('adminCamarero.manageMenu.itemFallbackName')) : t('adminCamarero.manageMenu.itemNew');

    return (
        <>
            <Modal
                opened={opened} onClose={handleModalClose}
                title={initialData ? t('adminCamarero.manageMenu.editItemTitle') : t('adminCamarero.manageMenu.addItemTitle')}
                centered size="xl"
                overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
                trapFocus closeOnClickOutside={!isSubmitting} closeOnEscape={!isSubmitting}
                scrollAreaComponent={NativeScrollArea}
            >
                <form onSubmit={form.onSubmit(handleSubmitForm)}>
                    <Stack gap="md">
                        <Group grow>
                            <TextInput label={t('component.rewardForm.nameEsLabel')} placeholder={t('adminCamarero.manageMenu.itemNameEsPlaceholder')} required disabled={isSubmitting} {...form.getInputProps('name_es')} />
                            <TextInput label={t('component.rewardForm.nameEnLabel')} placeholder={t('adminCamarero.manageMenu.itemNameEnPlaceholder')} disabled={isSubmitting} {...form.getInputProps('name_en')} />
                        </Group>
                        <Textarea label={t('component.rewardForm.descriptionEsLabel')} placeholder={t('adminCamarero.manageMenu.itemDescEsPlaceholder')} rows={3} disabled={isSubmitting} {...form.getInputProps('description_es')} />
                        <Textarea label={t('component.rewardForm.descriptionEnLabel')} placeholder={t('adminCamarero.manageMenu.itemDescEnPlaceholder')} rows={3} disabled={isSubmitting} {...form.getInputProps('description_en')} />

                        <NumberInput
                            label={t('adminCamarero.manageMenu.itemPrice')}
                            placeholder="0.00" required min={0} step={0.01} decimalScale={2} fixedDecimalScale
                            leftSection={<IconCurrencyEuro size={16} />}
                            disabled={isSubmitting}
                            {...form.getInputProps('price')}
                        />
                        
                        <ImageUploadCropper
                            aspectRatio={1}
                            minDimension={150}
                            initialImageUrl={form.values.imageUrl || null}
                            onUploadSuccess={(url) => form.setFieldValue('imageUrl', url)}
                            onUploadError={(errorMsg) => form.setFieldError('imageUrl', errorMsg)}
                            onClearImage={() => form.setFieldValue('imageUrl', null)}
                            folderName="loyalpyme/menu-items"
                            disabled={isSubmitting}
                            imagePreviewAltText={t('adminCamarero.menuItemForm.altPreview')}
                            imageToCropAltText={t('adminCamarero.menuItemForm.altCropImage')}
                        />
                         {form.errors.imageUrl && (
                            <MantineText c="red" size="xs" mt={-10}>{form.errors.imageUrl}</MantineText>
                        )}

                        <MultiSelect
                            label={t('adminCamarero.manageMenu.itemAllergens')}
                            placeholder={t('adminCamarero.manageMenu.itemAllergensPlaceholder')}
                            data={allergenOptions}
                            searchable
                            // @ts-expect-error creatable is a valid prop for Mantine v7 MultiSelect
                            creatable
                            getCreateLabel={(query: string) => `+ ${t('common.add')} "${query}"`}
                            disabled={isSubmitting}
                            {...allergenInputProps}
                        />
                        <MultiSelect
                            label={t('adminCamarero.manageMenu.itemTags')}
                            placeholder={t('adminCamarero.manageMenu.itemTagsPlaceholder')}
                            data={tagOptions}
                            searchable
                            // @ts-expect-error creatable is a valid prop for Mantine v7 MultiSelect
                            creatable
                            getCreateLabel={(query: string) => `+ ${t('common.add')} "${query}"`}
                            disabled={isSubmitting}
                            {...tagInputProps}
                        />
                        <Group grow>
                            <NumberInput label={t('adminCamarero.manageMenu.itemPosition')} placeholder="0" min={0} step={1} allowDecimal={false} disabled={isSubmitting} {...form.getInputProps('position')} />
                            <NumberInput label={t('adminCamarero.manageMenu.itemPrepTime')} placeholder={t('common.optional')} min={0} step={1} allowDecimal={false} disabled={isSubmitting} {...form.getInputProps('preparationTime')} />
                        </Group>
                        <Group grow>
                            <NumberInput label={t('adminCamarero.manageMenu.itemCalories')} placeholder={t('common.optional')} min={0} step={1} allowDecimal={false} disabled={isSubmitting} {...form.getInputProps('calories')} />
                            <TextInput label={t('adminCamarero.manageMenu.itemSku')} placeholder={t('common.optional')} disabled={isSubmitting} {...form.getInputProps('sku')} />
                        </Group>
                        <TextInput label={t('adminCamarero.manageMenu.itemKds')} placeholder={t('adminCamarero.manageMenu.itemKdsPlaceholder')} description={t('adminCamarero.manageMenu.itemKdsDesc')} disabled={isSubmitting} {...form.getInputProps('kdsDestination')} />
                        <Switch label={t('adminCamarero.manageMenu.itemIsAvailable')} description={t('adminCamarero.manageMenu.itemIsAvailableDesc')} mt="sm" disabled={isSubmitting} {...form.getInputProps('isAvailable', { type: 'checkbox' })} />

                        {initialData && (
                            <Box mt="lg" pt="lg" style={{ borderTop: `1px solid ${theme.colors.gray[3]}` }}>
                                <Group justify="space-between" mb="sm">
                                    <Title order={5}>{t('adminCamarero.manageMenu.modifierGroupsTitle')}</Title>
                                    <Button
                                        variant="outline" size="xs"
                                        leftSection={<IconSettings size={16} />}
                                        onClick={openGroupsModal}
                                        disabled={isSubmitting}
                                    >
                                        {t('adminCamarero.manageMenu.manageGroupsButton')}
                                    </Button>
                                </Group>
                                <MantineText size="xs" c="dimmed" mb="md">
                                    {t('adminCamarero.manageMenu.modifierGroupsDescription')}
                                </MantineText>
                            </Box>
                        )}

                        <Group justify="flex-end" mt="lg">
                            <Button variant="default" onClick={handleModalClose} disabled={isSubmitting}>{t('common.cancel')}</Button>
                            <Button type="submit" loading={isSubmitting} leftSection={<IconDeviceFloppy size={18} />} >
                                {initialData ? t('common.save') : t('common.add')}
                            </Button>
                        </Group>
                    </Stack>
                </form>
            </Modal>

            {initialData && menuItemIdForGroupsModal && (
                <ModifierGroupsManagementModal
                    opened={groupsModalOpened}
                    onClose={closeGroupsModal}
                    menuItemId={menuItemIdForGroupsModal}
                    menuItemName={menuItemDisplayNameForModal}
                />
            )}
        </>
    );
};

export default MenuItemFormModal;


// ====== [124] frontend/src/modules/camarero/components/admin/menu/MenuItemManager.tsx ======
// frontend/src/components/admin/camarero/menu/MenuItemManager.tsx
// Version 1.0.1 (Remove unused categoryName prop)

import React, { useState } from 'react';
import {
    Box, Button, Text, Stack, Group, Loader, Alert,
    Table, ActionIcon, Badge, Tooltip,
    Image as MantineImage, AspectRatio, Center,
} from '@mantine/core';
import {
    IconPlus, IconAlertCircle, IconPencil, IconTrash, IconPhoto,
    IconPlayerPlay, IconPlayerStop, IconFileDescription
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useModals } from '@mantine/modals';
import { notifications } from '@mantine/notifications'; // A√±adido para handleManageModifiers

import { useAdminMenuItems } from '../../../hooks/useAdminMenuItems';
import { MenuItemData, MenuItemFormData } from '../../../types/menu.types';
import MenuItemFormModal from './MenuItemFormModal';

interface MenuItemManagerProps {
    categoryId: string;
    // categoryName: string; // <-- PROP ELIMINADA
}

// --- CORRECCI√ìN: Quitar categoryName de la desestructuraci√≥n ---
const MenuItemManager: React.FC<MenuItemManagerProps> = ({ categoryId /*, categoryName*/ }) => {
    const { t, i18n } = useTranslation();
    const modals = useModals();
    const currentLanguage = i18n.language;

    const {
        items,
        loading: loadingItems,
        error: errorItems,
        addItem,
        updateItem,
        deleteItem,
    } = useAdminMenuItems(categoryId);

    const [itemModalOpened, setItemModalOpened] = useState(false);
    const [editingItem, setEditingItem] = useState<MenuItemData | null>(null);
    const [isSubmittingItemForm, setIsSubmittingItemForm] = useState(false);
    const [isUpdatingItemStatusId, setIsUpdatingItemStatusId] = useState<string | null>(null);
    const [isDeletingItemId, setIsDeletingItemId] = useState<string | null>(null);

    const handleOpenAddItemModal = () => {
        setEditingItem(null);
        setItemModalOpened(true);
    };

    const handleOpenEditItemModal = (item: MenuItemData) => {
        setEditingItem(item);
        setItemModalOpened(true);
    };

    const handleCloseItemModal = () => {
        setItemModalOpened(false);
        setEditingItem(null);
    };

    const handleSubmitItemForm = async (formData: MenuItemFormData) => {
        setIsSubmittingItemForm(true);
        let success = false;
        if (editingItem) {
            const result = await updateItem(editingItem.id, formData);
            if (result) success = true;
        } else {
            const result = await addItem(formData);
            if (result) success = true;
        }
        if (success) {
            handleCloseItemModal();
        }
        setIsSubmittingItemForm(false);
    };

    const handleToggleItemAvailable = async (item: MenuItemData) => {
        setIsUpdatingItemStatusId(item.id);
        const newStatus = !item.isAvailable;
        try {
            // Asegurarse de que solo se env√≠a el campo que se quiere actualizar
            await updateItem(item.id, { isAvailable: newStatus });
        } catch (error) {
            console.error(`Error toggling availability for item ${item.id}:`, error);
            // La notificaci√≥n de error ya la maneja el hook si ocurre
        } finally {
            setIsUpdatingItemStatusId(null);
        }
    };

    const handleDeleteItemClick = (item: MenuItemData) => {
        const itemName = (currentLanguage === 'es' && item.name_es) ? item.name_es : (item.name_en || item.name_es || t('adminCamarero.manageMenu.itemFallbackName'));
        modals.openConfirmModal({
            title: t('adminCommon.confirmDeleteTitle'),
            centered: true,
            children: ( <Text size="sm"> {t('adminCommon.confirmDeleteMessage')}{' '} {t('adminCamarero.manageMenu.itemLabel')}: <strong>"{itemName}"</strong>? </Text> ),
            labels: { confirm: t('common.delete'), cancel: t('common.cancel') },
            confirmProps: { color: 'red' },
            onConfirm: async () => {
                setIsDeletingItemId(item.id);
                await deleteItem(item.id); // El hook maneja la notificaci√≥n
                setIsDeletingItemId(null);
            },
        });
    };
    
    const handleManageModifiers = (item: MenuItemData) => {
        const itemName = (currentLanguage === 'es' && item.name_es) ? item.name_es : (item.name_en || item.name_es || t('adminCamarero.manageMenu.itemFallbackName'));
        // Implementaci√≥n real para abrir el modal de modificadores
        // Esto es solo un placeholder:
        notifications.show({
             title: t('common.upcomingFeatureTitle'),
             message: `${t('adminCamarero.manageMenu.manageModifiersTooltip')} para: ${itemName} (ID: ${item.id})`,
             color: 'blue'
        });
        console.log("Abrir modal de modificadores para el √≠tem:", item.id, itemName);
    };


    const rows = items.map((item) => {
        const displayName = (currentLanguage === 'es' && item.name_es) ? item.name_es : (item.name_en || item.name_es || t('common.nameNotAvailable'));
        const isLoadingThisRowStatus = isUpdatingItemStatusId === item.id;
        const isLoadingThisRowDelete = isDeletingItemId === item.id;
        const disableActions = isSubmittingItemForm || !!isDeletingItemId || !!isUpdatingItemStatusId;
        const itemAvailabilityText = item.isAvailable ? t('adminCamarero.manageMenu.itemAvailable') : t('adminCamarero.manageMenu.itemNotAvailable');
        const tooltipToggleAvailable = item.isAvailable ? t('adminCamarero.manageMenu.markNotAvailable') : t('adminCamarero.manageMenu.markAvailable');

        return (
            <Table.Tr key={item.id}>
                <Table.Td>
                    <AspectRatio ratio={1 / 1} w={50}>
                        {item.imageUrl ? ( <MantineImage src={item.imageUrl} alt={displayName} radius="xs" fit="cover" fallbackSrc="/placeholder-item.png" /> )
                         : ( <Center bg="gray.1" h="100%" style={{ borderRadius: 'var(--mantine-radius-xs)' }}> <IconPhoto size={20} color="var(--mantine-color-gray-5)" /> </Center> )}
                    </AspectRatio>
                </Table.Td>
                <Table.Td>
                    <Text fw={500}>{displayName}</Text>
                    {displayName !== item.name_es && item.name_es && <Text size="xs" c="dimmed">ES: {item.name_es}</Text>}
                    {displayName !== item.name_en && item.name_en && <Text size="xs" c="dimmed">EN: {item.name_en}</Text>}
                </Table.Td>
                <Table.Td ta="right">{Number(item.price).toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}</Table.Td>
                <Table.Td>{item.position}</Table.Td>
                <Table.Td>
                    <Badge color={item.isAvailable ? 'green' : 'gray'} variant="light">
                        {itemAvailabilityText}
                    </Badge>
                </Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        <Tooltip label={t('adminCamarero.manageMenu.manageModifiersTooltip')} withArrow position="top">
                            <Box>
                                <ActionIcon variant="subtle" color="violet" onClick={() => handleManageModifiers(item)} disabled={disableActions || isLoadingThisRowStatus || isLoadingThisRowDelete}>
                                    <IconFileDescription size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                        <Tooltip label={t('common.edit')} withArrow position="top">
                            <Box>
                                <ActionIcon variant="subtle" color="blue" onClick={() => handleOpenEditItemModal(item)} disabled={disableActions || isLoadingThisRowStatus || isLoadingThisRowDelete} >
                                    <IconPencil size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                        <Tooltip label={tooltipToggleAvailable} withArrow position="top" >
                           <Box>
                                <ActionIcon
                                    variant="subtle"
                                    color={item.isAvailable ? "orange" : "teal"}
                                    onClick={() => handleToggleItemAvailable(item)}
                                    loading={isLoadingThisRowStatus}
                                    disabled={disableActions || isLoadingThisRowDelete || (isUpdatingItemStatusId !== null && isUpdatingItemStatusId !== item.id)}
                                >
                                    {item.isAvailable ? <IconPlayerStop size={16} /> : <IconPlayerPlay size={16} />}
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                        <Tooltip label={t('common.delete')} withArrow position="top">
                            <Box>
                                <ActionIcon
                                    variant="subtle"
                                    color="red"
                                    onClick={() => handleDeleteItemClick(item)}
                                    loading={isLoadingThisRowDelete}
                                    disabled={disableActions || isLoadingThisRowStatus || (isDeletingItemId !== null && isDeletingItemId !== item.id)}
                                >
                                    <IconTrash size={16} />
                                </ActionIcon>
                            </Box>
                        </Tooltip>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    return (
        <Stack gap="md" mt="lg">
            <Group justify="space-between">
                <Button
                    leftSection={<IconPlus size={16} />}
                    onClick={handleOpenAddItemModal}
                    disabled={loadingItems || isSubmittingItemForm || !!isDeletingItemId || !!isUpdatingItemStatusId}
                >
                    {t('common.add')} {t('adminCamarero.manageMenu.itemLabel')}
                </Button>
            </Group>

            {loadingItems && <Group justify="center" mt="xl"><Loader /></Group>}
            {errorItems && !loadingItems && (
                <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{errorItems}</Alert>
            )}

            {!loadingItems && !errorItems && items.length === 0 && (
                <Text c="dimmed" ta="center" mt="md">
                    {t('adminCamarero.manageMenu.noItemsInCategory')}
                </Text>
            )}

            {!loadingItems && !errorItems && items.length > 0 && (
                <Table.ScrollContainer minWidth={700}>
                    <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                        <Table.Thead>
                            <Table.Tr>
                                <Table.Th style={{width: '70px'}}>{t('adminCamarero.manageMenu.itemImageLabel')}</Table.Th>
                                <Table.Th>{t('common.name')}</Table.Th>
                                <Table.Th ta="right">{t('adminCamarero.manageMenu.itemPrice')}</Table.Th>
                                <Table.Th>{t('adminCamarero.manageMenu.itemPosition')}</Table.Th>
                                <Table.Th>{t('adminCamarero.manageMenu.itemAvailability')}</Table.Th>
                                <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                            </Table.Tr>
                        </Table.Thead>
                        <Table.Tbody>{rows}</Table.Tbody>
                    </Table>
                </Table.ScrollContainer>
            )}

            {categoryId && ( // categoryId existe porque es una prop requerida
                 <MenuItemFormModal
                    opened={itemModalOpened}
                    onClose={handleCloseItemModal}
                    onSubmit={handleSubmitItemForm}
                    initialData={editingItem}
                    isSubmitting={isSubmittingItemForm}
                    categoryId={categoryId}
                />
            )}
        </Stack>
    );
};

export default MenuItemManager;


// ====== [125] frontend/src/modules/camarero/components/admin/menu/ModifierGroupsManagementModal.tsx ======
// frontend/src/components/admin/camarero/menu/ModifierGroupsManagementModal.tsx
import React, { useState, useEffect } from 'react';
import {
    Modal, Button, Stack, Group, Title, Text, Loader, Alert,
    Table, ActionIcon, Badge, Tooltip, TextInput, Select, NumberInput, Switch,
    Paper, Divider, NativeScrollArea
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import { z } from 'zod';
import {
    IconPlus, IconAlertCircle, IconPencil, IconTrash, IconDeviceFloppy, IconSettings
} from '@tabler/icons-react';
import { useAdminModifierGroups } from '../../../hooks/useAdminModifierGroups';
import { ModifierGroupData, ModifierGroupFormData, ModifierUiType } from '../../../types/menu.types';
import ModifierOptionsManagementModal from './ModifierOptionsManagementModal';
import { useTranslation } from 'react-i18next'; // Asegurarse de importar

const createModifierGroupSchema = (t: Function) => z.object({
    name_es: z.string().min(1, { message: t('adminCamarero.modifierGroupForm.validation.nameEsRequired') }),
    name_en: z.string().nullable().optional(),
    uiType: z.nativeEnum(ModifierUiType, { errorMap: () => ({ message: t('adminCamarero.modifierGroupForm.validation.uiTypeInvalid') }) }),
    minSelections: z.number().min(0, { message: t('adminCamarero.modifierGroupForm.validation.minSelectionsInvalid') }).default(0),
    maxSelections: z.number().min(1, { message: t('adminCamarero.modifierGroupForm.validation.maxSelectionsInvalid') }).default(1),
    position: z.number().min(0).default(0),
    isRequired: z.boolean().default(false),
}).refine(data => data.minSelections <= data.maxSelections, {
    message: t('adminCamarero.modifierGroupForm.validation.minMaxMismatch'),
    path: ["maxSelections"],
});

type ModifierGroupFormValues = z.infer<ReturnType<typeof createModifierGroupSchema>>;

interface ModifierGroupsManagementModalProps {
    opened: boolean;
    onClose: () => void;
    menuItemId: string | null;
    menuItemName: string;
}

const ModifierGroupsManagementModal: React.FC<ModifierGroupsManagementModalProps> = ({
    opened,
    onClose,
    menuItemId,
    menuItemName,
}) => {
    const { t, i18n } = useTranslation(); // A√±adir i18n para currentLanguage si es necesario
    const currentLanguage = i18n.language;

    const {
        modifierGroups,
        loading: loadingGroups,
        error: errorGroups,
        addModifierGroup,
        updateModifierGroup,
        deleteModifierGroup,
        fetchModifierGroups,
    } = useAdminModifierGroups(menuItemId);

    const [showForm, setShowForm] = useState(false);
    const [editingGroup, setEditingGroup] = useState<ModifierGroupData | null>(null);
    const [isSubmittingForm, setIsSubmittingForm] = useState(false);
    const [isDeletingGroupId, setIsDeletingGroupId] = useState<string | null>(null);

    const [optionsModalOpened, { open: openOptionsModal, close: closeOptionsModal }] = useDisclosure(false);
    const [selectedGroupForOptions, setSelectedGroupForOptions] = useState<ModifierGroupData | null>(null);

    const form = useForm<ModifierGroupFormValues>({
        initialValues: {
            name_es: '', name_en: null, uiType: ModifierUiType.RADIO,
            minSelections: 0, maxSelections: 1, position: 0, isRequired: false,
        },
        validate: zodResolver(createModifierGroupSchema(t)),
    });

    useEffect(() => {
        if (opened && menuItemId) {
            fetchModifierGroups();
        }
        if (!opened) {
            setShowForm(false);
            setEditingGroup(null);
            form.reset();
            closeOptionsModal();
            setSelectedGroupForOptions(null);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, menuItemId, closeOptionsModal]);

    const handleOpenAddForm = () => {
        setEditingGroup(null);
        form.reset();
        form.setFieldValue('position', modifierGroups.length > 0 ? Math.max(...modifierGroups.map(g => g.position)) + 1 : 0);
        setShowForm(true);
    };

    const handleOpenEditForm = (group: ModifierGroupData) => {
        setEditingGroup(group);
        form.setValues({
            name_es: group.name_es,
            name_en: group.name_en || null,
            uiType: group.uiType,
            minSelections: group.minSelections,
            maxSelections: group.maxSelections,
            position: group.position,
            isRequired: group.isRequired,
        });
        setShowForm(true);
    };

    const handleFormSubmit = async (values: ModifierGroupFormValues) => {
        if (!menuItemId) return;
        setIsSubmittingForm(true);
        const formData: ModifierGroupFormData = {
            name_es: values.name_es,
            name_en: values.name_en || null,
            uiType: values.uiType,
            minSelections: values.minSelections,
            maxSelections: values.maxSelections,
            position: values.position,
            isRequired: values.isRequired,
        };

        let success = false;
        if (editingGroup) {
            const result = await updateModifierGroup(editingGroup.id, formData);
            if (result) success = true;
        } else {
            const result = await addModifierGroup(formData);
            if (result) success = true;
        }

        if (success) {
            setShowForm(false);
            setEditingGroup(null);
            form.reset();
        }
        setIsSubmittingForm(false);
    };

    const handleDeleteGroup = async (groupId: string) => {
        setIsDeletingGroupId(groupId);
        await deleteModifierGroup(groupId); // El hook se encarga de la notificaci√≥n
        setIsDeletingGroupId(null);
    };

    const handleManageOptions = (group: ModifierGroupData) => {
        setSelectedGroupForOptions(group);
        openOptionsModal();
    };

    const groupRows = modifierGroups.map((group) => {
        const groupDisplayName = (currentLanguage === 'es' && group.name_es) ? group.name_es : (group.name_en || group.name_es || t('common.nameNotAvailable'));
        return (
            <Table.Tr key={group.id}>
                <Table.Td>
                    <Text fw={500}>{groupDisplayName}</Text>
                    {groupDisplayName !== group.name_es && group.name_es && <Text size="xs" c="dimmed">ES: {group.name_es}</Text>}
                    {groupDisplayName !== group.name_en && group.name_en && <Text size="xs" c="dimmed">EN: {group.name_en}</Text>}
                </Table.Td>
                <Table.Td><Badge color="cyan" variant="light">{group.uiType}</Badge></Table.Td>
                <Table.Td>{group.minSelections} - {group.maxSelections}</Table.Td>
                <Table.Td>{group.isRequired ? t('common.yes') : t('common.no')}</Table.Td>
                <Table.Td>{group.position}</Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        <Tooltip label={t('adminCamarero.modifierGroupsModal.tooltipManageOptions')} withArrow>
                            <ActionIcon variant="subtle" color="green" onClick={() => handleManageOptions(group)} disabled={!!isDeletingGroupId}>
                                <IconSettings size={16} />
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={t('adminCamarero.modifierGroupsModal.tooltipEditGroup')} withArrow>
                            <ActionIcon variant="subtle" color="blue" onClick={() => handleOpenEditForm(group)} disabled={!!isDeletingGroupId}>
                                <IconPencil size={16} />
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={t('adminCamarero.modifierGroupsModal.tooltipDeleteGroup')} withArrow>
                            <ActionIcon variant="subtle" color="red" onClick={() => handleDeleteGroup(group.id)} loading={isDeletingGroupId === group.id} disabled={!!isDeletingGroupId && isDeletingGroupId !== group.id}>
                                <IconTrash size={16} />
                            </ActionIcon>
                        </Tooltip>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    const uiTypeOptions = Object.values(ModifierUiType).map(type => ({
        value: type,
        label: t(`adminCamarero.modifierGroupForm.uiType.${type}`, type) // Claves como 'adminCamarero.modifierGroupForm.uiType.RADIO'
    }));


    return (
        <>
            <Modal
                opened={opened && !!menuItemId}
                onClose={onClose}
                title={t('adminCamarero.modifierGroupsModal.title', { itemName: menuItemName })}
                size="xl"
                centered
                scrollAreaComponent={NativeScrollArea}
                overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
            >
                <Stack gap="lg">
                    {!showForm ? (
                        <>
                            <Group justify="space-between">
                                <Title order={5}>{t('adminCamarero.modifierGroupsModal.existingGroupsTitle')}</Title>
                                <Button leftSection={<IconPlus size={16} />} onClick={handleOpenAddForm} disabled={loadingGroups}>
                                    {t('adminCamarero.modifierGroupsModal.createNewGroupButton')}
                                </Button>
                            </Group>

                            {loadingGroups && <Group justify="center" mt="md"><Loader /></Group>}
                            {errorGroups && !loadingGroups && <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{errorGroups}</Alert>}
                            {!loadingGroups && !errorGroups && modifierGroups.length === 0 && <Text c="dimmed" ta="center" mt="md">{t('adminCamarero.modifierGroupsModal.noGroupsForItem')}</Text>}
                            {!loadingGroups && !errorGroups && modifierGroups.length > 0 && (
                                <Table.ScrollContainer minWidth={600}>
                                    <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                                        <Table.Thead>
                                            <Table.Tr>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderName')}</Table.Th>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderUiType')}</Table.Th>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderSelections')}</Table.Th>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderRequired')}</Table.Th>
                                                <Table.Th>{t('adminCamarero.modifierGroupsModal.tableHeaderPosition')}</Table.Th>
                                                <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                                            </Table.Tr>
                                        </Table.Thead>
                                        <Table.Tbody>{groupRows}</Table.Tbody>
                                    </Table>
                                </Table.ScrollContainer>
                            )}
                        </>
                    ) : (
                        <Paper withBorder p="md" radius="md">
                            <Title order={5} mb="md">{editingGroup ? t('adminCamarero.modifierGroupsModal.formEditTitle', { groupName: (currentLanguage === 'es' && editingGroup.name_es) ? editingGroup.name_es : (editingGroup.name_en || editingGroup.name_es || '') }) : t('adminCamarero.modifierGroupsModal.formCreateTitle')}</Title>
                            <form onSubmit={form.onSubmit(handleFormSubmit)}>
                                <Stack gap="sm">
                                    <TextInput label={t('adminCamarero.modifierGroupForm.nameEsLabel')} required {...form.getInputProps('name_es')} disabled={isSubmittingForm} />
                                    <TextInput label={t('adminCamarero.modifierGroupForm.nameEnLabel')} {...form.getInputProps('name_en')} disabled={isSubmittingForm} />
                                    <Select
                                        label={t('adminCamarero.modifierGroupForm.uiTypeLabel')}
                                        data={uiTypeOptions}
                                        required
                                        {...form.getInputProps('uiType')}
                                        disabled={isSubmittingForm}
                                    />
                                    <Group grow>
                                        <NumberInput label={t('adminCamarero.modifierGroupForm.minSelectionsLabel')} min={0} {...form.getInputProps('minSelections')} disabled={isSubmittingForm} />
                                        <NumberInput label={t('adminCamarero.modifierGroupForm.maxSelectionsLabel')} min={1} {...form.getInputProps('maxSelections')} disabled={isSubmittingForm} />
                                    </Group>
                                    <NumberInput label={t('adminCamarero.modifierGroupForm.positionLabel')} min={0} {...form.getInputProps('position')} disabled={isSubmittingForm} />
                                    <Switch label={t('adminCamarero.modifierGroupForm.isRequiredLabel')} {...form.getInputProps('isRequired', { type: 'checkbox' })} disabled={isSubmittingForm} />

                                    <Group justify="flex-end" mt="md">
                                        <Button variant="default" onClick={() => { setShowForm(false); setEditingGroup(null); form.reset(); }} disabled={isSubmittingForm}>
                                            {t('common.cancel')}
                                        </Button>
                                        <Button type="submit" loading={isSubmittingForm} leftSection={<IconDeviceFloppy size={16} />}>
                                            {editingGroup ? t('common.saveChanges') : t('adminCamarero.modifierGroupsModal.formCreateButton')}
                                        </Button>
                                    </Group>
                                </Stack>
                            </form>
                        </Paper>
                    )}
                    <Divider mt="lg" />
                    <Group justify="flex-end" mt="md">
                        <Button variant="outline" onClick={onClose}>{t('adminCamarero.modifierGroupsModal.closeButton')}</Button>
                    </Group>
                </Stack>
            </Modal>

            {selectedGroupForOptions && (
                <ModifierOptionsManagementModal
                    opened={optionsModalOpened}
                    onClose={() => {
                        closeOptionsModal();
                        setSelectedGroupForOptions(null);
                        fetchModifierGroups();
                    }}
                    modifierGroupId={selectedGroupForOptions.id}
                    modifierGroupName={(currentLanguage === 'es' && selectedGroupForOptions.name_es) ? selectedGroupForOptions.name_es : (selectedGroupForOptions.name_en || selectedGroupForOptions.name_es || t('common.nameNotAvailable'))}
                />
            )}
        </>
    );
};

export default ModifierGroupsManagementModal;


// ====== [126] frontend/src/modules/camarero/components/admin/menu/ModifierOptionsManagementModal.tsx ======
// frontend/src/components/admin/camarero/menu/ModifierOptionsManagementModal.tsx
import React, { useState, useEffect } from 'react';
import {
    Modal, Button, Stack, Group, Title, Text, Loader, Alert,
    Table, ActionIcon, Badge, Tooltip, TextInput, NumberInput, Switch,
    Paper, Divider, NativeScrollArea
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import {
    IconPlus, IconAlertCircle, IconPencil, IconTrash, IconDeviceFloppy, IconCurrencyEuro,
    IconPlayerPlay, IconPlayerStop
} from '@tabler/icons-react';
import { useAdminModifierOptions } from '../../../hooks/useAdminModifierOptions';
import { ModifierOptionData, ModifierOptionFormData } from '../../../types/menu.types';
import { useTranslation } from 'react-i18next'; // Asegurarse de importar

// Schema de validaci√≥n Zod usando la funci√≥n t
const createModifierOptionSchema = (t: Function) => z.object({
    name_es: z.string().min(1, { message: t('adminCamarero.modifierOptionForm.validation.nameEsRequired') }),
    name_en: z.string().nullable().optional(),
    priceAdjustment: z.coerce.number().default(0),
    position: z.coerce.number().min(0).default(0),
    isDefault: z.boolean().default(false),
    isAvailable: z.boolean().default(true),
});

type ModifierOptionFormValues = z.infer<ReturnType<typeof createModifierOptionSchema>>;

interface ModifierOptionsManagementModalProps {
    opened: boolean;
    onClose: () => void;
    modifierGroupId: string | null;
    modifierGroupName: string;
}

const ModifierOptionsManagementModal: React.FC<ModifierOptionsManagementModalProps> = ({
    opened,
    onClose,
    modifierGroupId,
    modifierGroupName,
}) => {
    const { t, i18n } = useTranslation(); // A√±adir i18n para currentLanguage si es necesario
    const currentLanguage = i18n.language;

    const {
        modifierOptions,
        loading: loadingOptions,
        error: errorOptions,
        addModifierOption,
        updateModifierOption,
        deleteModifierOption,
        fetchModifierOptions,
    } = useAdminModifierOptions(modifierGroupId);

    const [showOptionForm, setShowOptionForm] = useState(false);
    const [editingOption, setEditingOption] = useState<ModifierOptionData | null>(null);
    const [isSubmittingOptionForm, setIsSubmittingOptionForm] = useState(false);
    const [isDeletingOptionId, setIsDeletingOptionId] = useState<string | null>(null);
    const [isTogglingStatusOptionId, setIsTogglingStatusOptionId] = useState<string | null>(null);

    const form = useForm<ModifierOptionFormValues>({
        initialValues: {
            name_es: '', name_en: null, priceAdjustment: 0,
            position: 0, isDefault: false, isAvailable: true,
        },
        validate: zodResolver(createModifierOptionSchema(t)), // Pasar t al resolver
    });

    useEffect(() => {
        if (opened && modifierGroupId) {
            fetchModifierOptions();
        }
        if (!opened) {
            setShowOptionForm(false);
            setEditingOption(null);
            form.reset();
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, modifierGroupId]);

    const handleOpenAddOptionForm = () => {
        setEditingOption(null);
        form.reset();
        form.setFieldValue('position', modifierOptions.length > 0 ? Math.max(...modifierOptions.map(o => o.position)) + 1 : 0);
        setShowOptionForm(true);
    };

    const handleOpenEditOptionForm = (option: ModifierOptionData) => {
        setEditingOption(option);
        form.setValues({
            name_es: option.name_es,
            name_en: option.name_en || null,
            priceAdjustment: Number(option.priceAdjustment),
            position: Number(option.position),
            isDefault: option.isDefault,
            isAvailable: option.isAvailable,
        });
        setShowOptionForm(true);
    };

    const handleOptionFormSubmit = async (values: ModifierOptionFormValues) => {
        if (!modifierGroupId) return;
        setIsSubmittingOptionForm(true);
        const formData: ModifierOptionFormData = {
            name_es: values.name_es,
            name_en: values.name_en || null,
            priceAdjustment: values.priceAdjustment,
            position: values.position,
            isDefault: values.isDefault,
            isAvailable: values.isAvailable,
        };
        let success = false;
        if (editingOption) {
            const result = await updateModifierOption(editingOption.id, formData);
            if (result) success = true;
        } else {
            const result = await addModifierOption(formData);
            if (result) success = true;
        }
        if (success) {
            setShowOptionForm(false);
            setEditingOption(null);
            form.reset();
        }
        setIsSubmittingOptionForm(false);
    };

    const handleDeleteOption = async (optionId: string) => {
        setIsDeletingOptionId(optionId);
        await deleteModifierOption(optionId); // El hook maneja la notificaci√≥n
        setIsDeletingOptionId(null);
    };

    const handleToggleOptionAvailable = async (option: ModifierOptionData) => {
        setIsTogglingStatusOptionId(option.id);
        const newStatus = !option.isAvailable;
        try {
            await updateModifierOption(option.id, { isAvailable: newStatus });
        } catch (error) {
            console.error(`Error toggling availability for option ${option.id}:`, error);
        } finally {
            setIsTogglingStatusOptionId(null);
        }
    };


    const optionRows = modifierOptions.map((option) => {
        const optionDisplayName = (currentLanguage === 'es' && option.name_es) ? option.name_es : (option.name_en || option.name_es || t('common.nameNotAvailable'));
        const isLoadingThisStatus = isTogglingStatusOptionId === option.id;
        const isLoadingThisDelete = isDeletingOptionId === option.id;
        const disableActionsGeneral = isSubmittingOptionForm || !!isDeletingOptionId || !!isTogglingStatusOptionId;
        const optionAvailabilityText = option.isAvailable ? t('adminCamarero.modifierOption.statusAvailable') : t('adminCamarero.modifierOption.statusNotAvailable');
        const tooltipToggleAvailable = option.isAvailable ? t('adminCamarero.modifierOption.tooltipMarkNotAvailable') : t('adminCamarero.modifierOption.tooltipMarkAvailable');

        return (
            <Table.Tr key={option.id}>
                <Table.Td>
                    <Text fw={500}>{optionDisplayName}</Text>
                    {optionDisplayName !== option.name_es && option.name_es && <Text size="xs" c="dimmed">ES: {option.name_es}</Text>}
                    {optionDisplayName !== option.name_en && option.name_en && <Text size="xs" c="dimmed">EN: {option.name_en}</Text>}
                </Table.Td>
                <Table.Td ta="right">
                    {option.priceAdjustment.toLocaleString(undefined, { style: 'currency', currency: 'EUR' })}
                </Table.Td>
                <Table.Td>{option.position}</Table.Td>
                <Table.Td>{option.isDefault ? t('common.yes') : t('common.no')}</Table.Td>
                <Table.Td>
                    <Badge color={option.isAvailable ? 'green' : 'gray'} variant="light">
                        {optionAvailabilityText}
                    </Badge>
                </Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        <Tooltip label={t('adminCamarero.modifierOption.tooltipEditOption')} withArrow>
                            <ActionIcon variant="subtle" color="blue"
                                onClick={() => handleOpenEditOptionForm(option)}
                                disabled={disableActionsGeneral || isLoadingThisStatus || isLoadingThisDelete}
                            >
                                <IconPencil size={16} />
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={tooltipToggleAvailable} withArrow>
                            <ActionIcon
                                variant="subtle"
                                color={option.isAvailable ? "orange" : "teal"}
                                onClick={() => handleToggleOptionAvailable(option)}
                                loading={isLoadingThisStatus}
                                disabled={disableActionsGeneral || isLoadingThisDelete || (isTogglingStatusOptionId !== null && isTogglingStatusOptionId !== option.id)}
                            >
                                {option.isAvailable ? <IconPlayerStop size={16} /> : <IconPlayerPlay size={16} />}
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={t('adminCamarero.modifierOption.tooltipDeleteOption')} withArrow>
                            <ActionIcon variant="subtle" color="red"
                                onClick={() => handleDeleteOption(option.id)}
                                loading={isLoadingThisDelete}
                                disabled={disableActionsGeneral || isLoadingThisStatus || (isDeletingOptionId !== null && isDeletingOptionId !== option.id)}
                            >
                                <IconTrash size={16} />
                            </ActionIcon>
                        </Tooltip>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    return (
        <Modal
            opened={opened && !!modifierGroupId}
            onClose={onClose}
            title={t('adminCamarero.modifierOptionsModal.title', { groupName: modifierGroupName })}
            size="lg"
            centered
            scrollAreaComponent={NativeScrollArea}
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            <Stack gap="lg">
                {!showOptionForm ? (
                    <>
                        <Group justify="space-between">
                            <Title order={5}>{t('adminCamarero.modifierOptionsModal.existingOptionsTitle')}</Title>
                            <Button leftSection={<IconPlus size={16} />} onClick={handleOpenAddOptionForm} disabled={loadingOptions}>
                                {t('adminCamarero.modifierOptionsModal.createNewOptionButton')}
                            </Button>
                        </Group>

                        {loadingOptions && <Group justify="center" mt="md"><Loader /></Group>}
                        {errorOptions && !loadingOptions && <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{errorOptions}</Alert>}
                        {!loadingOptions && !errorOptions && modifierOptions.length === 0 && <Text c="dimmed" ta="center" mt="md">{t('adminCamarero.modifierOptionsModal.noOptionsForGroup')}</Text>}
                        {!loadingOptions && !errorOptions && modifierOptions.length > 0 && (
                            <Table.ScrollContainer minWidth={500}>
                                <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                                    <Table.Thead>
                                        <Table.Tr>
                                            <Table.Th>{t('adminCamarero.modifierOptionsModal.tableHeaderName')}</Table.Th>
                                            <Table.Th ta="right">{t('adminCamarero.modifierOptionsModal.tableHeaderPriceAdjustment')}</Table.Th>
                                            <Table.Th>{t('adminCamarero.modifierOptionsModal.tableHeaderPosition')}</Table.Th>
                                            <Table.Th>{t('adminCamarero.modifierOptionsModal.tableHeaderDefault')}</Table.Th>
                                            <Table.Th>{t('adminCamarero.modifierOptionsModal.tableHeaderAvailable')}</Table.Th>
                                            <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                                        </Table.Tr>
                                    </Table.Thead>
                                    <Table.Tbody>{optionRows}</Table.Tbody>
                                </Table>
                            </Table.ScrollContainer>
                        )}
                    </>
                ) : (
                    <Paper withBorder p="md" radius="md">
                        <Title order={5} mb="md">{editingOption ? t('adminCamarero.modifierOptionsModal.formEditTitle', { optionName: (currentLanguage === 'es' && editingOption.name_es) ? editingOption.name_es : (editingOption.name_en || editingOption.name_es || '') }) : t('adminCamarero.modifierOptionsModal.formCreateTitle')}</Title>
                        <form onSubmit={form.onSubmit(handleOptionFormSubmit)}>
                            <Stack gap="sm">
                                <TextInput label={t('adminCamarero.modifierOptionForm.nameEsLabel')} required {...form.getInputProps('name_es')} disabled={isSubmittingOptionForm} />
                                <TextInput label={t('adminCamarero.modifierOptionForm.nameEnLabel')} {...form.getInputProps('name_en')} disabled={isSubmittingOptionForm} />
                                <NumberInput
                                    label={t('adminCamarero.modifierOptionForm.priceAdjustmentLabel')}
                                    description={t('adminCamarero.modifierOptionForm.priceAdjustmentDescription')}
                                    decimalScale={2}
                                    fixedDecimalScale
                                    step={0.10}
                                    leftSection={<IconCurrencyEuro size={16} />}
                                    {...form.getInputProps('priceAdjustment')}
                                    disabled={isSubmittingOptionForm}
                                />
                                <NumberInput
                                    label={t('adminCamarero.modifierOptionForm.positionLabel')}
                                    min={0}
                                    step={1}
                                    allowDecimal={false}
                                    {...form.getInputProps('position')}
                                    disabled={isSubmittingOptionForm}
                                />
                                <Switch label={t('adminCamarero.modifierOptionForm.isDefaultLabel')} {...form.getInputProps('isDefault', { type: 'checkbox' })} disabled={isSubmittingOptionForm} />
                                <Switch label={t('adminCamarero.modifierOptionForm.isAvailableLabel')} {...form.getInputProps('isAvailable', { type: 'checkbox' })} disabled={isSubmittingOptionForm} />

                                <Group justify="flex-end" mt="md">
                                    <Button variant="default" onClick={() => { setShowOptionForm(false); setEditingOption(null); form.reset(); }} disabled={isSubmittingOptionForm}>
                                        {t('common.cancel')}
                                    </Button>
                                    <Button type="submit" loading={isSubmittingOptionForm} leftSection={<IconDeviceFloppy size={16} />}>
                                        {editingOption ? t('common.saveChanges') : t('adminCamarero.modifierOptionsModal.formCreateButton')}
                                    </Button>
                                </Group>
                            </Stack>
                        </form>
                    </Paper>
                )}
                 <Divider mt="lg" />
                <Group justify="flex-end" mt="md">
                    <Button variant="outline" onClick={onClose}>{t('adminCamarero.modifierOptionsModal.closeButton')}</Button>
                </Group>
            </Stack>
        </Modal>
    );
};

export default ModifierOptionsManagementModal;


// ====== [127] frontend/src/modules/camarero/components/public/menu/CategoryAccordion.tsx ======
// frontend/src/components/public/menu/CategoryAccordion.tsx
// Version: 1.0.1 (Fix itemDetails access and use initialQuantity)

import React from 'react';
import { Accordion, Group, Image, Stack, Title, Text } from '@mantine/core';
import { IconChevronDown } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import {
    PublicMenuCategory,
    PublicMenuItem,
    ModifierUiType
} from '../../../types/menu.types';
import MenuItemCard, { MenuItemCardConfiguringState } from './MenuItemCard';

interface CategoryAccordionProps {
    categories: PublicMenuCategory[];
    activeAccordionItems: string[];
    onAccordionChange: (value: string[]) => void;
    
    // NUEVA PROP: ID del √≠tem que se est√° configurando actualmente
    configuringItemId: string | null; 
    configuringItemState: MenuItemCardConfiguringState | null;
    
    onStartConfigureItem: (item: PublicMenuItem) => void;
    onCancelConfiguration: () => void;
    onConfigQuantityChange: (newQuantity: number) => void;
    onConfigModifierSelectionChange: (groupId: string, newSelection: string | string[], groupUiType: ModifierUiType) => void;
    onConfigNotesChange: (newNotes: string) => void;
    onConfigAddToCart: () => void;
    onSimpleAddToCart: (item: PublicMenuItem, quantity: number) => void;
}

const CategoryAccordion: React.FC<CategoryAccordionProps> = ({
    categories,
    activeAccordionItems,
    onAccordionChange,
    configuringItemId, // <<< NUEVA PROP
    configuringItemState,
    onStartConfigureItem,
    onCancelConfiguration,
    onConfigQuantityChange,
    onConfigModifierSelectionChange,
    onConfigNotesChange,
    onConfigAddToCart,
    onSimpleAddToCart,
}) => {
    const { t, i18n } = useTranslation();

    if (!categories || categories.length === 0) {
        return <Text c="dimmed" ta="center">{t('publicMenu.noCategories', 'No hay categor√≠as de men√∫ disponibles.')}</Text>;
    }

    return (
        <Accordion
            variant="separated"
            chevron={<IconChevronDown />}
            multiple
            value={activeAccordionItems}
            onChange={onAccordionChange}
        >
            {categories.map((category: PublicMenuCategory) => (
                <Accordion.Item key={category.id} value={category.id}>
                    <Accordion.Control>
                        <Group wrap="nowrap">
                            {category.imageUrl && (
                                <Image src={category.imageUrl} alt={(i18n.language === 'es' && category.name_es) ? category.name_es : (category.name_en || category.name_es || '')} w={60} h={60} fit="cover" radius="sm" />
                            )}
                            <Stack gap={0}>
                                <Title order={4}>
                                    {i18n.language === 'es' && category.name_es ? category.name_es : category.name_en || category.name_es || t('publicMenu.unnamedCategory', 'Categor√≠a sin nombre')}
                                </Title>
                                {(category.description_es && i18n.language === 'es') && <Text size="sm" c="dimmed" lineClamp={1}>{category.description_es}</Text>}
                                {(category.description_en && i18n.language === 'en') && <Text size="sm" c="dimmed" lineClamp={1}>{category.description_en}</Text>}
                            </Stack>
                        </Group>
                    </Accordion.Control>
                    <Accordion.Panel>
                        {category.items.length > 0 ? (
                            <Stack gap="md" pt="md">
                                {category.items.map((item: PublicMenuItem) => {
                                    // CORRECCI√ìN: Usar configuringItemId para determinar si se est√° configurando este √≠tem
                                    const isConfiguringThisItem = configuringItemId === item.id;
                                    const itemConfigForCard = isConfiguringThisItem ? configuringItemState : null;
                                    
                                    // Usar la cantidad del estado de configuraci√≥n si este √≠tem se est√° configurando, sino 1
                                    const quantityForCard = isConfiguringThisItem && itemConfigForCard ? itemConfigForCard.quantity : 1;

                                    return (
                                        <MenuItemCard
                                            key={item.id}
                                            item={item}
                                            isConfiguringThisItem={isConfiguringThisItem}
                                            currentConfig={itemConfigForCard ? { // Asegurarse de pasar todos los campos de MenuItemCardConfiguringState
                                                quantity: quantityForCard,
                                                selectedOptionsByGroup: itemConfigForCard.selectedOptionsByGroup,
                                                currentUnitPrice: itemConfigForCard.currentUnitPrice,
                                                itemNotes: itemConfigForCard.itemNotes,
                                                areModifiersValid: itemConfigForCard.areModifiersValid,
                                            } : null}
                                            onStartConfigure={() => onStartConfigureItem(item)}
                                            onCancelConfiguration={onCancelConfiguration}
                                            // Asegurarse que los callbacks para actualizar la config se pasan correctamente
                                            onQuantityChange={onConfigQuantityChange}
                                            onModifierSelectionChange={onConfigModifierSelectionChange}
                                            onNotesChange={onConfigNotesChange}
                                            onAddToCart={isConfiguringThisItem ? onConfigAddToCart : () => {
                                                const quantityInput = document.getElementById(`quantity-${item.id}`) as HTMLInputElement;
                                                const quantity = quantityInput ? parseInt(quantityInput.value, 10) : 1;
                                                onSimpleAddToCart(item, quantity >= 1 ? quantity : 1);
                                            }}
                                        />
                                    );
                                })}
                            </Stack>
                        ) : (
                            <Text c="dimmed">{t('publicMenu.noItemsInCategory', 'No hay √≠tems en esta categor√≠a.')}</Text>
                        )}
                    </Accordion.Panel>
                </Accordion.Item>
            ))}
        </Accordion>
    );
};

export default CategoryAccordion;


// ====== [128] frontend/src/modules/camarero/components/public/menu/MenuItemCard.tsx ======
// frontend/src/components/public/menu/MenuItemCard.tsx
// Version: 1.0.4 (Correct i18n key path for allergens and tags)

import React, { useState, useEffect } from 'react';
import {
    Paper, Title, Text, Stack, Group, Badge, Box, Image,
    NumberInput, Button as MantineButton, TextInput as MantineTextInput
} from '@mantine/core';
import { IconShoppingCartPlus, IconNotes, IconListDetails } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import {
    PublicMenuItem,
    ModifierUiType,
    PublicMenuModifierGroup,
} from '../../../types/menu.types';
import ModifierGroupInteractiveRenderer from './ModifierGroupInteractiveRenderer';

export interface MenuItemCardConfiguringState {
    quantity: number;
    selectedOptionsByGroup: Record<string, string[] | string>;
    currentUnitPrice: number;
    itemNotes: string;
    areModifiersValid: boolean;
}

interface MenuItemCardProps {
    item: PublicMenuItem;
    isConfiguringThisItem: boolean;
    currentConfig: MenuItemCardConfiguringState | null;
    onStartConfigure: () => void;
    onCancelConfiguration: () => void;
    onQuantityChange: (newQuantity: number) => void;
    onModifierSelectionChange: (groupId: string, newSelection: string | string[], groupUiType: ModifierUiType) => void;
    onNotesChange: (newNotes: string) => void;
    onAddToCart: (quantityIfSimple?: number) => void;
}

const MenuItemCard: React.FC<MenuItemCardProps> = ({
    item,
    isConfiguringThisItem,
    currentConfig,
    onStartConfigure,
    onCancelConfiguration,
    onQuantityChange,
    onModifierSelectionChange,
    onNotesChange,
    onAddToCart,
}) => {
    const { t, i18n } = useTranslation();
    const [simpleQuantity, setSimpleQuantity] = useState<number>(1);

    useEffect(() => {
        if (!isConfiguringThisItem) {
            setSimpleQuantity(1);
        }
    }, [isConfiguringThisItem]);

    const displayPrice = isConfiguringThisItem && currentConfig ? currentConfig.currentUnitPrice : item.price;
    const displayQuantity = isConfiguringThisItem && currentConfig ? currentConfig.quantity : simpleQuantity;
    
    let mainButtonText: string;
    let mainButtonAction: () => void;
    let mainButtonDisabled = false;

    if (isConfiguringThisItem && currentConfig) {
        mainButtonAction = () => onAddToCart();
        mainButtonText = t('publicMenu.confirmAndAddToCart');
        mainButtonDisabled = !currentConfig.areModifiersValid;
    } else if (item.modifierGroups && item.modifierGroups.length > 0) {
        mainButtonAction = onStartConfigure;
        mainButtonText = t('publicMenu.customizeAndAdd');
    } else {
        mainButtonAction = () => onAddToCart(simpleQuantity);
        mainButtonText = t('publicMenu.addToCart');
    }

    const handleNumberInputChange = (value: number | string) => {
        const newQty = Number(value) < 1 ? 1 : Number(value);
        if (isConfiguringThisItem) {
            onQuantityChange(newQty);
        } else {
            setSimpleQuantity(newQty);
        }
    };

    return (
        <Paper p="md" radius="sm" withBorder>
            <Group wrap="nowrap" align="flex-start" gap="md">
                {item.imageUrl && (
                    <Image src={item.imageUrl} alt={(i18n.language === 'es' && item.name_es) ? item.name_es : (item.name_en || item.name_es || '')} w={100} h={100} fit="cover" radius="sm" />
                )}
                <Stack gap="xs" style={{ flexGrow: 1 }}>
                    <Title order={5}>
                        {i18n.language === 'es' && item.name_es ? item.name_es : item.name_en || item.name_es || t('publicMenu.unnamedItem')}
                    </Title>
                    <Text c="blue.7" fw={700} fz="lg">
                        {displayPrice.toLocaleString(i18n.language, { style: 'currency', currency: 'EUR' })}
                    </Text>
                    {(item.description_es && i18n.language === 'es') && <Text size="sm" c="dimmed" lineClamp={3}>{item.description_es}</Text>}
                    {(item.description_en && i18n.language === 'en') && <Text size="sm" c="dimmed" lineClamp={3}>{item.description_en}</Text>}

                    {!isConfiguringThisItem && item.modifierGroups && item.modifierGroups.length > 0 && (
                        <MantineButton 
                            variant="subtle" 
                            size="xs" 
                            onClick={onStartConfigure}
                            leftSection={<IconListDetails size={14}/>}
                            mt="xs"
                        >
                            {t('publicMenu.customizeButton')}
                        </MantineButton>
                    )}

                    {isConfiguringThisItem && currentConfig && item.modifierGroups && item.modifierGroups.length > 0 && (
                        <Box mt="sm" pl="xs">
                            <Title order={6} c="dimmed" tt="uppercase" fz="xs" mb="xs">{t('publicMenu.optionsTitle')}</Title>
                            {item.modifierGroups.map((group: PublicMenuModifierGroup) => (
                                <ModifierGroupInteractiveRenderer
                                    key={group.id}
                                    group={group}
                                    selectedOptionsForThisGroup={currentConfig.selectedOptionsByGroup[group.id] || (group.uiType === ModifierUiType.RADIO ? '' : [])}
                                    onSelectionChange={(newSelection) => onModifierSelectionChange(group.id, newSelection, group.uiType)}
                                />
                            ))}
                            <MantineTextInput
                                label={t('publicMenu.itemNotesLabel')}
                                placeholder={t('publicMenu.itemNotesPlaceholder')}
                                value={currentConfig.itemNotes}
                                onChange={(event) => onNotesChange(event.currentTarget.value)}
                                mt="sm"
                                rightSection={<IconNotes size={16} />}
                            />
                        </Box>
                    )}
                    
                    {/* ---------- CORRECCI√ìN AQU√ç ---------- */}
                    {(item.allergens.length > 0 || item.tags.length > 0) && (
                        <Group gap="xs" mt="sm">
                            {item.allergens.map(allergen => (
                                <Badge key={allergen} variant="outline" color="orange" size="xs">
                                    {t(`adminCamarero.menuItem.allergen.${allergen}`, allergen)} {/* <--- A√±adido adminCamarero. */}
                                </Badge>
                            ))}
                            {item.tags.map(tag => (
                                <Badge key={tag} variant="light" color="grape" size="xs">
                                    {t(`adminCamarero.menuItem.tag.${tag}`, tag)} {/* <--- A√±adido adminCamarero. */}
                                </Badge>
                            ))}
                        </Group>
                    )}
                    {/* ---------- FIN CORRECCI√ìN ---------- */}


                    <Group mt="md" justify="flex-end" align="flex-end">
                        <NumberInput
                            label={t('publicMenu.quantity')}
                            value={displayQuantity}
                            onChange={handleNumberInputChange}
                            min={1} max={20} step={1} size="xs"
                            style={{ width: '100px' }}
                            readOnly={!isConfiguringThisItem && !!(item.modifierGroups && item.modifierGroups.length > 0)}
                        />
                        <MantineButton 
                            onClick={mainButtonAction}
                            leftSection={<IconShoppingCartPlus size={16} />}
                            size="sm"
                            variant="filled"
                            disabled={mainButtonDisabled}
                        >
                            {mainButtonText}
                        </MantineButton>
                        {isConfiguringThisItem && (
                            <MantineButton variant="subtle" size="sm" onClick={onCancelConfiguration}>
                                {t('common.cancel')}
                            </MantineButton>
                        )}
                    </Group>
                </Stack>
            </Group>
        </Paper>
    );
};

export default MenuItemCard;


// ====== [129] frontend/src/modules/camarero/components/public/menu/ModifierGroupInteractiveRenderer.tsx ======
// frontend/src/components/public/menu/ModifierGroupInteractiveRenderer.tsx
// Version: 1.0.1 (Corrected imports)

import React from 'react';
import { 
    Stack, Text, Radio, Checkbox, 
    Box // <--- A√ëADIDO Box
} from '@mantine/core';
// Group, Badge, ThemeIcon, IconPoint eliminados de las importaciones ya que no se usan aqu√≠
import { useTranslation } from 'react-i18next';
import { PublicMenuModifierGroup, PublicMenuModifierOption, ModifierUiType } from '../../../types/menu.types';

interface ModifierGroupInteractiveRendererProps {
    group: PublicMenuModifierGroup;
    selectedOptionsForThisGroup: string | string[]; 
    onSelectionChange: (newSelection: string | string[]) => void;
}

const ModifierGroupInteractiveRenderer: React.FC<ModifierGroupInteractiveRendererProps> = ({
    group,
    selectedOptionsForThisGroup,
    onSelectionChange,
}) => {
    const { t, i18n } = useTranslation();

    const getModifierGroupSelectionText = (grp: PublicMenuModifierGroup): string => {
        const { isRequired, uiType, minSelections, maxSelections } = grp;
        if (isRequired) {
            if (uiType === ModifierUiType.RADIO) { return t('publicMenu.modifier.chooseOneRequired', 'Elige 1 (obligatorio)'); }
            if (minSelections === 1 && maxSelections === 1) { return t('publicMenu.modifier.chooseOneRequired', 'Elige 1 (obligatorio)');}
            if (minSelections === 1 && maxSelections > 1) { return t('publicMenu.modifier.chooseAtLeastOneUpToMax', { max: maxSelections, context: 'required' }); }
            if (minSelections > 0 && maxSelections >= minSelections) { return t('publicMenu.modifier.chooseMinUpToMax', { min: minSelections, max: maxSelections, context: 'required' }); }
        } else { 
            if (uiType === ModifierUiType.RADIO && maxSelections === 1) { return t('publicMenu.modifier.chooseOneOptional', 'Elige 1 (opcional)'); }
            if (maxSelections > 0) { return t('publicMenu.modifier.chooseUpToMaxOptional', { max: maxSelections }); }
        }
        return t('publicMenu.modifier.chooseOptional', 'Opcional');
    };
    
    const renderOptionLabel = (option: PublicMenuModifierOption) => (
        <>
            {i18n.language === 'es' && option.name_es ? option.name_es : option.name_en || option.name_es}
            {option.priceAdjustment !== 0 && (
                <Text span c={option.priceAdjustment > 0 ? "teal.7" : "pink.7"} ml={5} fz="xs">
                    ({option.priceAdjustment > 0 ? '+' : ''}{option.priceAdjustment.toFixed(2)}‚Ç¨)
                </Text>
            )}
        </>
    );

    return (
        <Box key={group.id} mb="md" pl="sm" style={{borderLeft: `2px solid var(--mantine-color-gray-3)`, marginLeft:'4px'}}>
            <Text size="sm" fw={500}>
                {i18n.language === 'es' && group.name_es ? group.name_es : group.name_en || group.name_es}
                {group.isRequired && <Text span c="red.7" ml={4} fw={700}>*</Text>}
            </Text>
            <Text size="xs" c="dimmed" mb={4}>
                {getModifierGroupSelectionText(group)}
            </Text>
            <Stack gap="xs" mt={4}>
                {group.uiType === ModifierUiType.RADIO && (
                    <Radio.Group
                        value={selectedOptionsForThisGroup as string || ''}
                        onChange={(value) => onSelectionChange(value)}
                        name={`radio-group-${group.id}`}
                    >
                        <Stack gap="xs">
                            {group.options.map((option: PublicMenuModifierOption) => (
                                <Radio 
                                    key={option.id} 
                                    value={option.id}
                                    label={renderOptionLabel(option)} 
                                />
                            ))}
                        </Stack>
                    </Radio.Group>
                )}
                {group.uiType === ModifierUiType.CHECKBOX && (
                    <Checkbox.Group
                        value={selectedOptionsForThisGroup as string[] || []}
                        onChange={(values) => onSelectionChange(values)}
                    >
                         <Stack gap="xs">
                            {group.options.map((option: PublicMenuModifierOption) => (
                                <Checkbox
                                    key={option.id}
                                    value={option.id}
                                    label={renderOptionLabel(option)}
                                />
                            ))}
                        </Stack>
                    </Checkbox.Group>
                )}
            </Stack>
        </Box>
    );
};

export default ModifierGroupInteractiveRenderer;


// ====== [130] frontend/src/modules/camarero/components/public/menu/ShoppingCartModal.tsx ======
// frontend/src/components/public/menu/ShoppingCartModal.tsx
// Version: 0.1.4 (Add new props for "add to existing order" context)

import React from 'react';
import {
    Modal,
    Text,
    Stack,
    Group,
    Button,
    Divider,
    ScrollArea,
    Box,
    NumberInput,
    ActionIcon,
    Textarea,
    Paper,
    Tooltip,
} from '@mantine/core';
import { useTranslation } from 'react-i18next';
import {
    IconTrash,
    IconSend,
    IconCirclePlus,
    IconCircleMinus,
    IconShoppingCartOff
} from '@tabler/icons-react';

// Interfaz OrderItemFE (debe coincidir con la de PublicMenuViewPage o importarse de un tipo com√∫n)
interface OrderItemFE {
    cartItemId: string;
    menuItemName_es: string | null;
    menuItemName_en: string | null;
    quantity: number;
    currentPricePerUnit: number;
    totalPriceForItem: number;
    notes?: string | null;
    selectedModifiers: { 
        modifierOptionId: string;
        name_es?: string | null;
        name_en?: string | null;
        priceAdjustment: number;
        modifierGroupName_es?: string | null;
        modifierGroupName_en?: string | null;
    }[];
}

interface ShoppingCartModalProps {
    opened: boolean;
    onClose: () => void;
    orderItems: OrderItemFE[];
    orderNotes: string;
    onUpdateItemQuantity: (cartItemId: string, newQuantity: number) => void;
    onRemoveItem: (cartItemId: string) => void;
    onUpdateOrderNotes: (notes: string) => void;
    onSubmitOrder: () => Promise<void>;
    isSubmittingOrder: boolean;
    onClearCart: () => void;
    // --- NUEVAS PROPS A√ëADIDAS ---
    isAddingToExistingOrder?: boolean; 
    activeOrderNumber?: string | null;
}

const ShoppingCartModal: React.FC<ShoppingCartModalProps> = ({
    opened,
    onClose,
    orderItems,
    orderNotes,
    onUpdateItemQuantity,
    onRemoveItem,
    onUpdateOrderNotes,
    onSubmitOrder,
    isSubmittingOrder,
    onClearCart,
    // --- RECIBIR NUEVAS PROPS ---
    isAddingToExistingOrder,
    activeOrderNumber,
}) => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;

    const calculateSubtotal = () => {
        return orderItems.reduce((acc, item) => acc + item.totalPriceForItem, 0);
    };

    const subtotal = calculateSubtotal();
    const totalOrderAmount = subtotal;

    const handleQuantityChange = (cartItemId: string, value: number | string) => {
        const newQuantity = Number(value);
        onUpdateItemQuantity(cartItemId, Math.max(1, newQuantity));
    };

    // Determinar el t√≠tulo del modal y el texto del bot√≥n de env√≠o
    const modalTitle = isAddingToExistingOrder 
        ? t('publicMenu.cart.titleAddToOrder', { orderNumber: activeOrderNumber || '' })
        : t('publicMenu.cart.title', 'Tu Pedido');
    
    const submitButtonText = isAddingToExistingOrder
        ? t('publicMenu.cart.submitAddToOrder', 'A√±adir al Pedido')
        : t('publicMenu.cart.submitOrder', 'Enviar Pedido');


    return (
        <Modal
            opened={opened}
            onClose={onClose}
            title={modalTitle} // <-- T√≠tulo din√°mico
            size="lg"
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
            scrollAreaComponent={ScrollArea.Autosize}
            centered
        >
            <Stack gap="md">
                {orderItems.length > 0 && (
                    <Group justify="flex-end">
                        <Button
                            variant="outline"
                            color="red"
                            size="xs"
                            leftSection={<IconShoppingCartOff size={14} />}
                            onClick={onClearCart}
                            disabled={isSubmittingOrder}
                        >
                            {t('publicMenu.cart.clearCartButton', 'Vaciar Carrito')}
                        </Button>
                    </Group>
                )}

                {orderItems.length === 0 ? (
                    <Text c="dimmed" ta="center" py="xl">
                        {isAddingToExistingOrder 
                            ? t('publicMenu.cart.emptyAddToOrder', 'Selecciona √≠tems para a√±adir a tu pedido.')
                            : t('publicMenu.cart.empty', 'Tu carrito de pedido est√° vac√≠o.')
                        }
                    </Text>
                ) : (
                    <ScrollArea.Autosize mah="40vh">
                        <Stack gap="md">
                            {orderItems.map((item) => {
                                const itemNameForLabel = (currentLanguage === 'es' && item.menuItemName_es ? item.menuItemName_es : item.menuItemName_en || item.menuItemName_es) || t('publicMenu.unnamedItem');
                                return (
                                <Paper key={item.cartItemId} p="sm" withBorder radius="sm">
                                    <Group justify="space-between" align="flex-start">
                                        <Box style={{ flex: 1 }}>
                                            <Text fw={500}>
                                                {itemNameForLabel}
                                            </Text>
                                            {item.selectedModifiers && item.selectedModifiers.length > 0 && (
                                                <Box ml="xs" mt={2}>
                                                    {item.selectedModifiers.map(mod => (
                                                        <Text key={mod.modifierOptionId} size="xs" c="dimmed">
                                                            + {(currentLanguage === 'es' && mod.name_es ? mod.name_es : mod.name_en || mod.name_es) || t('publicMenu.unnamedModifier')}
                                                            {mod.priceAdjustment !== 0 && ` (${mod.priceAdjustment > 0 ? '+' : ''}${mod.priceAdjustment.toFixed(2)}‚Ç¨)`}
                                                        </Text>
                                                    ))}
                                                </Box>
                                            )}
                                            {item.notes && (
                                                <Text size="xs" c="dimmed" fs="italic" mt={2}>
                                                    {t('publicMenu.cart.itemNotesLabel', 'Notas:')} {item.notes}
                                                </Text>
                                            )}
                                        </Box>
                                        <Stack align="flex-end" gap={4}>
                                            <Text fw={500} size="sm">
                                                {item.totalPriceForItem.toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}
                                            </Text>
                                            <Group gap="xs" wrap="nowrap">
                                                <ActionIcon 
                                                    variant="default" 
                                                    size="sm" 
                                                    onClick={() => handleQuantityChange(item.cartItemId, item.quantity - 1)} 
                                                    disabled={item.quantity <= 1 || isSubmittingOrder}
                                                    aria-label={t('publicMenu.cart.decreaseQuantity', { itemName: itemNameForLabel })}
                                                >
                                                    <IconCircleMinus size={16} />
                                                </ActionIcon>
                                                <NumberInput
                                                    value={item.quantity}
                                                    onChange={(val) => handleQuantityChange(item.cartItemId, val)}
                                                    min={1}
                                                    max={20}
                                                    step={1}
                                                    hideControls
                                                    disabled={isSubmittingOrder}
                                                    styles={{ input: { width: '40px', textAlign: 'center', paddingLeft: '0', paddingRight: '0'} }}
                                                    aria-label={t('publicMenu.cart.itemQuantity', { itemName: itemNameForLabel })}
                                                />
                                                <ActionIcon 
                                                    variant="default" 
                                                    size="sm" 
                                                    onClick={() => handleQuantityChange(item.cartItemId, item.quantity + 1)} 
                                                    disabled={isSubmittingOrder}
                                                    aria-label={t('publicMenu.cart.increaseQuantity', { itemName: itemNameForLabel })}
                                                >
                                                    <IconCirclePlus size={16} />
                                                </ActionIcon>
                                                <Tooltip label={t('publicMenu.cart.removeItem', 'Eliminar √≠tem')} withArrow>
                                                    <Box> 
                                                        <ActionIcon 
                                                            color="red" 
                                                            variant="light" 
                                                            onClick={() => onRemoveItem(item.cartItemId)} 
                                                            disabled={isSubmittingOrder}
                                                            aria-label={t('publicMenu.cart.removeItemFromOrder', { itemName: itemNameForLabel })}
                                                        >
                                                            <IconTrash size={16} />
                                                        </ActionIcon>
                                                    </Box>
                                                </Tooltip>
                                            </Group>
                                        </Stack>
                                    </Group>
                                </Paper>
                            )})}
                        </Stack>
                    </ScrollArea.Autosize>
                )}

                <Divider my="sm" />

                <Textarea
                    label={t('publicMenu.cart.orderNotesLabel', 'Notas para el Pedido (Opcional)')}
                    placeholder={t('publicMenu.cart.orderNotesPlaceholder', 'Ej: Alergias generales, preferencia de entrega...')}
                    value={orderNotes}
                    onChange={(event) => onUpdateOrderNotes(event.currentTarget.value)}
                    minRows={2}
                    disabled={isSubmittingOrder}
                />

                <Divider my="sm" />

                <Group justify="space-between">
                    <Text fw={700} size="lg">
                        {isAddingToExistingOrder 
                            ? t('publicMenu.cart.totalAddItems', 'Total a A√±adir:')
                            : t('publicMenu.cart.totalOrder', 'Total del Pedido:')
                        }
                    </Text>
                    <Text fw={700} size="lg">
                        {totalOrderAmount.toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}
                    </Text>
                </Group>

                <Group justify="flex-end" mt="xl">
                    <Button variant="default" onClick={onClose} disabled={isSubmittingOrder}>
                        {t('publicMenu.cart.continueShopping', 'Seguir Pidiendo')}
                    </Button>
                    <Button
                        onClick={onSubmitOrder}
                        loading={isSubmittingOrder}
                        disabled={orderItems.length === 0}
                        leftSection={<IconSend size={16} />}
                        color="green"
                    >
                        {submitButtonText} {/* <-- Texto din√°mico del bot√≥n */}
                    </Button>
                </Group>
            </Stack>
        </Modal>
    );
};

export default ShoppingCartModal;


// ====== [131] frontend/src/modules/camarero/hooks/useActiveOrderState.ts ======
// frontend/src/hooks/useActiveOrderState.ts
import { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { OrderStatus as PageOrderStatus, PublicOrderStatusInfo as PagePublicOrderStatusInfo } from '../pages/OrderStatusPage'; // Aseg√∫rate que la ruta es correcta

// Importar tipo ActiveOrderInfo
interface ActiveOrderInfo {
    orderId: string;
    orderNumber: string;
    businessSlug: string;
    tableIdentifier?: string;
    savedAt: number; // timestamp de cuando se guard√≥
}

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL_PUBLIC || 'http://localhost:3000/public';
const ACTIVE_ORDER_INFO_KEY_PREFIX = 'loyalpyme_active_order_info_';

export interface UseActiveOrderStateReturn {
    activeOrderId: string | null;
    activeOrderNumber: string | null;
    canCurrentlyAddToExistingOrder: boolean;
    loadingActiveOrderStatus: boolean;
    checkActiveOrderStatus: () => Promise<void>; // Para una comprobaci√≥n manual si es necesario
    clearActiveOrder: () => void;
    setActiveOrderManually: (orderId: string, orderNumber: string) => void; // Para cuando se crea un nuevo pedido
}

export const useActiveOrderState = (businessSlug: string | undefined, tableIdentifier: string | undefined): UseActiveOrderStateReturn => {
    const activeOrderKey = businessSlug ? `${ACTIVE_ORDER_INFO_KEY_PREFIX}${businessSlug}${tableIdentifier ? `_${tableIdentifier}` : ''}` : null;

    const [activeOrderId, setActiveOrderId] = useState<string | null>(null);
    const [activeOrderNumber, setActiveOrderNumber] = useState<string | null>(null);
    const [canCurrentlyAddToExistingOrder, setCanCurrentlyAddToExistingOrder] = useState<boolean>(false);
    const [loadingActiveOrderStatus, setLoadingActiveOrderStatus] = useState<boolean>(true); // Inicia en true

    const canAddMoreItemsToOrderStatus = useCallback((status: PageOrderStatus | undefined): boolean => {
        if (!status) return false;
        return [
            PageOrderStatus.RECEIVED, PageOrderStatus.IN_PROGRESS, PageOrderStatus.PARTIALLY_READY,
            PageOrderStatus.ALL_ITEMS_READY, PageOrderStatus.COMPLETED
        ].includes(status);
    }, []);

    const checkActiveOrderStatus = useCallback(async (currentOrderId?: string, currentOrderNumber?: string) => {
        const orderIdToCheck = currentOrderId || activeOrderId;
        const orderNumberToCheck = currentOrderNumber || activeOrderNumber;

        if (!orderIdToCheck || !orderNumberToCheck) {
            setCanCurrentlyAddToExistingOrder(false);
            setLoadingActiveOrderStatus(false);
            return;
        }

        setLoadingActiveOrderStatus(true);
        try {
            const response = await axios.get<PagePublicOrderStatusInfo>(`${API_BASE_URL}/order/${orderIdToCheck}/status`);
            if (response.data && canAddMoreItemsToOrderStatus(response.data.orderStatus)) {
                setCanCurrentlyAddToExistingOrder(true);
                // Reafirmar el estado si la comprobaci√≥n fue exitosa, en caso de que currentOrderId viniera de localStorage y a√∫n no estuviera en el estado
                setActiveOrderId(orderIdToCheck);
                setActiveOrderNumber(orderNumberToCheck);
            } else {
                setCanCurrentlyAddToExistingOrder(false);
                if (activeOrderKey) localStorage.removeItem(activeOrderKey);
                setActiveOrderId(null);
                setActiveOrderNumber(null);
            }
        } catch (error) {
            console.error(`[useActiveOrderState] Error checking status for order ${orderIdToCheck}:`, error);
            setCanCurrentlyAddToExistingOrder(false);
            if (activeOrderKey) localStorage.removeItem(activeOrderKey);
            setActiveOrderId(null);
            setActiveOrderNumber(null);
        } finally {
            setLoadingActiveOrderStatus(false);
        }
    }, [activeOrderId, activeOrderNumber, activeOrderKey, canAddMoreItemsToOrderStatus]);


    useEffect(() => {
        // console.log(`[useActiveOrderState] useEffect triggered. activeOrderKey: ${activeOrderKey}`);
        if (activeOrderKey) {
            const storedActiveOrderInfo = localStorage.getItem(activeOrderKey);
            if (storedActiveOrderInfo) {
                try {
                    const parsedInfo: ActiveOrderInfo = JSON.parse(storedActiveOrderInfo);
                    if (parsedInfo.orderId && parsedInfo.orderNumber) {
                        // console.log(`[useActiveOrderState] Found active order in localStorage: ${parsedInfo.orderId}`);
                        setActiveOrderId(parsedInfo.orderId);
                        setActiveOrderNumber(parsedInfo.orderNumber);
                        checkActiveOrderStatus(parsedInfo.orderId, parsedInfo.orderNumber);
                    } else {
                        // console.log(`[useActiveOrderState] Invalid info in localStorage for key ${activeOrderKey}, removing.`);
                        localStorage.removeItem(activeOrderKey);
                        setActiveOrderId(null); setActiveOrderNumber(null); setCanCurrentlyAddToExistingOrder(false);
                        setLoadingActiveOrderStatus(false);
                    }
                } catch (e) {
                    // console.error(`[useActiveOrderState] Error parsing localStorage for key ${activeOrderKey}:`, e);
                    localStorage.removeItem(activeOrderKey);
                    setActiveOrderId(null); setActiveOrderNumber(null); setCanCurrentlyAddToExistingOrder(false);
                    setLoadingActiveOrderStatus(false);
                }
            } else {
                // console.log(`[useActiveOrderState] No active order info in localStorage for key ${activeOrderKey}.`);
                setActiveOrderId(null); setActiveOrderNumber(null); setCanCurrentlyAddToExistingOrder(false);
                setLoadingActiveOrderStatus(false);
            }
        } else {
            // console.log(`[useActiveOrderState] activeOrderKey is null.`);
            setActiveOrderId(null); setActiveOrderNumber(null); setCanCurrentlyAddToExistingOrder(false);
            setLoadingActiveOrderStatus(false);
        }
    }, [activeOrderKey, checkActiveOrderStatus]); // Ejecutar solo cuando activeOrderKey cambia

    const clearActiveOrder = useCallback(() => {
        if (activeOrderKey) {
            localStorage.removeItem(activeOrderKey);
        }
        setActiveOrderId(null);
        setActiveOrderNumber(null);
        setCanCurrentlyAddToExistingOrder(false);
        // console.log(`[useActiveOrderState] Active order cleared.`);
    }, [activeOrderKey]);

    const setActiveOrderManually = useCallback((orderId: string, orderNumber: string) => {
        if (activeOrderKey && businessSlug) {
            const activeOrderData: ActiveOrderInfo = { orderId, orderNumber, businessSlug, tableIdentifier, savedAt: Date.now() };
            localStorage.setItem(activeOrderKey, JSON.stringify(activeOrderData));
            setActiveOrderId(orderId);
            setActiveOrderNumber(orderNumber);
            setCanCurrentlyAddToExistingOrder(true); // Asumimos que un nuevo pedido puede tener √≠tems a√±adidos
            // console.log(`[useActiveOrderState] Active order set manually: ${orderId}`);
        }
    }, [activeOrderKey, businessSlug, tableIdentifier]);


    return {
        activeOrderId,
        activeOrderNumber,
        canCurrentlyAddToExistingOrder,
        loadingActiveOrderStatus,
        checkActiveOrderStatus: () => checkActiveOrderStatus(), // Envolver para que no requiera params
        clearActiveOrder,
        setActiveOrderManually,
    };
};


// ====== [132] frontend/src/modules/camarero/hooks/useAdminMenuCategories.ts ======
// Nuevo archivo: frontend/src/hooks/useAdminMenuCategories.ts

import { useState, useCallback, useEffect } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
import { MenuCategoryData, MenuCategoryFormData } from '../types/menu.types'; // Importar nuestros nuevos tipos

const API_ENDPOINT = '/camarero/admin/menu/categories'; // Endpoint base para categor√≠as

export interface UseAdminMenuCategoriesReturn {
    categories: MenuCategoryData[];
    loading: boolean;
    error: string | null;
    fetchCategories: () => Promise<void>;
    addCategory: (data: MenuCategoryFormData) => Promise<MenuCategoryData | null>;
    updateCategory: (id: string, data: Partial<MenuCategoryFormData>) => Promise<MenuCategoryData | null>;
    deleteCategory: (id: string) => Promise<boolean>;
    // Podr√≠amos a√±adir aqu√≠ funciones para reordenar si fuera necesario
}

export const useAdminMenuCategories = (): UseAdminMenuCategoriesReturn => {
    const { t } = useTranslation();
    const [categories, setCategories] = useState<MenuCategoryData[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);

    const fetchCategories = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
            const response = await axiosInstance.get<MenuCategoryData[]>(API_ENDPOINT);
            // El backend ya deber√≠a devolverlas ordenadas por 'position'
            setCategories(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            setError(msg);
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
        } finally {
            setLoading(false);
        }
    }, [t]);

    useEffect(() => {
        fetchCategories();
    }, [fetchCategories]);

    const addCategory = async (data: MenuCategoryFormData): Promise<MenuCategoryData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.post<MenuCategoryData>(API_ENDPOINT, data);
            notifications.show({
                title: t('adminCommon.createSuccess'),
                message: t('adminCamarero.manageMenu.categoryCreateSuccess', { name: response.data.name_es }), // Necesitaremos esta clave i18n
                color: 'green',
            });
            await fetchCategories(); // Refrescar la lista
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.createError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false); // Asegurar que loading se desactiva en error
            return null;
        }
    };

    const updateCategory = async (id: string, data: Partial<MenuCategoryFormData>): Promise<MenuCategoryData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.put<MenuCategoryData>(`${API_ENDPOINT}/${id}`, data);
            notifications.show({
                title: t('adminCommon.updateSuccess'),
                message: t('adminCamarero.manageMenu.categoryUpdateSuccess', { name: response.data.name_es }), // Necesitaremos esta clave i18n
                color: 'green',
            });
            await fetchCategories(); // Refrescar
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.updateError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        }
    };

    const deleteCategory = async (id: string): Promise<boolean> => {
        setLoading(true);
        try {
            await axiosInstance.delete(`${API_ENDPOINT}/${id}`);
            notifications.show({
                title: t('adminCommon.deleteSuccess'),
                message: t('adminCamarero.manageMenu.categoryDeleteSuccess'), // Necesitaremos esta clave i18n
                color: 'green',
            });
            await fetchCategories(); // Refrescar
            return true;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.deleteError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return false;
        }
    };

    return {
        categories,
        loading,
        error,
        fetchCategories,
        addCategory,
        updateCategory,
        deleteCategory,
    };
};


// ====== [133] frontend/src/modules/camarero/hooks/useAdminMenuItems.ts ======
// frontend/src/hooks/useAdminMenuItems.ts
import { useState, useCallback, useEffect } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
import { MenuItemData, MenuItemFormData } from '../types/menu.types';

const ITEMS_API_BASE = `/camarero/admin/menu/items`;
const CATEGORY_ITEMS_API_BASE = (categoryId: string) => `/camarero/admin/menu/categories/${categoryId}/items`;

export interface UseAdminMenuItemsReturn {
    items: MenuItemData[];
    loading: boolean;
    error: string | null;
    fetchItems: () => Promise<void>;
    addItem: (data: MenuItemFormData) => Promise<MenuItemData | null>;
    updateItem: (itemId: string, data: Partial<MenuItemFormData>) => Promise<MenuItemData | null>;
    deleteItem: (itemId: string) => Promise<boolean>;
}

export const useAdminMenuItems = (categoryId: string | null): UseAdminMenuItemsReturn => {
    const { t } = useTranslation();
    const [items, setItems] = useState<MenuItemData[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    const fetchItems = useCallback(async () => {
        if (!categoryId) {
            setItems([]);
            setLoading(false);
            return;
        }
        setLoading(true);
        setError(null);
        try {
            const response = await axiosInstance.get<MenuItemData[]>(CATEGORY_ITEMS_API_BASE(categoryId));
            setItems(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            setError(msg);
            // No mostrar notificaci√≥n aqu√≠ directamente
        } finally {
            setLoading(false);
        }
    }, [categoryId, t]);

    useEffect(() => {
        if (categoryId) {
            fetchItems();
        } else {
            setItems([]);
        }
    }, [categoryId, fetchItems]);

    const addItem = async (data: MenuItemFormData): Promise<MenuItemData | null> => {
        if (!categoryId) {
            notifications.show({
                title: t('common.error'),
                message: t('adminCamarero.menuItemHook.errorNoCategoryForItem'),
                color: 'red'
            });
            return null;
        }
        setLoading(true);
        try {
            const response = await axiosInstance.post<MenuItemData>(CATEGORY_ITEMS_API_BASE(categoryId), data);
            notifications.show({
                title: t('adminCommon.createSuccess'),
                message: t('adminCamarero.manageMenu.itemCreateSuccess', { name: response.data.name_es || t('adminCamarero.manageMenu.itemFallbackName') }),
                color: 'green',
            });
            fetchItems();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.createError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            // Asegurar que loading se desactive si no se hizo ya
            if (loading) setLoading(false);
        }
    };

    const updateItem = async (itemId: string, data: Partial<MenuItemFormData>): Promise<MenuItemData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.put<MenuItemData>(`${ITEMS_API_BASE}/${itemId}`, data);
            notifications.show({
                title: t('adminCommon.updateSuccess'),
                message: t('adminCamarero.manageMenu.itemUpdateSuccess', { name: response.data.name_es || t('adminCamarero.manageMenu.itemFallbackName') }),
                color: 'green',
            });
            fetchItems();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.updateError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const deleteItem = async (itemId: string): Promise<boolean> => {
        setLoading(true);
        try {
            await axiosInstance.delete(`${ITEMS_API_BASE}/${itemId}`);
            notifications.show({
                title: t('adminCommon.deleteSuccess'),
                message: t('adminCamarero.manageMenu.itemDeleteSuccess'),
                color: 'green',
            });
            fetchItems();
            return true;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.deleteError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return false;
        } finally {
            if (loading) setLoading(false);
        }
    };

    return {
        items,
        loading,
        error,
        fetchItems,
        addItem,
        updateItem,
        deleteItem,
    };
};


// ====== [134] frontend/src/modules/camarero/hooks/useAdminModifierGroups.ts ======
// frontend/src/hooks/useAdminModifierGroups.ts
import { useState, useCallback, useEffect } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
import { ModifierGroupData, ModifierGroupFormData } from '../types/menu.types';

const getGroupsApiEndpoint = (menuItemId: string) => `/camarero/admin/menu/items/${menuItemId}/modifier-groups`;
const groupApiEndpoint = (modifierGroupId: string) => `/camarero/admin/modifier-groups/${modifierGroupId}`;

export interface UseAdminModifierGroupsReturn {
    modifierGroups: ModifierGroupData[];
    loading: boolean;
    error: string | null;
    fetchModifierGroups: () => Promise<void>;
    addModifierGroup: (data: ModifierGroupFormData) => Promise<ModifierGroupData | null>;
    updateModifierGroup: (groupId: string, data: Partial<ModifierGroupFormData>) => Promise<ModifierGroupData | null>;
    deleteModifierGroup: (groupId: string) => Promise<boolean>;
}

export const useAdminModifierGroups = (menuItemId: string | null): UseAdminModifierGroupsReturn => {
    const { t } = useTranslation();
    const [modifierGroups, setModifierGroups] = useState<ModifierGroupData[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    const fetchModifierGroups = useCallback(async () => {
        if (!menuItemId) {
            setModifierGroups([]);
            setLoading(false);
            return;
        }
        setLoading(true);
        setError(null);
        console.log(`[useAdminModifierGroups] Fetching groups for menuItemId: ${menuItemId}`);
        try {
            const response = await axiosInstance.get<ModifierGroupData[]>(getGroupsApiEndpoint(menuItemId));
            setModifierGroups(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            setError(msg);
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
        } finally {
            setLoading(false);
        }
    }, [menuItemId, t]);

    useEffect(() => {
        fetchModifierGroups();
    }, [fetchModifierGroups]);

    const addModifierGroup = async (data: ModifierGroupFormData): Promise<ModifierGroupData | null> => {
        if (!menuItemId) {
            notifications.show({
                title: t('common.error'),
                message: t('adminCamarero.modifierGroupHook.errorNoMenuItemForGroup'), // Nueva clave
                color: 'red'
            });
            return null;
        }
        setLoading(true);
        try {
            const response = await axiosInstance.post<ModifierGroupData>(getGroupsApiEndpoint(menuItemId), data);
            notifications.show({
                title: t('adminCommon.createSuccess'),
                message: t('adminCamarero.manageMenu.modifierGroupCreateSuccess', { name: response.data.name_es || t('adminCamarero.modifierGroupHook.fallbackGroupName') }), // Nueva clave para fallback
                color: 'green',
            });
            await fetchModifierGroups();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.createError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const updateModifierGroup = async (groupId: string, data: Partial<ModifierGroupFormData>): Promise<ModifierGroupData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.put<ModifierGroupData>(groupApiEndpoint(groupId), data);
            notifications.show({
                title: t('adminCommon.updateSuccess'),
                message: t('adminCamarero.manageMenu.modifierGroupUpdateSuccess', { name: response.data.name_es || t('adminCamarero.modifierGroupHook.fallbackGroupName') }),
                color: 'green',
            });
            await fetchModifierGroups();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.updateError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const deleteModifierGroup = async (groupId: string): Promise<boolean> => {
        setLoading(true);
        try {
            await axiosInstance.delete(groupApiEndpoint(groupId));
            notifications.show({
                title: t('adminCommon.deleteSuccess'),
                message: t('adminCamarero.manageMenu.modifierGroupDeleteSuccess'),
                color: 'green',
            });
            await fetchModifierGroups();
            return true;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCommon.deleteError');
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return false;
        } finally {
            if (loading) setLoading(false);
        }
    };

    return {
        modifierGroups,
        loading,
        error,
        fetchModifierGroups,
        addModifierGroup,
        updateModifierGroup,
        deleteModifierGroup,
    };
};


// ====== [135] frontend/src/modules/camarero/hooks/useAdminModifierOptions.ts ======
// frontend/src/hooks/useAdminModifierOptions.ts
import { useState, useCallback, useEffect } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next'; // Importar useTranslation
import { ModifierOptionData, ModifierOptionFormData } from '../types/menu.types';

const getOptionsApiEndpoint = (modifierGroupId: string) => `/camarero/admin/modifier-groups/${modifierGroupId}/options`;
const optionApiEndpoint = (modifierOptionId: string) => `/camarero/admin/modifier-options/${modifierOptionId}`;

export interface UseAdminModifierOptionsReturn {
    modifierOptions: ModifierOptionData[];
    loading: boolean;
    error: string | null;
    fetchModifierOptions: () => Promise<void>;
    addModifierOption: (data: ModifierOptionFormData) => Promise<ModifierOptionData | null>;
    updateModifierOption: (optionId: string, data: Partial<ModifierOptionFormData>) => Promise<ModifierOptionData | null>;
    deleteModifierOption: (optionId: string) => Promise<boolean>;
}

export const useAdminModifierOptions = (modifierGroupId: string | null): UseAdminModifierOptionsReturn => {
    const { t } = useTranslation(); // Inicializar hook
    const [modifierOptions, setModifierOptions] = useState<ModifierOptionData[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    const fetchModifierOptions = useCallback(async () => {
        if (!modifierGroupId) {
            setModifierOptions([]);
            setLoading(false);
            return;
        }
        setLoading(true);
        setError(null);
        console.log(`[useAdminModifierOptions] Fetching options for modifierGroupId: ${modifierGroupId}`);
        try {
            const response = await axiosInstance.get<ModifierOptionData[]>(getOptionsApiEndpoint(modifierGroupId));
            setModifierOptions(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCamarero.modifierOptionHook.errorLoadingOptions'); // Usar clave
            setError(msg);
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
        } finally {
            setLoading(false);
        }
    }, [modifierGroupId, t]); // A√±adir t como dependencia

    useEffect(() => {
        if (modifierGroupId) {
            fetchModifierOptions();
        } else {
            setModifierOptions([]);
        }
    }, [modifierGroupId, fetchModifierOptions]);

    const addModifierOption = async (data: ModifierOptionFormData): Promise<ModifierOptionData | null> => {
        if (!modifierGroupId) {
            notifications.show({
                title: t('common.error'),
                message: t('adminCamarero.modifierOptionHook.errorNoGroupForOption'), // Usar clave
                color: 'red'
            });
            return null;
        }
        setLoading(true);
        try {
            const response = await axiosInstance.post<ModifierOptionData>(getOptionsApiEndpoint(modifierGroupId), data);
            notifications.show({
                title: t('common.success'),
                message: t('adminCamarero.modifierOptionHook.createSuccess', { optionName: response.data.name_es || t('adminCamarero.modifierOptionHook.fallbackOptionName') }), // Usar clave
                color: 'green',
            });
            await fetchModifierOptions();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCamarero.modifierOptionHook.errorCreatingOption'); // Usar clave
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const updateModifierOption = async (optionId: string, data: Partial<ModifierOptionFormData>): Promise<ModifierOptionData | null> => {
        setLoading(true);
        try {
            const response = await axiosInstance.put<ModifierOptionData>(optionApiEndpoint(optionId), data);
            notifications.show({
                title: t('common.success'),
                message: t('adminCamarero.modifierOptionHook.updateSuccess', { optionName: response.data.name_es || t('adminCamarero.modifierOptionHook.fallbackOptionName') }), // Usar clave
                color: 'green',
            });
            await fetchModifierOptions();
            return response.data;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCamarero.modifierOptionHook.errorUpdatingOption'); // Usar clave
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return null;
        } finally {
            if (loading) setLoading(false);
        }
    };

    const deleteModifierOption = async (optionId: string): Promise<boolean> => {
        setLoading(true);
        try {
            await axiosInstance.delete(optionApiEndpoint(optionId));
            notifications.show({
                title: t('common.success'),
                message: t('adminCamarero.modifierOptionHook.deleteSuccess'), // Usar clave
                color: 'green',
            });
            await fetchModifierOptions();
            return true;
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('adminCamarero.modifierOptionHook.errorDeletingOption'); // Usar clave
            notifications.show({ title: t('common.error'), message: msg, color: 'red' });
            setLoading(false);
            return false;
        } finally {
            if (loading) setLoading(false);
        }
    };

    return {
        modifierOptions,
        loading,
        error,
        fetchModifierOptions,
        addModifierOption,
        updateModifierOption,
        deleteModifierOption,
    };
};


// ====== [136] frontend/src/modules/camarero/hooks/useMenuItemConfigurator.ts ======
// frontend/src/hooks/useMenuItemConfigurator.ts
import { useState, useEffect, useCallback } from 'react';
import { useTranslation } from 'react-i18next';
import {
    PublicMenuItem,
    ModifierUiType,
} from '../types/menu.types';
import { ConfiguringItemState } from '../types/publicOrder.types';

const getTranslatedNameHelper = (item: { name_es?: string | null, name_en?: string | null }, lang: string, defaultName: string = 'Unnamed') => {
    if (lang === 'es' && item.name_es) return item.name_es;
    if (lang === 'en' && item.name_en) return item.name_en;
    return item.name_es || item.name_en || defaultName;
};

export interface UseMenuItemConfiguratorReturn {
    configuringItem: ConfiguringItemState | null;
    startConfiguringItem: (item: PublicMenuItem) => void;
    cancelConfiguration: () => void;
    updateConfigQuantity: (newQuantity: number) => void;
    updateConfigModifierSelection: (groupId: string, newSelection: string | string[], groupUiType: ModifierUiType) => void;
    updateConfigNotes: (newNotes: string) => void;
}

export const useMenuItemConfigurator = (): UseMenuItemConfiguratorReturn => {
    const { i18n } = useTranslation();
    const currentLang = i18n.language;
    const [configuringItem, setConfiguringItem] = useState<ConfiguringItemState | null>(null);

    const calculatePriceAndValidate = useCallback((itemDetails: PublicMenuItem, selectedOptions: Record<string, string[] | string>): { newPrice: number; isValid: boolean } => {
        let newPrice = itemDetails.price;
        let isValid = true;
        const itemNameForLog = getTranslatedNameHelper(itemDetails, currentLang, "Item Desconocido");

        if (Array.isArray(itemDetails.modifierGroups)) {
            for (const group of itemDetails.modifierGroups) {
                const groupNameForLog = getTranslatedNameHelper(group, currentLang, "Grupo Desconocido");
                const selections = selectedOptions[group.id];
                let count = 0;
                let currentSelectionsForGroup: string[] = [];

                if (Array.isArray(selections)) {
                    currentSelectionsForGroup = selections.filter(s => s && s.trim() !== '');
                    count = currentSelectionsForGroup.length;
                } else if (typeof selections === 'string' && selections.trim() !== '') {
                    currentSelectionsForGroup = [selections.trim()];
                    count = 1;
                }

                if (group.isRequired && count < group.minSelections) isValid = false;
                if (count > group.maxSelections) isValid = false;
                if (group.uiType === ModifierUiType.RADIO && count > 1) isValid = false;
                
                if(Array.isArray(group.options)) {
                    currentSelectionsForGroup.forEach(optionId => {
                        const option = group.options.find(opt => opt.id === optionId);
                        if (option) {
                            newPrice += option.priceAdjustment;
                        } else {
                            console.warn(`[useMenuItemConfigurator] Option ID "${optionId}" not found in group "${groupNameForLog}" for item "${itemNameForLog}".`);
                        }
                    });
                }
            }
        }
        return { newPrice, isValid };
    }, [currentLang]);

    useEffect(() => {
        if (configuringItem) {
            const { newPrice, isValid } = calculatePriceAndValidate(configuringItem.itemDetails, configuringItem.selectedOptionsByGroup);
            if (newPrice !== configuringItem.currentUnitPrice || isValid !== configuringItem.areModifiersValid) {
                setConfiguringItem(prev => prev ? { ...prev, currentUnitPrice: newPrice, areModifiersValid: isValid } : null);
            }
        }
    }, [configuringItem, calculatePriceAndValidate, currentLang]);

    const startConfiguringItem = useCallback((item: PublicMenuItem) => {
        const initialSelectedOptions: Record<string, string[] | string> = {};
        if (Array.isArray(item.modifierGroups)) {
            item.modifierGroups.forEach(group => {
                const optionsAvailable = Array.isArray(group.options) ? group.options : [];
                const defaultOptions = optionsAvailable.filter(opt => opt.isDefault && opt.isAvailable);

                if (group.uiType === ModifierUiType.RADIO) {
                    let defaultRadioOptionId = '';
                    if (defaultOptions.length > 0) {
                        defaultRadioOptionId = defaultOptions[0].id;
                    } else if (optionsAvailable.length > 0 && group.isRequired && group.minSelections === 1) {
                        const firstAvailableOption = optionsAvailable.find(opt => opt.isAvailable);
                        if (firstAvailableOption) defaultRadioOptionId = firstAvailableOption.id;
                    }
                    initialSelectedOptions[group.id] = defaultRadioOptionId;
                } else {
                    initialSelectedOptions[group.id] = defaultOptions.map(opt => opt.id);
                }
            });
        }
        const {newPrice, isValid} = calculatePriceAndValidate(item, initialSelectedOptions);
        setConfiguringItem({
            itemDetails: item,
            quantity: 1,
            selectedOptionsByGroup: initialSelectedOptions,
            currentUnitPrice: newPrice,
            itemNotes: '',
            areModifiersValid: isValid
        });
    }, [calculatePriceAndValidate, currentLang]);

    const cancelConfiguration = useCallback(() => setConfiguringItem(null), []);
    const updateConfigQuantity = useCallback((newQuantity: number) => setConfiguringItem(prev => prev ? { ...prev, quantity: newQuantity } : null), []);

    const updateConfigModifierSelection = useCallback((groupId: string, newSelection: string | string[]) => {
        setConfiguringItem(prev => {
            if (!prev) return null;
            return {
                ...prev,
                selectedOptionsByGroup: {
                    ...prev.selectedOptionsByGroup,
                    [groupId]: newSelection
                }
            };
        });
    }, []);
    
    const updateConfigNotes = useCallback((newNotes: string) => setConfiguringItem(prev => prev ? { ...prev, itemNotes: newNotes } : null), []);

    return {
        configuringItem,
        startConfiguringItem,
        cancelConfiguration,
        updateConfigQuantity,
        updateConfigModifierSelection,
        updateConfigNotes,
    };
};


// ====== [137] frontend/src/modules/camarero/hooks/usePublicMenuData.ts ======
// frontend/src/hooks/usePublicMenuData.ts
// Version 1.0.0 (Created to encapsulate menu fetching logic)

import { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { useTranslation } from 'react-i18next';
import { PublicDigitalMenuData } from '../types/menu.types';

const API_MENU_BASE_URL = import.meta.env.VITE_API_BASE_URL_PUBLIC || 'http://localhost:3000/public';

export interface UsePublicMenuDataReturn {
    menuData: PublicDigitalMenuData | null;
    loadingMenu: boolean;
    errorMenu: string | null;
    fetchMenu: () => void;
}

export const usePublicMenuData = (businessSlug: string | undefined): UsePublicMenuDataReturn => {
    const { t } = useTranslation();
    const [menuData, setMenuData] = useState<PublicDigitalMenuData | null>(null);
    const [loadingMenu, setLoadingMenu] = useState<boolean>(true);
    const [errorMenu, setErrorMenu] = useState<string | null>(null);

    const fetchMenu = useCallback(async () => {
        if (!businessSlug) {
            setErrorMenu(t('error.missingBusinessSlug'));
            setLoadingMenu(false);
            return;
        }
        setLoadingMenu(true);
        setErrorMenu(null);
        try {
            const response = await axios.get<PublicDigitalMenuData>(`${API_MENU_BASE_URL}/menu/business/${businessSlug}`);
            if (response.data) {
                // Parse prices from string to number, as Prisma Decimal can be serialized as string
                const parsedMenuData = {
                    ...response.data,
                    categories: response.data.categories.map(c => ({
                        ...c,
                        items: c.items.map(i => ({
                            ...i,
                            price: parseFloat(String(i.price)),
                            modifierGroups: Array.isArray(i.modifierGroups) ? i.modifierGroups.map(g => ({
                                ...g,
                                options: Array.isArray(g.options) ? g.options.map(o => ({ ...o, priceAdjustment: parseFloat(String(o.priceAdjustment)) })) : []
                            })) : []
                        }))
                    }))
                };
                setMenuData(parsedMenuData);
            } else {
                throw new Error(t('error.noMenuDataReceived'));
            }
        } catch (err: any) {
            setErrorMenu(err.response?.data?.message || err.message || t('common.errorUnknown'));
            setMenuData(null);
        } finally {
            setLoadingMenu(false);
        }
    }, [businessSlug, t]);

    useEffect(() => {
        fetchMenu();
    }, [fetchMenu]);

    return { menuData, loadingMenu, errorMenu, fetchMenu };
};


// ====== [138] frontend/src/modules/camarero/hooks/usePublicOrderCart.ts ======
// frontend/src/hooks/usePublicOrderCart.ts
import React, { useState, useEffect, useCallback } from 'react'; // <-- A√ëADIDO React
import { notifications, NotificationData } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
import { IconShoppingCartPlus, IconCheck } from '@tabler/icons-react';

import { OrderItemFE } from '../types/publicOrder.types';
import { PublicMenuItem } from '../types/menu.types';

const LOCAL_STORAGE_CART_KEY_PREFIX = 'loyalpyme_public_cart_';
const LOCAL_STORAGE_ORDER_NOTES_KEY_PREFIX = 'loyalpyme_public_order_notes_';

const getTranslatedNameHelper = (item: { name_es?: string | null, name_en?: string | null }, lang: string, defaultName: string = 'Unnamed') => {
    if (lang === 'es' && item.name_es) return item.name_es;
    if (lang === 'en' && item.name_en) return item.name_en;
    return item.name_es || item.name_en || defaultName;
};

export interface UsePublicOrderCartReturn {
    currentOrderItems: OrderItemFE[];
    orderNotes: string;
    totalCartItems: number;
    totalCartAmount: number;
    addItemToCart: (item: OrderItemFE) => void;
    addSimpleItemToCart: (menuItem: PublicMenuItem, quantity: number) => void;
    updateItemQuantityInCart: (cartItemId: string, newQuantity: number) => void;
    removeItemFromCart: (cartItemId: string) => void;
    updateOrderNotes: (notes: string) => void;
    clearCart: () => void;
    loadCartFromStorage: () => void;
    clearCartStorage: () => void;
}

export const usePublicOrderCart = (
    businessSlug: string | undefined,
    tableIdentifier: string | undefined,
    activeOrderId: string | null
): UsePublicOrderCartReturn => {
    const { t, i18n } = useTranslation();
    const currentLang = i18n.language;

    const cartStorageKey = `${LOCAL_STORAGE_CART_KEY_PREFIX}${businessSlug || 'default'}${tableIdentifier ? `_${tableIdentifier}` : ''}`;
    const notesStorageKey = `${LOCAL_STORAGE_ORDER_NOTES_KEY_PREFIX}${businessSlug || 'default'}${tableIdentifier ? `_${tableIdentifier}` : ''}`;

    const [currentOrderItemsState, setCurrentOrderItemsState] = useState<OrderItemFE[]>([]);
    const [orderNotesState, setOrderNotesState] = useState<string>('');

    const loadCartFromStorage = useCallback((): void => {
        if (activeOrderId) {
            setCurrentOrderItemsState([]);
            setOrderNotesState('');
            return;
        }
        const savedCart = localStorage.getItem(cartStorageKey);
        const savedNotes = localStorage.getItem(notesStorageKey);
        try {
            setCurrentOrderItemsState(savedCart ? JSON.parse(savedCart) : []);
        } catch (e) {
            console.error("Error parsing cart from localStorage", e);
            setCurrentOrderItemsState([]);
        }
        setOrderNotesState(savedNotes || '');
    }, [cartStorageKey, notesStorageKey, activeOrderId]);

    useEffect(() => {
        loadCartFromStorage();
    }, [loadCartFromStorage]);

    useEffect(() => {
        if (!activeOrderId) {
            localStorage.setItem(cartStorageKey, JSON.stringify(currentOrderItemsState));
        }
    }, [currentOrderItemsState, cartStorageKey, activeOrderId]);

    useEffect(() => {
        if (!activeOrderId) {
            localStorage.setItem(notesStorageKey, orderNotesState);
        }
    }, [orderNotesState, notesStorageKey, activeOrderId]);

    const addItemToCart = useCallback((newItem: OrderItemFE): void => {
        setCurrentOrderItemsState((prevItems: OrderItemFE[]) => {
            const existingItemIndex = prevItems.findIndex(item => item.cartItemId === newItem.cartItemId);
            if (existingItemIndex > -1) {
                const updatedItems = [...prevItems];
                const existing = updatedItems[existingItemIndex];
                existing.quantity += newItem.quantity;
                existing.totalPriceForItem = existing.currentPricePerUnit * existing.quantity;
                return updatedItems;
            } else {
                return [...prevItems, newItem];
            }
        });
        const itemName = getTranslatedNameHelper({name_es: newItem.menuItemName_es, name_en: newItem.menuItemName_en}, currentLang, t('publicMenu.unnamedItem'));
        
        const notificationData: NotificationData = {
            title: t('publicMenu.itemAddedTitle'),
            message: t('publicMenu.itemAddedMessage', { itemName: itemName, quantity: newItem.quantity }),
            color: 'green',
            icon: React.createElement(IconShoppingCartPlus, { size: 18 })
        };
        notifications.show(notificationData);
    }, [currentLang, t]);

    const addSimpleItemToCart = useCallback((menuItem: PublicMenuItem, quantity: number): void => {
        const cartItemId = menuItem.id;
        const itemName = getTranslatedNameHelper(menuItem, currentLang, t('publicMenu.unnamedItem'));
        
        setCurrentOrderItemsState((prevItems: OrderItemFE[]) => {
            const existingSimpleItemIndex = prevItems.findIndex(
                (ci: OrderItemFE) => ci.menuItemId === menuItem.id && 
                      (!ci.selectedModifiers || ci.selectedModifiers.length === 0) && 
                      !ci.notes
            );

            if (existingSimpleItemIndex > -1) {
                const updatedItems = [...prevItems];
                const existing = updatedItems[existingSimpleItemIndex];
                existing.quantity += quantity;
                existing.totalPriceForItem = existing.currentPricePerUnit * existing.quantity;
                return updatedItems;
            } else {
                const newCartItem: OrderItemFE = {
                    cartItemId: cartItemId,
                    menuItemId: menuItem.id,
                    menuItemName_es: menuItem.name_es,
                    menuItemName_en: menuItem.name_en,
                    quantity: quantity,
                    basePrice: menuItem.price,
                    currentPricePerUnit: menuItem.price,
                    totalPriceForItem: menuItem.price * quantity,
                    notes: undefined,
                    selectedModifiers: [],
                };
                return [...prevItems, newCartItem];
            }
        });
        
        const notificationData: NotificationData = {
            title: t('publicMenu.itemAddedTitle'),
            message: t('publicMenu.itemAddedMessage', { itemName: itemName, quantity: quantity }),
            color: 'green',
            icon: React.createElement(IconShoppingCartPlus, { size: 18 })
        };
        notifications.show(notificationData);
    }, [currentLang, t]);


    const updateItemQuantityInCart = useCallback((cartItemId: string, newQuantity: number): void => {
        setCurrentOrderItemsState((prevItems: OrderItemFE[]) =>
            prevItems.map((item: OrderItemFE) =>
                item.cartItemId === cartItemId
                    ? { ...item, quantity: newQuantity, totalPriceForItem: item.currentPricePerUnit * newQuantity }
                    : item
            ).filter((item: OrderItemFE) => item.quantity > 0)
        );
    }, []);

    const removeItemFromCart = useCallback((cartItemId: string): void => {
        setCurrentOrderItemsState((prevItems: OrderItemFE[]) => prevItems.filter((item: OrderItemFE) => item.cartItemId !== cartItemId));
    }, []);

    const updateOrderNotes = useCallback((notes: string): void => {
        setOrderNotesState(notes);
    }, []);

    const clearCart = useCallback((): void => {
        setCurrentOrderItemsState([]);
        setOrderNotesState('');
        
        const notificationData: NotificationData = {
            title: t('publicMenu.cart.clearedTitle'),
            message: t('publicMenu.cart.clearedMsg'),
            color: 'blue',
            icon: React.createElement(IconCheck, { size: 18 })
        };
        notifications.show(notificationData);
    }, [t]);

    const clearCartStorage = useCallback((): void => {
        localStorage.removeItem(cartStorageKey);
        localStorage.removeItem(notesStorageKey);
    }, [cartStorageKey, notesStorageKey]);

    const totalCartItems = currentOrderItemsState.reduce((sum: number, item: OrderItemFE) => sum + item.quantity, 0);
    const totalCartAmount = currentOrderItemsState.reduce((sum: number, item: OrderItemFE) => sum + item.totalPriceForItem, 0);

    // Devolver solo las funciones que se usan
    return {
        currentOrderItems: currentOrderItemsState,
        orderNotes: orderNotesState,
        totalCartItems, // Usado en PublicMenuViewPage
        totalCartAmount, // Usado en PublicMenuViewPage
        addItemToCart, // Usado en PublicMenuViewPage
        addSimpleItemToCart, // Usado en PublicMenuViewPage
        updateItemQuantityInCart, // Usado en ShoppingCartModal (pasado desde PublicMenuViewPage)
        removeItemFromCart, // Usado en ShoppingCartModal (pasado desde PublicMenuViewPage)
        updateOrderNotes, // Usado en ShoppingCartModal (pasado desde PublicMenuViewPage)
        clearCart, // Usado en ShoppingCartModal (pasado desde PublicMenuViewPage)
        loadCartFromStorage, // No se usa externamente, pero es parte de la l√≥gica interna del hook
        clearCartStorage, // Usado en PublicMenuViewPage
    };
};


// ====== [139] frontend/src/modules/camarero/hooks/useWaiterPickupItems.ts ======
// frontend/src/hooks/useWaiterPickupItems.ts
import { useState, useCallback, useEffect, useRef } from 'react';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
// IconCheck y IconX no se usar√°n temporalmente en las notificaciones para depurar
// import { IconCheck, IconX } from '@tabler/icons-react'; 

import { getReadyForPickupItems, markOrderItemAsServed } from '../services/waiterService';
import type { ReadyPickupItem } from '../types/camarero.types';

const POLLING_INTERVAL_MS = 15000;

export interface UseWaiterPickupItemsReturn {
    items: ReadyPickupItem[];
    isLoadingInitial: boolean;
    fetchError: string | null;
    markingItemId: string | null;
    fetchItems: (isInitialLoad?: boolean) => Promise<void>; // La declaraci√≥n es Promise<void>
    handleMarkAsServed: (orderItemId: string) => Promise<void>;
}

export const useWaiterPickupItems = (): UseWaiterPickupItemsReturn => {
    const { t, i18n } = useTranslation();
    const [items, setItems] = useState<ReadyPickupItem[]>([]);
    const [isLoadingInitial, setIsLoadingInitial] = useState<boolean>(true);
    const [fetchError, setFetchError] = useState<string | null>(null);
    const [markingItemId, setMarkingItemId] = useState<string | null>(null);

    const pollingTimeoutRef = useRef<number | null>(null);
    const isMountedRef = useRef<boolean>(true);

    // fetchItems: Obtiene los √≠tems listos del servidor.
    // La declaraci√≥n de retorno es Promise<void> porque es una funci√≥n async que no devuelve un valor expl√≠cito.
    const fetchItems = useCallback(async (isInitialLoad = false): Promise<void> => {
        if (isInitialLoad) {
            setIsLoadingInitial(true);
            setFetchError(null);
        }
        // console.log(`[useWaiterPickupItems] Fetching items. Initial: ${isInitialLoad}`);

        try {
            const fetchedItems = await getReadyForPickupItems();
            if (isMountedRef.current) {
                setItems(fetchedItems);
                if (fetchError && !isInitialLoad) { // Limpiar error si un fetch posterior es exitoso
                    setFetchError(null);
                }
            }
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            if (isMountedRef.current) {
                setFetchError(msg);
                // console.error("[useWaiterPickupItems] Error fetching items:", msg);
            }
        } finally {
            if (isMountedRef.current && isInitialLoad) {
                setIsLoadingInitial(false);
            }
        }
    }, [t, fetchError]); // Dependencias: t, fetchError

    // Efecto para la carga inicial y limpieza al desmontar
    useEffect(() => {
        isMountedRef.current = true;
        fetchItems(true); // Carga inicial
        return () => {
            isMountedRef.current = false;
            if (pollingTimeoutRef.current) {
                clearTimeout(pollingTimeoutRef.current);
            }
        };
    }, [fetchItems]); // Solo depende de fetchItems para la carga inicial

    // Efecto para el polling
    useEffect(() => {
        if (pollingTimeoutRef.current) {
            clearTimeout(pollingTimeoutRef.current);
        }
        // Condiciones para activar el polling
        if (!isLoadingInitial && !fetchError && !markingItemId && isMountedRef.current) {
            pollingTimeoutRef.current = window.setTimeout(() => {
                // console.log(`[useWaiterPickupItems] Polling for new items...`);
                fetchItems(false);
            }, POLLING_INTERVAL_MS);
        }
        // Funci√≥n de limpieza para este efecto espec√≠fico (se ejecuta si las dependencias cambian o al desmontar)
        return () => {
            if (pollingTimeoutRef.current) {
                clearTimeout(pollingTimeoutRef.current);
            }
        };
    }, [items, isLoadingInitial, fetchError, markingItemId, fetchItems]); // Dependencias que reinician el polling

    // handleMarkAsServed: Marca un √≠tem como servido
    const handleMarkAsServed = async (orderItemId: string): Promise<void> => {
        if (markingItemId) { // Prevenir acciones concurrentes
            notifications.show({
                title: t('common.info'),
                message: t('waiterInterface.actionInProgress', 'Por favor, espera a que la acci√≥n actual termine.'),
                color: 'yellow',
            });
            return;
        }

        setMarkingItemId(orderItemId);

        const itemToMark = items.find(it => it.orderItemId === orderItemId);
        const itemNameForNotification =
            (i18n.language === 'es' && itemToMark?.itemNameSnapshot_es)
                ? itemToMark.itemNameSnapshot_es
                : (itemToMark?.itemNameSnapshot_en || itemToMark?.itemNameSnapshot_es || t('common.item', '√çtem'));

        try {
            await markOrderItemAsServed(orderItemId); // Llamada al servicio

            if (isMountedRef.current) {
                notifications.show({ // Notificaci√≥n SIN icono temporalmente
                    title: t('common.success'),
                    message: t('waiterInterface.itemMarkedServedSuccess', { itemName: itemNameForNotification }),
                    color: 'green',
                    // icon: <IconCheck size={18} />, // TEMPORALMENTE COMENTADO
                });
                fetchItems(); // Refrescar la lista para mostrar los cambios
            }
        } catch (err: any) {
            const errorMsg = err.response?.data?.message || err.message || t('waiterInterface.errorMarkingServed', 'Error al marcar el √≠tem como servido.');
            if (isMountedRef.current) {
                notifications.show({ // Notificaci√≥n SIN icono temporalmente
                    title: t('common.error'),
                    message: errorMsg,
                    color: 'red',
                    // icon: <IconX size={18} />, // TEMPORALMENTE COMENTADO
                });
                // console.error(`[useWaiterPickupItems] Error marking item ${orderItemId} as served:`, err);
            }
        } finally {
            if (isMountedRef.current) {
                setMarkingItemId(null);
            }
        }
    };

    return {
        items,
        isLoadingInitial,
        fetchError,
        markingItemId,
        fetchItems,
        handleMarkAsServed,
    };
};


// ====== [140] frontend/src/modules/camarero/pages/OrderStatusPage.tsx ======
// frontend/src/pages/OrderStatusPage.tsx
// Version 1.1.2 (Fix TypeError on items[0] after requesting bill by refetching)

import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useParams, useLocation, Link, useNavigate } from 'react-router-dom';
import axios from 'axios';
import {
    Container, Title, Text, Loader, Alert, Paper, Stack, Group,
    Button, Divider, Badge, List, ThemeIcon, Box
} from '@mantine/core';
import {
    IconAlertCircle, IconClipboardList, IconToolsKitchen, IconChefHat,
    IconCircleCheck, IconCircleX, IconReload, IconArrowLeft, IconShoppingCart,
    IconPlus,
    IconCreditCard
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { notifications } from '@mantine/notifications';

// Tipos para el estado del pedido
export enum OrderItemStatus {
    PENDING_KDS = 'PENDING_KDS', PREPARING = 'PREPARING', READY = 'READY',
    SERVED = 'SERVED', CANCELLED = 'CANCELLED', CANCELLATION_REQUESTED = 'CANCELLATION_REQUESTED',
}
export enum OrderStatus {
    RECEIVED = 'RECEIVED', IN_PROGRESS = 'IN_PROGRESS', PARTIALLY_READY = 'PARTIALLY_READY',
    ALL_ITEMS_READY = 'ALL_ITEMS_READY', COMPLETED = 'COMPLETED', PENDING_PAYMENT = 'PENDING_PAYMENT',
    PAID = 'PAID', CANCELLED = 'CANCELLED', PAYMENT_FAILED = 'PAYMENT_FAILED',
}
export interface PublicOrderItemStatusInfo {
    id: string; menuItemName_es: string | null; menuItemName_en: string | null;
    quantity: number; status: OrderItemStatus;
}
export interface PublicOrderStatusInfo {
    orderId: string; orderNumber: string; orderStatus: OrderStatus;
    items: PublicOrderItemStatusInfo[]; tableIdentifier?: string | null;
    orderNotes?: string | null; createdAt: string;
    isBillRequested?: boolean;
}

const API_BASE_URL_PUBLIC = import.meta.env.VITE_API_BASE_URL_PUBLIC || 'http://localhost:3000/public';
const POLLING_INTERVAL = 10000;
const ACTIVE_ORDER_INFO_KEY_PREFIX = 'loyalpyme_active_order_info_';
const LOCAL_STORAGE_CART_KEY_PREFIX = 'loyalpyme_public_cart_';
const LOCAL_STORAGE_ORDER_NOTES_KEY_PREFIX = 'loyalpyme_public_order_notes_';

const OrderStatusPage: React.FC = () => {
    const { t, i18n } = useTranslation();
    const { orderId, tableIdentifier: tableIdFromParams } = useParams<{ orderId: string; tableIdentifier?: string }>();
    const location = useLocation();
    const navigate = useNavigate();

    const navigationState = location.state as { orderNumber?: string; businessSlug?: string, tableIdentifier?: string } | null;
    const displayOrderNumber = navigationState?.orderNumber || orderId;
    const businessSlugForReturn = navigationState?.businessSlug;
    const currentTableIdentifierForReturn = navigationState?.tableIdentifier || tableIdFromParams || undefined;

    const [orderStatusData, setOrderStatusData] = useState<PublicOrderStatusInfo | null>(null);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const pollingTimeoutRef = useRef<number | null>(null);
    const [isRequestingBill, setIsRequestingBill] = useState<boolean>(false);

    const activeOrderKey = businessSlugForReturn ? `${ACTIVE_ORDER_INFO_KEY_PREFIX}${businessSlugForReturn}${currentTableIdentifierForReturn ? `_${currentTableIdentifierForReturn}` : ''}` : null;

    const isOrderConsideredFinalOrPendingPayment = (status: OrderStatus | undefined): boolean => {
        if (!status) return false;
        return [
            OrderStatus.PAID,
            OrderStatus.CANCELLED,
            OrderStatus.PENDING_PAYMENT,
            OrderStatus.PAYMENT_FAILED
        ].includes(status);
    };

    const canAddMoreItemsToOrder = (status: OrderStatus | undefined): boolean => {
        if (!status) return false;
        return [
            OrderStatus.RECEIVED, OrderStatus.IN_PROGRESS, OrderStatus.PARTIALLY_READY,
            OrderStatus.ALL_ITEMS_READY, OrderStatus.COMPLETED
        ].includes(status);
    };

    const shouldPoll = !isOrderConsideredFinalOrPendingPayment(orderStatusData?.orderStatus) && !loading && !error && !isRequestingBill;

    const fetchOrderStatus = useCallback(async (isInitialFetch = false) => {
        if (!orderId) {
            setError(t('orderStatusPage.error.missingOrderId'));
            if (isInitialFetch) setLoading(false);
            return;
        }
        if (isInitialFetch) {
            setLoading(true);
            setError(null);
        }
        // No mostramos log de fetching si no es inicial para no llenar la consola con el polling
        // console.log(`[OrderStatusPage] Fetching status for order ${orderId}. Initial: ${isInitialFetch}`);
        try {
            const response = await axios.get<PublicOrderStatusInfo>(`${API_BASE_URL_PUBLIC}/order/${orderId}/status`);
            if (response.data) {
                setOrderStatusData(response.data);
                if (error) setError(null); // Limpiar error si el fetch actual es exitoso
            } else {
                // No deber√≠a pasar si la API siempre devuelve algo o un error
                throw new Error(t('orderStatusPage.error.noData'));
            }
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorUnknown');
            setError(msg);
            if (err.response?.status === 404) {
                setOrderStatusData(null);
            }
            console.error(`[OrderStatusPage] Error fetching status for order ${orderId}:`, err);
        } finally {
            if (isInitialFetch) setLoading(false);
        }
    }, [orderId, t, error]); // error como dependencia

    useEffect(() => {
        fetchOrderStatus(true);
    }, [fetchOrderStatus]); // Solo fetchOrderStatus como dependencia para la carga inicial

    useEffect(() => {
        if (shouldPoll) {
            // console.log(`[OrderStatusPage] Setting up polling for order ${orderId}... Interval: ${POLLING_INTERVAL}ms`);
            pollingTimeoutRef.current = window.setTimeout(() => {
                // console.log(`[OrderStatusPage] Polling for order ${orderId}...`);
                fetchOrderStatus(false);
            }, POLLING_INTERVAL);
        } else {
             if (pollingTimeoutRef.current) {
                // console.log(`[OrderStatusPage] Clearing polling timeout (condition not met).`);
                clearTimeout(pollingTimeoutRef.current);
                pollingTimeoutRef.current = null;
            }
        }
        return () => {
            if (pollingTimeoutRef.current) {
                clearTimeout(pollingTimeoutRef.current);
                // console.log(`[OrderStatusPage] Polling timeout cleared on unmount/re-render for order ${orderId}.`);
            }
        };
    }, [orderStatusData, shouldPoll, fetchOrderStatus, orderId]); // A√±adir orderStatusData para que re-eval√∫e shouldPoll

    useEffect(() => {
        if (
            (orderStatusData?.orderStatus === OrderStatus.PAID || orderStatusData?.orderStatus === OrderStatus.CANCELLED) &&
            activeOrderKey &&
            orderStatusData?.orderId === orderId
        ) {
            const storedActiveOrderInfo = localStorage.getItem(activeOrderKey);
            if (storedActiveOrderInfo) {
                try {
                    const parsedInfo = JSON.parse(storedActiveOrderInfo);
                    if (parsedInfo.orderId === orderId) {
                        localStorage.removeItem(activeOrderKey);
                        console.log(`[OrderStatusPage] Active order info for ${orderId} (Key: ${activeOrderKey}) removed from localStorage because order is final.`);
                    }
                } catch(e) {
                    console.error("Error parsing or removing active order info from localStorage:", e);
                }
            }
        }
    }, [orderStatusData?.orderStatus, activeOrderKey, orderId]);

    const getOrderItemStatusInfo = (status: OrderItemStatus): { text: string; color: string; icon: React.ReactNode } => {
        switch (status) {
            case OrderItemStatus.PENDING_KDS: return { text: t('orderStatusPage.itemStatus.pending_kds'), color: 'gray', icon: <IconClipboardList size={16}/> };
            case OrderItemStatus.PREPARING: return { text: t('orderStatusPage.itemStatus.preparing'), color: 'blue', icon: <IconToolsKitchen size={16}/> };
            case OrderItemStatus.READY: return { text: t('orderStatusPage.itemStatus.ready'), color: 'lime', icon: <IconChefHat size={16}/> };
            case OrderItemStatus.SERVED: return { text: t('orderStatusPage.itemStatus.served'), color: 'green', icon: <IconCircleCheck size={16}/> };
            case OrderItemStatus.CANCELLED: return { text: t('orderStatusPage.itemStatus.cancelled'), color: 'red', icon: <IconCircleX size={16}/> };
            case OrderItemStatus.CANCELLATION_REQUESTED: return { text: t('orderStatusPage.itemStatus.cancellation_requested'), color: 'orange', icon: <IconAlertCircle size={16}/> };
            default: return { text: String(t(status as string, status as string)), color: 'gray', icon: <IconClipboardList size={16}/> };
        }
    };

    const getOrderStatusText = (status: OrderStatus): string => {
         return String(t(`orderStatusPage.orderStatus.${status.toLowerCase()}`, status as string));
    };

    const handleStartNewOrder = () => {
        const cartKey = businessSlugForReturn ? `${LOCAL_STORAGE_CART_KEY_PREFIX}${businessSlugForReturn}${currentTableIdentifierForReturn ? `_${currentTableIdentifierForReturn}` : ''}` : null;
        const notesKey = businessSlugForReturn ? `${LOCAL_STORAGE_ORDER_NOTES_KEY_PREFIX}${businessSlugForReturn}${currentTableIdentifierForReturn ? `_${currentTableIdentifierForReturn}` : ''}` : null;

        if (activeOrderKey) localStorage.removeItem(activeOrderKey);
        if (cartKey) localStorage.removeItem(cartKey);
        if (notesKey) localStorage.removeItem(notesKey);
        setOrderStatusData(null);

        if (businessSlugForReturn) {
            navigate(`/m/${businessSlugForReturn}${currentTableIdentifierForReturn ? `/${currentTableIdentifierForReturn}` : ''}`, { replace: true });
        } else {
            navigate('/login', { replace: true });
        }
    };

    const handleRequestBill = async () => {
        if (!orderId || !orderStatusData || isRequestingBill) return;

        setIsRequestingBill(true);
        setError(null);
        console.log(`[OrderStatusPage] Client requesting bill for order ${orderId}`);
        try {
            // La respuesta del backend en este caso no incluye 'items', solo 'id', 'orderNumber', 'status', 'isBillRequested'
            // Por lo tanto, no podemos hacer setOrderStatusData(response.data.order) directamente o perderemos los items.
            // En lugar de eso, solo mostramos la notificaci√≥n y dejamos que el polling actualice el estado completo.
            await axios.post<{order: Pick<PublicOrderStatusInfo, 'orderId' | 'orderNumber' | 'orderStatus' | 'isBillRequested'>}>(
                `${API_BASE_URL_PUBLIC}/order/${orderId}/request-bill`,
                { paymentPreference: undefined }
            );

            notifications.show({
                title: t('common.success'),
                message: t('orderStatusPage.billRequestedSuccess'),
                color: 'green',
                icon: <IconCircleCheck />
            });
            // ---- CORRECCI√ìN: Forzar un refetch despu√©s de la acci√≥n exitosa ----
            // Esto asegura que la UI se actualice con el nuevo estado del pedido (incluyendo items)
            // y el polling se re-eval√∫e correctamente.
            fetchOrderStatus(false);
            // ---- FIN CORRECCI√ìN ----

        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorUnknown');
            setError(msg);
            notifications.show({
                title: t('common.error'),
                message: t('orderStatusPage.errorRequestingBill', { message: msg }),
                color: 'red',
                icon: <IconAlertCircle />
            });
            console.error(`[OrderStatusPage] Error requesting bill for order ${orderId}:`, err);
        } finally {
            setIsRequestingBill(false);
        }
    };

    if (loading && !orderStatusData) {
        return (
            <Container size="sm" py="xl" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: 'calc(100vh - 60px)' }}>
                <Loader size="xl" />
            </Container>
        );
    }

    if (error && !orderStatusData) {
        return (
            <Container size="sm" py="xl">
                <Alert icon={<IconAlertCircle size="1rem" />} title={t('common.error')} color="red" radius="md">
                    {error}
                </Alert>
                {businessSlugForReturn && (
                    <Button
                        component={Link}
                        to={`/m/${businessSlugForReturn}${currentTableIdentifierForReturn ? `/${currentTableIdentifierForReturn}`: ''}`}
                        variant="light" mt="lg" leftSection={<IconArrowLeft size={16}/>}>
                        {t('orderStatusPage.backToMenuButton')}
                    </Button>
                )}
                 {!businessSlugForReturn && (
                    <Button
                        onClick={() => navigate('/login')}
                        variant="light" mt="lg" leftSection={<IconArrowLeft size={16}/>}>
                        {t('common.back')}
                    </Button>
                 )}
            </Container>
        );
    }

    if (!orderStatusData) { // Ya no necesitamos && !loading aqu√≠
        return (
            <Container size="sm" py="xl">
                <Text ta="center" c="dimmed">{t('orderStatusPage.error.notFound')}</Text>
                {businessSlugForReturn && (
                     <Group justify="center" mt="xl">
                        <Button
                            component={Link}
                            to={`/m/${businessSlugForReturn}${currentTableIdentifierForReturn ? `/${currentTableIdentifierForReturn}`: ''}`}
                            variant="outline" leftSection={<IconArrowLeft size={16}/>}>
                            {t('orderStatusPage.backToMenuButton')}
                        </Button>
                    </Group>
                )}
                 {!businessSlugForReturn && (
                     <Group justify="center" mt="xl">
                        <Button
                            onClick={() => navigate('/login')}
                            variant="outline" leftSection={<IconArrowLeft size={16}/>}>
                            {t('common.back')}
                        </Button>
                    </Group>
                 )}
            </Container>
        );
    }

    const { orderNumber, orderStatus, items, tableIdentifier: orderTableIdentifier, orderNotes: generalOrderNotes, createdAt } = orderStatusData;
    const isCurrentOrderEffectivelyFinal = isOrderConsideredFinalOrPendingPayment(orderStatus);
    const showAddMoreItemsButton = !isCurrentOrderEffectivelyFinal && canAddMoreItemsToOrder(orderStatus);

    const canRequestBill =
        !isRequestingBill &&
        (
            orderStatus === OrderStatus.RECEIVED ||
            orderStatus === OrderStatus.IN_PROGRESS ||
            orderStatus === OrderStatus.PARTIALLY_READY ||
            orderStatus === OrderStatus.ALL_ITEMS_READY ||
            orderStatus === OrderStatus.COMPLETED
        );

    return (
        <Container size="md" py="xl">
            <Paper shadow="md" p="xl" radius="lg" withBorder>
                <Stack gap="lg">
                    <Title order={2} ta="center">{t('orderStatusPage.title')}</Title>
                    <Text ta="center" fz="xl" fw={700}>#{orderNumber || displayOrderNumber}</Text>

                    {error && !loading && (
                        <Alert icon={<IconAlertCircle size="1rem" />} title={t('common.error')} color="orange" radius="md" withCloseButton onClose={() => setError(null)}>
                            {String(t('orderStatusPage.error.updateFailed', { message: error }))}
                        </Alert>
                    )}

                    <Paper withBorder p="md" radius="sm" bg={i18n.language === 'dark' ? "dark.6" : "gray.0"}>
                        <Group justify="space-between">
                            <Text fw={500}>{t('orderStatusPage.generalStatus')}</Text>
                            <Badge size="lg"
                                // ---- CORRECCI√ìN AQU√ç para la guarda de items[0] ----
                                color={getOrderItemStatusInfo( (items && items.length > 0 ? items[0]?.status : undefined) || OrderItemStatus.PENDING_KDS).color}
                                variant="filled"
                            >
                                {getOrderStatusText(orderStatus)}
                            </Badge>
                        </Group>
                        {orderTableIdentifier && (
                            <Text size="sm" mt="xs">
                                {t('orderStatusPage.table')} <Text span fw={500}>{orderTableIdentifier}</Text>
                            </Text>
                        )}
                        <Text size="sm" c="dimmed" mt="xs">
                            {t('orderStatusPage.placedAt')} {new Date(createdAt).toLocaleString(i18n.language, { dateStyle: 'medium', timeStyle: 'short' })}
                        </Text>
                    </Paper>

                    <Divider my="sm" label={t('orderStatusPage.itemsTitle')} labelPosition="center" />

                    <Box>
                        {items.length === 0 ? (
                            <Text c="dimmed" ta="center">{t('publicMenu.noItemsInCategory')}</Text>
                        ) : (
                            <List spacing="md" listStyleType="none" p={0}>
                                {items.map((item: PublicOrderItemStatusInfo) => { // <-- Tipo expl√≠cito aqu√≠
                                    const statusInfo = getOrderItemStatusInfo(item.status);
                                    const itemName = (i18n.language === 'es' && item.menuItemName_es) ? item.menuItemName_es : (item.menuItemName_en || item.menuItemName_es || '√çtem');
                                    return (
                                        <List.Item
                                            key={item.id}
                                            icon={
                                                <ThemeIcon color={statusInfo.color} size={24} radius="xl">
                                                    {statusInfo.icon}
                                                </ThemeIcon>
                                            }
                                        >
                                            <Paper p="sm" radius="sm" withBorder style={{ flexGrow: 1 }}>
                                                <Group justify="space-between" wrap="nowrap">
                                                    <Stack gap={2} style={{flexGrow: 1, minWidth: 0}}>
                                                        <Text fw={500} truncate>{itemName}</Text>
                                                        <Text size="sm" c="dimmed">{t('orderStatusPage.quantity')} {item.quantity}</Text>
                                                    </Stack>
                                                    <Text size="sm" c={statusInfo.color} style={{flexShrink: 0}}>{statusInfo.text}</Text>
                                                </Group>
                                            </Paper>
                                        </List.Item>
                                    );
                                })}
                            </List>
                        )}
                    </Box>

                    {generalOrderNotes && (
                        <>
                            <Divider my="sm" label={t('orderStatusPage.orderNotesLabel')} labelPosition="center" />
                            <Paper withBorder p="sm" radius="sm" bg={i18n.language === 'dark' ? "dark.6" : "gray.0"}>
                                <Text size="sm" style={{ whiteSpace: 'pre-wrap' }}>{generalOrderNotes}</Text>
                            </Paper>
                        </>
                    )}

                    <Group justify="space-between" mt="xl" wrap="nowrap">
                        <Group>
                            {showAddMoreItemsButton && businessSlugForReturn && (
                                <Button
                                    component={Link}
                                    to={`/m/${businessSlugForReturn}${currentTableIdentifierForReturn ? `/${currentTableIdentifierForReturn}` : ''}`}
                                    variant="filled"
                                    leftSection={<IconPlus size={16} />}
                                    mr="sm"
                                >
                                    {t('orderStatusPage.addMoreItemsButton')}
                                </Button>
                            )}

                            {canRequestBill && (
                                <Button
                                    variant="gradient"
                                    gradient={{ from: 'orange', to: 'yellow' }}
                                    onClick={handleRequestBill}
                                    loading={isRequestingBill}
                                    disabled={isRequestingBill || loading}
                                    leftSection={<IconCreditCard size={16} />}
                                    mr="sm"
                                >
                                    {t('orderStatusPage.requestBillButton')}
                                </Button>
                            )}

                            {!isCurrentOrderEffectivelyFinal && !canRequestBill && (
                                <Button
                                    variant="outline"
                                    onClick={() => fetchOrderStatus(false)}
                                    leftSection={<IconReload size={16}/>}
                                    loading={loading && !!orderStatusData && !isRequestingBill}
                                    disabled={isRequestingBill || (loading && !orderStatusData)}
                                >
                                    {t('orderStatusPage.refreshButton')}
                                </Button>
                            )}

                            {(orderStatus === OrderStatus.PAID || orderStatus === OrderStatus.CANCELLED) && (
                                <Button
                                    variant="filled"
                                    color="green"
                                    onClick={handleStartNewOrder}
                                    leftSection={<IconShoppingCart size={16} />}
                                >
                                    {t('publicMenu.activeOrder.startNewButton')}
                                </Button>
                            )}
                        </Group>

                        {businessSlugForReturn ? (
                            <Button
                                component={Link}
                                to={`/m/${businessSlugForReturn}${currentTableIdentifierForReturn ? `/${currentTableIdentifierForReturn}`: ''}`}
                                variant="light"
                                leftSection={<IconArrowLeft size={16}/>}
                            >
                                {t('orderStatusPage.backToMenuButton')}
                            </Button>
                        ) : (
                             <Button
                                 onClick={() => navigate('/login')}
                                 variant="light"
                                 leftSection={<IconArrowLeft size={16}/>}
                             >
                                 {t('common.back')}
                             </Button>
                         )}
                    </Group>
                </Stack>
            </Paper>
        </Container>
    );
};

export default OrderStatusPage;


// ====== [141] frontend/src/modules/camarero/pages/PublicMenuViewPage.tsx ======
// frontend/src/pages/PublicMenuViewPage.tsx
// Version 2.2.0 (Refactored to use usePublicMenuData hook)

import React, { useState, useEffect } from 'react';
import { useParams, useNavigate, Link } from 'react-router-dom';
import {
    Container, Title, Loader, Alert, Text, Stack, Paper, Image, Group,
    useMantineTheme, Button, useMantineColorScheme
} from '@mantine/core';
import {
    IconAlertCircle, IconShoppingCart, IconCheck, IconInfoCircle
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { notifications } from '@mantine/notifications';
import { useDisclosure } from '@mantine/hooks';

// Tipos
import { SelectedModifierFE } from '../types/publicOrder.types';

// Componentes
import CategoryAccordion from '../components/public/menu/CategoryAccordion';
import { MenuItemCardConfiguringState } from '../components/public/menu/MenuItemCard';
import ShoppingCartModal from '../components/public/menu/ShoppingCartModal';

// Hooks
import { useActiveOrderState } from '../hooks/useActiveOrderState';
import { usePublicOrderCart } from '../hooks/usePublicOrderCart';
import { useMenuItemConfigurator } from '../hooks/useMenuItemConfigurator';
import { usePublicMenuData } from '../hooks/usePublicMenuData'; // <-- NUEVA IMPORTACI√ìN

// Servicio
import { handleOrderSubmission } from '../services/publicOrderApiService';


const PublicMenuViewPage: React.FC = () => {
    const { t, i18n } = useTranslation();
    const theme = useMantineTheme();
    const { colorScheme } = useMantineColorScheme();
    const { businessSlug, tableIdentifier: tableIdentifierFromParams } = useParams<{ businessSlug: string; tableIdentifier?: string }>();
    const navigate = useNavigate();

    // --- L√ìGICA DE DATOS AHORA CENTRALIZADA EN HOOKS ---
    const { menuData, loadingMenu, errorMenu } = usePublicMenuData(businessSlug);
    const {
        activeOrderId, activeOrderNumber, canCurrentlyAddToExistingOrder,
        loadingActiveOrderStatus, clearActiveOrder, setActiveOrderManually,
    } = useActiveOrderState(businessSlug, tableIdentifierFromParams);
    const {
        currentOrderItems, orderNotes, totalCartItems, totalCartAmount,
        addItemToCart, addSimpleItemToCart, updateItemQuantityInCart,
        removeItemFromCart, updateOrderNotes, clearCart, clearCartStorage,
    } = usePublicOrderCart(businessSlug, tableIdentifierFromParams, activeOrderId);
    const {
        configuringItem, startConfiguringItem, cancelConfiguration,
        updateConfigQuantity, updateConfigModifierSelection, updateConfigNotes,
    } = useMenuItemConfigurator();
    
    // --- ESTADO LOCAL SOLO PARA LA UI ---
    const [activeAccordionItems, setActiveAccordionItems] = useState<string[]>([]);
    const [isCartOpen, { open: openCart, close: closeCart }] = useDisclosure(false);
    const [isSubmittingOrder, setIsSubmittingOrder] = useState(false);

    // Efecto para abrir la primera categor√≠a del men√∫ (ahora depende de menuData)
    useEffect(() => {
        if (menuData && menuData.categories.length > 0 && !activeOrderId) {
            setActiveAccordionItems([menuData.categories[0].id]);
        } else if (activeOrderId) {
            setActiveAccordionItems([]);
        }
    }, [menuData, activeOrderId]);

    // L√≥gica para a√±adir √≠tem configurado al carrito (sin cambios)
    const handleConfiguredItemAddToCart = () => {
        if (!configuringItem) return;
        const { itemDetails, quantity, selectedOptionsByGroup, currentUnitPrice, itemNotes, areModifiersValid } = configuringItem;
        if (!areModifiersValid) {
            notifications.show({ title: t('publicMenu.invalidSelectionTitle'), message: t('publicMenu.invalidSelectionMsg'), color: 'orange' });
            return;
        }
        const flatSelectedModifiers: SelectedModifierFE[] = [];
        if (Array.isArray(itemDetails.modifierGroups)) {
            Object.entries(selectedOptionsByGroup).forEach(([groupId, optionSelections]) => {
                const group = itemDetails.modifierGroups!.find(g => g.id === groupId);
                if (!group || !Array.isArray(group.options)) return;
                const ids = Array.isArray(optionSelections) ? optionSelections.filter(s => s && s.trim() !== '') : ((typeof optionSelections === 'string' && optionSelections.trim() !== '') ? [optionSelections.trim()] : []);
                ids.forEach(optId => {
                    const option = group.options.find(o => o.id === optId);
                    if (option) { flatSelectedModifiers.push({ modifierOptionId: option.id, name_es: option.name_es, name_en: option.name_en, priceAdjustment: option.priceAdjustment, modifierGroupName_es: group.name_es, modifierGroupName_en: group.name_en }); }
                });
            });
        }
        const sortedModifierOptionIds = flatSelectedModifiers.map(m => m.modifierOptionId).sort().join(',');
        const notesHash = itemNotes ? `_notes-${itemNotes.toLocaleLowerCase().replace(/\s/g, '')}` : '';
        const cartItemId = `${itemDetails.id}${flatSelectedModifiers.length > 0 ? `-[${sortedModifierOptionIds}]` : ''}${notesHash}`;
        addItemToCart({ cartItemId, menuItemId: itemDetails.id, menuItemName_es: itemDetails.name_es, menuItemName_en: itemDetails.name_en, quantity, basePrice: itemDetails.price, currentPricePerUnit: currentUnitPrice, totalPriceForItem: currentUnitPrice * quantity, notes: itemNotes || undefined, selectedModifiers: flatSelectedModifiers });
        cancelConfiguration();
    };

    // L√≥gica de env√≠o de pedido (sin cambios)
    const handleSubmitOrderOrAddItems = async () => {
        if (currentOrderItems.length === 0) {
            notifications.show({ title: t('publicMenu.cart.errorTitle'), message: activeOrderId ? t('publicMenu.cart.errorEmptyAddToOrder') : t('publicMenu.cart.errorEmpty'), color: 'orange' });
            return;
        }
        if (!businessSlug) {
            notifications.show({ title: t('common.error'), message: t('error.missingBusinessSlug'), color: 'red' });
            return;
        }
        setIsSubmittingOrder(true);
        try {
            const response = await handleOrderSubmission(
                currentOrderItems,
                orderNotes,
                canCurrentlyAddToExistingOrder ? activeOrderId : null,
                businessSlug,
                tableIdentifierFromParams
            );
            const orderIdToNavigate = response.id;
            const orderNumberToNavigate = response.orderNumber || activeOrderNumber || orderIdToNavigate;
            const successMessage = activeOrderId
                ? t('publicMenu.cart.itemsAddedSuccessMsg', { orderNumber: orderNumberToNavigate })
                : t('publicMenu.cart.orderSuccessMsg', { orderNumber: orderNumberToNavigate });
            notifications.show({
                title: activeOrderId ? t('publicMenu.cart.itemsAddedSuccessTitle') : t('publicMenu.cart.orderSuccessTitle'),
                message: successMessage,
                color: 'green',
                icon: <IconCheck />
            });
            if (!activeOrderId) {
                setActiveOrderManually(orderIdToNavigate, orderNumberToNavigate);
            }
            clearCart();
            clearCartStorage();
            closeCart();
            navigate(`/order-status/${orderIdToNavigate}`, {
                state: { orderNumber: orderNumberToNavigate, businessSlug, tableIdentifier: tableIdentifierFromParams }
            });
        } catch (err: any) {
            const errMsg = err.response?.data?.message || err.message || t('publicMenu.cart.orderErrorMsg');
            notifications.show({
                title: t('publicMenu.cart.orderErrorTitle'),
                message: errMsg,
                color: 'red',
                icon: <IconAlertCircle />
            });
        } finally {
            setIsSubmittingOrder(false);
        }
    };

    // El resto del componente (renderizado) permanece sin cambios...
    const isLoadingPage = loadingMenu || loadingActiveOrderStatus;
    const pageError = errorMenu;

    if (isLoadingPage) {
        return ( <Container size="md" py="xl" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '80vh' }}><Loader size="xl" /></Container> );
    }
    if (pageError) {
        return ( <Container size="md" py="xl"><Alert icon={<IconAlertCircle size="1rem" />} title={t('common.error')} color="red" radius="md">{pageError}</Alert></Container> );
    }
    if (!menuData) {
        return ( <Container size="md" py="xl"><Text ta="center" c="dimmed">{t('publicMenu.menuNotAvailable')}</Text></Container> );
    }
    const menuItemCardConfigState: MenuItemCardConfiguringState | null = configuringItem;
    const topOffsetForCartBar = typeof theme.spacing.md === 'number' ? theme.spacing.md + 10 : 26;
    const cartButtonText = activeOrderId && canCurrentlyAddToExistingOrder ? t('publicMenu.cart.addItemsToOrderButton', { count: totalCartItems, orderNumber: activeOrderNumber }) : t('publicMenu.cart.viewOrderItems', { count: totalCartItems });

    return (
        <>
            <Container size="lg" py="xl">
                <Stack gap="xl">
                    <Group justify="center" align="center" wrap="nowrap">
                        {menuData.businessLogoUrl && ( <Image src={menuData.businessLogoUrl} alt={`${menuData.businessName} logo`} h={50} w="auto" fit="contain" radius="sm" /> )}
                        <Title order={1} ta="center" style={{ flexShrink: 1, minWidth: 0 }}>{menuData.businessName}</Title>
                    </Group>
                    {activeOrderId && canCurrentlyAddToExistingOrder && !configuringItem && (
                        <Paper shadow="md" p="lg" radius="md" withBorder mb="xl" bg={colorScheme === 'dark' ? theme.colors.dark[5] : theme.colors.blue[0]}>
                            <Group justify="space-between" align="center">
                                <Group><IconInfoCircle size={24} color={theme.colors.blue[6]} /><Stack gap={0}>
                                    <Text fw={500}>{t('publicMenu.activeOrder.addingToOrderTitle', {orderNumber: activeOrderNumber})}</Text>
                                    <Text size="sm">{t('publicMenu.activeOrder.addingToOrderMsg')}</Text>
                                </Stack></Group>
                                <Button variant="outline" size="xs" component={Link} to={`/order-status/${activeOrderId}`} state={{ orderNumber: activeOrderNumber, businessSlug, tableIdentifier: tableIdentifierFromParams }}>
                                    {t('publicMenu.activeOrder.viewStatusButton')}
                                </Button>
                            </Group>
                        </Paper>
                    )}
                    {activeOrderId && !canCurrentlyAddToExistingOrder && !loadingActiveOrderStatus && !configuringItem && (
                         <Paper shadow="md" p="lg" radius="md" withBorder mb="xl" bg={colorScheme === 'dark' ? theme.colors.dark[5] : theme.colors.gray[0]}>
                            <Group justify="space-between" align="center">
                                 <Group><IconAlertCircle size={24} color={theme.colors.orange[6]} /><Stack gap={0}>
                                    <Text fw={500}>{t('publicMenu.activeOrder.cannotAddTitle', {orderNumber: activeOrderNumber})}</Text>
                                    <Text size="sm">{t('publicMenu.activeOrder.cannotAddMsg')}</Text>
                                </Stack></Group>
                                <Button variant="outline" size="xs" onClick={clearActiveOrder}>
                                    {t('publicMenu.activeOrder.startNewButtonAlt')}
                                </Button>
                            </Group>
                        </Paper>
                    )}
                    {totalCartItems > 0 && (!activeOrderId || (activeOrderId && canCurrentlyAddToExistingOrder)) && !configuringItem && (
                        <Paper p={0} shadow="xs" withBorder={false} radius="md" style={{ position: 'sticky', top: topOffsetForCartBar, zIndex: 200 }} >
                            <Button fullWidth size="lg" variant="gradient"
                                gradient={{ from: theme.primaryColor, to: theme.colors[theme.primaryColor][4], deg: 105 }}
                                onClick={openCart}
                                disabled={isCartOpen}
                                styles={{ root: { height: 'auto', padding: `${theme.spacing.sm} ${theme.spacing.md}` }, label: { width: '100%' } }}
                            >
                                <Group justify="space-between" style={{ width: '100%' }}>
                                    <Group gap="xs"><IconShoppingCart size={22} stroke={1.8} /><Text fw={500} inherit> {cartButtonText} </Text></Group>
                                    <Text fw={700} inherit>{t('publicMenu.cart.total')}: {totalCartAmount.toLocaleString(i18n.language, { style: 'currency', currency: 'EUR' })}</Text>
                                </Group>
                            </Button>
                        </Paper>
                    )}
                    <CategoryAccordion
                        categories={menuData.categories}
                        activeAccordionItems={activeAccordionItems}
                        onAccordionChange={setActiveAccordionItems}
                        configuringItemId={configuringItem?.itemDetails.id || null}
                        configuringItemState={menuItemCardConfigState}
                        onStartConfigureItem={startConfiguringItem}
                        onCancelConfiguration={cancelConfiguration}
                        onConfigQuantityChange={updateConfigQuantity}
                        onConfigModifierSelectionChange={updateConfigModifierSelection}
                        onConfigNotesChange={updateConfigNotes}
                        onConfigAddToCart={handleConfiguredItemAddToCart}
                        onSimpleAddToCart={addSimpleItemToCart}
                    />
                </Stack>
            </Container>
            {(!activeOrderId || (activeOrderId && canCurrentlyAddToExistingOrder)) && (
                <ShoppingCartModal
                    opened={isCartOpen} onClose={closeCart}
                    orderItems={currentOrderItems} orderNotes={orderNotes}
                    onUpdateItemQuantity={updateItemQuantityInCart} onRemoveItem={removeItemFromCart}
                    onUpdateOrderNotes={updateOrderNotes} onSubmitOrder={handleSubmitOrderOrAddItems}
                    isSubmittingOrder={isSubmittingOrder} onClearCart={clearCart}
                    isAddingToExistingOrder={!!(activeOrderId && canCurrentlyAddToExistingOrder)}
                    activeOrderNumber={activeOrderNumber}
                />
            )}
        </>
    );
};

export default PublicMenuViewPage;


// ====== [142] frontend/src/modules/camarero/pages/admin/camarero/KitchenDisplayPage.tsx ======
// frontend/src/pages/admin/camarero/KitchenDisplayPage.tsx
// Version: 1.1.0 (Add action buttons for KDS item status update)

import React, { useState, useEffect, useCallback, useRef } from 'react';
import {
    Container,
    Title,
    Text,
    Loader,
    Alert,
    Paper,
    List,
    Stack,
    Group,
    Badge,
    SegmentedControl,
    Box,
    Button,
} from '@mantine/core';
import { 
    IconAlertCircle, 
    IconReload,
    IconCheck, // A√±adido para notificaciones
    //IconX,     // A√±adido para notificaciones
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { 
    KdsListItem, 
    getItemsForKds, 
    updateOrderItemKdsStatus // Importar funci√≥n de actualizaci√≥n
} from '../../../services/kdsService'; 
import { OrderItemStatus } from '../../OrderStatusPage'; // Usar enum existente
import { notifications } from '@mantine/notifications'; // Importar notificaciones

// Configuraci√≥n
const DEFAULT_KDS_DESTINATION = 'COCINA';
const POLLING_INTERVAL_MS = 15000; 

const KitchenDisplayPage: React.FC = () => {
    const { t, i18n } = useTranslation();
    const [items, setItems] = useState<KdsListItem[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [currentDestination, setCurrentDestination] = useState<string>(DEFAULT_KDS_DESTINATION);
    
    const pollingTimeoutRef = useRef<number | null>(null);
    const [updatingItemId, setUpdatingItemId] = useState<string | null>(null);

    const fetchKdsItems = useCallback(async (isInitialFetch = false) => {
        if (isInitialFetch) {
            setLoading(true);
            setError(null);
        }
        console.log(`[KDS Page] Fetching items for destination: ${currentDestination}. Initial: ${isInitialFetch}`);
        try {
            const fetchedItems = await getItemsForKds(currentDestination, [
                OrderItemStatus.PENDING_KDS,
                OrderItemStatus.PREPARING,
            ]);
            setItems(fetchedItems);
            if (error && !isInitialFetch) setError(null); 
        } catch (err: any) {
            const errMsg = err.response?.data?.message || err.message || t('common.errorFetchingData');
            setError(errMsg);
            console.error(`[KDS Page] Error fetching KDS items for ${currentDestination}:`, err);
        } finally {
            if (isInitialFetch) {
                setLoading(false);
            }
        }
    }, [currentDestination, t, error]);

    useEffect(() => {
        fetchKdsItems(true); 
    }, [fetchKdsItems]); 

    useEffect(() => {
        if (pollingTimeoutRef.current) {
            clearTimeout(pollingTimeoutRef.current);
        }
        if (!updatingItemId) { // Solo hacer polling si no hay una actualizaci√≥n en curso
            pollingTimeoutRef.current = window.setTimeout(() => {
                console.log(`[KDS Page] Polling for destination: ${currentDestination}...`);
                fetchKdsItems(false); 
            }, POLLING_INTERVAL_MS);
        } else {
            console.log(`[KDS Page] Polling paused due to item update in progress.`);
        }

        return () => {
            if (pollingTimeoutRef.current) {
                clearTimeout(pollingTimeoutRef.current);
                console.log(`[KDS Page] Polling timeout cleared for ${currentDestination}.`);
            }
        };
    }, [items, fetchKdsItems, currentDestination, updatingItemId]); // A√±adir updatingItemId a las dependencias

    const getItemName = (item: KdsListItem | undefined): string => {
        if (!item) return t('kdsPage.unknownItem', '√çtem Desconocido');
        return (i18n.language === 'es' && item.menuItemName_es) ? item.menuItemName_es : (item.menuItemName_en || item.menuItemName_es || t('kdsPage.unknownItem', '√çtem Desconocido'));
    };

    const getOrderItemDisplayInfo = (status: OrderItemStatus): { textKey: string; color: string } => {
        switch (status) {
            case OrderItemStatus.PENDING_KDS: return { textKey: 'orderStatusPage.itemStatus.pending_kds', color: 'gray' };
            case OrderItemStatus.PREPARING: return { textKey: 'orderStatusPage.itemStatus.preparing', color: 'blue' };
            case OrderItemStatus.READY: return { textKey: 'orderStatusPage.itemStatus.ready', color: 'lime' };
            case OrderItemStatus.SERVED: return { textKey: 'orderStatusPage.itemStatus.served', color: 'green' };
            case OrderItemStatus.CANCELLED: return { textKey: 'orderStatusPage.itemStatus.cancelled', color: 'red' };
            case OrderItemStatus.CANCELLATION_REQUESTED: return { textKey: 'orderStatusPage.itemStatus.cancellation_requested', color: 'orange' };
            default: return { textKey: String(status), color: 'gray' };
        }
    };

    const handleUpdateStatus = async (itemId: string, newStatus: OrderItemStatus) => {
        if (updatingItemId) {
            notifications.show({
                title: t('kdsPage.updateInProgressTitle', 'Actualizaci√≥n en Progreso'),
                message: t('kdsPage.updateInProgressMsg', 'Espera a que finalice la acci√≥n actual.'),
                color: 'yellow'
            });
            return;
        }

        const itemBeingUpdated = items.find(i => i.id === itemId);
        const itemNameForNotif = getItemName(itemBeingUpdated);
        const newStatusText = t(`orderStatusPage.itemStatus.${newStatus.toLowerCase()}`, newStatus);

        setUpdatingItemId(itemId);
        try {
            await updateOrderItemKdsStatus(itemId, newStatus);
            notifications.show({
                title: t('kdsPage.statusUpdateSuccessTitle', 'Estado Actualizado'),
                message: t('kdsPage.statusUpdateSuccessMsg', { itemName: itemNameForNotif , status: newStatusText }),
                color: 'green',
                icon: <IconCheck size={18} />
            });
            await fetchKdsItems(false); 
        } catch (err: any) {
            const errorMsg = err.response?.data?.message || err.message || t('kdsPage.statusUpdateErrorMsg', 'Error al actualizar estado');
            notifications.show({
                title: t('common.error'),
                message: errorMsg,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
            console.error(`[KDS Page] Error updating status for item ${itemId} to ${newStatus}:`, err);
        } finally {
            setUpdatingItemId(null);
        }
    };

    if (loading && items.length === 0) { 
        return <Container style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}><Loader size="xl" /></Container>;
    }

    return (
        <Container fluid p="md">
            <Stack gap="lg">
                <Title order={2} ta="center">{t('kdsPage.title', 'Pantalla de Cocina (KDS)')} - {currentDestination}</Title>

                <SegmentedControl
                    value={currentDestination}
                    onChange={(value) => {
                        if (pollingTimeoutRef.current) clearTimeout(pollingTimeoutRef.current);
                        setCurrentDestination(value);
                        setItems([]); 
                    }}
                    data={[
                        { label: t('kdsPage.destination.kitchen', 'COCINA'), value: 'COCINA' },
                        { label: t('kdsPage.destination.bar', 'BARRA'), value: 'BARRA' },
                    ]}
                    fullWidth
                    mb="md"
                />

                {error && (
                    <Alert icon={<IconAlertCircle size="1rem" />} title={t('common.error')} color="red" withCloseButton onClose={() => setError(null)}>
                        {error}
                    </Alert>
                )}

                {items.length === 0 && !loading && !error && (
                    <Paper p="xl" shadow="xs" withBorder>
                        <Text ta="center" c="dimmed">{t('kdsPage.noItems', 'No hay √≠tems pendientes para este destino.')}</Text>
                    </Paper>
                )}

                {items.length > 0 && (
                    <List spacing="sm" listStyleType="none">
                        {items.map((item) => {
                            const displayInfo = getOrderItemDisplayInfo(item.status);
                            const isThisItemUpdating = updatingItemId === item.id;
                            const disableOtherItemsActions = !!updatingItemId && !isThisItemUpdating;

                            return (
                                <List.Item key={item.id}>
                                    <Paper withBorder p="md" radius="sm" shadow="xs">
                                        <Group justify="space-between">
                                            <Stack gap={0}>
                                                <Text fw={500} size="lg">{getItemName(item)}</Text>
                                                <Text size="sm" c="dimmed">{t('kdsPage.quantity', 'Cantidad')}: {item.quantity}</Text>
                                                {item.notes && <Text size="xs" c="orange">{t('kdsPage.notes', 'Notas')}: {item.notes}</Text>}
                                                <Text size="xs" c="dimmed">#{item.orderInfo.orderNumber} ({item.orderInfo.tableIdentifier || t('kdsPage.noTable', 'Sin Mesa')})</Text>
                                                 <Text size="xs" c="dimmed">{t('kdsPage.createdAt', 'Recibido KDS')}: {new Date(item.orderInfo.createdAt).toLocaleTimeString(i18n.language, { hour: '2-digit', minute: '2-digit' })}</Text>
                                            </Stack>
                                            <Badge color={displayInfo.color} variant="filled">
                                                {t(displayInfo.textKey, item.status)}
                                            </Badge>
                                        </Group>
                                        {item.selectedModifiers && item.selectedModifiers.length > 0 && (
                                            <Box mt="xs" pl="sm" style={{ borderLeft: '2px solid #ccc', marginLeft: '4px'}}>
                                                <Text size="xs" fw={500} mb={2}>{t('kdsPage.modifiers', 'Modificadores:')}</Text>
                                                <List listStyleType="disc" size="xs" c="dimmed" spacing={2}>
                                                    {item.selectedModifiers.map((mod, index) => (
                                                        <List.Item key={index}>
                                                            {(i18n.language === 'es' && mod.optionName_es) ? mod.optionName_es : (mod.optionName_en || mod.optionName_es)}
                                                        </List.Item>
                                                    ))}
                                                </List>
                                            </Box>
                                        )}
                                        <Group justify="flex-end" mt="md">
                                            {item.status === OrderItemStatus.PENDING_KDS && (
                                                <Button
                                                    size="xs"
                                                    color="blue"
                                                    onClick={() => handleUpdateStatus(item.id, OrderItemStatus.PREPARING)}
                                                    loading={isThisItemUpdating}
                                                    disabled={disableOtherItemsActions}
                                                >
                                                    {t('kdsPage.action.startPreparing', 'Empezar Preparaci√≥n')}
                                                </Button>
                                            )}
                                            {item.status === OrderItemStatus.PREPARING && (
                                                <Button
                                                    size="xs"
                                                    color="green"
                                                    onClick={() => handleUpdateStatus(item.id, OrderItemStatus.READY)}
                                                    loading={isThisItemUpdating}
                                                    disabled={disableOtherItemsActions}
                                                >
                                                    {t('kdsPage.action.markReady', 'Marcar como Listo')}
                                                </Button>
                                            )}
                                            {(item.status === OrderItemStatus.PENDING_KDS || item.status === OrderItemStatus.PREPARING) && (
                                                <Button
                                                    size="xs"
                                                    color="red"
                                                    variant="outline"
                                                    onClick={() => handleUpdateStatus(item.id, OrderItemStatus.CANCELLED)}
                                                    loading={isThisItemUpdating}
                                                    disabled={disableOtherItemsActions}
                                                >
                                                    {t('kdsPage.action.cancelItem', 'Cancelar √çtem')}
                                                </Button>
                                            )}
                                        </Group>
                                    </Paper>
                                </List.Item>
                            );
                        })}
                    </List>
                )}
                <Group justify="center" mt="md">
                    <Button onClick={() => fetchKdsItems(true)} leftSection={<IconReload size={16}/>} variant="outline" loading={loading && items.length > 0}>
                        {t('kdsPage.refreshManual', 'Refrescar Manualmente')}
                    </Button>
                </Group>
            </Stack>
        </Container>
    );
};

export default KitchenDisplayPage;


// ====== [143] frontend/src/modules/camarero/pages/admin/camarero/MenuManagementPage.tsx ======
// frontend/src/modules/camarero/pages/admin/camarero/MenuManagementPage.tsx (CORREGIDO)
import React, { useState } from 'react';
import { 
    Container, 
    Title, 
    Paper, 
    Stack, 
    Button,
    Group     
} from '@mantine/core';
import { useTranslation } from 'react-i18next';
import { notifications } from '@mantine/notifications'; 
import { IconExternalLink } from '@tabler/icons-react'; 

// --- RUTAS CORREGIDAS ---
import MenuCategoryManager from '../../../../../modules/camarero/components/admin/menu/MenuCategoryManager';
import MenuItemManager from '../../../../../modules/camarero/components/admin/menu/MenuItemManager'; 
import { MenuCategoryData } from '../../../../../modules/camarero/types/menu.types';
import { useLayoutUserData } from '../../../../../shared/hooks/useLayoutUserData'; 
// --- FIN RUTAS CORREGIDAS ---

const MenuManagementPage: React.FC = () => {
    const { t } = useTranslation();
    const [selectedCategory, setSelectedCategory] = useState<MenuCategoryData | null>(null);
    
    const { userData, loadingUser: loadingLayoutUser } = useLayoutUserData();

    const handleViewItems = (category: MenuCategoryData) => {
        setSelectedCategory(category);
    };
    const handleBackToCategories = () => {
        setSelectedCategory(null);
    };

    const handlePreviewMenu = () => {
        if (userData?.businessSlug) {
            window.open(`/m/${userData.businessSlug}`, '_blank');
        } else {
            console.error("[MenuManagementPage] Business slug no disponible para previsualizar el men√∫.");
            notifications.show({
                 title: t('common.error'),
                 message: t('adminCamarero.manageMenu.previewErrorNoSlug'),
                 color: 'red'
            });
        }
    };

    return (
        <Container size="xl" py="xl">
            <Stack gap="lg">
                <Group justify="space-between" align="flex-start">
                    <Title order={2}>
                        {t('adminCamarero.manageMenu.title')}
                    </Title>
                    {userData?.isCamareroActive && !loadingLayoutUser && (
                        <Button
                            variant="outline"
                            leftSection={<IconExternalLink size={16} />}
                            onClick={handlePreviewMenu}
                            disabled={!userData?.businessSlug}
                            title={!userData?.businessSlug ? t('adminCamarero.manageMenu.previewDisabledTooltip') : undefined}
                        >
                            {t('adminCamarero.manageMenu.previewButton')}
                        </Button>
                    )}
                </Group>

                {!selectedCategory ? (
                    <Paper shadow="sm" p="lg" withBorder radius="lg">
                        <Title order={4} mb="md">
                            {t('adminCamarero.manageMenu.categoriesSectionTitle')}
                        </Title>
                        <MenuCategoryManager 
                            onSelectCategoryForItems={handleViewItems}
                        />
                    </Paper>
                ) : (
                    <Paper shadow="sm" p="lg" withBorder radius="lg">
                        <Group justify="space-between" mb="md">
                            <Title order={4}>
                                {t('adminCamarero.manageMenu.itemsSectionTitle')} - {selectedCategory.name_es || selectedCategory.name_en}
                            </Title>
                            <Button variant="outline" onClick={handleBackToCategories}>
                                {t('common.back')} {t('adminCamarero.manageMenu.toCategories')}
                            </Button>
                        </Group>
                        <MenuItemManager 
                            categoryId={selectedCategory.id} 
                        />
                    </Paper>
                )}
            </Stack>
        </Container>
    );
};

export default MenuManagementPage;


// ====== [144] frontend/src/modules/camarero/pages/admin/camarero/WaiterOrderManagementPage.tsx ======
// frontend/src/pages/admin/camarero/WaiterOrderManagementPage.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
    Container,
    Title,
    Text,
    Loader,
    Alert,
    Paper,
    Stack,
    Group,
    Button,
    Table,
    Badge,
    SegmentedControl,
    // Modal, // Para el futuro modal de detalles de pago
    // TextInput, // Para el futuro modal de detalles de pago
} from '@mantine/core';
import {
    IconAlertCircle,
    IconCash, // Para el bot√≥n de "Marcar como Pagado"
    //IconReceipt2, // Para "Pedir Cuenta" (si se a√±ade aqu√≠)
    IconReload,
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX } from '@tabler/icons-react'; // Para notificaciones

// Suponiendo que estos tipos y servicios se crear√°n/adaptar√°n:
import { WaiterOrderListItemDto } from '../../../types/camarero.types'; // Aseg√∫rate que este DTO exista y se importe
import { OrderStatus } from '../../../../../shared/types/user.types'; // Usaremos el enum de OrderStatus
import axiosInstance from '../../../../../shared/services/axiosInstance'; // Para las llamadas API

// Hook para los datos (a√∫n por crear)
// import { useWaiterOrders } from '../../../hooks/useWaiterOrders';

const WaiterOrderManagementPage: React.FC = () => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;

    // Estado para los pedidos
    const [orders, setOrders] = useState<WaiterOrderListItemDto[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [selectedStatusFilter, setSelectedStatusFilter] = useState<string>(OrderStatus.PENDING_PAYMENT); // Filtro inicial
    const [markingPaidOrderId, setMarkingPaidOrderId] = useState<string | null>(null);

    // Opciones para el filtro de estado
    const statusFilterOptions = [
        { label: t('waiterOrderManagement.statusOptionPendingPayment', 'Pendientes de Pago'), value: OrderStatus.PENDING_PAYMENT },
        { label: t('waiterOrderManagement.statusOptionCompleted', 'Completados (No Pagados)'), value: OrderStatus.COMPLETED },
        { label: t('orderStatusPage.orderStatus.all_items_ready', 'Listos para Entregar'), value: OrderStatus.ALL_ITEMS_READY },
        { label: t('orderStatusPage.orderStatus.in_progress', 'En Progreso'), value: OrderStatus.IN_PROGRESS },
        { label: t('orderStatusPage.orderStatus.received', 'Recibidos'), value: OrderStatus.RECEIVED },
        { label: t('waiterOrderManagement.statusOptionPaid', 'Pagados'), value: OrderStatus.PAID },
        { label: t('waiterOrderManagement.statusOptionAll', 'Todos los Pedidos'), value: 'ALL' }, // 'ALL' es un valor especial
    ];

    // Funci√≥n para cargar pedidos
    const fetchOrders = useCallback(async (status?: string) => {
        setLoading(true);
        setError(null);
        console.log(`[WaiterOrderMgmt] Fetching orders with status filter: ${status || 'Default (from service)'}`);
        try {
            const params: { status?: string } = {};
            if (status && status !== 'ALL') {
                params.status = status;
            }
            // El endpoint es /api/camarero/staff/orders
            const response = await axiosInstance.get<WaiterOrderListItemDto[]>('/camarero/staff/orders', { params });
            setOrders(response.data || []);
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorLoadingData');
            setError(msg);
            notifications.show({ title: t('common.error'), message: msg, color: 'red', icon: <IconAlertCircle /> });
        } finally {
            setLoading(false);
        }
    }, [t]);

    // Carga inicial y cuando cambia el filtro
    useEffect(() => {
        fetchOrders(selectedStatusFilter);
    }, [fetchOrders, selectedStatusFilter]);

    // Handler para marcar como pagado
    const handleMarkAsPaid = async (orderId: string, orderNumber: string) => {
        if (markingPaidOrderId) return; // Evitar clics m√∫ltiples

        setMarkingPaidOrderId(orderId);
        // Por ahora, un payload simple. En el futuro, un modal para 'method' y 'notes'.
        const payload = {
            method: "EFECTIVO_CAJA", // Valor por defecto para la prueba
            notes: `Pagado por camarero UI (MVP) - ${new Date().toLocaleTimeString()}`
        };

        try {
            await axiosInstance.post(`/camarero/staff/order/${orderId}/mark-as-paid`, payload);
            notifications.show({
                title: t('common.success'),
                message: t('waiterOrderManagement.markAsPaidSuccess', { orderNumber: orderNumber }),
                color: 'green',
                icon: <IconCheck />,
            });
            fetchOrders(selectedStatusFilter); // Refrescar la lista
        } catch (err: any) {
            const msg = err.response?.data?.message || err.message || t('common.errorUnknown');
            notifications.show({
                title: t('common.error'),
                message: t('waiterOrderManagement.markAsPaidError', { orderNumber: orderNumber, error: msg }),
                color: 'red',
                icon: <IconX />,
            });
        } finally {
            setMarkingPaidOrderId(null);
        }
    };

    const getStatusBadgeColor = (status: OrderStatus): string => {
        switch (status) {
            case OrderStatus.PENDING_PAYMENT: return 'orange';
            case OrderStatus.COMPLETED: return 'blue';
            case OrderStatus.PAID: return 'green';
            case OrderStatus.CANCELLED: return 'red';
            case OrderStatus.RECEIVED: return 'gray';
            case OrderStatus.IN_PROGRESS: return 'cyan';
            case OrderStatus.PARTIALLY_READY: return 'yellow';
            case OrderStatus.ALL_ITEMS_READY: return 'lime';
            default: return 'gray';
        }
    };

    const rows = orders.map((order) => {
        const isThisOrderLoading = markingPaidOrderId === order.orderId;
        const canMarkAsPaid = order.status === OrderStatus.PENDING_PAYMENT || order.status === OrderStatus.COMPLETED;
        
        return (
            <Table.Tr key={order.orderId}>
                <Table.Td>{order.orderNumber}</Table.Td>
                <Table.Td>{order.tableIdentifier || 'N/A'}</Table.Td>
                <Table.Td ta="right">
                    {order.finalAmount.toLocaleString(currentLanguage, { style: 'currency', currency: 'EUR' })}
                </Table.Td>
                <Table.Td>
                    <Badge color={getStatusBadgeColor(order.status)} variant="light">
                        {t(`orderStatusPage.orderStatus.${order.status.toLowerCase()}`, order.status)}
                    </Badge>
                </Table.Td>
                <Table.Td>
                    <Text size="xs" c="dimmed">
                        {new Date(order.createdAt).toLocaleString(currentLanguage, { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' })}
                    </Text>
                </Table.Td>
                <Table.Td>
                    <Group justify="flex-end">
                        {canMarkAsPaid && (
                            <Button
                                size="xs"
                                color="green"
                                leftSection={<IconCash size={14} />}
                                onClick={() => handleMarkAsPaid(order.orderId, order.orderNumber)}
                                loading={isThisOrderLoading}
                                disabled={!!markingPaidOrderId && !isThisOrderLoading}
                            >
                                {t('waiterOrderManagement.buttonMarkAsPaid')}
                            </Button>
                        )}
                        {/* Aqu√≠ podr√≠amos a√±adir m√°s acciones, como "Pedir Cuenta" si el estado lo permite */}
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    return (
        <Container size="xl" py="xl">
            <Stack gap="lg">
                <Group justify="space-between">
                    <Title order={2}>{t('waiterOrderManagement.title')}</Title>
                    <Button
                        onClick={() => fetchOrders(selectedStatusFilter)}
                        leftSection={<IconReload size={16} />}
                        variant="outline"
                        loading={loading && orders.length > 0} // Mostrar loading si ya hay datos y se refresca
                        disabled={loading || !!markingPaidOrderId}
                    >
                        {t('orderStatusPage.refreshButton')}
                    </Button>
                </Group>

                <SegmentedControl
                    data={statusFilterOptions}
                    value={selectedStatusFilter}
                    onChange={setSelectedStatusFilter}
                    disabled={loading || !!markingPaidOrderId}
                />

                {loading && orders.length === 0 && <Group justify="center" mt="xl"><Loader /></Group>}
                {error && !loading && (
                    <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>
                        {error}
                    </Alert>
                )}

                {!loading && !error && orders.length === 0 && (
                    <Paper p="xl" shadow="xs" withBorder mt="md">
                        <Text ta="center" c="dimmed">
                            {t('waiterOrderManagement.noOrdersFound')}
                        </Text>
                    </Paper>
                )}

                {!loading && !error && orders.length > 0 && (
                    <Table.ScrollContainer minWidth={700}>
                        <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                            <Table.Thead>
                                <Table.Tr>
                                    <Table.Th>{t('waiterOrderManagement.tableHeaderOrderNum')}</Table.Th>
                                    <Table.Th>{t('waiterOrderManagement.tableHeaderTable')}</Table.Th>
                                    <Table.Th ta="right">{t('waiterOrderManagement.tableHeaderTotal')}</Table.Th>
                                    <Table.Th>{t('waiterOrderManagement.tableHeaderStatus')}</Table.Th>
                                    <Table.Th>{t('common.registered')}</Table.Th>
                                    <Table.Th style={{ textAlign: 'right' }}>{t('common.actions')}</Table.Th>
                                </Table.Tr>
                            </Table.Thead>
                            <Table.Tbody>{rows}</Table.Tbody>
                        </Table>
                    </Table.ScrollContainer>
                )}
            </Stack>
        </Container>
    );
};

export default WaiterOrderManagementPage;


// ====== [145] frontend/src/modules/camarero/pages/admin/camarero/WaiterPickupPage.tsx ======
// frontend/src/pages/admin/camarero/WaiterPickupPage.tsx
import React from 'react';
import {
    Container,
    Title,
    Text,
    Loader,
    Alert,
    Paper,
    Stack,
    Group,
    Button,
    Badge,
    ScrollArea,
    Box,
    useMantineTheme,
    List, // <--- A√ëADIDO AQU√ç
} from '@mantine/core';
import {
    IconAlertCircle,
    IconChefHat,
    IconClipboardList,
    IconToolsKitchen,
    IconCircleCheck,
    IconReload,
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useWaiterPickupItems } from '../../../hooks/useWaiterPickupItems'; // Ajusta la ruta si es necesario
import type { ReadyPickupItem } from '../../../types/camarero.types';
import { OrderItemStatus } from '../../../../../shared/types/user.types';

const WaiterPickupPage: React.FC = () => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;
    const theme = useMantineTheme();

    const {
        items,
        isLoadingInitial,
        fetchError,
        markingItemId,
        fetchItems,
        handleMarkAsServed,
    } = useWaiterPickupItems();

    const getItemNameForDisplay = (item: ReadyPickupItem): string => {
        return (currentLanguage === 'es' && item.itemNameSnapshot_es)
            ? item.itemNameSnapshot_es
            : (item.itemNameSnapshot_en || item.itemNameSnapshot_es || t('common.item', '√çtem'));
    };
    
    const getStatusBadge = (status: OrderItemStatus): React.ReactNode => {
        let color = "gray";
        let textKey = '';
        let IconComponent = IconClipboardList;

        switch (status) {
            case OrderItemStatus.READY:
                color = "lime";
                textKey = 'orderStatusPage.itemStatus.ready';
                IconComponent = IconChefHat;
                break;
            case OrderItemStatus.PREPARING:
                color = "blue";
                textKey = 'orderStatusPage.itemStatus.preparing';
                IconComponent = IconToolsKitchen;
                break;
            default:
                textKey = String(status); 
        }
        return <Badge color={color} leftSection={<IconComponent size={14} />} variant="light">{t(textKey, status)}</Badge>;
    };

    if (isLoadingInitial) {
        return (
            <Container size="lg" py="xl" style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: 'calc(100vh - 120px)' }}>
                <Loader size="xl" />
            </Container>
        );
    }

    return (
        <Container size="xl" py="xl">
            <Stack gap="lg">
                <Group justify="space-between" align="center">
                    <Title order={2}>
                        {t('waiterInterface.pickupPageTitle', 'Pedidos Listos para Recoger y Servir')}
                    </Title>
                    <Button
                        onClick={() => fetchItems(true)}
                        leftSection={<IconReload size={16} />}
                        variant="outline"
                        loading={isLoadingInitial && items.length > 0}
                        disabled={isLoadingInitial || !!markingItemId}
                    >
                        {t('orderStatusPage.refreshButton', 'Actualizar')}
                    </Button>
                </Group>

                {fetchError && (
                    <Alert
                        icon={<IconAlertCircle size="1rem" />}
                        title={t('common.error')}
                        color="red"
                        radius="md"
                        withCloseButton
                        onClose={() => fetchItems(true)} 
                    >
                        {fetchError}
                    </Alert>
                )}

                {!fetchError && items.length === 0 && (
                    <Paper p="xl" shadow="xs" withBorder mt="xl">
                        <Text ta="center" c="dimmed">
                            {t('waiterInterface.noItemsReady', 'No hay √≠tems listos para recoger en este momento.')}
                        </Text>
                    </Paper>
                )}

                {items.length > 0 && (
                    <ScrollArea style={{ height: 'calc(100vh - 220px)' }} mt="md">
                        <Stack gap="md">
                            {items.map((item) => (
                                <Paper key={item.orderItemId} shadow="sm" p="md" withBorder radius="md">
                                    <Group justify="space-between" align="flex-start" wrap="nowrap">
                                        <Box style={{ flexGrow: 1 }}>
                                            <Title order={4}>{getItemNameForDisplay(item)}</Title>
                                            <Text size="sm">
                                                {t('kdsPage.quantity', 'Cantidad')}: <Text span fw={700}>{item.quantity}</Text>
                                            </Text>
                                            <Text size="xs" c="dimmed">
                                                {t('waiterInterface.orderNumber', 'Pedido')}: #{item.orderNumber}
                                            </Text>
                                            <Text size="xs" c="dimmed">
                                                {t('orderStatusPage.table', 'Mesa')}: {item.tableIdentifier || t('kdsPage.noTable', 'Sin Mesa')}
                                            </Text>
                                            {item.kdsDestination && (
                                                <Text size="xs" c="dimmed">
                                                    {t('waiterInterface.pickupFrom', 'Recoger de')}: <Badge variant="outline" size="xs">{item.kdsDestination}</Badge>
                                                </Text>
                                            )}
                                            <Text size="xs" c="dimmed">
                                                {t('kdsPage.createdAt', 'Recibido KDS')}: {new Date(item.orderCreatedAt).toLocaleTimeString(i18n.language, { hour: '2-digit', minute: '2-digit' })}
                                            </Text>
                                            {item.currentOrderItemStatus && (
                                                <Box mt={4}>{getStatusBadge(item.currentOrderItemStatus)}</Box>
                                            )}
                                        </Box>
                                        <Button
                                            onClick={() => handleMarkAsServed(item.orderItemId)}
                                            loading={markingItemId === item.orderItemId}
                                            disabled={!!markingItemId && markingItemId !== item.orderItemId}
                                            variant="filled"
                                            color="green"
                                            leftSection={<IconCircleCheck size={18} />}
                                        >
                                            {t('waiterInterface.markAsServedButton', 'Marcar como Servido')}
                                        </Button>
                                    </Group>

                                    {item.selectedModifiers && item.selectedModifiers.length > 0 && (
                                        <Box mt="sm" pt="xs" style={{ borderTop: `1px solid ${theme.colors.gray[3]}` }}>
                                            <Text size="xs" fw={500} mb={2}>{t('kdsPage.modifiers', 'Modificadores:')}</Text>
                                            <List listStyleType="none" spacing={2} size="xs" c="dimmed"> {/* <--- Uso de List */}
                                                {item.selectedModifiers.map((mod, index) => (
                                                    <List.Item key={index}> {/* <--- Uso de List.Item */}
                                                        {(currentLanguage === 'es' && mod.optionName_es) ? mod.optionName_es : (mod.optionName_en || mod.optionName_es)}
                                                    </List.Item>
                                                ))}
                                            </List>
                                        </Box>
                                    )}
                                    {item.itemNotes && (
                                        <Box mt="sm" pt="xs" style={{ borderTop: `1px solid ${theme.colors.gray[3]}` }}>
                                            <Text size="xs" fw={500} mb={2}>{t('kdsPage.notes', 'Notas √çtem')}:</Text>
                                            <Text size="xs" c="orange.7" style={{ whiteSpace: 'pre-wrap' }}>{item.itemNotes}</Text>
                                        </Box>
                                    )}
                                </Paper>
                            ))}
                        </Stack>
                    </ScrollArea>
                )}
            </Stack>
        </Container>
    );
};

export default WaiterPickupPage;


// ====== [146] frontend/src/modules/camarero/services/kdsService.ts ======
// frontend/src/services/kdsService.ts
// Version: 1.0.2 (Use baseURL from axiosInstance implicitly)

import axiosInstance from '../../../shared/services/axiosInstance'; // Tu instancia configurada de Axios
import { 
    OrderItemStatus as AppOrderItemStatus, 
    OrderStatus as AppOrderStatus  // Aseg√∫rate que OrderStatus se importa si se usa en los tipos aqu√≠
} from '../pages/OrderStatusPage'; //

// --- Tipos para la respuesta del GET /api/camarero/kds/items ---
// (Estos tipos son los de la versi√≥n 1.0.1 que ya tienes en project-all-code.txt)
export interface KdsListItem {
    id: string; 
    quantity: number;
    status: AppOrderItemStatus;
    notes: string | null;
    kdsDestination: string | null;
    menuItemName_es: string | null;
    menuItemName_en: string | null; 
    selectedModifiers: {
        optionName_es: string | null;
        optionName_en: string | null; 
    }[];
    orderInfo: {
        id: string; 
        orderNumber: string;
        createdAt: string; 
        tableIdentifier: string | null;
    };
    preparationTime?: number | null; 
    preparedAt?: string | null; 
    servedAt?: string | null; 
}

// --- Tipos para la respuesta del PATCH /api/camarero/kds/items/:orderItemId/status ---
// (Estos tipos son los de la versi√≥n 1.0.1 que ya tienes en project-all-code.txt)
interface ModifierOptionInfo {
    id: string;
    name_es: string | null;
    name_en: string | null;
    priceAdjustment: string; 
    position: number;
    isDefault: boolean;
    isAvailable: boolean;
    groupId: string;
    createdAt: string; 
    updatedAt: string; 
}

interface SelectedModifierInfo {
    orderItemId: string;
    modifierOptionId: string;
    optionNameSnapshot: string | null;
    optionPriceAdjustmentSnapshot: string; 
    createdAt: string; 
    modifierOption: ModifierOptionInfo; 
}

interface MenuItemInfoForKdsPatchResponse {
    id: string;
    sku: string | null;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    price: string; 
    imageUrl: string | null;
    allergens: string[]; 
    tags: string[]; 
    isAvailable: boolean;
    position: number;
    preparationTime: number | null;
    calories: number | null;
    kdsDestination: string | null;
    categoryId: string;
    businessId: string;
    trackInventory: boolean;
    stockQuantity: number | null;
    createdAt: string; 
    updatedAt: string; 
}

interface OrderInfoForKdsPatchResponse {
    id: string;
    orderNumber: string;
    status: AppOrderStatus; 
    totalAmount: string; 
    discountAmount: string | null; 
    finalAmount: string; 
    notes: string | null;
    source: string | null; 
    tableId: string | null;
    customerLCoId: string | null;
    waiterId: string | null;
    businessId: string;
    createdAt: string; 
    updatedAt: string; 
    confirmedAt: string | null; 
    billedAt: string | null; 
    paidAt: string | null; 
    orderType: string; 
    paymentMethodPreference: string | null;
    amountToPayWith: string | null; 
    paymentIntentId: string | null;
    paymentProvider: string | null;
    deliveryAddressJson: string | null; 
    deliveryFee: string | null; 
    estimatedDeliveryTime: string | null; 
    appliedLcoRewardId: string | null;
    appliedLcoRewardDiscountAmount: string | null; 
    appliedLcoTierBenefitDiscountAmount: string | null; 
}

export interface FullOrderItemKdsResponse {
    id: string;
    quantity: number;
    priceAtPurchase: string; 
    totalItemPrice: string; 
    notes: string | null;
    status: AppOrderItemStatus; 
    kdsDestination: string | null;
    orderId: string;
    menuItemId: string;
    itemNameSnapshot: string | null;
    itemDescriptionSnapshot: string | null;
    servedById: string | null;
    preparedAt: string | null; 
    servedAt: string | null; 
    cancellationReason: string | null;
    createdAt: string; 
    updatedAt: string; 
    order: OrderInfoForKdsPatchResponse;
    menuItem: MenuItemInfoForKdsPatchResponse;
    selectedModifiers: SelectedModifierInfo[];
}

// --- CAMBIO: Definir solo la ruta relativa ---
const KDS_API_PATH = '/camarero/kds'; 
// --- FIN CAMBIO ---

export const getItemsForKds = async (
    destination: string,
    statusValues?: AppOrderItemStatus[]
): Promise<KdsListItem[]> => {
    try {
        const params: Record<string, string | string[]> = { destination: destination.toUpperCase() };
        if (statusValues && statusValues.length > 0) {
            params.status = statusValues; 
        }
        // --- CAMBIO: Usar solo la ruta relativa ---
        const response = await axiosInstance.get<KdsListItem[]>(`${KDS_API_PATH}/items`, { params });
        // --- FIN CAMBIO ---
        console.log('[kdsService.getItemsForKds] Raw response data:', response.data);
        return response.data;
    } catch (error) {
        console.error('[kdsService.getItemsForKds] Error fetching KDS items:', error);
        throw error;
    }
};

export const updateOrderItemKdsStatus = async (
    orderItemId: string,
    newStatus: AppOrderItemStatus
): Promise<FullOrderItemKdsResponse> => { 
    try {
        // --- CAMBIO: Usar solo la ruta relativa ---
        const response = await axiosInstance.patch<FullOrderItemKdsResponse>(
            `${KDS_API_PATH}/items/${orderItemId}/status`,
            { newStatus } 
        );
        // --- FIN CAMBIO ---
        console.log('[kdsService.updateOrderItemKdsStatus] Raw response data:', response.data);
        return response.data;
    } catch (error) {
        console.error(`[kdsService.updateOrderItemKdsStatus] Error updating KDS order item ${orderItemId} status:`, error);
        throw error;
    }
};


// ====== [147] frontend/src/modules/camarero/services/publicOrderApiService.ts ======
// frontend/src/services/publicOrderApiService.ts
// Version 1.1.2 (Fix property name from orderNotes to customerNotes in payload)

import axios from 'axios';
import {
    CreateOrderPayloadDto,
    AddItemsToOrderPayloadDto,
    BackendOrderResponse,
    OrderItemFE,
} from '../types/publicOrder.types';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL_PUBLIC || 'http://localhost:3000/public';

const getProcessedNotesValue = (notesInput: string | null | undefined): string | null => {
    if (notesInput === null || notesInput === undefined) return null;
    const trimmed = notesInput.trim();
    return trimmed === "" ? null : trimmed;
};

export const submitNewOrder = async (
    businessSlug: string,
    payload: CreateOrderPayloadDto
): Promise<BackendOrderResponse> => {
    try {
        const response = await axios.post<BackendOrderResponse>(`${API_BASE_URL}/order/${businessSlug}`, payload);
        return response.data;
    } catch (error) {
        console.error(`[PublicOrderApiService] Error submitting NEW order for slug ${businessSlug}:`, error);
        throw error;
    }
};

export const addItemsToExistingOrderApi = async (
    orderId: string,
    businessSlug: string,
    payload: AddItemsToOrderPayloadDto
): Promise<BackendOrderResponse> => {
    try {
        const headers: Record<string, string> = { 'Content-Type': 'application/json' };
        if (businessSlug) {
            headers['x-loyalpyme-business-slug'] = businessSlug;
        }
        const response = await axios.post<BackendOrderResponse>(
            `${API_BASE_URL}/order/${orderId}/items`,
            payload,
            { headers }
        );
        return response.data;
    } catch (error) {
        console.error(`[PublicOrderApiService] Error adding items to order ${orderId}:`, error);
        throw error;
    }
};

export const handleOrderSubmission = async (
    cartItems: OrderItemFE[],
    generalOrderNotes: string,
    activeOrderId: string | null,
    businessSlug: string,
    tableIdentifier?: string
): Promise<BackendOrderResponse> => {

    const dtoItems = cartItems.map(feItem => ({
        menuItemId: feItem.menuItemId,
        quantity: feItem.quantity,
        notes: getProcessedNotesValue(feItem.notes),
        selectedModifierOptions: feItem.selectedModifiers.length > 0
            ? feItem.selectedModifiers.map(sm => ({ modifierOptionId: sm.modifierOptionId }))
            : [],
    }));

    let customerIdForPayload: string | null = null;
    const storedUser = localStorage.getItem('user');
    if (storedUser) {
        try {
            const parsedUser = JSON.parse(storedUser);
            if (parsedUser?.id && parsedUser.role === 'CUSTOMER_FINAL') {
                customerIdForPayload = parsedUser.id;
            }
        } catch (e) {
            console.error("Error parsing user from localStorage for order submission:", e);
        }
    }

    if (activeOrderId) {
        const payloadForAdd: AddItemsToOrderPayloadDto = {
            items: dtoItems,
            customerNotes: getProcessedNotesValue(generalOrderNotes),
        };
        const response = await addItemsToExistingOrderApi(activeOrderId, businessSlug, payloadForAdd);
        return { ...response, id: activeOrderId };
    } else {
        const payloadForCreate: CreateOrderPayloadDto = {
            items: dtoItems,
            // --- CORRECCI√ìN AQU√ç: Cambiar 'orderNotes' por 'customerNotes' ---
            customerNotes: getProcessedNotesValue(generalOrderNotes),
            // --- FIN CORRECCI√ìN ---
            tableIdentifier: tableIdentifier || null,
            customerId: customerIdForPayload,
        };
        return submitNewOrder(businessSlug, payloadForCreate);
    }
};


// ====== [148] frontend/src/modules/camarero/services/waiterService.ts ======
// frontend/src/services/waiterService.ts
// Version: 1.0.0 (Initial service for waiter actions: get ready items, mark as served)

import axiosInstance from '../../../shared/services/axiosInstance'; // Nuestra instancia de Axios configurada con interceptor de token
import { ReadyPickupItem, OrderItemStatusUpdateResponse } from '../types/camarero.types'; // Tipos que definimos antes
import { OrderItemStatus } from '../../../shared/types/user.types';

const WAITER_STAFF_API_BASE = '/camarero/staff'; // Prefijo base para las rutas de este servicio

/**
 * Obtiene la lista de √≠tems de pedido que est√°n listos para ser recogidos.
 * Llama a GET /api/camarero/staff/ready-for-pickup
 * @returns Una promesa que resuelve con un array de ReadyPickupItem.
 */
export const getReadyForPickupItems = async (): Promise<ReadyPickupItem[]> => {
    console.log('[WaiterService] Fetching items ready for pickup...');
    try {
        const response = await axiosInstance.get<ReadyPickupItem[]>(`${WAITER_STAFF_API_BASE}/ready-for-pickup`);
        console.log(`[WaiterService] Successfully fetched ${response.data?.length || 0} ready items.`);
        return response.data || []; // Devolver array vac√≠o si no hay datos
    } catch (error) {
        // El error ya deber√≠a ser manejado y logueado por el interceptor de axiosInstance,
        // pero podemos a√±adir un log espec√≠fico aqu√≠ si es necesario.
        console.error("[WaiterService] Error fetching ready for pickup items:", error);
        // Relanzar para que el hook o componente que llama pueda manejarlo (ej. mostrar UI de error)
        throw error; 
    }
};

/**
 * Marca un OrderItem espec√≠fico como SERVED.
 * Llama a PATCH /api/camarero/staff/order-items/:orderItemId/status
 * @param orderItemId - El ID del OrderItem a actualizar.
 * @returns Una promesa que resuelve con la respuesta del backend (OrderItemStatusUpdateResponse).
 */
export const markOrderItemAsServed = async (orderItemId: string): Promise<OrderItemStatusUpdateResponse> => {
    console.log(`[WaiterService] Marking order item ${orderItemId} as SERVED...`);
    try {
        // El backend espera un payload: { newStatus: "SERVED" }
        const payload = { newStatus: OrderItemStatus.SERVED }; 

        const response = await axiosInstance.patch<OrderItemStatusUpdateResponse>(
            `${WAITER_STAFF_API_BASE}/order-items/${orderItemId}/status`,
            payload
        );
        console.log(`[WaiterService] Successfully marked item ${orderItemId} as SERVED. Response:`, response.data);
        return response.data;
    } catch (error) {
        console.error(`[WaiterService] Error marking order item ${orderItemId} as served:`, error);
        throw error;
    }
};


// ====== [149] frontend/src/modules/camarero/types/camarero.types.ts ======
// frontend/src/types/camarero.types.ts
// Version: 1.1.0 (Add WaiterOrderListItemDto and import OrderType)

// Aseg√∫rate de que OrderItemStatus, OrderStatus y OrderType se importan correctamente.
import { OrderItemStatus, OrderStatus, OrderType } from './customer'; // OrderType a√±adido al import

/**
 * DTO para la informaci√≥n de un modificador seleccionado que se muestra al camarero.
 */
export interface WaiterSelectedModifier { // Renombrado desde WaiterSelectedModifierDto para consistencia
  optionName_es: string | null;
  optionName_en: string | null;
}

/**
 * DTO para cada √≠tem de pedido que est√° listo para ser recogido y servido por el camarero.
 */
export interface ReadyPickupItem { // Renombrado desde ReadyPickupItemDto
  orderItemId: string;
  orderId: string;
  orderNumber: string;
  orderCreatedAt: Date; // Cambiado a Date, el servicio backend devuelve Date, la serializaci√≥n JSON lo convierte
  tableIdentifier: string | null;
  itemNameSnapshot_es: string | null;
  itemNameSnapshot_en: string | null;
  quantity: number;
  itemNotes: string | null;
  kdsDestination: string | null;
  selectedModifiers: WaiterSelectedModifier[];
  currentOrderItemStatus: OrderItemStatus;
}

/**
 * DTO para la respuesta del backend al actualizar el estado de un OrderItem
 * desde la interfaz de camarero o KDS.
 */
export interface OrderItemStatusUpdateResponse { // Renombrado desde OrderItemStatusUpdateResponseDto
  message: string;
  orderItemId: string;
  newStatus: OrderItemStatus;
  orderStatus?: OrderStatus;
}

// ---- NUEVO DTO A√ëADIDO ----
/**
 * DTO para representar un √≠tem en la lista de pedidos para la interfaz del camarero.
 * Usado en: GET /api/camarero/staff/orders (respuesta del backend)
 */
export interface WaiterOrderListItemDto {
  orderId: string;
  orderNumber: string;
  tableIdentifier: string | null;
  status: OrderStatus;
  finalAmount: number; // El servicio ya lo convierte a n√∫mero
  itemCount: number;
  customerName?: string | null;
  createdAt: Date; // El servicio devuelve Date, la serializaci√≥n JSON lo convierte
  isBillRequested?: boolean;
  orderType?: OrderType | null;
}
// ---- FIN NUEVO DTO ----


// ====== [150] frontend/src/modules/camarero/types/menu.types.ts ======
// frontend/src/types/menu.types.ts
// Version: (tu versi√≥n existente + tipos para men√∫ p√∫blico)

// --- MENU CATEGORY (Existente) ---
export interface MenuCategoryData {
  id: string;
  businessId: string; 
  name_es: string;
  name_en: string | null;
  description_es?: string | null;
  description_en?: string | null;
  imageUrl?: string | null;
  position: number;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
  items?: MenuItemData[]; // Opcional para cargas anidadas
}

export interface MenuCategoryFormData {
  name_es: string;
  name_en: string | null;
  description_es?: string | null;
  description_en?: string | null;
  imageUrl?: string | null;
  position: number;
  isActive: boolean;
}

// --- MENU ITEM (Existente) ---
export interface MenuItemData {
  id: string;
  categoryId: string;
  businessId: string;
  name_es: string;
  name_en: string | null;
  description_es: string | null;
  description_en: string | null;
  price: number; 
  imageUrl: string | null;
  allergens: string[];
  tags: string[];
  isAvailable: boolean;
  position: number;
  preparationTime: number | null;
  calories: number | null;
  kdsDestination: string | null;
  sku: string | null;
  createdAt: string;
  updatedAt: string;
  modifierGroups?: ModifierGroupData[]; // MODIFICADO: A√±adido ? para que sea opcional si no se carga siempre
}

export interface MenuItemFormData {
  name_es: string;
  name_en: string | null;
  description_es: string | null;
  description_en: string | null;
  price: number; 
  imageUrl: string | null;
  allergens: string[];
  tags: string[];
  isAvailable: boolean;
  position: number;
  preparationTime?: number | null;
  calories?: number | null;
  kdsDestination?: string | null;
  sku?: string | null;
}

// --- MODIFIER GROUP (Existente) ---
export enum ModifierUiType {
    RADIO = 'RADIO',
    CHECKBOX = 'CHECKBOX',
}

export interface ModifierGroupData {
  id: string;
  menuItemId: string;
  businessId: string;
  name_es: string;
  name_en: string | null;
  uiType: ModifierUiType;
  minSelections: number;
  maxSelections: number;
  position: number;
  isRequired: boolean;
  options?: ModifierOptionData[];
  createdAt: string;
  updatedAt: string;
}

export interface ModifierGroupFormData {
  name_es: string;
  name_en: string | null;
  uiType: ModifierUiType;
  minSelections: number;
  maxSelections: number;
  position: number;
  isRequired: boolean;
}


// --- MODIFIER OPTION (Existente) ---
export interface ModifierOptionData {
  id: string;
  groupId: string;
  name_es: string;
  name_en: string | null;
  priceAdjustment: number;
  position: number;
  isDefault: boolean;
  isAvailable: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface ModifierOptionFormData {
  name_es: string;
  name_en: string | null;
  priceAdjustment: number;
  position: number;
  isDefault: boolean;
  isAvailable: boolean;
}

// --- Tipos para la Visualizaci√≥n P√∫blica del Men√∫ (NUEVOS) ---
export interface PublicMenuModifierOption {
    id: string;
    name_es: string | null;
    name_en: string | null;
    priceAdjustment: number; // En frontend, esperamos un n√∫mero.
    position: number;
    isDefault: boolean;
    isAvailable: boolean;
}

export interface PublicMenuModifierGroup {
    id: string;
    name_es: string | null;
    name_en: string | null;
    uiType: ModifierUiType; // Reutilizamos el enum existente
    minSelections: number;
    maxSelections: number;
    isRequired: boolean;
    position: number;
    options: PublicMenuModifierOption[];
}

export interface PublicMenuItem {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    price: number; // En frontend, esperamos un n√∫mero.
    imageUrl: string | null;
    allergens: string[];
    tags: string[];
    position: number;
    modifierGroups: PublicMenuModifierGroup[];
}

export interface PublicMenuCategory {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es: string | null;
    description_en: string | null;
    imageUrl: string | null;
    position: number;
    items: PublicMenuItem[];
}

export interface PublicDigitalMenuData {
    businessName: string;
    businessSlug: string;
    businessLogoUrl: string | null;
    categories: PublicMenuCategory[];
}


// ====== [151] frontend/src/modules/camarero/types/publicOrder.types.ts ======
// frontend/src/types/publicOrder.types.ts
// Version: 1.0.5 (Correct property name from orderNotes to customerNotes)

import { PublicMenuItem } from './menu.types';

// --- Tipos para el Frontend del Carrito y Configuraci√≥n de √çtems ---
export interface SelectedModifierFE {
    modifierOptionId: string;
    name_es?: string | null;
    name_en?: string | null;
    priceAdjustment: number;
    modifierGroupName_es?: string | null;
    modifierGroupName_en?: string | null;
}

export interface OrderItemFE {
    cartItemId: string;
    menuItemId: string;
    menuItemName_es: string | null;
    menuItemName_en: string | null;
    quantity: number;
    basePrice: number;
    currentPricePerUnit: number;
    totalPriceForItem: number;
    notes?: string | null;
    selectedModifiers: SelectedModifierFE[];
}

export interface ConfiguringItemState {
    itemDetails: PublicMenuItem;
    quantity: number;
    selectedOptionsByGroup: Record<string, string[] | string>;
    currentUnitPrice: number;
    itemNotes: string;
    areModifiersValid: boolean;
}

// --- Tipos para los DTOs de la API (Payloads para el Backend) ---
export interface CreateOrderItemModifierDto {
    modifierOptionId: string;
}

export interface CreateOrderItemDto {
    menuItemId: string;
    quantity: number;
    notes?: string | null;
    selectedModifierOptions?: CreateOrderItemModifierDto[] | null;
}

export interface CreateOrderPayloadDto {
    tableIdentifier?: string | null;
    customerId?: string | null;
    // --- CORRECCI√ìN AQU√ç ---
    customerNotes: string | null; // Antes era orderNotes
    // --- FIN CORRECCI√ìN ---
    items: CreateOrderItemDto[];
    businessId?: string;
}

export interface AddItemsToOrderPayloadDto {
    items: CreateOrderItemDto[];
    customerNotes: string | null;
}

// --- Tipos para las Respuestas de la API de Pedidos ---
export interface BackendOrderResponse {
    id: string;
    orderNumber?: string | null;
}

// --- Tipos para la Gesti√≥n del Pedido Activo en localStorage ---
export interface ActiveOrderInfo {
    orderId: string;
    orderNumber: string;
    businessSlug: string;
    tableIdentifier?: string;
    savedAt: number;
}


// ====== [152] frontend/src/modules/loyalpyme/components/AddRewardForm.tsx ======
// filename: frontend/src/components/AddRewardForm.tsx
// Version: 1.3.1 (Fix encoding, remove logs and meta-comments)

import { useState, useEffect, FormEvent } from 'react';
import axiosInstance from '../services/axiosInstance';

// Mantine Imports
import {
    TextInput, Textarea, NumberInput, Button, Stack, Group
} from '@mantine/core';
// Importar notifications y iconos
import { notifications } from '@mantine/notifications';
import { IconAlertCircle, IconCheck, IconX } from '@tabler/icons-react';


// Interfaz Reward (local)
interface Reward {
    id: string; name: string; description?: string | null; pointsCost: number; isActive: boolean;
}

// Props del componente
interface RewardFormProps {
    mode: 'add' | 'edit';
    initialData?: Reward | null;
    rewardIdToUpdate?: string | null;
    onSubmitSuccess: () => void; // Callback en caso de √©xito
    onCancel: () => void; // Callback para cancelar
}

// Componente renombrado a RewardForm consistentemente
const RewardForm: React.FC<RewardFormProps> = ({
    mode, initialData, rewardIdToUpdate, onSubmitSuccess, onCancel
}) => {

    // Estados
    const [name, setName] = useState<string>('');
    const [description, setDescription] = useState<string>('');
    const [pointsCost, setPointsCost] = useState<number | ''>('');
    const [isSubmitting, setIsSubmitting] = useState<boolean>(false);

    // Efecto para popular/resetear formulario
    useEffect(() => {
        if (mode === 'edit' && initialData) {
            setName(initialData.name || '');
            setDescription(initialData.description || '');
            setPointsCost(initialData.pointsCost !== null ? initialData.pointsCost : '');
        } else {
            // Resetear para modo 'add' o si no hay initialData
            setName(''); setDescription(''); setPointsCost('');
        }
    }, [mode, initialData]);

    const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
        event.preventDefault();

        // Validaci√≥n frontend
        if (!name.trim()) {
            notifications.show({
                title: 'Campo Obligatorio',
                message: 'El nombre de la recompensa no puede estar vac√≠o.',
                color: 'orange', icon: <IconAlertCircle size={18} />,
            });
            return;
        }
        if (pointsCost === '' || pointsCost < 0) {
            notifications.show({
                title: 'Campo Inv√°lido', // Corregido: Inv√°lido
                message: 'El coste en puntos debe ser un n√∫mero igual o mayor que cero.', // Corregido: n√∫mero
                color: 'orange', icon: <IconAlertCircle size={18} />,
            });
            return;
        }

        setIsSubmitting(true);

        const commonData = {
            name: name.trim(),
            description: description.trim() || null, // Enviar null si est√° vac√≠o
            pointsCost: Number(pointsCost), // Asegurar que es n√∫mero
        };

        try {
            let successMessage = '';
            if (mode === 'add') {
                // console.log('Submitting ADD request:', commonData); // Log eliminado
                await axiosInstance.post('/rewards', commonData);
                // console.log('Add successful'); // Log eliminado
                successMessage = `Recompensa "${commonData.name}" a√±adida con √©xito.`; // Corregido: √©xito, a√±adida
            } else { // mode === 'edit'
                if (!rewardIdToUpdate) throw new Error("Falta el ID de la recompensa para actualizar.");
                // console.log(`Submitting EDIT request for ${rewardIdToUpdate}:`, commonData); // Log eliminado
                await axiosInstance.patch(`/rewards/${rewardIdToUpdate}`, commonData);
                // console.log('Edit successful'); // Log eliminado
                successMessage = `Recompensa "${commonData.name}" actualizada con √©xito.`; // Corregido: √©xito
            }

            // Notificaci√≥n de √âxito
            notifications.show({
                title: '√âxito', // Corregido: √âxito
                message: successMessage,
                color: 'green', icon: <IconCheck size={18} />, autoClose: 4000,
            });

            onSubmitSuccess(); // Llama al callback del padre

        } catch (err: any) {
            console.error(`Error ${mode === 'add' ? 'adding' : 'updating'} reward:`, err); // Mantener error log
            const actionText = mode === 'add' ? 'a√±adir' : 'actualizar';
            const errorMessage = `Error al ${actionText} la recompensa: ${err.response?.data?.message || err.message || 'Error desconocido'}`;

            // Notificaci√≥n de Error
            notifications.show({
                title: 'Error', message: errorMessage, color: 'red',
                icon: <IconX size={18} />, autoClose: 6000,
            });
        } finally {
            setIsSubmitting(false);
        }
    };

    const submitButtonText = mode === 'add' ? 'A√±adir Recompensa' : 'Actualizar Recompensa';

    return (
        <form onSubmit={handleSubmit}>
            <Stack gap="md">
                <TextInput label="Nombre de la Recompensa:" placeholder="Ej: Caf√© Gratis" value={name} onChange={(e) => setName(e.currentTarget.value)} required disabled={isSubmitting} radius="lg" />
                <Textarea label="Descripci√≥n (Opcional):" placeholder="Ej: Un caf√© espresso o americano" value={description} onChange={(e) => setDescription(e.currentTarget.value)} rows={3} disabled={isSubmitting} radius="lg" />
                <NumberInput label="Coste en Puntos:" placeholder="Ej: 100" value={pointsCost} onChange={(value) => setPointsCost(typeof value === 'number' ? value : '')} min={0} step={1} allowDecimal={false} required disabled={isSubmitting} radius="lg" />

                {/* Alert de error local eliminada */}

                <Group justify="flex-end" mt="md">
                    <Button variant="light" onClick={onCancel} disabled={isSubmitting} radius="lg"> Cancelar </Button>
                    <Button type="submit" loading={isSubmitting} radius="lg"> {submitButtonText} </Button>
                </Group>
            </Stack>
        </form>
    );
};

export default RewardForm;

// End of File: frontend/src/components/AddRewardForm.tsx


// ====== [153] frontend/src/modules/loyalpyme/components/GenerateQrCode.tsx ======
// filename: frontend/src/components/GenerateQrCode.tsx
import { useState } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { QRCodeCanvas } from 'qrcode.react';
import {
    TextInput, NumberInput, Button, Stack, Alert, Loader,
    Paper, Text, Code, Box, Group, Center
} from '@mantine/core';
import { IconAlertCircle, IconCheck } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

interface QrCodeData {
    qrToken: string;
    amount: number;
}

const GenerateQrCode: React.FC = () => {
    const { t } = useTranslation();
    const [amount, setAmount] = useState<number | ''>('');
    const [ticketNumber, setTicketNumber] = useState<string>('');
    const [isLoading, setIsLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);
    const [generatedData, setGeneratedData] = useState<QrCodeData | null>(null);

    const handleGenerateClick = async () => {
        setError(null);
        setGeneratedData(null);

        if (amount === '' || amount <= 0) {
            setError(t('component.generateQr.errorAmountPositive'));
            return;
        }
        if (!ticketNumber || ticketNumber.trim() === '') {
            setError(t('component.generateQr.errorTicketRequired'));
            return;
        }
        setIsLoading(true);
        try {
            const requestData = { amount: Number(amount), ticketNumber: ticketNumber.trim() };
            const response = await axiosInstance.post<QrCodeData>('/points/generate-qr', requestData);
            setGeneratedData(response.data);
            setAmount('');
            setTicketNumber('');
        } catch (err: any) {
            console.error('Error generating QR code data:', err);
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown'); // Clave com√∫n para error desconocido
            setError(t('component.generateQr.errorGeneric', { error: apiError }));
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Stack gap="md">
            <NumberInput
                label={t('component.generateQr.amountLabel')}
                placeholder={t('component.generateQr.amountPlaceholder')}
                value={amount}
                onChange={(value) => setAmount(typeof value === 'number' ? value : '')}
                min={0.01}
                step={0.01}
                decimalScale={2}
                fixedDecimalScale
                required
                radius="lg"
                disabled={isLoading}
            />
            <TextInput
                label={t('component.generateQr.ticketLabel')}
                placeholder={t('component.generateQr.ticketPlaceholder')}
                value={ticketNumber}
                onChange={(e) => setTicketNumber(e.currentTarget.value)}
                required
                radius="lg"
                disabled={isLoading}
            />
            <Box>
                <Button onClick={handleGenerateClick} loading={isLoading} radius="lg">
                    {t('component.generateQr.buttonText')}
                </Button>
            </Box>

            <Box mt="md" style={{ minHeight: '200px' }}>
                {isLoading && (
                    <Group justify="center"><Loader size="sm" /></Group>
                )}
                {error && (
                    <Alert
                        icon={<IconAlertCircle size={16} />}
                        title={t('common.error')}
                        color="red"
                        radius="lg"
                        withCloseButton
                        onClose={() => setError(null)}
                    >
                        {error}
                    </Alert>
                )}
                {generatedData && (
                    <Paper withBorder p="md" radius="lg" mt="sm">
                        <Group gap="xs" mb="xs">
                            <IconCheck size={16} color="var(--mantine-color-green-7)" />
                            <Text fw={500} size="sm">
                                {t('component.generateQr.successMessage', { amount: generatedData.amount.toFixed(2) })}
                            </Text>
                        </Group>
                        <Text size="sm" mb="md">
                            {t('component.generateQr.successInstructions')}
                        </Text>
                        <Center>
                            <QRCodeCanvas
                                value={generatedData.qrToken}
                                size={160}
                                bgColor={"#ffffff"}
                                fgColor={"#000000"}
                                level={"L"}
                                includeMargin={true}
                            />
                        </Center>
                        <Text size="xs" c="dimmed" mt="md" ta="center">
                            {t('component.generateQr.tokenRef')}{' '}
                            <Code>{generatedData.qrToken}</Code>
                        </Text>
                    </Paper>
                )}
                 {!isLoading && !error && !generatedData && (
                     <Text size="sm" c="dimmed">{t('component.generateQr.initialPrompt', 'Introduce importe y n√∫mero de ticket para generar los datos del QR.')}</Text>
                 )}
            </Box>
        </Stack>
    );
};

export default GenerateQrCode;


// ====== [154] frontend/src/modules/loyalpyme/components/admin/AdjustPointsModal.tsx ======
// frontend/src/components/admin/AdjustPointsModal.tsx
// Version 1.1.0 (Use adminCustomerService for API call)

import React, { useState, useEffect } from 'react';
import { Modal, TextInput, Button, Group, Text, NumberInput } from '@mantine/core';
import { useForm } from '@mantine/form'; // zodResolver no es estrictamente necesario aqu√≠ si la validaci√≥n es simple
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX } from '@tabler/icons-react';
import { Customer } from '../../hooks/useAdminCustomersData';
import { useTranslation } from 'react-i18next';

// --- NUEVO: Importar el servicio ---
import * as adminCustomerService from '../../services/adminCustomerService';
// --- FIN NUEVO ---

interface AdjustPointsModalProps {
    opened: boolean;
    onClose: () => void;
    customer: Customer | null;
    onSuccess: () => void; // Callback para refrescar datos en la p√°gina principal
}

const AdjustPointsModal: React.FC<AdjustPointsModalProps> = ({ opened, onClose, customer, onSuccess }) => {
    const { t } = useTranslation();
    const [loading, setLoading] = useState(false); // Renombrado de isSubmitting a loading para consistencia

    const form = useForm({
        initialValues: { amount: 0, reason: '' },
        validate: {
            amount: (value) => (value === 0 ? t('validation.cannotBeZero') : null),
            // 'reason' es opcional, no necesita validaci√≥n aqu√≠ a menos que cambien los requisitos
        }
    });

    useEffect(() => {
        if (opened) {
             form.reset(); // Resetear el formulario cada vez que se abre
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened]); // No necesitamos customer como dependencia si solo reseteamos

    const handleSubmit = async (values: typeof form.values) => {
        if (!customer) return;
        setLoading(true);
        try {
            // --- CAMBIO: Llamar al servicio en lugar de axiosInstance directamente ---
            await adminCustomerService.adjustCustomerPointsApi(
                customer.id,
                values.amount,
                values.reason.trim() ? values.reason.trim() : null // Enviar null si la raz√≥n est√° vac√≠a
            );
            // --- FIN CAMBIO ---

            notifications.show({
                title: t('common.success'),
                message: t('adminCustomersPage.adjustPointsSuccess', { name: customer.name || customer.email }),
                color: 'green',
                icon: <IconCheck size={18} />,
            });
            onSuccess(); // Llama al callback para refrescar la tabla en la p√°gina principal
            onClose();   // Cierra el modal
        } catch (error: any) {
            console.error("Error adjusting points via modal:", error);
            const apiError = error.response?.data?.message || error.message || t('common.errorUnknown');
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.adjustPointsError', { error: apiError }),
                color: 'red',
                icon: <IconX size={18} />,
            });
            // No cerramos el modal en caso de error para que el usuario pueda corregir si es necesario
        } finally {
            setLoading(false);
        }
    };

    const modalTitle = t('adminCustomersPage.adjustPointsModalTitle', {
        name: customer?.name || customer?.email || t('common.customer')
    });

    return (
        <Modal
            opened={opened}
            onClose={() => { if (!loading) onClose(); }} // Prevenir cierre si est√° enviando
            title={modalTitle}
            centered
            trapFocus // Mantener el foco dentro del modal
            closeOnClickOutside={!loading} // Prevenir cierre al hacer clic fuera si est√° cargando
            closeOnEscape={!loading}     // Prevenir cierre con ESC si est√° cargando
        >
            {customer ? (
                <form onSubmit={form.onSubmit(handleSubmit)}>
                    <Text size="sm" mb="md">
                        {t('adminCustomersPage.adjustPointsCurrent', { points: customer.points })}
                    </Text>
                    <NumberInput
                        label={t('adminCustomersPage.adjustPointsAmountLabel')}
                        placeholder={t('adminCustomersPage.adjustPointsAmountPlaceholder')}
                        required
                        allowNegative
                        disabled={loading}
                        data-autofocus // Enfocar este campo al abrir
                        {...form.getInputProps('amount')}
                    />
                    <TextInput
                        label={t('adminCustomersPage.adjustPointsReasonLabel')}
                        placeholder={t('adminCustomersPage.adjustPointsReasonPlaceholder')}
                        mt="md"
                        disabled={loading}
                        {...form.getInputProps('reason')}
                    />
                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={onClose} disabled={loading}>
                            {t('common.cancel')}
                        </Button>
                        <Button
                            type="submit"
                            loading={loading}
                            disabled={!form.isValid() || form.values.amount === 0 || loading}
                        >
                            {t('adminCustomersPage.adjustPointsButton')}
                        </Button>
                    </Group>
                </form>
            ) : (
                // Esto no deber√≠a mostrarse si el modal solo se abre con un customer
                <Text c="dimmed">{t('adminCustomersPage.noCustomerSelected')}</Text>
            )}
        </Modal>
    );
};

export default AdjustPointsModal;


// ====== [155] frontend/src/modules/loyalpyme/components/admin/AssignRewardModal.tsx ======
// frontend/src/components/admin/AssignRewardModal.tsx
// Version 1.2.0 (Use adminCustomerService for API call)

import React, { useState, useEffect } from 'react';
import { Modal, Select, Button, Group, Text, Loader, Alert } from '@mantine/core';
// axiosInstance ya no se usa aqu√≠ para la acci√≥n principal
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX, IconAlertCircle } from '@tabler/icons-react';
import type { Customer } from '../../hooks/useAdminCustomersData';
import { useTranslation } from 'react-i18next';

// --- NUEVO: Importar el servicio ---
import * as adminCustomerService from '../../services/adminCustomerService';
import axiosInstance from '../../../../shared/services/axiosInstance';// A√∫n necesario para fetchRewards

// Importar el tipo Reward de nuestro archivo centralizado
import type { Reward } from '../../../../shared/types/user.types';

interface AssignRewardModalProps {
    opened: boolean;
    onClose: () => void;
    customer: Customer | null;
    onSuccess: () => void; // Para refrescar la lista de clientes o detalles si es necesario
}

const AssignRewardModal: React.FC<AssignRewardModalProps> = ({ opened, onClose, customer, onSuccess }) => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;

    const [rewards, setRewards] = useState<{ value: string; label: string }[]>([]);
    const [selectedRewardId, setSelectedRewardId] = useState<string | null>(null);
    const [loadingRewards, setLoadingRewards] = useState(false);
    const [loadingAssign, setLoadingAssign] = useState(false);
    const [errorRewards, setErrorRewards] = useState<string | null>(null);

    useEffect(() => {
        if (opened && customer) {
            setLoadingRewards(true);
            setErrorRewards(null);
            setSelectedRewardId(null); // Resetear selecci√≥n al abrir

            // La API /rewards devuelve todos, filtramos las activas en el frontend para este modal
            axiosInstance.get<Reward[]>('/rewards')
                .then(response => {
                    const activeRewards = response.data?.filter(r => r.isActive) ?? [];
                    const availableRewards = activeRewards.map(reward => {
                        const displayName = (currentLanguage === 'es' ? reward.name_es : reward.name_en) || reward.name_es || reward.name_en || `ID: ${reward.id}`;
                        return {
                            value: reward.id,
                            label: `${displayName} (${t('adminCustomersPage.assignRewardOptionPoints', { points: reward.pointsCost ?? 0 })})`
                        };
                    });
                    setRewards(availableRewards);
                })
                .catch(err => {
                    console.error("Error fetching rewards for modal:", err);
                    const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
                    setErrorRewards(t('adminCustomersPage.assignRewardErrorLoading', { error: apiError }));
                })
                .finally(() => {
                    setLoadingRewards(false);
                });
        } else if (!opened) {
            setSelectedRewardId(null);
            setRewards([]);
            setErrorRewards(null);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, customer, t, currentLanguage]); // A√±adir t y currentLanguage

    const handleAssign = async () => {
        if (!customer || !selectedRewardId) return;
        setLoadingAssign(true);
        try {
            // --- CAMBIO: Llamar al servicio en lugar de axiosInstance directamente ---
            await adminCustomerService.assignRewardToCustomerApi(customer.id, selectedRewardId);
            // --- FIN CAMBIO ---

            notifications.show({
                title: t('common.success'),
                message: t('adminCustomersPage.assignRewardSuccess', { name: customer.name || customer.email }),
                color: 'green',
                icon: <IconCheck size={18} />
            });
            onSuccess(); // Refrescar datos en la p√°gina principal
            onClose();   // Cerrar el modal
        } catch (error: any) {
            console.error("Error assigning reward via modal:", error);
            const apiError = error.response?.data?.message || error.message || t('common.errorUnknown');
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.assignRewardError', { error: apiError }),
                color: 'red',
                icon: <IconX size={18} />
            });
        } finally {
            setLoadingAssign(false);
        }
    };

    const modalTitle = t('adminCustomersPage.assignRewardModalTitle', {
        name: customer?.name || customer?.email || t('common.customer')
    });

    return (
        <Modal
            opened={opened}
            onClose={() => { if (!loadingAssign) onClose(); }}
            title={modalTitle}
            centered
            trapFocus
            closeOnClickOutside={!loadingAssign}
            closeOnEscape={!loadingAssign}
        >
            {loadingRewards && <Group justify="center"><Loader /></Group>}
            {errorRewards && !loadingRewards && (
                <Alert title={t('adminCustomersPage.assignRewardLoadingErrorTitle')} color="red" icon={<IconAlertCircle />}>
                    {errorRewards}
                </Alert>
            )}

            {!loadingRewards && !errorRewards && customer && (
                <>
                    <Select
                        label={t('adminCustomersPage.assignRewardSelectLabel')}
                        placeholder={t('adminCustomersPage.assignRewardSelectPlaceholder')}
                        data={rewards}
                        value={selectedRewardId}
                        onChange={setSelectedRewardId}
                        searchable
                        nothingFoundMessage={rewards.length === 0 && !loadingRewards ? t('adminCustomersPage.assignRewardNotFound') : t('common.noResults')}
                        required
                        disabled={rewards.length === 0 || loadingRewards || loadingAssign}
                        mb="md"
                        data-autofocus
                    />
                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={onClose} disabled={loadingAssign}>
                            {t('common.cancel')}
                        </Button>
                        <Button
                            onClick={handleAssign}
                            loading={loadingAssign}
                            disabled={!selectedRewardId || loadingRewards || rewards.length === 0}
                        >
                            {t('adminCustomersPage.assignRewardButton')}
                        </Button>
                    </Group>
                </>
            )}
            {!loadingRewards && !errorRewards && !customer && (
                <Text c="dimmed">{t('adminCustomersPage.noCustomerSelected')}</Text>
            )}
        </Modal>
    );
};

export default AssignRewardModal;


// ====== [156] frontend/src/modules/loyalpyme/components/admin/BulkAdjustPointsModal.tsx ======
// filename: frontend/src/components/admin/BulkAdjustPointsModal.tsx
import React, { useState, useEffect } from 'react';
import {
    Modal, NumberInput, TextInput, Button, Group, Stack
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { IconPlusMinus } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next'; // Importar hook

// Tipo inferido del esquema
type FormValues = z.infer<ReturnType<typeof createValidationSchema>>;

// Funci√≥n para crear el esquema de validaci√≥n (para poder usar t())
const createValidationSchema = (t: Function) => z.object({
  amount: z.number().refine(val => val !== 0, { message: t('validation.cannotBeZero', 'La cantidad no puede ser cero') }),
  reason: z.string().optional(),
});

interface BulkAdjustPointsModalProps {
    opened: boolean;
    onClose: () => void;
    onSubmit: (values: FormValues) => Promise<void>; // La funci√≥n que manejar√° la l√≥gica de env√≠o y notificaciones
    numberOfCustomers: number;
}

const BulkAdjustPointsModal: React.FC<BulkAdjustPointsModalProps> = ({
    opened,
    onClose,
    onSubmit,
    numberOfCustomers
}) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [isSubmitting, setIsSubmitting] = useState(false);

    const form = useForm<FormValues>({
        initialValues: { amount: 0, reason: '', },
        // Pasar t al crear el schema
        validate: zodResolver(createValidationSchema(t)),
    });

    useEffect(() => {
        if (opened) {
            form.reset();
            setIsSubmitting(false);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened]);

    const handleSubmit = async (values: FormValues) => {
        setIsSubmitting(true);
        try {
            await onSubmit(values);
            // Notificaciones y cierre manejados por el padre
        } catch (error) {
            console.error("Error during bulk adjust points submission callback:", error);
            // Notificaci√≥n de error manejada por el padre
        } finally {
            // Decidimos si resetear isSubmitting aqu√≠ o dejarlo al padre/reapertura
            // setIsSubmitting(false);
        }
    };

    // Usar t() para el t√≠tulo del modal
    const modalTitle = t('adminCustomersPage.bulkAdjustPointsModalTitle', { count: numberOfCustomers });

    return (
        <Modal
            opened={opened}
            onClose={() => { if(!isSubmitting) onClose(); }} // Prevenir cierre si est√° enviando
            title={modalTitle}
            centered
        >
            <form onSubmit={form.onSubmit(handleSubmit)}>
                <Stack>
                    <NumberInput
                        label={t('adminCustomersPage.bulkAdjustPointsAmountLabel')}
                        placeholder={t('adminCustomersPage.bulkAdjustPointsAmountPlaceholder')}
                        required
                        allowNegative
                        {...form.getInputProps('amount')}
                        disabled={isSubmitting}
                        data-autofocus // Enfocar este campo al abrir
                    />
                    <TextInput
                        label={t('adminCustomersPage.bulkAdjustPointsReasonLabel')}
                        placeholder={t('adminCustomersPage.bulkAdjustPointsReasonPlaceholder')}
                        {...form.getInputProps('reason')}
                        disabled={isSubmitting}
                    />
                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={onClose} disabled={isSubmitting}>
                            {t('common.cancel')}
                        </Button>
                        <Button
                            type="submit"
                            loading={isSubmitting}
                            leftSection={<IconPlusMinus size={16} />}
                            disabled={!form.isValid() || form.values.amount === 0 || isSubmitting}
                        >
                            {t('adminCustomersPage.bulkAdjustPointsButton')}
                        </Button>
                    </Group>
                </Stack>
            </form>
        </Modal>
    );
};

export default BulkAdjustPointsModal;


// ====== [157] frontend/src/modules/loyalpyme/components/admin/ChangeTierModal.tsx ======
// frontend/src/components/admin/ChangeTierModal.tsx
// Version 1.1.0 (Use adminCustomerService for API call)

import React, { useState, useEffect } from 'react';
import { Modal, Select, Button, Group, Text, Loader, Alert } from '@mantine/core';
// axiosInstance ya no es necesario aqu√≠ directamente
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX, IconAlertCircle } from '@tabler/icons-react';
import { Customer } from '../../hooks/useAdminCustomersData';
import { useTranslation } from 'react-i18next';

// --- NUEVO: Importar el servicio ---
import * as adminCustomerService from '../../services/adminCustomerService';
import axiosInstance from '../../../../shared/services/axiosInstance'; // A√∫n necesario para fetchTiers

// Interfaz para los Tiers (se mantiene igual)
interface TierOption {
    value: string;
    label: string;
}
interface TierFromApi { // Para la respuesta de la API de tiers
    id: string;
    name: string;
    level: number;
}

interface ChangeTierModalProps {
    opened: boolean;
    onClose: () => void;
    customer: Customer | null;
    onSuccess: () => void;
}

const ChangeTierModal: React.FC<ChangeTierModalProps> = ({ opened, onClose, customer, onSuccess }) => {
    const { t } = useTranslation();
    const [tiers, setTiers] = useState<TierOption[]>([]);
    const [selectedTierId, setSelectedTierId] = useState<string | null>(null);
    const [loadingTiers, setLoadingTiers] = useState(false);
    const [loadingChange, setLoadingChange] = useState(false);
    const [errorTiers, setErrorTiers] = useState<string | null>(null);

    useEffect(() => {
        if (opened && customer) {
            setLoadingTiers(true);
            setErrorTiers(null);
            // Inicializar con el tier actual del cliente o '' para "Sin Nivel"
            setSelectedTierId(customer.currentTier?.id || '');

            axiosInstance.get<TierFromApi[]>('/tiers') // La ruta es /api/tiers (el servicio de admin para obtener todos los tiers)
                .then(response => {
                    const sortedTiers = response.data.sort((a, b) => a.level - b.level);
                    const availableTiers: TierOption[] = [
                        { value: '', label: t('adminCustomersPage.changeTierOptionNone') }, // Opci√≥n para quitar tier
                        ...sortedTiers.map(tier => ({
                            value: tier.id,
                            label: `${tier.name} (${t('adminCustomersPage.changeTierOptionLevel', { level: tier.level })})`
                        }))
                    ];
                    setTiers(availableTiers);
                })
                .catch(err => {
                    console.error("Error fetching tiers for modal:", err);
                    const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
                    setErrorTiers(t('adminCustomersPage.changeTierErrorLoadingTiers', { error: apiError }));
                })
                .finally(() => {
                    setLoadingTiers(false);
                });
        } else if (!opened) {
            // Resetear al cerrar
            setSelectedTierId(null);
            setTiers([]);
            setErrorTiers(null);
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, customer, t]); // t como dependencia por si las claves cambian

    const handleChangeTier = async () => {
        if (!customer) return;

        const tierIdToSend = selectedTierId === '' ? null : selectedTierId; // '' representa "Sin Nivel"

        if (tierIdToSend === (customer.currentTier?.id || null)) {
            notifications.show({
                title: t('adminCustomersPage.changeTierNoChangeTitle'),
                message: t('adminCustomersPage.changeTierNoChange'),
                color: 'blue'
            });
            return;
        }

        setLoadingChange(true);
        try {
            // --- CAMBIO: Llamar al servicio en lugar de axiosInstance directamente ---
            await adminCustomerService.changeCustomerTierApi(customer.id, tierIdToSend);
            // --- FIN CAMBIO ---

            notifications.show({
                title: t('common.success'),
                message: t('adminCustomersPage.changeTierSuccess', { name: customer.name || customer.email }),
                color: 'green',
                icon: <IconCheck size={18} />,
            });
            onSuccess(); // Refrescar datos en la p√°gina principal
            onClose();   // Cerrar el modal
        } catch (error: any) {
            console.error("Error changing tier via modal:", error);
            const apiError = error.response?.data?.message || error.message || t('common.errorUnknown');
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.changeTierError', { error: apiError }),
                color: 'red',
                icon: <IconX size={18} />,
            });
        } finally {
            setLoadingChange(false);
        }
    };

    const modalTitle = t('adminCustomersPage.changeTierModalTitle', {
        name: customer?.name || customer?.email || t('common.customer')
    });
    const currentTierName = customer?.currentTier?.name || t('customerDashboard.baseTier');

    return (
        <Modal
            opened={opened}
            onClose={() => { if (!loadingChange) onClose(); }}
            title={modalTitle}
            centered
            trapFocus
            closeOnClickOutside={!loadingChange}
            closeOnEscape={!loadingChange}
        >
            {customer && (
                <Text size="sm" mb="xs">
                    {t('adminCustomersPage.changeTierCurrent', { tierName: currentTierName })}
                </Text>
            )}

            {loadingTiers && <Group justify="center"><Loader /></Group>}
            {errorTiers && !loadingTiers && (
                <Alert title={t('adminCustomersPage.changeTierLoadingErrorTitle')} color="red" icon={<IconAlertCircle />}>
                    {errorTiers}
                </Alert>
            )}

            {!loadingTiers && !errorTiers && customer && (
                <>
                    <Select
                        label={t('adminCustomersPage.changeTierSelectLabel')}
                        placeholder={t('adminCustomersPage.changeTierSelectPlaceholder')}
                        data={tiers}
                        value={selectedTierId ?? ''} // Usar '' si es null para que coincida con la opci√≥n "Sin Nivel"
                        onChange={(value) => setSelectedTierId(value)} // Select de Mantine devuelve string | null
                        searchable
                        nothingFoundMessage={t('adminCustomersPage.changeTierNotFound')}
                        disabled={loadingTiers || loadingChange || tiers.length === 0}
                        mb="md"
                        clearable={false} // La opci√≥n "Sin Nivel" maneja la "limpieza"
                    />
                    <Group justify="flex-end" mt="lg">
                        <Button variant="default" onClick={onClose} disabled={loadingChange}>
                            {t('common.cancel')}
                        </Button>
                        <Button
                            onClick={handleChangeTier}
                            loading={loadingChange}
                            disabled={loadingTiers || (selectedTierId ?? '') === (customer.currentTier?.id || '') || tiers.length === 0}
                        >
                            {t('adminCustomersPage.changeTierButton')}
                        </Button>
                    </Group>
                </>
            )}
            {!loadingTiers && !errorTiers && !customer && (
                <Text c="dimmed">{t('adminCustomersPage.noCustomerSelected')}</Text>
            )}
        </Modal>
    );
};

export default ChangeTierModal;


// ====== [158] frontend/src/modules/loyalpyme/components/admin/CustomerBulkActionsBar.tsx ======
// frontend/src/components/admin/CustomerBulkActionsBar.tsx
import React from 'react';
import { Paper, Group, Text, Button } from '@mantine/core';
import {
    IconPlayerPlay,
    IconPlayerStop,
    IconTrash,
    IconPlusMinus
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

interface CustomerBulkActionsBarProps {
    selectedRowCount: number;
    onBulkDelete: () => void;
    onBulkActivate: () => void; // Ser√° onBulkToggleActive(true)
    onBulkDeactivate: () => void; // Ser√° onBulkToggleActive(false)
    onOpenBulkAdjustPoints: () => void; // Para abrir el modal de ajuste masivo de puntos
    isPerformingBulkAction: boolean; // Para el estado de carga de los botones
}

const CustomerBulkActionsBar: React.FC<CustomerBulkActionsBarProps> = ({
    selectedRowCount,
    onBulkDelete,
    onBulkActivate,
    onBulkDeactivate,
    onOpenBulkAdjustPoints,
    isPerformingBulkAction,
}) => {
    const { t } = useTranslation();

    if (selectedRowCount === 0) {
        return null; // No mostrar nada si no hay filas seleccionadas
    }

    return (
        <Paper p="xs" mb="md" withBorder shadow="xs">
            <Group justify="space-between">
                <Text fw={500} size="sm">
                    {/* Usar clave i18n con pluralizaci√≥n para el conteo */}
                    {t('adminCustomersPage.selectedCount', { count: selectedRowCount })}
                </Text>
                <Group>
                    <Button
                        size="xs"
                        color="red"
                        variant="filled" // O 'outline' si se prefiere
                        leftSection={<IconTrash size={14} />}
                        onClick={onBulkDelete}
                        loading={isPerformingBulkAction} // Asumimos un solo estado de carga para todas las acciones masivas
                        disabled={isPerformingBulkAction}
                    >
                        {t('adminCustomersPage.bulkDeleteButton')}
                    </Button>
                    <Button
                        size="xs"
                        color="green"
                        variant="outline"
                        leftSection={<IconPlayerPlay size={14} />}
                        onClick={onBulkActivate}
                        loading={isPerformingBulkAction}
                        disabled={isPerformingBulkAction}
                    >
                        {t('adminCustomersPage.bulkActivateButton')}
                    </Button>
                    <Button
                        size="xs"
                        color="red" // Podr√≠a ser 'orange' o 'gray' tambi√©n
                        variant="outline"
                        leftSection={<IconPlayerStop size={14} />}
                        onClick={onBulkDeactivate}
                        loading={isPerformingBulkAction}
                        disabled={isPerformingBulkAction}
                    >
                        {t('adminCustomersPage.bulkDeactivateButton')}
                    </Button>
                    <Button
                        size="xs"
                        color="blue"
                        variant="outline"
                        leftSection={<IconPlusMinus size={14} />}
                        onClick={onOpenBulkAdjustPoints} // Esta prop abre el modal
                        disabled={isPerformingBulkAction} // Se deshabilita si otra acci√≥n masiva est√° en curso
                    >
                        {t('adminCustomersPage.bulkPointsButton')}
                    </Button>
                </Group>
            </Group>
        </Paper>
    );
};

export default CustomerBulkActionsBar;


// ====== [159] frontend/src/modules/loyalpyme/components/admin/CustomerDetailsModal.tsx ======
// filename: frontend/src/components/admin/CustomerDetailsModal.tsx
import React, { useState, useEffect } from 'react';
import {
    Modal, LoadingOverlay, Alert, Text, Group, Badge, Divider, Stack, ScrollArea,
    Textarea, Button
} from '@mantine/core';
import { IconAlertCircle, IconDeviceFloppy } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next'; // Importar hook

// Interfaz CustomerDetails
export interface CustomerDetails {
    id: string;
    email: string;
    name?: string | null;
    points: number;
    createdAt: string;
    isActive: boolean;
    isFavorite?: boolean | null;
    tierAchievedAt?: string | null;
    adminNotes?: string | null;
    businessId: string;
    role: string;
    currentTier?: {
        id: string;
        name: string;
        level: number;
        description?: string | null;
    } | null;
}

// Props del Modal
interface CustomerDetailsModalProps {
    opened: boolean;
    onClose: () => void;
    customerDetails: CustomerDetails | null;
    isLoading: boolean;
    error: string | null;
    onSaveNotes: (notes: string | null) => Promise<void>;
}

const CustomerDetailsModal: React.FC<CustomerDetailsModalProps> = ({
    opened,
    onClose,
    customerDetails,
    isLoading,
    error,
    onSaveNotes
}) => {
    const { t, i18n } = useTranslation(); // Hook de traducci√≥n
    const [editedNotes, setEditedNotes] = useState<string>('');
    const [isSaving, setIsSaving] = useState<boolean>(false);

    // Efecto para inicializar/resetear las notas editables
    useEffect(() => {
        if (opened && customerDetails) {
            setEditedNotes(customerDetails.adminNotes || '');
        }
    }, [opened, customerDetails]);

    // Funci√≥n para formatear fechas usando el idioma actual
    const formatDate = (dateString: string | null | undefined) => {
        if (!dateString) return 'N/A';
        try {
            // Usar i18n.language para el locale
            return new Date(dateString).toLocaleDateString(i18n.language, { day: '2-digit', month: '2-digit', year: 'numeric' });
        } catch {
            return t('common.invalidDate', 'Fecha inv√°lida'); // Clave i18n
        }
    };

    // Usar t() para el t√≠tulo del modal
    const modalTitle = t('adminCustomersPage.customerDetailsModalTitle', {
        name: customerDetails?.name || customerDetails?.email || t('common.customer', 'Cliente')
    });

    // Handler para Guardar Notas
    const handleSave = async () => {
        if (!customerDetails) return;
        setIsSaving(true);
        try {
            await onSaveNotes(editedNotes.trim() ? editedNotes.trim() : null);
            // Notificaciones y cierre los maneja el padre
        } catch (saveError) {
            console.error("Error during save callback execution in modal:", saveError);
            // El padre deber√≠a mostrar la notificaci√≥n de error
        } finally {
            setIsSaving(false);
        }
    };

    return (
        <Modal opened={opened} onClose={onClose} title={modalTitle} size="lg" centered scrollAreaComponent={ScrollArea.Autosize} >
            <LoadingOverlay visible={isLoading} zIndex={1000} overlayProps={{ radius: "sm", blur: 2 }} />
            {error && !isLoading && (
                // Usar t() para el t√≠tulo del Alert
                <Alert icon={<IconAlertCircle size="1rem" />} title={t('adminCustomersPage.customerDetailsLoadingError')} color="red">
                    {error}
                </Alert>
            )}

            {!isLoading && !error && customerDetails && (
                <Stack gap="sm">
                    {/* Usar t() para las etiquetas */}
                    <Group justify="space-between"> <Text fw={500}>{t('common.email')}:</Text> <Text>{customerDetails.email}</Text> </Group>
                    <Group justify="space-between"> <Text fw={500}>{t('common.name')}:</Text> <Text>{customerDetails.name || '-'}</Text> </Group>
                    <Divider my="xs" />
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsPoints')}</Text> <Text fw={700} c="blue">{customerDetails.points}</Text> </Group>
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsTier')}</Text> <Badge color={customerDetails.currentTier ? 'teal' : 'gray'} variant="light"> {customerDetails.currentTier?.name || t('customerDashboard.baseTier')} </Badge> </Group>
                    {customerDetails.currentTier?.description && ( <Text size="sm" c="dimmed"> {customerDetails.currentTier.description} </Text> )}
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsTierDate')}</Text> <Text>{formatDate(customerDetails.tierAchievedAt)}</Text> </Group>
                    <Divider my="xs" />
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsStatus')}</Text> <Badge color={customerDetails.isActive ? 'green' : 'red'} variant="filled"> {customerDetails.isActive ? t('common.active') : t('common.inactive')} </Badge> </Group>
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsFavorite')}</Text> <Text>{customerDetails.isFavorite ? t('common.yes') : t('common.no')}</Text> </Group>
                    <Group justify="space-between"> <Text fw={500}>{t('adminCustomersPage.customerDetailsRegisteredDate')}</Text> <Text>{formatDate(customerDetails.createdAt)}</Text> </Group>

                    <Divider my="sm" />
                    <Textarea
                        label={t('adminCustomersPage.customerDetailsAdminNotesLabel')}
                        placeholder={t('adminCustomersPage.customerDetailsAdminNotesPlaceholder')}
                        value={editedNotes}
                        onChange={(event) => setEditedNotes(event.currentTarget.value)}
                        minRows={4}
                        autosize
                        disabled={isSaving}
                    />
                    <Group justify="flex-end" mt="md">
                        <Button
                            variant="filled"
                            onClick={handleSave}
                            loading={isSaving}
                            leftSection={<IconDeviceFloppy size={16} />}
                            disabled={editedNotes === (customerDetails.adminNotes || '') || isSaving}
                        >
                            {t('adminCustomersPage.customerDetailsSaveNotesButton')}
                        </Button>
                    </Group>
                </Stack>
            )}
            {!isLoading && !error && !customerDetails && (
                <Text c="dimmed">{t('adminCustomersPage.customerDetailsNoDetails')}</Text>
            )}
        </Modal>
    );
};

export default CustomerDetailsModal;


// ====== [160] frontend/src/modules/loyalpyme/components/admin/CustomerFiltersBar.tsx ======
// frontend/src/components/admin/CustomerFiltersBar.tsx
import React from 'react';
import { Paper, Group, Text, TextInput, Select, Checkbox } from '@mantine/core';
import { IconSearch, IconFilter } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

// Tipo para las opciones del Select de Tier (debe coincidir con el de la p√°gina principal)
export interface TierOption {
    value: string;
    label: string;
}

interface CustomerFiltersBarProps {
    searchTerm: string;
    onSearchTermChange: (term: string) => void;
    activeFilterValue: string; // '', 'active', 'inactive'
    onActiveFilterChange: (value: string | null) => void;
    isFavoriteFilterChecked: boolean;
    onIsFavoriteFilterChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
    tierFilterValue: string; // ID del tier, 'NONE', o '' para todos
    onTierFilterChange: (value: string | null) => void;
    tierOptions: TierOption[]; // Opciones para el selector de Tier
    loadingFilters: boolean; // Para deshabilitar inputs mientras cargan datos (ej. tiers)
    disabled: boolean; // Para deshabilitar todos los filtros si la tabla principal est√° cargando
}

const CustomerFiltersBar: React.FC<CustomerFiltersBarProps> = ({
    searchTerm,
    onSearchTermChange,
    activeFilterValue,
    onActiveFilterChange,
    isFavoriteFilterChecked,
    onIsFavoriteFilterChange,
    tierFilterValue,
    onTierFilterChange,
    tierOptions,
    loadingFilters, // Usado para deshabilitar select de tier mientras carga
    disabled,       // Usado para deshabilitar todo mientras la tabla carga
}) => {
    const { t } = useTranslation();

    return (
        <Paper p="md" withBorder radius="md" shadow="xs">
            <Group>
                <IconFilter size={18} />
                <Text fw={500} size="sm">{t('adminCustomersPage.filterLabel')}</Text>
                <TextInput
                    placeholder={t('adminCustomersPage.searchPlaceholder')}
                    leftSection={<IconSearch size={16} stroke={1.5} />}
                    value={searchTerm}
                    onChange={(event) => onSearchTermChange(event.currentTarget.value)}
                    radius="md"
                    style={{ flex: 1, minWidth: 200 }} // Darle flexibilidad y un m√≠nimo
                    disabled={disabled}
                />
                <Select
                    placeholder={t('adminCustomersPage.statusFilterPlaceholder')}
                    data={[
                        { value: '', label: t('adminCustomersPage.statusFilterAll') },
                        { value: 'active', label: t('adminCustomersPage.statusFilterActive') },
                        { value: 'inactive', label: t('adminCustomersPage.statusFilterInactive') }
                    ]}
                    value={activeFilterValue}
                    onChange={onActiveFilterChange}
                    clearable={false} // Para que siempre haya una opci√≥n (aunque sea 'todos')
                    radius="md"
                    disabled={disabled}
                    style={{ minWidth: 150 }}
                />
                <Checkbox
                    label={t('adminCustomersPage.favoriteFilterLabel')}
                    checked={isFavoriteFilterChecked}
                    onChange={onIsFavoriteFilterChange}
                    disabled={disabled}
                />
                <Select
                    placeholder={t('adminCustomersPage.tierFilterPlaceholder')}
                    data={tierOptions} // Las opciones vienen del componente padre
                    value={tierFilterValue}
                    onChange={onTierFilterChange}
                    disabled={disabled || loadingFilters} // Deshabilitar si los tiers est√°n cargando
                    searchable
                    nothingFoundMessage={t('adminCustomersPage.tierFilterError')} // Reutilizar clave
                    clearable={false} // Para que siempre haya una opci√≥n (ej. 'todos')
                    radius="md"
                    style={{ minWidth: 180 }}
                />
            </Group>
        </Paper>
    );
};

export default CustomerFiltersBar;


// ====== [161] frontend/src/modules/loyalpyme/components/admin/CustomerTable.tsx ======
// filename: frontend/src/components/admin/CustomerTable.tsx
import React from 'react';
import {
    Table, Group, ActionIcon, Text, useMantineTheme, UnstyledButton, Center, rem,
    Checkbox, Badge
} from '@mantine/core';
import {
    IconAdjustments, IconGift, IconEye, IconStar,
    IconStairsUp, IconSelector, IconChevronDown, IconChevronUp,
    IconEyeCheck, IconEyeOff
} from '@tabler/icons-react';
import classes from '../../pages/admin/AdminCustomerManagementPage.module.css';
import { useTranslation } from 'react-i18next'; // Importar hook

// Importar tipos necesarios desde el hook
import { Customer, SortStatus, SortColumn } from '../../hooks/useAdminCustomersData';

// --- Componente Th Auxiliar ---
interface ThProps {
    children: React.ReactNode;
    reversed: boolean;
    sorted: boolean;
    onSort(): void;
    sortKey: SortColumn;
    currentSortKey: SortColumn;
    disabled?: boolean;
}

function Th({ children, reversed, sorted, onSort, sortKey, currentSortKey, disabled }: ThProps) {
    const Icon = sorted && currentSortKey === sortKey ? (reversed ? IconChevronUp : IconChevronDown) : IconSelector;
    const isCurrent = sorted && currentSortKey === sortKey;
    return (
        <Table.Th className={classes.th}>
            <UnstyledButton onClick={disabled ? undefined : onSort} className={classes.control} disabled={disabled}>
                <Group justify="space-between" gap={0} data-active-sort={isCurrent || undefined}>
                    <Text fw={500} fz="sm" span>{children}</Text>
                    {!disabled && (
                        <Center className={classes.icon}>
                            <Icon style={{ width: rem(16), height: rem(16), color: isCurrent ? 'var(--mantine-color-blue-filled)' : undefined }} stroke={1.5} />
                        </Center>
                    )}
                </Group>
            </UnstyledButton>
        </Table.Th>
    );
}
// --- Fin Componente Th ---

// --- Props del Componente CustomerTable ---
interface CustomerTableProps {
    customers: Customer[];
    sortStatus: SortStatus;
    togglingFavoriteId: string | null;
    togglingActiveId?: string | null;
    selectedRows: string[];
    onSort: (column: SortColumn) => void;
    onToggleFavorite: (customerId: string, currentIsFavorite: boolean) => void;
    onOpenAdjustPoints: (customer: Customer) => void;
    onOpenChangeTier: (customer: Customer) => void;
    onOpenAssignReward: (customer: Customer) => void;
    onViewDetails: (customer: Customer) => void;
    onToggleActive: (customer: Customer) => void;
    onRowSelectionChange: (selectedIds: string[]) => void;
}
// --- Fin Props ---

// --- COMPONENTE PRINCIPAL: AdminCustomerTable ---
const CustomerTable: React.FC<CustomerTableProps> = ({
    customers,
    sortStatus,
    togglingFavoriteId,
    togglingActiveId,
    selectedRows,
    onSort,
    onToggleFavorite,
    onOpenAdjustPoints,
    onOpenChangeTier,
    onOpenAssignReward,
    onViewDetails,
    onToggleActive,
    onRowSelectionChange
}) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const theme = useMantineTheme();

    // L√≥gica de Selecci√≥n
    const allVisibleSelected = customers.length > 0 && customers.every(customer => selectedRows.includes(customer.id));
    const someVisibleSelected = customers.some(customer => selectedRows.includes(customer.id));
    const indeterminate = someVisibleSelected && !allVisibleSelected;

    const handleSelectAllClick = () => {
        if (allVisibleSelected) {
            const visibleIds = customers.map(c => c.id);
            onRowSelectionChange(selectedRows.filter(id => !visibleIds.includes(id)));
        } else {
            const visibleIds = customers.map(c => c.id);
            onRowSelectionChange(Array.from(new Set([...selectedRows, ...visibleIds])));
        }
    };

    const handleRowCheckboxChange = (customerId: string, checked: boolean) => {
        if (checked) { onRowSelectionChange([...selectedRows, customerId]); }
        else { onRowSelectionChange(selectedRows.filter(id => id !== customerId)); }
    };

    // Mapeo de filas
    const rows = customers.map((customer) => {
        const isActive = customer.isActive ?? false;
        // Usar t() para los t√≠tulos de los tooltips de activar/desactivar
        const ToggleIcon = isActive ? IconEyeOff : IconEyeCheck;
        const toggleTitle = isActive ? t('adminCustomersPage.tooltipDeactivateCustomer') : t('adminCustomersPage.tooltipActivateCustomer');
        const toggleColor = isActive ? 'red' : 'green';
        const isTogglingThisActive = togglingActiveId === customer.id;
        const isTogglingThisFavorite = togglingFavoriteId === customer.id;
        const isSelected = selectedRows.includes(customer.id);
        const favoriteTooltip = customer.isFavorite
            ? t('adminCustomersPage.tooltipUnfavorite', 'Quitar de Favoritos')
            : t('adminCustomersPage.tooltipFavorite', 'Marcar como Favorito');

        return (
            <Table.Tr key={customer.id} bg={isSelected ? theme.colors.blue[0] : undefined}>
                <Table.Td>
                    <Checkbox
                        aria-label={t('adminCustomersPage.checkboxAriaLabel', `Seleccionar fila ${customer.id}`)} // Nueva clave i18n
                        checked={isSelected}
                        onChange={(event) => handleRowCheckboxChange(customer.id, event.currentTarget.checked)}
                    />
                </Table.Td>
                <Table.Td>
                    <ActionIcon
                        variant="subtle"
                        onClick={() => onToggleFavorite(customer.id, customer.isFavorite ?? false)}
                        loading={isTogglingThisFavorite}
                        disabled={!!togglingFavoriteId || !!togglingActiveId}
                        title={favoriteTooltip} // Usar variable con clave i18n
                    >
                        <IconStar size={18} stroke={1.5} color={customer.isFavorite ? theme.colors.yellow[6] : theme.colors.gray[4]} fill={customer.isFavorite ? theme.colors.yellow[6] : 'none'} />
                    </ActionIcon>
                </Table.Td>
                <Table.Td>{customer.name || '-'}</Table.Td>
                <Table.Td>{customer.email}</Table.Td>
                <Table.Td ta="right">{customer.points}</Table.Td>
                <Table.Td>{customer.currentTier?.name || t('customerDashboard.baseTier')}</Table.Td>
                <Table.Td>{new Date(customer.createdAt).toLocaleDateString()}</Table.Td>
                <Table.Td> <Badge color={isActive ? 'green' : 'red'} variant="light"> {isActive ? t('common.active') : t('common.inactive')} </Badge> </Table.Td>
                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        <ActionIcon variant="subtle" color="gray" title={t('adminCustomersPage.tooltipViewDetails')} onClick={() => onViewDetails(customer)} disabled={isTogglingThisActive || isTogglingThisFavorite}><IconEye size={16} stroke={1.5} /></ActionIcon>
                        <ActionIcon variant="subtle" color="blue" title={t('adminCustomersPage.tooltipAdjustPoints')} onClick={() => onOpenAdjustPoints(customer)} disabled={isTogglingThisActive || isTogglingThisFavorite}><IconAdjustments size={16} stroke={1.5} /></ActionIcon>
                        <ActionIcon variant="subtle" color="teal" title={t('adminCustomersPage.tooltipChangeTier')} onClick={() => onOpenChangeTier(customer)} disabled={isTogglingThisActive || isTogglingThisFavorite}><IconStairsUp size={16} stroke={1.5} /></ActionIcon>
                        <ActionIcon variant="subtle" color="grape" title={t('adminCustomersPage.tooltipAssignReward')} onClick={() => onOpenAssignReward(customer)} disabled={isTogglingThisActive || isTogglingThisFavorite}><IconGift size={16} stroke={1.5} /></ActionIcon>
                        <ActionIcon variant="subtle" color={toggleColor} title={toggleTitle} onClick={() => onToggleActive(customer)} loading={isTogglingThisActive} disabled={!!togglingFavoriteId || !!togglingActiveId}><ToggleIcon size={16} stroke={1.5} /></ActionIcon>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    // Renderizado de la tabla
    return (
        <Table.ScrollContainer minWidth={800}>
            <Table striped highlightOnHover withTableBorder verticalSpacing="sm" className={classes.table}>
                <Table.Thead className={classes.thead}>
                    <Table.Tr>
                        <Table.Th style={{ width: rem(40) }}>
                            <Checkbox
                                aria-label={t('adminCustomersPage.checkboxSelectAllAriaLabel', 'Seleccionar todas las filas visibles')} // Nueva clave i18n
                                checked={allVisibleSelected}
                                indeterminate={indeterminate}
                                onChange={handleSelectAllClick}
                            />
                        </Table.Th>
                        <Th sorted={sortStatus.column === 'isFavorite'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('isFavorite')} sortKey="isFavorite" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderFavorite')}</Th>
                        <Th sorted={sortStatus.column === 'name'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('name')} sortKey="name" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderName')}</Th>
                        <Th sorted={sortStatus.column === 'email'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('email')} sortKey="email" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderEmail')}</Th>
                        <Th sorted={sortStatus.column === 'points'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('points')} sortKey="points" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderPoints')}</Th>
                        <Th sorted={sortStatus.column === 'currentTier.level'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('currentTier.level')} sortKey="currentTier.level" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderTier')}</Th>
                        <Th sorted={sortStatus.column === 'createdAt'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('createdAt')} sortKey="createdAt" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderRegistered')}</Th>
                        <Th sorted={sortStatus.column === 'isActive'} reversed={sortStatus.direction === 'desc'} onSort={() => onSort('isActive')} sortKey="isActive" currentSortKey={sortStatus.column}>{t('adminCustomersPage.tableHeaderStatus')}</Th>
                        <Table.Th style={{ textAlign: 'right' }}>{t('adminCustomersPage.tableHeaderActions')}</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>{rows.length > 0 ? rows : (
                    <Table.Tr><Table.Td colSpan={9}><Text c="dimmed" ta="center">{t('adminCustomersPage.noResults')}</Text></Table.Td></Table.Tr>
                 )}</Table.Tbody>
            </Table>
        </Table.ScrollContainer>
    );
};

export default CustomerTable;


// ====== [162] frontend/src/modules/loyalpyme/components/admin/StatCard.module.css ======
/* filename: frontend/src/components/admin/StatCard.module.css */
.card {
    position: relative;
    overflow: hidden;
    background-color: var(--mantine-color-body); /* Asegura fondo */
  }
  
  .value {
    font-size: var(--mantine-font-size-xl); /* Usa variable Mantine o rem(24px) */
    font-weight: 700;
    line-height: 1.3; 
  }
  
  .label {
    font-size: var(--mantine-font-size-xs);
    line-height: var(--mantine-line-height-xs);
    color: var(--mantine-color-dimmed);
    text-transform: uppercase; /* A√±adido para coincidir con dise√±o com√∫n */
  }


// ====== [163] frontend/src/modules/loyalpyme/components/admin/StatCard.test.tsx ======
// filename: frontend/src/components/admin/StatCard.test.tsx
// Version: 1.0.2 (Import screen directly from @testing-library/dom)

import React from 'react';
// --- CAMBIO: Importar render y screen por separado ---
import { render } from '@testing-library/react';
import { screen } from '@testing-library/dom';
// --- FIN CAMBIO ---
import { describe, it, expect } from 'vitest';
import StatCard from './StatCard';
import { IconUsers } from '@tabler/icons-react';
import { MantineProvider } from '@mantine/core';
import { theme } from '../../theme';

describe('StatCard Component', () => {

    const renderWithTheme = (ui: React.ReactElement) => {
        return render(<MantineProvider theme={theme}>{ui}</MantineProvider>);
    };

    it('should render title and value correctly', () => {
        renderWithTheme(<StatCard title="CLIENTES" value={123} />);
        expect(screen.getByText('CLIENTES')).toBeInTheDocument();
        expect(screen.getByText('123')).toBeInTheDocument();
    });

    it('should render icon when provided', () => {
        renderWithTheme(<StatCard title="Test" value={10} icon={<IconUsers data-testid="users-icon" size={24}/>} />);
        expect(screen.getByTestId('users-icon')).toBeInTheDocument();
    });

    it('should render "-" when value is null or undefined', () => {
        const { rerender } = renderWithTheme(<StatCard title="Test Null" value={null} />);
        expect(screen.getByText('-')).toBeInTheDocument();

        rerender(<MantineProvider theme={theme}><StatCard title="Test Undefined" value={undefined} /></MantineProvider>);
        expect(screen.getByText('-')).toBeInTheDocument();
    });

    it('should render trend up icon and value correctly', () => {
        renderWithTheme(<StatCard title="Trend Up" value={100} trendValue="+10.5%" trendDirection="up" />);
        expect(screen.getByText('+10.5%')).toBeInTheDocument();
    });

    it('should render trend down icon and value correctly', () => {
        renderWithTheme(<StatCard title="Trend Down" value={90} trendValue="-5.0%" trendDirection="down" />);
        expect(screen.getByText('-5.0%')).toBeInTheDocument();
    });

     it('should render neutral trend value without arrow', () => {
        const { rerender } = renderWithTheme(<StatCard title="Trend Neutral" value={100} trendValue="N/A" trendDirection="neutral" />);
        expect(screen.getByText('N/A')).toBeInTheDocument();

        rerender(<MantineProvider theme={theme}><StatCard title="Trend Zero" value={100} trendValue="+0.0%" trendDirection="neutral" /></MantineProvider>);
        expect(screen.getByText('+0.0%')).toBeInTheDocument();
    });

    it('should not render trend section if trendValue is null/undefined', () => {
        renderWithTheme(<StatCard title="No Trend" value={100} trendValue={null} trendDirection="neutral" />);
        expect(screen.queryByText(/%/)).not.toBeInTheDocument();
        expect(screen.queryByText('+')).not.toBeInTheDocument();
    });

    it('should display skeletons when loading', () => {
        renderWithTheme(<StatCard title="Loading Test" value={null} loading={true} />);
        expect(screen.queryByText(/-/)).not.toBeInTheDocument();
        expect(screen.getByText('Loading Test')).toBeInTheDocument();
    });

});


// ====== [164] frontend/src/modules/loyalpyme/components/admin/StatCard.tsx ======
// filename: frontend/src/components/admin/StatCard.tsx
import React from 'react';
import { Paper, Group, Text, ThemeIcon, Skeleton, MantineColor, useMantineTheme, Stack } from '@mantine/core';
import { IconArrowUpRight, IconArrowDownRight } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import classes from './StatCard.module.css';

// Tipo para la direcci√≥n de la tendencia
type TrendDirection = 'up' | 'down' | 'neutral';

// Props que acepta nuestro componente StatCard
interface StatCardProps {
  title: string;
  value: number | string | null | undefined;
  icon?: React.ReactNode;
  loading?: boolean;
  color?: MantineColor;
  trendValue?: string | null | undefined; // Aseguramos que trendValue siempre sea string o null/undefined
  trendDirection?: TrendDirection | null | undefined;
}

const StatCard: React.FC<StatCardProps> = ({
  title,
  value,
  icon,
  loading,
  color = 'gray',
  trendValue, // Recibe el string formateado o null/undefined desde el hook
  trendDirection,
}) => {
  const { i18n } = useTranslation(); // Solo para i18n.language
  const theme = useMantineTheme();

  // Formateo del valor principal (sin cambios)
  const displayValue = loading || value === null || value === undefined
    ? '-'
    : typeof value === 'number' ? value.toLocaleString(i18n.language) : value;

  // Determinar icono y color de la tendencia (sin cambios)
  let TrendIcon = null;
  let trendColor: MantineColor = 'dimmed';
  if (trendDirection === 'up') {
    TrendIcon = IconArrowUpRight;
    trendColor = 'teal';
  } else if (trendDirection === 'down') {
    TrendIcon = IconArrowDownRight;
    trendColor = 'red';
  }

  // **CORRECCI√ìN:** No necesitamos formatear `trendValue` aqu√≠, ya viene formateado.
  // Simplemente comprobamos si existe para renderizar la secci√≥n de tendencia.
  const displayTrendValue = trendValue; // Usamos directamente el valor recibido
  const renderTrend = displayTrendValue !== null && displayTrendValue !== undefined && trendDirection;

  return (
    <Paper withBorder p="md" radius="md" className={classes.card}>
      <Group justify="space-between" wrap="nowrap" align="flex-start">
        <Stack gap={0}>
          <Text c="dimmed" tt="uppercase" fw={700} fz="xs" className={classes.label}>
            {title}
          </Text>
          {loading ? (
            <Skeleton height={28} mt={5} width={70} />
          ) : (
             <Text fw={700} fz="xl" className={classes.value} c={color}>
               {displayValue}
             </Text>
          )}
        </Stack>

        {icon && !loading && (
          <ThemeIcon color={color} variant="light" size={38} radius="md">
            {icon}
          </ThemeIcon>
        )}
         {loading && (
            <Skeleton height={38} width={38} radius="md" />
         )}
      </Group>

      {/* Mostramos la tendencia si renderTrend es true */}
      {!loading && renderTrend && (
           <Group gap={4} mt={5} wrap="nowrap">
               {TrendIcon && <TrendIcon size={16} stroke={1.5} color={theme.colors[trendColor][6]} />}
               <Text c={trendColor} fz="xs" fw={500}>
                   {displayTrendValue} {/* Mostramos el string directamente */}
               </Text>
           </Group>
      )}
    </Paper>
  );
};

export default StatCard;


// ====== [165] frontend/src/modules/loyalpyme/components/admin/rewards/RewardForm.tsx ======
// frontend/src/components/admin/rewards/RewardForm.tsx
// Version 2.0.2 (Remove unused imports)

import { useState, useEffect } from 'react';
import {
    TextInput, Textarea, NumberInput, Button, Stack, Group, Text as MantineText
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import axiosInstance from '../../../../../shared/services/axiosInstance';
import type { Reward } from '../../../../../shared/types/user.types';

// Importar el nuevo componente reutilizable
import ImageUploadCropper from '../../../../../shared/components/utils/ImageUploadCropper';

// Schema de Zod para la validaci√≥n del formulario
const createRewardFormSchema = (t: Function) => z.object({
  name_es: z.string().min(1, { message: t('component.rewardForm.errorNameEsRequired') }),
  name_en: z.string().min(1, { message: t('component.rewardForm.errorNameEnRequired') }),
  description_es: z.string().optional(),
  description_en: z.string().optional(),
  pointsCost: z.number().min(0, { message: t('component.rewardForm.errorPointsCostInvalid') }),
  imageUrl: z.string().url({ message: t('validation.invalidUrl') }).nullable().optional(),
});

type RewardFormValues = z.infer<ReturnType<typeof createRewardFormSchema>>;

interface RewardFormProps {
    mode: 'add' | 'edit';
    initialData?: Reward | null;
    rewardIdToUpdate?: string | null;
    onSubmitSuccess: () => void;
    onCancel: () => void;
}

const RewardForm: React.FC<RewardFormProps> = ({
    mode, initialData, rewardIdToUpdate, onSubmitSuccess, onCancel
}) => {
    const { t } = useTranslation();
    const [isSubmitting, setIsSubmitting] = useState<boolean>(false);

    const form = useForm<RewardFormValues>({
        initialValues: {
            name_es: '', name_en: '', description_es: '', description_en: '',
            pointsCost: 0, imageUrl: null,
        },
        validate: zodResolver(createRewardFormSchema(t)),
    });

    useEffect(() => {
        if (mode === 'edit' && initialData) {
            form.setValues({
                name_es: initialData.name_es || '',
                name_en: initialData.name_en || '',
                description_es: initialData.description_es || '',
                description_en: initialData.description_en || '',
                pointsCost: initialData.pointsCost ?? 0,
                imageUrl: initialData.imageUrl || null,
            });
        } else {
            form.reset();
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [mode, initialData]);

    const handleSubmit = async (values: RewardFormValues) => {
        setIsSubmitting(true);
        const payload = {
            ...values,
            description_es: values.description_es?.trim() || null,
            description_en: values.description_en?.trim() || null,
        };
        
        try {
            let successMessage = '';
            let savedReward: Reward | null = null;
            if (mode === 'add') {
                const response = await axiosInstance.post<Reward>('/rewards', payload);
                savedReward = response.data;
                successMessage = t('adminRewardsPage.createSuccessMessage', { name: savedReward.name_es });
            } else {
                if (!rewardIdToUpdate) throw new Error(t('component.rewardForm.errorMissingIdForUpdate'));
                const response = await axiosInstance.patch<Reward>(`/rewards/${rewardIdToUpdate}`, payload);
                savedReward = response.data;
                successMessage = t('adminRewardsPage.updateSuccessMessage', { name: savedReward.name_es });
            }
            
            notifications.show({
                title: t('common.success'),
                message: successMessage,
                color: 'green', icon: <IconCheck size={18} />,
            });
            onSubmitSuccess();
        } catch (err: any) {
            const errorMessage = err.response?.data?.message || err.message || t('common.errorUnknown');
            notifications.show({
                title: t('common.error'),
                message: errorMessage,
                color: 'red', icon: <IconX size={18} />,
            });
        } finally {
            setIsSubmitting(false);
        }
    };

    const submitButtonText = mode === 'add' ? t('adminRewardsPage.addButton') : t('common.save');

    return (
        <Stack gap="md">
            <form onSubmit={form.onSubmit(handleSubmit)}>
                <Stack gap="md">
                    <TextInput label={t('component.rewardForm.nameEsLabel')} placeholder={t('component.rewardForm.nameEsPlaceholder')} required disabled={isSubmitting} {...form.getInputProps('name_es')} />
                    <TextInput label={t('component.rewardForm.nameEnLabel')} placeholder={t('component.rewardForm.nameEnPlaceholder')} required disabled={isSubmitting} {...form.getInputProps('name_en')} />
                    <Textarea label={t('component.rewardForm.descriptionEsLabel')} placeholder={t('component.rewardForm.descriptionEsPlaceholder')} rows={2} disabled={isSubmitting} {...form.getInputProps('description_es')} />
                    <Textarea label={t('component.rewardForm.descriptionEnLabel')} placeholder={t('component.rewardForm.descriptionEnPlaceholder')} rows={2} disabled={isSubmitting} {...form.getInputProps('description_en')} />
                    <NumberInput label={t('component.rewardForm.pointsCostLabel')} placeholder={t('component.rewardForm.pointsCostPlaceholder')} min={0} step={1} required disabled={isSubmitting} {...form.getInputProps('pointsCost')} />
                    
                    {/* Componente reutilizable de subida y recorte */}
                    <ImageUploadCropper
                        aspectRatio={1}
                        minDimension={150}
                        initialImageUrl={form.values.imageUrl || null}
                        onUploadSuccess={(url) => form.setFieldValue('imageUrl', url)}
                        onUploadError={(errorMsg) => form.setFieldError('imageUrl', errorMsg)}
                        onClearImage={() => form.setFieldValue('imageUrl', null)}
                        folderName="loyalpyme/rewards"
                        disabled={isSubmitting}
                        imagePreviewAltText={t('component.rewardForm.altImagePreview', { name: form.values.name_es })}
                    />
                    {form.errors.imageUrl && (
                        <MantineText c="red" size="xs" mt={-10}>{form.errors.imageUrl}</MantineText>
                    )}

                    <Group justify="flex-end" mt="md">
                        <Button variant="light" onClick={onCancel} disabled={isSubmitting}> {t('common.cancel')} </Button>
                        <Button type="submit" loading={isSubmitting}> {submitButtonText} </Button>
                    </Group>
                </Stack>
            </form>
        </Stack>
    );
};

export default RewardForm;


// ====== [166] frontend/src/modules/loyalpyme/components/admin/tiers/AddTierBenefitForm.tsx ======
// filename: frontend/src/components/admin/tiers/AddTierBenefitForm.tsx
import React from 'react';
import { TextInput, Textarea, Select, Switch, Stack } from '@mantine/core';
import { UseFormReturnType } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next'; // Importar hook

// --- Tipos/Enums ---
export enum BenefitType {
    POINTS_MULTIPLIER = 'POINTS_MULTIPLIER',
    EXCLUSIVE_REWARD_ACCESS = 'EXCLUSIVE_REWARD_ACCESS',
    CUSTOM_BENEFIT = 'CUSTOM_BENEFIT'
}

// Este schema no se usa directamente aqu√≠ para validar, pero define el tipo
const benefitFormSchema = z.object({
    type: z.nativeEnum(BenefitType),
    value: z.string().min(1),
    description: z.string().optional(),
    isActive: z.boolean(),
});
export type BenefitFormValues = z.infer<typeof benefitFormSchema>;
// --- Fin Tipos/Enums ---


// --- Props del Componente ---
interface AddTierBenefitFormProps {
    form: UseFormReturnType<BenefitFormValues>;
    isSubmitting: boolean;
}
// --- Fin Props ---

const AddTierBenefitForm: React.FC<AddTierBenefitFormProps> = ({ form, isSubmitting }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n

    // Las etiquetas para las opciones del Select se generan en el componente padre (TierBenefitsModal)
    // usando t(), aqu√≠ solo necesitamos los valores del enum.
    const typeOptions = Object.values(BenefitType).map(value => ({
        value: value,
        label: t(`component.addTierBenefitForm.benefitType_${value}`) // Usar t() para la etiqueta si fuera necesario aqu√≠, pero se hace en el padre
    }));

    return (
        <Stack gap="sm">
            <Select
                label={t('component.addTierBenefitForm.typeLabel')}
                placeholder={t('component.addTierBenefitForm.typePlaceholder')}
                data={typeOptions} // Las etiquetas ya vienen traducidas del padre
                required
                disabled={isSubmitting}
                {...form.getInputProps('type')}
            />
            <TextInput
                label={t('component.addTierBenefitForm.valueLabel')}
                placeholder={t('component.addTierBenefitForm.valuePlaceholder')}
                description={t('component.addTierBenefitForm.valueDescription')}
                required
                disabled={isSubmitting}
                {...form.getInputProps('value')}
            />
            <Textarea
                label={t('component.addTierBenefitForm.descriptionLabel')}
                placeholder={t('component.addTierBenefitForm.descriptionPlaceholder')}
                rows={2}
                disabled={isSubmitting}
                {...form.getInputProps('description')}
            />
            <Switch
                label={t('component.addTierBenefitForm.activeLabel')}
                disabled={isSubmitting}
                {...form.getInputProps('isActive', { type: 'checkbox' })}
            />
        </Stack>
    );
};

export default AddTierBenefitForm;


// ====== [167] frontend/src/modules/loyalpyme/components/admin/tiers/CreateTierModal.tsx ======
// filename: frontend/src/components/admin/tiers/CreateTierModal.tsx
import React, { useState } from 'react';
import { Modal, Button, Group } from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { notifications } from '@mantine/notifications';
import { IconDeviceFloppy, IconCheck, IconAlertCircle } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';
import TierForm from './TierForm'; // Este componente tambi√©n necesitar√° i18n
import { useTranslation } from 'react-i18next'; // Importar hook

// Tipos
interface Tier { id: string; name: string; level: number; /* ... otros campos si los devuelve la API ... */ }

// Funci√≥n para crear el esquema Zod, aceptando t
const createTierFormSchema = (t: Function) => z.object({
    name: z.string().min(1, { message: t('validation.nameRequired', 'El nombre es obligatorio') }),
    level: z.number().int().min(0, { message: t('validation.levelMin0', 'El nivel debe ser 0 o mayor') }),
    minValue: z.number().min(0, { message: t('validation.minValueMin0', 'El valor m√≠nimo debe ser 0 o mayor') }),
    description: z.string().optional(),
    benefitsDescription: z.string().optional(),
    isActive: z.boolean(),
});

// Tipo inferido del schema
type TierFormValues = z.infer<ReturnType<typeof createTierFormSchema>>;

// Props
interface CreateTierModalProps {
    opened: boolean;
    onClose: () => void;
    onSuccess: (newTier: Tier) => void;
}

const CreateTierModal: React.FC<CreateTierModalProps> = ({ opened, onClose, onSuccess }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [isCreating, setIsCreating] = useState<boolean>(false);

    // useForm - pasar t al resolver
    const form = useForm<TierFormValues>({
        initialValues: { name: '', level: 0, minValue: 0, description: '', benefitsDescription: '', isActive: true, },
        validate: zodResolver(createTierFormSchema(t)),
    });

    // handleSubmit
    const handleSubmit = async (values: TierFormValues) => {
        setIsCreating(true);
        try {
            const response = await axiosInstance.post<Tier>('/tiers/tiers', values);
            notifications.show({
                title: t('adminTiersManagePage.createSuccessTitle'),
                message: t('adminTiersManagePage.createSuccessMessage', { name: response.data.name }),
                color: 'green',
                icon: <IconCheck size={18} />
            });
            form.reset();
            onSuccess(response.data);
            onClose();
        } catch (err: any) {
            console.error("Error creating tier:", err);
            const apiError = err.response?.data?.message || t('adminTiersManagePage.createErrorMessage');
            notifications.show({
                title: t('adminTiersManagePage.createErrorTitle'),
                message: apiError,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
        } finally {
            setIsCreating(false);
        }
    };

    // handleClose
    const handleClose = () => { form.reset(); onClose(); }

    // JSX
    return (
        <Modal
            opened={opened}
            onClose={handleClose}
            title={t('adminTiersManagePage.createModalTitle')} // Usar t() para el t√≠tulo
            centered
            size="md"
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            <form onSubmit={form.onSubmit(handleSubmit)}>
                {/* TierForm necesita i18n internamente */}
                <TierForm form={form} />
                <Group justify="flex-end" mt="lg">
                    <Button variant="default" onClick={handleClose} disabled={isCreating}>{t('common.cancel')}</Button>
                    <Button type="submit" loading={isCreating} leftSection={<IconDeviceFloppy size={18} />}>
                        {/* Reutilizamos la clave del bot√≥n de la p√°gina principal */}
                        {t('adminTiersManagePage.addButton')}
                    </Button>
                </Group>
            </form>
        </Modal>
    );
};

export default CreateTierModal;


// ====== [168] frontend/src/modules/loyalpyme/components/admin/tiers/DeleteTierModal.tsx ======
// filename: frontend/src/components/admin/tiers/DeleteTierModal.tsx
import React from 'react';
import { Modal, Text, Button, Group } from '@mantine/core';
import { useTranslation } from 'react-i18next'; // Importar hook

// --- Props del Componente ---
interface DeleteTierModalProps {
    opened: boolean;
    onClose: () => void;
    onConfirm: () => void;
    tierName?: string | null;
    loading?: boolean;
}
// --- Fin Props ---

const DeleteTierModal: React.FC<DeleteTierModalProps> = ({ opened, onClose, onConfirm, tierName, loading }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n

    return (
        <Modal
            opened={opened}
            onClose={onClose}
            title={t('adminTiersManagePage.deleteModalTitle')} // Usar t() para el t√≠tulo
            centered
            size="sm"
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            {/* Usar t() para el mensaje, pasando el nombre del tier */}
            <Text size="sm">
                {t('adminTiersManagePage.deleteModalMessage', { name: tierName || '' })}
            </Text>
            <Group justify="flex-end" mt="lg">
                <Button variant="default" onClick={onClose} disabled={loading}>
                    {t('common.cancel')}
                </Button>
                <Button color="red" onClick={onConfirm} loading={loading}>
                    {t('adminTiersManagePage.deleteModalConfirm')}
                </Button>
            </Group>
        </Modal>
    );
};

export default DeleteTierModal;


// ====== [169] frontend/src/modules/loyalpyme/components/admin/tiers/EditTierModal.tsx ======
// filename: frontend/src/components/admin/tiers/EditTierModal.tsx
import React, { useState, useEffect } from 'react';
import { Modal, Button, Group } from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { notifications } from '@mantine/notifications';
import { IconDeviceFloppy, IconCheck, IconAlertCircle } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';
import TierForm from './TierForm'; // Este componente tambi√©n necesita i18n
import { useTranslation } from 'react-i18next'; // Importar hook

// --- Tipos ---
interface Tier {
    id: string;
    name: string;
    level: number;
    minValue: number;
    description: string | null;
    benefitsDescription: string | null;
    isActive: boolean;
}

// Funci√≥n para crear el esquema Zod, aceptando t
const createTierFormSchema = (t: Function) => z.object({
    name: z.string().min(1, { message: t('validation.nameRequired', 'El nombre es obligatorio') }),
    level: z.number().int().min(0, { message: t('validation.levelMin0', 'El nivel debe ser 0 o mayor') }),
    minValue: z.number().min(0, { message: t('validation.minValueMin0', 'El valor m√≠nimo debe ser 0 o mayor') }),
    description: z.string().optional(),
    benefitsDescription: z.string().optional(),
    isActive: z.boolean(),
});

type TierFormValues = z.infer<ReturnType<typeof createTierFormSchema>>;
// --- Fin Tipos ---

// --- Props del Componente ---
interface EditTierModalProps {
    opened: boolean;
    onClose: () => void;
    onSuccess: () => void;
    tier: Tier | null;
}
// --- Fin Props ---

const EditTierModal: React.FC<EditTierModalProps> = ({ opened, onClose, onSuccess, tier }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [isSaving, setIsSaving] = useState<boolean>(false);

    const form = useForm<TierFormValues>({
        initialValues: {
            name: '', level: 0, minValue: 0, description: '',
            benefitsDescription: '', isActive: true,
        },
        validate: zodResolver(createTierFormSchema(t)), // Pasar t al resolver
    });

    useEffect(() => {
        if (tier && opened) {
            form.setValues({
                name: tier.name,
                level: tier.level,
                minValue: tier.minValue,
                description: tier.description ?? '',
                benefitsDescription: tier.benefitsDescription ?? '',
                isActive: tier.isActive,
            });
        } else if (!opened) {
            form.reset();
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [tier, opened]);

    const handleSubmit = async (values: TierFormValues) => {
        if (!tier) return;
        setIsSaving(true);
        try {
            await axiosInstance.put(`/tiers/tiers/${tier.id}`, values);
            notifications.show({
                title: t('adminTiersManagePage.updateSuccessTitle'),
                message: t('adminTiersManagePage.updateSuccessMessage', { name: values.name }),
                color: 'green',
                icon: <IconCheck size={18} />
            });
            onSuccess();
            onClose();
        } catch (err: any) {
            console.error(`Error updating tier ${tier.id}:`, err);
            const apiError = err.response?.data?.message || t('adminTiersManagePage.updateErrorMessage');
            notifications.show({
                title: t('adminTiersManagePage.updateErrorTitle'),
                message: apiError,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
        } finally {
            setIsSaving(false);
        }
    };

    const handleClose = () => {
        onClose();
    }

    return (
        <Modal
            opened={opened}
            onClose={handleClose}
            // Usar t() para el t√≠tulo
            title={t('adminTiersManagePage.editModalTitle', { name: tier?.name || '' })}
            centered
            size="md"
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            <form onSubmit={form.onSubmit(handleSubmit)}>
                {/* TierForm necesita i18n internamente */}
                <TierForm form={form} />
                <Group justify="flex-end" mt="lg">
                    <Button variant="default" onClick={handleClose} disabled={isSaving}>{t('common.cancel')}</Button>
                    <Button type="submit" loading={isSaving} leftSection={<IconDeviceFloppy size={18} />}>
                        {t('common.save')}
                    </Button>
                </Group>
            </form>
        </Modal>
    );
};

export default EditTierModal;


// ====== [170] frontend/src/modules/loyalpyme/components/admin/tiers/TierBenefitsModal.tsx ======
// filename: frontend/src/components/admin/tiers/TierBenefitsModal.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
    Modal, Title, Text, Stack, Group, Button, Loader, Alert, Table, ActionIcon,
    Divider, Box, Badge
} from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next'; // Importar hook
import AddTierBenefitForm, { BenefitFormValues, BenefitType } from './AddTierBenefitForm'; // Este componente tambi√©n necesita i18n
import { notifications } from '@mantine/notifications';
import { IconPencil, IconTrash, IconAlertCircle, IconCheck } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';

// --- Tipos ---
interface TierBenefit { id: string; type: BenefitType; value: string; description: string | null; isActive: boolean; }
interface Tier { id: string; name: string; }

// --- Funci√≥n para crear Schema Zod con t() ---
const createBenefitFormSchema = (t: Function) => z.object({
    type: z.nativeEnum(BenefitType, { errorMap: () => ({ message: t('validation.benefitTypeRequired', 'Selecciona un tipo de beneficio v√°lido.') }) }),
    value: z.string().min(1, { message: t('component.addTierBenefitForm.errorValueRequired', 'El valor es obligatorio') }), // Usando clave del componente hijo (deber√≠a estar all√≠)
    description: z.string().optional(),
    isActive: z.boolean(),
});
// --- FIN ---

// --- Props ---
interface TierBenefitsModalProps {
    opened: boolean;
    onClose: () => void;
    tier: Tier | null;
}
// --- Fin Props ---

const TierBenefitsModal: React.FC<TierBenefitsModalProps> = ({ opened, onClose, tier }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [benefits, setBenefits] = useState<TierBenefit[]>([]);
    const [loading, setLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);
    const [isSubmitting, setIsSubmitting] = useState<boolean>(false);

    // Definir etiquetas de tipos de beneficio usando t()
    const benefitTypeLabels: Record<BenefitType, string> = {
        [BenefitType.POINTS_MULTIPLIER]: t('component.addTierBenefitForm.benefitType_POINTS_MULTIPLIER'),
        [BenefitType.EXCLUSIVE_REWARD_ACCESS]: t('component.addTierBenefitForm.benefitType_EXCLUSIVE_REWARD_ACCESS'),
        [BenefitType.CUSTOM_BENEFIT]: t('component.addTierBenefitForm.benefitType_CUSTOM_BENEFIT')
    };

    // useForm usa el schema con t()
    const form = useForm<BenefitFormValues>({
        initialValues: { type: BenefitType.CUSTOM_BENEFIT, value: '', description: '', isActive: true, },
        validate: zodResolver(createBenefitFormSchema(t)),
    });

    // Cargar beneficios
    const fetchBenefits = useCallback(async () => {
        if (!tier?.id || !opened) { setBenefits([]); return; }
        setLoading(true); setError(null);
        try {
            const response = await axiosInstance.get<TierBenefit[]>(`/tiers/tiers/${tier.id}/benefits`);
            setBenefits(response.data);
        } catch (err: any) {
            console.error(`Error fetching benefits for tier ${tier.id}:`, err);
            const message = err.response?.data?.message || t('component.tierBenefitsModal.errorLoading');
            setError(message);
            notifications.show({
                title: t('common.errorLoadingData'), // T√≠tulo gen√©rico
                message,
                color: 'red',
                icon: <IconAlertCircle />
            });
        } finally { setLoading(false); }
    }, [tier?.id, opened, t]); // A√±adir t como dependencia

    useEffect(() => { fetchBenefits(); }, [fetchBenefits]);

    // Handler para A√ëADIR beneficio
    const handleAddBenefit = async (values: BenefitFormValues) => {
        if (!tier?.id) return;
        setIsSubmitting(true);
        try {
            await axiosInstance.post(`/tiers/tiers/${tier.id}/benefits`, values);
            notifications.show({
                title: t('component.tierBenefitsModal.addSuccessTitle'),
                message: t('component.tierBenefitsModal.addSuccessMessage'),
                color: 'green',
                icon: <IconCheck />
            });
            form.reset();
            fetchBenefits();
        } catch (err: any) {
            console.error(`Error adding benefit to tier ${tier.id}:`, err);
            notifications.show({
                title: t('component.tierBenefitsModal.addErrorTitle'),
                message: err.response?.data?.message || t('component.tierBenefitsModal.addErrorMessage'),
                color: 'red',
                icon: <IconAlertCircle />
            });
        } finally { setIsSubmitting(false); }
    };

    // Handlers para Editar/Eliminar (Placeholders con t())
    const handleEditBenefit = (benefit: TierBenefit) => {
        console.log("TODO: Edit benefit", benefit);
        notifications.show({
            title: t('common.upcomingFeatureTitle', 'Pr√≥ximamente'), // Nueva clave
            message: t('component.tierBenefitsModal.editUpcoming'),
            color: 'blue'
        });
    };
    const handleDeleteBenefit = async (benefitId: string) => {
        console.log("TODO: Delete benefit", benefitId);
        notifications.show({
            title: t('common.upcomingFeatureTitle', 'Pr√≥ximamente'), // Nueva clave
            message: t('component.tierBenefitsModal.deleteUpcoming'),
            color: 'blue'
        });
    };

    // Filas tabla beneficios (Usa benefitTypeLabels local con t())
    const benefitRows = benefits.map((benefit) => (
        <Table.Tr key={benefit.id}>
            <Table.Td>{benefitTypeLabels[benefit.type] || benefit.type}</Table.Td>
            <Table.Td><Text size="sm" truncate style={{ maxWidth: 150 }}>{benefit.value}</Text></Table.Td>
            <Table.Td><Text size="sm" truncate style={{ maxWidth: 200 }}>{benefit.description || '-'}</Text></Table.Td>
            <Table.Td>
                <Badge color={benefit.isActive ? 'green' : 'gray'} variant="light">
                    {benefit.isActive ? t('common.active') : t('common.inactive')}
                </Badge>
            </Table.Td>
            <Table.Td>
                <Group gap="xs" wrap="nowrap">
                    <ActionIcon variant="subtle" color="blue" onClick={() => handleEditBenefit(benefit)} title={t('component.tierBenefitsModal.tooltipEditBenefit')}>
                        <IconPencil size={16} />
                    </ActionIcon>
                    <ActionIcon variant="subtle" color="red" onClick={() => handleDeleteBenefit(benefit.id)} title={t('component.tierBenefitsModal.tooltipDeleteBenefit')}>
                        <IconTrash size={16} />
                    </ActionIcon>
                </Group>
            </Table.Td>
        </Table.Tr>
    ));

    // JSX Modal
    return (
        <Modal
            opened={opened}
            onClose={() => { form.reset(); onClose(); }}
            // Usar t() para el t√≠tulo
            title={t('component.tierBenefitsModal.modalTitle', { name: tier?.name || '...' })}
            size="xl" centered
            overlayProps={{ backgroundOpacity: 0.55, blur: 3 }}
        >
            <Stack gap="lg">
                {/* Secci√≥n a√±adir */}
                <Box>
                    <Title order={4} mb="sm">{t('component.tierBenefitsModal.addSectionTitle')}</Title>
                    <form onSubmit={form.onSubmit(handleAddBenefit)}>
                        {/* AddTierBenefitForm necesita i18n internamente */}
                        <AddTierBenefitForm form={form} isSubmitting={isSubmitting} />
                        <Group justify="flex-end" mt="md">
                            <Button type="submit" loading={isSubmitting} size="sm">
                                {t('component.tierBenefitsModal.addBenefitButton')}
                            </Button>
                        </Group>
                    </form>
                </Box>

                <Divider my="sm" />

                {/* Secci√≥n listar beneficios */}
                <Box>
                    <Title order={4} mb="sm">{t('component.tierBenefitsModal.listSectionTitle')}</Title>
                    {loading && <Group justify="center"><Loader size="sm" /></Group>}
                    {error && !loading &&
                        <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>
                            {error}
                        </Alert>
                    }
                    {!loading && !error && benefits.length === 0 && (
                        <Text c="dimmed" ta="center">{t('component.tierBenefitsModal.noBenefits')}</Text>
                    )}
                    {!loading && !error && benefits.length > 0 && (
                        <Table.ScrollContainer minWidth={500}>
                            <Table striped highlightOnHover withTableBorder withColumnBorders verticalSpacing="sm">
                                <Table.Thead>
                                    <Table.Tr>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderType')}</Table.Th>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderValue')}</Table.Th>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderDescription')}</Table.Th>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderStatus')}</Table.Th>
                                        <Table.Th>{t('component.tierBenefitsModal.tableHeaderActions')}</Table.Th>
                                    </Table.Tr>
                                </Table.Thead>
                                <Table.Tbody>{benefitRows}</Table.Tbody>
                            </Table>
                        </Table.ScrollContainer>
                    )}
                </Box>

                {/* Bot√≥n cerrar */}
                <Group justify="flex-end" mt="lg">
                    <Button variant="default" onClick={() => { form.reset(); onClose(); }}>{t('common.close')}</Button>
                </Group>
            </Stack>
        </Modal>
    );
};

export default TierBenefitsModal;


// ====== [171] frontend/src/modules/loyalpyme/components/admin/tiers/TierForm.tsx ======
// filename: frontend/src/components/admin/tiers/TierForm.tsx
import React from 'react';
import { TextInput, NumberInput, Textarea, Switch, Stack } from '@mantine/core';
import { UseFormReturnType } from '@mantine/form';
import { z } from 'zod';
import { useTranslation } from 'react-i18next'; // Importar hook

// --- Tipos ---
// Esquema Zod (no necesita 't' aqu√≠ ya que los mensajes se definen en el componente padre)
const tierFormSchema = z.object({
    name: z.string().min(1),
    level: z.number().int().min(0),
    minValue: z.number().min(0),
    description: z.string().optional(),
    benefitsDescription: z.string().optional(),
    isActive: z.boolean(),
});

export type TierFormValues = z.infer<typeof tierFormSchema>;
// --- Fin Tipos ---

// --- Props del Componente ---
interface TierFormProps {
    form: UseFormReturnType<TierFormValues>;
    disabled?: boolean;
}
// --- Fin Props ---

const TierForm: React.FC<TierFormProps> = ({ form, disabled }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n

    return (
        <Stack gap="md">
            <TextInput
                label={t('component.tierForm.nameLabel')}
                placeholder={t('component.tierForm.namePlaceholder')}
                required
                disabled={disabled}
                {...form.getInputProps('name')}
            />
            <NumberInput
                label={t('component.tierForm.levelLabel')}
                placeholder={t('component.tierForm.levelPlaceholder')}
                description={t('component.tierForm.levelDescription')}
                required
                min={0}
                step={1}
                allowDecimal={false}
                disabled={disabled}
                {...form.getInputProps('level')}
            />
            <NumberInput
                label={t('component.tierForm.minValueLabel')}
                placeholder={t('component.tierForm.minValuePlaceholder')}
                description={t('component.tierForm.minValueDescription')}
                required
                min={0}
                decimalScale={2} // Permite decimales para gasto, pero step=1 si es para visitas/puntos
                // step={1} // Considera ajustar esto seg√∫n la l√≥gica de minValue
                disabled={disabled}
                {...form.getInputProps('minValue')}
            />
            <Textarea
                label={t('component.tierForm.descriptionLabel')}
                placeholder={t('component.tierForm.descriptionPlaceholder')}
                rows={2}
                disabled={disabled}
                {...form.getInputProps('description')}
            />
            <Textarea
                label={t('component.tierForm.benefitsDescriptionLabel')}
                placeholder={t('component.tierForm.benefitsDescriptionPlaceholder')}
                rows={3}
                disabled={disabled}
                {...form.getInputProps('benefitsDescription')}
            />
            <Switch
                label={t('component.tierForm.activeLabel')}
                description={t('component.tierForm.activeDescription')}
                mt="sm"
                disabled={disabled}
                {...form.getInputProps('isActive', { type: 'checkbox' })}
            />
        </Stack>
    );
};

export default TierForm;


// ====== [172] frontend/src/modules/loyalpyme/components/admin/tiers/TierTable.tsx ======
// filename: frontend/src/components/admin/tiers/TierTable.tsx
import React from 'react';
import { Table, Group, ActionIcon, Badge, Text } from '@mantine/core';
import { IconPencil, IconTrash, IconListDetails } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next'; // Importar hook

// Tipos
enum BenefitType { POINTS_MULTIPLIER = 'POINTS_MULTIPLIER', EXCLUSIVE_REWARD_ACCESS = 'EXCLUSIVE_REWARD_ACCESS', CUSTOM_BENEFIT = 'CUSTOM_BENEFIT' }
interface TierBenefit { id: string; isActive: boolean; type: BenefitType; value: string; description: string | null; }
interface Tier { id: string; name: string; level: number; minValue: number; description: string | null; benefitsDescription: string | null; isActive: boolean; benefits: TierBenefit[]; }

// Props
interface TierTableProps {
    tiers: Tier[];
    onEditClick: (tierId: string) => void;
    onDeleteClick: (tierId: string) => void;
    onManageBenefitsClick: (tier: Tier) => void;
}

const TierTable: React.FC<TierTableProps> = ({ tiers, onEditClick, onDeleteClick, onManageBenefitsClick }) => {
    const { t } = useTranslation(); // Hook de traducci√≥n

    // Funci√≥n interna para formatear resumen de beneficios
    const formatBenefitsSummary = (benefits: TierBenefit[]): string => {
        if (!benefits || benefits.length === 0) return t('adminTiersManagePage.benefitsSummaryNone');
        const activeBenefits = benefits.filter(b => b.isActive);
        if (activeBenefits.length === 0) return t('adminTiersManagePage.benefitsSummaryNoneActive');
        // Usar clave con pluralizaci√≥n
        return t('adminTiersManagePage.benefitsSummaryActive', { count: activeBenefits.length });
    };

    // Crear filas de la tabla
    const rows = tiers.map((tier) => (
        <Table.Tr key={tier.id}>
            <Table.Td>{tier.level}</Table.Td>
            <Table.Td fw={500}>{tier.name}</Table.Td>
            <Table.Td>{tier.minValue}</Table.Td>
            <Table.Td>{formatBenefitsSummary(tier.benefits)}</Table.Td>
            <Table.Td>
                <Badge color={tier.isActive ? 'green' : 'gray'} variant="light">
                    {tier.isActive ? t('common.active') : t('common.inactive')}
                </Badge>
            </Table.Td>
            <Table.Td>
                <Group gap="xs" wrap="nowrap">
                    <ActionIcon variant="subtle" color="teal" onClick={() => onManageBenefitsClick(tier)} title={t('adminTiersManagePage.tooltipManageBenefits')}>
                        <IconListDetails size={16} />
                    </ActionIcon>
                    <ActionIcon variant="subtle" color="blue" onClick={() => onEditClick(tier.id)} title={t('adminTiersManagePage.tooltipEditTier')}>
                        <IconPencil size={16} />
                    </ActionIcon>
                    <ActionIcon variant="subtle" color="red" onClick={() => onDeleteClick(tier.id)} title={t('adminTiersManagePage.tooltipDeleteTier')}>
                        <IconTrash size={16} />
                    </ActionIcon>
                </Group>
            </Table.Td>
        </Table.Tr>
    ));

    // Renderizado de la tabla
    return (
        <Table.ScrollContainer minWidth={600}>
            <Table verticalSpacing="sm" striped highlightOnHover withTableBorder withColumnBorders>
                <Table.Thead>
                    <Table.Tr>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderLevel')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderName')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderThreshold')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderBenefits')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderStatus')}</Table.Th>
                        <Table.Th>{t('adminTiersManagePage.tableHeaderActions')}</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>
                    {rows.length > 0 ? rows : (
                        <Table.Tr>
                            <Table.Td colSpan={6}>
                                <Text c="dimmed" ta="center">{t('adminTiersManagePage.noTiersDefined')}</Text>
                            </Table.Td>
                        </Table.Tr>
                    )}
                </Table.Tbody>
            </Table>
        </Table.ScrollContainer>
    );
};

export default TierTable;


// ====== [173] frontend/src/modules/loyalpyme/components/customer/NextTierPreview.tsx ======
// filename: frontend/src/components/customer/NextTierPreview.tsx
// Version: 1.0.1 (Remove unused imports/function, use i18n for title)

import React from 'react';
// --- MODIFICACI√ìN: Quitar Paper ---
import { Title, List, ThemeIcon, Text, Stack, Box } from '@mantine/core';
// --- MODIFICACI√ìN: Quitar iconos no usados ---
import { IconSparkles } from '@tabler/icons-react'; // Mantenemos IconSparkles
// --- FIN MODIFICACI√ìN ---
import { useTranslation } from 'react-i18next';

// Importar el tipo desde el archivo de tipos compartido
import { TierBenefitData } from '../../types/customer';

// --- Props del Componente ---
interface NextTierPreviewProps {
    nextTierName: string;
    nextTierBenefits: TierBenefitData[];
}
// --- Fin Props ---

const NextTierPreview: React.FC<NextTierPreviewProps> = ({ nextTierName, nextTierBenefits }) => {
    const { t } = useTranslation(); // Ahora s√≠ se usa t

    if (!nextTierBenefits || nextTierBenefits.length === 0) {
        return null;
    }

    // --- ELIMINADO: Funci√≥n getBenefitIcon eliminada ---
    // const getBenefitIcon = (type: string) => { ... };
    // --- FIN ELIMINADO ---

    // Funci√≥n helper para formatear texto de beneficio (se mantiene)
    const formatBenefitText = (benefit: TierBenefitData) => {
        switch (benefit.type) {
            case 'POINTS_MULTIPLIER':
                // TODO: Usar clave i18n
                return <>Multiplicador de Puntos: <Text span fw={700}>x{benefit.value}</Text></>;
            case 'EXCLUSIVE_REWARD_ACCESS':
                 // TODO: Usar clave i18n
                return <>Acceso Exclusivo: <Text span fw={500}>Recompensa ID {benefit.value}</Text></>;
            case 'CUSTOM_BENEFIT':
            default:
                return benefit.value;
        }
    }

    return (
        <Box mt="xl">
            <Stack gap="md">
                {/* --- MODIFICACI√ìN: Usar t() para el t√≠tulo --- */}
                <Title order={5} c="dimmed">
                    {t('customerDashboard.nextTierBenefitsTitle', { tierName: nextTierName })}
                    {/* Aseg√∫rate que la clave 'customerDashboard.nextTierBenefitsTitle' existe en tus JSON con valor tipo: "Al alcanzar {{tierName}} tendr√°s:" */}
                </Title>
                {/* --- FIN MODIFICACI√ìN --- */}

                {/* Lista de beneficios futuros */}
                <List
                    spacing="sm"
                    size="sm"
                    center
                    icon={
                        <ThemeIcon color="gray" variant='light' size={24} radius="xl">
                            <IconSparkles style={{ width: '70%', height: '70%' }} />
                        </ThemeIcon>
                    }
                >
                    {nextTierBenefits.map((benefit) => (
                        <List.Item key={benefit.id}>
                            <Text span c="dimmed">
                                {formatBenefitText(benefit)}
                            </Text>
                            {benefit.description && (
                                <Text size="xs" c="dimmed" display="block">
                                    {benefit.description}
                                </Text>
                            )}
                        </List.Item>
                    ))}
                </List>
            </Stack>
        </Box>
    );
};

export default NextTierPreview;

// End of File: frontend/src/components/customer/NextTierPreview.tsx


// ====== [174] frontend/src/modules/loyalpyme/components/customer/QrValidationSection.tsx ======
// filename: frontend/src/components/customer/QrValidationSection.tsx
// Version: 2.3.2 (Remove isMobile check, Add console log for isValidating prop)

import React, { useState, useCallback } from 'react';
import {
    Paper, Title, Group, TextInput, Button, Modal, Stack, Alert, Text, Box, 
} from '@mantine/core';
import { IconAlertCircle, IconScan, IconTicket } from '@tabler/icons-react';
import { useQrScanner } from '../../hooks/useQrScanner'; // Asume v1.2.1 con try/catch
// useMediaQuery ya no es necesario
import { useTranslation } from 'react-i18next';

// Props (sin cambios)
interface QrValidationSectionProps {
    onValidate: (token: string) => Promise<void>;
    isValidating: boolean;
    scannerOpened: boolean;
    onOpenScanner: () => void;
    onCloseScanner: () => void;
}

const QrValidationSection: React.FC<QrValidationSectionProps> = ({
    onValidate,
    isValidating, // <-- La prop que queremos comprobar
    scannerOpened,
    onOpenScanner,
    onCloseScanner
}) => {
    const { t } = useTranslation();
    const [qrTokenInput, setQrTokenInput] = useState('');
    const qrcodeRegionId = "html5qr-code-reader-region";

    // --- Log de Depuraci√≥n ---
    console.log('[QrValidationSection] Rendering. isValidating =', isValidating);
    // --- Fin Log ---

    const handleScanSuccess = useCallback((decodedText: string) => { if (!isValidating) { onValidate(decodedText); onCloseScanner(); } }, [isValidating, onValidate, onCloseScanner]);
    const { scannerError, clearScannerError } = useQrScanner({ qrcodeRegionId: qrcodeRegionId, enabled: scannerOpened, onScanSuccess: handleScanSuccess, config: { fps: 10, qrbox: { width: 250, height: 250 } } });
    const handleManualSubmit = () => { if (qrTokenInput.trim() && !isValidating) { onValidate(qrTokenInput.trim()); } };
    const handleCloseModal = () => { clearScannerError(); onCloseScanner(); };

    return (
        <>
            <Paper shadow="sm" p="lg" mb="xl" withBorder radius="lg">
                <Title order={4} mb="md">{t('customerDashboard.validateQrSectionTitle')}</Title>
                <Group align="flex-end">
                     <TextInput label={t('customerDashboard.qrInputLabel')} placeholder={t('customerDashboard.qrInputPlaceholder')} value={qrTokenInput} onChange={(event) => setQrTokenInput(event.currentTarget.value)} style={{ flexGrow: 1 }} disabled={isValidating || scannerOpened} />
                     <Button onClick={handleManualSubmit} leftSection={<IconTicket size={18} />} loading={isValidating && !scannerOpened} disabled={!qrTokenInput.trim() || isValidating || scannerOpened} variant='outline'> {t('customerDashboard.validateButton')} </Button>
                    {/* --- Bot√≥n Scan: ELIMINADA condici√≥n !isMobile de 'disabled' --- */}
                    <Button
                        onClick={onOpenScanner}
                        leftSection={<IconScan size={18} />}
                        disabled={isValidating} // <-- SOLO deshabilitado si isValidating es true
                        variant='gradient'
                        gradient={{ from: 'blue', to: 'cyan', deg: 90 }}
                    >
                        {t('customerDashboard.scanButton')}
                    </Button>
                    {/* --- FIN CAMBIO --- */}
                </Group>
            </Paper>

            {/* Modal (sin cambios aqu√≠) */}
            <Modal opened={scannerOpened} onClose={handleCloseModal} title={t('customerDashboard.scanModalTitle')} size="auto" centered>
                <Stack>
                   <Text size="sm" ta="center" c="dimmed">{t('customerDashboard.scanInstructions')}</Text>
                    <Box id={qrcodeRegionId} w="100%"></Box>
                    {/* El error del scanner ahora se mostrar√° aqu√≠ si no hay c√°mara */}
                    {scannerError && ( <Alert icon={<IconAlertCircle size="1rem" />} title={t('customerDashboard.errorScanningQr')} color="red" withCloseButton onClose={clearScannerError} mt="sm"> {scannerError} </Alert> )}
                    {isValidating && <Group justify='center'><Text>{t('customerDashboard.validating')}</Text></Group>}
                    <Button variant="outline" onClick={handleCloseModal} disabled={isValidating}> {t('customerDashboard.scanCancelButton')} </Button>
                </Stack>
            </Modal>
        </>
    );
};

export default QrValidationSection;

// End of File: frontend/src/components/customer/QrValidationSection.tsx


// ====== [175] frontend/src/modules/loyalpyme/components/customer/RewardList.tsx ======
// filename: frontend/src/components/customer/RewardList.tsx
// Version: 1.5.1 (Wrap Tooltip child in Box to fix ref error)

import React from 'react';
import {
    SimpleGrid, Card, Button, Alert, Group, Text, Badge, Tooltip, Title,
    AspectRatio, Image as MantineImage, Stack, Box // <-- A√±adido Box
} from '@mantine/core';
import { IconGift, IconAlertCircle, IconInfoCircle, IconCoin } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { DisplayReward } from '../../types/customer';

// Props (sin cambios)
interface RewardListProps {
    rewards: DisplayReward[];
    userPoints: number | undefined;
    redeemingRewardId: string | null;
    errorRewards: string | null;
    loadingRewards: boolean;
    loadingGrantedRewards: boolean;
    onRedeemPoints: (rewardId: string) => void;
    onRedeemGift: (grantedRewardId: string, rewardName: string) => void;
}

const RewardList: React.FC<RewardListProps> = ({
    rewards,
    userPoints,
    redeemingRewardId,
    errorRewards,
    // loadingRewards,
    // loadingGrantedRewards,
    onRedeemPoints,
    onRedeemGift
}) => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;

    const formatDate = (dateString: string | undefined) => { if (!dateString) return '?'; try { return new Date(dateString).toLocaleDateString(i18n.language); } catch { return '?'; } };

    if (errorRewards) { return ( <Alert icon={<IconAlertCircle size="1rem" />} title={t('common.error')} color="red" mt="lg"> {t('customerDashboard.errorLoadingRewards', { error: errorRewards })} </Alert> ); }
    if (rewards.length === 0) { return <Text mt="md">{t('customerDashboard.noRewardsAvailable')}</Text>; }

    return (
        <>
            <SimpleGrid cols={{ base: 1, xs: 2, md: 3 }} spacing="lg">
                {rewards.map((item) => {
                    const displayName = (currentLanguage === 'es' ? item.name_es : item.name_en) || item.name_es || item.name_en || '(Sin nombre)';
                    const displayDescription = (currentLanguage === 'es' ? item.description_es : item.description_en) || item.description_es || item.description_en;
                    const isPointsRedeemDisabled = typeof userPoints === 'undefined' || userPoints < item.pointsCost || redeemingRewardId === item.id || !!redeemingRewardId;
                    const isGiftRedeemDisabled = redeemingRewardId === item.grantedRewardId || !!redeemingRewardId;
                    const isCurrentlyRedeemingThis = redeemingRewardId === (item.isGift ? item.grantedRewardId : item.id);

                    return (
                        <Card shadow="sm" padding="sm" radius="md" withBorder key={item.isGift ? `G-${item.grantedRewardId}` : `R-${item.id}`}>
                            <Stack gap="md">
                                <AspectRatio ratio={1 / 1}>
                                    <MantineImage src={item.imageUrl || '/placeholder-reward.png'} alt={displayName} fit="cover" radius="sm" fallbackSrc="/placeholder-reward.png" />
                                </AspectRatio>
                                <Stack gap="xs" style={{ flexGrow: 1 }}>
                                    <Title order={5}>{displayName}</Title>
                                    {displayDescription && <Text size="sm" c="dimmed" lineClamp={2}>{displayDescription}</Text>}
                                </Stack>
                                {item.isGift ? (
                                    <>
                                        <Group gap="xs" mt="sm" justify='space-between'>
                                            <Badge color="lime" variant='light' size="lg" radius="sm">{t('customerDashboard.giftFree')}</Badge>
                                            {/* --- MODIFICACI√ìN: Envolver hijo de Tooltip en Box --- */}
                                            <Tooltip multiline w={220} withArrow position="top" label={t('customerDashboard.giftAssignedBy', { assigner: item.assignedByString, date: formatDate(item.assignedAt) })}>
                                                <Box style={{ display: 'inline-block', cursor: 'help' }}> {/* A√±adir Box wrapper */}
                                                    <Group gap={4}>
                                                        <IconInfoCircle size={16} stroke={1.5} style={{ display: 'block' }}/>
                                                        <Text size="xs" c="dimmed">{t('customerDashboard.giftInfo')}</Text>
                                                    </Group>
                                                </Box>
                                            </Tooltip>
                                            {/* --- FIN MODIFICACI√ìN --- */}
                                        </Group>
                                        <Button variant="filled" color="yellow" fullWidth mt="sm" radius="md" size="sm" onClick={() => onRedeemGift(item.grantedRewardId!, displayName)} disabled={isGiftRedeemDisabled} loading={isCurrentlyRedeemingThis} leftSection={<IconGift size={16}/>}> {t('customerDashboard.redeemGiftButton')} </Button>
                                    </>
                                ) : (
                                    <>
                                        <Group justify="space-between" align="center" mt="sm"> <Text fw={500} size="sm">{item.pointsCost} {t('common.points')}</Text> {(userPoints !== undefined && userPoints >= item.pointsCost) && ( <Badge color="green" variant="light" size="xs">Asequible</Badge> )} </Group>
                                        <Button variant="light" color="blue" fullWidth mt="sm" radius="md" size="sm" onClick={() => onRedeemPoints(item.id)} disabled={isPointsRedeemDisabled} loading={isCurrentlyRedeemingThis} leftSection={<IconCoin size={16}/>}> {!isPointsRedeemDisabled || isCurrentlyRedeemingThis ? t('customerDashboard.redeemRewardButton') : t('customerDashboard.insufficientPoints')} </Button>
                                    </>
                                )}
                            </Stack>
                        </Card>
                    );
                })}
            </SimpleGrid>
        </>
    );
};

export default RewardList;


// ====== [176] frontend/src/modules/loyalpyme/components/customer/TierBenefitsDisplay.tsx ======
// filename: frontend/src/components/customer/TierBenefitsDisplay.tsx
// Version: 1.0.2 (Use i18n key for title)

import React from 'react';
import { Paper, Title, List, ThemeIcon, Text, Stack } from '@mantine/core';
import { IconCircleCheck } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

// Importar el tipo desde el archivo de tipos compartido
import { TierBenefitData } from '../../types/customer';

// --- Props del Componente ---
interface TierBenefitsDisplayProps {
    tierName: string;
    benefits: TierBenefitData[];
}
// --- Fin Props ---

const TierBenefitsDisplay: React.FC<TierBenefitsDisplayProps> = ({ tierName, benefits }) => {
    const { t } = useTranslation();

    if (!benefits || benefits.length === 0) {
        return null;
    }

    return (
        <Paper shadow="sm" p="lg" mt="xl" mb="xl" withBorder radius="lg">
            <Stack gap="md">
                {/* --- MODIFICACI√ìN: Usar t() para el t√≠tulo --- */}
                <Title order={4}>
                    {t('customerDashboard.tierBenefitsTitle', { tierName })}
                </Title>
                {/* --- FIN MODIFICACI√ìN --- */}

                {/* Lista de beneficios */}
                <List
                    spacing="xs"
                    size="sm"
                    center
                    icon={
                        <ThemeIcon color="teal" size={20} radius="xl">
                            <IconCircleCheck style={{ width: '70%', height: '70%' }} />
                        </ThemeIcon>
                    }
                >
                    {benefits.map((benefit) => (
                        <List.Item key={benefit.id}>
                            {/* TODO: Mejorar la visualizaci√≥n seg√∫n el 'benefit.type' */}
                            <Text fw={500} span>
                                {benefit.type === 'POINTS_MULTIPLIER' ? `Multiplicador x${benefit.value}` :
                                 benefit.type === 'EXCLUSIVE_REWARD_ACCESS' ? `Acceso a Recompensa Exclusiva (ID: ${benefit.value})` :
                                 benefit.value}
                            </Text>
                            {benefit.description && (
                                <Text size="xs" c="dimmed" display="block">
                                    {benefit.description}
                                </Text>
                            )}
                        </List.Item>
                    ))}
                </List>
            </Stack>
        </Paper>
    );
};

export default TierBenefitsDisplay;

// End of File: frontend/src/components/customer/TierBenefitsDisplay.tsx


// ====== [177] frontend/src/modules/loyalpyme/components/customer/UserInfoDisplay.tsx ======
// frontend/src/components/customer/UserInfoDisplay.tsx
// La versi√≥n que me pasaste era frontend/src/components/customer/dashboard/UserInfoDisplay.tsx
// Usar√© esa ruta. Si es diferente, d√≠melo.

import React from 'react';
import {
    Card, Text, Group, Progress, Stack, Popover, List, ThemeIcon, Loader, Alert, Box,
    ActionIcon
} from '@mantine/core';
import {
    IconCircleCheck, IconGift, IconDiscount2, IconStar, IconAlertCircle,
    IconHelp
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { TFunction } from 'i18next';
import { useDisclosure, useMediaQuery } from '@mantine/hooks';
import { UserData, TierBenefitData, TierCalculationBasis, TierData } from '../../types/customer'; // Asumiendo que TierData tambi√©n se importa aqu√≠ si se usa

type ProgressBarDataType = {
    type: 'progress';
    percentage: number;
    currentValueLabel: string;
    targetValueLabel: string;
    unit: string;
    nextTierName: string;
} | {
    type: 'max_level';
    currentTierName: string;
} | null;

export interface UserInfoDisplayProps {
    userData: UserData | null; // UserData ahora tiene points? opcional
    loadingUser: boolean;
    errorUser: string | null;
    progressBarData: ProgressBarDataType;
    benefits: TierBenefitData[];
    nextTierName: string | null; // Se usa para el popover
    nextTierBenefits: TierBenefitData[];
    tierCalculationBasis?: TierCalculationBasis | null;
    allTiers?: TierData[];
}

const renderBenefitItem = (benefit: TierBenefitData, index: number, t: TFunction): JSX.Element => {
    let icon = <IconStar size={16} />;
    let text = benefit.description || `${benefit.type}: ${benefit.value}`;
    switch (benefit.type) {
        case 'POINTS_MULTIPLIER': icon = <IconCircleCheck size={16} />; text = t('benefits.pointsMultiplier', { value: benefit.value }); break;
        case 'EXCLUSIVE_REWARD_ACCESS': icon = <IconGift size={16} />; text = t('benefits.exclusiveRewardAccess', { value: benefit.value }); break;
        case 'CUSTOM_BENEFIT': icon = <IconDiscount2 size={16} />; text = t('benefits.customBenefit', { value: benefit.value }); break;
    }
    return ( <List.Item key={benefit.id || index} icon={<ThemeIcon color="teal" size={24} radius="xl">{icon}</ThemeIcon>}>{text}</List.Item> );
};


const UserInfoDisplay: React.FC<UserInfoDisplayProps> = ({
    userData,
    loadingUser,
    errorUser,
    progressBarData,
    benefits,
    nextTierBenefits, // nextTierName se saca de progressBarData
    // tierCalculationBasis, // No se usa directamente en el render
    // allTiers // No se usa directamente en el render
}) => {
    const { t } = useTranslation();
    const isMobile = useMediaQuery('(max-width: em(768px))');
    const [popoverOpened, { open: openPopover, close: closePopover, toggle: togglePopover }] = useDisclosure(false);

    if (loadingUser) { return <Card withBorder radius="md" p="xl"><Loader size="sm" data-testid="user-info-loader" /></Card>; }
    if (errorUser || !userData) { return ( <Card withBorder radius="md" p="xl"><Alert title={t('customerDashboard.errorLoadingProfileTitle')} color="red" icon={<IconAlertCircle size="1rem" />} data-testid="user-info-error">{errorUser || t('customerDashboard.errorLoadingProfileDefault')}</Alert></Card> ); }

    const currentTierDisplayName = userData.currentTier?.name ?? t('customerDashboard.baseTier');

    // --- CORRECCI√ìN AQU√ç para userData.points ---
    const displayPoints = userData.points ?? 0; // Si points es undefined, mostrar 0
    // --- FIN CORRECCI√ìN ---

    const nextTierTitle = progressBarData?.type === 'progress' ? progressBarData.nextTierName : null;
    const popoverTitleText = nextTierTitle ? t('customerDashboard.nextTierBenefitsTitle', { tierName: nextTierTitle }) : '';

    const nextTierContent = nextTierTitle ? (
        <Stack gap="xs">
            <Text fw={500}>{popoverTitleText}</Text>
            {nextTierBenefits && nextTierBenefits.length > 0 ? (
                <List spacing="xs" size="sm" center>{nextTierBenefits.map((b, i) => renderBenefitItem(b, i, t))}</List>
            ) : ( <Text size="sm" c="dimmed">{t('common.noItems')}</Text> )}
        </Stack>
    ) : null;

    return (
        <Card withBorder radius="md" p="xl" data-testid="user-info-card">
            <Stack gap="lg">
                <Group justify="space-between">
                    <Text fz="lg" fw={600}>{userData.name || userData.email}</Text>
                    {/* --- USAR displayPoints --- */}
                    <Text fz="lg" fw={700} c="blue">{displayPoints.toLocaleString()} {t('common.points')}</Text>
                    {/* --- FIN USAR --- */}
                </Group>

                <Stack gap="xs">
                    <Group justify="space-between">
                        <Text fz="sm" fw={500} c="dimmed">{t('customerDashboard.currentTier')}</Text>
                        <Text fz="sm" fw={700} data-testid="current-tier-name">{currentTierDisplayName}</Text>
                    </Group>

                    {progressBarData?.type === 'progress' && nextTierContent && (
                        <Box>
                            <Popover
                                width={300}
                                position="top"
                                withArrow
                                shadow="md"
                                opened={popoverOpened}
                            >
                                <Popover.Target>
                                    <Group
                                        wrap="nowrap"
                                        gap="xs"
                                        onMouseEnter={!isMobile ? openPopover : undefined}
                                        onMouseLeave={!isMobile ? closePopover : undefined}
                                        style={{ cursor: !isMobile ? 'help' : 'default' }}
                                    >
                                        <Progress
                                            value={progressBarData.percentage}
                                            size="lg" radius="xl" striped animated
                                            style={{ flexGrow: 1 }}
                                            data-testid="progress-bar"
                                        />
                                        <ActionIcon
                                            variant="subtle"
                                            color="gray"
                                            onClick={togglePopover}
                                            hiddenFrom="sm"
                                            aria-label={t('customerDashboard.nextTierBenefitsTitle', { tierName: nextTierTitle || ''})}
                                            title={t('customerDashboard.nextTierBenefitsTitle', { tierName: nextTierTitle || ''})}
                                            data-testid="mobile-popover-trigger"
                                        >
                                            <IconHelp size={18} stroke={1.5}/>
                                        </ActionIcon>
                                    </Group>
                                </Popover.Target>
                                <Popover.Dropdown>
                                    {nextTierContent}
                                </Popover.Dropdown>
                            </Popover>
                            <Group justify="space-between" mt={5}>
                                <Text fz="xs" c="dimmed" data-testid="progress-label">
                                    {t('customerDashboard.progressLabel', {
                                        currentValue: progressBarData.currentValueLabel,
                                        targetValue: progressBarData.targetValueLabel,
                                        unit: progressBarData.unit,
                                        nextTierName: progressBarData.nextTierName
                                    })}
                                </Text>
                            </Group>
                        </Box>
                    )}
                    {progressBarData?.type === 'max_level' && (
                         <Box data-testid="max-level-indicator">
                            <Progress value={100} size="lg" radius="xl" color="teal" />
                            <Text fz="xs" c="teal" fw={500} mt={5}>{t('customerDashboard.maxLevelReachedShort')}</Text>
                         </Box>
                    )}
                    {!progressBarData && !loadingUser && !errorUser && (
                       <Text fz="xs" c="dimmed">{t('customerDashboard.errorLoadingProgress')}</Text>
                    )}
                </Stack>

                <Stack gap="xs" mt="md" data-testid="current-benefits-section">
                    <Text fw={500}>{t('customerDashboard.tierBenefitsTitle', { tierName: currentTierDisplayName })}</Text>
                    {benefits && benefits.length > 0 ? (
                        <List spacing="xs" size="sm" center icon={<></>}>
                            {benefits.map((b, i) => renderBenefitItem(b, i, t))}
                        </List>
                    ) : (
                        <Text size="sm" c="dimmed">{t('common.noItems')}</Text>
                    )}
                </Stack>
            </Stack>
        </Card>
    );
};

export default UserInfoDisplay;


// ====== [178] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/ActivityTab.tsx ======
// filename: frontend/src/components/customer/dashboard/tabs/ActivityTab.tsx
// Version: 2.1.4 (Use explicitly typed intermediate variable for timeline title)

import React from 'react';
import {
    Stack, Loader, Alert, Text, Pagination, Group, Box,
    Timeline, ThemeIcon, Badge,
    Title
} from '@mantine/core';
import {
    IconAlertCircle, IconGift, IconReceipt, IconTicket, IconAdjustments
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useCustomerActivity } from '../../../../hooks/useCustomerActivity';
// Importaci√≥n de tipos
import type { ActivityLogItem } from '../../../../types/customer';
import { ActivityType } from '../../../../types/customer';


const ActivityTab: React.FC = () => {
    const { t, i18n } = useTranslation();
    const {
        activityLogs,
        loading,
        error,
        currentPage,
        totalPages,
        totalItems,
        setPage,
        // refetch
    } = useCustomerActivity();

    // Funci√≥n para obtener icono y color
    const getActivityVisuals = (type: ActivityType): { icon: React.ReactNode; color: string } => {
        switch (type) {
            case 'POINTS_EARNED_QR': return { icon: <IconTicket size={12} />, color: 'green' };
            case 'POINTS_REDEEMED_REWARD': return { icon: <IconReceipt size={12} />, color: 'blue' };
            case 'GIFT_REDEEMED': return { icon: <IconGift size={12} />, color: 'yellow' };
            case 'POINTS_ADJUSTED_ADMIN': return { icon: <IconAdjustments size={12} />, color: 'grape' };
            default: return { icon: <IconTicket size={12} />, color: 'gray' };
        }
    };

    // Funci√≥n para formatear la fecha
    const formatDate = (dateString: string) => {
        if (!dateString) return 'N/A';
        try { return new Date(dateString).toLocaleString(i18n.language, { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' }); } catch { return t('common.invalidDate', 'Fecha inv√°lida'); }
    };

    // Contenido principal
    const renderContent = () => {
        if (loading && activityLogs.length === 0) { return <Group justify="center" p="lg"><Loader /></Group>; }
        if (error) { return <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{error}</Alert>; }
        if (activityLogs.length === 0) { return <Text c="dimmed" ta="center">{t('customerDashboard.activityTab.noActivity', 'A√∫n no tienes actividad registrada.')}</Text>; }

        return (
            <Timeline active={-1} bulletSize={20} lineWidth={2}>
                {activityLogs.map((item: ActivityLogItem) => {
                    const visuals = getActivityVisuals(item.type);
                    const pointsText = item.pointsChanged !== null ? `${item.pointsChanged > 0 ? '+' : ''}${item.pointsChanged}` : null;
                    const pointsColor = item.pointsChanged === null ? 'gray' : (item.pointsChanged > 0 ? 'green' : 'red');

                    // Variable para calcular el t√≠tulo (tipo inferido puede ser complejo)
                    let timelineTitleCalculationResult: string | ReturnType<typeof t> = '';
                    const descriptionData = item.description || '';

                    // Calcular t√≠tulo traducido con interpolaci√≥n
                    switch(item.type) {
                        case 'POINTS_EARNED_QR':
                            timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_EARNED', { ticketNumber: descriptionData });
                            break;
                        case 'POINTS_REDEEMED_REWARD':
                            timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_REDEEMED', { rewardName: descriptionData });
                            break;
                         case 'GIFT_REDEEMED':
                            timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_GIFT', { rewardName: descriptionData });
                             break;
                        case 'POINTS_ADJUSTED_ADMIN':
                            if (item.description) {
                                timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_ADJUSTED_REASON', { reason: item.description });
                            } else {
                                timelineTitleCalculationResult = t('customerDashboard.activityTab.desc_ADJUSTED');
                            }
                            break;
                        default:
                            // Fallback
                            timelineTitleCalculationResult = item.description || t(`customerDashboard.activityTab.type_${item.type}`, item.type);
                    }

                    // Variable intermedia expl√≠citamente tipada como string
                    const finalTimelineTitle: string = String(timelineTitleCalculationResult);

                    return (
                        <Timeline.Item
                            key={item.id}
                            bullet={ <ThemeIcon size={20} variant="light" color={visuals.color} radius="xl"> {visuals.icon} </ThemeIcon> }
                            // Usar la variable intermedia expl√≠citamente tipada
                            title={finalTimelineTitle}
                        >
                            <Group justify="space-between">
                                <Text c="dimmed" size="xs"> {formatDate(item.createdAt)} </Text>
                                {pointsText && ( <Badge color={pointsColor} variant="light" size="sm"> {pointsText} {t('common.points')} </Badge> )}
                            </Group>
                        </Timeline.Item>
                    );
                })}
            </Timeline>
        );
    };

    return (
        <Stack gap="lg">
            <Title order={3}>{t('customerDashboard.tabActivity', 'Mi Actividad')}</Title>
            <Box style={{ position: 'relative' }}>
                {loading && activityLogs.length > 0 && ( <Box style={{ position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(255,255,255,0.5)', zIndex: 1, display: 'flex', alignItems: 'center', justifyContent: 'center' }}> <Loader size="sm" /> </Box> )}
                {renderContent()}
            </Box>
            {totalPages > 1 && !loading && !error && ( <Group justify="center" mt="xl"> <Pagination total={totalPages} value={currentPage} onChange={setPage} disabled={loading} /> </Group> )}
            {totalItems > 0 && !loading && !error && ( <Text size="sm" c="dimmed" ta="center"> {t('customerDashboard.activityTab.totalItems', { count: totalItems })} </Text> )}
        </Stack>
    );
};

export default ActivityTab;


// ====== [179] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/OffersTab.tsx ======
// filename: frontend/src/components/customer/dashboard/tabs/OffersTab.tsx
// Version: 1.0.0 (Placeholder component for Offers & News Tab)

import React from 'react';
import { Text } from '@mantine/core';
import { useTranslation } from 'react-i18next';

// No props needed for this placeholder initially
// interface OffersTabProps {}

const OffersTab: React.FC = (/* props: OffersTabProps */) => {
    const { t } = useTranslation();

    return (
        <Text c="dimmed">
            ({t('common.upcomingFeatureTitle', 'Pr√≥ximamente')}) {t('customerDashboard.tabOffers', 'Ofertas y Noticias')}
        </Text>
        // Future: Replace with actual offers/news feed component
    );
};

export default OffersTab;

// End of File: frontend/src/components/customer/dashboard/tabs/OffersTab.tsx


// ====== [180] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/ProfileTab.tsx ======
// filename: frontend/src/components/customer/dashboard/tabs/ProfileTab.tsx
// Version: 1.0.0 (Placeholder component for Profile Tab)

import React from 'react';
import { Text } from '@mantine/core';
import { useTranslation } from 'react-i18next';

// No props needed for this placeholder initially
// interface ProfileTabProps {}

const ProfileTab: React.FC = (/* props: ProfileTabProps */) => {
    const { t } = useTranslation();

    return (
        <Text c="dimmed">
            ({t('common.upcomingFeatureTitle', 'Pr√≥ximamente')}) {t('customerDashboard.tabProfile', 'Mi Perfil')}
        </Text>
        // Future: Replace with actual profile view/edit component
    );
};

export default ProfileTab;

// End of File: frontend/src/components/customer/dashboard/tabs/ProfileTab.tsx


// ====== [181] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/RewardsTab.tsx ======
// filename: frontend/src/components/customer/dashboard/tabs/RewardsTab.tsx
// Version: 1.0.7 (Remove explicit Title component to avoid duplication)

import React from 'react';
import { Box } from '@mantine/core'; // Title removed from imports
// import { useTranslation } from 'react-i18next'; // Removed if t() is not used

// Import child component
import RewardList from '../../RewardList';

// Import types needed for props
import { DisplayReward } from '../../../../types/customer';

// Define props for the RewardsTab component
interface RewardsTabProps {
    displayRewards: DisplayReward[];
    userPoints: number | undefined;
    redeemingRewardId: string | null;
    loadingRewards: boolean;
    loadingGrantedRewards: boolean;
    errorRewards: string | null;
    onRedeemPoints: (rewardId: string) => Promise<void>;
    onRedeemGift: (grantedRewardId: string, rewardName: string) => Promise<void>;
}

const RewardsTab: React.FC<RewardsTabProps> = ({
    displayRewards,
    userPoints,
    redeemingRewardId,
    loadingRewards,
    loadingGrantedRewards,
    errorRewards,
    onRedeemPoints,
    onRedeemGift
}) => {
    // const { t } = useTranslation(); // Removed if t() is not used

    // Optional: Display error directly in this tab if it occurs
    // if (errorRewards && !loadingRewards && !loadingGrantedRewards) {
    //     return (
    //         <Alert title={t('common.errorLoadingData')} color="red" icon={<IconAlertCircle size="1rem" />} mt="md">
    //             {errorRewards}
    //         </Alert>
    //     );
    // }

    return (
        <Box>
            {/* <Title order={4} mb="md"> // <-- TITLE REMOVED
                {t('customerDashboard.rewardsSectionTitle', 'Recompensas y Regalos')}
            </Title> */}

            <RewardList
                rewards={displayRewards}
                userPoints={userPoints}
                redeemingRewardId={redeemingRewardId}
                loadingRewards={loadingRewards}
                loadingGrantedRewards={loadingGrantedRewards}
                errorRewards={errorRewards}
                onRedeemPoints={onRedeemPoints}
                onRedeemGift={onRedeemGift}
            />
        </Box>
    );
};

export default RewardsTab;

// End of File: frontend/src/components/customer/dashboard/tabs/RewardsTab.tsx


// ====== [182] frontend/src/modules/loyalpyme/components/customer/dashboard/tabs/SummaryTab.tsx ======
// frontend/src/components/customer/dashboard/tabs/SummaryTab.tsx
// Version: 1.5.3 (Remove "Next Reward" display from summary)

import React, { useMemo } from 'react';
import {
    Stack, Grid, Paper, Title, Group, Text, Box, Image as MantineImage,
    AspectRatio, Button, Alert, Loader, Center,
    SimpleGrid, Badge
} from '@mantine/core';
import { IconGift, IconArrowRight, IconCoin, IconToolsKitchen2 } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { Link } from 'react-router-dom';

// Importar Componentes Hijos y sus Props
import UserInfoDisplay, { type UserInfoDisplayProps } from '../../UserInfoDisplay';
import QrValidationSection from '../../QrValidationSection';

// Importar Tipos necesarios
import type { DisplayReward, UserData, TierBenefitData } from '../../../../types/customer';

// Props del componente
interface SummaryTabProps {
    userData: UserData | null;
    loadingUser: boolean;
    errorUser: string | null;
    progressBarData: UserInfoDisplayProps['progressBarData'];
    currentTierBenefits: TierBenefitData[];
    nextTierName: string | null;
    nextTierBenefits: TierBenefitData[];
    displayRewards: DisplayReward[] | null;
    userPoints: number | undefined;
    redeemingRewardId: string | null;
    onRedeemGift: (grantedRewardId: string, rewardName: string) => Promise<void>;
    onRedeemPoints: (rewardId: string) => Promise<void>;
    setActiveTab: (tabValue: string | null) => void;
    handleValidateQr: (token: string) => Promise<void>;
    validatingQr: boolean;
    scannerOpened: boolean;
    onOpenScanner: () => void;
    onCloseScanner: () => void;
}

const MAX_PREVIEW_ITEMS = 3;

const SummaryTab: React.FC<SummaryTabProps> = ({
    userData, loadingUser, errorUser, progressBarData, currentTierBenefits,
    nextTierName, nextTierBenefits, displayRewards, userPoints,
    redeemingRewardId, onRedeemGift, onRedeemPoints,
    setActiveTab, handleValidateQr, validatingQr, scannerOpened,
    onOpenScanner, onCloseScanner
}) => {
    const { t, i18n } = useTranslation();
    const currentLanguage = i18n.language;

    const rewardsSummary = useMemo(() => {
        const pendingGifts = displayRewards?.filter(r => r.isGift) ?? [];
        const pointsRewards = displayRewards?.filter(r => !r.isGift && r.pointsCost > 0) ?? [];
        // No necesitamos ordenar pointsRewards si no vamos a usar nextReward
        // pointsRewards.sort((a, b) => (a.pointsCost ?? 0) - (b.pointsCost ?? 0)); 
        // const nextReward = pointsRewards.length > 0 ? pointsRewards[0] : null; // <-- ELIMINADO
        
        // Aseguramos que previewItems no intente acceder a nextReward si fue eliminado
        const previewItems = [...pendingGifts, ...pointsRewards].slice(0, MAX_PREVIEW_ITEMS);
        return {
            pendingGiftsCount: pendingGifts.length,
            // nextReward, // <-- ELIMINADO
            previewItems,
            hasAnyRewards: !!displayRewards && displayRewards.length > 0
        };
    }, [displayRewards]); // Ya no depende de currentLanguage o t aqu√≠ directamente

    if (loadingUser && !userData) {
        return <Group justify="center" p="xl"><Loader /></Group>;
    }

    return (
        <Grid gutter="xl">
            {/* Columna Izquierda: UserInfo y Validaci√≥n QR */}
            <Grid.Col span={{ base: 12, md: 7 }}>
                <Stack gap="xl">
                    <UserInfoDisplay
                        userData={userData}
                        loadingUser={loadingUser}
                        errorUser={errorUser}
                        progressBarData={progressBarData}
                        benefits={currentTierBenefits}
                        nextTierName={nextTierName}
                        nextTierBenefits={nextTierBenefits}
                    />
                    <QrValidationSection
                        onValidate={handleValidateQr}
                        isValidating={validatingQr}
                        scannerOpened={scannerOpened}
                        onOpenScanner={onOpenScanner}
                        onCloseScanner={onCloseScanner}
                    />
                </Stack>
            </Grid.Col>

            {/* Columna Derecha: Resumen Recompensas Y Tarjeta Acceso Carta */}
            <Grid.Col span={{ base: 12, md: 5 }}>
                <Stack gap="xl" style={{ height: '100%' }}>
                    
                    {/* Tarjeta de Acceso al M√≥dulo Camarero */}
                    {userData?.isCamareroActive && userData?.businessSlug && (
                        <Paper withBorder p="lg" radius="md" shadow="sm">
                            <Group justify="space-between" align="center">
                                <Stack gap={0} style={{ flex: 1, minWidth: 0 }}>
                                    <Text fw={500} size="lg" truncate>
                                        {userData.businessName 
                                            ? t('customerDashboard.summary.viewMenuFor', { businessName: userData.businessName }) 
                                            : t('customerDashboard.summary.viewMenuDefaultTitle')}
                                    </Text>
                                    <Text size="sm" c="dimmed" lineClamp={2}>
                                        {t('customerDashboard.summary.viewMenuSubtitle')}
                                    </Text>
                                </Stack>
                                <Button
                                    component={Link}
                                    to={`/m/${userData.businessSlug}`}
                                    leftSection={<IconToolsKitchen2 size={18} />}
                                    variant="gradient"
                                    gradient={{ from: 'teal', to: 'lime', deg: 105 }}
                                    size="sm"
                                    style={{ flexShrink: 0 }}
                                >
                                    {t('customerDashboard.summary.viewMenuButton')}
                                </Button>
                            </Group>
                        </Paper>
                    )}

                    {/* Tarjeta de Recompensas (existente) */}
                    {userData?.isLoyaltyCoreActive && (
                        <Paper shadow="sm" p="lg" withBorder radius="md" style={{ flexGrow: 1, display: 'flex', flexDirection: 'column' }}>
                            <Stack gap="lg" style={{ flexGrow: 1 }}>
                                <Title order={4}>
                                    {rewardsSummary.pendingGiftsCount > 0 
                                        ? t('customerDashboard.summary.giftsAndRewardsTitle') 
                                        : t('customerDashboard.summary.rewardsTitle')}
                                </Title>
                                {rewardsSummary.pendingGiftsCount > 0 && (
                                    <Alert color="yellow" icon={<IconGift />} title={t('customerDashboard.summary.pendingGifts', { count: rewardsSummary.pendingGiftsCount })} variant='light' radius="md">
                                        {t('customerDashboard.summary.pendingGiftsDesc')}
                                    </Alert>
                                )}

                                {rewardsSummary.previewItems.length > 0 ? (
                                    <SimpleGrid cols={MAX_PREVIEW_ITEMS === 3 ? 3 : 2} spacing="sm" verticalSpacing="md">
                                        {rewardsSummary.previewItems.map(item => {
                                            const displayName = (currentLanguage === 'es' ? item.name_es : item.name_en) || item.name_es || item.name_en || t('common.nameNotAvailable');
                                            const isAffordable = item.isGift || (userPoints !== undefined && userPoints >= item.pointsCost);
                                            const isPointsRedeemDisabled = !isAffordable || !!redeemingRewardId;
                                            const isGiftRedeemDisabled = !!redeemingRewardId;
                                            const isThisItemLoading = redeemingRewardId === (item.isGift ? item.grantedRewardId : item.id);

                                            return (
                                                <Stack 
                                                    key={item.id + (item.isGift ? '-gift' : '-reward')} 
                                                    gap={4} 
                                                    align="center"
                                                >
                                                    <AspectRatio ratio={1 / 1} style={{ width: '80%', maxWidth: '80px' }}>
                                                        <MantineImage src={item.imageUrl || '/placeholder-reward.png'} alt={displayName} radius="sm" fallbackSrc="/placeholder-reward.png" />
                                                    </AspectRatio>
                                                    <Text size="xs" ta="center" lineClamp={2} style={{ height: '2.4em', fontWeight: 500 }}>{displayName}</Text>
                                                    {item.isGift ? (
                                                        <Badge size="xs" color="lime" variant='light' mt={2}>{t('customerDashboard.giftFree')}</Badge>
                                                    ) : (
                                                        <Text size="xs" fw={500} mt={2}>{item.pointsCost} {t('common.points')}</Text>
                                                    )}
                                                    <Button
                                                        mt={4}
                                                        size="compact-xs"
                                                        variant={item.isGift ? "filled" : "light"}
                                                        color={item.isGift ? "yellow" : "blue"}
                                                        onClick={() => {
                                                            if (item.isGift && item.grantedRewardId) { onRedeemGift(item.grantedRewardId, displayName); }
                                                            else if (!item.isGift) { onRedeemPoints(item.id); }
                                                        }}
                                                        disabled={isThisItemLoading || (item.isGift ? isGiftRedeemDisabled : isPointsRedeemDisabled)}
                                                        loading={isThisItemLoading}
                                                        fullWidth
                                                        radius="xl"
                                                        leftSection={item.isGift ? <IconGift size={14}/> : <IconCoin size={14}/>}
                                                    >
                                                        {isAffordable || item.isGift
                                                            ? t('customerDashboard.redeemButton')
                                                            : t('customerDashboard.insufficientPoints')
                                                        }
                                                    </Button>
                                                </Stack>
                                            );
                                        })}
                                    </SimpleGrid>
                                ) : (
                                    <Center style={{flexGrow: 1}}>
                                        <Text c="dimmed">{t('customerDashboard.summary.noRewardsInfo')}</Text>
                                    </Center>
                                )}
                                
                                <Box mt="auto">
                                    {/* --- BLOQUE DE "PR√ìXIMA RECOMPENSA" ELIMINADO --- */}
                                    {rewardsSummary.hasAnyRewards && (
                                        <Button
                                            variant="light"
                                            fullWidth
                                            mt="sm" 
                                            onClick={() => setActiveTab('rewards')}
                                            radius="lg"
                                            rightSection={<IconArrowRight size={16} />}
                                        >
                                            {t('customerDashboard.summary.viewAllButtonShort')}
                                        </Button>
                                    )}
                                </Box>
                            </Stack>
                        </Paper>
                    )}
                </Stack>
            </Grid.Col>
        </Grid>
    );
};

export default SummaryTab;


// ====== [183] frontend/src/modules/loyalpyme/hooks/useAdminCustomersData.ts ======
// filename: frontend/src/hooks/useAdminCustomersData.ts
// Version: 1.1.3 (Fix character encoding)

import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';

// --- Tipos necesarios (Exportados) ---
// TODO: Mover estas interfaces a archivos compartidos (e.g., src/types/)
export interface Customer { id: string; name?: string | null; email: string; points: number; currentTier?: { id: string; name: string; level?: number; } | null; createdAt: string; isFavorite?: boolean; isActive?: boolean; }
interface CustomerApiResponse { items: Customer[]; totalPages: number; currentPage: number; totalItems: number; }
export type SortColumn = 'name' | 'email' | 'points' | 'createdAt' | 'isActive' | 'isFavorite' | 'currentTier.level';
export interface SortStatus { column: SortColumn; direction: 'asc' | 'desc'; }
export interface CustomerFilters {
    search?: string;
    isFavorite?: boolean;
    isActive?: boolean;
    tierId?: string;
}

// Interfaz para el resultado que el hook devolver√° (Exportada)
export interface UseAdminCustomersDataResult {
    customers: Customer[];
    loading: boolean;
    error: string | null;
    totalPages: number;
    currentPage: number;
    totalItems: number;
    searchTerm: string;
    sortStatus: SortStatus;
    filters: CustomerFilters;
    setPage: (page: number) => void;
    setSearchTerm: (term: string) => void;
    setSortStatus: (status: SortStatus) => void;
    setFilters: (filters: Partial<CustomerFilters>) => void;
    refetch: () => Promise<void>;
}
// --- Fin Tipos ---


const useAdminCustomersData = (): UseAdminCustomersDataResult => {
    // Estados internos
    const [customers, setCustomers] = useState<Customer[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [activePage, setPage] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const [totalItems, setTotalItems] = useState(0);
    const [searchTerm, setSearchTerm] = useState<string>('');
    const [sortStatus, setSortStatusState] = useState<SortStatus>({ column: 'createdAt', direction: 'desc' });
    const [filters, setFiltersState] = useState<CustomerFilters>({});

    // Funci√≥n de carga de datos
    const fetchCustomers = useCallback(async () => {
        setLoading(true);
        setError(null);
        console.log(`[useAdminCustomersData] Fetching customers: Page=${activePage}, Search='${searchTerm}', SortBy=${sortStatus.column}, SortDir=${sortStatus.direction}, Filters=`, filters);
        try {
            const params = new URLSearchParams({
                page: activePage.toString(),
                limit: '10', // L√≠mite fijo por ahora
                sortBy: sortStatus.column,
                sortDir: sortStatus.direction
            });
            // A√±adir filtros a los par√°metros
            if (searchTerm) params.append('search', searchTerm);
            if (filters.isFavorite !== undefined) params.append('isFavorite', filters.isFavorite.toString());
            if (filters.isActive !== undefined) params.append('isActive', filters.isActive.toString());
            if (filters.tierId) { params.append('tierId', filters.tierId); }

            const response = await axiosInstance.get<CustomerApiResponse>(`/admin/customers?${params.toString()}`);
            const apiData = response.data;

            if (apiData && Array.isArray(apiData.items) && typeof apiData.currentPage === 'number' && typeof apiData.totalPages === 'number' && typeof apiData.totalItems === 'number') {
                setCustomers(apiData.items);
                setTotalPages(apiData.totalPages);
                setTotalItems(apiData.totalItems);
                // Ajustar p√°gina activa si es necesario
                if(apiData.currentPage !== activePage && apiData.currentPage <= apiData.totalPages) { setPage(apiData.currentPage); }
                else if (activePage > apiData.totalPages && apiData.totalPages > 0) { setPage(apiData.totalPages); }
                else if (apiData.totalPages === 0 && activePage !== 1) { setPage(1); }

                console.log(`[useAdminCustomersData] Fetched ${apiData.items.length} customers. Total: ${apiData.totalItems}, Pages: ${apiData.totalPages}. Current page state: ${activePage}`);
            } else {
                console.error("[useAdminCustomersData] Invalid paginated response structure:", apiData);
                throw new Error("La respuesta del servidor no tiene el formato esperado.");
            }
        } catch (err: any) {
            console.error("[useAdminCustomersData] Error fetching customers:", err);
            const errorMsg = err.response?.data?.message || err.message || 'Error desconocido al cargar clientes.';
            setError(errorMsg);
            setCustomers([]); setTotalPages(1); setTotalItems(0); setPage(1); // Resetear todo en error
        } finally {
            setLoading(false);
        }
    }, [activePage, searchTerm, sortStatus, filters]); // Dependencias correctas

    // Efecto para Carga Inicial y Recarga por cambio de dependencias
    useEffect(() => {
        fetchCustomers();
    }, [fetchCustomers]);

    // Efecto para resetear p√°gina SOLO al cambiar filtros/b√∫squeda (y si no est√°bamos ya en p√°gina 1)
     useEffect(() => {
        if (activePage !== 1) {
             console.log("[useAdminCustomersData] Search or filters changed, resetting page to 1.");
             setPage(1);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [searchTerm, filters]); // No incluir activePage aqu√≠ para evitar bucle


    // Funciones Setters expuestas
    const handleSetPage = useCallback((page: number) => { setPage(page); }, []);
    const handleSetSearchTerm = useCallback((term: string) => { setSearchTerm(term); }, []);
    const handleSetSortStatus = useCallback((status: SortStatus) => { setSortStatusState(status); }, []);
    const handleSetFilters = useCallback((newFilters: Partial<CustomerFilters>) => {
        setFiltersState(prevFilters => {
            const updatedFilters = { ...prevFilters };
             for (const key in newFilters) {
                if (Object.prototype.hasOwnProperty.call(newFilters, key)) {
                    const filterKey = key as keyof CustomerFilters;
                    const value = newFilters[filterKey];
                    // Si el valor es undefined o string vac√≠o, quitar filtro
                    if (value === undefined || value === '') {
                        delete updatedFilters[filterKey];
                    } else {
                        // Validar tipo antes de asignar
                        if ((filterKey === 'isActive' || filterKey === 'isFavorite') && typeof value === 'boolean') {
                            updatedFilters[filterKey] = value;
                        } else if ((filterKey === 'search' || filterKey === 'tierId') && typeof value === 'string') {
                            updatedFilters[filterKey] = value;
                        } else { console.warn(`[useAdminCustomersData] Ignorando filtro con tipo inesperado para key '${filterKey}':`, value); }
                    }
                }
            }
            console.log('[useAdminCustomersData] Filters updated:', updatedFilters);
            return updatedFilters;
        });
    }, []);

    const refetch = useCallback(async () => { await fetchCustomers(); }, [fetchCustomers]);

    // Retorno del hook
    return {
        customers, loading, error, totalPages,
        currentPage: activePage, totalItems, searchTerm, sortStatus, filters,
        setPage: handleSetPage, setSearchTerm: handleSetSearchTerm,
        setSortStatus: handleSetSortStatus, setFilters: handleSetFilters, refetch,
    };
};

export default useAdminCustomersData;

// End of File: frontend/src/hooks/useAdminCustomersData.ts


// ====== [184] frontend/src/modules/loyalpyme/hooks/useAdminOverviewStats.ts ======
// filename: frontend/src/hooks/useAdminOverviewStats.ts
// Version: 1.0.1 (Add console.log inside calculateTrend for debugging)

import { useState, useEffect, useCallback, useMemo } from 'react';
import { getAdminDashboardStats, AdminOverviewStats } from '../services/adminService';

type TrendDirection = 'up' | 'down' | 'neutral';
interface TrendResult {
    trendValue: string | null;
    trendDirection: TrendDirection | null;
}
interface UseAdminOverviewStatsReturn {
    statsData: AdminOverviewStats | null;
    loadingStats: boolean;
    errorStats: string | null;
    newCustomersTrend: TrendResult;
    pointsIssuedTrend: TrendResult;
    rewardsRedeemedTrend: TrendResult;
    refetchStats: () => void;
}

export const useAdminOverviewStats = (): UseAdminOverviewStatsReturn => {
    const [statsData, setStatsData] = useState<AdminOverviewStats | null>(null);
    const [loadingStats, setLoadingStats] = useState<boolean>(true);
    const [errorStats, setErrorStats] = useState<string | null>(null);

    const fetchStats = useCallback(async () => {
        setLoadingStats(true);
        setErrorStats(null);
        console.log("[useAdminOverviewStats] Fetching stats...");
        try {
            const data = await getAdminDashboardStats();
            setStatsData(data);
        } catch (err: any) {
            console.error("[useAdminOverviewStats] Error fetching stats:", err);
            setErrorStats(err.message || 'No se pudieron cargar las estad√≠sticas.');
        } finally {
            setLoadingStats(false);
            console.log("[useAdminOverviewStats] Stats fetch finished.");
        }
    }, []);

    useEffect(() => {
        fetchStats();
    }, [fetchStats]);

    const calculateTrend = useMemo(() => {
        // A√±adimos un identificador para saber qu√© m√©trica se est√° calculando
        return (metricName: string, current: number | null | undefined, previous: number | null | undefined): TrendResult => {
            const currentVal = current ?? 0;
            const previousVal = previous ?? 0;

            // --- DEBUG LOGGING ---
            console.log(`[calculateTrend - ${metricName}] Inputs: current=${currentVal}, previous=${previousVal}`);
            // --- FIN DEBUG LOGGING ---

            if (previousVal === 0) {
                if (currentVal > 0) {
                    // --- DEBUG LOGGING ---
                    console.log(`[calculateTrend - ${metricName}] Result: '+' (Previous was 0)`);
                    // --- FIN DEBUG LOGGING ---
                    return { trendValue: '+', trendDirection: 'up' };
                }
                // --- DEBUG LOGGING ---
                 console.log(`[calculateTrend - ${metricName}] Result: 'N/A' (Both 0 or current <= 0)`);
                 // --- FIN DEBUG LOGGING ---
                return { trendValue: 'N/A', trendDirection: 'neutral' };
            }

            const percentageChange = ((currentVal - previousVal) / previousVal) * 100;
            // --- DEBUG LOGGING ---
            console.log(`[calculateTrend - ${metricName}] Percentage Change: ${percentageChange}`);
            // --- FIN DEBUG LOGGING ---

            if (isNaN(percentageChange) || !isFinite(percentageChange)) {
                 console.warn(`[calculateTrend - ${metricName}] Invalid percentageChange calculated.`);
                return { trendValue: 'Error', trendDirection: 'neutral' };
            }

            let direction: TrendDirection = 'neutral';
            const threshold = 0.1;
            if (percentageChange > threshold) direction = 'up';
            else if (percentageChange < -threshold) direction = 'down';

            const formattedValue = `${percentageChange >= 0 ? '+' : ''}${percentageChange.toFixed(1)}%`;
            // --- DEBUG LOGGING ---
            console.log(`[calculateTrend - ${metricName}] Result: value='${formattedValue}', direction='${direction}'`);
            // --- FIN DEBUG LOGGING ---
            return { trendValue: formattedValue, trendDirection: direction };
        };
    }, []);

    const newCustomersTrend = useMemo(() => {
        if (!statsData) return { trendValue: null, trendDirection: null };
        // Pasar nombre de m√©trica para logs
        return calculateTrend('NewCustomers', statsData.newCustomersLast7Days, statsData.newCustomersPrevious7Days);
    }, [statsData, calculateTrend]);

    const pointsIssuedTrend = useMemo(() => {
        if (!statsData) return { trendValue: null, trendDirection: null };
         // Pasar nombre de m√©trica para logs
        return calculateTrend('PointsIssued', statsData.pointsIssuedLast7Days, statsData.pointsIssuedPrevious7Days);
    }, [statsData, calculateTrend]);

    const rewardsRedeemedTrend = useMemo(() => {
        if (!statsData) return { trendValue: null, trendDirection: null };
         // Pasar nombre de m√©trica para logs
        return calculateTrend('RewardsRedeemed', statsData.rewardsRedeemedLast7Days, statsData.rewardsRedeemedPrevious7Days);
    }, [statsData, calculateTrend]);

    return {
        statsData,
        loadingStats,
        errorStats,
        newCustomersTrend,
        pointsIssuedTrend,
        rewardsRedeemedTrend,
        refetchStats: fetchStats
    };
};

// End of File: frontend/src/hooks/useAdminOverviewStats.ts


// ====== [185] frontend/src/modules/loyalpyme/hooks/useAdminRewards.ts ======
// filename: frontend/src/hooks/useAdminRewards.ts
// Version: 1.2.0 (Ensure correct Reward type with i18n fields is used)

import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';

// --- IMPORTANTE: Asegurarse de importar Reward desde la ubicaci√≥n correcta ---
import { Reward } from '../../../shared/types/user.types'; // Debe importar la interfaz Reward actualizada
// --- FIN IMPORTANTE ---


// Tipos (sin cambios en la definici√≥n, pero ahora usan la Reward importada)
export type ActionLoading = { type: 'toggle' | 'delete'; id: string } | null;

export interface UseAdminRewardsReturn {
    rewards: Reward[]; // <-- Usa la interfaz Reward importada (que ahora tiene name_es/en)
    loading: boolean;
    error: string | null;
    actionLoading: ActionLoading;
    fetchRewards: () => Promise<void>;
    handleToggleActive: (rewardId: string, currentIsActive: boolean) => Promise<void>;
    handleDeleteReward: (rewardId: string, rewardName: string) => Promise<void>; // rewardName puede ser ahora name_es o name_en
}


export const useAdminRewards = (): UseAdminRewardsReturn => {
    // --- Estado interno usa la interfaz Reward importada ---
    const [rewards, setRewards] = useState<Reward[]>([]);
    // --- Fin Estado ---
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [actionLoading, setActionLoading] = useState<ActionLoading>(null);

    // Funciones (sin cambios en la l√≥gica interna, pero ahora trabajan con el tipo Reward correcto)
    const fetchRewards = useCallback(async () => {
        if (rewards.length === 0 || !loading) setLoading(true); // Ajuste para mostrar loading en refetch
        setError(null);
        console.log("[useAdminRewards] Fetching rewards...");
        try {
            // La llamada espera un array de objetos Reward (con name_es/en)
            const response = await axiosInstance.get<Reward[]>('/rewards'); // Usa el tipo Reward correcto
            console.log("[useAdminRewards] Raw rewards data received:", response.data);
            setRewards(response.data ?? []);
        } catch (err: any) {
           console.error('[useAdminRewards] Error fetching rewards:', err);
           const message = err.response?.data?.message || err.message || 'Error desconocido al cargar recompensas.';
           setError(message);
           // Solo mostrar notificaci√≥n si ya hab√≠a datos y falla el refetch
           if (rewards.length > 0) {
                notifications.show({ title: 'Error al Refrescar', message, color: 'red' });
           }
         } finally {
            setLoading(false);
            console.log("[useAdminRewards] Fetch rewards finished.");
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [loading]); // Dependencia ajustada para permitir refetch

    useEffect(() => {
        fetchRewards();
    }, [fetchRewards]); // fetchRewards ahora tiene dependencias correctas

    const handleToggleActive = useCallback(async (rewardId: string, currentIsActive: boolean) => {
         setActionLoading({ type: 'toggle', id: rewardId });
        const newIsActive = !currentIsActive;
        const actionText = newIsActive ? 'activada' : 'desactivada'; // TODO: i18n
        try {
            await axiosInstance.patch(`/rewards/${rewardId}`, { isActive: newIsActive });
            // Actualizaci√≥n optimista del estado
            setRewards((prevRewards) =>
                prevRewards.map((r) =>
                    r.id === rewardId ? { ...r, isActive: newIsActive, updatedAt: new Date().toISOString() } : r
                )
            );
            notifications.show({
                 title: `Recompensa ${actionText}`, // TODO: i18n
                message: `La recompensa se ha ${actionText} correctamente.`, // TODO: i18n
                color: 'green',
                autoClose: 4000
            });
        } catch (err: any) {
             console.error('Error toggling reward active state:', err);
             const message = `Error al ${actionText} la recompensa: ${err.response?.data?.message || err.message || 'Error desconocido'}`; // TODO: i18n
             notifications.show({
                title: 'Error al Actualizar Estado', message, color: 'red', // TODO: i18n
                autoClose: 6000
            });
        } finally {
            setActionLoading(null);
        }
    }, []);

    const handleDeleteReward = useCallback(async (rewardId: string, rewardName: string) => { // rewardName es ahora name_es o name_en
        setActionLoading({ type: 'delete', id: rewardId });
        try {
            await axiosInstance.delete(`/rewards/${rewardId}`);
            setRewards((prevRewards) => prevRewards.filter((r) => r.id !== rewardId) );
             notifications.show({
                title: 'Recompensa Eliminada', // TODO: i18n
                message: `La recompensa "${rewardName}" ha sido eliminada.`, // Usa el nombre pasado
                color: 'green',
                autoClose: 4000
            });
         } catch (err: any) {
            console.error('Error deleting reward:', err);
            const apiMessage = err.response?.data?.message || err.message || 'Error desconocido';
            let notifyMessage = `Error al eliminar "${rewardName}": ${apiMessage}`; // TODO: i18n
            if (err.response?.status === 404 || apiMessage.includes('no encontrada')) {
                 notifyMessage = `No se encontr√≥ la recompensa "${rewardName}" (quiz√°s ya fue eliminada).`; // TODO: i18n
            }
             if (err.response?.status === 409 || apiMessage.includes('siendo utilizada')) {
                notifyMessage = `No se puede eliminar "${rewardName}" porque est√° en uso.`; // TODO: i18n
            }
            notifications.show({
                title: 'Error al Eliminar', message: notifyMessage, color: 'red', // TODO: i18n
                autoClose: 6000
            });
        } finally {
            setActionLoading(null);
        }
    }, []);

    // Retorno del Hook (sin cambios)
    return {
        rewards,
        loading,
        error,
        actionLoading,
        fetchRewards,
        handleToggleActive,
        handleDeleteReward
    };
};

// End of File: frontend/src/hooks/useAdminRewards.ts


// ====== [186] frontend/src/modules/loyalpyme/hooks/useCustomerActivity.ts ======
// filename: frontend/src/hooks/useCustomerActivity.ts
import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { ActivityLogItem, PaginatedActivityResponse } from '../../../shared/types/user.types'; // Importar tipos definidos

// Definir el tipo de retorno del hook
export interface UseCustomerActivityResult {
    activityLogs: ActivityLogItem[];
    loading: boolean;
    error: string | null;
    currentPage: number;
    totalPages: number;
    totalItems: number;
    setPage: (page: number) => void; // Funci√≥n para cambiar de p√°gina
    refetch: () => void; // Funci√≥n para recargar la p√°gina actual
}

const ITEMS_PER_PAGE = 15; // N√∫mero de items por p√°gina

export const useCustomerActivity = (): UseCustomerActivityResult => {
    // Estados del hook
    const [activityLogs, setActivityLogs] = useState<ActivityLogItem[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [currentPage, setCurrentPage] = useState<number>(1);
    const [totalPages, setTotalPages] = useState<number>(1);
    const [totalItems, setTotalItems] = useState<number>(0);

    // Funci√≥n para obtener los datos de una p√°gina espec√≠fica
    const fetchActivity = useCallback(async (pageToFetch: number) => {
        setLoading(true);
        // No limpiar el error aqu√≠ necesariamente, podr√≠a ser √∫til verlo mientras carga
        // setError(null);
        console.log(`[useCustomerActivity] Fetching page ${pageToFetch}...`);

        try {
            const response = await axiosInstance.get<PaginatedActivityResponse>('/customer/activity', {
                params: {
                    page: pageToFetch,
                    limit: ITEMS_PER_PAGE,
                },
            });

            const data = response.data;
            if (data && Array.isArray(data.logs)) {
                setActivityLogs(data.logs);
                setTotalPages(data.totalPages ?? 1);
                setTotalItems(data.totalItems ?? 0);
                setCurrentPage(data.currentPage ?? pageToFetch); // Usar la p√°gina devuelta por la API si existe
                setError(null); // Limpiar error en caso de √©xito
                console.log(`[useCustomerActivity] Fetch successful for page ${pageToFetch}. Total Items: ${data.totalItems}`);
            } else {
                console.error('[useCustomerActivity] Invalid response structure:', data);
                throw new Error('La respuesta del servidor para el historial no tiene el formato esperado.');
            }

        } catch (err: any) {
            console.error(`[useCustomerActivity] Error fetching activity page ${pageToFetch}:`, err);
            const errorMsg = err.response?.data?.message || err.message || 'Error desconocido al cargar el historial.';
            setError(errorMsg);
            // No limpiar los logs existentes en caso de error de fetch, podr√≠a ser confuso
            // setActivityLogs([]);
            // setTotalPages(1);
            // setTotalItems(0);
            // setCurrentPage(1);
        } finally {
            setLoading(false);
            console.log(`[useCustomerActivity] Fetch process finished for page ${pageToFetch}.`);
        }
    }, []); // No necesita dependencias si usa 'currentPage' del estado

    // Funci√≥n para establecer la p√°gina (disparar√° el useEffect)
    const setPage = useCallback((page: number) => {
        // Validar que la p√°gina est√© dentro de los l√≠mites si ya conocemos totalPages
        if (page > 0 && (totalPages === 1 || page <= totalPages)) {
             if(page !== currentPage){ // Solo actualiza si la p√°gina es diferente
                console.log(`[useCustomerActivity] Setting page to: ${page}`);
                setCurrentPage(page);
             }
        } else {
             console.warn(`[useCustomerActivity] Attempted to set invalid page: ${page} (Total: ${totalPages})`);
        }
    }, [totalPages, currentPage]); // Depende de totalPages y currentPage

    // Efecto para la carga inicial
    useEffect(() => {
        console.log('[useCustomerActivity] Initial fetch triggered.');
        fetchActivity(1); // Cargar p√°gina 1 al montar
    }, [fetchActivity]);

    // Efecto para recargar cuando cambia la p√°gina (excepto en carga inicial)
    useEffect(() => {
        // Evitar recarga si es la carga inicial (manejada por el otro useEffect)
        // o si la p√°gina no es v√°lida
        if (currentPage !== 1 && currentPage > 0 && (totalPages === 1 || currentPage <= totalPages)) {
             console.log(`[useCustomerActivity] Page changed to ${currentPage}, refetching...`);
            fetchActivity(currentPage);
        }
    }, [currentPage, fetchActivity, totalPages]); // Depende de currentPage

    // Funci√≥n para recargar la p√°gina actual
    const refetch = useCallback(() => {
        console.log(`[useCustomerActivity] Manual refetch triggered for page ${currentPage}.`);
        fetchActivity(currentPage);
    }, [fetchActivity, currentPage]);


    // Retornar el estado y las funciones
    return {
        activityLogs,
        loading,
        error,
        currentPage,
        totalPages,
        totalItems,
        setPage,
        refetch
    };
};


// ====== [187] frontend/src/modules/loyalpyme/hooks/useCustomerRewardsData.ts ======
// filename: frontend/src/hooks/useCustomerRewardsData.ts
// Version: 1.2.2 (Fix infinite loop by correcting useCallback dependencies)

import { useState, useEffect, useCallback, useMemo } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { useTranslation } from 'react-i18next';

// Importar tipos actualizados
import { Reward, GrantedReward, DisplayReward } from '../../../shared/types/user.types';

// Interfaz de retorno (sin cambios)
export interface UseCustomerRewardsDataResult {
    displayRewards: DisplayReward[];
    loadingRewards: boolean;
    loadingGrantedRewards: boolean;
    errorRewards: string | null;
    refreshRewards: () => Promise<void>;
}

// Funci√≥n Helper para combinar y mapear (sin cambios respecto a v1.2.1)
const combineAndMapRewards = ( rewards: Reward[] | null, grantedRewards: GrantedReward[] | null, t: ReturnType<typeof useTranslation>['t'] ): DisplayReward[] => { /* ... (c√≥digo interno sin cambios) ... */ console.log('[useCustomerRewardsData] Combining rewards and gifts...'); const combined: DisplayReward[] = []; if (grantedRewards) { const gifts: DisplayReward[] = grantedRewards .filter(gr => gr && gr.reward) .map((gr): DisplayReward => { let assigner = t('customerDashboard.summary.unknownAssigner', 'Desconocido'); if (gr.assignedBy) { assigner = gr.assignedBy.name || gr.assignedBy.email || assigner; } return { isGift: true, grantedRewardId: gr.id, id: gr.reward.id, name_es: gr.reward.name_es, name_en: gr.reward.name_en, description_es: gr.reward.description_es, description_en: gr.reward.description_en, pointsCost: 0, imageUrl: gr.reward.imageUrl, assignedByString: assigner, assignedAt: gr.assignedAt, }; }); combined.push(...gifts); console.log(`[useCustomerRewardsData] Mapped ${gifts.length} gifts.`); } else { console.log('[useCustomerRewardsData] No granted rewards data received.'); } if (rewards) { const grantedRewardBaseIds = new Set(grantedRewards?.map(gr => gr.reward.id) ?? []); const pointsRewards: DisplayReward[] = rewards .filter(r => r && !grantedRewardBaseIds.has(r.id)) .map((r): DisplayReward => { return { isGift: false, id: r.id, name_es: r.name_es, name_en: r.name_en, description_es: r.description_es, description_en: r.description_en, pointsCost: r.pointsCost, imageUrl: r.imageUrl, }; }); combined.push(...pointsRewards); console.log(`[useCustomerRewardsData] Mapped ${pointsRewards.length} points rewards.`); } else { console.log('[useCustomerRewardsData] No points rewards data received.'); } console.log('[useCustomerRewardsData] Final combined display rewards:', combined); return combined; };


// Hook Principal
export const useCustomerRewardsData = (): UseCustomerRewardsDataResult => {
    const { t } = useTranslation(); // No necesitamos i18n aqu√≠ directamente si solo pasamos t
    const [rewards, setRewards] = useState<Reward[] | null>(null);
    const [grantedRewards, setGrantedRewards] = useState<GrantedReward[] | null>(null);
    const [loadingRewards, setLoadingRewards] = useState<boolean>(true);
    const [loadingGrantedRewards, setLoadingGrantedRewards] = useState<boolean>(true);
    const [errorRewards, setErrorRewards] = useState<string | null>(null);

    // --- useCallback ACTUALIZADO: Dependencias corregidas ---
    const fetchAllRewardsData = useCallback(async () => {
        setLoadingRewards(true); setLoadingGrantedRewards(true); setErrorRewards(null);
        console.log('[useCustomerRewardsData] Fetching rewards data...');
        try {
            const [rewardsResponse, grantedRewardsResponse] = await Promise.all([
                axiosInstance.get<Reward[]>('/customer/rewards'),
                axiosInstance.get<GrantedReward[]>('/customer/granted-rewards')
            ]);
            if (!Array.isArray(rewardsResponse.data) || !Array.isArray(grantedRewardsResponse.data)) { console.error("Invalid API response structure", {rewards: rewardsResponse.data, granted: grantedRewardsResponse.data}); throw new Error("La respuesta de la API no tiene el formato esperado."); }
            setRewards(rewardsResponse.data);
            setGrantedRewards(grantedRewardsResponse.data);
            console.log('[useCustomerRewardsData] Rewards data fetch successful.');
        } catch (err: any) { console.error('[useCustomerRewardsData] Error fetching rewards data:', err); const message = err.response?.data?.message || err.message || t('customerDashboard.errorLoadingRewards'); setErrorRewards(message); /* No mostrar notif aqu√≠, podr√≠a ser molesto en bucle if(!rewards && !grantedRewards) { notifications.show({ title: t('common.errorLoadingData'), message, color: 'red' }); } */
        } finally { setLoadingRewards(false); setLoadingGrantedRewards(false); console.log('[useCustomerRewardsData] Fetch rewards process finished.'); }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [t]); // <-- SOLO depende de 't' ahora
    // --- FIN useCallback ---

    // Carga inicial (sin cambios)
    useEffect(() => {
        fetchAllRewardsData();
    }, [fetchAllRewardsData]); // Este useEffect ahora es seguro porque fetchAllRewardsData no cambia innecesariamente

    // Combinar y mapear (sin cambios)
    const displayRewards = useMemo(() => {
        return combineAndMapRewards(rewards, grantedRewards, t);
    }, [rewards, grantedRewards, t]);

    useEffect(() => { console.log("[useCustomerRewardsData] Display rewards updated.", displayRewards); }, [displayRewards]);

    // Funci√≥n de refresco (sin cambios)
    const refreshRewards = useCallback(() => { console.log("[useCustomerRewardsData] Refresh triggered."); return fetchAllRewardsData(); }, [fetchAllRewardsData]);

    return { displayRewards, loadingRewards, loadingGrantedRewards, errorRewards, refreshRewards };
};

// End of File: frontend/src/hooks/useCustomerRewardsData.ts


// ====== [188] frontend/src/modules/loyalpyme/hooks/useCustomerTierData.ts ======
// filename: frontend/src/hooks/useCustomerTierData.ts
// Version: 1.2.2 (Remove unused TierCalculationBasis import)

import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { AxiosError } from 'axios';
import { notifications } from '@mantine/notifications';
// import { IconAlertCircle } from '@tabler/icons-react'; // Sigue sin usarse

// --- MODIFICACI√ìN: Importar solo los tipos usados directamente por el hook ---
import {
    TierData,
    CustomerBusinessConfig,
    UseCustomerTierDataResult,
} from '../../../shared/types/user.types';


// --- Hook ---

// Usar el tipo importado para el retorno
export const useCustomerTierData = (): UseCustomerTierDataResult => {
    // Usar los tipos importados para el estado
    const [allTiers, setAllTiers] = useState<TierData[] | null>(null);
    const [businessConfig, setBusinessConfig] = useState<CustomerBusinessConfig | null>(null);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);

    const fetchData = useCallback(async () => {
        setLoading(true);
        setError(null);
        console.log('[useCustomerTierData] Fetching all tiers and business config...');

        try {
            const [tiersResponse, configResponse] = await Promise.all([
                // Usar los tipos importados en las llamadas
                axiosInstance.get<TierData[]>('/customer/tiers'),
                axiosInstance.get<CustomerBusinessConfig>('/customer/business-config')
            ]);

            const activeTiers = tiersResponse.data?.filter(t => t.isActive) ?? [];
            setAllTiers(activeTiers);
            console.log('[useCustomerTierData] Active tiers fetched:', activeTiers);

            setBusinessConfig(configResponse.data ?? null);
            console.log('[useCustomerTierData] Business config fetched:', configResponse.data);

        } catch (err) {
            console.error("[useCustomerTierData] Error fetching data:", err);
            let errorMsg = 'Error al cargar datos de niveles o configuraci√≥n.';
            if (err instanceof AxiosError) {
                errorMsg = err.response?.data?.message || err.message || errorMsg;
            } else if (err instanceof Error) {
                errorMsg = err.message;
            }
            setError(errorMsg);

            notifications.show({
                title: 'Error de Carga',
                message: errorMsg,
                color: 'red',
                // icon: <IconAlertCircle />, // Mantenemos sin icono
            });

            setAllTiers(null);
            setBusinessConfig(null);
        } finally {
            setLoading(false);
            console.log('[useCustomerTierData] Fetch process finished.');
        }
    }, []);

    useEffect(() => {
        fetchData();
    }, [fetchData]);

    // El tipo de retorno ya coincide con UseCustomerTierDataResult importado
    return {
        allTiers,
        businessConfig,
        loading,
        error,
        refetch: fetchData
    };
};

// End of File: frontend/src/hooks/useCustomerTierData.ts


// ====== [189] frontend/src/modules/loyalpyme/hooks/useQrScanner.ts ======
// filename: frontend/src/hooks/useQrScanner.ts
// Version: 1.2.1 (Fix type errors and unused warnings)

import { useState, useEffect, useRef, useCallback } from 'react';
// --- MODIFICADO: Eliminar Html5QrcodeError y Html5QrcodeResult ---
import {
    Html5Qrcode,
    // Html5QrcodeError, // <-- Eliminado
    // Html5QrcodeResult, // <-- Eliminado
    QrcodeSuccessCallback,
    QrcodeErrorCallback
} from 'html5-qrcode';
import type { Html5QrcodeScannerConfig } from 'html5-qrcode/html5-qrcode-scanner';

// Props del Hook (sin cambios)
interface UseQrScannerProps {
    qrcodeRegionId: string;
    enabled: boolean;
    onScanSuccess: QrcodeSuccessCallback;
    onScanError?: QrcodeErrorCallback;
    config?: Omit<Html5QrcodeScannerConfig, 'fps' | 'qrbox'> & { fps?: number; qrbox?: { width: number; height: number; } | number };
    verbose?: boolean;
}

// Tipo de Retorno del Hook (sin cambios)
export interface UseQrScannerReturn {
    scannerError: string | null;
    clearScannerError: () => void;
    isScanning: boolean;
}

export const useQrScanner = ({
    qrcodeRegionId,
    enabled,
    onScanSuccess,
    // --- MODIFICADO: Prefijar errorMessage no usado ---
    onScanError = (_errorMessage) => { /* No hacer nada por defecto */ },
    // --- FIN MODIFICADO ---
    config = {},
    verbose = false,
}: UseQrScannerProps): UseQrScannerReturn => {
    const [scannerError, setScannerError] = useState<string | null>(null);
    const [isScanning, setIsScanning] = useState<boolean>(false);
    const scannerInstanceRef = useRef<Html5Qrcode | null>(null);
    // --- MODIFICADO: Cambiar tipo de Timeout a number ---
    const initTimeoutRef = useRef<number | null>(null); // <- Tipo number
    // --- FIN MODIFICADO ---
    // --- ELIMINADO: initialMount ref ---
    // const initialMount = useRef(true);
    // --- FIN ELIMINADO ---


    const log = useCallback((message: string, ...optionalParams: any[]) => {
        if (verbose) { console.log(`[useQrScanner] ${message}`, ...optionalParams); }
    }, [verbose]);

    const clearScannerError = useCallback(() => { setScannerError(null); }, []);

    const startScanner = useCallback(async () => {
        // ... (l√≥gica interna de startScanner sin cambios funcionales, solo usa tipos correctos) ...
        if (!scannerInstanceRef.current) { log("Scanner instance not ready in startScanner."); setScannerError("El esc√°ner no est√° listo."); return; }
        if (isScanning) { log("Scanner already scanning in startScanner."); return; }
        log("Attempting to start scanner..."); clearScannerError();
        try {
            await scannerInstanceRef.current.start(
                { facingMode: "environment" },
                { fps: 10, qrbox: { width: 250, height: 250 }, ...config },
                (decodedText, result) => { // QrcodeSuccessCallback - result es de tipo Html5QrcodeResult impl√≠citamente
                     log(`Scan successful: ${decodedText}`, result);
                     if (!isScanning) return;
                     setIsScanning(false);
                     onScanSuccess(decodedText, result);
                 },
                (errorMessage, error) => { // QrcodeErrorCallback - error es de tipo Html5QrcodeError impl√≠citamente
                     const commonIgnoredErrors = ['QR code parse error', 'NotFoundException'];
                     if (!commonIgnoredErrors.some(e => errorMessage.includes(e))) {
                         console.warn(`[useQrScanner] Scan Error: ${errorMessage}`, error);
                         if (onScanError) { onScanError(errorMessage, error); }
                     }
                 }
            );
            log("Scanner started successfully."); setIsScanning(true);
        } catch (err: any) {
             console.error("[useQrScanner] Error starting scanner:", err);
             let friendlyError = 'Error desconocido al iniciar esc√°ner.';
             if (err.name === 'NotFoundError' || err.message?.includes('device not found')) { friendlyError = 'No se encontr√≥ una c√°mara compatible.'; }
             else if (err.name === 'NotAllowedError' || err.message?.includes('Permission denied')) { friendlyError = 'Permiso para acceder a la c√°mara denegado.'; }
             else if (err.message) { friendlyError = `Error al iniciar c√°mara: ${err.message}`; }
             setScannerError(friendlyError); setIsScanning(false);
        }
    }, [config, log, onScanError, onScanSuccess, isScanning, clearScannerError]);


    // Efecto para inicializar y limpiar
    useEffect(() => {
        if (enabled) {
            log("Hook enabled. Setting up initialization timeout...");
            // --- MODIFICADO: Usar window.setTimeout y window.clearTimeout ---
            initTimeoutRef.current = window.setTimeout(() => { // Usar window.setTimeout
                log("Initializing Html5Qrcode (after delay)...");
                try {
                    // A√±adir try/catch aqu√≠ por si el constructor falla
                    const scanner = new Html5Qrcode(qrcodeRegionId, verbose);
                    scannerInstanceRef.current = scanner;
                    startScanner();
                } catch (initError: any) {
                    console.error("[useQrScanner] Error initializing Html5Qrcode object:", initError);
                    setScannerError(`Error al inicializar lector QR: ${initError.message || 'Error desconocido'}`);
                }
            }, 500);
            // --- FIN MODIFICADO ---
        } else {
            // Limpieza cuando enabled pasa a false (sin cambios funcionales)
            if (initTimeoutRef.current) { log("Cleanup: Cleared pending initialization timeout."); window.clearTimeout(initTimeoutRef.current); initTimeoutRef.current = null; } // Usar window.clearTimeout
            if (scannerInstanceRef.current && isScanning) { log("Cleanup: Attempting to stop scanner..."); scannerInstanceRef.current.stop().then(() => { log("Cleanup: Scanner stopped successfully."); setIsScanning(false); }).catch((err) => { if (err.message?.includes('not running')) { log("Cleanup Warning: Attempted to stop scanner that wasn't running."); } else { console.error("[useQrScanner] Cleanup: Error stopping scanner:", err); } setIsScanning(false); }).finally(() => { log("Cleanup: Setting scanner instance ref to null."); scannerInstanceRef.current = null; });
            } else { log("Cleanup: No active scanner instance found to stop or hook disabled."); if (scannerInstanceRef.current) { scannerInstanceRef.current = null; } setIsScanning(false); }
        }

        // Funci√≥n de limpieza al desmontar (sin cambios funcionales)
        return () => {
            log("Component unmounting or 'enabled' changed. Running cleanup...");
            if (initTimeoutRef.current) { log("Cleanup: Cleared pending initialization timeout on unmount."); window.clearTimeout(initTimeoutRef.current); } // Usar window.clearTimeout
             if (scannerInstanceRef.current && isScanning) {
                 log("Cleanup: Attempting to stop scanner on unmount...");
                 try { scannerInstanceRef.current.stop().then(() => log("Cleanup: Scanner stopped successfully on unmount.")).catch((err) => { if (err.message?.includes('not running')) { log("Cleanup Warning: Attempted to stop scanner (unmount) that wasn't running."); } else { console.error("[useQrScanner] Cleanup: Error stopping scanner on unmount:", err); } }).finally(() => { scannerInstanceRef.current = null; log("Cleanup: Scanner instance ref set to null on unmount."); }); } catch (stopError) { console.error("[useQrScanner] Cleanup: Immediate error calling stop() on unmount:", stopError); scannerInstanceRef.current = null; }
             } else if (scannerInstanceRef.current) { log("Cleanup: Scanner instance exists but wasn't scanning on unmount. Setting ref to null."); scannerInstanceRef.current = null; }
            setIsScanning(false);
        };
    }, [qrcodeRegionId, enabled, verbose, log, startScanner, isScanning]);

    return { scannerError, clearScannerError, isScanning };
};

// End of File: frontend/src/hooks/useQrScanner.ts


// ====== [190] frontend/src/modules/loyalpyme/hooks/useUserProfileData.ts ======
// filename: frontend/src/hooks/useUserProfileData.ts
// Version: 1.5.0 (Return setUserData function and use imported types)

import { useState, useEffect, useCallback } from 'react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { AxiosError } from 'axios';
// Importar tipos desde el archivo central
import { UserData, UseProfileResult } from '../../../shared/types/user.types'; // Aseg√∫rate que la ruta es correcta


/**
 * Hook para obtener y gestionar los datos del perfil del usuario logueado.
 */
export const useUserProfileData = (): UseProfileResult => { // <-- Usa tipo importado
    const [userData, setUserData] = useState<UserData | null>(null); // <-- Usa tipo importado
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);

    const fetchUserProfile = useCallback(async () => {
        console.log('[useUserProfileData] Fetching user profile...');
        setLoading(true);
        setError(null);
        try {
            const response = await axiosInstance.get<UserData>('/profile'); // <-- Usa tipo importado
            if (response.data) {
                setUserData(response.data);
                console.log('[useUserProfileData] User profile updated.');
            } else {
                console.warn('[useUserProfileData] No user data received from /profile endpoint.');
                setUserData(null);
            }
        } catch (err) {
            console.error("[useUserProfileData] Error fetching user profile:", err);
            const errorMsg = err instanceof Error ? err.message : 'Ocurri√≥ un error desconocido.';
            let detailedError = `Error al cargar perfil: ${errorMsg}.`;
            if (err instanceof AxiosError && err.response) { detailedError += ` (Status: ${err.response.status})`; }
            setError(detailedError);
            setUserData(null);
        } finally {
            setLoading(false);
            console.log('[useUserProfileData] Fetch user profile finished.');
        }
    }, []);

    useEffect(() => {
        fetchUserProfile();
    }, [fetchUserProfile]);

    // Devolver tambi√©n setUserData
    // Aseg√∫rate de que esta secci√≥n es id√©ntica en tu archivo:
    return {
        userData,
        loading,
        error,
        refetch: fetchUserProfile,
        setUserData // <-- La propiedad que falta seg√∫n el error
    };
};

export default useUserProfileData;

// End of File: frontend/src/hooks/useUserProfileData.ts


// ====== [191] frontend/src/modules/loyalpyme/pages/CustomerDashboardPage.tsx ======
// filename: frontend/src/pages/CustomerDashboardPage.tsx
// Version: 3.0.15 (Pass redemption handlers/state to SummaryTab)

import { useState, useCallback, useMemo } from 'react';
import { Container, Title, Alert, Tabs, Text, Space, LoadingOverlay } from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { IconAlertCircle, IconCircleCheck, IconGift, IconLayoutDashboard, IconHistory, IconSpeakerphone, IconUserCircle } from '@tabler/icons-react';
import axiosInstance from '../../../shared/services/axiosInstance';
import { AxiosError } from 'axios';
import { useDisclosure } from '@mantine/hooks';
import { useTranslation } from 'react-i18next';

// Hooks
import { useUserProfileData } from '../hooks/useUserProfileData';
import { useCustomerRewardsData } from '../hooks/useCustomerRewardsData';
import { useCustomerTierData } from '../hooks/useCustomerTierData';
// Componentes de Pesta√±as
import SummaryTab from '../components/customer/dashboard/tabs/SummaryTab';
import RewardsTab from '../components/customer/dashboard/tabs/RewardsTab';
import ActivityTab from '../components/customer/dashboard/tabs/ActivityTab';
import OffersTab from '../components/customer/dashboard/tabs/OffersTab';
import ProfileTab from '../components/customer/dashboard/tabs/ProfileTab';

// Tipos
import {
    UserData,
    TierData,
    TierCalculationBasis,
    TierBenefitData
} from '../../../shared/types/user.types';

// Tipos locales
type ProgressBarDataType = { type: 'progress'; percentage: number; currentValueLabel: string; targetValueLabel: string; unit: string; nextTierName: string; } | { type: 'max_level'; currentTierName: string; } | null;
interface TierDisplayMemoResult { progressBarData: ProgressBarDataType; nextTierName: string | null; nextTierBenefits: TierBenefitData[]; }


function CustomerDashboardPage() {
    const { t } = useTranslation();
    // Hooks de datos
    const { userData, loading: loadingUser, error: errorUser, refetch: refetchUser, setUserData } = useUserProfileData();
    const { displayRewards, loadingRewards, loadingGrantedRewards, errorRewards, refreshRewards } = useCustomerRewardsData();
    const { allTiers, businessConfig, loading: loadingTierData, error: errorTierData, refetch: refetchTierData } = useCustomerTierData();
    // Estados locales de UI
    const [validatingQr, setValidatingQr] = useState(false);
    const [redeemingRewardId, setRedeemingRewardId] = useState<string | null>(null); // ID de la recompensa/regalo que se est√° canjeando
    const [scannerOpened, { open: openScanner, close: closeScanner }] = useDisclosure(false);
    const [activeTab, setActiveTab] = useState<string | null>('summary');
    // Handlers (sin cambios)
    const handleRefetchAll = useCallback(async () => { await Promise.all([refetchUser(), refreshRewards(), refetchTierData()]); }, [refetchUser, refreshRewards, refetchTierData]);
    const handleValidateQr = useCallback(async (token: string) => { setValidatingQr(true); try { const response = await axiosInstance.post<any>('/points/validate-qr', { qrToken: token }); const apiUser = response.data.user; const pointsEarned = response.data.pointsEarned ?? 0; if (!apiUser) { throw new Error(t('customerDashboard.errorValidatingQrMessage')); } notifications.show({ title: t('common.success'), message: t('customerDashboard.successQrValidation', { points: pointsEarned }), color: 'green', icon: <IconCircleCheck /> }); const currentUserData = userData; setUserData(prev => { if (!prev) return null; let newTierData: UserData['currentTier'] = null; if (apiUser.currentTierId) { const keepOldBenefits = prev.currentTier?.id === apiUser.currentTierId; newTierData = { id: apiUser.currentTierId, name: apiUser.currentTierName || prev.currentTier?.name || '', benefits: keepOldBenefits ? (prev.currentTier?.benefits || []) : [] }; } const newPoints: number = apiUser.points ?? currentUserData?.points ?? 0; const newTotalSpend: number = apiUser.totalSpend ?? currentUserData?.totalSpend ?? 0; const newTotalVisits: number = apiUser.totalVisits ?? currentUserData?.totalVisits ?? 0; return { ...prev, points: newPoints, totalSpend: newTotalSpend, totalVisits: newTotalVisits, currentTier: newTierData }; }); await handleRefetchAll(); } catch (err) { const errorMsg = (err instanceof AxiosError && err.response?.data?.message) ? err.response.data.message : (err instanceof Error ? err.message : t('customerDashboard.errorValidatingQrMessage')); notifications.show({ title: t('customerDashboard.errorValidatingQr'), message: errorMsg, color: 'red', icon: <IconAlertCircle /> }); } finally { setValidatingQr(false); } }, [handleRefetchAll, t, setUserData, userData]);
    const handleRedeemReward = useCallback(async (rewardId: string) => { setRedeemingRewardId(rewardId); try { await axiosInstance.post<any>(`/points/redeem-reward/${rewardId}`); notifications.show({ title: t('customerDashboard.successRedeemRewardTitle'), message: t('customerDashboard.successRedeemRewardMessage'), color: 'teal', icon: <IconGift /> }); await handleRefetchAll(); } catch (err) { const errorMsg = (err instanceof AxiosError && err.response?.data?.message) ? err.response.data.message : (err instanceof Error ? err.message : t('customerDashboard.errorRedeemMessage')); notifications.show({ title: t('customerDashboard.errorRedeemTitle'), message: errorMsg, color: 'red', icon: <IconAlertCircle /> }); } finally { setRedeemingRewardId(null); } }, [handleRefetchAll, t]);
    const handleRedeemGrantedReward = useCallback(async (grantedRewardId: string, rewardName: string) => { setRedeemingRewardId(grantedRewardId); try { await axiosInstance.post(`/customer/granted-rewards/${grantedRewardId}/redeem`); notifications.show({ title: t('customerDashboard.successRedeemGiftTitle'), message: t('customerDashboard.successRedeemGiftMessage', { rewardName }), color: 'green', icon: <IconCircleCheck /> }); await handleRefetchAll(); } catch (err) { const errorMsg = (err instanceof AxiosError && err.response?.data?.message) ? err.response.data.message : (err instanceof Error ? err.message : t('customerDashboard.errorRedeemGiftMessage')); notifications.show({ title: t('customerDashboard.errorRedeemTitle'), message: errorMsg, color: 'red', icon: <IconAlertCircle /> }); } finally { setRedeemingRewardId(null); } }, [handleRefetchAll, t]);

     // Memo tierDisplayData (sin cambios)
     const tierDisplayData = useMemo((): TierDisplayMemoResult => { const initialLoadingState: TierDisplayMemoResult = { progressBarData: null, nextTierName: null, nextTierBenefits: [] }; if (loadingUser || loadingTierData || !userData || !allTiers || !businessConfig || !businessConfig.tierCalculationBasis) { return initialLoadingState; } const sortTiersLocal = (tiers: TierData[]): TierData[] => [...tiers].sort((a, b) => a.level - b.level); const currentMetricValueFunc = (): number => { switch (businessConfig.tierCalculationBasis) { case TierCalculationBasis.SPEND: return userData.totalSpend ?? 0; case TierCalculationBasis.VISITS: return userData.totalVisits ?? 0; case TierCalculationBasis.POINTS_EARNED: return userData.points ?? 0; default: return 0; }}; const currentMetricValue = currentMetricValueFunc(); const sortedTiers = sortTiersLocal(allTiers); const currentTierIndex = sortedTiers.findIndex(t => t.id === userData.currentTier?.id); const currentTier = currentTierIndex !== -1 ? sortedTiers[currentTierIndex] : null; const currentTierMinValue = currentTier?.minValue ?? 0; const nextTier = currentTierIndex !== -1 && currentTierIndex < sortedTiers.length - 1 ? sortedTiers[currentTierIndex + 1] : null; let progressBarResult: ProgressBarDataType = null; let nextTierNameResult: string | null = null; let nextTierBenefitsResult: TierBenefitData[] = []; if (!nextTier) { progressBarResult = { type: 'max_level' as const, currentTierName: currentTier?.name || t('customerDashboard.baseTier') }; } else { nextTierNameResult = nextTier.name; nextTierBenefitsResult = nextTier.benefits ?? []; const nextTierMinValue = nextTier.minValue; const range = Math.max(0.01, nextTierMinValue - currentTierMinValue); const progressInTier = Math.max(0, currentMetricValue - currentTierMinValue); let percentage = (progressInTier / range) * 100; percentage = Math.max(0, Math.min(100, percentage)); let unit = ''; switch (businessConfig.tierCalculationBasis) { case TierCalculationBasis.SPEND: unit = '‚Ç¨'; break; case TierCalculationBasis.VISITS: unit = t('customerDashboard.progressUnitVisits'); break; case TierCalculationBasis.POINTS_EARNED: unit = t('common.points'); break; } const currentValueLabel = `${currentMetricValue.toLocaleString(undefined, { maximumFractionDigits: businessConfig.tierCalculationBasis === TierCalculationBasis.SPEND ? 2 : 0 })}`; const targetValueLabel = `${nextTierMinValue.toLocaleString(undefined, { maximumFractionDigits: businessConfig.tierCalculationBasis === TierCalculationBasis.SPEND ? 2 : 0 })}`; if (nextTierNameResult) { progressBarResult = { type: 'progress' as const, percentage: percentage, currentValueLabel: currentValueLabel, targetValueLabel: targetValueLabel, unit: unit, nextTierName: nextTierNameResult }; } else { progressBarResult = { type: 'max_level' as const, currentTierName: currentTier?.name || t('customerDashboard.baseTier') }; } } return { progressBarData: progressBarResult, nextTierName: nextTierNameResult, nextTierBenefits: nextTierBenefitsResult }; }, [userData, allTiers, businessConfig, loadingUser, loadingTierData, t]);
    // Memo currentTierBenefits (sin cambios)
    const currentTierBenefits = useMemo(() => { return userData?.currentTier?.benefits ?? []; }, [userData?.currentTier]);
    // Estados carga/error (sin cambios)
    const isLoading = loadingUser || loadingTierData || loadingRewards || loadingGrantedRewards;
    const mainError = errorUser || errorTierData || errorRewards;
    if (mainError && !isLoading) { return ( <Container size="lg" py="xl"><Alert icon={<IconAlertCircle size="1rem" />} title={t('common.errorLoadingData')} color="red" radius="md">{mainError}</Alert></Container> ); }

    // Renderizado Principal
    return (
        <Container size="lg" py="xl">
            <LoadingOverlay visible={loadingUser && !userData} overlayProps={{ radius: 'sm', blur: 2 }} />
            {userData && (
                <>
                    <Title order={2} ta="center" mb="xl">{t('customerDashboard.title')}</Title>
                    <Tabs value={activeTab} onChange={setActiveTab} keepMounted={false}>
                        <Tabs.List grow>
                            <Tabs.Tab value="summary" leftSection={<IconLayoutDashboard size={16} />}>{t('customerDashboard.tabSummary')}</Tabs.Tab>
                            <Tabs.Tab value="rewards" leftSection={<IconGift size={16} />}>{t('customerDashboard.tabRewards')}</Tabs.Tab>
                            <Tabs.Tab value="activity" leftSection={<IconHistory size={16} />}>{t('customerDashboard.tabActivity')}</Tabs.Tab>
                            <Tabs.Tab value="offers" leftSection={<IconSpeakerphone size={16} />} disabled>{t('customerDashboard.tabOffers')}</Tabs.Tab>
                            <Tabs.Tab value="profile" leftSection={<IconUserCircle size={16} />} disabled>{t('customerDashboard.tabProfile')}</Tabs.Tab>
                        </Tabs.List>
                        <Space h="xl" />
                        <Tabs.Panel value="summary">
                             {/* --- MODIFICADO: A√±adir props a SummaryTab --- */}
                            <SummaryTab
                                userData={userData}
                                loadingUser={loadingUser}
                                errorUser={errorUser}
                                progressBarData={tierDisplayData.progressBarData}
                                currentTierBenefits={currentTierBenefits}
                                nextTierName={tierDisplayData.nextTierName}
                                nextTierBenefits={tierDisplayData.nextTierBenefits}
                                displayRewards={displayRewards}
                                setActiveTab={setActiveTab}
                                handleValidateQr={handleValidateQr}
                                validatingQr={validatingQr}
                                scannerOpened={scannerOpened}
                                onOpenScanner={openScanner}
                                onCloseScanner={closeScanner}
                                // Nuevas props para canje:
                                userPoints={userData.points}
                                redeemingRewardId={redeemingRewardId}
                                onRedeemGift={handleRedeemGrantedReward}
                                onRedeemPoints={handleRedeemReward}
                            />
                             {/* --- FIN MODIFICACI√ìN --- */}
                        </Tabs.Panel>
                        <Tabs.Panel value="rewards">
                             <RewardsTab
                                 displayRewards={displayRewards}
                                 userPoints={userData.points}
                                 redeemingRewardId={redeemingRewardId}
                                 loadingRewards={loadingRewards} // Pasamos estos loadings aunque RewardList no los use (por ahora)
                                 loadingGrantedRewards={loadingGrantedRewards} // Pasamos estos loadings
                                 errorRewards={errorRewards}
                                 onRedeemPoints={handleRedeemReward}
                                 onRedeemGift={handleRedeemGrantedReward}
                             />
                         </Tabs.Panel>
                         <Tabs.Panel value="activity"><ActivityTab /></Tabs.Panel>
                         <Tabs.Panel value="offers"><OffersTab /></Tabs.Panel>
                         <Tabs.Panel value="profile"><ProfileTab /></Tabs.Panel>
                    </Tabs>
                </>
            )}
            {!userData && !loadingUser && !mainError && ( <Text ta="center" c="dimmed" mt="xl">{t('customerDashboard.noUserDataError', 'No se pudieron cargar los datos del usuario.')}</Text> )}
        </Container>
    );
}

export default CustomerDashboardPage;


// ====== [192] frontend/src/modules/loyalpyme/pages/admin/AdminCustomerManagementPage.module.css ======
/*
.th {
  padding: 0 !important;
}

.control {
  width: 100%;
  padding: var(--mantine-spacing-xs) var(--mantine-spacing-md);
  display: flex;
  justify-content: space-between;
  align-items: center;

  &:hover {
    background-color: light-dark(var(--mantine-color-gray-0), var(--mantine-color-dark-6));
  }

  &:disabled {
    cursor: default;
    &:hover {
       background-color: transparent;
    }
  }
}

.icon {
  width: rem(21px);
  height: rem(21px);
  border-radius: rem(21px);
}

.thead {
  position: sticky;
  top: 0;
  background-color: var(--mantine-color-body);
  transition: box-shadow 150ms ease;
  z-index: 1;

  &::after {
    content: '';
    position: absolute;
    left: 0;
    right: 0;
    bottom: 0;
    border-bottom: rem(1px) solid var(--table-border-color);
  }
}
*/


// ====== [193] frontend/src/modules/loyalpyme/pages/admin/AdminCustomerManagementPage.tsx ======
// frontend/src/pages/admin/AdminCustomerManagementPage.tsx
// Version 2.0.1 (Complete integration of FiltersBar, BulkActionsBar, and adminCustomerService)

import React, { useState, useEffect, useCallback } from 'react';
import {
    Paper, Title, Stack, Loader, Alert, Pagination, Group, Text
} from '@mantine/core';
import {
    IconAlertCircle, IconCheck, IconX
} from '@tabler/icons-react';
import { useDisclosure } from '@mantine/hooks';
import { useModals } from '@mantine/modals';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';

// Nuevos Componentes
import CustomerFiltersBar, { TierOption } from '../../components/admin/CustomerFiltersBar';
import CustomerBulkActionsBar from '../../components/admin/CustomerBulkActionsBar';

// Componentes Modales
import AdjustPointsModal from '../../components/admin/AdjustPointsModal';
import ChangeTierModal from '../../components/admin/ChangeTierModal';
import AssignRewardModal from '../../components/admin/AssignRewardModal';
import CustomerDetailsModal, { CustomerDetails } from '../../components/admin/CustomerDetailsModal';
import BulkAdjustPointsModal from '../../components/admin/BulkAdjustPointsModal';

// Hook y Tipos de Datos
import useAdminCustomersData, {
    Customer,
    UseAdminCustomersDataResult,
    SortColumn,
} from '../../hooks/useAdminCustomersData';
import CustomerTable from '../../components/admin/CustomerTable';

// Nuevo Servicio API
import * as adminCustomerService from '../../services/adminCustomerService';
import axiosInstance from '../../../../shared/services/axiosInstance';// Para fetchTiersForFilter

const AdminCustomerManagementPage: React.FC = () => {
    const { t } = useTranslation();
    const {
        customers, loading, error,
        currentPage, totalPages, totalItems,
        setPage, searchTerm, setSearchTerm, sortStatus, setSortStatus,
        filters, setFilters,
        refetch
    }: UseAdminCustomersDataResult = useAdminCustomersData();
    const modals = useModals();

    const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(null);
    const [adjustModalOpened, { open: openAdjustModal, close: closeAdjustModal }] = useDisclosure(false);
    const [changeTierModalOpened, { open: openChangeTierModal, close: closeChangeTierModal }] = useDisclosure(false);
    const [assignRewardModalOpened, { open: openAssignRewardModal, close: closeAssignRewardModal }] = useDisclosure(false);
    const [detailsModalOpened, { open: openDetailsModal, close: closeDetailsModal }] = useDisclosure(false);
    const [bulkAdjustModalOpened, { open: openBulkAdjustModal, close: closeBulkAdjustModal }] = useDisclosure(false);
    const [selectedCustomerDetails, setSelectedCustomerDetails] = useState<CustomerDetails | null>(null);
    const [loadingDetails, setLoadingDetails] = useState<boolean>(false);
    const [errorDetails, setErrorDetails] = useState<string | null>(null);
    const [togglingFavoriteId, setTogglingFavoriteId] = useState<string | null>(null);
    const [togglingActiveId, setTogglingActiveId] = useState<string | null>(null);
    const [isSavingNotes, setIsSavingNotes] = useState<boolean>(false);
    const [selectedRowIds, setSelectedRowIds] = useState<string[]>([]);
    const [isPerformingBulkAction, setIsPerformingBulkAction] = useState<boolean>(false);
    const [tierOptions, setTierOptions] = useState<TierOption[]>([]);
    const [loadingTiers, setLoadingTiers] = useState<boolean>(true);

    useEffect(() => {
        const fetchTiersForFilter = async () => {
            setLoadingTiers(true);
            try {
                const response = await axiosInstance.get<{ id: string; name: string; level: number }[]>('/tiers');
                const sortedTiers = response.data.sort((a, b) => a.level - b.level);
                const options: TierOption[] = [
                    { value: '', label: t('adminCustomersPage.tierFilterAll') },
                    { value: 'NONE', label: t('adminCustomersPage.tierFilterNone') },
                    ...sortedTiers.map(tier => ({ value: tier.id, label: tier.name }))
                ];
                setTierOptions(options);
            } catch (err) {
                console.error("Error fetching tiers for filter:", err);
                notifications.show({ title: t('common.error'), message: t('adminCustomersPage.tierFilterError'), color: 'red' });
                setTierOptions([{ value: '', label: t('adminCustomersPage.tierFilterError') }]);
            } finally { setLoadingTiers(false); }
        };
        fetchTiersForFilter();
    }, [t]);

    const handleOpenAdjustPoints = useCallback((customer: Customer) => { setSelectedCustomer(customer); openAdjustModal(); }, [openAdjustModal]);
    const handleAdjustSuccess = useCallback(() => { refetch(); closeAdjustModal(); setSelectedCustomer(null); }, [refetch, closeAdjustModal]);
    const handleOpenChangeTier = useCallback((customer: Customer) => { setSelectedCustomer(customer); openChangeTierModal(); }, [openChangeTierModal]);
    const handleChangeTierSuccess = useCallback(() => { refetch(); closeChangeTierModal(); setSelectedCustomer(null); }, [refetch, closeChangeTierModal]);
    const handleOpenAssignReward = useCallback((customer: Customer) => { setSelectedCustomer(customer); openAssignRewardModal(); }, [openAssignRewardModal]);
    const handleAssignRewardSuccess = useCallback(() => { refetch(); closeAssignRewardModal(); setSelectedCustomer(null); }, [refetch, closeAssignRewardModal]);
    const handleCloseDetailsModal = () => { closeDetailsModal(); setSelectedCustomerDetails(null); setLoadingDetails(false); setErrorDetails(null); };

    const handleToggleFavorite = useCallback(async (customerId: string, currentIsFavorite: boolean) => {
        setTogglingFavoriteId(customerId);
        try {
            await adminCustomerService.toggleCustomerFavoriteApi(customerId);
            notifications.show({
                title: t('common.updateSuccess'),
                message: t('adminCustomersPage.bulkActionStatusSuccess', { // Reutilizando clave de acci√≥n masiva para mensaje similar
                    count: 1, // Implica un cliente
                    status: !currentIsFavorite
                        ? t('adminCustomersPage.bulkActionStatusActivated').replace('activado', 'marcado como favorito') // Adaptar
                        : t('adminCustomersPage.bulkActionStatusDeactivated').replace('desactivado', 'desmarcado de favorito') // Adaptar
                }),
                color: 'green', icon: <IconCheck />
            });
            refetch();
        } catch (err: any) {
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.bulkActionStatusError', { // Reutilizando clave
                    action: 'cambiar estado de favorito', // Adaptar
                    error: err.response?.data?.message || err.message
                }),
                color: 'red', icon: <IconX />
            });
        } finally { setTogglingFavoriteId(null); }
    }, [refetch, t]);

    const handleToggleActive = useCallback(async (customer: Customer) => {
        const actionText = customer.isActive ? t('adminCustomersPage.bulkConfirmToggleDeactivate') : t('adminCustomersPage.bulkConfirmToggleActivate');
        const currentStatusText = customer.isActive ? t('adminCustomersPage.bulkActionStatusDeactivated') : t('adminCustomersPage.bulkActionStatusActivated');

        if (!window.confirm(t('adminCustomersPage.bulkConfirmToggleActiveMessage', { action: actionText, count: 1 }))) return;

        setTogglingActiveId(customer.id);
        try {
            await adminCustomerService.toggleCustomerActiveApi(customer.id);
            notifications.show({
                title: t('common.updateSuccess'),
                message: t('adminCustomersPage.bulkActionStatusSuccess', { count: 1, status: currentStatusText }),
                color: 'green', icon: <IconCheck />,
            });
            refetch();
        } catch (err: any) {
            console.error(`Error toggling active status for customer ${customer.id}:`, err);
            notifications.show({
                title: t('common.error'),
                message: t('adminCustomersPage.bulkActionStatusError', { action: actionText, error: err.response?.data?.message || err.message }),
                color: 'red', icon: <IconX />,
            });
        } finally { setTogglingActiveId(null); }
    }, [refetch, t]);

    const handleViewDetails = useCallback(async (customer: Customer) => {
        setSelectedCustomerDetails(null); setErrorDetails(null); setLoadingDetails(true); openDetailsModal();
        try {
            const details = await adminCustomerService.getCustomerDetailsApi(customer.id);
            setSelectedCustomerDetails(details);
        } catch (err: any) {
            setErrorDetails(err.response?.data?.message || err.message || t('adminCustomersPage.customerDetailsLoadingError'));
        } finally { setLoadingDetails(false); }
    }, [openDetailsModal, t]);

    const handleSaveNotes = useCallback(async (notes: string | null) => {
        if (!selectedCustomerDetails?.id) { return Promise.reject(new Error("Missing customer ID")); }
        setIsSavingNotes(true);
        try {
            await adminCustomerService.updateCustomerNotesApi(selectedCustomerDetails.id, notes);
            notifications.show({ title: t('common.saveSuccess'), message: t('adminCustomersPage.customerDetailsNotesSaved'), color: 'green', icon: <IconCheck /> });
            const details = await adminCustomerService.getCustomerDetailsApi(selectedCustomerDetails.id);
            setSelectedCustomerDetails(details);
        } catch (err: any) {
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
            notifications.show({ title: t('common.saveError'), message: t('adminCustomersPage.customerDetailsNotesError', { error: apiError }), color: 'red', icon: <IconX /> });
            throw err;
        } finally { setIsSavingNotes(false); }
    }, [selectedCustomerDetails, t]);

    const handleTableSort = useCallback((column: SortColumn) => { setSortStatus({ column, direction: sortStatus.column === column && sortStatus.direction === 'asc' ? 'desc' : 'asc' }); }, [sortStatus, setSortStatus]);
    const handleRowSelectionChange = useCallback((selectedIds: string[]) => { setSelectedRowIds(selectedIds); }, []);

    const handleBulkToggleActive = useCallback(async (targetStatus: boolean) => {
        const action = targetStatus ? t('adminCustomersPage.bulkConfirmToggleActivate') : t('adminCustomersPage.bulkConfirmToggleDeactivate');
        const count = selectedRowIds.length;
        if (count === 0) {
            notifications.show({ title: t('common.info'), message: t('adminCustomersPage.bulkActionNoneSelected'), color: 'yellow' });
            return;
        }
        if (!window.confirm(t('adminCustomersPage.bulkConfirmToggleActiveMessage', { action, count }))) return;

        setIsPerformingBulkAction(true);
        try {
            const response = await adminCustomerService.bulkUpdateCustomerStatusApi(selectedRowIds, targetStatus);
            const statusResult = targetStatus ? t('adminCustomersPage.bulkActionStatusActivated') : t('adminCustomersPage.bulkActionStatusDeactivated');
            notifications.show({ title: t('adminCommon.updateSuccess'), message: t('adminCustomersPage.bulkActionStatusSuccess', { count: response.count, status: statusResult }), color: 'green', icon: <IconCheck /> });
            refetch(); setSelectedRowIds([]);
        } catch (err: any) {
            console.error(`Error during bulk ${action}:`, err);
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
            notifications.show({ title: t('adminCommon.updateError'), message: t('adminCustomersPage.bulkActionStatusError', { action, error: apiError }), color: 'red', icon: <IconX /> });
        } finally { setIsPerformingBulkAction(false); }
    }, [selectedRowIds, refetch, t]);

    const handleBulkDelete = useCallback(() => {
        const count = selectedRowIds.length;
        if (count === 0) {
            notifications.show({ title: t('common.info'), message: t('adminCustomersPage.bulkActionNoneSelected'), color: 'yellow' });
            return;
        }
        modals.openConfirmModal({
            title: t('adminCustomersPage.bulkConfirmDeleteTitle'), centered: true,
            children: ( <Text size="sm">{t('adminCustomersPage.bulkConfirmDeleteMessage', { count })}</Text> ),
            labels: { confirm: t('adminCustomersPage.bulkConfirmDeleteButton'), cancel: t('common.cancel') },
            confirmProps: { color: 'red' }, zIndex: 1001,
            onConfirm: async () => {
                setIsPerformingBulkAction(true);
                try {
                    const response = await adminCustomerService.bulkDeleteCustomersApi(selectedRowIds);
                    notifications.show({ title: t('adminCommon.deleteSuccess'), message: t('adminCustomersPage.bulkActionDeleteSuccess', { count: response.count }), color: 'green', icon: <IconCheck /> });
                    refetch(); setSelectedRowIds([]);
                } catch (err: any) {
                    console.error(`Error during bulk delete:`, err);
                    const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
                    notifications.show({ title: t('adminCommon.deleteError'), message: t('adminCustomersPage.bulkActionDeleteError', { error: apiError }), color: 'red', icon: <IconX /> });
                } finally { setIsPerformingBulkAction(false); }
            },
        });
    }, [selectedRowIds, refetch, modals, t]);

    const handleBulkAdjustPointsSubmit = useCallback(async (values: { amount: number; reason?: string | undefined }) => {
        const { amount, reason } = values; const count = selectedRowIds.length;
        if (count === 0) {
            notifications.show({ title: t('common.error'), message: t('adminCustomersPage.bulkAdjustPointsErrorNoneSelected'), color: 'red' });
            return Promise.reject(new Error("No customers selected"));
        }
        setIsPerformingBulkAction(true); closeBulkAdjustModal();
        try {
            const response = await adminCustomerService.bulkAdjustCustomerPointsApi(selectedRowIds, amount, reason || null);
            const actionResult = amount > 0 ? t('adminCustomersPage.bulkAdjustPointsAdded') : t('adminCustomersPage.bulkAdjustPointsSubtracted');
            notifications.show({ title: t('adminCommon.updateSuccess'), message: t('adminCustomersPage.bulkAdjustPointsSuccess', { points: Math.abs(amount), action: actionResult, count: response.count }), color: 'green', icon: <IconCheck /> });
            refetch(); setSelectedRowIds([]);
        } catch (err: any) {
            console.error(`Error during bulk points adjustment:`, err);
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
            notifications.show({ title: t('adminCommon.updateError'), message: t('adminCustomersPage.bulkAdjustPointsError', { error: apiError }), color: 'red', icon: <IconX /> });
            throw err; // Relanzar para que el modal sepa que fall√≥ y no se cierre si as√≠ est√° programado
        } finally { setIsPerformingBulkAction(false); }
    }, [selectedRowIds, refetch, closeBulkAdjustModal, t]);

    const handleFilterSearchTermChange = (term: string) => setSearchTerm(term);
    const handleFilterActiveChange = (value: string | null) => {
        setFilters({ isActive: value === 'active' ? true : value === 'inactive' ? false : undefined });
    };
    const handleFilterFavoriteChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        setFilters({ isFavorite: event.currentTarget.checked ? true : undefined });
    };
    const handleFilterTierChange = (value: string | null) => {
        setFilters({ tierId: value || undefined });
    };

    const areFiltersActive = filters.isActive !== undefined || filters.isFavorite !== undefined || filters.tierId !== undefined;

    return (
        <>
            <Paper shadow="sm" p="lg" withBorder radius="lg">
                <Stack gap="lg">
                    <Title order={2}>{t('adminCustomersPage.title')}</Title>
                    <CustomerFiltersBar
                        searchTerm={searchTerm}
                        onSearchTermChange={handleFilterSearchTermChange}
                        activeFilterValue={filters.isActive === true ? 'active' : filters.isActive === false ? 'inactive' : ''}
                        onActiveFilterChange={handleFilterActiveChange}
                        isFavoriteFilterChecked={filters.isFavorite === true}
                        onIsFavoriteFilterChange={handleFilterFavoriteChange}
                        tierFilterValue={filters.tierId || ''}
                        onTierFilterChange={handleFilterTierChange}
                        tierOptions={tierOptions}
                        loadingFilters={loadingTiers}
                        disabled={loading || isPerformingBulkAction}
                    />
                    <CustomerBulkActionsBar
                        selectedRowCount={selectedRowIds.length}
                        onBulkDelete={handleBulkDelete}
                        onBulkActivate={() => handleBulkToggleActive(true)}
                        onBulkDeactivate={() => handleBulkToggleActive(false)}
                        onOpenBulkAdjustPoints={openBulkAdjustModal}
                        isPerformingBulkAction={isPerformingBulkAction}
                    />

                    {!loading && !error && (
                        <Group justify="space-between">
                            <Text size="sm" c="dimmed">
                                {t('adminCustomersPage.resultsCount', { count: totalItems })}
                                {searchTerm || areFiltersActive ? ` ${t('adminCustomersPage.resultsCountFiltered')}` : ''}.
                            </Text>
                        </Group>
                    )}
                    {loading && <Group justify="center" p="md"><Loader /></Group>}
                    {error && !loading && <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{error}</Alert>}
                    {!loading && !error && customers.length === 0 && totalItems > 0 && (
                         <Text c="dimmed" ta="center" p="md">{t('adminCustomersPage.noResultsFiltered')}</Text>
                     )}
                    {!loading && !error && totalItems === 0 && (
                         <Text c="dimmed" ta="center" p="md">{searchTerm || areFiltersActive ? t('adminCustomersPage.noResultsFiltered') : t('adminCustomersPage.noResults')}.</Text>
                     )}

                    {!loading && !error && customers.length > 0 && (
                        <CustomerTable
                            customers={customers}
                            sortStatus={sortStatus}
                            togglingFavoriteId={togglingFavoriteId}
                            togglingActiveId={togglingActiveId}
                            selectedRows={selectedRowIds}
                            onSort={handleTableSort}
                            onToggleFavorite={handleToggleFavorite}
                            onOpenAdjustPoints={handleOpenAdjustPoints}
                            onOpenChangeTier={handleOpenChangeTier}
                            onOpenAssignReward={handleOpenAssignReward}
                            onViewDetails={handleViewDetails}
                            onToggleActive={handleToggleActive}
                            onRowSelectionChange={handleRowSelectionChange}
                        />
                    )}
                    {!loading && !error && totalPages > 1 && (
                        <Group justify="center" mt="md">
                            <Pagination total={totalPages} value={currentPage} onChange={setPage} disabled={loading || isPerformingBulkAction}/>
                        </Group>
                    )}
                </Stack>
            </Paper>

            <AdjustPointsModal
                opened={adjustModalOpened}
                onClose={() => { closeAdjustModal(); setSelectedCustomer(null); }}
                customer={selectedCustomer}
                onSuccess={handleAdjustSuccess} // Este onSuccess ahora es solo para refetch y cerrar modal
            />
            <ChangeTierModal
                opened={changeTierModalOpened}
                onClose={() => { closeChangeTierModal(); setSelectedCustomer(null); }}
                customer={selectedCustomer}
                onSuccess={handleChangeTierSuccess} // Similarmente, para refetch y cerrar
            />
            <AssignRewardModal
                opened={assignRewardModalOpened}
                onClose={() => { closeAssignRewardModal(); setSelectedCustomer(null); }}
                customer={selectedCustomer}
                onSuccess={handleAssignRewardSuccess} // Similarmente
            />
            <CustomerDetailsModal
                opened={detailsModalOpened}
                onClose={handleCloseDetailsModal}
                customerDetails={selectedCustomerDetails}
                isLoading={loadingDetails || isSavingNotes}
                error={errorDetails}
                onSaveNotes={handleSaveNotes} // Este ya usa el servicio
            />
            <BulkAdjustPointsModal
                opened={bulkAdjustModalOpened}
                onClose={closeBulkAdjustModal}
                onSubmit={handleBulkAdjustPointsSubmit} // Este ya usa el servicio
                numberOfCustomers={selectedRowIds.length}
            />
        </>
    );
};

export default AdminCustomerManagementPage;


// ====== [194] frontend/src/modules/loyalpyme/pages/admin/AdminGenerateQr.tsx ======
// filename: frontend/src/pages/admin/AdminGenerateQr.tsx
import React from 'react';
import GenerateQrCode from '../../components/GenerateQrCode';
import { Paper, Stack, Title } from '@mantine/core';
import { useTranslation } from 'react-i18next';

const AdminGenerateQr: React.FC = () => {
    const { t } = useTranslation();

    return (
        <Paper shadow="xs" p="lg" withBorder radius="lg">
            <Stack gap="md">
                {/* Usamos la clave del t√≠tulo de la tarjeta de acceso r√°pido que ya ten√≠amos */}
                <Title order={2}>{t('adminOverview.cardQrTitle')}</Title>
                <GenerateQrCode />
            </Stack>
        </Paper>
    );
};

export default AdminGenerateQr;


// ====== [195] frontend/src/modules/loyalpyme/pages/admin/AdminOverview.tsx ======
// frontend/src/pages/admin/AdminOverview.tsx
import { useEffect, useState, FC } from 'react';
import {
    Container, Title, Text, SimpleGrid, Card, Button, Group, Stack,
    Loader, Alert
} from '@mantine/core';
import {
    IconGift, IconStairsUp, IconQrcode, IconUsers, IconSettings,
    IconUserPlus, IconTicket, IconAlertCircle, IconToolsKitchen
} from '@tabler/icons-react';
import { Link } from 'react-router-dom';
import { useTranslation } from 'react-i18next';

import { useAdminOverviewStats } from '../../hooks/useAdminOverviewStats';
import StatCard from '../../components/admin/StatCard';
import { useLayoutUserData } from '../../../../shared/hooks/useLayoutUserData';

const AdminOverview: FC = () => {
    const { t } = useTranslation();
    const { userData: layoutUserData, loadingUser: loadingLayoutUser } = useLayoutUserData();
    const [adminName, setAdminName] = useState<string | null>(null);
    const [businessName, setBusinessName] = useState<string | null>(null);

    const {
        statsData,
        loadingStats,
        errorStats,
        newCustomersTrend,
        pointsIssuedTrend,
        rewardsRedeemedTrend,
    } = useAdminOverviewStats();

    useEffect(() => {
        if (layoutUserData) {
            setAdminName(layoutUserData.name || layoutUserData.email || t('adminCommon.adminTitle'));
            // Como discutimos, /api/profile no devuelve el nombre del negocio directamente en layoutUserData.
            // Si quisieras el nombre real del negocio aqu√≠, necesitar√≠as:
            // 1. Que /api/profile (auth.middleware.ts) a√±ada business.name a req.user
            // 2. O hacer una llamada API separada aqu√≠ para obtener los detalles del layoutUserData.businessId
            // Por ahora, mantenemos el placeholder.
            setBusinessName(t('adminOverview.defaultBusinessName'));
        } else if (!loadingLayoutUser) {
            setAdminName(t('adminCommon.adminTitle'));
            setBusinessName(t('adminOverview.defaultBusinessName'));
        }
    }, [layoutUserData, loadingLayoutUser, t]);

    const routes = {
        rewards: '/admin/dashboard/rewards',
        generateQr: '/admin/dashboard/generate-qr',
        manageTiers: '/admin/dashboard/tiers/manage',
        settingsTiers: '/admin/dashboard/tiers/settings',
        customers: '/admin/dashboard/customers',
        camareroMenuEditor: "/admin/dashboard/camarero/menu-editor", // Ruta actualizada
    };

    const isLoadingPage = loadingLayoutUser || loadingStats;

    const quickAccessCards = [
        {
            titleKey: 'adminOverview.cardRewardsTitle',
            descriptionKey: 'adminOverview.cardRewardsDesc',
            buttonTextKey: 'adminOverview.cardRewardsButton',
            icon: IconGift,
            color: 'blue',
            to: routes.rewards,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true,
        },
        {
            titleKey: 'adminOverview.cardTiersTitle',
            descriptionKey: 'adminOverview.cardTiersDesc',
            buttonTextKey: 'adminOverview.cardTiersButton',
            icon: IconStairsUp,
            color: 'teal',
            to: routes.manageTiers,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true,
        },
        {
            titleKey: 'adminOverview.cardTierSettingsTitle',
            descriptionKey: 'adminOverview.cardTierSettingsDesc',
            buttonTextKey: 'adminOverview.cardTierSettingsButton',
            icon: IconSettings,
            color: 'orange',
            to: routes.settingsTiers,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true,
        },
        {
            titleKey: 'adminOverview.cardQrTitle',
            descriptionKey: 'adminOverview.cardQrDesc',
            buttonTextKey: 'adminOverview.cardQrButton',
            icon: IconQrcode,
            color: 'grape',
            to: routes.generateQr,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true,
        },
        {
            titleKey: 'adminOverview.cardCustomersTitle',
            descriptionKey: 'adminOverview.cardCustomersDesc',
            buttonTextKey: 'adminOverview.cardCustomersButton',
            icon: IconUsers,
            color: 'indigo',
            to: routes.customers,
            showCondition: layoutUserData?.isLoyaltyCoreActive === true || layoutUserData?.isCamareroActive === true,
        },
        // Tarjeta para Gesti√≥n de Men√∫ del M√≥dulo Camarero
        {
            titleKey: 'adminCamarero.manageMenu.title', // Usar clave de t√≠tulo de p√°gina para consistencia
            descriptionKey: 'adminCamarero.cardMenuDesc', // Clave para descripci√≥n de la tarjeta
            buttonTextKey: 'adminCamarero.cardMenuButton', // Clave para texto del bot√≥n
            icon: IconToolsKitchen,
            color: 'lime',
            to: routes.camareroMenuEditor, // Ruta correcta
            showCondition: layoutUserData?.isCamareroActive === true,
        },
    ];

    if (isLoadingPage && !statsData && !layoutUserData) {
        return <Container size="lg" mt="md"><Group justify="center" p="xl"><Loader /></Group></Container>;
    }

    return (
        <Container size="lg" mt="md">
            <Stack gap="xl">
                <Title order={2}>{t('adminOverview.welcome', { name: adminName || t('adminCommon.adminTitle') })}</Title>
                <Text fz="lg">
                    {t('adminOverview.panelIntro')}{' '}
                    <Text span fw={700}>{businessName || '...'}</Text>.
                </Text>
                <Text c="dimmed">{t('adminOverview.panelDescription')}</Text>

                <Title order={3} mt="lg">{t('adminOverview.quickSummaryTitle')}</Title>
                {loadingStats && !statsData && ( <Group justify="center" p="lg"><Loader size="sm" /></Group> )}
                {errorStats && !loadingStats && ( <Alert title={t('common.errorLoadingData')} color="red" icon={<IconAlertCircle size={18} />}>{errorStats}</Alert> )}
                {!loadingStats && !errorStats && statsData && (
                    <SimpleGrid cols={{ base: 1, sm: 2, lg: 4 }}>
                        <StatCard title={t('adminOverview.statActiveCustomers')} value={statsData.totalActiveCustomers} icon={<IconUsers size={24} stroke={1.5} />} color="blue" />
                        <StatCard title={t('adminOverview.statNewCustomers')} value={statsData.newCustomersLast7Days} icon={<IconUserPlus size={24} stroke={1.5} />} color="teal" trendValue={newCustomersTrend.trendValue} trendDirection={newCustomersTrend.trendDirection} />
                        <StatCard title={t('adminOverview.statPointsIssued')} value={statsData.pointsIssuedLast7Days} icon={<IconTicket size={24} stroke={1.5} />} color="grape" trendValue={pointsIssuedTrend.trendValue} trendDirection={pointsIssuedTrend.trendDirection} />
                        <StatCard title={t('adminOverview.statRedemptions')} value={statsData.rewardsRedeemedLast7Days} icon={<IconGift size={24} stroke={1.5} />} color="orange" trendValue={rewardsRedeemedTrend.trendValue} trendDirection={rewardsRedeemedTrend.trendDirection} />
                    </SimpleGrid>
                )}
                {!loadingStats && !errorStats && !statsData && ( <Text c="dimmed" ta="center">{t('adminOverview.noStatsAvailable')}</Text> )}

                <Title order={3} mt="lg">{t('adminOverview.quickAccessTitle')}</Title>
                <SimpleGrid cols={{ base: 1, sm: 2, md: 3 }}>
                    {quickAccessCards.filter(card => card.showCondition).map((card) => (
                        <Card shadow="sm" padding="lg" radius="md" withBorder key={card.to}>
                            <Group justify="space-between" mt="md" mb="xs">
                                <Text fw={500}>{t(card.titleKey)}</Text>
                                <card.icon size={24} stroke={1.5} />
                            </Group>
                            <Text size="sm" c="dimmed">{t(card.descriptionKey)}</Text>
                            <Button variant="light" color={card.color} fullWidth mt="md" radius="md" component={Link} to={card.to}>
                                {t(card.buttonTextKey)}
                            </Button>
                        </Card>
                    ))}
                </SimpleGrid>
                {quickAccessCards.filter(card => card.showCondition).length === 0 && !isLoadingPage && (
                    <Text c="dimmed" ta="center">{t('adminOverview.noModulesActivePrompt')}</Text>
                )}
            </Stack>
        </Container>
    );
};

export default AdminOverview;


// ====== [196] frontend/src/modules/loyalpyme/pages/admin/AdminRewardsManagement.tsx ======
// filename: frontend/src/pages/admin/AdminRewardsManagement.tsx
// Version: 1.4.4 (Fix hydration warnings and Tooltip error)

import React, { useState, useCallback } from 'react';
import {
    Group, Button, Title, Text, Loader, Alert, Paper, Stack,
    Table, Badge, ActionIcon, Tooltip, Modal,
} from '@mantine/core';
import { useDisclosure, useMediaQuery } from '@mantine/hooks';
import { useMantineTheme } from '@mantine/core';
import {
    IconAlertCircle, IconPencil, IconTrash, IconToggleLeft, IconToggleRight,
    IconPlus
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import { useAdminRewards } from '../../hooks/useAdminRewards';
import type { Reward } from '../../types/customer';
import RewardForm from '../../components/admin/rewards/RewardForm.tsx';

const AdminRewardsManagement: React.FC = () => {
    const { t, i18n } = useTranslation();
    const { rewards, loading, error, actionLoading, fetchRewards, handleToggleActive, handleDeleteReward } = useAdminRewards();
    const [showAddForm, setShowAddForm] = useState<boolean>(false);
    const [editModalOpened, { open: openEditModalHandler, close: closeEditModal }] = useDisclosure(false);
    const [editingReward, setEditingReward] = useState<Reward | null>(null);
    const theme = useMantineTheme();
    const isMobile = useMediaQuery(`(max-width: ${theme.breakpoints.sm})`);

    const handleRewardAdded = useCallback(() => { setShowAddForm(false); fetchRewards(); }, [fetchRewards]);
    const handleOpenEditModal = (reward: Reward) => { setEditingReward(reward); openEditModalHandler(); };
    const handleCloseEditModal = () => { closeEditModal(); setEditingReward(null); };
    const handleRewardUpdated = useCallback(() => { handleCloseEditModal(); fetchRewards(); }, [fetchRewards, handleCloseEditModal]);

    const confirmAndDeleteReward = useCallback((reward: Reward) => {
        const displayName = (i18n.language === 'es' ? reward.name_es : reward.name_en) || reward.name_es || reward.name_en || `ID ${reward.id}`;
        if (window.confirm(t('adminRewardsPage.confirmDeleteMessage', { name: displayName }))) {
            handleDeleteReward(reward.id, displayName);
        }
    }, [handleDeleteReward, t, i18n.language]);


    // --- Renderizado de la Tabla ACTUALIZADO (Limpieza JSX) ---
    const renderRewardsTable = () => {
        const rows = rewards.map((reward) => {
            const iconSize = 14;
            const isLoadingToggle = actionLoading?.type === 'toggle' && actionLoading?.id === reward.id;
            const isLoadingDelete = actionLoading?.type === 'delete' && actionLoading?.id === reward.id;
            const isAnyActionLoading = !!actionLoading;
            const displayName = (i18n.language === 'es' ? reward.name_es : reward.name_en) || reward.name_es || reward.name_en || '(Sin nombre)';

            // Definimos los iconos con Tooltip por separado
            const editIcon = (
                <Tooltip label={t('adminRewardsPage.tooltipEdit')} withArrow position={isMobile ? 'bottom' : 'left'}>
                    <ActionIcon variant="subtle" color="blue" onClick={() => handleOpenEditModal(reward)} disabled={isAnyActionLoading}>
                        <IconPencil size={iconSize} stroke={1.5} />
                    </ActionIcon>
                </Tooltip>
            );
            const toggleIcon = (
                <Tooltip label={reward.isActive ? t('adminRewardsPage.tooltipDeactivate') : t('adminRewardsPage.tooltipActivate')} withArrow position="top">
                    <ActionIcon variant="subtle" color={reward.isActive ? 'orange' : 'teal'} onClick={() => handleToggleActive(reward.id, reward.isActive)} loading={isLoadingToggle} disabled={isAnyActionLoading}>
                        {reward.isActive ? <IconToggleLeft size={iconSize} stroke={1.5} /> : <IconToggleRight size={iconSize} stroke={1.5} />}
                    </ActionIcon>
                </Tooltip>
            );
             const deleteIcon = (
                <Tooltip label={t('adminRewardsPage.tooltipDelete')} withArrow position={isMobile ? 'bottom' : 'right'}>
                    <ActionIcon variant="subtle" color="red" onClick={() => confirmAndDeleteReward(reward)} loading={isLoadingDelete} disabled={isAnyActionLoading}>
                        <IconTrash size={iconSize} stroke={1.5} />
                    </ActionIcon>
                </Tooltip>
             );

            // El <></> que devolv√≠a actionIcons podr√≠a causar problemas con Tooltip.
            // Ahora renderizamos los iconos directamente dentro de Group o Stack.
            return (
                // No dejar espacios extra entre <Table.Tr> y <Table.Td>
                <Table.Tr key={reward.id}>
                    <Table.Td fz={{ base: 'xs', sm: 'sm' }}>{displayName}</Table.Td>
                    <Table.Td fz={{ base: 'xs', sm: 'sm' }}>{reward.pointsCost}</Table.Td>
                    <Table.Td><Badge color={reward.isActive ? 'green' : 'gray'} variant="light" radius="lg" fz={{ base: 'xs', sm: 'sm' }}>{reward.isActive ? t('common.active') : t('common.inactive')}</Badge></Table.Td>
                    <Table.Td>
                        {isMobile ? (
                            <Stack gap={2} align="flex-end">{/* No dejar espacio extra aqu√≠ */}
                                {editIcon}
                                {toggleIcon}
                                {deleteIcon}
                            </Stack>
                        ) : (
                            <Group gap="xs" justify="flex-end" wrap="nowrap">{/* No dejar espacio extra aqu√≠ */}
                                {editIcon}
                                {toggleIcon}
                                {deleteIcon}
                            </Group>
                        )}
                    </Table.Td>
                </Table.Tr> // No dejar espacio extra aqu√≠
            );
        });

        return (
            // No dejar espacios extra entre elementos de tabla
            <Table striped highlightOnHover withTableBorder withColumnBorders verticalSpacing="sm">
                <Table.Thead>
                    <Table.Tr>
                        <Table.Th fz={{ base: 'xs', sm: 'sm' }}>{t('adminRewardsPage.tableHeaderName')}</Table.Th>
                        <Table.Th fz={{ base: 'xs', sm: 'sm' }}>{t('adminRewardsPage.tableHeaderCost')}</Table.Th>
                        <Table.Th fz={{ base: 'xs', sm: 'sm' }}>{t('adminRewardsPage.tableHeaderStatus')}</Table.Th>
                        <Table.Th style={{ textAlign: 'right' }} fz={{ base: 'xs', sm: 'sm' }}>{t('adminRewardsPage.tableHeaderActions')}</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>{rows}</Table.Tbody>
            </Table>
        );
    };
     // --- FIN Renderizado Tabla ---

    // Renderizado condicional (sin cambios)
    const renderRewardsSectionContent = () => { /* ... (sin cambios) ... */ if (loading && rewards.length === 0) return <Group justify="center" p="lg"><Loader /></Group>; if (error && rewards.length === 0) return (<Alert icon={<IconAlertCircle size={16} />} title={t('common.errorLoadingData')} color="red" radius="lg">{error}</Alert>); if (!loading && rewards.length === 0 && !showAddForm) return <Text c="dimmed" ta="center" p="lg">{t('adminRewardsPage.noRewardsYet')}</Text>; if (rewards.length > 0) return renderRewardsTable(); return null; };

    // RENDER PRINCIPAL (sin cambios)
    return (
        <>
            <Paper shadow="xs" p="lg" withBorder radius="lg">
                <Stack gap="md">
                    <Group justify="space-between" align="flex-start"> <Title order={2}>{t('adminRewardsPage.title')}</Title> <Button leftSection={showAddForm ? undefined : <IconPlus size={18} />} onClick={() => setShowAddForm(!showAddForm)} disabled={loading && rewards.length === 0} variant={showAddForm ? "outline" : "filled"} radius="lg" > {showAddForm ? t('adminRewardsPage.cancelAddButton') : t('adminRewardsPage.addButton')} </Button> </Group>
                     {renderRewardsSectionContent()}
                    {showAddForm && ( <Paper withBorder p="md" mt="md" radius="lg"> <RewardForm mode="add" onSubmitSuccess={handleRewardAdded} onCancel={() => setShowAddForm(false)} /> </Paper> )}
                </Stack>
            </Paper>
            <Modal opened={editModalOpened} onClose={handleCloseEditModal} title={t('adminRewardsPage.editFormTitle')} centered radius="lg" size="lg" overlayProps={{ backgroundOpacity: 0.55, blur: 3 }} >
                {editingReward && ( <RewardForm mode="edit" initialData={editingReward} rewardIdToUpdate={editingReward.id} onSubmitSuccess={handleRewardUpdated} onCancel={handleCloseEditModal} /> )}
            </Modal>
        </>
    );
};

export default AdminRewardsManagement;


// ====== [197] frontend/src/modules/loyalpyme/pages/admin/tiers/TierManagementPage.tsx ======
// filename: frontend/src/pages/admin/tiers/TierManagementPage.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
    Paper, Title, Stack, Button, Group, Loader, Alert,
    Text
} from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { notifications } from '@mantine/notifications';
import { IconPlus, IconAlertCircle, IconCheck } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';
import { useTranslation } from 'react-i18next'; // Importar hook

// Importar componentes
import TierTable from '../../../components/admin/tiers/TierTable';
import CreateTierModal from '../../../components/admin/tiers/CreateTierModal';
import DeleteTierModal from '../../../components/admin/tiers/DeleteTierModal';
import EditTierModal from '../../../components/admin/tiers/EditTierModal';
import TierBenefitsModal from '../../../components/admin/tiers/TierBenefitsModal';

// Tipos
enum BenefitType { POINTS_MULTIPLIER = 'POINTS_MULTIPLIER', EXCLUSIVE_REWARD_ACCESS = 'EXCLUSIVE_REWARD_ACCESS', CUSTOM_BENEFIT = 'CUSTOM_BENEFIT' }
interface TierBenefit { id: string; isActive: boolean; type: BenefitType; value: string; description: string | null; }
interface Tier { id: string; name: string; level: number; minValue: number; description: string | null; benefitsDescription: string | null; isActive: boolean; benefits: TierBenefit[]; }


const TierManagementPage: React.FC = () => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    // Estado
    const [tiers, setTiers] = useState<Tier[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [deletingTier, setDeletingTier] = useState<Tier | null>(null);
    const [deleteModalOpened, { open: openDeleteModal, close: closeDeleteModal }] = useDisclosure(false);
    const [createModalOpened, { open: openCreateModal, close: closeCreateModal }] = useDisclosure(false);
    const [editingTier, setEditingTier] = useState<Tier | null>(null);
    const [editModalOpened, { open: openEditModal, close: closeEditModal }] = useDisclosure(false);
    const [viewingBenefitsForTier, setViewingBenefitsForTier] = useState<Tier | null>(null);
    const [benefitsModalOpened, { open: openBenefitsModal, close: closeBenefitsModal }] = useDisclosure(false);

    // L√≥gica de Datos
    const fetchTiers = useCallback(async () => {
        setLoading(true); setError(null);
        try {
            const response = await axiosInstance.get<Tier[]>('/tiers?includeBenefits=true');
            setTiers(response.data);
        } catch (err: any) {
            console.error("Error fetching tiers:", err);
            const message = err.response?.data?.message || t('adminCommon.errorLoadingData'); // Usar t() para error gen√©rico
            setError(message);
            notifications.show({
                title: t('common.errorLoadingData'), // T√≠tulo gen√©rico
                message: message,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
        } finally {
            setLoading(false);
        }
    }, [t]); // A√±adir t como dependencia

    useEffect(() => {
        fetchTiers();
    }, [fetchTiers]);

    // Handlers CRUD
    const handleCreate = () => { openCreateModal(); };
    const handleCreateSuccess = () => { fetchTiers(); }; // Ya no muestra notificaci√≥n, el modal lo hace
    const handleEdit = (tierId: string) => {
        const tierToEdit = tiers.find(t => t.id === tierId);
        if (tierToEdit) {
            setEditingTier(tierToEdit);
            openEditModal();
        } else {
            console.error(`Tier with ID ${tierId} not found for editing.`);
            notifications.show({
                title: t('common.error'), // T√≠tulo gen√©rico
                message: t('adminTiersManagePage.deleteErrorNotFound'), // Mensaje espec√≠fico
                color: 'orange'
            });
        }
    };
    const handleEditSuccess = () => { fetchTiers(); setEditingTier(null); }; // Notificaci√≥n en modal
    const confirmDelete = (tierId: string) => {
        const tierToDelete = tiers.find(t => t.id === tierId);
        if (tierToDelete) {
            setDeletingTier(tierToDelete);
            openDeleteModal(); // El modal DeleteTierModal ahora necesitar√° usar t() internamente
        }
    };
    const handleDelete = async () => {
        if (!deletingTier) return;
        const tierToDeleteId = deletingTier.id;
        const tierToDeleteName = deletingTier.name;
        closeDeleteModal();

        // Usar t() para las notificaciones de borrado
        notifications.show({
            id: `delete-tier-${tierToDeleteId}`,
            title: t('common.deleting', 'Eliminando...'), // Nueva clave
            message: t('adminTiersManagePage.deleteLoadingMessage', { name: tierToDeleteName }),
            loading: true,
            autoClose: false,
            withCloseButton: false,
        });

        try {
            await axiosInstance.delete(`/tiers/tiers/${tierToDeleteId}`);
            notifications.update({
                id: `delete-tier-${tierToDeleteId}`,
                title: t('adminTiersManagePage.deleteSuccessTitle'),
                message: t('adminTiersManagePage.deleteSuccessMessage', { name: tierToDeleteName }),
                color: 'green',
                icon: <IconCheck size={18} />,
                loading: false,
                autoClose: 4000,
            });
            setDeletingTier(null);
            fetchTiers();
        } catch (err: any) {
            console.error(`Error deleting tier ${tierToDeleteId}:`, err);
            const message = err.response?.data?.message || t('adminTiersManagePage.deleteErrorMessage');
            notifications.update({
                id: `delete-tier-${tierToDeleteId}`,
                title: t('adminTiersManagePage.deleteErrorTitle'),
                message: message,
                color: 'red',
                icon: <IconAlertCircle size={18} />,
                loading: false,
                autoClose: 6000,
            });
            setDeletingTier(null);
        }
    };
    const handleManageBenefits = (tier: Tier) => {
        setViewingBenefitsForTier(tier);
        openBenefitsModal(); // El modal TierBenefitsModal necesita usar t() internamente
    };

    // Renderizado
    return (
        <>
            <Paper shadow="sm" p="lg" withBorder radius="lg">
                <Stack gap="lg">
                    <Group justify="space-between">
                        <Title order={2}>{t('adminTiersManagePage.title')}</Title>
                        <Button leftSection={<IconPlus size={18} />} onClick={handleCreate}>
                            {t('adminTiersManagePage.addButton')}
                        </Button>
                    </Group>

                    {loading && <Group justify="center" mt="xl"><Loader /></Group>}
                    {error && !loading &&
                        <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>
                            {error}
                        </Alert>
                    }

                    {!loading && !error && (
                        // TierTable necesita i18n internamente
                        <TierTable
                            tiers={tiers}
                            onEditClick={handleEdit}
                            onDeleteClick={confirmDelete}
                            onManageBenefitsClick={handleManageBenefits}
                        />
                    )}
                    {!loading && !error && tiers.length === 0 && (
                        <Text c="dimmed" ta="center" mt="md">{t('adminTiersManagePage.noTiersDefined')}</Text>
                    )}
                </Stack>
            </Paper>

            {/* Modales (necesitan i18n internamente) */}
            <CreateTierModal
                opened={createModalOpened}
                onClose={closeCreateModal}
                onSuccess={handleCreateSuccess} />
            <DeleteTierModal
                opened={deleteModalOpened}
                onClose={() => { setDeletingTier(null); closeDeleteModal(); }}
                onConfirm={handleDelete}
                tierName={deletingTier?.name} />
            {editingTier && (
                <EditTierModal
                    opened={editModalOpened}
                    onClose={() => { setEditingTier(null); closeEditModal();}}
                    onSuccess={handleEditSuccess}
                    tier={editingTier} />
            )}
            {viewingBenefitsForTier && (
                <TierBenefitsModal
                    opened={benefitsModalOpened}
                    onClose={() => { setViewingBenefitsForTier(null); closeBenefitsModal(); }}
                    tier={viewingBenefitsForTier} />
            )}
        </>
    );
};

export default TierManagementPage;


// ====== [198] frontend/src/modules/loyalpyme/pages/admin/tiers/TierSettingsPage.tsx ======
// filename: frontend/src/pages/admin/tiers/TierSettingsPage.tsx
import React, { useState, useEffect, useCallback } from 'react';
import {
    Paper, Title, Stack, Switch, Select, NumberInput, Button, Loader, Alert, Group, LoadingOverlay, Text
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { notifications } from '@mantine/notifications';
import { IconAlertCircle, IconCheck, IconDeviceFloppy } from '@tabler/icons-react';
import axiosInstance from '../../../../../shared/services/axiosInstance';
import { useTranslation } from 'react-i18next'; // Importar hook

// Tipos/Enums
enum TierCalculationBasis { SPEND = 'SPEND', VISITS = 'VISITS', POINTS_EARNED = 'POINTS_EARNED' }
enum TierDowngradePolicy { NEVER = 'NEVER', PERIODIC_REVIEW = 'PERIODIC_REVIEW', AFTER_INACTIVITY = 'AFTER_INACTIVITY' }

interface TierConfigData {
    tierSystemEnabled: boolean;
    tierCalculationBasis: TierCalculationBasis | null;
    tierCalculationPeriodMonths: number | null;
    tierDowngradePolicy: TierDowngradePolicy;
    inactivityPeriodMonths: number | null;
}

const TierSettingsPage: React.FC = () => {
    const { t } = useTranslation(); // Hook de traducci√≥n
    const [isLoading, setIsLoading] = useState<boolean>(true);
    const [isSaving, setIsSaving] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);

    const form = useForm<TierConfigData>({
        initialValues: {
            tierSystemEnabled: false,
            tierCalculationBasis: null,
            tierCalculationPeriodMonths: null,
            tierDowngradePolicy: TierDowngradePolicy.NEVER,
            inactivityPeriodMonths: null,
        },
        // Validaci√≥n no necesita t() aqu√≠ directamente si los mensajes son gen√©ricos o manejados por Mantine/Zod
        validate: (values) => ({
            // L√≥gica de validaci√≥n se mantiene, los mensajes se pueden mejorar si es necesario
             tierCalculationBasis: (!values.tierSystemEnabled || values.tierCalculationBasis) ? null : t('common.requiredField'), // Ejemplo gen√©rico
             tierCalculationPeriodMonths: (!values.tierSystemEnabled || !values.tierCalculationBasis || values.tierCalculationBasis === TierCalculationBasis.POINTS_EARNED) ? null : (values.tierCalculationPeriodMonths === null || values.tierCalculationPeriodMonths <= 0) ? t('validation.mustBePositive', 'Debe ser > 0') : null, // Clave nueva propuesta
             inactivityPeriodMonths: (!values.tierSystemEnabled || values.tierDowngradePolicy !== TierDowngradePolicy.AFTER_INACTIVITY) ? null : (values.inactivityPeriodMonths === null || values.inactivityPeriodMonths <= 0) ? t('validation.mustBePositive', 'Debe ser > 0') : null, // Clave nueva propuesta
         }),
    });

    // fetchConfig (usar t() en mensajes de error)
    const fetchConfig = useCallback(async () => {
        setIsLoading(true);
        setError(null);
        try {
            const response = await axiosInstance.get<TierConfigData>('/tiers/config');
            const fetchedConfig = {
                tierSystemEnabled: response.data.tierSystemEnabled ?? false,
                tierCalculationBasis: response.data.tierCalculationBasis ?? null,
                tierCalculationPeriodMonths: response.data.tierCalculationPeriodMonths ?? null,
                tierDowngradePolicy: response.data.tierDowngradePolicy ?? TierDowngradePolicy.NEVER,
                inactivityPeriodMonths: response.data.inactivityPeriodMonths ?? null,
            };
            form.setValues(fetchedConfig);
            form.resetDirty(fetchedConfig); // Asegurar que el estado inicial no est√© 'dirty'
            console.log("Config fetched and form set:", fetchedConfig);
        } catch (err: any) {
            console.error("Error fetching tier config:", err);
            const message = err.response?.data?.message || t('adminTiersSettingsPage.errorLoading');
            setError(message);
            notifications.show({ title: t('common.errorLoadingData'), message, color: 'red', icon: <IconAlertCircle size={18} /> });
        } finally {
            setIsLoading(false);
        }
     // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [t]); // A√±adir t como dependencia

    useEffect(() => {
        fetchConfig();
    }, [fetchConfig]);

    // handleSaveChanges (usar t() en mensajes de notificaci√≥n/error)
    const handleSaveChanges = async (values: TierConfigData) => {
        setIsSaving(true);
        setError(null);
        const dataToSend = { /* ... l√≥gica sin cambios ... */
            ...values,
             tierCalculationPeriodMonths: values.tierCalculationPeriodMonths || null,
             inactivityPeriodMonths: values.inactivityPeriodMonths || null,
             tierCalculationBasis: values.tierSystemEnabled ? values.tierCalculationBasis : null,
        };
         if (dataToSend.tierCalculationBasis === TierCalculationBasis.POINTS_EARNED) { dataToSend.tierCalculationPeriodMonths = null; }
         if (dataToSend.tierDowngradePolicy !== TierDowngradePolicy.AFTER_INACTIVITY) { dataToSend.inactivityPeriodMonths = null; }

        console.log("Saving config:", dataToSend);
        try {
            await axiosInstance.put('/tiers/config', dataToSend);
            notifications.show({
                title: t('adminTiersSettingsPage.successSaving'), // Usar t√≠tulo espec√≠fico
                message: t('adminTiersSettingsPage.successSaving'), // Usar mismo texto como mensaje por ahora
                color: 'green',
                icon: <IconCheck size={18} />
            });
            form.setValues(values);
            form.resetDirty(values); // Resetear dirty con los nuevos valores guardados
        } catch (err: any) {
            console.error("Error saving tier config:", err);
            const message = err.response?.data?.message || t('adminTiersSettingsPage.errorSaving');
            setError(message);
            notifications.show({
                title: t('adminCommon.saveError'), // T√≠tulo gen√©rico de error
                message,
                color: 'red',
                icon: <IconAlertCircle size={18} />
            });
        } finally {
            setIsSaving(false);
        }
    };

    // Opciones para Selects (usando t())
    const basisOptions = Object.values(TierCalculationBasis).map(value => ({
        value,
        label: t(`adminTiersSettingsPage.basisOption_${value}`)
    }));
    const policyOptions = Object.values(TierDowngradePolicy).map(value => ({
        value,
        label: t(`adminTiersSettingsPage.downgradePolicyOption_${value}`)
    }));

    // Renderizado
    if (isLoading) {
        return <Group justify="center" mt="xl"><Loader /></Group>;
    }
    // Usar t() en t√≠tulo del Alert de error
    if (error && !isLoading && form.values.tierCalculationBasis === null && !form.values.tierSystemEnabled) {
        return <Alert title={t('common.errorLoadingData')} color="red" icon={<IconAlertCircle />}>{error}</Alert>;
    }

    return (
        <Paper shadow="sm" p="lg" withBorder radius="lg" style={{ position: 'relative' }}>
            <LoadingOverlay visible={isSaving} zIndex={1000} overlayProps={{ radius: "sm", blur: 2 }} />
            <Title order={2} mb="xl">{t('adminTiersSettingsPage.title')}</Title>
            <Text c="dimmed" size="sm" mb="lg">
                {t('adminTiersSettingsPage.description')}
            </Text>

            <form onSubmit={form.onSubmit(handleSaveChanges)}>
                <Stack gap="lg">
                    {/* Usar t() para labels y descriptions */}
                    <Switch
                        label={t('adminTiersSettingsPage.enableSystemLabel')}
                        description={t('adminTiersSettingsPage.enableSystemDescription')}
                        disabled={isSaving}
                        {...form.getInputProps('tierSystemEnabled', { type: 'checkbox' })}
                    />
                    <Select
                        label={t('adminTiersSettingsPage.basisLabel')}
                        placeholder={!form.values.tierSystemEnabled ? t('adminTiersSettingsPage.basisPlaceholderDisabled') : t('adminTiersSettingsPage.basisPlaceholder')}
                        data={basisOptions}
                        disabled={isSaving || !form.values.tierSystemEnabled}
                        clearable
                        description={t('adminTiersSettingsPage.basisDescription')}
                        {...form.getInputProps('tierCalculationBasis')}
                    />
                    <NumberInput
                        label={t('adminTiersSettingsPage.periodLabel')}
                        placeholder={!form.values.tierCalculationBasis || form.values.tierCalculationBasis === TierCalculationBasis.POINTS_EARNED ? t('adminTiersSettingsPage.periodPlaceholderNA') : t('adminTiersSettingsPage.periodPlaceholder')}
                        description={t('adminTiersSettingsPage.periodDescription')}
                        min={0}
                        step={1}
                        allowDecimal={false}
                        disabled={isSaving || !form.values.tierSystemEnabled || !form.values.tierCalculationBasis || form.values.tierCalculationBasis === TierCalculationBasis.POINTS_EARNED}
                        {...form.getInputProps('tierCalculationPeriodMonths')}
                    />
                    <Select
                        label={t('adminTiersSettingsPage.downgradePolicyLabel')}
                        placeholder={t('adminTiersSettingsPage.downgradePolicyPlaceholder')}
                        data={policyOptions}
                        disabled={isSaving || !form.values.tierSystemEnabled}
                        clearable={false}
                        description={t('adminTiersSettingsPage.downgradePolicyDescription')}
                        {...form.getInputProps('tierDowngradePolicy')}
                    />
                    {form.values.tierDowngradePolicy === TierDowngradePolicy.AFTER_INACTIVITY && (
                        <NumberInput
                            label={t('adminTiersSettingsPage.inactivityLabel')}
                            placeholder={t('adminTiersSettingsPage.inactivityPlaceholder')}
                            description={t('adminTiersSettingsPage.inactivityDescription')}
                            min={1}
                            step={1}
                            allowDecimal={false}
                            disabled={isSaving || !form.values.tierSystemEnabled}
                            required
                            {...form.getInputProps('inactivityPeriodMonths')}
                        />
                    )}

                    {error && (
                        <Alert title={t('common.error')} color="red" icon={<IconAlertCircle size="1rem" />} mt="md" withCloseButton onClose={() => setError(null)}>
                            {error}
                        </Alert>
                    )}

                    <Group justify="flex-end" mt="xl">
                        <Button
                            type="submit"
                            disabled={!form.isDirty() || isSaving}
                            loading={isSaving}
                            leftSection={<IconDeviceFloppy size={18} />}
                        >
                            {t('adminTiersSettingsPage.saveButton')}
                        </Button>
                    </Group>
                </Stack>
            </form>
        </Paper>
    );
};

export default TierSettingsPage;


// ====== [199] frontend/src/modules/loyalpyme/services/adminCustomerService.ts ======
// frontend/src/services/adminCustomerService.ts
import axiosInstance from '../../../shared/services/axiosInstance';
import { CustomerDetails } from '../components/admin/CustomerDetailsModal';
// Customer ya no se importa directamente aqu√≠ si la respuesta de la API es diferente

// ... (otros tipos de Payload sin cambios) ...
interface UpdateNotesPayload { notes: string | null; }
interface AdjustPointsPayload { amount: number; reason: string | null; }
interface ChangeTierPayload { tierId: string | null; }
interface AssignRewardPayload { rewardId: string; }
interface BulkStatusPayload { customerIds: string[]; isActive: boolean; }
interface BulkDeletePayload { customerIds: string[]; }
interface BulkAdjustPointsPayload { customerIds: string[]; amount: number; reason: string | null; }

// --- CORRECCI√ìN EN CustomerActionResponse ---
// Definir la estructura del objeto 'customer' que devuelve la API para estas acciones
interface CustomerUpdatePartial {
    id: string;
    points?: number;          // Hacer opcional si no siempre viene
    currentTierId?: string | null; // Propiedad directa del backend
    tierAchievedAt?: string | null; // Propiedad directa del backend
    isFavorite?: boolean;     // Hacer opcional
    isActive?: boolean;       // Hacer opcional
    // A√±adir cualquier otro campo que la API devuelva en el objeto 'customer'
}

export interface CustomerActionResponse {
    message: string;
    customer: CustomerUpdatePartial; // Usar el nuevo tipo
}
// --- FIN CORRECCI√ìN ---

export interface GrantedRewardIdResponse {
    message: string;
    grantedRewardId: string;
}

export interface BulkOperationResponse {
    message: string;
    count: number;
}

// --- Funciones del Servicio (sin cambios en la l√≥gica, solo usan el tipo corregido) ---

export const getCustomerDetailsApi = async (customerId: string): Promise<CustomerDetails> => {
    const response = await axiosInstance.get<CustomerDetails>(`/admin/customers/${customerId}/details`);
    return response.data;
};

export const updateCustomerNotesApi = async (customerId: string, notes: string | null): Promise<{ message: string }> => {
    const payload: UpdateNotesPayload = { notes };
    const response = await axiosInstance.patch<{ message: string }>(`/admin/customers/${customerId}/notes`, payload);
    return response.data;
};

export const adjustCustomerPointsApi = async (customerId: string, amount: number, reason: string | null): Promise<CustomerActionResponse> => {
    const payload: AdjustPointsPayload = { amount, reason };
    const response = await axiosInstance.post<CustomerActionResponse>(`/admin/customers/${customerId}/adjust-points`, payload);
    return response.data;
};

export const changeCustomerTierApi = async (customerId: string, tierId: string | null): Promise<CustomerActionResponse> => {
    const payload: ChangeTierPayload = { tierId };
    const response = await axiosInstance.put<CustomerActionResponse>(`/admin/customers/${customerId}/tier`, payload);
    return response.data;
};

export const assignRewardToCustomerApi = async (customerId: string, rewardId: string): Promise<GrantedRewardIdResponse> => {
    const payload: AssignRewardPayload = { rewardId };
    const response = await axiosInstance.post<GrantedRewardIdResponse>(`/admin/customers/${customerId}/assign-reward`, payload);
    return response.data;
};

export const toggleCustomerFavoriteApi = async (customerId: string): Promise<CustomerActionResponse> => {
    const response = await axiosInstance.patch<CustomerActionResponse>(`/admin/customers/${customerId}/toggle-favorite`);
    return response.data;
};

export const toggleCustomerActiveApi = async (customerId: string): Promise<CustomerActionResponse> => {
    const response = await axiosInstance.patch<CustomerActionResponse>(`/admin/customers/${customerId}/toggle-active`);
    return response.data;
};

export const bulkUpdateCustomerStatusApi = async (customerIds: string[], isActive: boolean): Promise<BulkOperationResponse> => {
    const payload: BulkStatusPayload = { customerIds, isActive };
    const response = await axiosInstance.patch<BulkOperationResponse>('/admin/customers/bulk-status', payload);
    return response.data;
};

export const bulkDeleteCustomersApi = async (customerIds: string[]): Promise<BulkOperationResponse> => {
    const payload: BulkDeletePayload = { customerIds };
    const response = await axiosInstance.delete<BulkOperationResponse>('/admin/customers/bulk-delete', { data: payload });
    return response.data;
};

export const bulkAdjustCustomerPointsApi = async (customerIds: string[], amount: number, reason: string | null): Promise<BulkOperationResponse> => {
    const payload: BulkAdjustPointsPayload = { customerIds, amount, reason };
    const response = await axiosInstance.post<BulkOperationResponse>('/admin/customers/bulk-adjust-points', payload);
    return response.data;
};


// ====== [200] frontend/src/modules/loyalpyme/services/adminService.ts ======
// filename: frontend/src/services/adminService.ts
// Version: 1.1.1 (Fix character encoding)

import axiosInstance from '../../../shared/services/axiosInstance'; // Usar instancia configurada

/**
 * Interface actualizada que define la estructura de los datos de estad√≠sticas
 * devueltos por el endpoint del backend /api/admin/stats/overview,
 * incluyendo datos del periodo anterior para calcular tendencias.
 */
export interface AdminOverviewStats {
    totalActiveCustomers: number;       // Valor puntual
    newCustomersLast7Days: number;
    newCustomersPrevious7Days: number; // Para tendencia
    pointsIssuedLast7Days: number;
    pointsIssuedPrevious7Days: number; // Para tendencia
    rewardsRedeemedLast7Days: number;   // Nota: Solo cuenta regalos canjeados actualmente
    rewardsRedeemedPrevious7Days: number;// Para tendencia
}

/**
 * Obtiene las estad√≠sticas clave (incluyendo datos previos) para el dashboard
 * del administrador desde la API.
 * @returns Una promesa que resuelve con el objeto AdminOverviewStats actualizado.
 * @throws Lanza un error si la petici√≥n a la API falla.
 */
export const getAdminDashboardStats = async (): Promise<AdminOverviewStats> => {
  console.log('[AdminService] Fetching dashboard overview stats (including previous period)...');
  try {
    // La petici√≥n GET sigue siendo la misma, espera la nueva estructura
    const response = await axiosInstance.get<AdminOverviewStats>('/admin/stats/overview');

    // AxiosInstance ya est√° tipado con la interfaz AdminOverviewStats
    console.log('[AdminService] Stats received (with previous period):', response.data);
    return response.data;

  } catch (error: any) {
    console.error('[AdminService] Error fetching extended dashboard stats:', error);
    const errorMessage = error.response?.data?.message ||
                           error.message ||
                           'Error desconocido al obtener estad√≠sticas extendidas.'; // Corregido: estad√≠sticas, desconocido
    // Relanzamos para que el hook/componente que llama lo maneje
    throw new Error(errorMessage);
  }
};

// End of file: frontend/src/services/adminService.ts


// ====== [201] frontend/src/modules/superadmin/components/SubscriptionManagementModal.tsx ======
// frontend/src/components/admin/superadmin/SubscriptionManagementModal.tsx

import React, { useState, useEffect, useCallback } from 'react';
import { Modal, Stack, Tabs, Title, Text, NumberInput, Button, Group, Table, Loader, Alert, Textarea, Select, LoadingOverlay, TextInput } from '@mantine/core';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import { notifications } from '@mantine/notifications';
import { IconDeviceFloppy, IconHistory, IconSettings, IconCirclePlus, IconAlertCircle, IconCheck } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import * as superAdminService from '../services/superAdminService';
import { SuperAdminBusiness, BusinessPayment } from '../../../types/superadmin.types';

interface SubscriptionManagementModalProps {
    opened: boolean;
    onClose: () => void;
    business: SuperAdminBusiness | null;
    onSuccess: () => void;
}

const priceFormSchema = z.object({
    monthlyPrice: z.number().min(0, { message: 'El precio debe ser 0 o mayor.' }),
    currency: z.string().length(3, { message: 'La moneda debe ser un c√≥digo de 3 letras.' }),
});
type PriceFormValues = z.infer<typeof priceFormSchema>;

// --- CAMBIO: Schema del formulario de pago adaptado ---
const paymentFormSchema = z.object({
    amountPaid: z.number().min(0.01, { message: 'El importe debe ser mayor que 0.' }),
    period: z.string().min(1, { message: 'Debe seleccionar un periodo.' }), // Ej: "2025-6"
    notes: z.string().optional(),
    paymentMethod: z.string().optional(),
});
type PaymentFormValues = z.infer<typeof paymentFormSchema>;


const SubscriptionManagementModal: React.FC<SubscriptionManagementModalProps> = ({ opened, onClose, business, onSuccess }) => {
    const { i18n } = useTranslation();
    const [activeTab, setActiveTab] = useState<string | null>('config');
    const [isSaving, setIsSaving] = useState(false);
    
    const [paymentHistory, setPaymentHistory] = useState<BusinessPayment[]>([]);
    const [loadingHistory, setLoadingHistory] = useState(false);
    const [errorHistory, setErrorHistory] = useState<string | null>(null);

    // --- NUEVO ESTADO para los periodos pendientes ---
    const [pendingPeriods, setPendingPeriods] = useState<{ value: string; label: string; }[]>([]);
    const [loadingPeriods, setLoadingPeriods] = useState(false);

    const priceForm = useForm<PriceFormValues>({
        initialValues: { monthlyPrice: 0, currency: 'EUR' },
        validate: zodResolver(priceFormSchema),
    });

    const paymentForm = useForm<PaymentFormValues>({
        initialValues: { amountPaid: 0, period: '', notes: '', paymentMethod: 'Manual' },
        validate: zodResolver(paymentFormSchema),
    });
    
    const fetchDropdownData = useCallback(async () => {
        if (!business) return;
        setLoadingHistory(true);
        setLoadingPeriods(true);
        setErrorHistory(null);
        
        try {
            const historyPromise = superAdminService.getPaymentHistory(business.id);
            const periodsPromise = superAdminService.getPendingPaymentPeriods(business.id);

            const [history, periods] = await Promise.all([historyPromise, periodsPromise]);
            
            setPaymentHistory(history);
            
            const formattedPeriods = periods.map(p => ({
                value: `${p.year}-${p.month}`,
                label: p.label,
            }));
            setPendingPeriods(formattedPeriods);

            // Pre-seleccionar el primer periodo pendiente en el formulario
            if (formattedPeriods.length > 0) {
                paymentForm.setFieldValue('period', formattedPeriods[0].value);
            }

        } catch (err: any) {
            setErrorHistory(err.message || "Error al cargar los datos del modal.");
        } finally {
            setLoadingHistory(false);
            setLoadingPeriods(false);
        }
    }, [business, paymentForm]);

    useEffect(() => {
        if (opened && business) {
            priceForm.setValues({ monthlyPrice: Number(business.monthlyPrice) || 0, currency: business.currency || 'EUR' });
            paymentForm.setFieldValue('amountPaid', Number(business.monthlyPrice) || 0);
            fetchDropdownData();
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [opened, business]);

    const handleUpdatePrice = async (values: PriceFormValues) => {
        if (!business) return;
        setIsSaving(true);
        try {
            await superAdminService.setSubscriptionPrice(business.id, { price: values.monthlyPrice, currency: values.currency });
            notifications.show({ title: '√âxito', message: 'Precio de suscripci√≥n actualizado.', color: 'green', icon: <IconCheck/> });
            onSuccess();
        } catch (error: any) {
            notifications.show({ title: 'Error', message: error.response?.data?.message || error.message, color: 'red', icon: <IconAlertCircle/> });
        } finally {
            setIsSaving(false);
        }
    };

    const handleRecordPayment = async (values: PaymentFormValues) => {
        if (!business) return;
        
        // --- CAMBIO: Extraer mes y a√±o del valor del 'period' ---
        const [year, month] = values.period.split('-').map(Number);
        if (!year || !month) {
            notifications.show({ title: 'Error', message: 'Periodo seleccionado no v√°lido.', color: 'red' });
            return;
        }

        setIsSaving(true);
        try {
            await superAdminService.recordPayment(business.id, {
                amountPaid: values.amountPaid,
                month: month,
                year: year,
                notes: values.notes,
                paymentMethod: values.paymentMethod
            });
            notifications.show({ title: '√âxito', message: 'Pago registrado correctamente.', color: 'green', icon: <IconCheck/> });
            
            // Refrescar datos y resetear formulario
            paymentForm.reset();
            fetchDropdownData();
            onSuccess();
        } catch (error: any) {
            notifications.show({ title: 'Error', message: error.response?.data?.message || error.message, color: 'red', icon: <IconAlertCircle/> });
        } finally {
            setIsSaving(false);
        }
    };

    return (
        <Modal
            opened={opened}
            onClose={onClose}
            title={<Title order={4}>Gestionar Suscripci√≥n: {business?.name}</Title>}
            size="lg"
            centered
        >
            <LoadingOverlay visible={isSaving} />
            <Tabs value={activeTab} onChange={setActiveTab}>
                <Tabs.List>
                    <Tabs.Tab value="config" leftSection={<IconSettings size={16} />}>Configuraci√≥n</Tabs.Tab>
                    <Tabs.Tab value="payment" leftSection={<IconCirclePlus size={16} />}>Registrar Pago</Tabs.Tab>
                    <Tabs.Tab value="history" leftSection={<IconHistory size={16} />}>Historial</Tabs.Tab>
                </Tabs.List>

                <Tabs.Panel value="config" pt="md">
                    {/* (Sin cambios en esta pesta√±a) */}
                    <form onSubmit={priceForm.onSubmit(handleUpdatePrice)}>
                        <Stack>
                            <Text size="sm">Establece el precio mensual que se le cobrar√° a este negocio.</Text>
                            <Group grow align="flex-end">
                                <NumberInput label="Precio Mensual" required min={0} decimalScale={2} {...priceForm.getInputProps('monthlyPrice')} />
                                <Select label="Moneda" data={['EUR', 'USD']} required {...priceForm.getInputProps('currency')} />
                            </Group>
                            <Group justify="flex-end" mt="md">
                                <Button type="submit" leftSection={<IconDeviceFloppy size={16}/>} loading={isSaving}>Guardar Precio</Button>
                            </Group>
                        </Stack>
                    </form>
                </Tabs.Panel>

                <Tabs.Panel value="payment" pt="md">
                     <form onSubmit={paymentForm.onSubmit(handleRecordPayment)}>
                        <Stack>
                            <Text size="sm">Registra un pago manual para un periodo espec√≠fico.</Text>
                            
                            {/* --- CAMBIO: Reemplazo de Mes/A√±o por un √∫nico Select --- */}
                            <Select
                                label="Periodo a Pagar"
                                placeholder={loadingPeriods ? "Cargando periodos..." : "Selecciona un mes pendiente"}
                                data={pendingPeriods}
                                required
                                disabled={pendingPeriods.length === 0}
                                {...paymentForm.getInputProps('period')}
                            />

                            <NumberInput label="Importe Pagado" required min={0.01} decimalScale={2} {...paymentForm.getInputProps('amountPaid')} />
                            <Textarea label="Notas (Opcional)" placeholder="Ej: Pago parcial, referencia de transferencia..." {...paymentForm.getInputProps('notes')} />
                             <TextInput label="M√©todo de Pago (Opcional)" placeholder="Ej: Transferencia, Efectivo" {...paymentForm.getInputProps('paymentMethod')} />
                            <Group justify="flex-end" mt="md">
                                <Button type="submit" color="green" leftSection={<IconCheck size={16}/>} loading={isSaving} disabled={pendingPeriods.length === 0}>
                                    {pendingPeriods.length > 0 ? "Registrar Pago" : "Sin meses pendientes"}
                                </Button>
                            </Group>
                        </Stack>
                    </form>
                </Tabs.Panel>
                
                <Tabs.Panel value="history" pt="md">
                    <Stack>
                        {loadingHistory && <Loader />}
                        {errorHistory && <Alert color="red" title="Error">{errorHistory}</Alert>}
                        {!loadingHistory && !errorHistory && paymentHistory.length === 0 && <Text c="dimmed" ta="center">No hay pagos registrados para este negocio.</Text>}
                        {!loadingHistory && !errorHistory && paymentHistory.length > 0 && (
                            <Table.ScrollContainer minWidth={500}>
                                <Table striped highlightOnHover>
                                    <Table.Thead>
                                        <Table.Tr>
                                            <Table.Th>Fecha</Table.Th>
                                            <Table.Th>Periodo</Table.Th>
                                            <Table.Th ta="right">Importe</Table.Th>
                                        </Table.Tr>
                                    </Table.Thead>
                                    <Table.Tbody>
                                        {paymentHistory.map(p => (
                                            <Table.Tr key={p.id}>
                                                <Table.Td>{new Date(p.paymentDate).toLocaleDateString(i18n.language)}</Table.Td>
                                                <Table.Td>{`${p.month}/${p.year}`}</Table.Td>
                                                <Table.Td ta="right">{p.amountPaid.toLocaleString(i18n.language, { style: 'currency', currency: 'EUR' })}</Table.Td>
                                            </Table.Tr>
                                        ))}
                                    </Table.Tbody>
                                </Table>
                            </Table.ScrollContainer>
                        )}
                    </Stack>
                </Tabs.Panel>
            </Tabs>
        </Modal>
    );
};

export default SubscriptionManagementModal;


// ====== [202] frontend/src/modules/superadmin/pages/SuperAdminPage.tsx ======
import React, { useEffect, useState, useCallback, useMemo } from 'react';
import {
    Container,
    Title,
    Table,
    Switch,
    ActionIcon,
    Tooltip,
    Loader,
    Alert,
    Group,
    Text,
    TextInput,
    Badge,
    Stack,
    SegmentedControl
} from '@mantine/core';
import {
    IconBuildingCommunity,
    IconLockOpen,
    IconLockOff,
    IconToolsKitchen2,
    IconHeartHandshake,
    IconAlertCircle,
    IconSearch,
    IconCash,
    IconSpy,
    IconCheck,
    IconX
} from '@tabler/icons-react';
import { useDisclosure } from '@mantine/hooks';
import axiosInstance from '../../../shared/services/axiosInstance';
import { notifications } from '@mantine/notifications';
import { useTranslation } from 'react-i18next';
import SubscriptionManagementModal from '../components/SubscriptionManagementModal';

// --- CAMBIO: Importar el tipo desde el archivo central ---
import { SuperAdminBusiness } from '../../../shared/types/superadmin.types';

const SuperAdminPage: React.FC = () => {
    const { t } = useTranslation();
    const [businesses, setBusinesses] = useState<SuperAdminBusiness[]>([]);
    const [loading, setLoading] = useState<boolean>(true);
    const [error, setError] = useState<string | null>(null);
    const [searchTerm, setSearchTerm] = useState('');
    const [statusFilter, setStatusFilter] = useState('ALL');
    
    const [subscriptionModalOpened, { open: openSubscriptionModal, close: closeSubscriptionModal }] = useDisclosure(false);
    const [selectedBusiness, setSelectedBusiness] = useState<SuperAdminBusiness | null>(null);
    
    const fetchBusinesses = useCallback(async () => {
        setLoading(true);
        setError(null);
        try {
            const response = await axiosInstance.get<SuperAdminBusiness[]>('/superadmin/businesses');
            setBusinesses(response.data);
        } catch (err: any) {
            console.error("Error fetching businesses for superadmin:", err);
            const message = err.response?.data?.message || t('common.errorLoadingData');
            setError(message);
        } finally {
            setLoading(false);
        }
    }, [t]);

    useEffect(() => {
        fetchBusinesses();
    }, [fetchBusinesses]);
    
    const handleManageSubscription = (business: SuperAdminBusiness) => {
        // Al pasar el objeto al estado, nos aseguramos que el tipo coincide con lo que el modal espera.
        // La conversi√≥n de string a number se maneja dentro del modal.
        setSelectedBusiness(business);
        openSubscriptionModal();
    };

    const handleToggleBusinessStatus = async (businessId: string, currentIsActive: boolean) => {
        const newStatus = !currentIsActive;
        const statusText = newStatus ? t('common.active') : t('common.inactive');
        const businessName = businesses.find(b => b.id === businessId)?.name || t('superAdminPage.businessFallbackName');
        try {
            await axiosInstance.patch(`/superadmin/businesses/${businessId}/status`, { isActive: newStatus });
            notifications.show({ title: t('common.success'), message: t('superAdminPage.statusChangeSuccess', { businessName, status: statusText.toLowerCase() }), color: 'green', icon: <IconCheck />, });
            fetchBusinesses();
        } catch (err: any) {
            const message = err.response?.data?.message || t('superAdminPage.statusChangeError');
            notifications.show({ title: t('common.error'), message, color: 'red', icon: <IconX /> });
        }
    };

    const handleToggleModule = async (businessId: string, moduleKey: 'loyaltycore' | 'camarero', currentIsActive: boolean) => {
        const newStatus = !currentIsActive;
        const moduleName = moduleKey === 'loyaltycore' ? t('superAdminPage.moduleLoyaltyCore') : t('superAdminPage.moduleCamarero');
        const statusText = newStatus ? t('common.active') : t('common.inactive');
        const businessName = businesses.find(b => b.id === businessId)?.name || t('superAdminPage.businessFallbackName');
        try {
            await axiosInstance.patch(`/superadmin/businesses/${businessId}/module-${moduleKey}`, { isActive: newStatus });
            notifications.show({ title: t('common.success'), message: t('superAdminPage.moduleChangeSuccess', { moduleName, status: statusText.toLowerCase(), businessName }), color: 'green', icon: <IconCheck />, });
            fetchBusinesses();
        } catch (err: any) {
            const message = err.response?.data?.message || t('superAdminPage.moduleChangeError', { moduleName });
            notifications.show({ title: t('common.error'), message, color: 'red', icon: <IconX /> });
        }
    };

    const handleImpersonate = (business: SuperAdminBusiness) => {
        console.log("Iniciar suplantaci√≥n para el admin de:", business.name);
        notifications.show({ title: t('common.upcomingFeatureTitle'), message: `Aqu√≠ se iniciar√≠a la suplantaci√≥n de identidad para el admin de ${business.name}.`, color: 'grape' });
    };
    
    const filteredBusinesses = useMemo(() => {
        return businesses
            .filter(business => 
                business.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                business.slug.toLowerCase().includes(searchTerm.toLowerCase())
            )
            .filter(business => {
                if (statusFilter === 'ALL') return true;
                return business.paymentStatus === statusFilter;
            });
    }, [businesses, searchTerm, statusFilter]);
    
    const rows = filteredBusinesses.map((business) => {
        const paymentStatusConfig = {
            PAID: { color: 'green', label: t('superAdminPage.statusPaid', 'Al d√≠a') },
            PENDING: { color: 'orange', label: t('superAdminPage.statusPending', 'Pendiente') },
            OVERDUE: { color: 'red', label: t('superAdminPage.statusOverdue', 'Atrasado') }
        };
        const statusInfo = paymentStatusConfig[business.paymentStatus];

        // Convertir el precio (que puede ser string) a n√∫mero para formatearlo
        const priceAsNumber = business.monthlyPrice !== null ? Number(business.monthlyPrice) : null;

        return (
            <Table.Tr key={business.id}>
                <Table.Td>
                    <Text fw={500}>{business.name}</Text>
                    <Text size="xs" c="dimmed">{business.slug}</Text>
                </Table.Td>
                
                <Table.Td>
                    <Text ta="right">{`${priceAsNumber !== null ? priceAsNumber.toFixed(2) : 'N/A'} ${business.currency}`}</Text>
                </Table.Td>

                <Table.Td>
                    <Badge color={statusInfo.color} variant="light">{statusInfo.label}</Badge>
                    {business.pendingMonths > 0 && (
                        <Text size="xs" c="dimmed">{`${business.pendingMonths} mes(es) pendiente(s)`}</Text>
                    )}
                </Table.Td>

                <Table.Td>
                    <Switch
                        checked={business.isLoyaltyCoreActive}
                        onChange={() => handleToggleModule(business.id, 'loyaltycore', business.isLoyaltyCoreActive)}
                        thumbIcon={<IconHeartHandshake size={12} />}
                        color="teal"
                        aria-label={t('superAdminPage.moduleLoyaltyCoreTooltip')}
                    />
                </Table.Td>
                <Table.Td>
                    <Switch
                        checked={business.isCamareroActive}
                        onChange={() => handleToggleModule(business.id, 'camarero', business.isCamareroActive)}
                        thumbIcon={<IconToolsKitchen2 size={12} />}
                        color="indigo"
                        aria-label={t('superAdminPage.moduleCamareroTooltip')}
                    />
                </Table.Td>

                <Table.Td>
                    <Group gap="xs" justify="flex-end" wrap="nowrap">
                        <Tooltip label={t('superAdminPage.manageSubscriptionTooltip', "Gestionar Suscripci√≥n y Pagos")}>
                            <ActionIcon variant="subtle" color="blue" onClick={() => handleManageSubscription(business)}>
                                <IconCash size={18} />
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={business.isActive ? t('superAdminPage.tooltipDeactivateBusiness') : t('superAdminPage.tooltipActivateBusiness')}>
                            <ActionIcon variant="subtle" color={business.isActive ? 'red' : 'green'} onClick={() => handleToggleBusinessStatus(business.id, business.isActive)}>
                                {business.isActive ? <IconLockOff size={18} /> : <IconLockOpen size={18} />}
                            </ActionIcon>
                        </Tooltip>
                        <Tooltip label={t('superAdminPage.impersonateTooltip', "Iniciar sesi√≥n como este administrador")}>
                             <ActionIcon variant="subtle" color="grape" onClick={() => handleImpersonate(business)}>
                                <IconSpy size={18} />
                            </ActionIcon>
                        </Tooltip>
                    </Group>
                </Table.Td>
            </Table.Tr>
        );
    });

    return (
        <>
            <Container size="xl" py="xl">
                <Stack gap="lg">
                    <Title order={2}>
                        <IconBuildingCommunity style={{ marginRight: '10px', verticalAlign: 'middle' }} />
                        {t('superAdminPage.title')}
                    </Title>
                    
                    <Group justify="space-between">
                        <TextInput
                            placeholder={t('superAdminPage.searchPlaceholder')}
                            leftSection={<IconSearch size={16} />}
                            value={searchTerm}
                            onChange={(event) => setSearchTerm(event.currentTarget.value)}
                            style={{ flex: 1 }}
                        />
                        <SegmentedControl
                            value={statusFilter}
                            onChange={setStatusFilter}
                            data={[
                                { label: t('superAdminPage.filterAll', 'Todos'), value: 'ALL' },
                                { label: t('superAdminPage.statusPaid', 'Al d√≠a'), value: 'PAID' },
                                { label: t('superAdminPage.statusPending', 'Pendientes'), value: 'PENDING' },
                                { label: t('superAdminPage.statusOverdue', 'Atrasados'), value: 'OVERDUE' },
                            ]}
                        />
                    </Group>

                    {loading && <Group justify="center" mt="xl"><Loader /></Group>}
                    {error && !loading && <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />}>{error}</Alert>}
                    
                    {!loading && !error && (
                        <Table.ScrollContainer minWidth={900}>
                            <Table striped highlightOnHover withTableBorder verticalSpacing="sm">
                                <Table.Thead>
                                    <Table.Tr>
                                        <Table.Th>{t('superAdminPage.tableHeaderBusiness')}</Table.Th>
                                        <Table.Th ta="right">{t('superAdminPage.tableHeaderPrice', 'Precio/mes')}</Table.Th>
                                        <Table.Th>{t('superAdminPage.tableHeaderPaymentStatus', 'Estado de Pago')}</Table.Th>
                                        <Table.Th>{t('superAdminPage.tableHeaderLoyalty')}</Table.Th>
                                        <Table.Th>{t('superAdminPage.tableHeaderCamarero')}</Table.Th>
                                        <Table.Th ta="right">{t('common.actions', 'Acciones')}</Table.Th>
                                    </Table.Tr>
                                </Table.Thead>
                                <Table.Tbody>
                                    {rows.length > 0 ? rows : (
                                        <Table.Tr>
                                            <Table.Td colSpan={6} align="center">
                                                <Text c="dimmed">{searchTerm || statusFilter !== 'ALL' ? t('common.noResults') : t('superAdminPage.noBusinesses')}</Text>
                                            </Table.Td>
                                        </Table.Tr>
                                    )}
                                </Table.Tbody>
                            </Table>
                        </Table.ScrollContainer>
                    )}
                </Stack>
            </Container>

            <SubscriptionManagementModal
                opened={subscriptionModalOpened}
                onClose={() => {
                    closeSubscriptionModal();
                    setSelectedBusiness(null);
                }}
                business={selectedBusiness}
                onSuccess={() => {
                    fetchBusinesses();
                    closeSubscriptionModal();
                    setSelectedBusiness(null);
                }}
            />
        </>
    );
};

export default SuperAdminPage;


// ====== [203] frontend/src/modules/superadmin/services/superAdminService.ts ======
// frontend/src/services/superAdminService.ts

import axiosInstance from '../../../shared/services/axiosInstance';

// --- Tipos de Datos para Payloads y Respuestas ---

interface SetPricePayload {
    price: number;
    currency: string;
}

interface RecordPaymentPayload {
    amountPaid: number;
    month: number;
    year: number;
    notes?: string;
    paymentMethod?: string;
}

export interface BusinessPayment {
    id: string;
    paymentDate: string;
    amountPaid: number;
    month: number;
    year: number;
    paymentMethod: string | null;
    notes: string | null;
}

export interface UpdatedBusinessResponse {
    id: string;
    monthlyPrice: number | null;
    currency: string;
}

// --- NUEVO TIPO A√ëADIDO ---
// El tipo de dato para cada periodo pendiente que devuelve la API
export interface PendingPeriod {
    year: number;
    month: number;
    label: string; // ej. "Junio 2025"
}


// --- Funciones del Servicio ---

/**
 * Llama a la API para establecer el precio de suscripci√≥n de un negocio.
 */
export const setSubscriptionPrice = async (businessId: string, payload: SetPricePayload): Promise<UpdatedBusinessResponse> => {
    try {
        const response = await axiosInstance.put<UpdatedBusinessResponse>(`/superadmin/businesses/${businessId}/subscription`, payload);
        return response.data;
    } catch (error) {
        console.error(`[SuperAdminService] Error setting subscription price for business ${businessId}:`, error);
        throw error;
    }
};

/**
 * Llama a la API para registrar un nuevo pago manual.
 */
export const recordPayment = async (businessId: string, payload: RecordPaymentPayload): Promise<BusinessPayment> => {
    try {
        const response = await axiosInstance.post<BusinessPayment>(`/superadmin/businesses/${businessId}/payments`, payload);
        return response.data;
    } catch (error) {
        console.error(`[SuperAdminService] Error recording payment for business ${businessId}:`, error);
        throw error;
    }
};

/**
 * Llama a la API para obtener el historial de pagos de un negocio.
 */
export const getPaymentHistory = async (businessId: string): Promise<BusinessPayment[]> => {
    try {
        const response = await axiosInstance.get<BusinessPayment[]>(`/superadmin/businesses/${businessId}/payments`);
        return response.data || [];
    } catch (error) {
        console.error(`[SuperAdminService] Error fetching payment history for business ${businessId}:`, error);
        throw error;
    }
};

// --- NUEVA FUNCI√ìN A√ëADIDA ---
/**
 * Llama a la API para obtener los periodos de pago pendientes para un negocio.
 * @param businessId - El ID del negocio.
 * @returns Una lista de los periodos pendientes.
 */
export const getPendingPaymentPeriods = async (businessId: string): Promise<PendingPeriod[]> => {
    try {
        const response = await axiosInstance.get<PendingPeriod[]>(`/superadmin/businesses/${businessId}/pending-payments`);
        return response.data || [];
    } catch (error) {
        console.error(`[SuperAdminService] Error fetching pending payment periods for business ${businessId}:`, error);
        throw error;
    }
};


// ====== [204] frontend/src/pages/ForgotPasswordPage.tsx ======
// filename: frontend/src/pages/ForgotPasswordPage.tsx
// Version: 1.5.1 (Remove unused imports)

import { useState, FormEvent } from 'react';
// import { useNavigate, Link } from 'react-router-dom'; // Quitamos useNavigate
import { Link } from 'react-router-dom'; // Mantenemos Link
import axios from 'axios';
import {
    Container, Paper, Title, Text, Stack, TextInput, Button, Anchor
} from '@mantine/core';
import { notifications } from '@mantine/notifications';
// import { IconCheck, IconX, IconAlertCircle } from '@tabler/icons-react'; // Quitamos IconX
import { IconCheck, IconAlertCircle } from '@tabler/icons-react'; // Mantenemos los otros
import { useTranslation } from 'react-i18next';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000';

const ForgotPasswordPage: React.FC = () => {
    const { t } = useTranslation();
    // const navigate = useNavigate(); // Eliminado
    const [email, setEmail] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [messageSent, setMessageSent] = useState(false);

    const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        setIsLoading(true);
        setMessageSent(false);
        if (!email) {
             notifications.show({
                title: t('forgotPasswordPage.errorTitle'),
                message: t('forgotPasswordPage.errorMissingEmail'),
                color: 'orange',
                icon: <IconAlertCircle size={18}/>
            });
             setIsLoading(false);
             return;
        }
        try {
            await axios.post(`${API_BASE_URL}/api/auth/forgot-password`, { email });
             notifications.show({
                title: t('forgotPasswordPage.successTitle'),
                message: t('forgotPasswordPage.successMessage'),
                color: 'green',
                icon: <IconCheck size={18} />,
                autoClose: 7000
            });
            setMessageSent(true);
            setEmail('');
        } catch (error: any) {
            console.error('Error requesting password reset:', error);
             notifications.show({
                 title: t('forgotPasswordPage.errorGenericTitle'),
                 message: t('forgotPasswordPage.errorGenericMessage'),
                 color: 'blue',
                 autoClose: 7000
             });
             setMessageSent(true);
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Container size={480} my={40}>
             <Title ta="center" style={{ fontWeight: 900 }}>{t('forgotPasswordPage.title')}</Title>
             <Text c="dimmed" size="sm" ta="center" mt={5}>
                {t('forgotPasswordPage.subtitle')}{' '}
                <Anchor component={Link} to="/login" size="sm">{t('forgotPasswordPage.loginLink')}</Anchor>
             </Text>
            <Paper withBorder shadow="md" p={30} mt={30} radius="lg">
                <form onSubmit={handleSubmit}>
                    <Stack>
                        <Text size="sm" ta="center">{t('forgotPasswordPage.instructions')}</Text>
                        <TextInput
                            label={t('forgotPasswordPage.emailLabel')}
                            placeholder={t('forgotPasswordPage.emailPlaceholder')}
                            value={email}
                            onChange={(event) => setEmail(event.currentTarget.value)}
                            required
                            type="email"
                            disabled={isLoading || messageSent}
                        />
                        {messageSent && (
                           <Text c="green" ta="center" size="sm" mt="md">
                               {t('forgotPasswordPage.successTitle')}
                           </Text>
                         )}
                        <Button
                            type="submit"
                            loading={isLoading}
                            fullWidth
                            mt="xl"
                            radius="lg"
                            disabled={messageSent}
                        >
                            {t('forgotPasswordPage.buttonText')}
                        </Button>
                    </Stack>
                </form>
            </Paper>
         </Container>
    );
};

export default ForgotPasswordPage;

// End of File: frontend/src/pages/ForgotPasswordPage.tsx


// ====== [205] frontend/src/pages/LoginPage.module.css ======
/* File: frontend/src/pages/LoginPage.module.css */
/* Version: 1.0.2 (Debug Styles) */

.loginPage {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    min-height: 90vh; /* Aumentar un poco la altura m√≠nima */
    padding: 20px;
    background-color: var(--color-background);
  }
  
  .card {
    background-color: var(--color-secondary);
    padding: 2rem 2.5rem;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    max-width: 450px;
    width: 100%;
    text-align: center;
    /* --- DEBUG: Forzar fuente --- */
    font-family: var(--font-family-sans);
  }
  
  .pageTitle {
      color: var(--color-primary);
      margin-bottom: 2rem;
      font-size: 2.2em;
  }
  
  .title {
    margin-bottom: 1.5rem;
    font-size: 1.8em;
    color: var(--color-text);
    border-bottom: none;
    font-family: var(--font-family-sans); /* Forzar fuente tambi√©n aqu√≠ */
  }
  
  .form {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    text-align: left;
    font-family: var(--font-family-sans); /* Forzar fuente en todo el form */
  }
  
  /* Bot√≥n de submit principal - con estilos de DEBUG */
  .button {
    /* Estilos originales comentados temporalmente
    background-color: var(--color-primary);
    color: white;
    border: none;
    */
    /* --- DEBUG: Estilos muy visibles --- */
    background-color: red !important;
    color: yellow !important;
    border: 3px solid black !important;
    display: block !important; /* Asegurar que sea bloque */
    width: 100%; /* Ocupar todo el ancho */
    /* --- FIN DEBUG --- */
  
    margin-top: 0.5rem;
    padding: 0.8em 1.2em;
    transition: background-color 0.2s ease;
    border-radius: 8px; /* Heredado de index.css, pero lo ponemos por si acaso */
    font-size: 1em; /* Heredado */
    font-weight: 500; /* Heredado */
    font-family: inherit; /* Heredado */
    cursor: pointer; /* Heredado */
  }
  .button:hover:not(:disabled) {
    /* background-color: var(--color-primary-light); */
    border-color: yellow !important; /* Borde amarillo en hover */
  }
  .button:disabled {
      background-color: grey !important; /* Gris si est√° deshabilitado */
      opacity: 0.7;
  }
  
  /* Mensaje de error */
  .error {
    color: var(--color-error);
    font-size: 0.9em;
    text-align: center;
    min-height: 1.2em;
    margin-top: 0.5rem;
  }
  
  /* End of File: frontend/src/pages/LoginPage.module.css */


// ====== [206] frontend/src/pages/LoginPage.tsx ======
// frontend/src/pages/LoginPage.tsx (CORREGIDO)
import { useState, FormEvent } from 'react';
import { useNavigate, Link } from 'react-router-dom';
// --- RUTA CORREGIDA ---
import axiosInstance from '../shared/services/axiosInstance';
import { UserRole } from '../shared/types/user.types';
import type { UserData } from '../shared/types/user.types';
// --- FIN RUTAS CORREGIDAS ---

import { AxiosError } from 'axios';
import {
    TextInput, PasswordInput, Button, Paper, Title, Stack, Container,
    Alert, LoadingOverlay, Anchor, Group, Text
} from '@mantine/core';
import { IconAlertCircle } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';


function LoginPage() {
    const { t } = useTranslation();
    const [email, setEmail] = useState<string>('');
    const [password, setPassword] = useState<string>('');
    const [error, setError] = useState<string | null>(null);
    const [loading, setLoading] = useState<boolean>(false);
    const navigate = useNavigate();

    const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
        event.preventDefault();
        setLoading(true);
        setError(null);
        // La ruta de la API es correcta, ya que axiosInstance apunta a /api
        const loginPath = '/auth/login'; 
        try {
            const response = await axiosInstance.post<{ user: UserData; token: string }>(
                loginPath, { email, password }
            );
            const { user, token } = response.data;

            if (user && token) {
                localStorage.setItem('token', token);
                localStorage.setItem('user', JSON.stringify(user));

                // La l√≥gica de redirecci√≥n no cambia
                if (user.role === UserRole.KITCHEN_STAFF || user.role === UserRole.BAR_STAFF) {
                    navigate('/admin/kds', { replace: true });
                } else if (user.role === UserRole.BUSINESS_ADMIN) {
                    navigate('/admin/dashboard', { replace: true });
                } else if (user.role === UserRole.CUSTOMER_FINAL) {
                    navigate('/customer/dashboard', { replace: true });
                } else if (user.role === UserRole.SUPER_ADMIN) {
                    navigate('/superadmin', { replace: true });
                } else if (user.role === UserRole.WAITER) {
                    navigate('/admin/camarero/pickup', { replace: true });
                } else {
                    setError(t('loginPage.errorUnknown', { ns: 'translation' }));
                }
            } else {
                setError(t('loginPage.errorServer', { ns: 'translation' }));
            }
        } catch (err: unknown) {
            if (err instanceof AxiosError && err.response?.status === 401) {
                setError(t('loginPage.errorCredentials', { ns: 'translation' }));
            } else if (err instanceof AxiosError && err.response) {
                setError(err.response.data?.message || t('loginPage.errorServer', { ns: 'translation' }));
            } else if (err instanceof Error) {
                setError(err.message);
            } else {
                setError(t('loginPage.errorUnknown', { ns: 'translation' }));
            }
        } finally {
            setLoading(false);
        }
    };

    return (
        <Container size="xs" p="md" style={{ minHeight: '90vh', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            <Paper shadow="md" p="xl" radius="lg" withBorder style={{ position: 'relative', width: '100%' }}>
                <LoadingOverlay visible={loading} zIndex={1000} overlayProps={{ radius: "sm", blur: 2 }} />
                <Title order={2} ta="center" mb="xl">{t('loginPage.title')}</Title>
                <form onSubmit={handleSubmit}>
                    <Stack gap="lg">
                        <TextInput
                            required
                            label={t('loginPage.emailLabel')}
                            placeholder={t('loginPage.emailPlaceholder')}
                            value={email}
                            onChange={(event) => setEmail(event.currentTarget.value)}
                            error={!!error}
                            radius="lg"
                        />
                        <PasswordInput
                            required
                            label={t('loginPage.passwordLabel')}
                            placeholder={t('loginPage.passwordPlaceholder')}
                            value={password}
                            onChange={(event) => setPassword(event.currentTarget.value)}
                            error={!!error}
                            radius="lg"
                        />
                        {error && (
                            <Alert icon={<IconAlertCircle size={16} />} title={t('common.error')} color="red" radius="lg" mt="md">
                                {error}
                            </Alert>
                        )}
                        <Group justify="space-between" mt="xl">
                            <Anchor component={Link} to="/forgot-password" c="dimmed" size="sm">
                                {t('loginPage.forgotPasswordLink')}
                            </Anchor>
                            <Button type="submit" loading={loading} radius="lg">
                                {t('loginPage.loginButton')}
                            </Button>
                        </Group>
                    </Stack>
                </form>
                <Text ta="center" mt="md">
                    {t('loginPage.subtitle')}{' '}
                    <Anchor component={Link} to="/register" size="sm">
                        {t('loginPage.registerLink')}
                    </Anchor>
                </Text>
            </Paper>
        </Container>
    );
}
export default LoginPage;


// ====== [207] frontend/src/pages/RegisterBusinessPage.tsx ======
// filename: frontend/src/pages/RegisterBusinessPage.tsx
// Version: 1.1.0 (Implement i18n using useTranslation)

import { useState } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useForm, zodResolver } from '@mantine/form';
import { z } from 'zod';
import axios from 'axios';
import { notifications } from '@mantine/notifications';
import {
    Container, Paper, Title, Text, TextInput, PasswordInput, Button,
    LoadingOverlay, Alert, Stack, Anchor
} from '@mantine/core';
import { IconAlertCircle, IconCircleCheck } from '@tabler/icons-react';
// --- NUEVO: Importar useTranslation ---
import { useTranslation } from 'react-i18next';
// --- FIN NUEVO ---

// Esquema Zod (usando t() para mensajes, aunque requerir√≠a pasar t al schema o usar llaves fijas)
// Por simplicidad ahora, dejamos los mensajes fijos en espa√±ol aqu√≠, pero idealmente se usar√≠an claves
const registerBusinessSchema = z.object({
    businessName: z.string().min(2, { message: 'El nombre del negocio debe tener al menos 2 caracteres' }), // TODO: i18n key
    adminName: z.string().optional(),
    adminEmail: z.string().email({ message: 'Email inv√°lido' }), // TODO: i18n key
    adminPassword: z.string().min(6, { message: 'La contrase√±a debe tener al menos 6 caracteres' }), // TODO: i18n key
    confirmPassword: z.string().min(6, { message: 'La confirmaci√≥n de contrase√±a debe tener al menos 6 caracteres' }), // TODO: i18n key
}).refine((data) => data.adminPassword === data.confirmPassword, {
    message: "Las contrase√±as no coinciden", // TODO: i18n key
    path: ["confirmPassword"],
});

type RegisterBusinessFormValues = z.infer<typeof registerBusinessSchema>;
const REGISTER_BUSINESS_URL = `${import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000'}/api/auth/register-business`;

function RegisterBusinessPage() {
    // --- NUEVO: Hook useTranslation ---
    const { t } = useTranslation();
    // --- FIN NUEVO ---

    const navigate = useNavigate();
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);

    const form = useForm<RegisterBusinessFormValues>({
        initialValues: { businessName: '', adminName: '', adminEmail: '', adminPassword: '', confirmPassword: '', },
        // TODO: Pasar la funci√≥n t al resolver si queremos traducir errores de Zod din√°micamente
        validate: zodResolver(registerBusinessSchema),
    });

    const handleSubmit = async (values: RegisterBusinessFormValues) => {
        setLoading(true);
        setError(null);
        const { confirmPassword, ...dataToSend } = values;
        if (!dataToSend.adminName?.trim()) { delete dataToSend.adminName; }

        try {
            const response = await axios.post(REGISTER_BUSINESS_URL, dataToSend);
            if (response.data.token && response.data.user) {
                 localStorage.setItem('token', response.data.token);
                 localStorage.setItem('user', JSON.stringify(response.data.user));
            }
            // --- CAMBIO: Usar t() en notificaciones ---
            notifications.show({
                 title: t('registerBusinessPage.successTitle'),
                 message: t('registerBusinessPage.successMessage', { businessName: values.businessName, adminEmail: values.adminEmail }), // Pasar variables
                 color: 'green',
                 icon: <IconCircleCheck />,
            });
             // --- FIN CAMBIO ---
            navigate('/admin/dashboard');
        } catch (err: unknown) {
            console.error("Registration error:", err);
            let errorMsg = t('registerBusinessPage.errorRegistration', 'No se pudo completar el registro. Int√©ntalo de nuevo.'); // Usar clave gen√©rica
            if (axios.isAxiosError(err) && err.response?.data?.message) { errorMsg = err.response.data.message; }
            else if (err instanceof Error) { errorMsg = err.message; }
            setError(errorMsg);
             // --- CAMBIO: Usar t() en notificaciones ---
             notifications.show({
                 title: t('registerBusinessPage.errorTitle'), message: errorMsg, color: 'red',
                 icon: <IconAlertCircle />,
             });
              // --- FIN CAMBIO ---
        } finally {
            setLoading(false);
        }
    };

    // --- JSX MODIFICADO ---
    return (
        <Container size={460} my={40}>
            <Paper withBorder shadow="md" p={30} radius="md" mt="xl" style={{ position: 'relative' }}>
                <LoadingOverlay visible={loading} overlayProps={{ radius: "sm", blur: 2 }} />
                {/* T√≠tulos y textos traducidos */}
                <Title ta="center" order={2}>{t('registerBusinessPage.title')}</Title>
                <Text c="dimmed" size="sm" ta="center" mt={5} mb={30}>
                    {t('registerBusinessPage.subtitle')}
                </Text>

                <form onSubmit={form.onSubmit(handleSubmit)}>
                    <Stack>
                        {/* Inputs con labels y placeholders traducidos */}
                        <TextInput
                            required
                            label={t('registerBusinessPage.businessNameLabel')}
                            placeholder={t('registerBusinessPage.businessNamePlaceholder')}
                            {...form.getInputProps('businessName')} />
                        <TextInput
                            label={t('registerBusinessPage.adminNameLabel')}
                            placeholder={t('registerBusinessPage.adminNamePlaceholder')}
                            {...form.getInputProps('adminName')} />
                        <TextInput
                            required
                            label={t('registerBusinessPage.adminEmailLabel')}
                            placeholder={t('registerBusinessPage.adminEmailPlaceholder')}
                            {...form.getInputProps('adminEmail')} />
                        <PasswordInput
                            required
                            label={t('registerBusinessPage.adminPasswordLabel')}
                            placeholder={t('registerBusinessPage.adminPasswordPlaceholder')}
                            {...form.getInputProps('adminPassword')} />
                        <PasswordInput
                            required
                            label={t('registerBusinessPage.confirmPasswordLabel')}
                            placeholder={t('registerBusinessPage.confirmPasswordPlaceholder')}
                            {...form.getInputProps('confirmPassword')} />

                        {/* Alert de error (sin cambios, usa estado 'error') */}
                        {error && (
                             <Alert title={t('common.error')} color="red" icon={<IconAlertCircle size="1rem" />} mt="md">
                                {error}
                            </Alert>
                         )}
                        {/* Bot√≥n traducido */}
                        <Button type="submit" fullWidth mt="xl" disabled={loading}>
                            {t('registerBusinessPage.registerButton')}
                        </Button>
                     </Stack>
                </form>

                 {/* Enlace traducido */}
                 <Text c="dimmed" size="sm" ta="center" mt="md">
                     {t('registerBusinessPage.loginLinkSubtitle')}{' '}
                     <Anchor component={Link} to="/login" size="sm">
                         {t('registerBusinessPage.loginLink')}
                     </Anchor>
                 </Text>
            </Paper>
        </Container>
    );
    // --- FIN JSX MODIFICADO ---
}

export default RegisterBusinessPage;

// End of File: frontend/src/pages/RegisterBusinessPage.tsx


// ====== [208] frontend/src/pages/RegisterPage.tsx ======
// frontend/src/pages/RegisterPage.tsx (CORREGIDO)
import { useState, useEffect } from 'react';
import { useNavigate, Link } from 'react-router-dom';
// --- RUTAS CORREGIDAS ---
import axiosInstance from '../shared/services/axiosInstance';
import { getPublicBusinessList, BusinessOption } from '../shared/services/businessService';
// --- FIN RUTAS CORREGIDAS ---

import { AxiosError } from 'axios';
import {
    Container, Paper, Title, Text, Stack, TextInput, PasswordInput,
    Button, Select, Anchor, Loader, Group
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX } from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';

// Los enums y la interfaz de formulario se quedan igual
enum DocumentType { DNI = 'DNI', NIE = 'NIE', PASSPORT = 'PASSPORT', OTHER = 'OTHER' }
enum UserRole { BUSINESS_ADMIN = 'BUSINESS_ADMIN', CUSTOMER_FINAL = 'CUSTOMER_FINAL' }

interface RegisterFormValues {
    email: string; password: string; confirmPassword: string; name: string; phone: string;
    documentType: DocumentType | null; documentId: string; businessId: string;
}

const RegisterPage: React.FC = () => {
    const { t } = useTranslation();
    const navigate = useNavigate();
    const role: UserRole = UserRole.CUSTOMER_FINAL;
    const [isLoading, setIsLoading] = useState(false);
    const documentTypeOptions = Object.values(DocumentType).map(value => ({ value, label: value }));
    const [businesses, setBusinesses] = useState<BusinessOption[]>([]);
    const [loadingBusinesses, setLoadingBusinesses] = useState<boolean>(true);
    const [errorBusinesses, setErrorBusinesses] = useState<string | null>(null);

    const form = useForm<RegisterFormValues>({
        initialValues: {
            email: '', password: '', confirmPassword: '', name: '', phone: '',
            documentType: null, documentId: '', businessId: '',
        },
        validate: {
            email: (value) => (!value ? t('common.requiredField') : !/^\S+@\S+\.\S+$/.test(value) ? t('registerPage.errorInvalidEmail', 'Formato de email inv√°lido.') : null),
            password: (value) => (!value ? t('common.requiredField') : value.length < 6 ? t('registerPage.errorPasswordLength', 'La contrase√±a debe tener al menos 6 caracteres.') : null),
            confirmPassword: (value, values) => (!value ? t('registerPage.errorConfirmPassword', 'Confirma la contrase√±a.') : value !== values.password ? t('registerPage.errorPasswordsDontMatch') : null),
            phone: (value) => (!value ? t('common.requiredField') : !/^\+\d{9,15}$/.test(value) ? t('registerPage.errorPhoneFormat', 'Formato inv√°lido (ej: +346...).') : null),
            documentType: (value) => (value ? null : t('registerPage.errorDocType', 'Selecciona un tipo de documento.')),
            documentId: (value, values) => {
                 if (!value) return t('common.requiredField');
                 if (values.documentType === DocumentType.DNI && !/^\d{8}[A-Z]$/i.test(value)) return t('registerPage.errorDNIFormat', 'Formato DNI inv√°lido (8 n√∫meros y 1 letra).');
                 if (values.documentType === DocumentType.NIE && !/^[XYZ]\d{7}[A-Z]$/i.test(value)) return t('registerPage.errorNIEFormat', 'Formato NIE inv√°lido (letra, 7 n√∫meros, letra).');
                 return null;
            },
            businessId: (value) => (value ? null : t('registerPage.errorBusinessRequired', 'Debes seleccionar un negocio.')),
        },
    });

    useEffect(() => {
        const fetchBusinesses = async () => {
            setLoadingBusinesses(true); setErrorBusinesses(null);
            try { const data = await getPublicBusinessList(); setBusinesses(data); }
            catch (err: any) { console.error("Error fetching businesses:", err); setErrorBusinesses(t('registerPage.errorLoadingBusinesses')); }
            finally { setLoadingBusinesses(false); }
        };
        fetchBusinesses();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    const handleSubmit = async (values: RegisterFormValues) => {
        setIsLoading(true);
        const registrationData = {
            email: values.email.trim(), password: values.password, name: values.name.trim() || undefined,
            phone: values.phone.trim(), documentId: values.documentId.trim().toUpperCase(), documentType: values.documentType,
            businessId: values.businessId, role,
         };
        const registerPath = '/auth/register';
        try {
            const response = await axiosInstance.post(registerPath, registrationData);
            console.log('Registration successful:', response.data);
            notifications.show({
                title: t('common.success'),
                message: t('registerPage.successMessage', 'Tu cuenta ha sido creada. Ser√°s redirigido a la p√°gina de inicio de sesi√≥n.'),
                color: 'green', icon: <IconCheck size={18} />, autoClose: 4000,
            });
            setTimeout(() => { navigate('/login', { state: { registrationSuccess: true } }); }, 1500);
        } catch (err: unknown) {
            console.error('Error during registration:', err);
             let message = t('registerPage.errorRegistration');
            if (err instanceof AxiosError && err.response?.data?.message) { message = err.response.data.message; }
            else if (err instanceof Error) { message = err.message; }
             notifications.show({
                  title: t('common.error'), message: message, color: 'red', icon: <IconX size={18} />, autoClose: 6000,
             });
        } finally { setIsLoading(false); }
    };

    const businessSelectOptions = businesses.map(b => ({ value: b.id, label: b.name }));

    return (
        <Container size={480} my={40}>
             <Title ta="center" style={{ fontWeight: 900 }}>{t('registerPage.welcomeTitle', '¬°Bienvenido a LoyalPyME!')}</Title>
             <Text c="dimmed" size="sm" ta="center" mt={5}>
                 {t('registerPage.subtitle')}{' '}
                 <Anchor size="sm" component={Link} to="/login">{t('registerPage.loginLink')}</Anchor>
             </Text>
             <Paper withBorder shadow="md" p={30} mt={30} radius="lg">
                 <Title order={2} ta="center" mb="lg">{t('registerPage.title')}</Title>
                 <form onSubmit={form.onSubmit(handleSubmit)}>
                     <Stack>
                         <TextInput
                             label={t('registerPage.emailLabel')}
                             placeholder={t('registerPage.emailPlaceholder')}
                             required disabled={isLoading} {...form.getInputProps('email')} />
                         <PasswordInput
                             label={t('registerPage.passwordLabel')}
                             placeholder={t('registerPage.passwordPlaceholder')}
                             required disabled={isLoading} {...form.getInputProps('password')} />
                         <PasswordInput
                             label={t('registerPage.confirmPasswordLabel')}
                             placeholder={t('registerPage.confirmPasswordPlaceholder')}
                             required disabled={isLoading} {...form.getInputProps('confirmPassword')} />
                         <TextInput
                             label={t('registerPage.nameLabel')}
                             placeholder={t('registerPage.namePlaceholder')}
                             disabled={isLoading} {...form.getInputProps('name')} />
                         <TextInput
                             label={t('registerPage.phoneLabel')}
                             placeholder={t('registerPage.phonePlaceholder')}
                             required disabled={isLoading} {...form.getInputProps('phone')} />
                         <Select
                             label={t('registerPage.docTypeLabel')}
                             placeholder={t('registerPage.docTypePlaceholder')}
                             data={documentTypeOptions} required disabled={isLoading} clearable={false} {...form.getInputProps('documentType')} />
                         <TextInput
                             label={t('registerPage.docIdLabel')}
                             placeholder={t('registerPage.docIdPlaceholder')}
                             required disabled={isLoading} {...form.getInputProps('documentId')} />
                         <Select
                             label={t('registerPage.businessLabel')}
                             placeholder={loadingBusinesses ? t('registerPage.businessSelectLoading') : t('registerPage.businessSelectPlaceholder')}
                             data={businessSelectOptions}
                             required
                             disabled={isLoading || loadingBusinesses || businesses.length === 0}
                             searchable
                             nothingFoundMessage={errorBusinesses ? t('registerPage.businessSelectError') : t('registerPage.businessSelectNotFound')}
                             clearable={false}
                             error={errorBusinesses}
                             {...form.getInputProps('businessId')}
                         />
                         {loadingBusinesses && <Group justify='center'><Loader size="xs" /></Group>}
                         <Button type="submit" loading={isLoading} fullWidth mt="xl" radius="lg">
                             {t('registerPage.registerButton')}
                         </Button>
                      </Stack>
                 </form>
             </Paper>
        </Container>
    );
};

export default RegisterPage;


// ====== [209] frontend/src/pages/ResetPasswordPage.tsx ======
// filename: frontend/src/pages/ResetPasswordPage.tsx
// Version: 1.1.0 (Implement i18n using useTranslation)

import { useState, useEffect, FormEvent } from 'react';
import { useNavigate, useParams, Link } from 'react-router-dom';
import axios from 'axios';
import {
    Container, Paper, Title, Text, Stack, PasswordInput, Button, Anchor
} from '@mantine/core';
import { notifications } from '@mantine/notifications';
import { IconCheck, IconX, IconAlertCircle } from '@tabler/icons-react';
// --- NUEVO: Importar useTranslation ---
import { useTranslation } from 'react-i18next';
// --- FIN NUEVO ---


const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000';

const ResetPasswordPage: React.FC = () => {
    // --- NUEVO: Hook useTranslation ---
    const { t } = useTranslation();
    // --- FIN NUEVO ---

    const navigate = useNavigate();
    const { token } = useParams<{ token: string }>();

    const [password, setPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [isLoading, setIsLoading] = useState(false);

    useEffect(() => {
        if (!token) {
            console.error('No reset token found in URL parameters.');
            // --- CAMBIO: Usar t() en notificaci√≥n ---
            notifications.show({
                title: t('resetPasswordPage.errorTitle'),
                message: t('resetPasswordPage.errorMissingToken'),
                color: 'red',
                icon: <IconX size={18} />,
                autoClose: false,
            });
            // --- FIN CAMBIO ---
        }
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [token]); // t() no necesita ser dependencia aqu√≠ generalmente


    const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
        event.preventDefault();

        if (!token) {
             // --- CAMBIO: Usar t() en notificaci√≥n ---
             notifications.show({
                title: t('resetPasswordPage.errorTitle'),
                message: t('resetPasswordPage.errorMissingToken'),
                color: 'red',
                icon: <IconX size={18} />
            });
            // --- FIN CAMBIO ---
            return;
        }
        if (!password || !confirmPassword) {
             // --- CAMBIO: Usar t() en notificaci√≥n ---
             notifications.show({
                title: t('common.error'), // Usar clave com√∫n
                message: t('resetPasswordPage.errorPasswordsRequired'),
                color: 'orange',
                icon: <IconAlertCircle size={18}/>
            });
             // --- FIN CAMBIO ---
            return;
        }
        if (password !== confirmPassword) {
             // --- CAMBIO: Usar t() en notificaci√≥n ---
             notifications.show({
                title: t('common.error'),
                message: t('resetPasswordPage.errorPasswordsDontMatch'),
                color: 'orange',
                icon: <IconAlertCircle size={18}/>
            });
             // --- FIN CAMBIO ---
            return;
        }
        if (password.length < 6) {
             // --- CAMBIO: Usar t() en notificaci√≥n ---
            notifications.show({
                title: t('resetPasswordPage.errorTitle'), // T√≠tulo espec√≠fico? O com√∫n?
                message: t('resetPasswordPage.errorPasswordLength'),
                color: 'orange',
                icon: <IconAlertCircle size={18}/>
            });
            // --- FIN CAMBIO ---
            return;
        }

        setIsLoading(true);

        try {
            const resetUrl = `${API_BASE_URL}/api/auth/reset-password/${token}`;
            await axios.post(resetUrl, { password });

            // --- CAMBIO: Usar t() en notificaci√≥n ---
            notifications.show({
                title: t('resetPasswordPage.successTitle'),
                message: t('resetPasswordPage.successMessage'),
                color: 'green', icon: <IconCheck size={18} />, autoClose: 5000,
            });
            // --- FIN CAMBIO ---

            setTimeout(() => {
                navigate('/login', { state: { passwordResetSuccess: true } });
            }, 2000);
        } catch (error: any) {
            console.error('Error resetting password:', error);
            const message = error.response?.data?.message || t('resetPasswordPage.errorInvalidToken');
            // --- CAMBIO: Usar t() en notificaci√≥n ---
            notifications.show({
                title: t('resetPasswordPage.errorTitle'),
                message: message,
                color: 'red',
                icon: <IconX size={18} />,
                autoClose: 6000,
            });
            // --- FIN CAMBIO ---
        } finally {
            setIsLoading(false);
        }
    };

    // --- JSX MODIFICADO ---
    return (
         <Container size={480} my={40}>
             <Title ta="center" style={{ fontWeight: 900 }}>{t('resetPasswordPage.title')}</Title>
             <Text c="dimmed" size="sm" ta="center" mt={5}>{t('resetPasswordPage.subtitle')}</Text>

             <Paper withBorder shadow="md" p={30} mt={30} radius="lg">
                 {token ? (
                     <form onSubmit={handleSubmit}>
                         <Stack>
                             <PasswordInput
                                 label={t('resetPasswordPage.passwordLabel')}
                                 placeholder={t('resetPasswordPage.passwordPlaceholder')}
                                 value={password}
                                 onChange={(event) => setPassword(event.currentTarget.value)}
                                 required
                                 disabled={isLoading} />
                             <PasswordInput
                                 label={t('resetPasswordPage.confirmPasswordLabel')}
                                 placeholder={t('resetPasswordPage.confirmPasswordPlaceholder')}
                                 value={confirmPassword}
                                 onChange={(event) => setConfirmPassword(event.currentTarget.value)}
                                 required
                                 disabled={isLoading} />
                             <Button
                                 type="submit"
                                 loading={isLoading}
                                 fullWidth
                                 mt="xl"
                                 radius="lg"
                             >
                                 {t('resetPasswordPage.buttonText')}
                             </Button>
                         </Stack>
                     </form>
                  ) : (
                      <Text color="red" ta="center">{t('resetPasswordPage.errorMissingToken')}</Text>
                  )}
                  <Text ta="center" mt="md">
                      <Anchor component={Link} to="/login" size="sm">{t('resetPasswordPage.loginLink')}</Anchor>
                  </Text>
            </Paper>
         </Container>
    );
    // --- FIN JSX MODIFICADO ---
};

export default ResetPasswordPage;

// End of File: frontend/src/pages/ResetPasswordPage.tsx


// ====== [210] frontend/src/routes/index.tsx ======
// frontend/src/routes/index.tsx (CORREGIDO FINAL v5)
import { Routes, Route, Navigate, Outlet } from 'react-router-dom';

// --- SHARED ---
import PrivateRoute from '../shared/components/PrivateRoute';
import MainLayout from '../shared/components/layout/MainLayout';
import PublicLayout from '../shared/components/layout/PublicLayout';
import { UserRole } from '../shared/types/user.types';

// --- P√ÅGINAS P√öBLICAS ---
import LoginPage from '../pages/LoginPage';
import RegisterPage from '../pages/RegisterPage';
import ForgotPasswordPage from '../pages/ForgotPasswordPage';
import ResetPasswordPage from '../pages/ResetPasswordPage';
import RegisterBusinessPage from '../pages/RegisterBusinessPage';

// --- P√ÅGINAS DE M√ìDULOS ---
// M√≥dulo Camarero
import PublicMenuViewPage from '../modules/camarero/pages/PublicMenuViewPage';
import OrderStatusPage from '../modules/camarero/pages/OrderStatusPage';
import KitchenDisplayPage from '../modules/camarero/pages/admin/camarero/KitchenDisplayPage';
import MenuManagementPage from '../modules/camarero/pages/admin/camarero/MenuManagementPage';
import WaiterOrderManagementPage from '../modules/camarero/pages/admin/camarero/WaiterOrderManagementPage';
import WaiterPickupPage from '../modules/camarero/pages/admin/camarero/WaiterPickupPage';
// M√≥dulo LoyalPyME
import CustomerDashboardPage from '../modules/loyalpyme/pages/CustomerDashboardPage';
import AdminOverview from '../modules/loyalpyme/pages/admin/AdminOverview';
import AdminRewardsManagement from '../modules/loyalpyme/pages/admin/AdminRewardsManagement';
import AdminGenerateQr from '../modules/loyalpyme/pages/admin/AdminGenerateQr';
import TierSettingsPage from '../modules/loyalpyme/pages/admin/tiers/TierSettingsPage';
import TierManagementPage from '../modules/loyalpyme/pages/admin/tiers/TierManagementPage';
import AdminCustomerManagementPage from '../modules/loyalpyme/pages/admin/AdminCustomerManagementPage';
// M√≥dulo SuperAdmin
import SuperAdminPage from '../modules/superadmin/pages/SuperAdminPage';


function AppRoutes() {
  return (
    <Routes>
      {/* Rutas P√∫blicas */}
      <Route element={<PublicLayout />}>
        <Route path="/login" element={<LoginPage />} />
        <Route path="/register" element={<RegisterPage />} />
        <Route path="/register-business" element={<RegisterBusinessPage />} />
        <Route path="/forgot-password" element={<ForgotPasswordPage />} />
        <Route path="/reset-password/:token" element={<ResetPasswordPage />} />
        <Route path="/m/:businessSlug/:tableIdentifier?" element={<PublicMenuViewPage />} />
        <Route path="/order-status/:orderId" element={<OrderStatusPage />} />
        <Route path="/" element={<Navigate to="/login" replace />} />
      </Route>

      {/* Rutas Protegidas */}
      <Route element={<MainLayout />}>
        <Route
            path="/superadmin"
            element={ <PrivateRoute allowedRoles={[UserRole.SUPER_ADMIN]}><SuperAdminPage /></PrivateRoute> }
        />
        <Route path="/admin" element={<Outlet />}>
            <Route path="dashboard" element={<PrivateRoute allowedRoles={[UserRole.BUSINESS_ADMIN]}><Outlet /></PrivateRoute>}>
                <Route index element={<AdminOverview />} />
                <Route path="rewards" element={<AdminRewardsManagement />} />
                <Route path="generate-qr" element={<AdminGenerateQr />} />
                <Route path="tiers/settings" element={<TierSettingsPage />} />
                <Route path="tiers/manage" element={<TierManagementPage />} />
                <Route path="customers" element={<AdminCustomerManagementPage />} />
                <Route path="camarero/menu-editor" element={<MenuManagementPage />} />
            </Route>
            <Route path="kds" element={<PrivateRoute allowedRoles={[UserRole.KITCHEN_STAFF, UserRole.BAR_STAFF, UserRole.BUSINESS_ADMIN]}><KitchenDisplayPage /></PrivateRoute>} />
            <Route path="camarero/pickup" element={<PrivateRoute allowedRoles={[UserRole.WAITER, UserRole.BUSINESS_ADMIN]}><WaiterPickupPage /></PrivateRoute>} />
            <Route path="camarero/orders" element={<PrivateRoute allowedRoles={[UserRole.WAITER, UserRole.BUSINESS_ADMIN]}><WaiterOrderManagementPage /></PrivateRoute>} />
            <Route index element={<PrivateRoute allowedRoles={[UserRole.BUSINESS_ADMIN, UserRole.KITCHEN_STAFF, UserRole.BAR_STAFF, UserRole.WAITER]}><Navigate to="dashboard" replace /></PrivateRoute>} />
        </Route>
        <Route
            path="/customer/dashboard"
            element={ <PrivateRoute allowedRoles={[UserRole.CUSTOMER_FINAL]}><CustomerDashboardPage /></PrivateRoute> }
        />
      </Route>
    </Routes>
  );
}

export default AppRoutes;


// ====== [211] frontend/src/shared/components/PrivateRoute.tsx ======
// frontend/src/shared/components/PrivateRoute.tsx (CORREGIDO)
import React from 'react';
import { Navigate, Outlet, useLocation } from 'react-router-dom';

// --- RUTA Y NOMBRE CORREGIDOS ---
import { UserRole } from '../types/user.types';
// --- FIN CORRECCI√ìN ---


interface PrivateRouteProps {
  allowedRoles?: UserRole[];
  children?: React.ReactNode;
}

function PrivateRoute({ allowedRoles, children }: PrivateRouteProps) {
  const location = useLocation();

  const token = localStorage.getItem('token');
  if (!token) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  const userJson = localStorage.getItem('user');
  let user = null;
  try {
      if(userJson) user = JSON.parse(userJson);
  } catch (e) {
      console.error("[PrivateRoute] Failed to parse user from localStorage", e);
      localStorage.removeItem('token');
      localStorage.removeItem('user');
      return <Navigate to="/login" state={{ from: location }} replace />;
  }

  if (!user || (allowedRoles && allowedRoles.length > 0 && (!user.role || !allowedRoles.includes(user.role as UserRole)))) {
    const fallbackPath = user?.role === UserRole.BUSINESS_ADMIN ? '/admin/dashboard'
                       : user?.role === UserRole.CUSTOMER_FINAL ? '/customer/dashboard'
                       : user?.role === UserRole.SUPER_ADMIN ? '/superadmin'
                       // --- A√ëADIDO: Redirecci√≥n para roles de staff ---
                       : user?.role === UserRole.WAITER ? '/admin/camarero/pickup'
                       : user?.role === UserRole.KITCHEN_STAFF || user.role === UserRole.BAR_STAFF ? '/admin/kds'
                       // --- FIN A√ëADIDO ---
                       : '/login';
    return <Navigate to={fallbackPath} replace />;
  }

  return <>{children || <Outlet />}</>;
}

export default PrivateRoute;


// ====== [212] frontend/src/shared/components/layout/AdminNavbar.tsx ======
// frontend/src/components/layout/AdminNavbar.tsx
// Version: 1.2.1 (Add debug logs for WAITER role)

import React from 'react';
import { Link } from 'react-router-dom';
import { NavLink } from '@mantine/core';
import {
    IconGauge,
    IconGift,
    IconQrcode,
    IconUsers,
    IconStairsUp,
    IconSettings,
    IconToolsKitchen,
    IconClipboardText,
    IconFileInvoice
} from '@tabler/icons-react';
import { useTranslation } from 'react-i18next';
import type { UserData } from '../../../shared/types/user.types';
import { UserRole } from '../../../shared/types/user.types';

interface AdminNavbarProps {
    pathname: string;
    closeNavbar: () => void;
    userData: UserData | null;
}

const AdminNavbar: React.FC<AdminNavbarProps> = ({ pathname, closeNavbar, userData }) => {
    const { t } = useTranslation();

    // ---- DEBUG LOG ----
    // Loguear siempre que userData cambie o el componente se renderice con userData
    if (userData) {
        console.log("[AdminNavbar DEBUG] UserData received in props:", JSON.stringify(userData, null, 2));
        console.log(`[AdminNavbar DEBUG] Current Role: ${userData.role}, IsCamareroActive: ${userData.isCamareroActive}`);

        if (userData.role === UserRole.WAITER) {
            console.log("[AdminNavbar DEBUG - WAITER CONTEXT] Role matches WAITER.");
            const conditionForPickup = userData?.isCamareroActive === true && (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN);
            console.log("[AdminNavbar DEBUG - WAITER CONTEXT] ShowCondition for '/admin/camarero/pickup':", conditionForPickup);

            const conditionForOrders = userData?.isCamareroActive === true && (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN);
            console.log("[AdminNavbar DEBUG - WAITER CONTEXT] ShowCondition for '/admin/camarero/orders':", conditionForOrders);
        }
    } else {
        console.log("[AdminNavbar DEBUG] UserData is null.");
    }
    // ---- FIN DEBUG LOG ----

    const allPossibleNavLinks = [
        {
            to: "/admin/dashboard",
            labelKey: 'adminCommon.dashboard',
            icon: IconGauge,
            showCondition: userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/rewards",
            labelKey: 'adminCommon.rewards',
            icon: IconGift,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/generate-qr",
            labelKey: 'adminCommon.generateQr',
            icon: IconQrcode,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/customers",
            labelKey: 'adminCommon.customers',
            icon: IconUsers,
            showCondition: (userData?.isLoyaltyCoreActive === true || userData?.isCamareroActive === true) && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/tiers/manage",
            labelKey: 'adminCommon.manageTiers',
            icon: IconStairsUp,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/tiers/settings",
            labelKey: 'adminCommon.tierSettings',
            icon: IconSettings,
            showCondition: userData?.isLoyaltyCoreActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/dashboard/camarero/menu-editor",
            labelKey: 'adminCamarero.manageMenu.title',
            icon: IconToolsKitchen,
            showCondition: userData?.isCamareroActive === true && userData?.role === UserRole.BUSINESS_ADMIN,
        },
        {
            to: "/admin/camarero/pickup",
            labelKey: 'waiterInterface.navLinkPickup',
            icon: IconClipboardText,
            showCondition: userData?.isCamareroActive === true &&
                           (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN)
        },
        {
            to: "/admin/camarero/orders",
            labelKey: 'waiterOrderManagement.navLinkTitle',
            icon: IconFileInvoice,
            showCondition: userData?.isCamareroActive === true &&
                           (userData?.role === UserRole.WAITER || userData?.role === UserRole.BUSINESS_ADMIN)
        },
    ];

    const navLinksToShow = allPossibleNavLinks.filter(link => link.showCondition);
    
    // ---- DEBUG LOG ----
    if (userData?.role === UserRole.WAITER) {
      console.log("[AdminNavbar DEBUG - WAITER CONTEXT] Final navLinksToShow for WAITER:", navLinksToShow.map(l => ({ to: l.to, labelKey: l.labelKey })));
    }
    // ---- FIN DEBUG LOG ----


    return (
        <>
            {navLinksToShow.map((link) => (
                <NavLink
                    key={link.to}
                    label={t(link.labelKey)}
                    leftSection={<link.icon size="1rem" stroke={1.5} />}
                    component={Link}
                    to={link.to}
                    active={pathname.startsWith(link.to) && (pathname === link.to || pathname.startsWith(link.to + '/'))}
                    onClick={closeNavbar}
                />
            ))}
        </>
    );
};

export default AdminNavbar;


// ====== [213] frontend/src/shared/components/layout/AppHeader.tsx ======
// frontend/src/components/layout/AppHeader.tsx
// Version: 1.6.2 (Use full UserRole enum for LayoutUserData)

import React from 'react';
import {
    Group, Burger, Skeleton, Button, Menu, UnstyledButton, Box, Text,
    Container
} from '@mantine/core';
import {
    IconUserCircle,
    IconLogout,
    IconChevronDown,
} from '@tabler/icons-react';
import { useDisclosure } from '@mantine/hooks';
import { useTranslation } from 'react-i18next';
import ReactCountryFlag from 'react-country-flag';
import { Link } from 'react-router-dom';

// ---- MODIFICACI√ìN: Importar UserRole ----
import { UserRole } from '../../../shared/types/user.types'; // Aseg√∫rate que la ruta es correcta

// Interfaz LayoutUserData MODIFICADA
interface LayoutUserData {
    id: string;
    name?: string | null;
    email: string;
    role: UserRole; // <--- CAMBIADO A USAR EL ENUM UserRole COMPLETO
}
// ---- FIN MODIFICACI√ìN ----

interface AppHeaderProps {
    userData: LayoutUserData | null; // Ahora espera el enum UserRole
    loadingUser: boolean;
    handleLogout: () => void;
    navbarOpened?: boolean;
    toggleNavbar?: () => void;
    showAdminNavbar?: boolean;
}

// Componente Logo (sin cambios)
const Logo: React.FC<{ homePath: string }> = ({ homePath }) => (
    <Link
        to={homePath}
        style={{ textDecoration: 'none', color: 'inherit', display: 'flex', alignItems: 'center' }}
        aria-label={homePath === "/" || homePath === "/login" ? "Ir a la p√°gina de inicio de sesi√≥n" : "Ir a mi panel principal"}
    >
        <img
            src="/loyalpymelogo.jpg"
            alt="LoyalPyME Logo"
            style={{ height: '40px', width: 'auto', display: 'block' }}
        />
    </Link>
);

const AppHeader: React.FC<AppHeaderProps> = ({
    userData, loadingUser, handleLogout, navbarOpened, toggleNavbar, showAdminNavbar = false,
}) => {
    const { i18n, t } = useTranslation();
    const [mobileMenuOpened, { toggle: toggleMobileMenu, close: closeMobileMenu }] = useDisclosure(false);

    let logoLinkPath = "/";

    if (userData) {
        // La l√≥gica de redirecci√≥n aqu√≠ ya usa el enum UserRole, lo cual es bueno
        if (userData.role === UserRole.CUSTOMER_FINAL) {
            logoLinkPath = "/customer/dashboard";
        } else if (userData.role === UserRole.BUSINESS_ADMIN) {
            logoLinkPath = "/admin/dashboard";
        } else if (userData.role === UserRole.SUPER_ADMIN) {
            logoLinkPath = "/superadmin";
        // ---- A√ëADIR CASOS PARA NUEVOS ROLES DE STAFF SI QUIERES QUE EL LOGO LOS LLEVE A SU P√ÅGINA ----
        } else if (userData.role === UserRole.WAITER) {
            logoLinkPath = "/admin/camarero/pickup"; // O a /admin/camarero/orders
        } else if (userData.role === UserRole.KITCHEN_STAFF || userData.role === UserRole.BAR_STAFF) {
            logoLinkPath = "/admin/kds";
        }
        // ---- FIN A√ëADIR CASOS ----
    }

    const changeLanguage = (lang: string) => { i18n.changeLanguage(lang); closeMobileMenu(); };
    const currentCountryCode = i18n.resolvedLanguage === 'es' ? 'ES' : 'GB';
    const languages = [ { code: 'es', name: 'Espa√±ol', country: 'ES' }, { code: 'en', name: 'English', country: 'GB' }, ];

    const onLogoutClick = () => {
        handleLogout();
        closeMobileMenu();
    };

    const LogoutButtonInternal = () => ( <Button onClick={onLogoutClick} variant="light" color="red" size="sm" leftSection={<IconLogout size={16}/>}>{t('header.logoutButton')}</Button> );

    const LanguageSwitcherDesktop = () => (
         <Menu shadow="md" width={150} trigger="hover" openDelay={100} closeDelay={200}>
            <Menu.Target>
                 <UnstyledButton style={{ display: 'flex', alignItems: 'center', padding: '5px', borderRadius: 'var(--mantine-radius-sm)'}}>
                    <ReactCountryFlag countryCode={currentCountryCode} svg style={{ display: 'block', width: '1.4em', height: '1.4em' }} aria-label={currentCountryCode} />
                    <IconChevronDown size={16} stroke={1.5} style={{ marginLeft: '4px', color: 'var(--mantine-color-dimmed)' }} />
                 </UnstyledButton>
            </Menu.Target>
            <Menu.Dropdown>
                <Menu.Label>{t('header.languageLabel')}</Menu.Label>
                {languages.map((lang) => ( <Menu.Item key={lang.code} leftSection={<ReactCountryFlag countryCode={lang.country} svg style={{ fontSize: '1.1em', display:'block' }} />} onClick={() => changeLanguage(lang.code)} disabled={i18n.resolvedLanguage === lang.code}>{lang.name}</Menu.Item> ))}
            </Menu.Dropdown>
        </Menu>
    );

    return (
        <Box component="header" h="100%">
            <Container size="lg" h="100%" style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                <Group gap="xs">
                    {showAdminNavbar && toggleNavbar && ( <Burger opened={navbarOpened ?? false} onClick={toggleNavbar} hiddenFrom="sm" size="sm"/> )}
                    <Logo homePath={logoLinkPath} />
                </Group>

                {loadingUser ? ( <Skeleton height={30} width={120} /> )
                 : userData ? (
                    <Group gap="sm">
                        <Group visibleFrom="sm" gap="sm">
                            <Text size="sm" truncate>
                                <IconUserCircle size={18} style={{ verticalAlign: 'middle', marginRight: '4px' }} />
                                {t('header.greeting', { name: userData.name || userData.email })}
                            </Text>
                            <LanguageSwitcherDesktop />
                            <LogoutButtonInternal />
                        </Group>
                         <Box hiddenFrom="sm">
                             <Menu shadow="md" width={200} opened={mobileMenuOpened} onChange={toggleMobileMenu} position="bottom-end">
                                <Menu.Target>
                                     <Burger opened={mobileMenuOpened} onClick={toggleMobileMenu} aria-label={t('header.toggleNavigation', 'Toggle navigation')} size="sm"/>
                                </Menu.Target>
                                <Menu.Dropdown>
                                     <Menu.Label>{userData.name || userData.email}</Menu.Label>
                                    <Menu.Divider />
                                    <Menu.Label>{t('header.languageLabel')}</Menu.Label>
                                    {languages.map((lang) => (
                                        <Menu.Item key={lang.code} leftSection={<ReactCountryFlag countryCode={lang.country} svg style={{ fontSize: '1.1em', display:'block' }} />} onClick={() => changeLanguage(lang.code)} disabled={i18n.resolvedLanguage === lang.code}>
                                            {lang.name}
                                         </Menu.Item>
                                    ))}
                                    <Menu.Divider />
                                     <Menu.Item color="red" leftSection={<IconLogout size={14} />} onClick={onLogoutClick}>
                                         {t('header.logoutButton')}
                                     </Menu.Item>
                                </Menu.Dropdown>
                            </Menu>
                         </Box>
                    </Group>
                ) : (
                    <Group>
                        <LanguageSwitcherDesktop />
                    </Group>
                )}
            </Container>
        </Box>
    );
};

export default AppHeader;


// ====== [214] frontend/src/shared/components/layout/MainLayout.tsx ======
// frontend/src/components/layout/MainLayout.tsx
// Version 1.0.1 (Correct logic for showing AdminNavbar for WAITER and other staff roles)

import React from 'react';
import { Outlet, useLocation } from 'react-router-dom';
import { AppShell } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { useLayoutUserData } from '../../hooks/useLayoutUserData';
import AppHeader from './AppHeader';
import AdminNavbar from './AdminNavbar';
import { UserRole } from '../../types/user.types';

const MainLayout: React.FC = () => {
    const { userData, loadingUser, handleLogout } = useLayoutUserData();
    const location = useLocation();
    const [navbarOpened, { toggle: toggleNavbar, close: closeNavbar }] = useDisclosure();

    // ---- L√ìGICA MODIFICADA PARA MOSTRAR AdminNavbar ----
    // Determinar si la ruta actual es una ruta de "admin" en general
    const isAnyAdminRoute = location.pathname.startsWith('/admin/');

    // Definir qu√© roles deben ver la AdminNavbar en las rutas /admin/*
    const rolesThatSeeAdminNavbar: UserRole[] = [
        UserRole.BUSINESS_ADMIN,
        UserRole.WAITER,
        UserRole.KITCHEN_STAFF,
        UserRole.BAR_STAFF
        // SUPER_ADMIN tiene su propia ruta /superadmin y no usa esta navbar
    ];

    // AdminNavbar se muestra si el usuario tiene uno de los roles permitidos Y est√° en una ruta /admin/*
    const showAdminNavbar = userData?.role &&
                            rolesThatSeeAdminNavbar.includes(userData.role) &&
                            isAnyAdminRoute;
    // ---- FIN L√ìGICA MODIFICADA ----


    // Debug log para la condici√≥n de la navbar
    // console.log(`[MainLayout] Path: ${location.pathname}, Role: ${userData?.role}, isAnyAdminRoute: ${isAnyAdminRoute}, showAdminNavbar: ${showAdminNavbar}`);

    return (
        <AppShell
            header={{ height: 60 }}
            navbar={{
                width: 250,
                breakpoint: 'sm',
                // Mostrar/ocultar navbar si showAdminNavbar es true y navbarOpened es true (para m√≥vil)
                collapsed: { mobile: !navbarOpened || !showAdminNavbar, desktop: !showAdminNavbar }
            }}
            padding="md"
        >
            <AppShell.Header>
                <AppHeader
                    userData={userData}
                    loadingUser={loadingUser}
                    handleLogout={handleLogout}
                    navbarOpened={navbarOpened}
                    toggleNavbar={toggleNavbar}
                    // El burger del header debe aparecer si showAdminNavbar es true,
                    // independientemente de si la navbar est√° colapsada o no en desktop.
                    showAdminNavbar={showAdminNavbar}
                />
            </AppShell.Header>

            {/* Mostrar AdminNavbar solo si showAdminNavbar es true */}
            {showAdminNavbar && (
                <AppShell.Navbar p="md">
                    <AdminNavbar
                        pathname={location.pathname}
                        closeNavbar={closeNavbar}
                        userData={userData}
                    />
                </AppShell.Navbar>
            )}

            <AppShell.Main>
                <Outlet />
            </AppShell.Main>
        </AppShell>
    );
};

export default MainLayout;


// ====== [215] frontend/src/shared/components/layout/PublicLayout.tsx ======
// filename: frontend/src/components/layout/PublicLayout.tsx
// Nuevo layout simple para p√°ginas p√∫blicas, solo incluye el Header.

import React from 'react';
import { Outlet } from 'react-router-dom';
import { AppShell } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks'; // Necesario para AppHeader
import { useLayoutUserData } from '../../hooks/useLayoutUserData'; // Necesario para AppHeader
import AppHeader from './AppHeader'; // Importamos el header existente

const PublicLayout: React.FC = () => {
    // Necesitamos obtener los datos y el estado de la navbar para pasarlos al AppHeader
    const { userData, loadingUser, handleLogout } = useLayoutUserData();
    // Aunque no mostramos la navbar aqu√≠, AppHeader necesita el estado y el toggle para el Burger en m√≥vil
    const [navbarOpened, { toggle: toggleNavbar }] = useDisclosure();

    return (
        <AppShell
            header={{ height: 60 }}
            // NO definimos navbar aqu√≠
            padding="md" // Mantenemos padding general
        >
            {/* Cabecera (la misma que en MainLayout) */}
            <AppShell.Header>
                <AppHeader
                    userData={userData}
                    loadingUser={loadingUser}
                    handleLogout={handleLogout}
                    navbarOpened={navbarOpened}
                    toggleNavbar={toggleNavbar}
                    showAdminNavbar={false} // Nunca mostramos navbar admin en layout p√∫blico
                />
            </AppShell.Header>

            {/* Contenido principal de la p√°gina p√∫blica actual */}
            <AppShell.Main>
                <Outlet /> {/* Aqu√≠ se renderiza LoginPage, RegisterPage, etc. */}
            </AppShell.Main>
        </AppShell>
    );
};

export default PublicLayout;

// End of File: frontend/src/components/layout/PublicLayout.tsx


// ====== [216] frontend/src/shared/components/utils/ImageUploadCropper.tsx ======
// frontend/src/components/utils/ImageUploadCropper.tsx
// Version 1.1.0 (Set default crop to 100% width)

import React, { useState, useRef, SyntheticEvent, useEffect } from 'react';
import {
    FileInput, Button, Group, AspectRatio, Image as MantineImage,
    Center, Text, Alert, Box, Stack, LoadingOverlay
} from '@mantine/core';
import {
    IconUpload, IconPhoto, IconX, IconAlertCircle, IconCrop, IconCameraRotate
} from '@tabler/icons-react';
import ReactCrop, {
    centerCrop,
    makeAspectCrop,
    type Crop,
    type PixelCrop,
} from 'react-image-crop';
import 'react-image-crop/dist/ReactCrop.css';
import { canvasPreview, canvasToBlob } from '../utils/canvasPreview';
import { useTranslation } from 'react-i18next';
import axiosInstance from '../../services/axiosInstance';

export interface ImageUploadCropperProps {
    aspectRatio: number;
    minDimension: number;
    outputWidth?: number;
    outputHeight?: number;
    initialImageUrl: string | null;
    onUploadSuccess: (imageUrl: string) => void;
    onUploadError: (errorMessage: string) => void;
    onClearImage: () => void;
    folderName?: string;
    disabled?: boolean;
    selectImageButtonLabel?: string;
    confirmCropButtonLabel?: string;
    removeImageButtonLabel?: string;
    cropInstructionsLabel?: string;
    imagePreviewAltText?: string;
    imageToCropAltText?: string;
}

const DEFAULT_CLOUDINARY_FOLDER = 'loyalpyme/uploads';

const ImageUploadCropper: React.FC<ImageUploadCropperProps> = ({
    aspectRatio,
    minDimension,
    outputWidth,
    outputHeight,
    initialImageUrl,
    onUploadSuccess,
    onUploadError,
    onClearImage,
    folderName = DEFAULT_CLOUDINARY_FOLDER,
    disabled = false,
    selectImageButtonLabel,
    confirmCropButtonLabel,
    removeImageButtonLabel,
    cropInstructionsLabel,
    imagePreviewAltText,
    imageToCropAltText,
}) => {
    const { t } = useTranslation();
    const imgRef = useRef<HTMLImageElement>(null);
    const previewCanvasRef = useRef<HTMLCanvasElement>(null);

    const [currentDisplayUrl, setCurrentDisplayUrl] = useState<string | null>(initialImageUrl);
    const [imgSrcForCropper, setImgSrcForCropper] = useState<string>('');
    const [crop, setCrop] = useState<Crop>();
    const [completedCrop, setCompletedCrop] = useState<PixelCrop>();
    const [isUploading, setIsUploading] = useState<boolean>(false);
    const [internalUploadError, setInternalUploadError] = useState<string | null>(null);
    const [selectedFile, setSelectedFile] = useState<File | null>(null);

    useEffect(() => {
        setCurrentDisplayUrl(initialImageUrl);
        if (initialImageUrl && imgSrcForCropper) {
            setImgSrcForCropper('');
            setSelectedFile(null);
            setCrop(undefined);
            setCompletedCrop(undefined);
        }
    }, [initialImageUrl, imgSrcForCropper]);


    const handleFileSelect = (file: File | null) => {
        setInternalUploadError(null);
        setSelectedFile(file);
        if (file) {
            setCrop(undefined);
            setCompletedCrop(undefined);
            setCurrentDisplayUrl(null);
            const reader = new FileReader();
            reader.addEventListener('load', () => {
                setImgSrcForCropper(reader.result?.toString() || '');
            });
            reader.readAsDataURL(file);
        } else {
            setImgSrcForCropper('');
            if (initialImageUrl) {
                setCurrentDisplayUrl(initialImageUrl);
            }
        }
    };

    const onImageLoad = (e: SyntheticEvent<HTMLImageElement>) => {
        const { naturalWidth, naturalHeight } = e.currentTarget;
        setInternalUploadError(null);

        if (naturalWidth < minDimension || naturalHeight < minDimension) {
            const errorMsg = t('common.errorImageTooSmall', { minSize: minDimension });
            setInternalUploadError(errorMsg);
            onUploadError(errorMsg);
            setImgSrcForCropper('');
            setSelectedFile(null);
            return;
        }

        // --- CAMBIO CLAVE: Cambiar width de 90 a 100 para seleccionar todo por defecto ---
        const newCrop = centerCrop(
            makeAspectCrop(
                {
                    unit: '%',
                    width: 100, // <--- ANTES 90, AHORA 100
                },
                aspectRatio,
                naturalWidth,
                naturalHeight
            ),
            naturalWidth,
            naturalHeight
        );
        // --- FIN CAMBIO CLAVE ---
        
        setCrop(newCrop);
        
        if (naturalWidth && naturalHeight) {
             setCompletedCrop({
                 unit: 'px',
                 x: (newCrop.x / 100) * naturalWidth,
                 y: (newCrop.y / 100) * naturalHeight,
                 width: (newCrop.width / 100) * naturalWidth,
                 height: (newCrop.height / 100) * naturalHeight,
             });
        }
    };

    const handleConfirmCropAndUpload = async () => {
        if (!imgRef.current || !previewCanvasRef.current || !completedCrop || completedCrop.width === 0 || completedCrop.height === 0) {
            const errorMsg = t('adminCamarero.menuCategoryForm.errorInvalidCropOrImage');
            setInternalUploadError(errorMsg);
            onUploadError(errorMsg);
            return;
        }
        setIsUploading(true);
        setInternalUploadError(null);
        try {
            const targetWidth = outputWidth || completedCrop.width;
            const targetHeight = outputHeight || completedCrop.height;

            await canvasPreview(
                imgRef.current,
                previewCanvasRef.current,
                completedCrop,
                1, 0,
                targetWidth,
                targetHeight
            );
            const blob = await canvasToBlob(previewCanvasRef.current);

            if (!blob) { throw new Error(t('adminCamarero.menuCategoryForm.errorCreatingCroppedFile')); }
            const formData = new FormData();
            formData.append('image', blob, selectedFile?.name || `cropped-image-${Date.now()}.png`);
            
            // Usamos la carpeta especificada en las props
            const response = await axiosInstance.post<{ url: string }>('/uploads/image', formData, {
                headers: { 'Content-Type': 'multipart/form-data', 'X-Upload-Folder': folderName }
            });

            if (response.data && response.data.url) {
                onUploadSuccess(response.data.url);
                setCurrentDisplayUrl(response.data.url);
                setImgSrcForCropper(''); setSelectedFile(null); setCrop(undefined); setCompletedCrop(undefined);
            } else { throw new Error(t('adminCamarero.menuCategoryForm.errorApiNoUrl')); }
        } catch (err: any) {
            const apiError = err.response?.data?.message || err.message || t('common.errorUnknown');
            const errorMsg = t('adminCamarero.menuCategoryForm.errorUploadingWithDetail', { error: apiError });
            setInternalUploadError(errorMsg);
            onUploadError(errorMsg);
        } finally { setIsUploading(false); }
    };

    const handleRemoveImage = () => {
        setCurrentDisplayUrl(null);
        setImgSrcForCropper('');
        setSelectedFile(null);
        setCrop(undefined);
        setCompletedCrop(undefined);
        setInternalUploadError(null);
        onClearImage();
    };

    const showCropper = !!imgSrcForCropper;
    const effectiveImagePreviewAlt = imagePreviewAltText || t('component.rewardForm.altImagePreview', { name: 'Imagen' });
    const effectiveImageToCropAlt = imageToCropAltText || t('component.rewardForm.altCropImage');

    return (
        <Stack gap="sm">
            <LoadingOverlay visible={isUploading} overlayProps={{ radius: "sm", blur: 2 }} />
            <Text fw={500} size="sm">{t('component.rewardForm.imageLabel')}</Text>
            {!showCropper && (
                <AspectRatio ratio={aspectRatio} maw={300} mx="auto">
                    <Center bg="gray.1" style={{ borderRadius: 'var(--mantine-radius-md)', border: `1px dashed var(--mantine-color-gray-4)` }}>
                        {currentDisplayUrl ? (
                            <MantineImage src={currentDisplayUrl} alt={effectiveImagePreviewAlt} radius="sm" fit="contain" style={{ maxHeight: '100%', maxWidth: '100%' }} fallbackSrc="/placeholder-image.png" />
                        ) : ( <IconPhoto size={48} color="var(--mantine-color-gray-5)" stroke={1.5} /> )}
                    </Center>
                </AspectRatio>
            )}
            {showCropper && (
                <Box mt="xs" style={{ maxWidth: 500, margin: 'auto' }}>
                    <ReactCrop crop={crop} onChange={(_, percentCrop) => setCrop(percentCrop)} onComplete={(c) => setCompletedCrop(c)} aspect={aspectRatio} minWidth={50} minHeight={50 / aspectRatio} >
                        <img ref={imgRef} src={imgSrcForCropper} style={{ display: 'block', maxHeight: '400px', objectFit: 'contain' }} onLoad={onImageLoad} alt={effectiveImageToCropAlt} />
                    </ReactCrop>
                    {completedCrop && completedCrop.width > 0 && ( <canvas ref={previewCanvasRef} style={{ display: 'none', border: '1px solid black', objectFit: 'contain', width: completedCrop.width, height: completedCrop.height, }} /> )}
                </Box>
            )}
            <Group justify="center" mt="xs" wrap="nowrap">
                <FileInput placeholder={selectImageButtonLabel || t('component.rewardForm.selectImageButton')} accept="image/png,image/jpeg,image/webp,image/gif" onChange={handleFileSelect} leftSection={<IconUpload size={16} />} clearable disabled={disabled || isUploading} style={{ flexGrow: 1, maxWidth: showCropper ? 'calc(50% - 4px)' : '100%' }} value={selectedFile} />
                {showCropper && ( <Button onClick={handleConfirmCropAndUpload} loading={isUploading} disabled={!completedCrop || isUploading || disabled} leftSection={<IconCrop size={16} />} style={{ flexGrow: 1, maxWidth: 'calc(50% - 4px)' }} > {confirmCropButtonLabel || t('component.rewardForm.confirmCropButton')} </Button> )}
            </Group>
            {imgSrcForCropper && ( <Button variant="outline" color="gray" size="xs" mt="xs" onClick={() => { setImgSrcForCropper(''); setSelectedFile(null); setCrop(undefined); setCompletedCrop(undefined); if(initialImageUrl) setCurrentDisplayUrl(initialImageUrl); }} leftSection={<IconCameraRotate size={14}/>} disabled={isUploading || disabled} fullWidth > {t('common.cancel')} {t('common.edit')} / {t('common.selectPlaceholder')} </Button> )}
            {currentDisplayUrl && !showCropper && ( <Button variant="subtle" color="red" size="xs" mt="xs" onClick={handleRemoveImage} leftSection={<IconX size={14} />} disabled={disabled || isUploading} > {removeImageButtonLabel || t('component.rewardForm.removeImageButton')} </Button> )}
            {internalUploadError && ( <Alert title={t('common.error')} color="red" icon={<IconAlertCircle />} mt="sm" withCloseButton onClose={() => setInternalUploadError(null)} > <Text size="sm">{internalUploadError}</Text> </Alert> )}
            {cropInstructionsLabel && showCropper && <Text size="xs" c="dimmed" ta="center" mt="xs">{cropInstructionsLabel}</Text>}
        </Stack>
    );
};
export default ImageUploadCropper;


// ====== [217] frontend/src/shared/components/utils/canvasPreview.ts ======
// frontend/src/utils/canvasPreview.ts
// Version 1.0.2 (Removed unused centerX, centerY for current logic)
import { PixelCrop } from 'react-image-crop';

const TO_RADIANS = Math.PI / 180;

export async function canvasPreview(
  image: HTMLImageElement,
  canvas: HTMLCanvasElement,
  crop: PixelCrop,
  scale = 1,
  rotate = 0,
  outputWidth?: number,
  outputHeight?: number
) {
  const ctx = canvas.getContext('2d');

  if (!ctx) {
    throw new Error('No 2d context');
  }

  const scaleX = image.naturalWidth / image.width;  // Relaci√≥n entre tama√±o natural y tama√±o mostrado
  const scaleY = image.naturalHeight / image.height; // Usado para convertir crop de % a px si fuera el caso

  canvas.width = Math.floor(outputWidth || crop.width);   // Usar outputWidth o el ancho del crop en p√≠xeles
  canvas.height = Math.floor(outputHeight || crop.height); // Usar outputHeight o el alto del crop en p√≠xeles

  ctx.imageSmoothingQuality = 'high';

  const cropXInOriginal = crop.x * scaleX; // Coordenada X del crop en la imagen original
  const cropYInOriginal = crop.y * scaleY; // Coordenada Y del crop en la imagen original
  const cropWidthInOriginal = crop.width * scaleX; // Ancho del crop en la imagen original
  const cropHeightInOriginal = crop.height * scaleY; // Alto del crop en la imagen original

  const rotateRads = rotate * TO_RADIANS;

  ctx.save();
  // Mover el origen del canvas al centro del canvas para la rotaci√≥n/escalado
  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.rotate(rotateRads);
  ctx.scale(scale, scale);
  // Mover el origen de nuevo para que (0,0) del drawImage sea la esquina superior izquierda del √°rea de destino
  ctx.translate(-canvas.width / 2, -canvas.height / 2);

  // Dibujar la porci√≥n recortada de la imagen original,
  // y que se ajuste a las dimensiones completas del canvas (que son outputWidth/Height o el tama√±o del crop).
  ctx.drawImage(
    image,
    cropXInOriginal,
    cropYInOriginal,
    cropWidthInOriginal,
    cropHeightInOriginal,
    0, // Dibujar en la esquina (0,0) del canvas (ya transformado)
    0,
    canvas.width,  // Estirar/encoger a todo el ancho del canvas
    canvas.height  // Estirar/encoger a todo el alto del canvas
  );

  ctx.restore();
}

// canvasToBlob (sin cambios)
export function canvasToBlob(
  canvas: HTMLCanvasElement,
  type = 'image/png',
  quality = 0.9
): Promise<Blob | null> {
    return new Promise((resolve) => {
        canvas.toBlob(
            (blob) => { resolve(blob); },
            type,
            quality
        );
    });
}


// ====== [218] frontend/src/shared/hooks/useLayoutUserData.ts ======
// frontend/src/hooks/useLayoutUserData.ts
import { useState, useEffect, useCallback } from 'react';
import { useNavigate } from 'react-router-dom';
import axiosInstance from '../services/axiosInstance';
import type { UserData } from '../../types/customer';

interface UseLayoutUserDataReturn {
    userData: UserData | null;
    loadingUser: boolean;
    handleLogout: () => void;
}

export const useLayoutUserData = (): UseLayoutUserDataReturn => {
    const navigate = useNavigate();
    const [userData, setUserData] = useState<UserData | null>(null);
    const [loadingUser, setLoadingUser] = useState(true);

    const handleLogout = useCallback(() => {
        console.log("[useLayoutUserData] Executing logout...");
        localStorage.removeItem('token');
        localStorage.removeItem('user'); // Tambi√©n limpiar el usuario al hacer logout
        setUserData(null);
        if (window.location.pathname !== '/login') {
            navigate('/login', { replace: true });
        }
    }, [navigate]);

    useEffect(() => {
        const fetchAndSetUserData = async () => {
            console.log("[useLayoutUserData] Starting user data check/fetch...");
            setLoadingUser(true);
            const token = localStorage.getItem('token');

            if (!token) {
                console.log("[useLayoutUserData] No token found. Ensuring user is null.");
                if (userData !== null) setUserData(null); // Asegurar que userData es null si no hay token
                setLoadingUser(false);
                return;
            }

            // SIEMPRE intentamos obtener de /api/profile si hay token para datos frescos
            console.log("[useLayoutUserData] Token found. Fetching user profile from API...");
            try {
                const response = await axiosInstance.get<UserData>('/profile');
                if (response.data && response.data.id && response.data.email && response.data.role) {
                    setUserData(response.data);
                    localStorage.setItem('user', JSON.stringify(response.data)); // Actualizar localStorage con datos frescos
                    console.log("[useLayoutUserData] User data fetched from API and saved to localStorage:", response.data);
                } else {
                    console.error("[useLayoutUserData] Invalid or incomplete data received from API /profile endpoint. Logging out.");
                    handleLogout(); // Logout si API devuelve datos inv√°lidos/incompletos
                }
            } catch (apiError: any) {
                console.error("[useLayoutUserData] Error fetching user profile from API:", apiError);
                // Si falla /profile (ej. token expirado o inv√°lido), hacemos logout.
                // Esto tambi√©n limpia el localStorage.
                // Podr√≠amos intentar cargar desde localStorage como fallback aqu√≠,
                // pero es m√°s seguro hacer logout si /profile falla con un token existente.
                if (apiError.response?.status === 401 || apiError.response?.status === 403) {
                    console.log("[useLayoutUserData] API /profile returned 401/403, logging out.");
                    handleLogout();
                } else {
                    // Otro error de red, etc. No necesariamente invalida el token.
                    // Podr√≠amos intentar cargar desde localStorage como √∫ltimo recurso.
                    console.warn("[useLayoutUserData] API /profile fetch failed with other error. Attempting to load from localStorage if available.");
                    const storedUserJson = localStorage.getItem('user');
                    if (storedUserJson) {
                        try {
                            const parsed = JSON.parse(storedUserJson) as UserData;
                            if (parsed && parsed.id && parsed.email && parsed.role) {
                                setUserData(parsed);
                                console.log("[useLayoutUserData] Loaded stale data from localStorage due to API error.");
                            } else {
                                handleLogout(); // Stored data is invalid
                            }
                        } catch (e) {
                            handleLogout(); // Error parsing stored data
                        }
                    } else {
                        // No hay nada en localStorage y la API fall√≥, nos rendimos y hacemos logout.
                        handleLogout();
                    }
                }
            } finally {
                setLoadingUser(false);
                console.log("[useLayoutUserData] User data fetch/check process finished.");
            }
        };

        fetchAndSetUserData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [navigate]); // handleLogout no necesita estar aqu√≠ si su referencia no cambia, pero navigate s√≠

    // useEffect para reaccionar a cambios en localStorage (ej: logout en otra pesta√±a)
    useEffect(() => {
        const handleStorageChange = (event: StorageEvent) => {
            if (event.key === 'token' || event.key === 'user') {
                console.log('[useLayoutUserData] localStorage changed in another tab. Re-evaluating auth state.');
                // Forzar una re-evaluaci√≥n. Si 'token' es null, el efecto principal har√° logout.
                // Si 'token' existe pero 'user' cambi√≥ (o se borr√≥), el efecto principal deber√≠a recargar de /profile.
                // Una forma simple de forzarlo es recargar los datos.
                // O, si el token ya no existe, hacer logout.
                const token = localStorage.getItem('token');
                if (!token && userData !== null) { // Si el token se borr√≥ y ten√≠amos datos, hacemos logout
                    handleLogout();
                } else if (token && (!userData || (event.key === 'user' && localStorage.getItem('user') !== JSON.stringify(userData)))) {
                    // Si hay token pero no userData, o si 'user' cambi√≥, podemos forzar una recarga
                    // Esto es m√°s complejo, por ahora, el efecto principal al montar/cambiar navigate deber√≠a ser suficiente
                    // para la mayor√≠a de los casos de carga inicial.
                    // Para una sincronizaci√≥n perfecta entre pesta√±as, se necesitar√≠a una l√≥gica m√°s robusta
                    // o una librer√≠a de gesti√≥n de estado global.
                }
            }
        };

        window.addEventListener('storage', handleStorageChange);
        return () => {
            window.removeEventListener('storage', handleStorageChange);
        };
    }, [userData, handleLogout]);


    return { userData, loadingUser, handleLogout };
};


// ====== [219] frontend/src/shared/services/axiosInstance.ts ======
// filename: frontend/src/services/axiosInstance.ts
// Version: 1.1.1 (Remove meta-comments)

import axios from 'axios';

// Usar ruta relativa para baseURL
// El proxy de Vite redirigir√° /api a http://localhost:3000/api
const API_BASE_URL = '/api'; // Ruta relativa para que funcione el proxy

// Crea una instancia de Axios con la configuraci√≥n base
const axiosInstance = axios.create({
  baseURL: API_BASE_URL,
});

// A√±ade un interceptor de peticiones (request interceptor)
axiosInstance.interceptors.request.use(
  (config) => {
    // Obtener el token de localStorage
    const token = localStorage.getItem('token');
    if (token) {
      // A√±adir la cabecera Authorization si existe el token
      config.headers.set('Authorization', `Bearer ${token}`);
    }
    return config; // Devolver la configuraci√≥n modificada (o la original si no hay token)
  },
  (error) => {
    // Manejar errores que ocurran durante la configuraci√≥n de la petici√≥n
    console.error('Error in request interceptor:', error);
    return Promise.reject(error); // Rechazar la promesa con el error
  }
);

// Opcional: A√±adir interceptor de respuestas aqu√≠ si fuera necesario
/*
axiosInstance.interceptors.response.use(
  (response) => {
    // Cualquier c√≥digo de estado que este dentro del rango de 2xx causa la ejecuci√≥n de esta funci√≥n
    // Haz algo con los datos de la respuesta
    return response;
  },
  (error) => {
    // Cualquier c√≥digo de estado que caiga fuera del rango de 2xx causa la ejecuci√≥n de esta funci√≥n
    // Por ejemplo, manejar errores 401/403 globales aqu√≠
    if (error.response?.status === 401) {
      // Podr√≠amos hacer logout autom√°tico aqu√≠
      console.error("Unauthorized (401) response detected by interceptor.");
      // localStorage.removeItem('token');
      // localStorage.removeItem('user');
      // window.location.href = '/login'; // Redirecci√≥n forzada
    }
    return Promise.reject(error); // Rechazar la promesa con el error
  }
);
*/

// Exporta la instancia configurada para usarla en otros servicios
export default axiosInstance;

// End of File: frontend/src/services/axiosInstance.ts


// ====== [220] frontend/src/shared/services/businessService.ts ======
// filename: frontend/src/services/businessService.ts
// Version: 1.1.1 (Remove meta-comments, fix encoding)

import axios from 'axios'; // Usamos axios base, NO axiosInstance, porque es una ruta p√∫blica

/**
 * Interface para la estructura de datos de cada negocio en la lista p√∫blica.
 * Contiene lo necesario para un desplegable (valor y etiqueta).
 */
export interface BusinessOption {
  id: string;
  name: string;
}

// Usar ruta relativa para que funcione con el proxy de Vite
// El proxy definido en vite.config.ts para '/public' redirigir√° esto
const PUBLIC_BUSINESS_LIST_URL = '/public/businesses/public-list';


/**
 * Obtiene la lista p√∫blica de negocios (ID y Nombre) desde la API.
 * @returns Una promesa que resuelve con un array de objetos BusinessOption.
 * @throws Lanza un error si la petici√≥n a la API falla.
 */
export const getPublicBusinessList = async (): Promise<BusinessOption[]> => {
  console.log('[BusinessService] Fetching public business list...');
  try {
    // La llamada ahora usa la URL relativa
    const response = await axios.get<BusinessOption[]>(PUBLIC_BUSINESS_LIST_URL);

    console.log(`[BusinessService] Received ${response.data?.length ?? 0} businesses.`);
    return response.data || []; // Devolver array vac√≠o si la data es null/undefined

  } catch (error: any) {
    console.error('[BusinessService] Error fetching public business list:', error);
    const errorMessage = error.response?.data?.message ||
                           error.message ||
                           'Error desconocido al obtener la lista de negocios.'; // Corregido: desconocido
    // Relanzar el error para que el componente que llama lo maneje (ej: en RegisterPage)
    throw new Error(errorMessage);
  }
};

// End of file: frontend/src/services/businessService.ts


// ====== [221] frontend/src/shared/types/superadmin.types.ts ======
// frontend/src/types/superadmin.types.ts

// El tipo de dato que la API /superadmin/businesses devuelve para cada negocio
export interface SuperAdminBusiness {
    id: string;
    name: string;
    slug: string;
    isActive: boolean;
    isLoyaltyCoreActive: boolean;
    isCamareroActive: boolean;
    createdAt: string;
    monthlyPrice: string | number | null; // La API puede enviar Decimal como string
    currency: string;
    paymentStatus: 'PAID' | 'PENDING' | 'OVERDUE';
    lastPayment?: { month: number; year: number };
    pendingMonths: number;
}

// El tipo de dato para un registro de pago individual
export interface BusinessPayment {
    id: string;
    paymentDate: string;
    amountPaid: number;
    month: number;
    year: number;
    paymentMethod: string | null;
    notes: string | null;
}


// ====== [222] frontend/src/shared/types/user.types.ts ======
// frontend/src/types/customer.ts
// Version: 1.1.3 (Ensure OrderType is exported)

import React from 'react';

export enum UserRole {
    SUPER_ADMIN = 'SUPER_ADMIN',
    BUSINESS_ADMIN = 'BUSINESS_ADMIN',
    CUSTOMER_FINAL = 'CUSTOMER_FINAL',
    WAITER = 'WAITER',
    KITCHEN_STAFF = 'KITCHEN_STAFF',
    BAR_STAFF = 'BAR_STAFF'
}

export enum OrderItemStatus {
    PENDING_KDS = 'PENDING_KDS', PREPARING = 'PREPARING', READY = 'READY',
    SERVED = 'SERVED', CANCELLED = 'CANCELLED', CANCELLATION_REQUESTED = 'CANCELLATION_REQUESTED',
}

export enum OrderStatus {
    RECEIVED = 'RECEIVED', IN_PROGRESS = 'IN_PROGRESS', PARTIALLY_READY = 'PARTIALLY_READY',
    ALL_ITEMS_READY = 'ALL_ITEMS_READY', COMPLETED = 'COMPLETED', PENDING_PAYMENT = 'PENDING_PAYMENT',
    PAID = 'PAID', CANCELLED = 'CANCELLED', PAYMENT_FAILED = 'PAYMENT_FAILED',
}

// ---- A√ëADIR Y EXPORTAR OrderType SI NO EXISTE ----
export enum OrderType {
  DINE_IN = 'DINE_IN',
  TAKE_AWAY = 'TAKE_AWAY',
  DELIVERY = 'DELIVERY',
}
// ---- FIN A√ëADIR/EXPORTAR OrderType ----


export enum TierCalculationBasis {
    SPEND = 'SPEND',
    VISITS = 'VISITS',
    POINTS_EARNED = 'POINTS_EARNED'
}

export interface CustomerBusinessConfig {
    tierCalculationBasis: TierCalculationBasis | null;
}

export interface TierBenefitData {
  id: string;
  type: string;
  value: string;
  description: string | null;
  isActive?: boolean;
}

export interface TierData {
    id: string;
    name: string;
    level: number;
    minValue: number;
    isActive: boolean;
    benefits?: TierBenefitData[];
}

export interface UserData {
    id: string;
    email: string;
    name?: string | null;
    role: UserRole;
    businessId: string | null;
    isActive: boolean;
    points?: number;
    totalSpend?: number;
    totalVisits?: number;
    currentTier?: {
        id: string;
        name: string;
        benefits: TierBenefitData[];
    } | null;
    businessIsActive?: boolean;
    isLoyaltyCoreActive?: boolean;
    isCamareroActive?: boolean;
    businessName?: string | null;
    businessSlug?: string | null;
    businessLogoUrl?: string | null;
}
export interface Reward {
    id: string;
    name_es: string | null;
    name_en: string | null;
    description_es?: string | null;
    description_en?: string | null;
    pointsCost: number;
    isActive: boolean;
    businessId?: string;
    imageUrl?: string | null;
    createdAt?: string;
    updatedAt?: string;
}
export interface GrantedReward {
    id: string;
    status: string;
    assignedAt: string;
    reward: Pick<Reward, 'id' | 'name_es' | 'name_en' | 'description_es' | 'description_en' | 'imageUrl'>;
    assignedBy?: { name?: string | null; email: string; } | null;
    business?: { name: string; } | null;
}
export type DisplayReward =
    {
        isGift: false;
        id: string;
        name_es: string | null;
        name_en: string | null;
        description_es?: string | null;
        description_en?: string | null;
        pointsCost: number;
        imageUrl?: string | null;
        grantedRewardId?: undefined;
        assignedByString?: undefined;
        assignedAt?: undefined;
    } |
    {
        isGift: true;
        grantedRewardId: string;
        id: string;
        name_es: string | null;
        name_en: string | null;
        description_es?: string | null;
        description_en?: string | null;
        pointsCost: 0;
        imageUrl?: string | null;
        assignedByString: string;
        assignedAt: string;
    };

export interface UseProfileResult {
    userData: UserData | null;
    loading: boolean;
    error: string | null;
    refetch: () => Promise<void>;
    setUserData: React.Dispatch<React.SetStateAction<UserData | null>>;
}

export interface UseCustomerTierDataResult {
    allTiers: TierData[] | null;
    businessConfig: CustomerBusinessConfig | null;
    loading: boolean;
    error: string | null;
    refetch: () => Promise<void>;
}

export type ActivityType =
    | 'POINTS_EARNED_QR'
    | 'POINTS_REDEEMED_REWARD'
    | 'GIFT_REDEEMED'
    | 'POINTS_ADJUSTED_ADMIN'
    | 'POINTS_EARNED_ORDER_LC'; // Aseg√∫rate que este tambi√©n est√© si lo usas en el frontend

export interface ActivityLogItem {
  id: string;
  type: ActivityType;
  pointsChanged: number | null;
  description: string | null;
  createdAt: string;
}

export interface PaginatedActivityResponse {
  logs: ActivityLogItem[];
  totalPages: number;
  currentPage: number;
  totalItems: number;
}


// ====== [223] frontend/src/test/setup.ts ======
// filename: frontend/src/test/setup.ts
// Configuraci√≥n inicial para tests de Vitest en Frontend

// Importa los matchers de jest-dom para que est√©n disponibles globalmente en 'expect'
import '@testing-library/jest-dom';

// Aqu√≠ podr√≠as a√±adir otras configuraciones globales para tests en el futuro si fuera necesario
// (Ej: Limpiar localStorage antes de cada test, configurar mocks globales, etc.)



// ====== [224] frontend/src/theme.ts ======
// filename: frontend/src/theme.ts
// Version: 1.0.3 (Clean up comments and commented code)

import { createTheme } from '@mantine/core';

// Crear el objeto del tema
export const theme = createTheme({
  /* Aqu√≠ puedes a√±adir tus personalizaciones del tema de Mantine */

  // Color primario establecido a azul
  primaryColor: 'blue',

  // Radio de borde por defecto para componentes
  defaultRadius: 'lg', // Opciones: 'xs', 'sm', 'md', 'lg', 'xl'

  // Fuente por defecto
  fontFamily: 'Verdana, sans-serif',

  // Ejemplo de c√≥mo personalizar componentes espec√≠ficos (descomentar y ajustar si es necesario):
  /*
  components: {
    Button: {
      defaultProps: {
        // Ejemplo: hacer todos los botones un poco m√°s grandes por defecto
        // size: 'md',
      }
    }
  }
  */
});

// End of File: frontend/src/theme.ts


// ====== [225] frontend/src/vite-env.d.ts ======
/// <reference types="vite/client" />



// ====== [226] frontend/tsconfig.app.json ======
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}



// ====== [227] frontend/tsconfig.json ======
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}



// ====== [228] frontend/tsconfig.node.json ======
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}



// ====== [229] frontend/vite.config.ts ======
// filename: frontend/vite.config.ts
// Version: 1.1.3 (Use mergeConfig to combine Vite and Vitest configs)

// Importar defineConfig y mergeConfig de Vite
import { defineConfig, mergeConfig } from 'vite';
// Importar defineConfig de Vitest con un alias
import { defineConfig as defineVitestConfig } from 'vitest/config';

import react from '@vitejs/plugin-react';
import mkcert from 'vite-plugin-mkcert';

// Configuraci√≥n espec√≠fica de Vite
const viteConfig = defineConfig({
  plugins: [react(), mkcert()],
  server: {
    host: true,
    port: 5173,
    https: true,
    proxy: {
      '/api': { target: 'http://localhost:3000', changeOrigin: true },
      '/public': { target: 'http://localhost:3000', changeOrigin: true }
    }
  },
  // Aqu√≠ ir√≠an otras opciones espec√≠ficas de Vite si las tuvieras
});

// Configuraci√≥n espec√≠fica de Vitest
const vitestConfig = defineVitestConfig({
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts', // Seguimos necesitando este archivo
    css: true,
  },
  // Aqu√≠ ir√≠an otras opciones espec√≠ficas de Vitest si las tuvieras
});

// Exportar la configuraci√≥n combinada
export default mergeConfig(viteConfig, vitestConfig);

// End of File: frontend/vite.config.ts

